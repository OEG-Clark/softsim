{"home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler.__init__": [[13, 83], ["data.copy", "do_sampler.DoSampler._causal_model.identify_effect", "do_sampler.DoSampler._target_estimand.set_identifier_method", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "do_sampler.DoSampler._data.copy", "logging.getLogger", "params.items", "do_sampler.DoSampler._infer_variable_types", "do_sampler.DoSampler._data[].min", "do_sampler.DoSampler._data[].max", "setattr", "do_sampler.DoSampler._target_estimand.get_backdoor_variables", "do_sampler.DoSampler._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.set_identifier_method", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelDensitySampler._infer_variable_types", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["def", "__init__", "(", "self", ",", "data", ",", "\n", "params", "=", "None", ",", "variable_types", "=", "None", ",", "\n", "num_cores", "=", "1", ",", "causal_model", "=", "None", ",", "keep_original_treatment", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Initializes a do sampler with data and names of relevant variables.\n\n        Do sampling implements the do() operation from Pearl (2000). This is an operation is defined on a causal\n        bayesian network, an explicit implementation of which is the basis for the MCMC sampling method.\n\n        We abstract the idea behind the three-step process to allow other methods, as well. The `disrupt_causes`\n        method is the means to make treatment assignment ignorable. In the Pearlian framework, this is where we cut the\n        edges pointing into the causal state. With other methods, this will typically be by using some approach which\n        assumes conditional ignorability (e.g. weighting, or explicit conditioning with Robins G-formula.)\n\n        Next, the `make_treatment_effective` method reflects the assumption that the intervention we impose is\n        \"effective\". Most simply, we fix the causal state to some specific value. We skip this step there is no value\n        specified for the causal state, and the original values are used instead.\n\n        Finally, we sample from the resulting distribution. This can be either from a `point_sample` method, in the case\n        that the inference method doesn't support batch sampling, or the `sample` method in the case that it does. For\n        convenience, the `point_sample` method parallelizes with `multiprocessing` using the `num_cores` kwargs to set\n        the number of cores to use for parallelization.\n\n        While different methods will have their own class attributes, the `_df` method should be common to all methods.\n        This is them temporary dataset which starts as a copy of the original data, and is modified to reflect the steps\n        of the do operation. Read through the existing methods (weighting is likely the most minimal) to get an idea of\n        how this works to implement one yourself.\n\n        :param data: pandas.DataFrame containing the data\n        :param identified_estimand: dowhy.causal_identifier.IdentifiedEstimand: and estimand using a backdoor method\n        for effect identification.\n        :param treatments: list or str:  names of the treatment variables\n        :param outcomes: list or str: names of the outcome variables\n        :param variable_types: dict: A dictionary containing the variable's names and types. 'c' for continuous, 'o'\n        for ordered, 'd' for discrete, and 'u' for unordered discrete.\n        :param keep_original_treatment: bool: Whether to use `make_treatment_effective`, or to keep the original\n        treatment assignments.\n        :param params: (optional) additional method parameters\n\n        \"\"\"", "\n", "self", ".", "_data", "=", "data", ".", "copy", "(", ")", "\n", "self", ".", "_causal_model", "=", "causal_model", "\n", "self", ".", "_target_estimand", "=", "self", ".", "_causal_model", ".", "identify_effect", "(", ")", "\n", "self", ".", "_target_estimand", ".", "set_identifier_method", "(", "\"backdoor\"", ")", "\n", "self", ".", "_treatment_names", "=", "parse_state", "(", "self", ".", "_causal_model", ".", "_treatment", ")", "\n", "self", ".", "_outcome_names", "=", "parse_state", "(", "self", ".", "_causal_model", ".", "_outcome", ")", "\n", "self", ".", "_estimate", "=", "None", "\n", "self", ".", "_variable_types", "=", "variable_types", "\n", "self", ".", "num_cores", "=", "num_cores", "\n", "self", ".", "point_sampler", "=", "True", "\n", "self", ".", "sampler", "=", "None", "\n", "self", ".", "keep_original_treatment", "=", "keep_original_treatment", "\n", "\n", "if", "params", "is", "not", "None", ":", "\n", "            ", "for", "key", ",", "value", "in", "params", ".", "items", "(", ")", ":", "\n", "                ", "setattr", "(", "self", ",", "key", ",", "value", ")", "\n", "\n", "", "", "self", ".", "_df", "=", "self", ".", "_data", ".", "copy", "(", ")", "\n", "\n", "if", "not", "self", ".", "_variable_types", ":", "\n", "            ", "self", ".", "_infer_variable_types", "(", ")", "\n", "", "self", ".", "dep_type", "=", "[", "self", ".", "_variable_types", "[", "var", "]", "for", "var", "in", "self", ".", "_outcome_names", "]", "\n", "self", ".", "indep_type", "=", "[", "self", ".", "_variable_types", "[", "var", "]", "for", "var", "in", "\n", "self", ".", "_treatment_names", "+", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "]", "\n", "self", ".", "density_types", "=", "[", "self", ".", "_variable_types", "[", "var", "]", "for", "var", "in", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "]", "\n", "\n", "self", ".", "outcome_lower_support", "=", "self", ".", "_data", "[", "self", ".", "_outcome_names", "]", ".", "min", "(", ")", ".", "values", "\n", "self", ".", "outcome_upper_support", "=", "self", ".", "_data", "[", "self", ".", "_outcome_names", "]", ".", "max", "(", ")", ".", "values", "\n", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler._sample_point": [[84, 92], ["None"], "methods", ["None"], ["", "def", "_sample_point", "(", "self", ",", "x_z", ")", ":", "\n", "        ", "\"\"\"\n        OVerride this if your sampling method only allows sampling a point at a time.\n        :param : numpy.array: x_z is a numpy array containing the values of x and z in the order of the list given by\n        self._treatment_names + self._target_estimand.get_backdoor_variables()\n        :return: numpy.array:  a sampled outcome point\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler.reset": [[93, 100], ["do_sampler.DoSampler._data.copy"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        If your `DoSampler` has more attributes that the `_df` attribute, you should reset them all to their\n        initialization values by overriding this method.\n        :return:\n        \"\"\"", "\n", "self", ".", "_df", "=", "self", ".", "_data", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler.make_treatment_effective": [[101, 110], ["None"], "methods", ["None"], ["", "def", "make_treatment_effective", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        This is more likely the implementation you'd like to use, but some methods may require overriding this method\n        to make the treatment effective.\n        :param x:\n        :return:\n        \"\"\"", "\n", "if", "not", "self", ".", "keep_original_treatment", ":", "\n", "            ", "self", ".", "_df", "[", "self", ".", "_treatment_names", "]", "=", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler.disrupt_causes": [[111, 117], ["None"], "methods", ["None"], ["", "", "def", "disrupt_causes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Override this method to render treatment assignment conditionally ignorable\n        :return:\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler.point_sample": [[118, 130], ["do_sampler.DoSampler._df[].apply", "Pool", "numpy.array", "pandas.DataFrame", "Pool.map", "do_sampler.DoSampler._target_estimand.get_backdoor_variables", "do_sampler.DoSampler._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "point_sample", "(", "self", ")", ":", "\n", "            ", "if", "self", ".", "num_cores", "==", "1", ":", "\n", "                ", "sampled_outcomes", "=", "self", ".", "_df", "[", "self", ".", "_treatment_names", "+", "\n", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "]", ".", "apply", "(", "self", ".", "_sample_point", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "from", "multiprocessing", "import", "Pool", "\n", "p", "=", "Pool", "(", "self", ".", "num_cores", ")", "\n", "sampled_outcomes", "=", "np", ".", "array", "(", "p", ".", "map", "(", "self", ".", "sampler", ".", "sample_point", ",", "\n", "self", ".", "_df", "[", "self", ".", "_treatment_names", "+", "\n", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "]", ".", "values", ")", ")", "\n", "sampled_outcomes", "=", "pd", ".", "DataFrame", "(", "sampled_outcomes", ",", "columns", "=", "self", ".", "_outcome_names", ")", "\n", "", "self", ".", "_df", "[", "self", ".", "_outcome_names", "]", "=", "sampled_outcomes", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler.sample": [[131, 141], ["do_sampler.DoSampler.sampler.sample", "pandas.DataFrame", "do_sampler.DoSampler._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "sample", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        By default, this expects a sampler to be built on class initialization which contains a `sample` method.\n        Override this method if you want to use a different approach to sampling.\n        :return:\n        \"\"\"", "\n", "sampled_outcomes", "=", "self", ".", "sampler", ".", "sample", "(", "self", ".", "_df", "[", "self", ".", "_treatment_names", "+", "\n", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "]", ".", "values", ")", "\n", "sampled_outcomes", "=", "pd", ".", "DataFrame", "(", "sampled_outcomes", ",", "columns", "=", "self", ".", "_outcome_names", ")", "\n", "self", ".", "_df", "[", "self", ".", "_outcome_names", "]", "=", "sampled_outcomes", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler.do_sample": [[142, 151], ["do_sampler.DoSampler.reset", "do_sampler.DoSampler.disrupt_causes", "do_sampler.DoSampler.make_treatment_effective", "do_sampler.DoSampler.point_sample", "do_sampler.DoSampler.sample"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.reset", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.disrupt_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.make_treatment_effective", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler.point_sample", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample"], ["", "def", "do_sample", "(", "self", ",", "x", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "self", ".", "disrupt_causes", "(", ")", "\n", "self", ".", "make_treatment_effective", "(", "x", ")", "\n", "if", "self", ".", "point_sampler", ":", "\n", "            ", "self", ".", "point_sample", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "sample", "(", ")", "\n", "", "return", "self", ".", "_df", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.do_sampler.DoSampler._infer_variable_types": [[152, 154], ["NotImplementedError"], "methods", ["None"], ["", "def", "_infer_variable_types", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Variable type inference not implemented. Use the variable_types kwarg.'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.interpreter.Interpreter.__init__": [[16, 42], ["isinstance", "logging.getLogger", "isinstance", "kwargs.items", "isinstance", "setattr", "interpreter.Interpreter.logger.error"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "instance", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize an interpreter.\n\n        :param instance: An object of type CausalModel, CausalEstimate or CausalRefutation.\n\n        \"\"\"", "\n", "\n", "self", ".", "model", "=", "None", "\n", "self", ".", "estimate", "=", "None", "\n", "self", ".", "refutation", "=", "None", "\n", "\n", "if", "isinstance", "(", "instance", ",", "dowhy", ".", "causal_model", ".", "CausalModel", ")", ":", "\n", "            ", "self", ".", "model", "=", "instance", "\n", "", "elif", "isinstance", "(", "instance", ",", "dowhy", ".", "causal_estimator", ".", "CausalEstimate", ")", ":", "\n", "            ", "self", ".", "estimate", "=", "instance", "\n", "", "elif", "isinstance", "(", "instance", ",", "dowhy", ".", "causal_refuter", ".", "CausalRefutation", ")", ":", "\n", "            ", "self", ".", "refutation", "=", "instance", "\n", "", "else", ":", "\n", "            ", "self", ".", "logger", ".", "error", "(", "\"Type of object passed not supported for interpretation.\"", ")", "\n", "\n", "# Unpacking the keyword arguments", "\n", "", "if", "kwargs", "is", "not", "None", ":", "\n", "            ", "for", "key", ",", "value", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                ", "setattr", "(", "self", ",", "key", ",", "value", ")", "\n", "\n", "", "", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.interpreter.Interpreter.interpret": [[43, 49], ["None"], "methods", ["None"], ["", "def", "interpret", "(", "self", ")", ":", "\n", "        ", "\"\"\"Method that implements the functionality of an interpreter. \n\n        To be overridden by interpreter sub-classes.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.graph_learner.GraphLearner.__init__": [[8, 14], ["list"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data", ",", "library_class", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\n", "\t\t", "self", ".", "_data", "=", "data", "\n", "self", ".", "_labels", "=", "list", "(", "self", ".", "_data", ".", "columns", ")", "\n", "self", ".", "_adjacency_matrix", "=", "None", "\n", "self", ".", "_graph_dot", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.graph_learner.GraphLearner.learn_graph": [[15, 21], ["None"], "methods", ["None"], ["", "def", "learn_graph", "(", "self", ")", ":", "\n", "\t\t", "'''\n\t\tDiscover causal graph and the graph in DOT format.\n\n\t\t'''", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.__init__": [[18, 39], ["logging.getLogger", "numpy.random.seed", "causal_refuter.CausalRefuter.logger.error", "causal_refuter.CausalRefuter._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["def", "__init__", "(", "self", ",", "data", ",", "identified_estimand", ",", "estimate", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "_data", "=", "data", "\n", "self", ".", "_target_estimand", "=", "identified_estimand", "\n", "self", ".", "_estimate", "=", "estimate", "\n", "self", ".", "_treatment_name", "=", "self", ".", "_target_estimand", ".", "treatment_variable", "\n", "self", ".", "_outcome_name", "=", "self", ".", "_target_estimand", ".", "outcome_variable", "\n", "self", ".", "_random_seed", "=", "None", "\n", "\n", "if", "\"random_seed\"", "in", "kwargs", ":", "\n", "            ", "self", ".", "_random_seed", "=", "kwargs", "[", "'random_seed'", "]", "\n", "np", ".", "random", ".", "seed", "(", "self", ".", "_random_seed", ")", "\n", "\n", "", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "# Concatenate the confounders, instruments and effect modifiers", "\n", "try", ":", "\n", "            ", "self", ".", "_variables_of_interest", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "+", "self", ".", "_target_estimand", ".", "instrumental_variables", "+", "self", ".", "_estimate", ".", "params", "[", "'effect_modifiers'", "]", "\n", "", "except", "AttributeError", "as", "attr_error", ":", "\n", "            ", "self", ".", "logger", ".", "error", "(", "attr_error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.choose_variables": [[40, 96], ["causal_refuter.CausalRefuter.logger.info", "causal_refuter.CausalRefuter.logger.info", "type", "len", "causal_refuter.CausalRefuter.logger.error", "ValueError", "random.shuffle", "type", "all", "causal_refuter.CausalRefuter.logger.error", "TypeError", "all", "set", "causal_refuter.CausalRefuter.logger.error", "ValueError", "len", "causal_refuter.CausalRefuter.logger.error", "ValueError", "set", "set", "list", "type", "list", "set", "set", "set", "set"], "methods", ["None"], ["", "", "def", "choose_variables", "(", "self", ",", "required_variables", ")", ":", "\n", "        ", "'''\n            This method provides a way to choose the confounders whose values we wish to\n            modify for finding its effect on the ability of the treatment to affect the outcome.\n        '''", "\n", "\n", "invert", "=", "None", "\n", "\n", "if", "required_variables", "is", "False", ":", "\n", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"All variables required: Running bootstrap adding noise to confounders, instrumental variables and effect modifiers.\"", ")", "\n", "return", "None", "\n", "\n", "", "elif", "required_variables", "is", "True", ":", "\n", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"All variables required: Running bootstrap adding noise to confounders, instrumental variables and effect modifiers.\"", ")", "\n", "return", "self", ".", "_variables_of_interest", "\n", "\n", "", "elif", "type", "(", "required_variables", ")", "is", "int", ":", "\n", "\n", "            ", "if", "len", "(", "self", ".", "_variables_of_interest", ")", "<", "required_variables", ":", "\n", "                ", "self", ".", "logger", ".", "error", "(", "\"Too many variables passed.\\n The number of  variables is: {}.\\n The number of variables passed: {}\"", ".", "format", "(", "\n", "len", "(", "self", ".", "_variables_of_interest", ")", ",", "\n", "required_variables", ")", "\n", ")", "\n", "raise", "ValueError", "(", "\"The number of variables in the required_variables is greater than the number of confounders, instrumental variables and effect modifiers\"", ")", "\n", "", "else", ":", "\n", "# Shuffle the confounders", "\n", "                ", "random", ".", "shuffle", "(", "self", ".", "_variables_of_interest", ")", "\n", "return", "self", ".", "_variables_of_interest", "[", ":", "required_variables", "]", "\n", "\n", "", "", "elif", "type", "(", "required_variables", ")", "is", "list", ":", "\n", "\n", "# Check if all are select or deselect variables", "\n", "            ", "if", "all", "(", "variable", "[", "0", "]", "==", "'-'", "for", "variable", "in", "required_variables", ")", ":", "\n", "                ", "invert", "=", "True", "\n", "required_variables", "=", "[", "variable", "[", "1", ":", "]", "for", "variable", "in", "required_variables", "]", "\n", "", "elif", "all", "(", "variable", "[", "0", "]", "!=", "'-'", "for", "variable", "in", "required_variables", ")", ":", "\n", "                ", "invert", "=", "False", "\n", "", "else", ":", "\n", "                ", "self", ".", "logger", ".", "error", "(", "\"{} has both select and delect variables\"", ".", "format", "(", "required_variables", ")", ")", "\n", "raise", "ValueError", "(", "\"It appears that there are some select and deselect variables. Note you can either select or delect variables at a time, but not both\"", ")", "\n", "\n", "# Check if all the required_variables belong to confounders, instrumental variables or effect", "\n", "", "if", "set", "(", "required_variables", ")", "-", "set", "(", "self", ".", "_variables_of_interest", ")", "!=", "set", "(", "[", "]", ")", ":", "\n", "                ", "self", ".", "logger", ".", "error", "(", "\"{} are not confounder, instrumental variable or effect modifier\"", ".", "format", "(", "list", "(", "set", "(", "required_variables", ")", "-", "set", "(", "self", ".", "_variables_of_interest", ")", ")", ")", ")", "\n", "raise", "ValueError", "(", "\"At least one of required_variables is not a valid variable name, or it is not a confounder, instrumental variable or effect modifier\"", ")", "\n", "\n", "", "if", "invert", "is", "False", ":", "\n", "                ", "return", "required_variables", "\n", "", "elif", "invert", "is", "True", ":", "\n", "                ", "return", "list", "(", "set", "(", "self", ".", "_variables_of_interest", ")", "-", "set", "(", "required_variables", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "logger", ".", "error", "(", "\"Incorrect type: {}. Expected an int,list or bool\"", ".", "format", "(", "type", "(", "required_variables", ")", ")", ")", "\n", "raise", "TypeError", "(", "\"Expected int, list or bool. Got an unexpected datatype\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.test_significance": [[97, 170], ["len", "causal_refuter.CausalRefuter.logger.info", "causal_refuter.CausalRefuter.perform_bootstrap_test", "causal_refuter.CausalRefuter.logger.warning", "causal_refuter.CausalRefuter.perform_normal_distribution_test", "causal_refuter.CausalRefuter.logger.info", "causal_refuter.CausalRefuter.perform_bootstrap_test", "causal_refuter.CausalRefuter.logger.info", "causal_refuter.CausalRefuter.perform_normal_distribution_test", "len", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.perform_bootstrap_test", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.perform_normal_distribution_test", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.perform_bootstrap_test", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.perform_normal_distribution_test"], ["", "", "def", "test_significance", "(", "self", ",", "estimate", ",", "simulations", ",", "test_type", "=", "'auto'", ",", "significance_level", "=", "0.05", ")", ":", "\n", "        ", "\"\"\" Tests the statistical significance of the estimate obtained to the simulations produced by a refuter.\n\n        The basis behind using the sample statistics of the refuter when we are in fact testing the estimate,\n        is due to the fact that, we would ideally expect them to follow the same distribition.\n\n        For refutation tests (e.g., placebo refuters), consider the null distribution as a distribution of effect\n        estimates over multiple simulations with placebo treatment, and compute how likely the true estimate (e.g.,\n        zero for placebo test) is under the null. If the probability of true effect estimate is lower than the\n        p-value, then estimator method fails the test.\n\n        For sensitivity analysis tests (e.g., bootstrap, subset or common cause refuters), the null distribution captures\n        the distribution of effect estimates under the \"true\" dataset (e.g., with an additional confounder or different\n        sampling), and we compute the probability of the obtained estimate under this distribution. If the probability is\n        lower than the p-value, then the estimator method fails the test.\n\n        Null Hypothesis- The estimate is a part of the distribution\n        Alternative Hypothesis- The estimate does not fall in the distribution.\n\n        :param 'estimate': CausalEstimate\n            The estimate obtained from the estimator for the original data.\n        :param 'simulations': np.array\n            An array containing the result of the refuter for the simulations\n        :param 'test_type': string, default 'auto'\n            The type of test the user wishes to perform.\n        :param 'significance_level': float, default 0.05\n            The significance level for the statistical test\n\n        :returns: significance_dict: Dict\n            A Dict containing the p_value and a boolean that indicates if the result is statistically significant\n        \"\"\"", "\n", "# Initializing the p_value", "\n", "p_value", "=", "0", "\n", "\n", "if", "test_type", "==", "'auto'", ":", "\n", "            ", "num_simulations", "=", "len", "(", "simulations", ")", "\n", "if", "num_simulations", ">=", "100", ":", "# Bootstrapping", "\n", "                ", "self", ".", "logger", ".", "info", "(", "\"Making use of Bootstrap as we have more than 100 examples.\\n \\\n                Note: The greater the number of examples, the more accurate are the confidence estimates\"", ")", "\n", "\n", "# Perform Bootstrap Significance Test with the original estimate and the set of refutations", "\n", "p_value", "=", "self", ".", "perform_bootstrap_test", "(", "estimate", ",", "simulations", ")", "\n", "\n", "", "else", ":", "\n", "                ", "self", ".", "logger", ".", "warning", "(", "\"We assume a Normal Distribution as the sample has less than 100 examples.\\n \\\n                Note: The underlying distribution may not be Normal. We assume that it approaches normal with the increase in sample size.\"", ")", "\n", "\n", "# Perform Normal Tests of Significance with the original estimate and the set of refutations", "\n", "p_value", "=", "self", ".", "perform_normal_distribution_test", "(", "estimate", ",", "simulations", ")", "\n", "\n", "", "", "elif", "test_type", "==", "'bootstrap'", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"Performing Bootstrap Test with {} samples\\n \\\n            Note: The greater the number of examples, the more accurate are the confidence estimates\"", ".", "format", "(", "len", "(", "simulations", ")", ")", ")", "\n", "\n", "# Perform Bootstrap Significance Test with the original estimate and the set of refutations", "\n", "p_value", "=", "self", ".", "perform_bootstrap_test", "(", "estimate", ",", "simulations", ")", "\n", "\n", "", "elif", "test_type", "==", "'normal_test'", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"Performing Normal Test with {} samples\\n \\\n            Note: We assume that the underlying distribution is Normal.\"", ".", "format", "(", "len", "(", "simulations", ")", ")", ")", "\n", "\n", "# Perform Normal Tests of Significance with the original estimate and the set of refutations", "\n", "p_value", "=", "self", ".", "perform_normal_distribution_test", "(", "estimate", ",", "simulations", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "significance_dict", "=", "{", "\n", "\"p_value\"", ":", "p_value", ",", "\n", "\"is_statistically_significant\"", ":", "p_value", "<=", "significance_level", "\n", "}", "\n", "\n", "return", "significance_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.perform_bootstrap_test": [[171, 194], ["len", "simulations.sort", "numpy.searchsorted", "numpy.searchsorted", "int"], "methods", ["None"], ["", "def", "perform_bootstrap_test", "(", "self", ",", "estimate", ",", "simulations", ")", ":", "\n", "\n", "# Get the number of simulations", "\n", "        ", "num_simulations", "=", "len", "(", "simulations", ")", "\n", "# Sort the simulations", "\n", "simulations", ".", "sort", "(", ")", "\n", "# Obtain the median value", "\n", "median_refute_values", "=", "simulations", "[", "int", "(", "num_simulations", "/", "2", ")", "]", "\n", "\n", "# Performing a two sided test", "\n", "if", "estimate", ".", "value", ">", "median_refute_values", ":", "\n", "# np.searchsorted tells us the index if it were a part of the array", "\n", "# We select side to be left as we want to find the first value that matches", "\n", "            ", "estimate_index", "=", "np", ".", "searchsorted", "(", "simulations", ",", "estimate", ".", "value", ",", "side", "=", "\"left\"", ")", "\n", "# We subtact 1 as we are finding the value from the right tail", "\n", "p_value", "=", "1", "-", "(", "estimate_index", "/", "num_simulations", ")", "\n", "", "else", ":", "\n", "# We take the side to be right as we want to find the last index that matches", "\n", "            ", "estimate_index", "=", "np", ".", "searchsorted", "(", "simulations", ",", "estimate", ".", "value", ",", "side", "=", "\"right\"", ")", "\n", "# We get the probability with respect to the left tail.", "\n", "p_value", "=", "estimate_index", "/", "num_simulations", "\n", "\n", "", "return", "p_value", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.perform_normal_distribution_test": [[195, 210], ["numpy.mean", "numpy.std", "scipy.norm.cdf", "scipy.norm.cdf"], "methods", ["None"], ["", "def", "perform_normal_distribution_test", "(", "self", ",", "estimate", ",", "simulations", ")", ":", "\n", "# Get the mean for the simulations", "\n", "        ", "mean_refute_values", "=", "np", ".", "mean", "(", "simulations", ")", "\n", "# Get the standard deviation for the simulations", "\n", "std_dev_refute_values", "=", "np", ".", "std", "(", "simulations", ")", "\n", "# Get the Z Score [(val - mean)/ std_dev ]", "\n", "z_score", "=", "(", "estimate", ".", "value", "-", "mean_refute_values", ")", "/", "std_dev_refute_values", "\n", "\n", "\n", "if", "z_score", ">", "0", ":", "# Right Tail", "\n", "            ", "p_value", "=", "1", "-", "st", ".", "norm", ".", "cdf", "(", "z_score", ")", "\n", "", "else", ":", "# Left Tail", "\n", "            ", "p_value", "=", "st", ".", "norm", ".", "cdf", "(", "z_score", ")", "\n", "\n", "", "return", "p_value", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.refute_estimate": [[211, 213], ["None"], "methods", ["None"], ["", "def", "refute_estimate", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.__init__": [[220, 226], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "estimated_effect", ",", "new_effect", ",", "refutation_type", ")", ":", "\n", "        ", "self", ".", "estimated_effect", "=", "estimated_effect", "\n", "self", ".", "new_effect", "=", "new_effect", "\n", "self", ".", "refutation_type", "=", "refutation_type", "\n", "\n", "self", ".", "refutation_result", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_significance_test_results": [[227, 229], ["None"], "methods", ["None"], ["", "def", "add_significance_test_results", "(", "self", ",", "refutation_result", ")", ":", "\n", "        ", "self", ".", "refutation_result", "=", "refutation_result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter": [[230, 232], ["None"], "methods", ["None"], ["", "def", "add_refuter", "(", "self", ",", "refuter_instance", ")", ":", "\n", "        ", "self", ".", "refuter", "=", "refuter_instance", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.interpret": [[233, 248], ["dowhy.utils.api.parse_state", "interpreters.get_class_object", "interpreters.get_class_object.interpret", "interpreters.get_class_object."], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.interpret"], ["", "def", "interpret", "(", "self", ",", "method_name", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Interpret the refutation results.\n\n        :param method_name: Method used (string) or a list of methods. If None, then the default for the specific refuter is used.\n\n        :returns: None\n\n        \"\"\"", "\n", "if", "method_name", "is", "None", ":", "\n", "            ", "method_name", "=", "self", ".", "refuter", ".", "interpret_method", "\n", "", "method_name_arr", "=", "parse_state", "(", "method_name", ")", "\n", "import", "dowhy", ".", "interpreters", "as", "interpreters", "\n", "for", "method", "in", "method_name_arr", ":", "\n", "            ", "interpreter", "=", "interpreters", ".", "get_class_object", "(", "method", ")", "\n", "interpreter", "(", "self", ",", "**", "kwargs", ")", ".", "interpret", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.__str__": [[249, 257], ["None"], "methods", ["None"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "refutation_result", "is", "None", ":", "\n", "            ", "return", "\"{0}\\nEstimated effect:{1}\\nNew effect:{2}\\n\"", ".", "format", "(", "\n", "self", ".", "refutation_type", ",", "self", ".", "estimated_effect", ",", "self", ".", "new_effect", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "\"{0}\\nEstimated effect:{1}\\nNew effect:{2}\\np value:{3}\\n\"", ".", "format", "(", "\n", "self", ".", "refutation_type", ",", "self", ".", "estimated_effect", ",", "self", ".", "new_effect", ",", "self", ".", "refutation_result", "[", "'p_value'", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.__init__": [[28, 113], ["dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "logging.getLogger", "causal_model.CausalModel.summary", "causal_model.CausalModel.logger.warning", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "causal_model.CausalModel.init_graph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "causal_model.CausalModel._data.columns.tolist", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "causal_model.CausalModel.logger.warning", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "causal_model.CausalModel._data.columns.tolist", "causal_model.CausalModel._data.columns.tolist", "causal_model.CausalModel._data.columns.tolist"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.summary", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.init_graph"], ["def", "__init__", "(", "self", ",", "data", ",", "treatment", ",", "outcome", ",", "graph", "=", "None", ",", "\n", "common_causes", "=", "None", ",", "instruments", "=", "None", ",", "\n", "effect_modifiers", "=", "None", ",", "\n", "estimand_type", "=", "\"nonparametric-ate\"", ",", "\n", "proceed_when_unidentifiable", "=", "False", ",", "\n", "missing_nodes_as_confounders", "=", "False", ",", "\n", "identify_vars", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize data and create a causal graph instance.\n\n        Assigns treatment and outcome variables.\n        Also checks and finds the common causes and instruments for treatment\n        and outcome.\n\n        At least one of graph, common_causes or instruments must be provided. If\n        none of these variables are provided, then learn_graph() can be used later.\n\n        :param data: a pandas dataframe containing treatment, outcome and other\n        variables.\n        :param treatment: name of the treatment variable\n        :param outcome: name of the outcome variable\n        :param graph: path to DOT file containing a DAG or a string containing\n        a DAG specification in DOT format\n        :param common_causes: names of common causes of treatment and _outcome. Only used when graph is None.\n        :param instruments: names of instrumental variables for the effect of\n        treatment on outcome. Only used when graph is None.\n        :param effect_modifiers: names of variables that can modify the treatment effect. If not provided, then the causal graph is used to find the effect modifiers. Estimators will return multiple different estimates based on each value of effect_modifiers.\n        :param estimand_type: the type of estimand requested (currently only \"nonparametric-ate\" is supported). In the future, may support other specific parametric forms of identification.\n        :param proceed_when_unidentifiable: does the identification proceed by ignoring potential unobserved confounders. Binary flag.\n        :param missing_nodes_as_confounders: Binary flag indicating whether variables in the dataframe that are not included in the causal graph, should be  automatically included as confounder nodes.\n        :param identify_vars: Variable deciding whether to compute common causes, instruments and effect modifiers while initializing the class. identify_vars should be set to False when user is providing common_causes, instruments or effect modifiers on their own(otherwise the identify_vars code can override the user provided values). Also it does not make sense if no graph is given.\n        :returns: an instance of CausalModel class\n\n        \"\"\"", "\n", "self", ".", "_data", "=", "data", "\n", "self", ".", "_treatment", "=", "parse_state", "(", "treatment", ")", "\n", "self", ".", "_outcome", "=", "parse_state", "(", "outcome", ")", "\n", "self", ".", "_effect_modifiers", "=", "parse_state", "(", "effect_modifiers", ")", "\n", "self", ".", "_estimand_type", "=", "estimand_type", "\n", "self", ".", "_proceed_when_unidentifiable", "=", "proceed_when_unidentifiable", "\n", "self", ".", "_missing_nodes_as_confounders", "=", "missing_nodes_as_confounders", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "if", "graph", "is", "None", ":", "\n", "            ", "self", ".", "logger", ".", "warning", "(", "\"Causal Graph not provided. DoWhy will construct a graph based on data inputs.\"", ")", "\n", "self", ".", "_common_causes", "=", "parse_state", "(", "common_causes", ")", "\n", "self", ".", "_instruments", "=", "parse_state", "(", "instruments", ")", "\n", "if", "common_causes", "is", "not", "None", "and", "instruments", "is", "not", "None", ":", "\n", "                ", "self", ".", "_graph", "=", "CausalGraph", "(", "\n", "self", ".", "_treatment", ",", "\n", "self", ".", "_outcome", ",", "\n", "common_cause_names", "=", "self", ".", "_common_causes", ",", "\n", "instrument_names", "=", "self", ".", "_instruments", ",", "\n", "effect_modifier_names", "=", "self", ".", "_effect_modifiers", ",", "\n", "observed_node_names", "=", "self", ".", "_data", ".", "columns", ".", "tolist", "(", ")", "\n", ")", "\n", "", "elif", "common_causes", "is", "not", "None", ":", "\n", "                ", "self", ".", "_graph", "=", "CausalGraph", "(", "\n", "self", ".", "_treatment", ",", "\n", "self", ".", "_outcome", ",", "\n", "common_cause_names", "=", "self", ".", "_common_causes", ",", "\n", "effect_modifier_names", "=", "self", ".", "_effect_modifiers", ",", "\n", "observed_node_names", "=", "self", ".", "_data", ".", "columns", ".", "tolist", "(", ")", "\n", ")", "\n", "", "elif", "instruments", "is", "not", "None", ":", "\n", "                ", "self", ".", "_graph", "=", "CausalGraph", "(", "\n", "self", ".", "_treatment", ",", "\n", "self", ".", "_outcome", ",", "\n", "instrument_names", "=", "self", ".", "_instruments", ",", "\n", "effect_modifier_names", "=", "self", ".", "_effect_modifiers", ",", "\n", "observed_node_names", "=", "self", ".", "_data", ".", "columns", ".", "tolist", "(", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "logger", ".", "warning", "(", "\"Relevant variables to build causal graph not provided. You may want to use the learn_graph() function to construct the causal graph.\"", ")", "\n", "self", ".", "_graph", "=", "CausalGraph", "(", "\n", "self", ".", "_treatment", ",", "\n", "self", ".", "_outcome", ",", "\n", "effect_modifier_names", "=", "self", ".", "_effect_modifiers", ",", "\n", "observed_node_names", "=", "self", ".", "_data", ".", "columns", ".", "tolist", "(", ")", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "init_graph", "(", "graph", "=", "graph", ",", "identify_vars", "=", "identify_vars", ")", "\n", "\n", "", "self", ".", "_other_variables", "=", "kwargs", "\n", "self", ".", "summary", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.init_graph": [[114, 139], ["dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "dowhy.causal_graph.CausalGraph", "causal_model.CausalModel._graph.get_common_causes", "causal_model.CausalModel._graph.get_instruments", "causal_model.CausalModel._data.columns.tolist", "causal_model.CausalModel._graph.get_effect_modifiers"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_instruments", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_effect_modifiers"], ["", "def", "init_graph", "(", "self", ",", "graph", ",", "identify_vars", ")", ":", "\n", "        ", "'''\n        Initialize self._graph using graph provided by the user.\n\n        '''", "\n", "# Create causal graph object", "\n", "self", ".", "_graph", "=", "CausalGraph", "(", "\n", "self", ".", "_treatment", ",", "\n", "self", ".", "_outcome", ",", "\n", "graph", ",", "\n", "effect_modifier_names", "=", "self", ".", "_effect_modifiers", ",", "\n", "observed_node_names", "=", "self", ".", "_data", ".", "columns", ".", "tolist", "(", ")", ",", "\n", "missing_nodes_as_confounders", "=", "self", ".", "_missing_nodes_as_confounders", "\n", ")", "\n", "\n", "if", "identify_vars", ":", "\n", "            ", "self", ".", "_common_causes", "=", "self", ".", "_graph", ".", "get_common_causes", "(", "self", ".", "_treatment", ",", "self", ".", "_outcome", ")", "\n", "self", ".", "_instruments", "=", "self", ".", "_graph", ".", "get_instruments", "(", "self", ".", "_treatment", ",", "\n", "self", ".", "_outcome", ")", "\n", "# Sometimes, effect modifiers from the graph may not match those provided by the user.", "\n", "# (Because some effect modifiers may also be common causes)", "\n", "# In such cases, the user-provided modifiers are used.", "\n", "# If no effect modifiers are provided,  then the ones from the graph are used.", "\n", "if", "self", ".", "_effect_modifiers", "is", "None", "or", "not", "self", ".", "_effect_modifiers", ":", "\n", "                ", "self", ".", "_effect_modifiers", "=", "self", ".", "_graph", ".", "get_effect_modifiers", "(", "self", ".", "_treatment", ",", "self", ".", "_outcome", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.get_common_causes": [[140, 143], ["causal_model.CausalModel._graph.get_common_causes"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes"], ["", "", "", "def", "get_common_causes", "(", "self", ")", ":", "\n", "        ", "self", ".", "_common_causes", "=", "self", ".", "_graph", ".", "get_common_causes", "(", "self", ".", "_treatment", ",", "self", ".", "_outcome", ")", "\n", "return", "self", ".", "_common_causes", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.get_instruments": [[144, 147], ["causal_model.CausalModel._graph.get_instruments"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_instruments"], ["", "def", "get_instruments", "(", "self", ")", ":", "\n", "        ", "self", ".", "_instruments", "=", "self", ".", "_graph", ".", "get_instruments", "(", "self", ".", "_treatment", ",", "self", ".", "_outcome", ")", "\n", "return", "self", ".", "_instruments", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.get_effect_modifiers": [[148, 151], ["causal_model.CausalModel._graph.get_effect_modifiers"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_effect_modifiers"], ["", "def", "get_effect_modifiers", "(", "self", ")", ":", "\n", "        ", "self", ".", "_effect_modifiers", "=", "self", ".", "_graph", ".", "get_effect_modifiers", "(", "self", ".", "_treatment", ",", "self", ".", "_outcome", ")", "\n", "return", "self", ".", "_effect_modifiers", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.learn_graph": [[152, 173], ["method_name.split", "dowhy.get_discovery_class_object", "dowhy.get_discovery_class_object", "dowhy.get_discovery_class_object", "dowhy.get_discovery_class_object", "dowhy.get_discovery_class_object.", "graph_learners.get_discovery_class_object.learn_graph", "causal_model.CausalModel.init_graph"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.__init__.get_discovery_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.__init__.get_discovery_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.__init__.get_discovery_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.__init__.get_discovery_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.lingam.LINGAM.learn_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.init_graph"], ["", "def", "learn_graph", "(", "self", ",", "method_name", "=", "\"cdt.causality.graph.LiNGAM\"", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''\n        Learn causal graph from the data. This function takes the method name as input and initializes the\n        causal graph object using the learnt graph.\n\n        :param self: instance of the CausalModel class (or its subclass)\n        :param method_name: Exact method name of the object to be imported from the concerned library.\n        :returns: an instance of the CausalGraph class initialized with the learned graph.\n        '''", "\n", "# Import causal discovery class", "\n", "str_arr", "=", "method_name", ".", "split", "(", "\".\"", ",", "maxsplit", "=", "1", ")", "\n", "library_name", "=", "str_arr", "[", "0", "]", "\n", "causal_discovery_class", "=", "graph_learners", ".", "get_discovery_class_object", "(", "library_name", ")", "\n", "\n", "model", "=", "causal_discovery_class", "(", "self", ".", "_data", ",", "method_name", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "graph", "=", "model", ".", "learn_graph", "(", ")", "\n", "\n", "# Initialize causal graph object", "\n", "self", ".", "init_graph", "(", "graph", "=", "graph", ")", "\n", "\n", "return", "self", ".", "_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.identify_effect": [[174, 202], ["dowhy.causal_identifiers.id_identifier.IDIdentifier", "dowhy.causal_identifiers.id_identifier.IDIdentifier", "dowhy.causal_identifiers.id_identifier.IDIdentifier", "dowhy.causal_identifiers.id_identifier.IDIdentifier", "causal_model.CausalModel.identifier.identify_effect", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifier.CausalIdentifier", "causal_model.CausalModel.identifier.identify_effect"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect"], ["", "def", "identify_effect", "(", "self", ",", "estimand_type", "=", "None", ",", "\n", "method_name", "=", "\"default\"", ",", "proceed_when_unidentifiable", "=", "None", ",", "optimize_backdoor", "=", "False", ")", ":", "\n", "        ", "\"\"\"Identify the causal effect to be estimated, using properties of the causal graph.\n\n        :param method_name: Method name for identification algorithm. (\"id-algorithm\" or \"default\")\n        :param proceed_when_unidentifiable: Binary flag indicating whether identification should proceed in the presence of (potential) unobserved confounders.\n        :returns: a probability expression (estimand) for the causal effect if identified, else NULL\n\n        \"\"\"", "\n", "if", "proceed_when_unidentifiable", "is", "None", ":", "\n", "            ", "proceed_when_unidentifiable", "=", "self", ".", "_proceed_when_unidentifiable", "\n", "", "if", "estimand_type", "is", "None", ":", "\n", "            ", "estimand_type", "=", "self", ".", "_estimand_type", "\n", "\n", "", "if", "method_name", "==", "\"id-algorithm\"", ":", "\n", "            ", "self", ".", "identifier", "=", "IDIdentifier", "(", "self", ".", "_graph", ",", "\n", "estimand_type", ",", "\n", "method_name", ",", "\n", "proceed_when_unidentifiable", "=", "proceed_when_unidentifiable", ")", "\n", "identified_estimand", "=", "self", ".", "identifier", ".", "identify_effect", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "identifier", "=", "CausalIdentifier", "(", "self", ".", "_graph", ",", "\n", "estimand_type", ",", "\n", "method_name", ",", "\n", "proceed_when_unidentifiable", "=", "proceed_when_unidentifiable", ")", "\n", "identified_estimand", "=", "self", ".", "identifier", ".", "identify_effect", "(", "optimize_backdoor", "=", "optimize_backdoor", ")", "\n", "\n", "", "return", "identified_estimand", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.estimate_effect": [[203, 331], ["len", "method_name.split", "identified_estimand.set_identifier_method", "causal_model.CausalModel.logger.warning", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "causal_model.CausalModel.get_effect_modifiers", "method_name.split", "print", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "causal_model.CausalModel.logger.error", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "causal_model.CausalModel.causal_estimator.estimate_effect", "causal_model.CausalModel.add_params", "len", "estimator_name.split", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object.", "causal_model.CausalModel.causal_estimator.update_input", "estimator_name.split", "method_params.get"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.set_identifier_method", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_effect_modifiers", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.add_params", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.update_input"], ["", "def", "estimate_effect", "(", "self", ",", "identified_estimand", ",", "method_name", "=", "None", ",", "\n", "control_value", "=", "0", ",", "\n", "treatment_value", "=", "1", ",", "\n", "test_significance", "=", "None", ",", "evaluate_effect_strength", "=", "False", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "target_units", "=", "\"ate\"", ",", "effect_modifiers", "=", "None", ",", "\n", "fit_estimator", "=", "True", ",", "\n", "method_params", "=", "None", ")", ":", "\n", "        ", "\"\"\"Estimate the identified causal effect.\n\n        Currently requires an explicit method name to be specified. Method names follow the convention of identification method followed by the specific estimation method: \"[backdoor/iv].estimation_method_name\". Following methods are supported.\n            * Propensity Score Matching: \"backdoor.propensity_score_matching\"\n            * Propensity Score Stratification: \"backdoor.propensity_score_stratification\"\n            * Propensity Score-based Inverse Weighting: \"backdoor.propensity_score_weighting\"\n            * Linear Regression: \"backdoor.linear_regression\"\n            * Generalized Linear Models (e.g., logistic regression): \"backdoor.generalized_linear_model\"\n            * Instrumental Variables: \"iv.instrumental_variable\"\n            * Regression Discontinuity: \"iv.regression_discontinuity\"\n\n        In addition, you can directly call any of the EconML estimation methods. The convention is \"backdoor.econml.path-to-estimator-class\". For example, for the double machine learning estimator (\"DML\" class) that is located inside \"dml\" module of EconML, you can use the method name, \"backdoor.econml.dml.DML\". CausalML estimators can also be called. See `this demo notebook <https://py-why.github.io/dowhy/example_notebooks/dowhy-conditional-treatment-effects.html>`_.\n\n\n        :param identified_estimand: a probability expression\n            that represents the effect to be estimated. Output of\n            CausalModel.identify_effect method\n        :param method_name: name of the estimation method to be used.\n        :param control_value: Value of the treatment in the control group, for effect estimation.  If treatment is multi-variate, this can be a list.\n        :param treatment_value: Value of the treatment in the treated group, for effect estimation. If treatment is multi-variate, this can be a list.\n        :param test_significance: Binary flag on whether to additionally do a statistical signficance test for the estimate.\n        :param evaluate_effect_strength: (Experimental) Binary flag on whether to estimate the relative strength of the treatment's effect. This measure can be used to compare different treatments for the same outcome (by running this method with different treatments sequentially).\n        :param confidence_intervals: (Experimental) Binary flag indicating whether confidence intervals should be computed.\n        :param target_units: (Experimental) The units for which the treatment effect should be estimated. This can be of three types. (1) a string for common specifications of target units (namely, \"ate\", \"att\" and \"atc\"), (2) a lambda function that can be used as an index for the data (pandas DataFrame), or (3) a new DataFrame that contains values of the effect_modifiers and effect will be estimated only for this new data.\n        :param effect_modifiers: Names of effect modifier variables can be (optionally) specified here too, since they do not affect identification. If None, the effect_modifiers from the CausalModel are used.\n        :param fit_estimator: Boolean flag on whether to fit the estimator.\n            Setting it to False is useful to estimate the effect on new data using a previously fitted estimator.\n        :param method_params: Dictionary containing any method-specific parameters. These are passed directly to the estimating method. See the docs for each estimation method for allowed method-specific params.\n        :returns: An instance of the CausalEstimate class, containing the causal effect estimate\n            and other method-dependent information\n\n        \"\"\"", "\n", "if", "effect_modifiers", "is", "None", ":", "\n", "            ", "if", "self", ".", "_effect_modifiers", "is", "None", "or", "len", "(", "self", ".", "_effect_modifiers", ")", "==", "0", ":", "\n", "                ", "effect_modifiers", "=", "self", ".", "get_effect_modifiers", "(", ")", "\n", "", "else", ":", "\n", "                ", "effect_modifiers", "=", "self", ".", "_effect_modifiers", "\n", "\n", "", "", "if", "method_name", "is", "None", ":", "\n", "#TODO add propensity score as default backdoor method, iv as default iv method, add an informational message to show which method has been selected.", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "# TODO add dowhy as a prefix to all dowhy estimators", "\n", "            ", "num_components", "=", "len", "(", "method_name", ".", "split", "(", "\".\"", ")", ")", "\n", "str_arr", "=", "method_name", ".", "split", "(", "\".\"", ",", "maxsplit", "=", "1", ")", "\n", "identifier_name", "=", "str_arr", "[", "0", "]", "\n", "estimator_name", "=", "str_arr", "[", "1", "]", "\n", "identified_estimand", ".", "set_identifier_method", "(", "identifier_name", ")", "\n", "# This is done as all dowhy estimators have two parts and external ones have two or more parts", "\n", "if", "num_components", ">", "2", ":", "\n", "                ", "estimator_package", "=", "estimator_name", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "if", "estimator_package", "==", "'dowhy'", ":", "# For updated dowhy methods", "\n", "                    ", "estimator_method", "=", "estimator_name", ".", "split", "(", "\".\"", ",", "maxsplit", "=", "1", ")", "[", "1", "]", "# discard dowhy from the full package name", "\n", "causal_estimator_class", "=", "causal_estimators", ".", "get_class_object", "(", "estimator_method", "+", "\"_estimator\"", ")", "\n", "", "else", ":", "\n", "                    ", "third_party_estimator_package", "=", "estimator_package", "\n", "causal_estimator_class", "=", "causal_estimators", ".", "get_class_object", "(", "third_party_estimator_package", ",", "estimator_name", ")", "\n", "if", "method_params", "is", "None", ":", "\n", "                        ", "method_params", "=", "{", "}", "\n", "# Define the third-party estimation method to be used", "\n", "", "method_params", "[", "third_party_estimator_package", "+", "\"_methodname\"", "]", "=", "estimator_name", "\n", "", "", "else", ":", "# For older dowhy methods", "\n", "                ", "print", "(", "estimator_name", ")", "\n", "# Process the dowhy estimators", "\n", "causal_estimator_class", "=", "causal_estimators", ".", "get_class_object", "(", "estimator_name", "+", "\"_estimator\"", ")", "\n", "", "", "if", "identified_estimand", ".", "no_directed_path", ":", "\n", "            ", "self", ".", "logger", ".", "warning", "(", "\"No directed path from {0} to {1}.\"", ".", "format", "(", "\n", "self", ".", "_treatment", ",", "\n", "self", ".", "_outcome", ")", ")", "\n", "estimate", "=", "CausalEstimate", "(", "0", ",", "identified_estimand", ",", "None", ",", "\n", "control_value", "=", "control_value", ",", "\n", "treatment_value", "=", "treatment_value", ")", "\n", "# Check if estimator's target estimand is identified", "\n", "", "elif", "identified_estimand", ".", "estimands", "[", "identifier_name", "]", "is", "None", ":", "\n", "            ", "self", ".", "logger", ".", "error", "(", "\"No valid identified estimand available.\"", ")", "\n", "estimate", "=", "CausalEstimate", "(", "None", ",", "None", ",", "None", ",", "\n", "control_value", "=", "control_value", ",", "\n", "treatment_value", "=", "treatment_value", ")", "\n", "", "else", ":", "\n", "            ", "if", "fit_estimator", ":", "\n", "                ", "if", "method_params", "is", "not", "None", "and", "(", "num_components", "<=", "2", "or", "estimator_package", "==", "'dowhy'", ")", ":", "\n", "                    ", "extra_args", "=", "method_params", ".", "get", "(", "\"init_params\"", ",", "{", "}", ")", "\n", "", "else", ":", "\n", "                    ", "extra_args", "=", "{", "}", "\n", "", "if", "method_params", "is", "None", ":", "\n", "                    ", "method_params", "=", "{", "}", "\n", "", "self", ".", "causal_estimator", "=", "causal_estimator_class", "(", "\n", "self", ".", "_data", ",", "\n", "identified_estimand", ",", "\n", "self", ".", "_treatment", ",", "self", ".", "_outcome", ",", "#names of treatment and outcome", "\n", "control_value", "=", "control_value", ",", "\n", "treatment_value", "=", "treatment_value", ",", "\n", "test_significance", "=", "test_significance", ",", "\n", "evaluate_effect_strength", "=", "evaluate_effect_strength", ",", "\n", "confidence_intervals", "=", "confidence_intervals", ",", "\n", "target_units", "=", "target_units", ",", "\n", "effect_modifiers", "=", "effect_modifiers", ",", "\n", "**", "method_params", ",", "\n", "**", "extra_args", ")", "\n", "", "else", ":", "\n", "# Estimator had been computed in a previous call", "\n", "                ", "assert", "self", ".", "causal_estimator", "is", "not", "None", "\n", "self", ".", "causal_estimator", ".", "update_input", "(", "treatment_value", ",", "control_value", ",", "\n", "target_units", ")", "\n", "\n", "", "estimate", "=", "self", ".", "causal_estimator", ".", "estimate_effect", "(", ")", "\n", "# Store parameters inside estimate object for refutation methods", "\n", "# TODO: This add_params needs to move to the estimator class", "\n", "# inside estimate_effect and estimate_conditional_effect", "\n", "estimate", ".", "add_params", "(", "\n", "estimand_type", "=", "identified_estimand", ".", "estimand_type", ",", "\n", "estimator_class", "=", "causal_estimator_class", ",", "\n", "test_significance", "=", "test_significance", ",", "\n", "evaluate_effect_strength", "=", "evaluate_effect_strength", ",", "\n", "confidence_intervals", "=", "confidence_intervals", ",", "\n", "target_units", "=", "target_units", ",", "\n", "effect_modifiers", "=", "effect_modifiers", ",", "\n", "method_params", "=", "method_params", "\n", ")", "\n", "", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.do": [[332, 388], ["method_name.split", "identified_estimand.set_identifier_method", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "causal_model.CausalModel.logger.warning", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_estimator.CausalEstimate", "dowhy.get_class_object.", "causal_model.CausalModel.causal_estimator.do", "causal_model.CausalModel.logger.error"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.set_identifier_method", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do"], ["", "def", "do", "(", "self", ",", "x", ",", "identified_estimand", ",", "method_name", "=", "None", ",", "\n", "fit_estimator", "=", "True", ",", "method_params", "=", "None", ")", ":", "\n", "        ", "\"\"\"Do operator for estimating values of the outcome after intervening on treatment.\n\n        :param x: interventional value of the treatment variable\n        :param identified_estimand: a probability expression\n            that represents the effect to be estimated. Output of\n            CausalModel.identify_effect method\n        :param method_name: any of the estimation method to be used. See docs\n            for estimate_effect method for a list of supported estimation methods.\n        :param fit_estimator: Boolean flag on whether to fit the estimator.\n            Setting it to False is useful to compute the do-operation on new\n            data using a previously fitted estimator.\n        :param method_params: Dictionary containing any method-specific parameters. These are passed directly to the estimating method.\n\n        :returns: an instance of the CausalEstimate class, containing the causal effect estimate\n            and other method-dependent information\n\n        \"\"\"", "\n", "if", "method_name", "is", "None", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "str_arr", "=", "method_name", ".", "split", "(", "\".\"", ",", "maxsplit", "=", "1", ")", "\n", "identifier_name", "=", "str_arr", "[", "0", "]", "\n", "estimator_name", "=", "str_arr", "[", "1", "]", "\n", "identified_estimand", ".", "set_identifier_method", "(", "identifier_name", ")", "\n", "causal_estimator_class", "=", "causal_estimators", ".", "get_class_object", "(", "estimator_name", "+", "\"_estimator\"", ")", "\n", "\n", "# Check if estimator's target estimand is identified", "\n", "", "if", "identified_estimand", ".", "estimands", "[", "identifier_name", "]", "is", "None", ":", "\n", "            ", "self", ".", "logger", ".", "warning", "(", "\"No valid identified estimand for using instrumental variables method\"", ")", "\n", "estimate", "=", "CausalEstimate", "(", "None", ",", "None", ",", "None", ",", "None", ",", "None", ")", "\n", "", "else", ":", "\n", "            ", "if", "fit_estimator", ":", "\n", "# Note that while the name of the variable is the same,", "\n", "# \"self.causal_estimator\", this estimator takes in less", "\n", "# parameters than the same from the", "\n", "# estimate_effect code. It is not advisable to use the", "\n", "# estimator from this function to call estimate_effect", "\n", "# with fit_estimator=False.", "\n", "                ", "self", ".", "causal_estimator", "=", "causal_estimator_class", "(", "\n", "self", ".", "_data", ",", "\n", "identified_estimand", ",", "\n", "self", ".", "_treatment", ",", "self", ".", "_outcome", ",", "\n", "test_significance", "=", "False", ",", "\n", "**", "method_params", "\n", ")", "\n", "", "else", ":", "\n", "# Estimator had been computed in a previous call", "\n", "                ", "assert", "self", ".", "causal_estimator", "is", "not", "None", "\n", "", "try", ":", "\n", "                ", "estimate", "=", "self", ".", "causal_estimator", ".", "do", "(", "x", ")", "\n", "", "except", "NotImplementedError", ":", "\n", "                ", "self", ".", "logger", ".", "error", "(", "'Do Operation not implemented or not supported for this estimator.'", ")", "\n", "raise", "NotImplementedError", "\n", "", "", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.refute_estimate": [[389, 422], ["dowhy.get_class_object.", "causal_refuters.get_class_object.refute_estimate", "causal_model.CausalModel.logger.error", "ValueError", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object", "dowhy.get_class_object"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object"], ["", "def", "refute_estimate", "(", "self", ",", "estimand", ",", "estimate", ",", "method_name", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Refute an estimated causal effect.\n\n        If method_name is provided, uses the provided method. In the future, we may support automatic selection of suitable refutation tests. Following refutation methods are supported.\n            * Adding a randomly-generated confounder: \"random_common_cause\"\n            * Adding a confounder that is associated with both treatment and outcome: \"add_unobserved_common_cause\"\n            * Replacing the treatment with a placebo (random) variable): \"placebo_treatment_refuter\"\n            * Removing a random subset of the data: \"data_subset_refuter\"\n\n        :param estimand: target estimand, an instance of the IdentifiedEstimand class (typically, the output of identify_effect)\n        :param estimate: estimate to be refuted, an instance of the CausalEstimate class (typically, the output of estimate_effect)\n        :param method_name: name of the refutation method\n        :param kwargs:  (optional) additional arguments that are passed directly to the refutation method. Can specify a random seed here to ensure reproducible results ('random_seed' parameter). For method-specific parameters, consult the documentation for the specific method. All refutation methods are in the causal_refuters subpackage.\n\n        :returns: an instance of the RefuteResult class\n\n        \"\"\"", "\n", "if", "estimate", "is", "None", "or", "estimate", ".", "value", "is", "None", ":", "\n", "            ", "self", ".", "logger", ".", "error", "(", "\"Aborting refutation! No estimate is provided.\"", ")", "\n", "raise", "ValueError", "(", "\"Aborting refutation! No valid estimate is provided.\"", ")", "\n", "", "if", "method_name", "is", "None", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "refuter_class", "=", "causal_refuters", ".", "get_class_object", "(", "method_name", ")", "\n", "\n", "", "refuter", "=", "refuter_class", "(", "\n", "self", ".", "_data", ",", "\n", "identified_estimand", "=", "estimand", ",", "\n", "estimate", "=", "estimate", ",", "\n", "**", "kwargs", "\n", ")", "\n", "res", "=", "refuter", ".", "refute_estimate", "(", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.view_model": [[423, 434], ["causal_model.CausalModel._graph.view_graph"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.view_graph"], ["", "def", "view_model", "(", "self", ",", "layout", "=", "\"dot\"", ",", "size", "=", "(", "8", ",", "6", ")", ",", "file_name", "=", "\"causal_model\"", ")", ":", "\n", "        ", "\"\"\"View the causal DAG.\n\n        :param layout: string specifying the layout of the graph.\n        :param size: tuple (x, y) specifying the width and height of the figure in inches.\n        :param file_name: string specifying the file name for the saved causal graph png.\n\n        :returns: a visualization of the graph\n\n        \"\"\"", "\n", "self", ".", "_graph", ".", "view_graph", "(", "layout", ",", "size", ",", "file_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.interpret": [[435, 455], ["dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "causal_model.CausalModel.summary", "causal_model.CausalModel.view_model", "interpreters.get_class_object", "interpreters.get_class_object.interpret", "interpreters.get_class_object."], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.summary", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.view_model", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.interpret"], ["", "def", "interpret", "(", "self", ",", "method_name", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Interpret the causal model.\n\n        :param method_name: method used for interpreting the model. If None,\n                            then default interpreter is chosen that describes the model summary and shows the associated causal graph.\n        :param kwargs:: Optional parameters that are directly passed to the interpreter method.\n\n        :returns: None\n\n        \"\"\"", "\n", "if", "method_name", "is", "None", ":", "\n", "            ", "self", ".", "summary", "(", "print_to_stdout", "=", "True", ")", "\n", "self", ".", "view_model", "(", ")", "\n", "return", "\n", "\n", "", "method_name_arr", "=", "parse_state", "(", "method_name", ")", "\n", "import", "dowhy", ".", "interpreters", "as", "interpreters", "\n", "for", "method", "in", "method_name_arr", ":", "\n", "            ", "interpreter", "=", "interpreters", ".", "get_class_object", "(", "method", ")", "\n", "interpreter", "(", "self", ",", "**", "kwargs", ")", ".", "interpret", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.summary": [[456, 467], ["causal_model.CausalModel.logger.info", "print"], "methods", ["None"], ["", "", "def", "summary", "(", "self", ",", "print_to_stdout", "=", "False", ")", ":", "\n", "        ", "\"\"\"Print a text summary of the model.\n\n        :returns: a string containining the summary\n\n        \"\"\"", "\n", "summary_text", "=", "\"Model to find the causal effect of treatment {0} on outcome {1}\"", ".", "format", "(", "self", ".", "_treatment", ",", "self", ".", "_outcome", ")", "\n", "self", ".", "logger", ".", "info", "(", "summary_text", ")", "\n", "if", "print_to_stdout", ":", "\n", "            ", "print", "(", "summary_text", ")", "\n", "", "return", "summary_text", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.refute_graph": [[468, 519], ["dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model", "dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model", "dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model", "dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model", "causal_model.CausalModel.logger.info", "dowhy.causal_refuters.graph_refuter.GraphRefuter", "dowhy.causal_refuters.graph_refuter.GraphRefuter", "dowhy.causal_refuters.graph_refuter.GraphRefuter", "dowhy.causal_refuters.graph_refuter.GraphRefuter", "dowhy.causal_refuters.graph_refuter.GraphRefuter", "dowhy.causal_refuters.graph_refuter.GraphRefuter", "dowhy.causal_refuters.graph_refuter.GraphRefuter", "dowhy.causal_refuters.graph_refuter.GraphRefuter", "list", "len", "list", "list", "causal_model.CausalModel.logger.info", "causal_model.CausalModel._graph.get_all_nodes", "range", "itertools.combinations", "list", "itertools.combinations", "causal_model.CausalModel._graph.check_dseparation", "causal_model.CausalModel.logger.info", "conditional_independences.append", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_dseparation"], ["", "def", "refute_graph", "(", "self", ",", "k", "=", "1", ",", "independence_test", "=", "None", ",", "independence_constraints", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Check if the dependencies in input graph matches with the dataset -\n        ( X \u2aeb Y ) | Z\n        where X and Y are considered as singleton sets currently\n        Z can have multiple variables\n        :param k: number of covariates in set Z\n        :param independence_test: dictionary containing methods to test conditional independece in data\n        :param independence_constraints: list of implications to be test input by the user in the format\n            [(x,y,(z1,z2)),\n            (x,y, (z3,))\n            ]\n        : returns: an instance of GraphRefuter class\n        \"\"\"", "\n", "if", "independence_test", "is", "not", "None", ":", "\n", "            ", "test_for_continuous", "=", "independence_test", "[", "'test_for_continuous'", "]", "\n", "test_for_discrete", "=", "independence_test", "[", "'test_for_discrete'", "]", "\n", "refuter", "=", "GraphRefuter", "(", "data", "=", "self", ".", "_data", ",", "method_name_continuous", "=", "test_for_continuous", ",", "method_name_discrete", "=", "test_for_discrete", ")", "\n", "\n", "", "else", ":", "\n", "            ", "refuter", "=", "GraphRefuter", "(", "data", "=", "self", ".", "_data", ")", "\n", "\n", "", "if", "independence_constraints", "is", "None", ":", "\n", "            ", "all_nodes", "=", "list", "(", "self", ".", "_graph", ".", "get_all_nodes", "(", "include_unobserved", "=", "False", ")", ")", "\n", "num_nodes", "=", "len", "(", "all_nodes", ")", "\n", "array_indices", "=", "list", "(", "range", "(", "0", ",", "num_nodes", ")", ")", "\n", "all_possible_combinations", "=", "list", "(", "combinations", "(", "array_indices", ",", "2", ")", ")", "#Generating sets of indices of size 2 for different x and y", "\n", "conditional_independences", "=", "[", "]", "\n", "self", ".", "logger", ".", "info", "(", "\"The followed conditional independences are true for the input graph\"", ")", "\n", "for", "combination", "in", "all_possible_combinations", ":", "#Iterate over the unique 2-sized sets [x,y]", "\n", "                ", "i", "=", "combination", "[", "0", "]", "\n", "j", "=", "combination", "[", "1", "]", "\n", "a", "=", "all_nodes", "[", "i", "]", "\n", "b", "=", "all_nodes", "[", "j", "]", "\n", "if", "(", "i", "<", "j", ")", ":", "\n", "                    ", "temp_arr", "=", "all_nodes", "[", ":", "i", "]", "+", "all_nodes", "[", "i", "+", "1", ":", "j", "]", "+", "all_nodes", "[", "j", "+", "1", ":", "]", "\n", "", "else", ":", "\n", "                    ", "temp_arr", "=", "all_nodes", "[", ":", "j", "]", "+", "all_nodes", "[", "j", "+", "1", ":", "i", "]", "+", "all_nodes", "[", "i", "+", "1", ":", "]", "\n", "", "k_sized_lists", "=", "list", "(", "combinations", "(", "temp_arr", ",", "k", ")", ")", "\n", "for", "k_list", "in", "k_sized_lists", ":", "\n", "                    ", "if", "self", ".", "_graph", ".", "check_dseparation", "(", "[", "str", "(", "a", ")", "]", ",", "[", "str", "(", "b", ")", "]", ",", "k_list", ")", "==", "True", ":", "\n", "                        ", "self", ".", "logger", ".", "info", "(", "\" %s and %s are CI given %s \"", ",", "a", ",", "b", ",", "k_list", ")", "\n", "conditional_independences", ".", "append", "(", "[", "a", ",", "b", ",", "k_list", "]", ")", "\n", "\n", "", "", "", "independence_constraints", "=", "conditional_independences", "\n", "\n", "", "res", "=", "refuter", ".", "refute_model", "(", "independence_constraints", "=", "independence_constraints", ")", "\n", "\n", "self", ".", "logger", ".", "info", "(", "refuter", ".", "_refutation_passed", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.__init__": [[44, 142], ["logging.getLogger", "bool", "len", "pandas.get_dummies", "causal_estimator.CausalEstimator.logger.debug"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data", ",", "identified_estimand", ",", "treatment", ",", "outcome", ",", "\n", "control_value", "=", "0", ",", "treatment_value", "=", "1", ",", "\n", "test_significance", "=", "False", ",", "evaluate_effect_strength", "=", "False", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "target_units", "=", "None", ",", "effect_modifiers", "=", "None", ",", "\n", "num_null_simulations", "=", "DEFAULT_NUMBER_OF_SIMULATIONS_STAT_TEST", ",", "\n", "num_simulations", "=", "DEFAULT_NUMBER_OF_SIMULATIONS_CI", ",", "\n", "sample_size_fraction", "=", "DEFAULT_SAMPLE_SIZE_FRACTION", ",", "\n", "confidence_level", "=", "DEFAULT_CONFIDENCE_LEVEL", ",", "\n", "need_conditional_estimates", "=", "'auto'", ",", "\n", "num_quantiles_to_discretize_cont_cols", "=", "NUM_QUANTILES_TO_DISCRETIZE_CONT_COLS", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initializes an estimator with data and names of relevant variables.\n\n        This method is called from the constructors of its child classes.\n\n        :param data: data frame containing the data\n        :param identified_estimand: probability expression\n            representing the target identified estimand to estimate.\n        :param treatment: name of the treatment variable\n        :param outcome: name of the outcome variable\n        :param control_value: Value of the treatment in the control group, for effect estimation.  If treatment is multi-variate, this can be a list.\n        :param treatment_value: Value of the treatment in the treated group, for effect estimation. If treatment is multi-variate, this can be a list.\n        :param test_significance: Binary flag or a string indicating whether to test significance and by which method. All estimators support test_significance=\"bootstrap\" that estimates a p-value for the obtained estimate using the bootstrap method. Individual estimators can override this to support custom testing methods. The bootstrap method supports an optional parameter, num_null_simulations. If False, no testing is done. If True, significance of the estimate is tested using the custom method if available, otherwise by bootstrap.\n        :param evaluate_effect_strength: (Experimental) whether to evaluate the strength of effect\n        :param confidence_intervals: Binary flag or a string indicating whether the confidence intervals should be computed and which method should be used. All methods support estimation of confidence intervals using the bootstrap method by using the parameter confidence_intervals=\"bootstrap\". The bootstrap method takes in two arguments (num_simulations and sample_size_fraction) that can be optionally specified in the params dictionary. Estimators may also override this to implement their own confidence interval method. If this parameter is False, no confidence intervals are computed. If True, confidence intervals are computed by the estimator's specific method if available, otherwise through bootstrap.\n        :param target_units: The units for which the treatment effect should be estimated. This can be a string for common specifications of target units (namely, \"ate\", \"att\" and \"atc\"). It can also be a lambda function that can be used as an index for the data (pandas DataFrame). Alternatively, it can be a new DataFrame that contains values of the effect_modifiers and effect will be estimated only for this new data.\n        :param effect_modifiers: Variables on which to compute separate\n            effects, or return a heterogeneous effect function. Not all\n            methods support this currently.\n        :param num_null_simulations: The number of simulations for testing the\n            statistical significance of the estimator\n        :param num_simulations: The number of simulations for finding the\n            confidence interval (and/or standard error) for a estimate\n        :param sample_size_fraction: The size of the sample for the bootstrap\n            estimator\n        :param confidence_level: The confidence level of the confidence\n            interval estimate\n        :param need_conditional_estimates: Boolean flag indicating whether\n            conditional estimates should be computed. Defaults to True if\n            there are effect modifiers in the graph\n        :param num_quantiles_to_discretize_cont_cols: The number of quantiles\n            into which a numeric effect modifier is split, to enable\n            estimation of conditional treatment effect over it.\n        :param kwargs: (optional) Additional estimator-specific parameters\n        :returns: an instance of the estimator class.\n        \"\"\"", "\n", "self", ".", "_data", "=", "data", "\n", "self", ".", "_target_estimand", "=", "identified_estimand", "\n", "# Currently estimation methods only support univariate treatment and outcome", "\n", "self", ".", "_treatment_name", "=", "treatment", "\n", "self", ".", "_outcome_name", "=", "outcome", "[", "0", "]", "# assuming one-dimensional outcome", "\n", "self", ".", "_control_value", "=", "control_value", "\n", "self", ".", "_treatment_value", "=", "treatment_value", "\n", "self", ".", "_significance_test", "=", "test_significance", "\n", "self", ".", "_effect_strength_eval", "=", "evaluate_effect_strength", "\n", "self", ".", "_target_units", "=", "target_units", "\n", "self", ".", "_effect_modifier_names", "=", "effect_modifiers", "\n", "self", ".", "_confidence_intervals", "=", "confidence_intervals", "\n", "self", ".", "_bootstrap_estimates", "=", "None", "# for confidence intervals and std error", "\n", "self", ".", "_bootstrap_null_estimates", "=", "None", "# for significance test", "\n", "self", ".", "_effect_modifiers", "=", "None", "\n", "self", ".", "method_params", "=", "kwargs", "\n", "# Setting the default interpret method", "\n", "self", ".", "interpret_method", "=", "CausalEstimator", ".", "DEFAULT_INTERPRET_METHOD", "\n", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "# Setting treatment and outcome values", "\n", "if", "self", ".", "_data", "is", "not", "None", ":", "\n", "            ", "self", ".", "_treatment", "=", "self", ".", "_data", "[", "self", ".", "_treatment_name", "]", "\n", "self", ".", "_outcome", "=", "self", ".", "_data", "[", "self", ".", "_outcome_name", "]", "\n", "\n", "# Now saving the effect modifiers", "\n", "", "if", "self", ".", "_effect_modifier_names", ":", "\n", "# only add the observed nodes", "\n", "            ", "self", ".", "_effect_modifier_names", "=", "[", "cname", "\n", "for", "cname", "in", "self", ".", "_effect_modifier_names", "\n", "if", "cname", "in", "self", ".", "_data", ".", "columns", "]", "\n", "if", "len", "(", "self", ".", "_effect_modifier_names", ")", ">", "0", ":", "\n", "                ", "self", ".", "_effect_modifiers", "=", "self", ".", "_data", "[", "self", ".", "_effect_modifier_names", "]", "\n", "self", ".", "_effect_modifiers", "=", "pd", ".", "get_dummies", "(", "self", ".", "_effect_modifiers", ",", "drop_first", "=", "True", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Effect modifiers: \"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_effect_modifier_names", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_effect_modifier_names", "=", "None", "\n", "\n", "# Check if some parameters were set, otherwise set to default values", "\n", "", "", "self", ".", "num_null_simulations", "=", "num_null_simulations", "\n", "self", ".", "num_simulations", "=", "num_simulations", "\n", "self", ".", "sample_size_fraction", "=", "sample_size_fraction", "\n", "self", ".", "confidence_level", "=", "confidence_level", "\n", "self", ".", "num_quantiles_to_discretize_cont_cols", "=", "num_quantiles_to_discretize_cont_cols", "\n", "# Estimate conditional estimates by default", "\n", "self", ".", "need_conditional_estimates", "=", "need_conditional_estimates", "if", "need_conditional_estimates", "!=", "'auto'", "else", "bool", "(", "self", ".", "_effect_modifier_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object": [[143, 176], ["estimator_class"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_estimator_object", "(", "new_data", ",", "identified_estimand", ",", "estimate", ")", ":", "\n", "        ", "\"\"\" Create a new estimator of the same type as the one passed in the estimate argument.\n\n        Creates a new object with new_data and the identified_estimand\n\n        :param new_data: np.ndarray, pd.Series, pd.DataFrame\n            The newly assigned data on which the estimator should run\n        :param identified_estimand: IdentifiedEstimand\n            An instance of the identified estimand class that provides the information with\n            respect to which causal pathways are employed when the treatment effects the outcome\n        :param estimate: CausalEstimate\n            It is an already existing estimate whose properties we wish to replicate\n\n        :returns: An instance of the same estimator class that had generated the given estimate.\n        \"\"\"", "\n", "estimator_class", "=", "estimate", ".", "params", "[", "'estimator_class'", "]", "\n", "new_estimator", "=", "estimator_class", "(", "\n", "new_data", ",", "\n", "identified_estimand", ",", "\n", "identified_estimand", ".", "treatment_variable", ",", "identified_estimand", ".", "outcome_variable", ",", "\n", "# names of treatment and outcome", "\n", "control_value", "=", "estimate", ".", "control_value", ",", "\n", "treatment_value", "=", "estimate", ".", "treatment_value", ",", "\n", "test_significance", "=", "False", ",", "\n", "evaluate_effect_strength", "=", "False", ",", "\n", "confidence_intervals", "=", "estimate", ".", "params", "[", "\"confidence_intervals\"", "]", ",", "\n", "target_units", "=", "estimate", ".", "params", "[", "\"target_units\"", "]", ",", "\n", "effect_modifiers", "=", "estimate", ".", "params", "[", "\"effect_modifiers\"", "]", ",", "\n", "**", "estimate", ".", "params", "[", "\"method_params\"", "]", "\n", ")", "\n", "\n", "return", "new_estimator", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_effect": [[177, 182], ["NotImplementedError"], "methods", ["None"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "'''This method is to be overriden by the child classes, so that they can run the estimation technique of their choice\n        '''", "\n", "raise", "NotImplementedError", "(", "\n", "(", "\"Main estimation method is \"", "+", "CausalEstimator", ".", "DEFAULT_NOTIMPLEMENTEDERROR_MSG", ")", ".", "format", "(", "self", ".", "__class__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect": [[183, 204], ["causal_estimator.CausalEstimator._estimate_effect", "causal_estimator.CausalEstimator.add_estimator", "causal_estimator.CausalEstimator.test_significance", "causal_estimator.CausalEstimator.estimate_confidence_intervals", "causal_estimator.CausalEstimator.evaluate_effect_strength", "causal_estimator.CausalEstimator.add_effect_strength"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.add_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.evaluate_effect_strength", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.add_effect_strength"], ["", "def", "estimate_effect", "(", "self", ")", ":", "\n", "        ", "\"\"\"Base estimation method that calls the estimate_effect method of its calling subclass.\n\n        Can optionally also test significance and estimate effect strength for any returned estimate.\n\n        :param self: object instance of class Estimator\n        :returns: A CausalEstimate instance that contains point estimates of average and conditional effects. Based on the parameters provided, it optionally includes confidence intervals, standard errors,statistical significance and other statistical parameters.\n        \"\"\"", "\n", "est", "=", "self", ".", "_estimate_effect", "(", ")", "\n", "est", ".", "add_estimator", "(", "self", ")", "\n", "\n", "if", "self", ".", "_significance_test", ":", "\n", "            ", "self", ".", "test_significance", "(", "est", ".", "value", ",", "method", "=", "self", ".", "_significance_test", ")", "\n", "", "if", "self", ".", "_confidence_intervals", ":", "\n", "            ", "self", ".", "estimate_confidence_intervals", "(", "est", ".", "value", ",", "confidence_level", "=", "self", ".", "confidence_level", ",", "\n", "method", "=", "self", ".", "_confidence_intervals", ")", "\n", "", "if", "self", ".", "_effect_strength_eval", ":", "\n", "            ", "effect_strength_dict", "=", "self", ".", "evaluate_effect_strength", "(", "est", ")", "\n", "est", ".", "add_effect_strength", "(", "effect_strength_dict", ")", "\n", "\n", "", "return", "est", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect_naive": [[205, 211], ["causal_estimator.CausalEstimate", "numpy.mean", "numpy.mean"], "methods", ["None"], ["", "def", "estimate_effect_naive", "(", "self", ")", ":", "\n", "# TODO Only works for binary treatment", "\n", "        ", "df_withtreatment", "=", "self", ".", "_data", ".", "loc", "[", "self", ".", "_data", "[", "self", ".", "_treatment_name", "]", "==", "1", "]", "\n", "df_notreatment", "=", "self", ".", "_data", ".", "loc", "[", "self", ".", "_data", "[", "self", ".", "_treatment_name", "]", "==", "0", "]", "\n", "est", "=", "np", ".", "mean", "(", "df_withtreatment", "[", "self", ".", "_outcome_name", "]", ")", "-", "np", ".", "mean", "(", "df_notreatment", "[", "self", ".", "_outcome_name", "]", ")", "\n", "return", "CausalEstimate", "(", "est", ",", "None", ",", "None", ",", "control_value", "=", "0", ",", "treatment_value", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_effect_fn": [[212, 220], ["NotImplementedError"], "methods", ["None"], ["", "def", "_estimate_effect_fn", "(", "self", ",", "data_df", ")", ":", "\n", "        ", "\"\"\"Function used in conditional effect estimation. This function is to be overridden by each child estimator.\n\n        The overridden function should take in a dataframe as input and return the estimate for that data.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "(", "\"Conditional treatment effects are \"", "+", "CausalEstimator", ".", "DEFAULT_NOTIMPLEMENTEDERROR_MSG", ")", ".", "format", "(", "\n", "self", ".", "__class__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_conditional_effects": [[221, 266], ["dowhy.utils.api.parse_state", "effect_modifier_names.copy.copy.copy", "range", "causal_estimator.CausalEstimator._data.groupby", "causal_estimator.CausalEstimator.apply", "ValueError", "all", "causal_estimator.CausalEstimator.logger.warn", "len", "pandas.api.types.is_numeric_dtype", "em.startswith", "pandas.qcut", "causal_estimator.CausalEstimator._do", "causal_estimator.CausalEstimator._do", "causal_estimator.CausalEstimator._data.pop", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._do", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._do"], ["", "def", "_estimate_conditional_effects", "(", "self", ",", "estimate_effect_fn", ",", "\n", "effect_modifier_names", "=", "None", ",", "\n", "num_quantiles", "=", "None", ")", ":", "\n", "        ", "\"\"\"Estimate conditional treatment effects. Common method for all estimators that utilizes a specific estimate_effect_fn implemented by each child estimator.\n\n        If a numeric effect modifier is provided, it is discretized into quantile bins. If you would like a custom discretization, you can do so yourself: create a new column containing the discretized effect modifier and then include that column's name in the effect_modifier_names argument.\n\n        :param estimate_effect_fn: Function that has a single parameter (a data frame) and returns the treatment effect estimate on that data.\n        :param effect_modifier_names: Names of effect modifier variables over which the conditional effects will be estimated. If not provided, defaults to the effect modifiers specified during creation of the CausalEstimator object.\n        :param num_quantiles: The number of quantiles into which a numeric effect modifier variable is discretized. Does not affect any categorical effect modifiers.\n\n        :returns: A (multi-index) dataframe that provides separate effects for each value of the (discretized) effect modifiers.\n        \"\"\"", "\n", "# Defaulting to class default values if parameters are not provided", "\n", "if", "effect_modifier_names", "is", "None", ":", "\n", "            ", "effect_modifier_names", "=", "self", ".", "_effect_modifier_names", "\n", "", "if", "num_quantiles", "is", "None", ":", "\n", "            ", "num_quantiles", "=", "self", ".", "num_quantiles_to_discretize_cont_cols", "\n", "# Checking that there is at least one effect modifier", "\n", "", "if", "not", "effect_modifier_names", ":", "\n", "            ", "raise", "ValueError", "(", "\"At least one effect modifier should be specified to compute conditional effects.\"", ")", "\n", "# Making sure that effect_modifier_names is a list", "\n", "", "effect_modifier_names", "=", "parse_state", "(", "effect_modifier_names", ")", "\n", "if", "not", "all", "(", "em", "in", "self", ".", "_effect_modifier_names", "for", "em", "in", "effect_modifier_names", ")", ":", "\n", "            ", "self", ".", "logger", ".", "warn", "(", "\n", "\"At least one of the provided effect modifiers was not included while fitting the estimator. You may get incorrect results. To resolve, fit the estimator again by providing the updated effect modifiers in estimate_effect().\"", ")", "\n", "# Making a copy since we are going to be changing effect modifier names", "\n", "", "effect_modifier_names", "=", "effect_modifier_names", ".", "copy", "(", ")", "\n", "prefix", "=", "CausalEstimator", ".", "TEMP_CAT_COLUMN_PREFIX", "\n", "# For every numeric effect modifier, adding a temp categorical column", "\n", "for", "i", "in", "range", "(", "len", "(", "effect_modifier_names", ")", ")", ":", "\n", "            ", "em", "=", "effect_modifier_names", "[", "i", "]", "\n", "if", "pd", ".", "api", ".", "types", ".", "is_numeric_dtype", "(", "self", ".", "_data", "[", "em", "]", ".", "dtypes", ")", ":", "\n", "                ", "self", ".", "_data", "[", "prefix", "+", "str", "(", "em", ")", "]", "=", "pd", ".", "qcut", "(", "self", ".", "_data", "[", "em", "]", ",", "\n", "num_quantiles", ",", "duplicates", "=", "\"drop\"", ")", "\n", "effect_modifier_names", "[", "i", "]", "=", "prefix", "+", "str", "(", "em", ")", "\n", "# Grouping by effect modifiers and computing effect separately", "\n", "", "", "by_effect_mods", "=", "self", ".", "_data", ".", "groupby", "(", "effect_modifier_names", ")", "\n", "cond_est_fn", "=", "lambda", "x", ":", "self", ".", "_do", "(", "self", ".", "_treatment_value", ",", "x", ")", "-", "self", ".", "_do", "(", "self", ".", "_control_value", ",", "x", ")", "\n", "conditional_estimates", "=", "by_effect_mods", ".", "apply", "(", "estimate_effect_fn", ")", "\n", "# Deleting the temporary categorical columns", "\n", "for", "em", "in", "effect_modifier_names", ":", "\n", "            ", "if", "em", ".", "startswith", "(", "prefix", ")", ":", "\n", "                ", "self", ".", "_data", ".", "pop", "(", "em", ")", "\n", "", "", "return", "conditional_estimates", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._do": [[267, 270], ["NotImplementedError"], "methods", ["None"], ["", "def", "_do", "(", "self", ",", "x", ",", "data_df", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\n", "(", "\"Do-operator is \"", "+", "CausalEstimator", ".", "DEFAULT_NOTIMPLEMENTEDERROR_MSG", ")", ".", "format", "(", "self", ".", "__class__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.do": [[271, 284], ["causal_estimator.CausalEstimator._do"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._do"], ["", "def", "do", "(", "self", ",", "x", ",", "data_df", "=", "None", ")", ":", "\n", "        ", "\"\"\"Method that implements the do-operator.\n\n        Given a value x for the treatment, returns the expected value of the outcome when the treatment is intervened to a value x.\n\n        :param x: Value of the treatment\n        :param data_df: Data on which the do-operator is to be applied.\n\n        :returns: Value of the outcome when treatment is intervened/set to x.\n\n        \"\"\"", "\n", "est", "=", "self", ".", "_do", "(", "x", ",", "data_df", ")", "\n", "return", "est", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.construct_symbolic_estimator": [[285, 287], ["NotImplementedError"], "methods", ["None"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "(", "\"Symbolic estimator string is \"", ")", ".", "format", "(", "self", ".", "__class__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._generate_bootstrap_estimates": [[288, 332], ["numpy.zeros", "int", "causal_estimator.CausalEstimator.logger.info", "causal_estimator.CausalEstimator.logger.info", "range", "CausalEstimator.BootstrapEstimates", "len", "causal_estimator.CausalEstimator.logger.warning", "sklearn.utils.resample", "new_estimator.estimate_effect", "len", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "def", "_generate_bootstrap_estimates", "(", "self", ",", "num_bootstrap_simulations", ",", "\n", "sample_size_fraction", ")", ":", "\n", "        ", "\"\"\" Helper function to generate causal estimates over bootstrapped samples.\n\n        :param num_bootstrap_simulations: Number of simulations for the bootstrap method.\n        :param sample_size_fraction: Fraction of the dataset to be resampled.\n        :returns: A collections.namedtuple containing a list of bootstrapped estimates and a dictionary containing parameters used for the bootstrap.\n        \"\"\"", "\n", "# The array that stores the results of all estimations", "\n", "simulation_results", "=", "np", ".", "zeros", "(", "num_bootstrap_simulations", ")", "\n", "\n", "# Find the sample size the proportion with the population size", "\n", "sample_size", "=", "int", "(", "sample_size_fraction", "*", "len", "(", "self", ".", "_data", ")", ")", "\n", "\n", "if", "sample_size", ">", "len", "(", "self", ".", "_data", ")", ":", "\n", "            ", "self", ".", "logger", ".", "warning", "(", "\"WARN: The sample size is greater than the data being sampled\"", ")", "\n", "\n", "", "self", ".", "logger", ".", "info", "(", "\"INFO: The sample size: {}\"", ".", "format", "(", "sample_size", ")", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: The number of simulations: {}\"", ".", "format", "(", "num_bootstrap_simulations", ")", ")", "\n", "\n", "# Perform the set number of simulations", "\n", "for", "index", "in", "range", "(", "num_bootstrap_simulations", ")", ":", "\n", "            ", "new_data", "=", "resample", "(", "self", ".", "_data", ",", "n_samples", "=", "sample_size", ")", "\n", "new_estimator", "=", "type", "(", "self", ")", "(", "\n", "new_data", ",", "\n", "self", ".", "_target_estimand", ",", "\n", "self", ".", "_target_estimand", ".", "treatment_variable", ",", "self", ".", "_target_estimand", ".", "outcome_variable", ",", "\n", "# names of treatment and outcome", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "test_significance", "=", "False", ",", "\n", "evaluate_effect_strength", "=", "False", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "target_units", "=", "self", ".", "_target_units", ",", "\n", "effect_modifiers", "=", "self", ".", "_effect_modifier_names", ",", "\n", "**", "self", ".", "method_params", "\n", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "simulation_results", "[", "index", "]", "=", "new_effect", ".", "value", "\n", "\n", "", "estimates", "=", "CausalEstimator", ".", "BootstrapEstimates", "(", "simulation_results", ",", "\n", "{", "'num_simulations'", ":", "num_bootstrap_simulations", ",", "\n", "'sample_size_fraction'", ":", "sample_size_fraction", "}", ")", "\n", "return", "estimates", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_confidence_intervals_with_bootstrap": [[333, 377], ["numpy.sort", "int", "int", "causal_estimator.CausalEstimator._generate_bootstrap_estimates", "causal_estimator.CausalEstimator.is_bootstrap_parameter_changed", "locals", "causal_estimator.CausalEstimator._generate_bootstrap_estimates", "len", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._generate_bootstrap_estimates", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.is_bootstrap_parameter_changed", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._generate_bootstrap_estimates"], ["", "def", "_estimate_confidence_intervals_with_bootstrap", "(", "self", ",", "estimate_value", ",", "\n", "confidence_level", "=", "None", ",", "\n", "num_simulations", "=", "None", ",", "sample_size_fraction", "=", "None", ")", ":", "\n", "        ", "'''\n            Method to compute confidence interval using bootstrapped sampling.\n\n            :param estimate_value: obtained estimate's value\n            :param confidence_level: The level for which to compute CI (e.g., 95% confidence level translates to confidence_level=0.95)\n            :param num_simulations: The number of simulations to be performed to get the bootstrap confidence intervals.\n            :param sample_size_fraction: The fraction of the dataset to be resampled.\n            :returns: confidence interval at the specified level.\n\n            For more details on bootstrap or resampling statistics, refer to the following links:\n            https://ocw.mit.edu/courses/mathematics/18-05-introduction-to-probability-and-statistics-spring-2014/readings/MIT18_05S14_Reading24.pdf\n            https://projecteuclid.org/download/pdf_1/euclid.ss/1032280214\n        '''", "\n", "# Using class default parameters if not specified", "\n", "if", "num_simulations", "is", "None", ":", "\n", "            ", "num_simulations", "=", "self", ".", "num_simulations", "\n", "", "if", "sample_size_fraction", "is", "None", ":", "\n", "            ", "sample_size_fraction", "=", "self", ".", "sample_size_fraction", "\n", "\n", "# Checking if bootstrap_estimates are already computed", "\n", "", "if", "self", ".", "_bootstrap_estimates", "is", "None", ":", "\n", "            ", "self", ".", "_bootstrap_estimates", "=", "self", ".", "_generate_bootstrap_estimates", "(", "\n", "num_simulations", ",", "sample_size_fraction", ")", "\n", "", "elif", "CausalEstimator", ".", "is_bootstrap_parameter_changed", "(", "self", ".", "_bootstrap_estimates", ".", "params", ",", "locals", "(", ")", ")", ":", "\n", "# Checked if any parameter is changed from the previous std error estimate", "\n", "            ", "self", ".", "_bootstrap_estimates", "=", "self", ".", "_generate_bootstrap_estimates", "(", "\n", "num_simulations", ",", "sample_size_fraction", ")", "\n", "# Now use the data obtained from the simulations to get the value of the confidence estimates", "\n", "", "bootstrap_estimates", "=", "self", ".", "_bootstrap_estimates", ".", "estimates", "\n", "# Get the variations of each bootstrap estimate and sort", "\n", "bootstrap_variations", "=", "[", "bootstrap_estimate", "-", "estimate_value", "for", "bootstrap_estimate", "in", "bootstrap_estimates", "]", "\n", "sorted_bootstrap_variations", "=", "np", ".", "sort", "(", "bootstrap_variations", ")", "\n", "\n", "# Now we take the (1- p)th and the (p)th variations, where p is the chosen confidence level", "\n", "upper_bound_index", "=", "int", "(", "(", "1", "-", "confidence_level", ")", "*", "len", "(", "sorted_bootstrap_variations", ")", ")", "\n", "lower_bound_index", "=", "int", "(", "confidence_level", "*", "len", "(", "sorted_bootstrap_variations", ")", ")", "\n", "\n", "# Get the lower and upper bounds by subtracting the variations from the estimate", "\n", "lower_bound", "=", "estimate_value", "-", "sorted_bootstrap_variations", "[", "lower_bound_index", "]", "\n", "upper_bound", "=", "estimate_value", "-", "sorted_bootstrap_variations", "[", "upper_bound_index", "]", "\n", "return", "lower_bound", ",", "upper_bound", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_confidence_intervals": [[378, 388], ["NotImplementedError"], "methods", ["None"], ["", "def", "_estimate_confidence_intervals", "(", "self", ",", "confidence_level", "=", "None", ",", "method", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "'''\n            This method is to be overriden by the child classes, so that they\n            can run a confidence interval estimation method suited to the specific\n            causal estimator.\n        '''", "\n", "raise", "NotImplementedError", "(", "(", "\n", "\"This method for estimating confidence intervals is \"", "+", "CausalEstimator", ".", "DEFAULT_NOTIMPLEMENTEDERROR_MSG", "+", "\" Meanwhile, you can try the bootstrap method (method='bootstrap') to estimate confidence intervals.\"", ")", ".", "format", "(", "\n", "self", ".", "__class__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_confidence_intervals": [[389, 426], ["causal_estimator.CausalEstimator._estimate_confidence_intervals", "causal_estimator.CausalEstimator._estimate_confidence_intervals_with_bootstrap", "causal_estimator.CausalEstimator._estimate_confidence_intervals", "causal_estimator.CausalEstimator._estimate_confidence_intervals_with_bootstrap"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._estimate_confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_confidence_intervals_with_bootstrap", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._estimate_confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_confidence_intervals_with_bootstrap"], ["", "def", "estimate_confidence_intervals", "(", "self", ",", "estimate_value", ",", "confidence_level", "=", "None", ",", "method", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "''' Find the confidence intervals corresponding to any estimator\n            By default, this is done with the help of bootstrapped confidence intervals\n            but can be overridden if the specific estimator implements other methods of estimating confidence intervals.\n\n            If the method provided is not bootstrap, this function calls the implementation of the specific estimator.\n\n            :param estimate_value: obtained estimate's value\n            :param method: Method for estimating confidence intervals.\n            :param confidence_level: The confidence level of the confidence intervals of the estimate.\n            :param kwargs: Other optional args to be passed to the CI method.\n            :returns: The obtained confidence interval.\n        '''", "\n", "if", "method", "is", "None", ":", "\n", "            ", "if", "self", ".", "_confidence_intervals", ":", "\n", "                ", "method", "=", "self", ".", "_confidence_intervals", "# this is either True or methodname", "\n", "", "else", ":", "\n", "                ", "method", "=", "\"default\"", "\n", "", "", "confidence_intervals", "=", "None", "\n", "if", "confidence_level", "is", "None", ":", "\n", "            ", "confidence_level", "=", "self", ".", "confidence_level", "\n", "", "if", "method", "==", "\"default\"", "or", "method", "is", "True", ":", "# user has not provided any method", "\n", "            ", "try", ":", "\n", "                ", "confidence_intervals", "=", "self", ".", "_estimate_confidence_intervals", "(", "\n", "confidence_level", ",", "method", "=", "method", ",", "**", "kwargs", ")", "\n", "", "except", "NotImplementedError", ":", "\n", "                ", "confidence_intervals", "=", "self", ".", "_estimate_confidence_intervals_with_bootstrap", "(", "estimate_value", ",", "\n", "confidence_level", ",", "**", "kwargs", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "method", "==", "\"bootstrap\"", ":", "\n", "                ", "confidence_intervals", "=", "self", ".", "_estimate_confidence_intervals_with_bootstrap", "(", "estimate_value", ",", "\n", "confidence_level", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "                ", "confidence_intervals", "=", "self", ".", "_estimate_confidence_intervals", "(", "\n", "confidence_level", ",", "method", "=", "method", ",", "**", "kwargs", ")", "\n", "", "", "return", "confidence_intervals", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_std_error_with_bootstrap": [[427, 453], ["numpy.std", "causal_estimator.CausalEstimator._generate_bootstrap_estimates", "causal_estimator.CausalEstimator.is_bootstrap_parameter_changed", "locals", "causal_estimator.CausalEstimator._generate_bootstrap_estimates"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._generate_bootstrap_estimates", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.is_bootstrap_parameter_changed", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._generate_bootstrap_estimates"], ["", "def", "_estimate_std_error_with_bootstrap", "(", "self", ",", "num_simulations", "=", "None", ",", "\n", "sample_size_fraction", "=", "None", ")", ":", "\n", "        ", "\"\"\" Compute standard error using the bootstrap method. Standard error\n        and confidence intervals use the same parameter num_simulations for\n        the number of bootstrap simulations.\n\n        :param num_simulations: Number of bootstrapped samples.\n        :param sample_size_fraction: Fraction of data to be resampled.\n        :returns: Standard error of the obtained estimate.\n        \"\"\"", "\n", "# Use existing params, if new user defined params are not present", "\n", "if", "num_simulations", "is", "None", ":", "\n", "            ", "num_simulations", "=", "self", ".", "num_simulations", "\n", "", "if", "sample_size_fraction", "is", "None", ":", "\n", "            ", "sample_size_fraction", "=", "self", ".", "sample_size_fraction", "\n", "# Checking if bootstrap_estimates are already computed", "\n", "", "if", "self", ".", "_bootstrap_estimates", "is", "None", ":", "\n", "            ", "self", ".", "_bootstrap_estimates", "=", "self", ".", "_generate_bootstrap_estimates", "(", "\n", "num_simulations", ",", "sample_size_fraction", ")", "\n", "", "elif", "CausalEstimator", ".", "is_bootstrap_parameter_changed", "(", "self", ".", "_bootstrap_estimates", ".", "params", ",", "locals", "(", ")", ")", ":", "\n", "# Check if any parameter is changed from the previous std error estimate", "\n", "            ", "self", ".", "_bootstrap_estimates", "=", "self", ".", "_generate_bootstrap_estimates", "(", "\n", "num_simulations", ",", "sample_size_fraction", ")", "\n", "\n", "", "std_error", "=", "np", ".", "std", "(", "self", ".", "_bootstrap_estimates", ".", "estimates", ")", "\n", "return", "std_error", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_std_error": [[454, 463], ["NotImplementedError"], "methods", ["None"], ["", "def", "_estimate_std_error", "(", "self", ",", "method", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''\n            This method is to be overriden by the child classes, so that they\n            can run a standard error estimation method suited to the specific\n            causal estimator.\n        '''", "\n", "raise", "NotImplementedError", "(", "(", "\n", "\"This method for estimating standard errors is \"", "+", "CausalEstimator", ".", "DEFAULT_NOTIMPLEMENTEDERROR_MSG", "+", "\" Meanwhile, you can try the bootstrap method (method='bootstrap') to estimate standard errors.\"", ")", ".", "format", "(", "\n", "self", ".", "__class__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_std_error": [[464, 488], ["causal_estimator.CausalEstimator._estimate_std_error", "causal_estimator.CausalEstimator._estimate_std_error_with_bootstrap", "causal_estimator.CausalEstimator._estimate_std_error", "causal_estimator.CausalEstimator._estimate_std_error_with_bootstrap"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator._estimate_std_error", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_std_error_with_bootstrap", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator._estimate_std_error", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_std_error_with_bootstrap"], ["", "def", "estimate_std_error", "(", "self", ",", "method", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Compute standard error of an obtained causal estimate.\n\n        :param method: Method for computing the standard error.\n        :param kwargs: Other optional parameters to be passed to the estimating method.\n        :returns: Standard error of the causal estimate.\n        \"\"\"", "\n", "if", "method", "is", "None", ":", "\n", "            ", "if", "self", ".", "_confidence_intervals", ":", "\n", "                ", "method", "=", "self", ".", "_confidence_intervals", "\n", "", "else", ":", "\n", "                ", "method", "=", "\"default\"", "\n", "", "", "std_error", "=", "None", "\n", "if", "method", "==", "\"default\"", "or", "method", "is", "True", ":", "# user has not provided any method", "\n", "            ", "try", ":", "\n", "                ", "std_error", "=", "self", ".", "_estimate_std_error", "(", "method", ",", "**", "kwargs", ")", "\n", "", "except", "NotImplementedError", ":", "\n", "                ", "std_error", "=", "self", ".", "_estimate_std_error_with_bootstrap", "(", "**", "kwargs", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "method", "==", "\"bootstrap\"", ":", "\n", "                ", "std_error", "=", "self", ".", "_estimate_std_error_with_bootstrap", "(", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "                ", "std_error", "=", "self", ".", "_estimate_std_error", "(", "method", ",", "**", "kwargs", ")", "\n", "", "", "return", "std_error", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._test_significance_with_bootstrap": [[489, 547], ["numpy.sort", "causal_estimator.CausalEstimator.logger.debug", "causal_estimator.CausalEstimator.is_bootstrap_parameter_changed", "numpy.zeros", "range", "CausalEstimator.BootstrapEstimates", "numpy.searchsorted", "numpy.searchsorted", "locals", "numpy.random.permutation", "causal_estimator.CausalEstimator._data.assign", "new_estimator.estimate_effect", "int", "type", "len", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.is_bootstrap_parameter_changed", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "def", "_test_significance_with_bootstrap", "(", "self", ",", "estimate_value", ",", "num_null_simulations", "=", "None", ")", ":", "\n", "        ", "\"\"\" Test statistical significance of an estimate using the bootstrap method.\n\n        :param estimate_value: Obtained estimate's value\n        :param num_null_simulations: Number of simulations for the null hypothesis\n        :returns: p-value of the statistical significance test.\n        \"\"\"", "\n", "# Use existing params, if new user defined params are not present", "\n", "if", "num_null_simulations", "is", "None", ":", "\n", "            ", "num_null_simulations", "=", "self", ".", "num_null_simulations", "\n", "", "do_retest", "=", "self", ".", "_bootstrap_null_estimates", "is", "None", "or", "CausalEstimator", ".", "is_bootstrap_parameter_changed", "(", "\n", "self", ".", "_bootstrap_null_estimates", ".", "params", ",", "locals", "(", ")", ")", "\n", "if", "do_retest", ":", "\n", "            ", "null_estimates", "=", "np", ".", "zeros", "(", "num_null_simulations", ")", "\n", "for", "i", "in", "range", "(", "num_null_simulations", ")", ":", "\n", "                ", "new_outcome", "=", "np", ".", "random", ".", "permutation", "(", "self", ".", "_outcome", ")", "\n", "new_data", "=", "self", ".", "_data", ".", "assign", "(", "dummy_outcome", "=", "new_outcome", ")", "\n", "# self._outcome = self._data[\"dummy_outcome\"]", "\n", "new_estimator", "=", "type", "(", "self", ")", "(", "\n", "new_data", ",", "\n", "self", ".", "_target_estimand", ",", "\n", "self", ".", "_target_estimand", ".", "treatment_variable", ",", "\n", "(", "\"dummy_outcome\"", ",", ")", ",", "\n", "test_significance", "=", "False", ",", "\n", "evaluate_effect_strength", "=", "False", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "target_units", "=", "self", ".", "_target_units", ",", "\n", "effect_modifiers", "=", "self", ".", "_effect_modifier_names", ",", "\n", "**", "self", ".", "method_params", "\n", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "null_estimates", "[", "i", "]", "=", "new_effect", ".", "value", "\n", "", "self", ".", "_bootstrap_null_estimates", "=", "CausalEstimator", ".", "BootstrapEstimates", "(", "\n", "null_estimates", ",", "\n", "{", "'num_null_simulations'", ":", "num_null_simulations", ",", "'sample_size_fraction'", ":", "1", "}", ")", "\n", "\n", "# Processing the null hypothesis estimates", "\n", "", "sorted_null_estimates", "=", "np", ".", "sort", "(", "self", ".", "_bootstrap_null_estimates", ".", "estimates", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Null estimates: {0}\"", ".", "format", "(", "sorted_null_estimates", ")", ")", "\n", "median_estimate", "=", "sorted_null_estimates", "[", "int", "(", "num_null_simulations", "/", "2", ")", "]", "\n", "# Doing a two-sided test", "\n", "if", "estimate_value", ">", "median_estimate", ":", "\n", "# Being conservative with the p-value reported", "\n", "            ", "estimate_index", "=", "np", ".", "searchsorted", "(", "sorted_null_estimates", ",", "estimate_value", ",", "side", "=", "\"left\"", ")", "\n", "p_value", "=", "1", "-", "(", "estimate_index", "/", "num_null_simulations", ")", "\n", "", "if", "estimate_value", "<=", "median_estimate", ":", "\n", "# Being conservative with the p-value reported", "\n", "            ", "estimate_index", "=", "np", ".", "searchsorted", "(", "sorted_null_estimates", ",", "estimate_value", ",", "side", "=", "\"right\"", ")", "\n", "p_value", "=", "(", "estimate_index", "/", "num_null_simulations", ")", "\n", "# If the estimate_index is 0, it depends on the number of simulations", "\n", "", "if", "p_value", "==", "0", ":", "\n", "            ", "p_value", "=", "(", "0", ",", "1", "/", "len", "(", "sorted_null_estimates", ")", ")", "# a tuple determining the range.", "\n", "", "elif", "p_value", "==", "1", ":", "\n", "            ", "p_value", "=", "(", "1", "-", "1", "/", "len", "(", "sorted_null_estimates", ")", ",", "1", ")", "\n", "", "signif_dict", "=", "{", "\n", "'p_value'", ":", "p_value", "\n", "}", "\n", "return", "signif_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._test_significance": [[548, 557], ["NotImplementedError"], "methods", ["None"], ["", "def", "_test_significance", "(", "self", ",", "estimate_value", ",", "method", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''\n            This method is to be overriden by the child classes, so that they\n            can run a significance test suited to the specific\n            causal estimator.\n        '''", "\n", "raise", "NotImplementedError", "(", "(", "\n", "\"This method for testing statistical significance is \"", "+", "CausalEstimator", ".", "DEFAULT_NOTIMPLEMENTEDERROR_MSG", "+", "\" Meanwhile, you can try the bootstrap method (method='bootstrap') to test statistical significance.\"", ")", ".", "format", "(", "\n", "self", ".", "__class__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance": [[558, 590], ["causal_estimator.CausalEstimator._test_significance", "causal_estimator.CausalEstimator._test_significance_with_bootstrap", "causal_estimator.CausalEstimator._test_significance", "causal_estimator.CausalEstimator._test_significance_with_bootstrap"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator._test_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._test_significance_with_bootstrap", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator._test_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._test_significance_with_bootstrap"], ["", "def", "test_significance", "(", "self", ",", "estimate_value", ",", "method", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test statistical significance of obtained estimate.\n\n        By default, uses resampling to create a non-parametric significance test.\n        A general procedure. Individual child estimators can implement different methods.\n        If the method name is different from \"bootstrap\", this function calls the\n        implementation of the child estimator.\n\n        :param self: object instance of class Estimator\n        :param estimate_value: obtained estimate's value\n        :param method: Method for checking statistical significance\n\n        :returns: p-value from the significance test\n\n        \"\"\"", "\n", "if", "method", "is", "None", ":", "\n", "            ", "if", "self", ".", "_significance_test", ":", "\n", "                ", "method", "=", "self", ".", "_significance_test", "# this is either True or methodname", "\n", "", "else", ":", "\n", "                ", "method", "=", "\"default\"", "\n", "", "", "signif_dict", "=", "None", "\n", "if", "method", "==", "\"default\"", "or", "method", "is", "True", ":", "# user has not provided any method", "\n", "            ", "try", ":", "\n", "                ", "signif_dict", "=", "self", ".", "_test_significance", "(", "estimate_value", ",", "method", ",", "**", "kwargs", ")", "\n", "", "except", "NotImplementedError", ":", "\n", "                ", "signif_dict", "=", "self", ".", "_test_significance_with_bootstrap", "(", "estimate_value", ",", "**", "kwargs", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "method", "==", "\"bootstrap\"", ":", "\n", "                ", "signif_dict", "=", "self", ".", "_test_significance_with_bootstrap", "(", "estimate_value", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "                ", "signif_dict", "=", "self", ".", "_test_significance", "(", "estimate_value", ",", "method", ",", "**", "kwargs", ")", "\n", "", "", "return", "signif_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.evaluate_effect_strength": [[591, 600], ["causal_estimator.CausalEstimator._evaluate_effect_strength"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._evaluate_effect_strength"], ["", "def", "evaluate_effect_strength", "(", "self", ",", "estimate", ")", ":", "\n", "        ", "fraction_effect_explained", "=", "self", ".", "_evaluate_effect_strength", "(", "estimate", ",", "method", "=", "\"fraction-effect\"", ")", "\n", "# Need to test r-squared before supporting", "\n", "# effect_r_squared = self._evaluate_effect_strength(estimate, method=\"r-squared\")", "\n", "strength_dict", "=", "{", "\n", "'fraction-effect'", ":", "fraction_effect_explained", "\n", "#       'r-squared': effect_r_squared", "\n", "}", "\n", "return", "strength_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._evaluate_effect_strength": [[601, 621], ["NotImplementedError", "causal_estimator.CausalEstimator.estimate_effect_naive", "print"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect_naive"], ["", "def", "_evaluate_effect_strength", "(", "self", ",", "estimate", ",", "method", "=", "\"fraction-effect\"", ")", ":", "\n", "        ", "supported_methods", "=", "[", "\"fraction-effect\"", "]", "\n", "if", "method", "not", "in", "supported_methods", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"This method is not supported for evaluating effect strength\"", ")", "\n", "", "if", "method", "==", "\"fraction-effect\"", ":", "\n", "            ", "naive_obs_estimate", "=", "self", ".", "estimate_effect_naive", "(", ")", "\n", "print", "(", "estimate", ".", "value", ",", "naive_obs_estimate", ".", "value", ")", "\n", "fraction_effect_explained", "=", "estimate", ".", "value", "/", "naive_obs_estimate", ".", "value", "\n", "return", "fraction_effect_explained", "\n", "# elif method == \"r-squared\":", "\n", "#    outcome_mean = np.mean(self._outcome)", "\n", "#    total_variance = np.sum(np.square(self._outcome - outcome_mean))", "\n", "# Assuming a linear model with one variable: the treatment", "\n", "# Currently only works for continuous y", "\n", "#    causal_model = outcome_mean + estimate.value*self._treatment", "\n", "#    squared_residual = np.sum(np.square(self._outcome - causal_model))", "\n", "#    r_squared = 1 - (squared_residual/total_variance)", "\n", "#    return r_squared", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.update_input": [[622, 626], ["None"], "methods", ["None"], ["", "", "def", "update_input", "(", "self", ",", "treatment_value", ",", "control_value", ",", "target_units", ")", ":", "\n", "        ", "self", ".", "_control_value", "=", "control_value", "\n", "self", ".", "_treatment_value", "=", "treatment_value", "\n", "self", ".", "_target_units", "=", "target_units", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.is_bootstrap_parameter_changed": [[627, 645], ["bootstrap_estimates_params.items", "given_params.get"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "is_bootstrap_parameter_changed", "(", "bootstrap_estimates_params", ",", "given_params", ")", ":", "\n", "        ", "\"\"\" Check whether parameters of the bootstrap have changed.\n\n        This is an efficiency method that checks if fresh resampling of the bootstrap samples is required.\n        Returns True if parameters have changed and resampling should be done again.\n\n        :param bootstrap_estimates_params: A dictionary of parameters for the current bootstrap samples\n        :param given_params: A dictionary of parameters passed by the user\n        :returns: A binary flag denoting whether the parameters are different.\n        \"\"\"", "\n", "is_any_parameter_changed", "=", "False", "\n", "for", "prm", ",", "val", "in", "bootstrap_estimates_params", ".", "items", "(", ")", ":", "\n", "            ", "given_val", "=", "given_params", ".", "get", "(", "prm", ",", "None", ")", "\n", "if", "given_val", "is", "not", "None", "and", "given_val", "!=", "val", ":", "\n", "                ", "is_any_parameter_changed", "=", "True", "\n", "break", "\n", "", "", "return", "is_any_parameter_changed", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.target_units_tostr": [[646, 655], ["type", "callable", "isinstance"], "methods", ["None"], ["", "def", "target_units_tostr", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"\"", "\n", "if", "type", "(", "self", ".", "_target_units", ")", "is", "str", ":", "\n", "            ", "s", "+=", "self", ".", "_target_units", "\n", "", "elif", "callable", "(", "self", ".", "_target_units", ")", ":", "\n", "            ", "s", "+=", "\"Data subset defined by a function\"", "\n", "", "elif", "isinstance", "(", "self", ".", "_target_units", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "s", "+=", "\"Data subset provided as a data frame\"", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.signif_results_tostr": [[656, 664], ["type"], "methods", ["None"], ["", "def", "signif_results_tostr", "(", "self", ",", "signif_results", ")", ":", "\n", "        ", "s", "=", "\"\"", "\n", "pval", "=", "signif_results", "[", "\"p_value\"", "]", "\n", "if", "type", "(", "pval", ")", "is", "tuple", ":", "\n", "            ", "s", "+=", "\"[{0}, {1}]\"", ".", "format", "(", "pval", "[", "0", "]", ",", "pval", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "s", "+=", "\"{0}\"", ".", "format", "(", "pval", ")", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.__init__": [[671, 687], ["causal_estimator.CausalEstimate.params.items", "setattr"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "estimate", ",", "target_estimand", ",", "realized_estimand_expr", ",", "\n", "control_value", ",", "\n", "treatment_value", ",", "\n", "conditional_estimates", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "value", "=", "estimate", "\n", "self", ".", "target_estimand", "=", "target_estimand", "\n", "self", ".", "realized_estimand_expr", "=", "realized_estimand_expr", "\n", "self", ".", "control_value", "=", "control_value", "\n", "self", ".", "treatment_value", "=", "treatment_value", "\n", "self", ".", "conditional_estimates", "=", "conditional_estimates", "\n", "self", ".", "params", "=", "kwargs", "\n", "if", "self", ".", "params", "is", "not", "None", ":", "\n", "            ", "for", "key", ",", "value", "in", "self", ".", "params", ".", "items", "(", ")", ":", "\n", "                ", "setattr", "(", "self", ",", "key", ",", "value", ")", "\n", "\n", "", "", "self", ".", "effect_strength", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.add_estimator": [[688, 690], ["None"], "methods", ["None"], ["", "def", "add_estimator", "(", "self", ",", "estimator_instance", ")", ":", "\n", "        ", "self", ".", "estimator", "=", "estimator_instance", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.add_effect_strength": [[691, 693], ["None"], "methods", ["None"], ["", "def", "add_effect_strength", "(", "self", ",", "strength_dict", ")", ":", "\n", "        ", "self", ".", "effect_strength", "=", "strength_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.add_params": [[694, 696], ["causal_estimator.CausalEstimate.params.update"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update"], ["", "def", "add_params", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "params", ".", "update", "(", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.get_confidence_intervals": [[697, 717], ["causal_estimator.CausalEstimate.estimator.estimate_confidence_intervals"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_confidence_intervals"], ["", "def", "get_confidence_intervals", "(", "self", ",", "confidence_level", "=", "None", ",", "\n", "method", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Get confidence intervals of the obtained estimate.\n\n        By default, this is done with the help of bootstrapped confidence intervals\n        but can be overridden if the specific estimator implements other methods of estimating confidence intervals.\n\n        If the method provided is not bootstrap, this function calls the implementation of the specific estimator.\n\n        :param method: Method for estimating confidence intervals.\n        :param confidence_level: The confidence level of the confidence intervals of the estimate.\n        :param kwargs: Other optional args to be passed to the CI method.\n        :returns: The obtained confidence interval.\n        \"\"\"", "\n", "confidence_intervals", "=", "self", ".", "estimator", ".", "estimate_confidence_intervals", "(", "\n", "estimate_value", "=", "self", ".", "value", ",", "\n", "confidence_level", "=", "confidence_level", ",", "\n", "method", "=", "method", ",", "\n", "**", "kwargs", ")", "\n", "return", "confidence_intervals", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.get_standard_error": [[718, 733], ["causal_estimator.CausalEstimate.estimator.estimate_std_error"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_std_error"], ["", "def", "get_standard_error", "(", "self", ",", "method", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Get standard error of the obtained estimate.\n\n        By default, this is done with the help of bootstrapped standard errors\n        but can be overridden if the specific estimator implements other methods of estimating standard error.\n\n        If the method provided is not bootstrap, this function calls the implementation of the specific estimator.\n\n        :param method: Method for computing the standard error.\n        :param kwargs: Other optional parameters to be passed to the estimating method.\n        :returns: Standard error of the causal estimate.\n\n        \"\"\"", "\n", "std_error", "=", "self", ".", "estimator", ".", "estimate_std_error", "(", "method", "=", "method", ",", "**", "kwargs", ")", "\n", "return", "std_error", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.test_stat_significance": [[734, 751], ["causal_estimator.CausalEstimate.estimator.test_significance"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance"], ["", "def", "test_stat_significance", "(", "self", ",", "method", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Test statistical significance of the estimate obtained.\n\n        By default, uses resampling to create a non-parametric significance test.\n        Individual child estimators can implement different methods.\n        If the method name is different from \"bootstrap\", this function calls the\n        implementation of the child estimator.\n\n        :param method: Method for checking statistical significance\n        :param kwargs: Other optional parameters to be passed to the estimating method.\n\n        :returns: p-value from the significance test\n        \"\"\"", "\n", "signif_results", "=", "self", ".", "estimator", ".", "test_significance", "(", "self", ".", "value", ",", "\n", "method", "=", "method", ",", "\n", "**", "kwargs", ")", "\n", "return", "{", "'p_value'", ":", "signif_results", "[", "\"p_value\"", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.estimate_conditional_effects": [[752, 766], ["causal_estimator.CausalEstimate.estimator._estimate_conditional_effects"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_conditional_effects"], ["", "def", "estimate_conditional_effects", "(", "self", ",", "effect_modifiers", "=", "None", ",", "\n", "num_quantiles", "=", "CausalEstimator", ".", "NUM_QUANTILES_TO_DISCRETIZE_CONT_COLS", ")", ":", "\n", "        ", "\"\"\"Estimate treatment effect conditioned on given variables.\n\n        If a numeric effect modifier is provided, it is discretized into quantile bins. If you would like a custom discretization, you can do so yourself: create a new column containing the discretized effect modifier and then include that column's name in the effect_modifier_names argument.\n\n        :param effect_modifiers: Names of effect modifier variables over which the conditional effects will be estimated. If not provided, defaults to the effect modifiers specified during creation of the CausalEstimator object.\n        :param num_quantiles: The number of quantiles into which a numeric effect modifier variable is discretized. Does not affect any categorical effect modifiers.\n\n        :returns: A (multi-index) dataframe that provides separate effects for each value of the (discretized) effect modifiers.\n        \"\"\"", "\n", "return", "self", ".", "estimator", ".", "_estimate_conditional_effects", "(", "\n", "self", ".", "estimator", ".", "_estimate_effect_fn", ",", "\n", "effect_modifiers", ",", "num_quantiles", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.interpret": [[767, 783], ["dowhy.utils.api.parse_state", "dowhy.get_class_object", "dowhy.get_class_object.interpret", "dowhy.get_class_object."], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.interpret"], ["", "def", "interpret", "(", "self", ",", "method_name", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Interpret the causal estimate.\n\n        :param method_name: Method used (string) or a list of methods. If None, then the default for the specific estimator is used.\n        :param kwargs:: Optional parameters that are directly passed to the interpreter method.\n\n        :returns: None\n\n        \"\"\"", "\n", "if", "method_name", "is", "None", ":", "\n", "            ", "method_name", "=", "self", ".", "estimator", ".", "interpret_method", "\n", "", "method_name_arr", "=", "parse_state", "(", "method_name", ")", "\n", "\n", "for", "method", "in", "method_name_arr", ":", "\n", "            ", "interpreter", "=", "interpreters", ".", "get_class_object", "(", "method", ")", "\n", "interpreter", "(", "self", ",", "**", "kwargs", ")", ".", "interpret", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.__str__": [[784, 812], ["hasattr", "hasattr", "hasattr", "causal_estimator.CausalEstimate.target_estimand.__str__", "str", "causal_estimator.CausalEstimate.estimator.target_units_tostr", "causal_estimator.CausalEstimate.estimator.signif_results_tostr", "causal_estimator.CausalEstimate.get_confidence_intervals", "causal_estimator.CausalEstimate.test_stat_significance"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.target_units_tostr", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.signif_results_tostr", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.get_confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.test_stat_significance"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"*** Causal Estimate ***\\n\"", "\n", "# No estimand was identified (identification failed)", "\n", "if", "self", ".", "target_estimand", "is", "None", ":", "\n", "            ", "return", "\"Estimation failed! No relevant identified estimand available for this estimation method.\"", "\n", "", "s", "+=", "\"\\n## Identified estimand\\n{0}\"", ".", "format", "(", "self", ".", "target_estimand", ".", "__str__", "(", "only_target_estimand", "=", "True", ")", ")", "\n", "s", "+=", "\"\\n## Realized estimand\\n{0}\"", ".", "format", "(", "self", ".", "realized_estimand_expr", ")", "\n", "if", "hasattr", "(", "self", ",", "\"estimator\"", ")", ":", "\n", "            ", "s", "+=", "\"\\nTarget units: {0}\\n\"", ".", "format", "(", "self", ".", "estimator", ".", "target_units_tostr", "(", ")", ")", "\n", "", "s", "+=", "\"\\n## Estimate\\n\"", "\n", "s", "+=", "\"Mean value: {0}\\n\"", ".", "format", "(", "self", ".", "value", ")", "\n", "s", "+=", "\"\"", "\n", "if", "hasattr", "(", "self", ",", "\"cate_estimates\"", ")", ":", "\n", "            ", "s", "+=", "\"Effect estimates: {0}\\n\"", ".", "format", "(", "self", ".", "cate_estimates", ")", "\n", "", "if", "hasattr", "(", "self", ",", "\"estimator\"", ")", ":", "\n", "            ", "if", "self", ".", "estimator", ".", "_significance_test", ":", "\n", "                ", "s", "+=", "\"p-value: {0}\\n\"", ".", "format", "(", "self", ".", "estimator", ".", "signif_results_tostr", "(", "self", ".", "test_stat_significance", "(", ")", ")", ")", "\n", "", "if", "self", ".", "estimator", ".", "_confidence_intervals", ":", "\n", "                ", "s", "+=", "\"{0}% confidence interval: {1}\\n\"", ".", "format", "(", "100", "*", "self", ".", "estimator", ".", "confidence_level", ",", "\n", "self", ".", "get_confidence_intervals", "(", ")", ")", "\n", "", "", "if", "self", ".", "conditional_estimates", "is", "not", "None", ":", "\n", "            ", "s", "+=", "\"### Conditional Estimates\\n\"", "\n", "s", "+=", "str", "(", "self", ".", "conditional_estimates", ")", "\n", "", "if", "self", ".", "effect_strength", "is", "not", "None", ":", "\n", "            ", "s", "+=", "\"\\n## Effect Strength\\n\"", "\n", "s", "+=", "\"Change in outcome attributable to treatment: {}\\n\"", ".", "format", "(", "self", ".", "effect_strength", "[", "\"fraction-effect\"", "]", ")", "\n", "# s += \"Variance in outcome explained by treatment: {}\\n\".format(self.effect_strength[\"r-squared\"])", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.RealizedEstimand.__init__": [[816, 825], ["identified_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["    ", "def", "__init__", "(", "self", ",", "identified_estimand", ",", "estimator_name", ")", ":", "\n", "        ", "self", ".", "treatment_variable", "=", "identified_estimand", ".", "treatment_variable", "\n", "self", ".", "outcome_variable", "=", "identified_estimand", ".", "outcome_variable", "\n", "self", ".", "backdoor_variables", "=", "identified_estimand", ".", "get_backdoor_variables", "(", ")", "\n", "self", ".", "instrumental_variables", "=", "identified_estimand", ".", "instrumental_variables", "\n", "self", ".", "estimand_type", "=", "identified_estimand", ".", "estimand_type", "\n", "self", ".", "estimand_expression", "=", "None", "\n", "self", ".", "assumptions", "=", "None", "\n", "self", ".", "estimator_name", "=", "estimator_name", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.RealizedEstimand.update_assumptions": [[826, 828], ["None"], "methods", ["None"], ["", "def", "update_assumptions", "(", "self", ",", "estimator_assumptions", ")", ":", "\n", "        ", "self", ".", "assumptions", "=", "estimator_assumptions", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.RealizedEstimand.update_estimand_expression": [[829, 831], ["None"], "methods", ["None"], ["", "def", "update_estimand_expression", "(", "self", ",", "estimand_expression", ")", ":", "\n", "        ", "self", ".", "estimand_expression", "=", "estimand_expression", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.RealizedEstimand.__str__": [[832, 841], ["causal_estimator.RealizedEstimand.assumptions.items", "sympy.pretty"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"Realized estimand: {0}\\n\"", ".", "format", "(", "self", ".", "estimator_name", ")", "\n", "s", "+=", "\"Realized estimand type: {0}\\n\"", ".", "format", "(", "self", ".", "estimand_type", ")", "\n", "s", "+=", "\"Estimand expression:\\n{0}\\n\"", ".", "format", "(", "sp", ".", "pretty", "(", "self", ".", "estimand_expression", ")", ")", "\n", "j", "=", "1", "\n", "for", "ass_name", ",", "ass_str", "in", "self", ".", "assumptions", ".", "items", "(", ")", ":", "\n", "            ", "s", "+=", "\"Estimand assumption {0}, {1}: {2}\\n\"", ".", "format", "(", "j", ",", "ass_name", ",", "ass_str", ")", "\n", "j", "+=", "1", "\n", "", "return", "s", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.plotter.plot_treatment_outcome": [[9, 26], ["matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.subplots", "ax.plot", "ax.plot", "ax.legend", "matplotlib.xlabel", "fig.set_size_inches", "fig.savefig", "datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot"], ["def", "plot_treatment_outcome", "(", "treatment", ",", "outcome", ",", "time_var", ")", ":", "\n", "    ", "plt", ".", "rc", "(", "'font'", ",", "size", "=", "SMALL_SIZE", ")", "# controls default text sizes", "\n", "plt", ".", "rc", "(", "'axes'", ",", "titlesize", "=", "BIGGER_SIZE", ")", "# fontsize of the axes title", "\n", "plt", ".", "rc", "(", "'axes'", ",", "labelsize", "=", "MEDIUM_SIZE", ")", "# fontsize of the x and y labels", "\n", "plt", ".", "rc", "(", "'xtick'", ",", "labelsize", "=", "MEDIUM_SIZE", ")", "# fontsize of the tick labels", "\n", "plt", ".", "rc", "(", "'ytick'", ",", "labelsize", "=", "MEDIUM_SIZE", ")", "# fontsize of the tick labels", "\n", "plt", ".", "rc", "(", "'legend'", ",", "fontsize", "=", "MEDIUM_SIZE", ")", "# legend fontsize", "\n", "plt", ".", "rc", "(", "'figure'", ",", "titlesize", "=", "BIGGER_SIZE", ")", "# fontsize of the figure title", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "tline", "=", "ax", ".", "plot", "(", "time_var", ",", "treatment", ",", "'o'", ",", "label", "=", "\"Treatment\"", ")", "\n", "oline", "=", "ax", ".", "plot", "(", "time_var", ",", "outcome", ",", "'r^'", ",", "label", "=", "\"Outcome\"", ")", "\n", "\n", "ax", ".", "legend", "(", "loc", "=", "\"upper left\"", ",", "bbox_to_anchor", "=", "(", "1.04", ",", "1", ")", ")", "\n", "plt", ".", "xlabel", "(", "\"Time\"", ")", "\n", "fig", ".", "set_size_inches", "(", "8", ",", "6", ")", "\n", "fig", ".", "savefig", "(", "\"obs_data\"", "+", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%H-%M-%S\"", ")", "+", "\".png\"", ",", "\n", "bbox_inches", "=", "\"tight\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.plotter.plot_causal_effect": [[28, 57], ["matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.subplots", "max", "ax.scatter", "ax.plot", "ax.set_ylim", "ax.set_xlim", "dict", "ax.text", "ax.legend", "matplotlib.xlabel", "matplotlib.ylabel", "fig.set_size_inches", "fig.savefig", "max", "str", "round", "datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot"], ["", "def", "plot_causal_effect", "(", "estimate", ",", "treatment", ",", "outcome", ")", ":", "\n", "    ", "plt", ".", "rc", "(", "'font'", ",", "size", "=", "SMALL_SIZE", ")", "# controls default text sizes", "\n", "plt", ".", "rc", "(", "'axes'", ",", "titlesize", "=", "BIGGER_SIZE", ")", "# fontsize of the axes title", "\n", "plt", ".", "rc", "(", "'axes'", ",", "labelsize", "=", "MEDIUM_SIZE", ")", "# fontsize of the x and y labels", "\n", "plt", ".", "rc", "(", "'xtick'", ",", "labelsize", "=", "MEDIUM_SIZE", ")", "# fontsize of the tick labels", "\n", "plt", ".", "rc", "(", "'ytick'", ",", "labelsize", "=", "MEDIUM_SIZE", ")", "# fontsize of the tick labels", "\n", "plt", ".", "rc", "(", "'legend'", ",", "fontsize", "=", "MEDIUM_SIZE", ")", "# legend fontsize", "\n", "plt", ".", "rc", "(", "'figure'", ",", "titlesize", "=", "BIGGER_SIZE", ")", "# fontsize of the figure title", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "x_min", "=", "0", "\n", "x_max", "=", "max", "(", "treatment", ")", "\n", "y_min", "=", "estimate", ".", "params", "[", "\"intercept\"", "]", "\n", "y_max", "=", "y_min", "+", "estimate", ".", "value", "*", "(", "x_max", "-", "x_min", ")", "\n", "ax", ".", "scatter", "(", "treatment", ",", "outcome", ",", "c", "=", "\"gray\"", ",", "marker", "=", "\"o\"", ",", "label", "=", "\"Observed data\"", ")", "\n", "ax", ".", "plot", "(", "[", "x_min", ",", "x_max", "]", ",", "[", "y_min", ",", "y_max", "]", ",", "c", "=", "\"black\"", ",", "ls", "=", "\"solid\"", ",", "lw", "=", "4", ",", "\n", "label", "=", "\"Causal variation\"", ")", "\n", "ax", ".", "set_ylim", "(", "0", ",", "max", "(", "outcome", ")", ")", "\n", "ax", ".", "set_xlim", "(", "0", ",", "x_max", ")", "\n", "\n", "bbox_props", "=", "dict", "(", "boxstyle", "=", "\"round\"", ",", "fc", "=", "\"w\"", ",", "ec", "=", "\"0.5\"", ",", "alpha", "=", "0.9", ")", "\n", "ax", ".", "text", "(", "10.8", ",", "1", ",", "r\"DoWhy estimate $\\rho$ (slope) = \"", "+", "str", "(", "round", "(", "estimate", ".", "value", ",", "2", ")", ")", ",", "\n", "ha", "=", "\"right\"", ",", "va", "=", "\"bottom\"", ",", "size", "=", "20", ",", "bbox", "=", "bbox_props", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "\"upper left\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Treatment\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Outcome\"", ")", "\n", "\n", "fig", ".", "set_size_inches", "(", "8", ",", "6", ")", "\n", "fig", ".", "savefig", "(", "\"effect\"", "+", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%H-%M-%S\"", ")", "+", "\".png\"", ",", "\n", "bbox_inches", "=", "'tight'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.data_transformer.DimensionalityReducer.__init__": [[3, 6], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "data_array", ",", "ndims", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "_data", "=", "data_array", "\n", "self", ".", "_ndims", "=", "ndims", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.data_transformer.DimensionalityReducer.reduce": [[7, 9], ["None"], "methods", ["None"], ["", "def", "reduce", "(", "self", ",", "target_dimensions", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplementedError", "", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.__init__": [[18, 93], ["dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "logging.getLogger", "isinstance", "causal_graph.CausalGraph.add_node_attributes", "isinstance", "re.match", "open", "open.read", "open.close", "isinstance", "re.match", "dowhy.utils.graph_operations.daggity_to_dot", "graph.replace.replace.replace", "networkx.DiGraph", "causal_graph.CausalGraph.build_graph", "re.match", "causal_graph.CausalGraph.add_missing_nodes_as_common_causes", "str", "re.match", "networkx.DiGraph", "networkx.DiGraph", "re.match", "networkx.drawing.nx_agraph.read_dot", "causal_graph.CausalGraph.logger.error", "networkx.read_gml", "re.match", "networkx.DiGraph", "pgv.AGraph", "networkx.drawing.nx_agraph.from_agraph", "networkx.DiGraph", "causal_graph.CausalGraph.logger.error", "causal_graph.CausalGraph.logger.error", "networkx.drawing.nx_pydot.read_dot", "causal_graph.CausalGraph.logger.error", "causal_graph.CausalGraph.logger.error", "networkx.parse_gml", "str", "pydot.graph_from_dot_data", "networkx.drawing.nx_pydot.from_pydot", "str", "causal_graph.CausalGraph.logger.error", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.add_node_attributes", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.daggity_to_dot", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.build_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.add_missing_nodes_as_common_causes"], ["def", "__init__", "(", "self", ",", "\n", "treatment_name", ",", "outcome_name", ",", "\n", "graph", "=", "None", ",", "\n", "common_cause_names", "=", "None", ",", "\n", "instrument_names", "=", "None", ",", "\n", "effect_modifier_names", "=", "None", ",", "\n", "mediator_names", "=", "None", ",", "\n", "observed_node_names", "=", "None", ",", "\n", "missing_nodes_as_confounders", "=", "False", ")", ":", "\n", "        ", "self", ".", "treatment_name", "=", "parse_state", "(", "treatment_name", ")", "\n", "self", ".", "outcome_name", "=", "parse_state", "(", "outcome_name", ")", "\n", "instrument_names", "=", "parse_state", "(", "instrument_names", ")", "\n", "common_cause_names", "=", "parse_state", "(", "common_cause_names", ")", "\n", "effect_modifier_names", "=", "parse_state", "(", "effect_modifier_names", ")", "\n", "mediator_names", "=", "parse_state", "(", "mediator_names", ")", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "#re.sub only takes string parameter so the first if is to avoid error", "\n", "#if the input is a text file, convert the contained data into string", "\n", "if", "isinstance", "(", "graph", ",", "str", ")", "and", "re", ".", "match", "(", "r\".*\\.txt\"", ",", "str", "(", "graph", ")", ")", ":", "\n", "            ", "text_file", "=", "open", "(", "graph", ",", "\"r\"", ")", "\n", "graph", "=", "text_file", ".", "read", "(", ")", "\n", "text_file", ".", "close", "(", ")", "\n", "\n", "", "if", "isinstance", "(", "graph", ",", "str", ")", "and", "re", ".", "match", "(", "r\"^dag\"", ",", "graph", ")", ":", "#Convert daggity output to dot format ", "\n", "            ", "graph", "=", "daggity_to_dot", "(", "graph", ")", "\n", "\n", "", "if", "isinstance", "(", "graph", ",", "str", ")", ":", "\n", "            ", "graph", "=", "graph", ".", "replace", "(", "\"\\n\"", ",", "\" \"", ")", "\n", "\n", "", "if", "graph", "is", "None", ":", "\n", "            ", "self", ".", "_graph", "=", "nx", ".", "DiGraph", "(", ")", "\n", "self", ".", "_graph", "=", "self", ".", "build_graph", "(", "common_cause_names", ",", "\n", "instrument_names", ",", "\n", "effect_modifier_names", ",", "\n", "mediator_names", ")", "\n", "", "elif", "re", ".", "match", "(", "r\".*\\.dot\"", ",", "graph", ")", ":", "\n", "# load dot file", "\n", "            ", "try", ":", "\n", "                ", "import", "pygraphviz", "as", "pgv", "\n", "self", ".", "_graph", "=", "nx", ".", "DiGraph", "(", "nx", ".", "drawing", ".", "nx_agraph", ".", "read_dot", "(", "graph", ")", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "self", ".", "logger", ".", "error", "(", "\"Pygraphviz cannot be loaded. \"", "+", "str", "(", "e", ")", "+", "\"\\nTrying pydot...\"", ")", "\n", "try", ":", "\n", "                    ", "import", "pydot", "\n", "self", ".", "_graph", "=", "nx", ".", "DiGraph", "(", "nx", ".", "drawing", ".", "nx_pydot", ".", "read_dot", "(", "graph", ")", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                    ", "self", ".", "logger", ".", "error", "(", "\"Error: Pydot cannot be loaded. \"", "+", "str", "(", "e", ")", ")", "\n", "raise", "e", "\n", "", "", "", "elif", "re", ".", "match", "(", "r\".*\\.gml\"", ",", "graph", ")", ":", "\n", "            ", "self", ".", "_graph", "=", "nx", ".", "DiGraph", "(", "nx", ".", "read_gml", "(", "graph", ")", ")", "\n", "", "elif", "re", ".", "match", "(", "r\".*graph\\s*\\{.*\\}\\s*\"", ",", "graph", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "import", "pygraphviz", "as", "pgv", "\n", "self", ".", "_graph", "=", "pgv", ".", "AGraph", "(", "graph", ",", "strict", "=", "True", ",", "directed", "=", "True", ")", "\n", "self", ".", "_graph", "=", "nx", ".", "drawing", ".", "nx_agraph", ".", "from_agraph", "(", "self", ".", "_graph", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "self", ".", "logger", ".", "error", "(", "\"Error: Pygraphviz cannot be loaded. \"", "+", "str", "(", "e", ")", "+", "\"\\nTrying pydot ...\"", ")", "\n", "try", ":", "\n", "                    ", "import", "pydot", "\n", "P_list", "=", "pydot", ".", "graph_from_dot_data", "(", "graph", ")", "\n", "self", ".", "_graph", "=", "nx", ".", "drawing", ".", "nx_pydot", ".", "from_pydot", "(", "P_list", "[", "0", "]", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                    ", "self", ".", "logger", ".", "error", "(", "\"Error: Pydot cannot be loaded. \"", "+", "str", "(", "e", ")", ")", "\n", "raise", "e", "\n", "", "", "", "elif", "re", ".", "match", "(", "\".*graph\\s*\\[.*\\]\\s*\"", ",", "graph", ")", ":", "\n", "            ", "self", ".", "_graph", "=", "nx", ".", "DiGraph", "(", "nx", ".", "parse_gml", "(", "graph", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "logger", ".", "error", "(", "\"Error: Please provide graph (as string or text file) in dot or gml format.\"", ")", "\n", "self", ".", "logger", ".", "error", "(", "\"Error: Incorrect graph format\"", ")", "\n", "raise", "ValueError", "\n", "", "if", "missing_nodes_as_confounders", ":", "\n", "            ", "self", ".", "_graph", "=", "self", ".", "add_missing_nodes_as_common_causes", "(", "observed_node_names", ")", "\n", "# Adding node attributes", "\n", "", "self", ".", "_graph", "=", "self", ".", "add_node_attributes", "(", "observed_node_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.view_graph": [[94, 131], ["networkx.drawing.nx_agraph.to_agraph", "networkx.drawing.nx_agraph.to_agraph.graph_attr.update", "networkx.drawing.nx_agraph.to_agraph.draw", "causal_graph.CausalGraph.logger.warning", "causal_graph.CausalGraph.logger.info", "plt.figure", "plt.clf", "networkx.layout.shell_layout", "networkx.draw_networkx_nodes", "networkx.draw_networkx_edges", "networkx.draw_networkx_edges", "networkx.draw_networkx_labels", "plt.axis", "plt.savefig", "plt.draw", "causal_graph.CausalGraph._graph.edges", "causal_graph.CausalGraph._graph.edges"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasEdges.edges", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasEdges.edges"], ["", "def", "view_graph", "(", "self", ",", "layout", "=", "\"dot\"", ",", "size", "=", "(", "8", ",", "6", ")", ",", "file_name", "=", "\"causal_model\"", ")", ":", "\n", "        ", "out_filename", "=", "\"{}.png\"", ".", "format", "(", "file_name", ")", "\n", "try", ":", "\n", "            ", "import", "pygraphviz", "as", "pgv", "\n", "agraph", "=", "nx", ".", "drawing", ".", "nx_agraph", ".", "to_agraph", "(", "self", ".", "_graph", ")", "\n", "agraph", ".", "graph_attr", ".", "update", "(", "size", "=", "\"{},{}!\"", ".", "format", "(", "size", "[", "0", "]", ",", "size", "[", "0", "]", ")", ")", "\n", "agraph", ".", "draw", "(", "out_filename", ",", "format", "=", "\"png\"", ",", "prog", "=", "layout", ")", "\n", "", "except", ":", "\n", "            ", "self", ".", "logger", ".", "warning", "(", "\"Warning: Pygraphviz cannot be loaded. Check that graphviz and pygraphviz are installed.\"", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Using Matplotlib for plotting\"", ")", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "plt", ".", "figure", "(", "figsize", "=", "size", ")", "\n", "solid_edges", "=", "[", "(", "n1", ",", "n2", ")", "for", "n1", ",", "n2", ",", "e", "in", "self", ".", "_graph", ".", "edges", "(", "data", "=", "True", ")", "if", "'style'", "not", "in", "e", "]", "\n", "dashed_edges", "=", "[", "(", "n1", ",", "n2", ")", "for", "n1", ",", "n2", ",", "e", "in", "self", ".", "_graph", ".", "edges", "(", "data", "=", "True", ")", "if", "(", "'style'", "in", "e", "and", "e", "[", "'style'", "]", "==", "\"dashed\"", ")", "]", "\n", "plt", ".", "clf", "(", ")", "\n", "\n", "pos", "=", "nx", ".", "layout", ".", "shell_layout", "(", "self", ".", "_graph", ")", "\n", "nx", ".", "draw_networkx_nodes", "(", "self", ".", "_graph", ",", "pos", ",", "node_color", "=", "'yellow'", ",", "node_size", "=", "400", ")", "\n", "nx", ".", "draw_networkx_edges", "(", "\n", "self", ".", "_graph", ",", "\n", "pos", ",", "\n", "edgelist", "=", "solid_edges", ",", "\n", "arrowstyle", "=", "\"-|>\"", ",", "\n", "arrowsize", "=", "12", ")", "\n", "nx", ".", "draw_networkx_edges", "(", "\n", "self", ".", "_graph", ",", "\n", "pos", ",", "\n", "edgelist", "=", "dashed_edges", ",", "\n", "arrowstyle", "=", "\"-|>\"", ",", "\n", "style", "=", "\"dashed\"", ",", "\n", "arrowsize", "=", "12", ")", "\n", "\n", "labels", "=", "nx", ".", "draw_networkx_labels", "(", "self", ".", "_graph", ",", "pos", ")", "\n", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "savefig", "(", "out_filename", ")", "\n", "plt", ".", "draw", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.build_graph": [[132, 186], ["itertools.product", "causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph._graph.add_edge", "itertools.product", "type", "itertools.product", "itertools.product", "itertools.product", "causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph._graph.add_edge", "causal_graph.CausalGraph._graph.add_edge", "len", "causal_graph.CausalGraph.logger.info", "causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph._graph.add_edge", "causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph._graph.add_edge", "causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph._graph.add_edge", "causal_graph.CausalGraph._graph.add_edge", "causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph._graph.add_edge"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge"], ["", "", "def", "build_graph", "(", "self", ",", "common_cause_names", ",", "instrument_names", ",", "\n", "effect_modifier_names", ",", "mediator_names", ")", ":", "\n", "        ", "\"\"\" Creates nodes and edges based on variable names and their semantics.\n\n        Currently only considers the graphical representation of \"direct\" effect modifiers. Thus, all effect modifiers are assumed to be \"direct\" unless otherwise expressed using a graph. Based on the taxonomy of effect modifiers by VanderWheele and Robins: \"Four types of effect modification: A classification based on directed acyclic graphs. Epidemiology. 2007.\"\n        \"\"\"", "\n", "\n", "for", "treatment", "in", "self", ".", "treatment_name", ":", "\n", "            ", "self", ".", "_graph", ".", "add_node", "(", "treatment", ",", "observed", "=", "\"yes\"", ",", "penwidth", "=", "2", ")", "\n", "", "for", "outcome", "in", "self", ".", "outcome_name", ":", "\n", "            ", "self", ".", "_graph", ".", "add_node", "(", "outcome", ",", "observed", "=", "\"yes\"", ",", "penwidth", "=", "2", ")", "\n", "", "for", "treatment", ",", "outcome", "in", "itertools", ".", "product", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", ":", "\n", "# adding penwidth to make the edge bold", "\n", "            ", "self", ".", "_graph", ".", "add_edge", "(", "treatment", ",", "outcome", ",", "penwidth", "=", "2", ")", "\n", "\n", "# Adding common causes", "\n", "", "if", "common_cause_names", "is", "not", "None", ":", "\n", "            ", "for", "node_name", "in", "common_cause_names", ":", "\n", "                ", "for", "treatment", ",", "outcome", "in", "itertools", ".", "product", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", ":", "\n", "                    ", "self", ".", "_graph", ".", "add_node", "(", "node_name", ",", "observed", "=", "\"yes\"", ")", "\n", "self", ".", "_graph", ".", "add_edge", "(", "node_name", ",", "treatment", ")", "\n", "self", ".", "_graph", ".", "add_edge", "(", "node_name", ",", "outcome", ")", "\n", "\n", "# Adding instruments", "\n", "", "", "", "if", "instrument_names", ":", "\n", "            ", "if", "type", "(", "instrument_names", "[", "0", "]", ")", "!=", "tuple", ":", "\n", "                ", "if", "len", "(", "self", ".", "treatment_name", ")", ">", "1", ":", "\n", "                    ", "self", ".", "logger", ".", "info", "(", "\"Assuming Instrument points to all treatments! Use tuples for more granularity.\"", ")", "\n", "", "for", "instrument", ",", "treatment", "in", "itertools", ".", "product", "(", "instrument_names", ",", "self", ".", "treatment_name", ")", ":", "\n", "                    ", "self", ".", "_graph", ".", "add_node", "(", "instrument", ",", "observed", "=", "\"yes\"", ")", "\n", "self", ".", "_graph", ".", "add_edge", "(", "instrument", ",", "treatment", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "instrument", ",", "treatment", "in", "itertools", ".", "product", "(", "instrument_names", ")", ":", "\n", "                    ", "self", ".", "_graph", ".", "add_node", "(", "instrument", ",", "observed", "=", "\"yes\"", ")", "\n", "self", ".", "_graph", ".", "add_edge", "(", "instrument", ",", "treatment", ")", "\n", "\n", "# Adding effect modifiers", "\n", "", "", "", "if", "effect_modifier_names", "is", "not", "None", ":", "\n", "            ", "for", "node_name", "in", "effect_modifier_names", ":", "\n", "                ", "if", "node_name", "not", "in", "common_cause_names", ":", "\n", "                    ", "for", "outcome", "in", "self", ".", "outcome_name", ":", "\n", "                        ", "self", ".", "_graph", ".", "add_node", "(", "node_name", ",", "observed", "=", "\"yes\"", ")", "\n", "# Assuming the simple form of effect modifier", "\n", "# that directly causes the outcome.", "\n", "self", ".", "_graph", ".", "add_edge", "(", "node_name", ",", "outcome", ")", "\n", "#self._graph.add_edge(node_name, outcome, style = \"dotted\", headport=\"s\", tailport=\"n\")", "\n", "#self._graph.add_edge(outcome, node_name, style = \"dotted\", headport=\"n\", tailport=\"s\") # TODO make the ports more general so that they apply not just to top-bottom node configurations", "\n", "", "", "", "", "if", "mediator_names", "is", "not", "None", ":", "\n", "            ", "for", "node_name", "in", "mediator_names", ":", "\n", "                ", "for", "treatment", ",", "outcome", "in", "itertools", ".", "product", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", ":", "\n", "                    ", "self", ".", "_graph", ".", "add_node", "(", "node_name", ",", "observed", "=", "\"yes\"", ")", "\n", "self", ".", "_graph", ".", "add_edge", "(", "treatment", ",", "node_name", ")", "\n", "self", ".", "_graph", ".", "add_edge", "(", "node_name", ",", "outcome", ")", "\n", "", "", "", "return", "self", ".", "_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.add_node_attributes": [[187, 194], ["None"], "methods", ["None"], ["", "def", "add_node_attributes", "(", "self", ",", "observed_node_names", ")", ":", "\n", "        ", "for", "node_name", "in", "self", ".", "_graph", ":", "\n", "            ", "if", "node_name", "in", "observed_node_names", ":", "\n", "                ", "self", ".", "_graph", ".", "nodes", "[", "node_name", "]", "[", "\"observed\"", "]", "=", "\"yes\"", "\n", "", "else", ":", "\n", "                ", "self", ".", "_graph", ".", "nodes", "[", "node_name", "]", "[", "\"observed\"", "]", "=", "\"no\"", "\n", "", "", "return", "self", ".", "_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.add_missing_nodes_as_common_causes": [[195, 203], ["causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph._graph.add_edge"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge"], ["", "def", "add_missing_nodes_as_common_causes", "(", "self", ",", "observed_node_names", ")", ":", "\n", "# Adding columns in the dataframe as confounders that were not in the graph", "\n", "        ", "for", "node_name", "in", "observed_node_names", ":", "\n", "            ", "if", "node_name", "not", "in", "self", ".", "_graph", ":", "\n", "                ", "self", ".", "_graph", ".", "add_node", "(", "node_name", ",", "observed", "=", "\"yes\"", ")", "\n", "for", "treatment_outcome_node", "in", "self", ".", "treatment_name", "+", "self", ".", "outcome_name", ":", "\n", "                    ", "self", ".", "_graph", ".", "add_edge", "(", "node_name", ",", "treatment_outcome_node", ")", "\n", "", "", "", "return", "self", ".", "_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.add_unobserved_common_cause": [[204, 220], ["causal_graph.CausalGraph.get_common_causes", "causal_graph.CausalGraph._graph.add_node", "causal_graph.CausalGraph.logger.info", "causal_graph.CausalGraph._graph.add_edge"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge"], ["", "def", "add_unobserved_common_cause", "(", "self", ",", "observed_node_names", ",", "color", "=", "\"gray\"", ")", ":", "\n", "# Adding unobserved confounders", "\n", "        ", "current_common_causes", "=", "self", ".", "get_common_causes", "(", "self", ".", "treatment_name", ",", "\n", "self", ".", "outcome_name", ")", "\n", "create_new_common_cause", "=", "True", "\n", "for", "node_name", "in", "current_common_causes", ":", "\n", "            ", "if", "self", ".", "_graph", ".", "nodes", "[", "node_name", "]", "[", "\"observed\"", "]", "==", "\"no\"", ":", "\n", "                ", "create_new_common_cause", "=", "False", "\n", "", "", "if", "create_new_common_cause", ":", "\n", "            ", "uc_label", "=", "\"Unobserved Confounders\"", "\n", "self", ".", "_graph", ".", "add_node", "(", "'U'", ",", "label", "=", "uc_label", ",", "observed", "=", "\"no\"", ",", "\n", "color", "=", "color", ",", "style", "=", "\"filled\"", ",", "fillcolor", "=", "color", ")", "\n", "for", "node", "in", "self", ".", "treatment_name", "+", "self", ".", "outcome_name", ":", "\n", "                ", "self", ".", "_graph", ".", "add_edge", "(", "'U'", ",", "node", ")", "\n", "", "self", ".", "logger", ".", "info", "(", "'If this is observed data (not from a randomized experiment), there might always be missing confounders. Adding a node named \"Unobserved Confounders\" to reflect this.'", ")", "\n", "", "return", "self", ".", "_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_unconfounded_observed_subgraph": [[221, 224], ["causal_graph.CausalGraph._graph.subgraph", "causal_graph.CausalGraph._graph.nodes"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes"], ["", "def", "get_unconfounded_observed_subgraph", "(", "self", ")", ":", "\n", "        ", "observed_nodes", "=", "[", "node", "for", "node", "in", "self", ".", "_graph", ".", "nodes", "(", ")", "if", "self", ".", "_graph", ".", "nodes", "[", "node", "]", "[", "\"observed\"", "]", "==", "\"yes\"", "]", "\n", "return", "self", ".", "_graph", ".", "subgraph", "(", "observed_nodes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.do_surgery": [[225, 239], ["dowhy.utils.api.parse_state", "causal_graph.CausalGraph._graph.copy", "causal_graph.CausalGraph.successors", "causal_graph.CausalGraph.remove_edges_from", "causal_graph.CausalGraph.predecessors", "causal_graph.CausalGraph.remove_edges_from"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.DirectedGraph.predecessors"], ["", "def", "do_surgery", "(", "self", ",", "node_names", ",", "remove_outgoing_edges", "=", "False", ",", "\n", "remove_incoming_edges", "=", "False", ")", ":", "\n", "        ", "node_names", "=", "parse_state", "(", "node_names", ")", "\n", "new_graph", "=", "self", ".", "_graph", ".", "copy", "(", ")", "\n", "for", "node_name", "in", "node_names", ":", "\n", "            ", "if", "remove_outgoing_edges", ":", "\n", "                ", "children", "=", "new_graph", ".", "successors", "(", "node_name", ")", "\n", "edges_bunch", "=", "[", "(", "node_name", ",", "child", ")", "for", "child", "in", "children", "]", "\n", "new_graph", ".", "remove_edges_from", "(", "edges_bunch", ")", "\n", "", "if", "remove_incoming_edges", ":", "\n", "                ", "parents", "=", "new_graph", ".", "predecessors", "(", "node_name", ")", "\n", "edges_bunch", "=", "[", "(", "parent", ",", "node_name", ")", "for", "parent", "in", "parents", "]", "\n", "new_graph", ".", "remove_edges_from", "(", "edges_bunch", ")", "\n", "", "", "return", "new_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_causes": [[240, 254], ["dowhy.utils.api.parse_state", "set", "causal_graph.CausalGraph._graph.copy", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "causes.union.union.union", "causal_graph.CausalGraph.get_ancestors", "causal_graph.CausalGraph.remove_edge"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_ancestors"], ["", "def", "get_causes", "(", "self", ",", "nodes", ",", "remove_edges", "=", "None", ")", ":", "\n", "        ", "nodes", "=", "parse_state", "(", "nodes", ")", "\n", "new_graph", "=", "None", "\n", "if", "remove_edges", "is", "not", "None", ":", "\n", "            ", "new_graph", "=", "self", ".", "_graph", ".", "copy", "(", ")", "# caution: shallow copy of the attributes", "\n", "sources", "=", "parse_state", "(", "remove_edges", "[", "\"sources\"", "]", ")", "\n", "targets", "=", "parse_state", "(", "remove_edges", "[", "\"targets\"", "]", ")", "\n", "for", "s", "in", "sources", ":", "\n", "                ", "for", "t", "in", "targets", ":", "\n", "                    ", "new_graph", ".", "remove_edge", "(", "s", ",", "t", ")", "\n", "", "", "", "causes", "=", "set", "(", ")", "\n", "for", "v", "in", "nodes", ":", "\n", "            ", "causes", "=", "causes", ".", "union", "(", "self", ".", "get_ancestors", "(", "v", ",", "new_graph", "=", "new_graph", ")", ")", "\n", "", "return", "causes", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_dseparation": [[255, 265], ["networkx.algorithms.d_separated", "ValueError", "set", "set", "set"], "methods", ["None"], ["", "def", "check_dseparation", "(", "self", ",", "nodes1", ",", "nodes2", ",", "nodes3", ",", "new_graph", "=", "None", ",", "\n", "dseparation_algo", "=", "\"default\"", ")", ":", "\n", "        ", "if", "dseparation_algo", "==", "\"default\"", ":", "\n", "            ", "if", "new_graph", "is", "None", ":", "\n", "                ", "new_graph", "=", "self", ".", "_graph", "\n", "", "dseparated", "=", "nx", ".", "algorithms", ".", "d_separated", "(", "new_graph", ",", "\n", "set", "(", "nodes1", ")", ",", "set", "(", "nodes2", ")", ",", "set", "(", "nodes3", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"{dseparation_algo} method for d-separation not supported.\"", ")", "\n", "", "return", "dseparated", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set": [[266, 287], ["networkx.algorithms.d_separated", "causal_graph.CausalGraph.do_surgery", "set", "set", "set", "all", "ValueError", "causal_graph.CausalGraph.get_backdoor_paths", "causal_graph.CausalGraph.is_blocked"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.do_surgery", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_backdoor_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.is_blocked"], ["", "def", "check_valid_backdoor_set", "(", "self", ",", "nodes1", ",", "nodes2", ",", "nodes3", ",", "\n", "backdoor_paths", "=", "None", ",", "new_graph", "=", "None", ",", "dseparation_algo", "=", "\"default\"", ")", ":", "\n", "        ", "\"\"\" Assume that the first parameter (nodes1) is the treatment,\n        the second is the outcome, and the third is the candidate backdoor set\n        \"\"\"", "\n", "# also return the number of backdoor paths blocked by observed nodes", "\n", "if", "dseparation_algo", "==", "\"default\"", ":", "\n", "            ", "if", "new_graph", "is", "None", ":", "\n", "# Assume that nodes1 is the treatment", "\n", "                ", "new_graph", "=", "self", ".", "do_surgery", "(", "nodes1", ",", "\n", "remove_outgoing_edges", "=", "True", ")", "\n", "", "dseparated", "=", "nx", ".", "algorithms", ".", "d_separated", "(", "new_graph", ",", "\n", "set", "(", "nodes1", ")", ",", "set", "(", "nodes2", ")", ",", "set", "(", "nodes3", ")", ")", "\n", "", "elif", "dseparation_algo", "==", "\"naive\"", ":", "\n", "# ignores new_graph parameter, always uses self._graph", "\n", "            ", "if", "backdoor_paths", "is", "None", ":", "\n", "                ", "backdoor_paths", "=", "self", ".", "get_backdoor_paths", "(", "nodes1", ",", "nodes2", ")", "\n", "", "dseparated", "=", "all", "(", "[", "self", ".", "is_blocked", "(", "path", ",", "nodes3", ")", "for", "path", "in", "backdoor_paths", "]", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"{dseparation_algo} method for d-separation not supported.\"", ")", "\n", "", "return", "{", "'is_dseparated'", ":", "dseparated", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_backdoor_paths": [[289, 307], ["causal_graph.CausalGraph._graph.to_undirected", "set().union", "causal_graph.CausalGraph.logger.debug", "set", "paths.extend", "str", "networkx.all_simple_paths", "causal_graph.CausalGraph._graph.has_edge", "len", "set().union.intersection"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection"], ["", "def", "get_backdoor_paths", "(", "self", ",", "nodes1", ",", "nodes2", ")", ":", "\n", "        ", "paths", "=", "[", "]", "\n", "undirected_graph", "=", "self", ".", "_graph", ".", "to_undirected", "(", ")", "\n", "nodes12", "=", "set", "(", "nodes1", ")", ".", "union", "(", "nodes2", ")", "\n", "for", "node1", "in", "nodes1", ":", "\n", "            ", "for", "node2", "in", "nodes2", ":", "\n", "                ", "backdoor_paths", "=", "[", "\n", "pth", "\n", "for", "pth", "in", "nx", ".", "all_simple_paths", "(", "undirected_graph", ",", "source", "=", "node1", ",", "target", "=", "node2", ")", "\n", "if", "self", ".", "_graph", ".", "has_edge", "(", "pth", "[", "1", "]", ",", "pth", "[", "0", "]", ")", "]", "\n", "# remove paths that have nodes1\\node1 or nodes2\\node2 as intermediate nodes", "\n", "filtered_backdoor_paths", "=", "[", "\n", "pth", "\n", "for", "pth", "in", "backdoor_paths", "\n", "if", "len", "(", "nodes12", ".", "intersection", "(", "pth", "[", "1", ":", "-", "1", "]", ")", ")", "==", "0", "]", "\n", "paths", ".", "extend", "(", "filtered_backdoor_paths", ")", "\n", "", "", "self", ".", "logger", ".", "debug", "(", "\"Backdoor paths: \"", "+", "str", "(", "paths", ")", ")", "\n", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.is_blocked": [[308, 330], ["range", "len", "causal_graph.CausalGraph._graph.has_edge", "causal_graph.CausalGraph._graph.has_edge", "networkx.descendants", "all"], "methods", ["None"], ["", "def", "is_blocked", "(", "self", ",", "path", ",", "conditioned_nodes", ")", ":", "\n", "        ", "\"\"\" Uses d-separation criteria to decide if conditioned_nodes block given path.\n        \"\"\"", "\n", "\n", "blocked_by_conditioning", "=", "False", "\n", "has_unconditioned_collider", "=", "False", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "2", ")", ":", "\n", "            ", "if", "self", ".", "_graph", ".", "has_edge", "(", "path", "[", "i", "]", ",", "path", "[", "i", "+", "1", "]", ")", "and", "self", ".", "_graph", ".", "has_edge", "(", "path", "[", "i", "+", "2", "]", ",", "path", "[", "i", "+", "1", "]", ")", ":", "# collider", "\n", "                ", "collider_descendants", "=", "nx", ".", "descendants", "(", "self", ".", "_graph", ",", "path", "[", "i", "+", "1", "]", ")", "\n", "if", "path", "[", "i", "+", "1", "]", "not", "in", "conditioned_nodes", "and", "all", "(", "cdesc", "not", "in", "conditioned_nodes", "for", "cdesc", "in", "collider_descendants", ")", ":", "\n", "                    ", "has_unconditioned_collider", "=", "True", "\n", "", "", "else", ":", "# chain or fork", "\n", "                ", "if", "path", "[", "i", "+", "1", "]", "in", "conditioned_nodes", ":", "\n", "                    ", "blocked_by_conditioning", "=", "True", "\n", "break", "\n", "", "", "", "if", "blocked_by_conditioning", ":", "\n", "            ", "return", "True", "\n", "", "elif", "has_unconditioned_collider", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes": [[331, 350], ["dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "set", "set", "list", "causes_1.union.union.union", "causal_graph.CausalGraph.get_parents", "causes_1.union.union.intersection", "causal_graph.CausalGraph.get_ancestors", "causes_2.union.union.union", "causes_2.union.union.union", "set", "causal_graph.CausalGraph.get_ancestors"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_parents", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_ancestors"], ["", "", "def", "get_common_causes", "(", "self", ",", "nodes1", ",", "nodes2", ")", ":", "\n", "        ", "\"\"\"\n        Assume that nodes1 causes nodes2 (e.g., nodes1 are the treatments and nodes2 are the outcomes)\n        \"\"\"", "\n", "# TODO Refactor to remove this from here and only implement this logic in causalIdentifier. Unnecessary assumption of nodes1 to be causing nodes2.", "\n", "nodes1", "=", "parse_state", "(", "nodes1", ")", "\n", "nodes2", "=", "parse_state", "(", "nodes2", ")", "\n", "causes_1", "=", "set", "(", ")", "\n", "causes_2", "=", "set", "(", ")", "\n", "for", "node", "in", "nodes1", ":", "\n", "            ", "causes_1", "=", "causes_1", ".", "union", "(", "self", ".", "get_ancestors", "(", "node", ")", ")", "\n", "", "for", "node", "in", "nodes2", ":", "\n", "# Cannot simply compute ancestors, since that will also include nodes1 and its parents (e.g. instruments)", "\n", "            ", "parents_2", "=", "self", ".", "get_parents", "(", "node", ")", "\n", "for", "parent", "in", "parents_2", ":", "\n", "                ", "if", "parent", "not", "in", "nodes1", ":", "\n", "                    ", "causes_2", "=", "causes_2", ".", "union", "(", "set", "(", "[", "parent", ",", "]", ")", ")", "\n", "causes_2", "=", "causes_2", ".", "union", "(", "self", ".", "get_ancestors", "(", "parent", ")", ")", "\n", "", "", "", "return", "list", "(", "causes_1", ".", "intersection", "(", "causes_2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_effect_modifiers": [[351, 365], ["set", "modifiers.difference.difference.difference", "list", "modifiers.difference.difference.union", "modifiers.difference.difference.difference", "causal_graph.CausalGraph.get_ancestors", "causal_graph.CausalGraph.get_ancestors", "networkx.all_simple_paths", "modifiers.difference.difference.difference"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference"], ["", "def", "get_effect_modifiers", "(", "self", ",", "nodes1", ",", "nodes2", ")", ":", "\n", "        ", "modifiers", "=", "set", "(", ")", "\n", "for", "node", "in", "nodes2", ":", "\n", "            ", "modifiers", "=", "modifiers", ".", "union", "(", "self", ".", "get_ancestors", "(", "node", ")", ")", "\n", "", "modifiers", "=", "modifiers", ".", "difference", "(", "nodes1", ")", "\n", "for", "node", "in", "nodes1", ":", "\n", "            ", "modifiers", "=", "modifiers", ".", "difference", "(", "self", ".", "get_ancestors", "(", "node", ")", ")", "\n", "# removing all mediators", "\n", "", "for", "node1", "in", "nodes1", ":", "\n", "            ", "for", "node2", "in", "nodes2", ":", "\n", "                ", "all_directed_paths", "=", "nx", ".", "all_simple_paths", "(", "self", ".", "_graph", ",", "node1", ",", "node2", ")", "\n", "for", "path", "in", "all_directed_paths", ":", "\n", "                    ", "modifiers", "=", "modifiers", ".", "difference", "(", "path", ")", "\n", "", "", "", "return", "list", "(", "modifiers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_parents": [[366, 368], ["set", "causal_graph.CausalGraph._graph.predecessors"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.DirectedGraph.predecessors"], ["", "def", "get_parents", "(", "self", ",", "node_name", ")", ":", "\n", "        ", "return", "set", "(", "self", ".", "_graph", ".", "predecessors", "(", "node_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_ancestors": [[369, 375], ["set", "networkx.ancestors"], "methods", ["None"], ["", "def", "get_ancestors", "(", "self", ",", "node_name", ",", "new_graph", "=", "None", ")", ":", "\n", "        ", "if", "new_graph", "is", "None", ":", "\n", "            ", "graph", "=", "self", ".", "_graph", "\n", "", "else", ":", "\n", "            ", "graph", "=", "new_graph", "\n", "", "return", "set", "(", "nx", ".", "ancestors", "(", "graph", ",", "node_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_descendants": [[376, 381], ["set", "descendants.union.union.union", "set", "networkx.descendants"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union"], ["", "def", "get_descendants", "(", "self", ",", "nodes", ")", ":", "\n", "        ", "descendants", "=", "set", "(", ")", "\n", "for", "node_name", "in", "nodes", ":", "\n", "            ", "descendants", "=", "descendants", ".", "union", "(", "set", "(", "nx", ".", "descendants", "(", "self", ".", "_graph", ",", "node_name", ")", ")", ")", "\n", "", "return", "descendants", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.all_observed": [[382, 388], ["None"], "methods", ["None"], ["", "def", "all_observed", "(", "self", ",", "node_names", ")", ":", "\n", "        ", "for", "node_name", "in", "node_names", ":", "\n", "            ", "if", "self", ".", "_graph", ".", "nodes", "[", "node_name", "]", "[", "\"observed\"", "]", "!=", "\"yes\"", ":", "\n", "                ", "return", "False", "\n", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes": [[389, 395], ["set", "causal_graph.CausalGraph.filter_unobserved_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.filter_unobserved_variables"], ["", "def", "get_all_nodes", "(", "self", ",", "include_unobserved", "=", "True", ")", ":", "\n", "        ", "nodes", "=", "self", ".", "_graph", ".", "nodes", "\n", "if", "not", "include_unobserved", ":", "\n", "            ", "nodes", "=", "set", "(", "self", ".", "filter_unobserved_variables", "(", "nodes", ")", ")", "\n", "\n", "", "return", "nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.filter_unobserved_variables": [[396, 403], ["list", "list.append"], "methods", ["None"], ["", "def", "filter_unobserved_variables", "(", "self", ",", "node_names", ")", ":", "\n", "        ", "observed_node_names", "=", "list", "(", ")", "\n", "for", "node_name", "in", "node_names", ":", "\n", "            ", "if", "self", ".", "_graph", ".", "nodes", "[", "node_name", "]", "[", "\"observed\"", "]", "==", "\"yes\"", ":", "\n", "                ", "observed_node_names", ".", "append", "(", "node_name", ")", "\n", "\n", "", "", "return", "observed_node_names", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_instruments": [[404, 432], ["dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "set", "causal_graph.CausalGraph.do_surgery", "set", "parents_treatment.union.union.difference", "causal_graph.CausalGraph.logger.debug", "set", "parents_treatment.union.difference.difference", "causal_graph.CausalGraph.logger.debug", "list", "parents_treatment.union.union.union", "ancestors_outcome.union.union.union", "networkx.descendants", "causal_graph.CausalGraph.get_parents", "networkx.ancestors"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.do_surgery", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_parents"], ["", "def", "get_instruments", "(", "self", ",", "treatment_nodes", ",", "outcome_nodes", ")", ":", "\n", "        ", "treatment_nodes", "=", "parse_state", "(", "treatment_nodes", ")", "\n", "outcome_nodes", "=", "parse_state", "(", "outcome_nodes", ")", "\n", "parents_treatment", "=", "set", "(", ")", "\n", "for", "node", "in", "treatment_nodes", ":", "\n", "            ", "parents_treatment", "=", "parents_treatment", ".", "union", "(", "self", ".", "get_parents", "(", "node", ")", ")", "\n", "", "g_no_parents_treatment", "=", "self", ".", "do_surgery", "(", "treatment_nodes", ",", "\n", "remove_incoming_edges", "=", "True", ")", "\n", "ancestors_outcome", "=", "set", "(", ")", "\n", "for", "node", "in", "outcome_nodes", ":", "\n", "            ", "ancestors_outcome", "=", "ancestors_outcome", ".", "union", "(", "nx", ".", "ancestors", "(", "g_no_parents_treatment", ",", "node", ")", ")", "\n", "# [TODO: double check these work with multivariate implementation:]", "\n", "# Exclusion", "\n", "", "candidate_instruments", "=", "parents_treatment", ".", "difference", "(", "ancestors_outcome", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Candidate instruments after satisfying exclusion: %s\"", ",", "\n", "candidate_instruments", ")", "\n", "# As-if-random setup", "\n", "children_causes_outcome", "=", "[", "nx", ".", "descendants", "(", "g_no_parents_treatment", ",", "v", ")", "\n", "for", "v", "in", "ancestors_outcome", "]", "\n", "children_causes_outcome", "=", "set", "(", "[", "item", "\n", "for", "sublist", "in", "children_causes_outcome", "\n", "for", "item", "in", "sublist", "]", ")", "\n", "\n", "# As-if-random", "\n", "instruments", "=", "candidate_instruments", ".", "difference", "(", "children_causes_outcome", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Candidate instruments after satisfying exclusion and as-if-random: %s\"", ",", "\n", "instruments", ")", "\n", "return", "list", "(", "instruments", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_directed_paths": [[434, 443], ["networkx.all_simple_paths"], "methods", ["None"], ["", "def", "get_all_directed_paths", "(", "self", ",", "nodes1", ",", "nodes2", ")", ":", "\n", "        ", "\"\"\" Get all directed paths between sets of nodes.\n\n        Currently only supports singleton sets.\n        \"\"\"", "\n", "node1", "=", "nodes1", "[", "0", "]", "\n", "node2", "=", "nodes2", "[", "0", "]", "\n", "# convert the outputted generator into a list", "\n", "return", "[", "p", "for", "p", "in", "nx", ".", "all_simple_paths", "(", "self", ".", "_graph", ",", "source", "=", "node1", ",", "target", "=", "node2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.has_directed_path": [[444, 452], ["networkx.has_path"], "methods", ["None"], ["", "def", "has_directed_path", "(", "self", ",", "nodes1", ",", "nodes2", ")", ":", "\n", "        ", "\"\"\" Checks if there is any directed path between two sets of nodes.\n\n        Currently only supports singleton sets.\n        \"\"\"", "\n", "#dpaths = self.get_all_directed_paths(nodes1, nodes2)", "\n", "#return len(dpaths) > 0", "\n", "return", "nx", ".", "has_path", "(", "self", ".", "_graph", ",", "nodes1", "[", "0", "]", ",", "nodes2", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_adjacency_matrix": [[453, 459], ["networkx.convert_matrix.to_numpy_matrix"], "methods", ["None"], ["", "def", "get_adjacency_matrix", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''\n        Get adjacency matrix from the networkx graph\n\n        '''", "\n", "return", "nx", ".", "convert_matrix", ".", "to_numpy_matrix", "(", "self", ".", "_graph", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_frontdoor_set": [[460, 479], ["networkx.algorithms.d_separated", "set", "set", "set", "all", "ValueError", "causal_graph.CausalGraph.get_all_directed_paths", "causal_graph.CausalGraph.is_blocked"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_directed_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.is_blocked"], ["", "def", "check_valid_frontdoor_set", "(", "self", ",", "nodes1", ",", "nodes2", ",", "candidate_nodes", ",", "\n", "frontdoor_paths", "=", "None", ",", "new_graph", "=", "None", ",", "\n", "dseparation_algo", "=", "\"default\"", ")", ":", "\n", "        ", "\"\"\"Check if valid the frontdoor variables for set of treatments, nodes1 to set of outcomes, nodes2.\n        \"\"\"", "\n", "# Condition 1: node 1 ---> node 2 is intercepted by candidate_nodes", "\n", "if", "dseparation_algo", "==", "\"default\"", ":", "\n", "            ", "if", "new_graph", "is", "None", ":", "\n", "                ", "new_graph", "=", "self", ".", "_graph", "\n", "", "dseparated", "=", "nx", ".", "algorithms", ".", "d_separated", "(", "new_graph", ",", "\n", "set", "(", "nodes1", ")", ",", "set", "(", "nodes2", ")", ",", "set", "(", "candidate_nodes", ")", ")", "\n", "", "elif", "dseparation_algo", "==", "\"naive\"", ":", "\n", "            ", "if", "frontdoor_paths", "is", "None", ":", "\n", "                ", "frontdoor_paths", "=", "self", ".", "get_all_directed_paths", "(", "nodes1", ",", "nodes2", ")", "\n", "\n", "", "dseparated", "=", "all", "(", "[", "self", ".", "is_blocked", "(", "path", ",", "candidate_nodes", ")", "for", "path", "in", "frontdoor_paths", "]", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"{dseparation_algo} method for d-separation not supported.\"", ")", "\n", "", "return", "dseparated", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_mediation_set": [[480, 488], ["any", "causal_graph.CausalGraph.get_all_directed_paths", "causal_graph.CausalGraph.is_blocked"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_directed_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.is_blocked"], ["", "def", "check_valid_mediation_set", "(", "self", ",", "nodes1", ",", "nodes2", ",", "candidate_nodes", ",", "mediation_paths", "=", "None", ")", ":", "\n", "        ", "\"\"\"Check if candidate nodes are valid mediators for set of treatments, nodes1 to set of outcomes, nodes2.\n        \"\"\"", "\n", "if", "mediation_paths", "is", "None", ":", "\n", "            ", "mediation_paths", "=", "self", ".", "get_all_directed_paths", "(", "nodes1", ",", "nodes2", ")", "\n", "\n", "", "is_mediator", "=", "any", "(", "[", "self", ".", "is_blocked", "(", "path", ",", "candidate_nodes", ")", "for", "path", "in", "mediation_paths", "]", ")", "\n", "return", "is_mediator", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.__init__": [[31, 41], ["logging.getLogger"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "graph", ",", "estimand_type", ",", "\n", "method_name", "=", "\"default\"", ",", "\n", "proceed_when_unidentifiable", "=", "False", ")", ":", "\n", "        ", "self", ".", "_graph", "=", "graph", "\n", "self", ".", "estimand_type", "=", "estimand_type", "\n", "self", ".", "treatment_name", "=", "graph", ".", "treatment_name", "\n", "self", ".", "outcome_name", "=", "graph", ".", "outcome_name", "\n", "self", ".", "method_name", "=", "method_name", "\n", "self", ".", "_proceed_when_unidentifiable", "=", "proceed_when_unidentifiable", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_effect": [[42, 68], ["causal_identifier.CausalIdentifier._graph.has_directed_path", "causal_identifier.CausalIdentifier.logger.warn", "causal_identifier.IdentifiedEstimand", "causal_identifier.CausalIdentifier.identify_ate_effect", "causal_identifier.CausalIdentifier.identify_nde_effect", "causal_identifier.CausalIdentifier.identify_nie_effect", "ValueError"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.has_directed_path", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_ate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_nde_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_nie_effect"], ["", "def", "identify_effect", "(", "self", ",", "optimize_backdoor", "=", "False", ")", ":", "\n", "        ", "\"\"\"Main method that returns an identified estimand (if one exists).\n\n        If estimand_type is non-parametric ATE, then  uses backdoor, instrumental variable and frontdoor identification methods,  to check if an identified estimand exists, based on the causal graph.\n\n        :param self: instance of the CausalIdentifier class (or its subclass)\n        :returns:  target estimand, an instance of the IdentifiedEstimand class\n        \"\"\"", "\n", "# First, check if there is a directed path from action to outcome", "\n", "if", "not", "self", ".", "_graph", ".", "has_directed_path", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", ":", "\n", "            ", "self", ".", "logger", ".", "warn", "(", "\"No directed path from treatment to outcome. Causal Effect is zero.\"", ")", "\n", "return", "IdentifiedEstimand", "(", "self", ",", "\n", "treatment_variable", "=", "self", ".", "treatment_name", ",", "\n", "outcome_variable", "=", "self", ".", "outcome_name", ",", "\n", "no_directed_path", "=", "True", ")", "\n", "", "if", "self", ".", "estimand_type", "==", "CausalIdentifier", ".", "NONPARAMETRIC_ATE", ":", "\n", "            ", "return", "self", ".", "identify_ate_effect", "(", "optimize_backdoor", "=", "optimize_backdoor", ")", "\n", "", "elif", "self", ".", "estimand_type", "==", "CausalIdentifier", ".", "NONPARAMETRIC_NDE", ":", "\n", "            ", "return", "self", ".", "identify_nde_effect", "(", ")", "\n", "", "elif", "self", ".", "estimand_type", "==", "CausalIdentifier", ".", "NONPARAMETRIC_NIE", ":", "\n", "            ", "return", "self", ".", "identify_nie_effect", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Estimand type is not supported. Use either {0}, {1}, or {2}.\"", ".", "format", "(", "\n", "CausalIdentifier", ".", "NONPARAMETRIC_ATE", ",", "\n", "CausalIdentifier", ".", "NONPARAMETRIC_NDE", ",", "\n", "CausalIdentifier", ".", "NONPARAMETRIC_NIE", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_ate_effect": [[69, 145], ["causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "causal_identifier.CausalIdentifier.get_default_backdoor_set_id", "causal_identifier.CausalIdentifier._graph.get_instruments", "causal_identifier.CausalIdentifier.logger.info", "causal_identifier.CausalIdentifier.identify_frontdoor", "causal_identifier.CausalIdentifier.logger.info", "causal_identifier.IdentifiedEstimand", "causal_identifier.CausalIdentifier.identify_backdoor", "Backdoor", "Backdoor.get_backdoor_vars", "len", "estimands_dict.get", "backdoor_variables_dict.get", "len", "causal_identifier.CausalIdentifier.construct_iv_estimand", "causal_identifier.CausalIdentifier.logger.debug", "len", "causal_identifier.CausalIdentifier.construct_frontdoor_estimand", "causal_identifier.CausalIdentifier.logger.debug", "causal_identifier.CausalIdentifier.identify_mediation_first_stage_confounders", "causal_identifier.CausalIdentifier.identify_mediation_second_stage_confounders", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.get_default_backdoor_set_id", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_instruments", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_frontdoor", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_iv_estimand", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_frontdoor_estimand", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation_first_stage_confounders", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation_second_stage_confounders"], ["", "", "def", "identify_ate_effect", "(", "self", ",", "optimize_backdoor", ")", ":", "\n", "        ", "estimands_dict", "=", "{", "}", "\n", "mediation_first_stage_confounders", "=", "None", "\n", "mediation_second_stage_confounders", "=", "None", "\n", "### 1. BACKDOOR IDENTIFICATION", "\n", "# First, checking if there are any valid backdoor adjustment sets", "\n", "if", "optimize_backdoor", "==", "False", ":", "\n", "            ", "backdoor_sets", "=", "self", ".", "identify_backdoor", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", "\n", "", "else", ":", "\n", "            ", "from", "dowhy", ".", "causal_identifiers", ".", "backdoor", "import", "Backdoor", "\n", "path", "=", "Backdoor", "(", "self", ".", "_graph", ".", "_graph", ",", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", "\n", "backdoor_sets", "=", "path", ".", "get_backdoor_vars", "(", ")", "\n", "", "estimands_dict", ",", "backdoor_variables_dict", "=", "self", ".", "build_backdoor_estimands_dict", "(", "\n", "self", ".", "treatment_name", ",", "\n", "self", ".", "outcome_name", ",", "\n", "backdoor_sets", ",", "\n", "estimands_dict", ")", "\n", "# Setting default \"backdoor\" identification adjustment set", "\n", "default_backdoor_id", "=", "self", ".", "get_default_backdoor_set_id", "(", "backdoor_variables_dict", ")", "\n", "if", "len", "(", "backdoor_variables_dict", ")", ">", "0", ":", "\n", "            ", "estimands_dict", "[", "\"backdoor\"", "]", "=", "estimands_dict", ".", "get", "(", "str", "(", "default_backdoor_id", ")", ",", "None", ")", "\n", "backdoor_variables_dict", "[", "\"backdoor\"", "]", "=", "backdoor_variables_dict", ".", "get", "(", "str", "(", "default_backdoor_id", ")", ",", "None", ")", "\n", "", "else", ":", "\n", "            ", "estimands_dict", "[", "\"backdoor\"", "]", "=", "None", "\n", "### 2. INSTRUMENTAL VARIABLE IDENTIFICATION", "\n", "# Now checking if there is also a valid iv estimand", "\n", "", "instrument_names", "=", "self", ".", "_graph", ".", "get_instruments", "(", "self", ".", "treatment_name", ",", "\n", "self", ".", "outcome_name", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Instrumental variables for treatment and outcome:\"", "+", "\n", "str", "(", "instrument_names", ")", ")", "\n", "if", "len", "(", "instrument_names", ")", ">", "0", ":", "\n", "            ", "iv_estimand_expr", "=", "self", ".", "construct_iv_estimand", "(", "\n", "self", ".", "estimand_type", ",", "\n", "self", ".", "_graph", ".", "treatment_name", ",", "\n", "self", ".", "_graph", ".", "outcome_name", ",", "\n", "instrument_names", "\n", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Identified expression = \"", "+", "str", "(", "iv_estimand_expr", ")", ")", "\n", "estimands_dict", "[", "\"iv\"", "]", "=", "iv_estimand_expr", "\n", "", "else", ":", "\n", "            ", "estimands_dict", "[", "\"iv\"", "]", "=", "None", "\n", "\n", "### 3. FRONTDOOR IDENTIFICATION", "\n", "# Now checking if there is a valid frontdoor variable", "\n", "", "frontdoor_variables_names", "=", "self", ".", "identify_frontdoor", "(", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Frontdoor variables for treatment and outcome:\"", "+", "\n", "str", "(", "frontdoor_variables_names", ")", ")", "\n", "if", "len", "(", "frontdoor_variables_names", ")", ">", "0", ":", "\n", "            ", "frontdoor_estimand_expr", "=", "self", ".", "construct_frontdoor_estimand", "(", "\n", "self", ".", "estimand_type", ",", "\n", "self", ".", "_graph", ".", "treatment_name", ",", "\n", "self", ".", "_graph", ".", "outcome_name", ",", "\n", "frontdoor_variables_names", "\n", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Identified expression = \"", "+", "str", "(", "frontdoor_estimand_expr", ")", ")", "\n", "estimands_dict", "[", "\"frontdoor\"", "]", "=", "frontdoor_estimand_expr", "\n", "mediation_first_stage_confounders", "=", "self", ".", "identify_mediation_first_stage_confounders", "(", "self", ".", "treatment_name", ",", "frontdoor_variables_names", ")", "\n", "mediation_second_stage_confounders", "=", "self", ".", "identify_mediation_second_stage_confounders", "(", "frontdoor_variables_names", ",", "self", ".", "outcome_name", ")", "\n", "", "else", ":", "\n", "            ", "estimands_dict", "[", "\"frontdoor\"", "]", "=", "None", "\n", "\n", "# Finally returning the estimand object", "\n", "", "estimand", "=", "IdentifiedEstimand", "(", "\n", "self", ",", "\n", "treatment_variable", "=", "self", ".", "_graph", ".", "treatment_name", ",", "\n", "outcome_variable", "=", "self", ".", "_graph", ".", "outcome_name", ",", "\n", "estimand_type", "=", "self", ".", "estimand_type", ",", "\n", "estimands", "=", "estimands_dict", ",", "\n", "backdoor_variables", "=", "backdoor_variables_dict", ",", "\n", "instrumental_variables", "=", "instrument_names", ",", "\n", "frontdoor_variables", "=", "frontdoor_variables_names", ",", "\n", "mediation_first_stage_confounders", "=", "mediation_first_stage_confounders", ",", "\n", "mediation_second_stage_confounders", "=", "mediation_second_stage_confounders", ",", "\n", "default_backdoor_id", "=", "default_backdoor_id", "\n", ")", "\n", "return", "estimand", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_nie_effect": [[146, 197], ["causal_identifier.CausalIdentifier.identify_backdoor", "causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "causal_identifier.CausalIdentifier.get_default_backdoor_set_id", "backdoor_variables_dict.get", "causal_identifier.CausalIdentifier.identify_mediation", "causal_identifier.CausalIdentifier.logger.info", "causal_identifier.IdentifiedEstimand", "str", "len", "causal_identifier.CausalIdentifier.construct_mediation_estimand", "causal_identifier.CausalIdentifier.logger.debug", "causal_identifier.CausalIdentifier.identify_mediation_first_stage_confounders", "causal_identifier.CausalIdentifier.identify_mediation_second_stage_confounders", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.get_default_backdoor_set_id", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_mediation_estimand", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation_first_stage_confounders", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation_second_stage_confounders"], ["", "def", "identify_nie_effect", "(", "self", ")", ":", "\n", "        ", "estimands_dict", "=", "{", "}", "\n", "### 1. FIRST DOING BACKDOOR IDENTIFICATION", "\n", "# First, checking if there are any valid backdoor adjustment sets", "\n", "backdoor_sets", "=", "self", ".", "identify_backdoor", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", "\n", "estimands_dict", ",", "backdoor_variables_dict", "=", "self", ".", "build_backdoor_estimands_dict", "(", "\n", "self", ".", "treatment_name", ",", "\n", "self", ".", "outcome_name", ",", "\n", "backdoor_sets", ",", "\n", "estimands_dict", ")", "\n", "# Setting default \"backdoor\" identification adjustment set", "\n", "default_backdoor_id", "=", "self", ".", "get_default_backdoor_set_id", "(", "backdoor_variables_dict", ")", "\n", "backdoor_variables_dict", "[", "\"backdoor\"", "]", "=", "backdoor_variables_dict", ".", "get", "(", "str", "(", "default_backdoor_id", ")", ",", "None", ")", "\n", "\n", "### 2. SECOND, CHECKING FOR MEDIATORS", "\n", "# Now checking if there are valid mediator variables", "\n", "estimands_dict", "=", "{", "}", "# Need to reinitialize this dictionary to avoid including the backdoor sets", "\n", "mediation_first_stage_confounders", "=", "None", "\n", "mediation_second_stage_confounders", "=", "None", "\n", "mediators_names", "=", "self", ".", "identify_mediation", "(", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Mediators for treatment and outcome:\"", "+", "\n", "str", "(", "mediators_names", ")", ")", "\n", "if", "len", "(", "mediators_names", ")", ">", "0", ":", "\n", "            ", "mediation_estimand_expr", "=", "self", ".", "construct_mediation_estimand", "(", "\n", "self", ".", "estimand_type", ",", "\n", "self", ".", "_graph", ".", "treatment_name", ",", "\n", "self", ".", "_graph", ".", "outcome_name", ",", "\n", "mediators_names", "\n", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Identified expression = \"", "+", "str", "(", "mediation_estimand_expr", ")", ")", "\n", "estimands_dict", "[", "\"mediation\"", "]", "=", "mediation_estimand_expr", "\n", "mediation_first_stage_confounders", "=", "self", ".", "identify_mediation_first_stage_confounders", "(", "self", ".", "treatment_name", ",", "mediators_names", ")", "\n", "mediation_second_stage_confounders", "=", "self", ".", "identify_mediation_second_stage_confounders", "(", "mediators_names", ",", "self", ".", "outcome_name", ")", "\n", "", "else", ":", "\n", "            ", "estimands_dict", "[", "\"mediation\"", "]", "=", "None", "\n", "# Finally returning the estimand object", "\n", "", "estimand", "=", "IdentifiedEstimand", "(", "\n", "self", ",", "\n", "treatment_variable", "=", "self", ".", "_graph", ".", "treatment_name", ",", "\n", "outcome_variable", "=", "self", ".", "_graph", ".", "outcome_name", ",", "\n", "estimand_type", "=", "self", ".", "estimand_type", ",", "\n", "estimands", "=", "estimands_dict", ",", "\n", "backdoor_variables", "=", "backdoor_variables_dict", ",", "\n", "instrumental_variables", "=", "None", ",", "\n", "frontdoor_variables", "=", "None", ",", "\n", "mediator_variables", "=", "mediators_names", ",", "\n", "mediation_first_stage_confounders", "=", "mediation_first_stage_confounders", ",", "\n", "mediation_second_stage_confounders", "=", "mediation_second_stage_confounders", ",", "\n", "default_backdoor_id", "=", "None", "\n", ")", "\n", "return", "estimand", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_nde_effect": [[198, 249], ["causal_identifier.CausalIdentifier.identify_backdoor", "causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "causal_identifier.CausalIdentifier.get_default_backdoor_set_id", "backdoor_variables_dict.get", "causal_identifier.CausalIdentifier.identify_mediation", "causal_identifier.CausalIdentifier.logger.info", "causal_identifier.IdentifiedEstimand", "str", "len", "causal_identifier.CausalIdentifier.construct_mediation_estimand", "causal_identifier.CausalIdentifier.logger.debug", "causal_identifier.CausalIdentifier.identify_mediation_first_stage_confounders", "causal_identifier.CausalIdentifier.identify_mediation_second_stage_confounders", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.get_default_backdoor_set_id", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_mediation_estimand", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation_first_stage_confounders", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation_second_stage_confounders"], ["", "def", "identify_nde_effect", "(", "self", ")", ":", "\n", "        ", "estimands_dict", "=", "{", "}", "\n", "### 1. FIRST DOING BACKDOOR IDENTIFICATION", "\n", "# First, checking if there are any valid backdoor adjustment sets", "\n", "backdoor_sets", "=", "self", ".", "identify_backdoor", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", "\n", "estimands_dict", ",", "backdoor_variables_dict", "=", "self", ".", "build_backdoor_estimands_dict", "(", "\n", "self", ".", "treatment_name", ",", "\n", "self", ".", "outcome_name", ",", "\n", "backdoor_sets", ",", "\n", "estimands_dict", ")", "\n", "# Setting default \"backdoor\" identification adjustment set", "\n", "default_backdoor_id", "=", "self", ".", "get_default_backdoor_set_id", "(", "backdoor_variables_dict", ")", "\n", "backdoor_variables_dict", "[", "\"backdoor\"", "]", "=", "backdoor_variables_dict", ".", "get", "(", "str", "(", "default_backdoor_id", ")", ",", "None", ")", "\n", "\n", "### 2. SECOND, CHECKING FOR MEDIATORS", "\n", "# Now checking if there are valid mediator variables", "\n", "estimands_dict", "=", "{", "}", "\n", "mediation_first_stage_confounders", "=", "None", "\n", "mediation_second_stage_confounders", "=", "None", "\n", "mediators_names", "=", "self", ".", "identify_mediation", "(", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Mediators for treatment and outcome:\"", "+", "\n", "str", "(", "mediators_names", ")", ")", "\n", "if", "len", "(", "mediators_names", ")", ">", "0", ":", "\n", "            ", "mediation_estimand_expr", "=", "self", ".", "construct_mediation_estimand", "(", "\n", "self", ".", "estimand_type", ",", "\n", "self", ".", "_graph", ".", "treatment_name", ",", "\n", "self", ".", "_graph", ".", "outcome_name", ",", "\n", "mediators_names", "\n", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Identified expression = \"", "+", "str", "(", "mediation_estimand_expr", ")", ")", "\n", "estimands_dict", "[", "\"mediation\"", "]", "=", "mediation_estimand_expr", "\n", "mediation_first_stage_confounders", "=", "self", ".", "identify_mediation_first_stage_confounders", "(", "self", ".", "treatment_name", ",", "mediators_names", ")", "\n", "mediation_second_stage_confounders", "=", "self", ".", "identify_mediation_second_stage_confounders", "(", "mediators_names", ",", "self", ".", "outcome_name", ")", "\n", "", "else", ":", "\n", "            ", "estimands_dict", "[", "\"mediation\"", "]", "=", "None", "\n", "# Finally returning the estimand object", "\n", "", "estimand", "=", "IdentifiedEstimand", "(", "\n", "self", ",", "\n", "treatment_variable", "=", "self", ".", "_graph", ".", "treatment_name", ",", "\n", "outcome_variable", "=", "self", ".", "_graph", ".", "outcome_name", ",", "\n", "estimand_type", "=", "self", ".", "estimand_type", ",", "\n", "estimands", "=", "estimands_dict", ",", "\n", "backdoor_variables", "=", "backdoor_variables_dict", ",", "\n", "instrumental_variables", "=", "None", ",", "\n", "frontdoor_variables", "=", "None", ",", "\n", "mediator_variables", "=", "mediators_names", ",", "\n", "mediation_first_stage_confounders", "=", "mediation_first_stage_confounders", ",", "\n", "mediation_second_stage_confounders", "=", "mediation_second_stage_confounders", ",", "\n", "default_backdoor_id", "=", "None", "\n", ")", "\n", "return", "estimand", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor": [[250, 312], ["set", "causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "causal_identifier.CausalIdentifier._graph.get_descendants", "set", "causal_identifier.CausalIdentifier._graph.get_backdoor_paths", "backdoor_sets.append", "set", "causal_identifier.CausalIdentifier._graph.check_dseparation", "causal_identifier.CausalIdentifier._graph.check_dseparation", "causal_identifier.CausalIdentifier.find_valid_adjustment_sets", "ValueError", "causal_identifier.CausalIdentifier._graph.do_surgery", "ValueError", "causal_identifier.CausalIdentifier._graph.get_all_nodes", "set", "dowhy.utils.api.parse_state", "set", "dowhy.utils.api.parse_state", "set", "set.add", "causal_identifier.CausalIdentifier.find_valid_adjustment_sets"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_descendants", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_backdoor_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_dseparation", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_dseparation", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.find_valid_adjustment_sets", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.do_surgery", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.find_valid_adjustment_sets"], ["", "def", "identify_backdoor", "(", "self", ",", "treatment_name", ",", "outcome_name", ",", "\n", "include_unobserved", "=", "False", ",", "dseparation_algo", "=", "\"default\"", ")", ":", "\n", "        ", "backdoor_sets", "=", "[", "]", "\n", "backdoor_paths", "=", "None", "\n", "bdoor_graph", "=", "None", "\n", "if", "dseparation_algo", "==", "\"naive\"", ":", "\n", "            ", "backdoor_paths", "=", "self", ".", "_graph", ".", "get_backdoor_paths", "(", "treatment_name", ",", "outcome_name", ")", "\n", "", "elif", "dseparation_algo", "==", "\"default\"", ":", "\n", "            ", "bdoor_graph", "=", "self", ".", "_graph", ".", "do_surgery", "(", "treatment_name", ",", "\n", "remove_outgoing_edges", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"d-separation algorithm {dseparation_algo} is not supported\"", ")", "\n", "", "method_name", "=", "self", ".", "method_name", "if", "self", ".", "method_name", "!=", "CausalIdentifier", ".", "BACKDOOR_DEFAULT", "else", "CausalIdentifier", ".", "DEFAULT_BACKDOOR_METHOD", "\n", "\n", "# First, checking if empty set is a valid backdoor set", "\n", "empty_set", "=", "set", "(", ")", "\n", "check", "=", "self", ".", "_graph", ".", "check_valid_backdoor_set", "(", "treatment_name", ",", "\n", "outcome_name", ",", "empty_set", ",", "\n", "backdoor_paths", "=", "backdoor_paths", ",", "new_graph", "=", "bdoor_graph", ",", "\n", "dseparation_algo", "=", "dseparation_algo", ")", "\n", "if", "check", "[", "\"is_dseparated\"", "]", ":", "\n", "            ", "backdoor_sets", ".", "append", "(", "{", "'backdoor_set'", ":", "empty_set", "}", ")", "\n", "# If the method is `minimal-adjustment`, return the empty set right away.", "\n", "if", "method_name", "==", "CausalIdentifier", ".", "BACKDOOR_MIN", ":", "\n", "                ", "return", "backdoor_sets", "\n", "\n", "# Second, checking for all other sets of variables. If include_unobserved is false, then only observed variables are eligible.", "\n", "", "", "eligible_variables", "=", "self", ".", "_graph", ".", "get_all_nodes", "(", "include_unobserved", "=", "include_unobserved", ")", "-", "set", "(", "treatment_name", ")", "-", "set", "(", "outcome_name", ")", "\n", "eligible_variables", "-=", "self", ".", "_graph", ".", "get_descendants", "(", "treatment_name", ")", "\n", "# If var is d-separated from both treatment or outcome, it cannot", "\n", "# be a part of the backdoor set", "\n", "filt_eligible_variables", "=", "set", "(", ")", "\n", "for", "var", "in", "eligible_variables", ":", "\n", "            ", "dsep_treat_var", "=", "self", ".", "_graph", ".", "check_dseparation", "(", "\n", "treatment_name", ",", "parse_state", "(", "var", ")", ",", "\n", "set", "(", ")", ")", "\n", "dsep_outcome_var", "=", "self", ".", "_graph", ".", "check_dseparation", "(", "\n", "outcome_name", ",", "parse_state", "(", "var", ")", ",", "set", "(", ")", ")", "\n", "if", "not", "dsep_outcome_var", "or", "not", "dsep_treat_var", ":", "\n", "                ", "filt_eligible_variables", ".", "add", "(", "var", ")", "\n", "", "", "if", "method_name", "in", "CausalIdentifier", ".", "METHOD_NAMES", ":", "\n", "            ", "backdoor_sets", ",", "found_valid_adjustment_set", "=", "self", ".", "find_valid_adjustment_sets", "(", "\n", "treatment_name", ",", "outcome_name", ",", "\n", "backdoor_paths", ",", "bdoor_graph", ",", "\n", "dseparation_algo", ",", "\n", "backdoor_sets", ",", "filt_eligible_variables", ",", "\n", "method_name", "=", "method_name", ",", "\n", "max_iterations", "=", "CausalIdentifier", ".", "MAX_BACKDOOR_ITERATIONS", ")", "\n", "if", "method_name", "==", "CausalIdentifier", ".", "BACKDOOR_DEFAULT", "and", "found_valid_adjustment_set", ":", "\n", "# repeat the above search with BACKDOOR_MIN", "\n", "                ", "backdoor_sets", ",", "_", "=", "self", ".", "find_valid_adjustment_sets", "(", "\n", "treatment_name", ",", "outcome_name", ",", "\n", "backdoor_paths", ",", "bdoor_graph", ",", "\n", "dseparation_algo", ",", "\n", "backdoor_sets", ",", "filt_eligible_variables", ",", "\n", "method_name", "=", "CausalIdentifier", ".", "BACKDOOR_MIN", ",", "\n", "max_iterations", "=", "CausalIdentifier", ".", "MAX_BACKDOOR_ITERATIONS", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Identifier method {method_name} not supported. Try one of the following: {CausalIdentifier.METHOD_NAMES}\"", ")", "\n", "", "return", "backdoor_sets", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.find_valid_adjustment_sets": [[313, 348], ["causal_identifier.CausalIdentifier._graph.all_observed", "causal_identifier.CausalIdentifier._graph.get_all_nodes", "range", "range", "itertools.combinations", "len", "causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "causal_identifier.CausalIdentifier.logger.debug", "causal_identifier.CausalIdentifier.logger.warning", "len", "backdoor_sets.append", "causal_identifier.CausalIdentifier.logger.warning"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.all_observed", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set"], ["", "def", "find_valid_adjustment_sets", "(", "self", ",", "treatment_name", ",", "outcome_name", ",", "\n", "backdoor_paths", ",", "bdoor_graph", ",", "dseparation_algo", ",", "\n", "backdoor_sets", ",", "filt_eligible_variables", ",", "\n", "method_name", ",", "max_iterations", ")", ":", "\n", "        ", "num_iterations", "=", "0", "\n", "found_valid_adjustment_set", "=", "False", "\n", "all_nodes_observed", "=", "self", ".", "_graph", ".", "all_observed", "(", "self", ".", "_graph", ".", "get_all_nodes", "(", ")", ")", "\n", "# If `minimal-adjustment` method is specified, start the search from the set with minimum size. Otherwise, start from the largest.", "\n", "set_sizes", "=", "range", "(", "1", ",", "len", "(", "filt_eligible_variables", ")", "+", "1", ",", "1", ")", "if", "method_name", "==", "CausalIdentifier", ".", "BACKDOOR_MIN", "else", "range", "(", "len", "(", "filt_eligible_variables", ")", ",", "0", ",", "-", "1", ")", "\n", "for", "size_candidate_set", "in", "set_sizes", ":", "\n", "            ", "for", "candidate_set", "in", "itertools", ".", "combinations", "(", "filt_eligible_variables", ",", "size_candidate_set", ")", ":", "\n", "                ", "check", "=", "self", ".", "_graph", ".", "check_valid_backdoor_set", "(", "treatment_name", ",", "\n", "outcome_name", ",", "candidate_set", ",", "\n", "backdoor_paths", "=", "backdoor_paths", ",", "\n", "new_graph", "=", "bdoor_graph", ",", "\n", "dseparation_algo", "=", "dseparation_algo", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Candidate backdoor set: {0}, is_dseparated: {1}\"", ".", "format", "(", "candidate_set", ",", "check", "[", "\"is_dseparated\"", "]", ")", ")", "\n", "if", "check", "[", "\"is_dseparated\"", "]", ":", "\n", "                    ", "backdoor_sets", ".", "append", "(", "{", "'backdoor_set'", ":", "candidate_set", "}", ")", "\n", "found_valid_adjustment_set", "=", "True", "\n", "", "num_iterations", "+=", "1", "\n", "if", "method_name", "==", "CausalIdentifier", ".", "BACKDOOR_EXHAUSTIVE", "and", "num_iterations", ">", "max_iterations", ":", "\n", "                    ", "self", ".", "logger", ".", "warning", "(", "f\"Max number of iterations {max_iterations} reached.\"", ")", "\n", "break", "\n", "# If the backdoor method is `maximal-adjustment` or `minimal-adjustment`, return the first found adjustment set.", "\n", "", "", "if", "method_name", "in", "{", "CausalIdentifier", ".", "BACKDOOR_DEFAULT", ",", "CausalIdentifier", ".", "BACKDOOR_MAX", ",", "CausalIdentifier", ".", "BACKDOOR_MIN", "}", "and", "found_valid_adjustment_set", ":", "\n", "                ", "break", "\n", "# If all variables are observed, and the biggest eligible set", "\n", "# does not satisfy backdoor, then none of its subsets will.", "\n", "", "if", "method_name", "in", "{", "CausalIdentifier", ".", "BACKDOOR_DEFAULT", ",", "CausalIdentifier", ".", "BACKDOOR_MAX", "}", "and", "all_nodes_observed", ":", "\n", "                ", "break", "\n", "", "if", "num_iterations", ">", "max_iterations", ":", "\n", "                ", "self", ".", "logger", ".", "warning", "(", "f\"Max number of iterations {max_iterations} reached. Could not find a valid backdoor set.\"", ")", "\n", "break", "\n", "", "", "return", "backdoor_sets", ",", "found_valid_adjustment_set", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.get_default_backdoor_set_id": [[350, 370], ["set", "min", "min_iv_backdoor_sets_dict.items", "len", "causal_identifier.CausalIdentifier._graph.get_instruments", "len", "iv_count_dict.values", "set().intersection", "backdoor_sets_dict.items", "iv_count_dict.items", "len", "len", "set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_instruments", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection"], ["", "def", "get_default_backdoor_set_id", "(", "self", ",", "backdoor_sets_dict", ")", ":", "\n", "# Adding a None estimand if no backdoor set found", "\n", "        ", "if", "len", "(", "backdoor_sets_dict", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "# Default set contains minimum possible number of instrumental variables, to prevent lowering variance in the treatment variable.", "\n", "", "instrument_names", "=", "set", "(", "self", ".", "_graph", ".", "get_instruments", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", ")", "\n", "iv_count_dict", "=", "{", "key", ":", "len", "(", "set", "(", "bdoor_set", ")", ".", "intersection", "(", "instrument_names", ")", ")", "for", "key", ",", "bdoor_set", "in", "backdoor_sets_dict", ".", "items", "(", ")", "}", "\n", "min_iv_count", "=", "min", "(", "iv_count_dict", ".", "values", "(", ")", ")", "\n", "min_iv_keys", "=", "{", "key", "for", "key", ",", "iv_count", "in", "iv_count_dict", ".", "items", "(", ")", "if", "iv_count", "==", "min_iv_count", "}", "\n", "min_iv_backdoor_sets_dict", "=", "{", "key", ":", "backdoor_sets_dict", "[", "key", "]", "for", "key", "in", "min_iv_keys", "}", "\n", "\n", "# Default set is the one with the least number of adjustment variables (optimizing for efficiency)", "\n", "min_set_length", "=", "1000000", "\n", "default_key", "=", "None", "\n", "for", "key", ",", "bdoor_set", "in", "min_iv_backdoor_sets_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "len", "(", "bdoor_set", ")", "<", "min_set_length", ":", "\n", "                ", "min_set_length", "=", "len", "(", "bdoor_set", ")", "\n", "default_key", "=", "key", "\n", "", "", "return", "default_key", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.build_backdoor_estimands_dict": [[371, 398], ["any", "range", "causal_identifier.CausalIdentifier._graph.all_observed", "causal_identifier.CausalIdentifier.logger.info", "causal_identifier.CausalIdentifier.logger.warning", "len", "causal_identifier.CausalIdentifier.construct_backdoor_estimand", "causal_identifier.CausalIdentifier.logger.debug", "list", "causal_identifier.CausalIdentifier._graph.all_observed", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.all_observed", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_backdoor_estimand", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.all_observed"], ["", "def", "build_backdoor_estimands_dict", "(", "self", ",", "treatment_name", ",", "outcome_name", ",", "\n", "backdoor_sets", ",", "estimands_dict", ",", "proceed_when_unidentifiable", "=", "None", ")", ":", "\n", "        ", "\"\"\"Build the final dict for backdoor sets by filtering unobserved variables if needed.\n        \"\"\"", "\n", "backdoor_variables_dict", "=", "{", "}", "\n", "if", "proceed_when_unidentifiable", "is", "None", ":", "\n", "            ", "proceed_when_unidentifiable", "=", "self", ".", "_proceed_when_unidentifiable", "\n", "", "is_identified", "=", "[", "self", ".", "_graph", ".", "all_observed", "(", "bset", "[", "\"backdoor_set\"", "]", ")", "for", "bset", "in", "backdoor_sets", "]", "\n", "\n", "if", "any", "(", "is_identified", ")", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"Causal effect can be identified.\"", ")", "\n", "backdoor_sets_arr", "=", "[", "list", "(", "\n", "bset", "[", "\"backdoor_set\"", "]", ")", "\n", "for", "bset", "in", "backdoor_sets", "\n", "if", "self", ".", "_graph", ".", "all_observed", "(", "bset", "[", "\"backdoor_set\"", "]", ")", "]", "\n", "", "else", ":", "# there is unobserved confounding", "\n", "            ", "self", ".", "logger", ".", "warning", "(", "\"Backdoor identification failed.\"", ")", "\n", "backdoor_sets_arr", "=", "[", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "backdoor_sets_arr", ")", ")", ":", "\n", "            ", "backdoor_estimand_expr", "=", "self", ".", "construct_backdoor_estimand", "(", "\n", "self", ".", "estimand_type", ",", "treatment_name", ",", "\n", "outcome_name", ",", "backdoor_sets_arr", "[", "i", "]", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Identified expression = \"", "+", "str", "(", "backdoor_estimand_expr", ")", ")", "\n", "estimands_dict", "[", "\"backdoor\"", "+", "str", "(", "i", "+", "1", ")", "]", "=", "backdoor_estimand_expr", "\n", "backdoor_variables_dict", "[", "\"backdoor\"", "+", "str", "(", "i", "+", "1", ")", "]", "=", "backdoor_sets_arr", "[", "i", "]", "\n", "", "return", "estimands_dict", ",", "backdoor_variables_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_frontdoor": [[399, 456], ["dowhy.utils.api.parse_state", "causal_identifier.CausalIdentifier._graph.do_surgery", "causal_identifier.CausalIdentifier._graph.do_surgery", "set", "causal_identifier.CausalIdentifier._graph.check_valid_frontdoor_set", "causal_identifier.CausalIdentifier.logger.debug", "causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "causal_identifier.CausalIdentifier._graph.do_surgery", "causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "causal_identifier.CausalIdentifier._graph.get_all_directed_paths", "ValueError", "causal_identifier.CausalIdentifier._graph.get_descendants", "set", "causal_identifier.CausalIdentifier._graph.get_descendants", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "set", "dowhy.utils.api.parse_state"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.do_surgery", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.do_surgery", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_frontdoor_set", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.do_surgery", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_directed_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_descendants", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_descendants", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state"], ["", "def", "identify_frontdoor", "(", "self", ",", "dseparation_algo", "=", "\"default\"", ")", ":", "\n", "        ", "\"\"\" Find a valid frontdoor variable if it exists.\n\n        Currently only supports a single variable frontdoor set.\n        \"\"\"", "\n", "frontdoor_var", "=", "None", "\n", "frontdoor_paths", "=", "None", "\n", "fdoor_graph", "=", "None", "\n", "if", "dseparation_algo", "==", "\"default\"", ":", "\n", "            ", "cond1_graph", "=", "self", ".", "_graph", ".", "do_surgery", "(", "self", ".", "treatment_name", ",", "\n", "remove_incoming_edges", "=", "True", ")", "\n", "bdoor_graph1", "=", "self", ".", "_graph", ".", "do_surgery", "(", "self", ".", "treatment_name", ",", "\n", "remove_outgoing_edges", "=", "True", ")", "\n", "", "elif", "dseparation_algo", "==", "\"naive\"", ":", "\n", "            ", "frontdoor_paths", "=", "self", ".", "_graph", ".", "get_all_directed_paths", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"d-separation algorithm {dseparation_algo} is not supported\"", ")", "\n", "\n", "\n", "", "eligible_variables", "=", "self", ".", "_graph", ".", "get_descendants", "(", "self", ".", "treatment_name", ")", "-", "set", "(", "self", ".", "outcome_name", ")", "-", "set", "(", "self", ".", "_graph", ".", "get_descendants", "(", "self", ".", "outcome_name", ")", ")", "\n", "# For simplicity, assuming a one-variable frontdoor set", "\n", "for", "candidate_var", "in", "eligible_variables", ":", "\n", "# Cond 1: All directed paths intercepted by candidate_var", "\n", "            ", "cond1", "=", "self", ".", "_graph", ".", "check_valid_frontdoor_set", "(", "\n", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ",", "\n", "parse_state", "(", "candidate_var", ")", ",", "\n", "frontdoor_paths", "=", "frontdoor_paths", ",", "\n", "new_graph", "=", "cond1_graph", ",", "\n", "dseparation_algo", "=", "dseparation_algo", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Candidate frontdoor set: {0}, is_dseparated: {1}\"", ".", "format", "(", "candidate_var", ",", "cond1", ")", ")", "\n", "if", "not", "cond1", ":", "\n", "                ", "continue", "\n", "# Cond 2: No confounding between treatment and candidate var", "\n", "", "cond2", "=", "self", ".", "_graph", ".", "check_valid_backdoor_set", "(", "\n", "self", ".", "treatment_name", ",", "parse_state", "(", "candidate_var", ")", ",", "\n", "set", "(", ")", ",", "\n", "backdoor_paths", "=", "None", ",", "\n", "new_graph", "=", "bdoor_graph1", ",", "\n", "dseparation_algo", "=", "dseparation_algo", ")", "\n", "if", "not", "cond2", ":", "\n", "                ", "continue", "\n", "# Cond 3: treatment blocks all confounding between candidate_var and outcome", "\n", "", "bdoor_graph2", "=", "self", ".", "_graph", ".", "do_surgery", "(", "candidate_var", ",", "\n", "remove_outgoing_edges", "=", "True", ")", "\n", "cond3", "=", "self", ".", "_graph", ".", "check_valid_backdoor_set", "(", "\n", "parse_state", "(", "candidate_var", ")", ",", "self", ".", "outcome_name", ",", "\n", "self", ".", "treatment_name", ",", "\n", "backdoor_paths", "=", "None", ",", "\n", "new_graph", "=", "bdoor_graph2", ",", "\n", "dseparation_algo", "=", "dseparation_algo", ")", "\n", "is_valid_frontdoor", "=", "cond1", "and", "cond2", "and", "cond3", "\n", "if", "is_valid_frontdoor", ":", "\n", "                ", "frontdoor_var", "=", "candidate_var", "\n", "break", "\n", "", "", "return", "parse_state", "(", "frontdoor_var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation": [[457, 478], ["causal_identifier.CausalIdentifier._graph.get_all_directed_paths", "dowhy.utils.api.parse_state", "causal_identifier.CausalIdentifier._graph.get_descendants", "set", "causal_identifier.CausalIdentifier._graph.check_valid_mediation_set", "causal_identifier.CausalIdentifier.logger.debug", "dowhy.utils.api.parse_state"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_directed_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_descendants", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_mediation_set", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state"], ["", "def", "identify_mediation", "(", "self", ")", ":", "\n", "        ", "\"\"\" Find a valid mediator if it exists.\n\n        Currently only supports a single variable mediator set.\n        \"\"\"", "\n", "mediation_var", "=", "None", "\n", "mediation_paths", "=", "self", ".", "_graph", ".", "get_all_directed_paths", "(", "self", ".", "treatment_name", ",", "self", ".", "outcome_name", ")", "\n", "eligible_variables", "=", "self", ".", "_graph", ".", "get_descendants", "(", "self", ".", "treatment_name", ")", "-", "set", "(", "self", ".", "outcome_name", ")", "\n", "# For simplicity, assuming a one-variable mediation set", "\n", "for", "candidate_var", "in", "eligible_variables", ":", "\n", "            ", "is_valid_mediation", "=", "self", ".", "_graph", ".", "check_valid_mediation_set", "(", "self", ".", "treatment_name", ",", "\n", "self", ".", "outcome_name", ",", "parse_state", "(", "candidate_var", ")", ",", "mediation_paths", "=", "mediation_paths", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Candidate mediation set: {0}, on_mediating_path: {1}\"", ".", "format", "(", "candidate_var", ",", "is_valid_mediation", ")", ")", "\n", "if", "is_valid_mediation", ":", "\n", "                ", "mediation_var", "=", "candidate_var", "\n", "break", "\n", "", "", "return", "parse_state", "(", "mediation_var", ")", "\n", "\n", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation_first_stage_confounders": [[479, 494], ["causal_identifier.CausalIdentifier.identify_backdoor", "causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "causal_identifier.CausalIdentifier.get_default_backdoor_set_id", "estimands_dict.get", "backdoor_variables_dict.get", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.get_default_backdoor_set_id"], ["", "def", "identify_mediation_first_stage_confounders", "(", "self", ",", "treatment_name", ",", "mediators_names", ")", ":", "\n", "# Create estimands dict as per the API for backdoor, but do not return it", "\n", "        ", "estimands_dict", "=", "{", "}", "\n", "backdoor_sets", "=", "self", ".", "identify_backdoor", "(", "treatment_name", ",", "mediators_names", ")", "\n", "estimands_dict", ",", "backdoor_variables_dict", "=", "self", ".", "build_backdoor_estimands_dict", "(", "\n", "treatment_name", ",", "\n", "mediators_names", ",", "\n", "backdoor_sets", ",", "\n", "estimands_dict", ",", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "# Setting default \"backdoor\" identification adjustment set", "\n", "default_backdoor_id", "=", "self", ".", "get_default_backdoor_set_id", "(", "backdoor_variables_dict", ")", "\n", "estimands_dict", "[", "\"backdoor\"", "]", "=", "estimands_dict", ".", "get", "(", "str", "(", "default_backdoor_id", ")", ",", "None", ")", "\n", "backdoor_variables_dict", "[", "\"backdoor\"", "]", "=", "backdoor_variables_dict", ".", "get", "(", "str", "(", "default_backdoor_id", ")", ",", "None", ")", "\n", "return", "backdoor_variables_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_mediation_second_stage_confounders": [[495, 510], ["causal_identifier.CausalIdentifier.identify_backdoor", "causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "causal_identifier.CausalIdentifier.get_default_backdoor_set_id", "estimands_dict.get", "backdoor_variables_dict.get", "str", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.build_backdoor_estimands_dict", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.get_default_backdoor_set_id"], ["", "def", "identify_mediation_second_stage_confounders", "(", "self", ",", "mediators_names", ",", "outcome_name", ")", ":", "\n", "# Create estimands dict as per the API for backdoor, but do not return it", "\n", "        ", "estimands_dict", "=", "{", "}", "\n", "backdoor_sets", "=", "self", ".", "identify_backdoor", "(", "mediators_names", ",", "outcome_name", ")", "\n", "estimands_dict", ",", "backdoor_variables_dict", "=", "self", ".", "build_backdoor_estimands_dict", "(", "\n", "mediators_names", ",", "\n", "outcome_name", ",", "\n", "backdoor_sets", ",", "\n", "estimands_dict", ",", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "# Setting default \"backdoor\" identification adjustment set", "\n", "default_backdoor_id", "=", "self", ".", "get_default_backdoor_set_id", "(", "backdoor_variables_dict", ")", "\n", "estimands_dict", "[", "\"backdoor\"", "]", "=", "estimands_dict", ".", "get", "(", "str", "(", "default_backdoor_id", ")", ",", "None", ")", "\n", "backdoor_variables_dict", "[", "\"backdoor\"", "]", "=", "backdoor_variables_dict", ".", "get", "(", "str", "(", "default_backdoor_id", ")", ",", "None", ")", "\n", "return", "backdoor_variables_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_backdoor_estimand": [[511, 543], ["sympy.Symbol", "sympy.Symbol", "sympy.Symbol", "sympy.Symbol", "sympy.Normal", "sympy.Normal", "sympy.Array", "sympy.Array", "sympy.Expectation", "sympy.Expectation", "sympy.Derivative", "sympy.Derivative", "len", "sympy.Symbol", "sympy.Symbol"], "methods", ["None"], ["", "def", "construct_backdoor_estimand", "(", "self", ",", "estimand_type", ",", "treatment_name", ",", "\n", "outcome_name", ",", "common_causes", ")", ":", "\n", "# TODO: outputs string for now, but ideally should do symbolic", "\n", "# expressions Mon 19 Feb 2018 04:54:17 PM DST", "\n", "# TODO Better support for multivariate treatments", "\n", "\n", "        ", "expr", "=", "None", "\n", "outcome_name", "=", "outcome_name", "[", "0", "]", "\n", "num_expr_str", "=", "outcome_name", "\n", "if", "len", "(", "common_causes", ")", ">", "0", ":", "\n", "            ", "num_expr_str", "+=", "\"|\"", "+", "\",\"", ".", "join", "(", "common_causes", ")", "\n", "", "expr", "=", "\"d(\"", "+", "num_expr_str", "+", "\")/d\"", "+", "\",\"", ".", "join", "(", "treatment_name", ")", "\n", "sym_mu", "=", "sp", ".", "Symbol", "(", "\"mu\"", ")", "\n", "sym_sigma", "=", "sp", ".", "Symbol", "(", "\"sigma\"", ",", "positive", "=", "True", ")", "\n", "sym_outcome", "=", "spstats", ".", "Normal", "(", "num_expr_str", ",", "sym_mu", ",", "sym_sigma", ")", "\n", "sym_treatment_symbols", "=", "[", "sp", ".", "Symbol", "(", "t", ")", "for", "t", "in", "treatment_name", "]", "\n", "sym_treatment", "=", "sp", ".", "Array", "(", "sym_treatment_symbols", ")", "\n", "sym_conditional_outcome", "=", "spstats", ".", "Expectation", "(", "sym_outcome", ")", "\n", "sym_effect", "=", "sp", ".", "Derivative", "(", "sym_conditional_outcome", ",", "sym_treatment", ")", "\n", "\n", "sym_assumptions", "=", "{", "\n", "'Unconfoundedness'", ":", "(", "\n", "u\"If U\\N{RIGHTWARDS ARROW}{{{0}}} and U\\N{RIGHTWARDS ARROW}{1}\"", "\n", "\" then P({1}|{0},{2},U) = P({1}|{0},{2})\"", "\n", ")", ".", "format", "(", "\",\"", ".", "join", "(", "treatment_name", ")", ",", "outcome_name", ",", "\",\"", ".", "join", "(", "common_causes", ")", ")", "\n", "}", "\n", "\n", "estimand", "=", "{", "\n", "'estimand'", ":", "sym_effect", ",", "\n", "'assumptions'", ":", "sym_assumptions", "\n", "}", "\n", "return", "estimand", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_iv_estimand": [[544, 574], ["sympy.Normal", "sympy.Normal", "sympy.Array", "sympy.Array", "sympy.Array", "sympy.Array", "sympy.Derivative", "sympy.Derivative", "sympy.Derivative", "sympy.Derivative", "sympy.Expectation", "sympy.Expectation", "sympy.Normal", "sympy.Normal", "sympy.Symbol", "sympy.Symbol"], "methods", ["None"], ["", "def", "construct_iv_estimand", "(", "self", ",", "estimand_type", ",", "treatment_name", ",", "\n", "outcome_name", ",", "instrument_names", ")", ":", "\n", "# TODO: support multivariate treatments better.", "\n", "        ", "expr", "=", "None", "\n", "outcome_name", "=", "outcome_name", "[", "0", "]", "\n", "sym_outcome", "=", "spstats", ".", "Normal", "(", "outcome_name", ",", "0", ",", "1", ")", "\n", "sym_treatment_symbols", "=", "[", "spstats", ".", "Normal", "(", "t", ",", "0", ",", "1", ")", "for", "t", "in", "treatment_name", "]", "\n", "sym_treatment", "=", "sp", ".", "Array", "(", "sym_treatment_symbols", ")", "\n", "sym_instrument_symbols", "=", "[", "sp", ".", "Symbol", "(", "inst", ")", "for", "inst", "in", "instrument_names", "]", "\n", "sym_instrument", "=", "sp", ".", "Array", "(", "sym_instrument_symbols", ")", "# \",\".join(instrument_names))", "\n", "sym_outcome_derivative", "=", "sp", ".", "Derivative", "(", "sym_outcome", ",", "sym_instrument", ")", "\n", "sym_treatment_derivative", "=", "sp", ".", "Derivative", "(", "sym_treatment", ",", "sym_instrument", ")", "\n", "sym_effect", "=", "spstats", ".", "Expectation", "(", "sym_outcome_derivative", "/", "sym_treatment_derivative", ")", "\n", "sym_assumptions", "=", "{", "\n", "\"As-if-random\"", ":", "(", "\n", "\"If U\\N{RIGHTWARDS ARROW}\\N{RIGHTWARDS ARROW}{0} then \"", "\n", "\"\\N{NOT SIGN}(U \\N{RIGHTWARDS ARROW}\\N{RIGHTWARDS ARROW}{{{1}}})\"", "\n", ")", ".", "format", "(", "outcome_name", ",", "\",\"", ".", "join", "(", "instrument_names", ")", ")", ",", "\n", "\"Exclusion\"", ":", "(", "\n", "u\"If we remove {{{0}}}\\N{RIGHTWARDS ARROW}{{{1}}}, then \"", "\n", "u\"\\N{NOT SIGN}({{{0}}}\\N{RIGHTWARDS ARROW}{2})\"", "\n", ")", ".", "format", "(", "\",\"", ".", "join", "(", "instrument_names", ")", ",", "\",\"", ".", "join", "(", "treatment_name", ")", ",", "\n", "outcome_name", ")", "\n", "}", "\n", "\n", "estimand", "=", "{", "\n", "'estimand'", ":", "sym_effect", ",", "\n", "'assumptions'", ":", "sym_assumptions", "\n", "}", "\n", "return", "estimand", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_frontdoor_estimand": [[575, 607], ["sympy.Normal", "sympy.Normal", "sympy.Array", "sympy.Array", "sympy.Array", "sympy.Array", "sympy.Derivative", "sympy.Derivative", "sympy.Derivative", "sympy.Derivative", "sympy.Expectation", "sympy.Expectation", "sympy.Normal", "sympy.Normal", "sympy.Symbol", "sympy.Symbol"], "methods", ["None"], ["", "def", "construct_frontdoor_estimand", "(", "self", ",", "estimand_type", ",", "treatment_name", ",", "\n", "outcome_name", ",", "frontdoor_variables_names", ")", ":", "\n", "# TODO: support multivariate treatments better.", "\n", "        ", "expr", "=", "None", "\n", "outcome_name", "=", "outcome_name", "[", "0", "]", "\n", "sym_outcome", "=", "spstats", ".", "Normal", "(", "outcome_name", ",", "0", ",", "1", ")", "\n", "sym_treatment_symbols", "=", "[", "spstats", ".", "Normal", "(", "t", ",", "0", ",", "1", ")", "for", "t", "in", "treatment_name", "]", "\n", "sym_treatment", "=", "sp", ".", "Array", "(", "sym_treatment_symbols", ")", "\n", "sym_frontdoor_symbols", "=", "[", "sp", ".", "Symbol", "(", "inst", ")", "for", "inst", "in", "frontdoor_variables_names", "]", "\n", "sym_frontdoor", "=", "sp", ".", "Array", "(", "sym_frontdoor_symbols", ")", "# \",\".join(instrument_names))", "\n", "sym_outcome_derivative", "=", "sp", ".", "Derivative", "(", "sym_outcome", ",", "sym_frontdoor", ")", "\n", "sym_treatment_derivative", "=", "sp", ".", "Derivative", "(", "sym_frontdoor", ",", "sym_treatment", ")", "\n", "sym_effect", "=", "spstats", ".", "Expectation", "(", "sym_treatment_derivative", "*", "sym_outcome_derivative", ")", "\n", "sym_assumptions", "=", "{", "\n", "\"Full-mediation\"", ":", "(", "\n", "\"{2} intercepts (blocks) all directed paths from {0} to {1}.\"", "\n", ")", ".", "format", "(", "\",\"", ".", "join", "(", "treatment_name", ")", ",", "\",\"", ".", "join", "(", "outcome_name", ")", ",", "\",\"", ".", "join", "(", "frontdoor_variables_names", ")", ")", ",", "\n", "\"First-stage-unconfoundedness\"", ":", "(", "\n", "u\"If U\\N{RIGHTWARDS ARROW}{{{0}}} and U\\N{RIGHTWARDS ARROW}{{{1}}}\"", "\n", "\" then P({1}|{0},U) = P({1}|{0})\"", "\n", ")", ".", "format", "(", "\",\"", ".", "join", "(", "treatment_name", ")", ",", "\",\"", ".", "join", "(", "frontdoor_variables_names", ")", ")", ",", "\n", "\"Second-stage-unconfoundedness\"", ":", "(", "\n", "u\"If U\\N{RIGHTWARDS ARROW}{{{2}}} and U\\N{RIGHTWARDS ARROW}{1}\"", "\n", "\" then P({1}|{2}, {0}, U) = P({1}|{2}, {0})\"", "\n", ")", ".", "format", "(", "\",\"", ".", "join", "(", "treatment_name", ")", ",", "outcome_name", ",", "\",\"", ".", "join", "(", "frontdoor_variables_names", ")", ")", "\n", "}", "\n", "\n", "estimand", "=", "{", "\n", "'estimand'", ":", "sym_effect", ",", "\n", "'assumptions'", ":", "sym_assumptions", "\n", "}", "\n", "return", "estimand", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.construct_mediation_estimand": [[608, 656], ["sympy.Normal", "sympy.Normal", "sympy.Array", "sympy.Array", "sympy.Array", "sympy.Array", "sympy.Derivative", "sympy.Derivative", "sympy.Derivative", "sympy.Derivative", "sympy.Symbol", "sympy.Symbol", "sympy.Symbol", "sympy.Symbol", "sympy.Normal", "sympy.Normal", "sympy.Derivative", "sympy.Derivative", "ValueError", "sympy.Normal", "sympy.Normal", "sympy.Symbol", "sympy.Symbol", "len", "sympy.Expectation", "sympy.Expectation", "sympy.Expectation", "sympy.Expectation"], "methods", ["None"], ["", "def", "construct_mediation_estimand", "(", "self", ",", "estimand_type", ",", "treatment_name", ",", "\n", "outcome_name", ",", "mediators_names", ")", ":", "\n", "# TODO: support multivariate treatments better.", "\n", "        ", "expr", "=", "None", "\n", "if", "estimand_type", "in", "(", "CausalIdentifier", ".", "NONPARAMETRIC_NDE", ",", "CausalIdentifier", ".", "NONPARAMETRIC_NIE", ")", ":", "\n", "            ", "outcome_name", "=", "outcome_name", "[", "0", "]", "\n", "sym_outcome", "=", "spstats", ".", "Normal", "(", "outcome_name", ",", "0", ",", "1", ")", "\n", "sym_treatment_symbols", "=", "[", "spstats", ".", "Normal", "(", "t", ",", "0", ",", "1", ")", "for", "t", "in", "treatment_name", "]", "\n", "sym_treatment", "=", "sp", ".", "Array", "(", "sym_treatment_symbols", ")", "\n", "sym_mediators_symbols", "=", "[", "sp", ".", "Symbol", "(", "inst", ")", "for", "inst", "in", "mediators_names", "]", "\n", "sym_mediators", "=", "sp", ".", "Array", "(", "sym_mediators_symbols", ")", "\n", "sym_outcome_derivative", "=", "sp", ".", "Derivative", "(", "sym_outcome", ",", "sym_mediators", ")", "\n", "sym_treatment_derivative", "=", "sp", ".", "Derivative", "(", "sym_mediators", ",", "sym_treatment", ")", "\n", "# For direct effect", "\n", "num_expr_str", "=", "outcome_name", "\n", "if", "len", "(", "mediators_names", ")", ">", "0", ":", "\n", "                ", "num_expr_str", "+=", "\"|\"", "+", "\",\"", ".", "join", "(", "mediators_names", ")", "\n", "", "sym_mu", "=", "sp", ".", "Symbol", "(", "\"mu\"", ")", "\n", "sym_sigma", "=", "sp", ".", "Symbol", "(", "\"sigma\"", ",", "positive", "=", "True", ")", "\n", "sym_conditional_outcome", "=", "spstats", ".", "Normal", "(", "num_expr_str", ",", "sym_mu", ",", "sym_sigma", ")", "\n", "sym_directeffect_derivative", "=", "sp", ".", "Derivative", "(", "sym_conditional_outcome", ",", "sym_treatment", ")", "\n", "if", "estimand_type", "==", "CausalIdentifier", ".", "NONPARAMETRIC_NIE", ":", "\n", "                ", "sym_effect", "=", "spstats", ".", "Expectation", "(", "sym_treatment_derivative", "*", "sym_outcome_derivative", ")", "\n", "", "elif", "estimand_type", "==", "CausalIdentifier", ".", "NONPARAMETRIC_NDE", ":", "\n", "                ", "sym_effect", "=", "spstats", ".", "Expectation", "(", "sym_directeffect_derivative", ")", "\n", "", "sym_assumptions", "=", "{", "\n", "\"Mediation\"", ":", "(", "\n", "\"{2} intercepts (blocks) all directed paths from {0} to {1} except the path {{{0}}}\\N{RIGHTWARDS ARROW}{{{1}}}.\"", "\n", ")", ".", "format", "(", "\",\"", ".", "join", "(", "treatment_name", ")", ",", "\",\"", ".", "join", "(", "outcome_name", ")", ",", "\",\"", ".", "join", "(", "mediators_names", ")", ")", ",", "\n", "\"First-stage-unconfoundedness\"", ":", "(", "\n", "u\"If U\\N{RIGHTWARDS ARROW}{{{0}}} and U\\N{RIGHTWARDS ARROW}{{{1}}}\"", "\n", "\" then P({1}|{0},U) = P({1}|{0})\"", "\n", ")", ".", "format", "(", "\",\"", ".", "join", "(", "treatment_name", ")", ",", "\",\"", ".", "join", "(", "mediators_names", ")", ")", ",", "\n", "\"Second-stage-unconfoundedness\"", ":", "(", "\n", "u\"If U\\N{RIGHTWARDS ARROW}{{{2}}} and U\\N{RIGHTWARDS ARROW}{1}\"", "\n", "\" then P({1}|{2}, {0}, U) = P({1}|{2}, {0})\"", "\n", ")", ".", "format", "(", "\",\"", ".", "join", "(", "treatment_name", ")", ",", "outcome_name", ",", "\",\"", ".", "join", "(", "mediators_names", ")", ")", "\n", "}", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Estimand type not supported. Supported estimand types are {0} or {1}'.\"", ".", "format", "(", "\n", "CausalIdentifier", ".", "NONPARAMETRIC_NDE", ",", "\n", "CausalIdentifier", ".", "NONPARAMETRIC_NIE", ")", ")", "\n", "\n", "", "estimand", "=", "{", "\n", "'estimand'", ":", "sym_effect", ",", "\n", "'assumptions'", ":", "sym_assumptions", "\n", "}", "\n", "return", "estimand", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.__init__": [[664, 687], ["dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state"], ["def", "__init__", "(", "self", ",", "identifier", ",", "treatment_variable", ",", "outcome_variable", ",", "\n", "estimand_type", "=", "None", ",", "estimands", "=", "None", ",", "\n", "backdoor_variables", "=", "None", ",", "instrumental_variables", "=", "None", ",", "\n", "frontdoor_variables", "=", "None", ",", "\n", "mediator_variables", "=", "None", ",", "\n", "mediation_first_stage_confounders", "=", "None", ",", "\n", "mediation_second_stage_confounders", "=", "None", ",", "\n", "default_backdoor_id", "=", "None", ",", "identifier_method", "=", "None", ",", "\n", "no_directed_path", "=", "False", ")", ":", "\n", "        ", "self", ".", "identifier", "=", "identifier", "\n", "self", ".", "treatment_variable", "=", "parse_state", "(", "treatment_variable", ")", "\n", "self", ".", "outcome_variable", "=", "parse_state", "(", "outcome_variable", ")", "\n", "self", ".", "backdoor_variables", "=", "backdoor_variables", "\n", "self", ".", "instrumental_variables", "=", "parse_state", "(", "instrumental_variables", ")", "\n", "self", ".", "frontdoor_variables", "=", "parse_state", "(", "frontdoor_variables", ")", "\n", "self", ".", "mediator_variables", "=", "parse_state", "(", "mediator_variables", ")", "\n", "self", ".", "mediation_first_stage_confounders", "=", "mediation_first_stage_confounders", "\n", "self", ".", "mediation_second_stage_confounders", "=", "mediation_second_stage_confounders", "\n", "self", ".", "estimand_type", "=", "estimand_type", "\n", "self", ".", "estimands", "=", "estimands", "\n", "self", ".", "default_backdoor_id", "=", "default_backdoor_id", "\n", "self", ".", "identifier_method", "=", "identifier_method", "\n", "self", ".", "no_directed_path", "=", "no_directed_path", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.set_identifier_method": [[688, 690], ["None"], "methods", ["None"], ["", "def", "set_identifier_method", "(", "self", ",", "identifier_name", ")", ":", "\n", "        ", "self", ".", "identifier_method", "=", "identifier_name", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables": [[691, 707], ["causal_identifier.IdentifiedEstimand.identifier_method.startswith", "len"], "methods", ["None"], ["", "def", "get_backdoor_variables", "(", "self", ",", "key", "=", "None", ")", ":", "\n", "        ", "\"\"\" Return a list containing the backdoor variables.\n\n            If the calling estimator method is a backdoor method, return the\n            backdoor variables corresponding to its target estimand.\n            Otherwise, return the backdoor variables for the default backdoor estimand.\n        \"\"\"", "\n", "if", "key", "is", "None", ":", "\n", "            ", "if", "self", ".", "identifier_method", "and", "self", ".", "identifier_method", ".", "startswith", "(", "\"backdoor\"", ")", ":", "\n", "                ", "return", "self", ".", "backdoor_variables", "[", "self", ".", "identifier_method", "]", "\n", "", "elif", "self", ".", "backdoor_variables", "is", "not", "None", "and", "len", "(", "self", ".", "backdoor_variables", ")", ">", "0", ":", "\n", "                ", "return", "self", ".", "backdoor_variables", "[", "self", ".", "default_backdoor_id", "]", "\n", "", "else", ":", "\n", "                ", "return", "[", "]", "\n", "", "", "else", ":", "\n", "            ", "return", "self", ".", "backdoor_variables", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.set_backdoor_variables": [[708, 712], ["None"], "methods", ["None"], ["", "", "def", "set_backdoor_variables", "(", "self", ",", "bdoor_variables_arr", ",", "key", "=", "None", ")", ":", "\n", "        ", "if", "key", "is", "None", ":", "\n", "            ", "key", "=", "self", ".", "identifier_method", "\n", "", "self", ".", "backdoor_variables", "[", "key", "]", "=", "bdoor_variables_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_frontdoor_variables": [[713, 717], ["None"], "methods", ["None"], ["", "def", "get_frontdoor_variables", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a list containing the frontdoor variables (if present)\n        \"\"\"", "\n", "return", "self", ".", "frontdoor_variables", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_mediator_variables": [[718, 722], ["None"], "methods", ["None"], ["", "def", "get_mediator_variables", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a list containing the mediator variables (if present)\n        \"\"\"", "\n", "return", "self", ".", "mediator_variables", "\n", "", "def", "get_instrumental_variables", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_instrumental_variables": [[722, 726], ["None"], "methods", ["None"], ["", "def", "get_instrumental_variables", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a list containing the instrumental variables (if present)\n        \"\"\"", "\n", "return", "self", ".", "instrumental_variables", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.__deepcopy__": [[727, 740], ["causal_identifier.IdentifiedEstimand", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy"], "methods", ["None"], ["", "def", "__deepcopy__", "(", "self", ",", "memo", ")", ":", "\n", "        ", "return", "IdentifiedEstimand", "(", "\n", "self", ".", "identifier", ",", "# not deep copied", "\n", "copy", ".", "deepcopy", "(", "self", ".", "treatment_variable", ")", ",", "\n", "copy", ".", "deepcopy", "(", "self", ".", "outcome_variable", ")", ",", "\n", "estimand_type", "=", "copy", ".", "deepcopy", "(", "self", ".", "estimand_type", ")", ",", "\n", "estimands", "=", "copy", ".", "deepcopy", "(", "self", ".", "estimands", ")", ",", "\n", "backdoor_variables", "=", "copy", ".", "deepcopy", "(", "self", ".", "backdoor_variables", ")", ",", "\n", "instrumental_variables", "=", "copy", ".", "deepcopy", "(", "self", ".", "instrumental_variables", ")", ",", "\n", "frontdoor_variables", "=", "copy", ".", "deepcopy", "(", "self", ".", "frontdoor_variables", ")", ",", "\n", "mediator_variables", "=", "copy", ".", "deepcopy", "(", "self", ".", "mediator_variables", ")", ",", "\n", "default_backdoor_id", "=", "copy", ".", "deepcopy", "(", "self", ".", "default_backdoor_id", ")", ",", "\n", "identifier_method", "=", "copy", ".", "deepcopy", "(", "self", ".", "identifier_method", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.__str__": [[742, 779], ["sum", "causal_identifier.IdentifiedEstimand.estimands.items", "sympy.pretty", "sympy.pretty", "v[].items", "causal_identifier.IdentifiedEstimand.estimands.keys", "k.startswith"], "methods", ["None"], ["", "def", "__str__", "(", "self", ",", "only_target_estimand", "=", "False", ",", "show_all_backdoor_sets", "=", "False", ")", ":", "\n", "        ", "if", "self", ".", "no_directed_path", ":", "\n", "            ", "s", "=", "\"No directed path from {0} to {1} in the causal graph.\"", ".", "format", "(", "\n", "self", ".", "treatment_variable", ",", "\n", "self", ".", "outcome_variable", ")", "\n", "s", "+=", "\"\\nCausal effect is zero.\"", "\n", "return", "s", "\n", "", "s", "=", "\"Estimand type: {0}\\n\"", ".", "format", "(", "self", ".", "estimand_type", ")", "\n", "i", "=", "1", "\n", "has_valid_backdoor", "=", "sum", "(", "\"backdoor\"", "in", "key", "for", "key", "in", "self", ".", "estimands", ".", "keys", "(", ")", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "estimands", ".", "items", "(", ")", ":", "\n", "            ", "if", "show_all_backdoor_sets", ":", "\n", "# Do not show backdoor key unless it is the only backdoor set.", "\n", "                ", "if", "k", "==", "\"backdoor\"", "and", "has_valid_backdoor", ">", "1", ":", "\n", "                    ", "continue", "\n", "", "", "else", ":", "\n", "# Just show the default backdoor set", "\n", "                ", "if", "k", ".", "startswith", "(", "\"backdoor\"", ")", "and", "k", "!=", "\"backdoor\"", ":", "\n", "                    ", "continue", "\n", "", "", "if", "only_target_estimand", "and", "k", "!=", "self", ".", "identifier_method", ":", "\n", "                ", "continue", "\n", "", "s", "+=", "\"\\n### Estimand : {0}\\n\"", ".", "format", "(", "i", ")", "\n", "s", "+=", "\"Estimand name: {0}\"", ".", "format", "(", "k", ")", "\n", "if", "k", "==", "self", ".", "default_backdoor_id", ":", "\n", "                ", "s", "+=", "\" (Default)\"", "\n", "", "s", "+=", "\"\\n\"", "\n", "if", "v", "is", "None", ":", "\n", "                ", "s", "+=", "\"No such variable(s) found!\\n\"", "\n", "", "else", ":", "\n", "                ", "sp_expr_str", "=", "sp", ".", "pretty", "(", "v", "[", "\"estimand\"", "]", ",", "use_unicode", "=", "True", ")", "\n", "s", "+=", "\"Estimand expression:\\n{0}\\n\"", ".", "format", "(", "sp_expr_str", ")", "\n", "j", "=", "1", "\n", "for", "ass_name", ",", "ass_str", "in", "v", "[", "\"assumptions\"", "]", ".", "items", "(", ")", ":", "\n", "                    ", "s", "+=", "\"Estimand assumption {0}, {1}: {2}\\n\"", ".", "format", "(", "j", ",", "ass_name", ",", "ass_str", ")", "\n", "j", "+=", "1", "\n", "", "", "i", "+=", "1", "\n", "", "return", "s", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.sigmoid": [[16, 18], ["math.exp"], "function", ["None"], ["def", "sigmoid", "(", "x", ")", ":", "\n", "    ", "return", "1", "/", "(", "1", "+", "math", ".", "exp", "(", "-", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.convert_to_binary": [[19, 25], ["datasets.sigmoid", "numpy.random.choice", "int"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.sigmoid"], ["", "def", "convert_to_binary", "(", "x", ",", "stochastic", "=", "True", ")", ":", "\n", "    ", "p", "=", "sigmoid", "(", "x", ")", "\n", "if", "stochastic", ":", "\n", "        ", "return", "choice", "(", "[", "0", ",", "1", "]", ",", "1", ",", "p", "=", "[", "1", "-", "p", ",", "p", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "int", "(", "p", ">", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.stochastically_convert_to_three_level_categorical": [[26, 29], ["datasets.sigmoid", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.sigmoid"], ["", "", "def", "stochastically_convert_to_three_level_categorical", "(", "x", ")", ":", "\n", "    ", "p", "=", "sigmoid", "(", "x", ")", "\n", "return", "choice", "(", "[", "0", ",", "1", ",", "2", "]", ",", "1", ",", "p", "=", "[", "0.8", "*", "(", "1", "-", "p", ")", ",", "0.8", "*", "p", ",", "0.2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.convert_to_categorical": [[30, 47], ["arr.copy", "range", "range", "numpy.quantile", "numpy.digitize", "numpy.delete", "numpy.concatenate", "numpy.concatenate", "numpy.eye", "len"], "function", ["None"], ["", "def", "convert_to_categorical", "(", "arr", ",", "num_vars", ",", "num_discrete_vars", ",", "\n", "quantiles", "=", "[", "0.25", ",", "0.5", ",", "0.75", "]", ",", "one_hot_encode", "=", "False", ")", ":", "\n", "    ", "arr_with_dummy", "=", "arr", ".", "copy", "(", ")", "\n", "# Below loop assumes that the last indices of W are alwawys converted to discrete", "\n", "for", "arr_index", "in", "range", "(", "num_vars", "-", "num_discrete_vars", ",", "num_vars", ")", ":", "\n", "# one-hot encode discrete W", "\n", "        ", "arr_bins", "=", "np", ".", "quantile", "(", "arr", "[", ":", ",", "arr_index", "]", ",", "q", "=", "quantiles", ")", "\n", "arr_categorical", "=", "np", ".", "digitize", "(", "arr", "[", ":", ",", "arr_index", "]", ",", "bins", "=", "arr_bins", ")", "\n", "if", "one_hot_encode", ":", "\n", "            ", "dummy_vecs", "=", "np", ".", "eye", "(", "len", "(", "quantiles", ")", "+", "1", ")", "[", "arr_categorical", "]", "\n", "arr_with_dummy", "=", "np", ".", "concatenate", "(", "(", "arr_with_dummy", ",", "dummy_vecs", ")", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "arr_with_dummy", "=", "np", ".", "concatenate", "(", "(", "arr_with_dummy", ",", "arr_categorical", "[", ":", ",", "np", ".", "newaxis", "]", ")", ",", "axis", "=", "1", ")", "\n", "# Now deleting the old continuous value", "\n", "", "", "for", "arr_index", "in", "range", "(", "num_vars", "-", "1", ",", "num_vars", "-", "num_discrete_vars", "-", "1", ",", "-", "1", ")", ":", "\n", "        ", "arr_with_dummy", "=", "np", ".", "delete", "(", "arr_with_dummy", ",", "arr_index", ",", "axis", "=", "1", ")", "\n", "", "return", "arr_with_dummy", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.construct_col_names": [[48, 60], ["str", "range", "str", "range", "range", "str", "range", "str"], "function", ["None"], ["", "def", "construct_col_names", "(", "name", ",", "num_vars", ",", "num_discrete_vars", ",", "\n", "num_discrete_levels", ",", "one_hot_encode", ")", ":", "\n", "    ", "colnames", "=", "[", "(", "name", "+", "str", "(", "i", ")", ")", "for", "i", "in", "range", "(", "0", ",", "num_vars", "-", "num_discrete_vars", ")", "]", "\n", "if", "one_hot_encode", ":", "\n", "        ", "discrete_colnames", "=", "[", "name", "+", "str", "(", "i", ")", "+", "\"_\"", "+", "str", "(", "j", ")", "\n", "for", "i", "in", "range", "(", "num_vars", "-", "num_discrete_vars", ",", "num_vars", ")", "\n", "for", "j", "in", "range", "(", "0", ",", "num_discrete_levels", ")", "]", "\n", "colnames", "=", "colnames", "+", "discrete_colnames", "\n", "", "else", ":", "\n", "        ", "colnames", "=", "colnames", "+", "[", "(", "name", "+", "str", "(", "i", ")", ")", "for", "i", "in", "range", "(", "num_vars", "-", "num_discrete_vars", ",", "num_vars", ")", "]", "\n", "\n", "", "return", "colnames", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset": [[61, 231], ["float", "numpy.random.normal", "datasets.linear_dataset._compute_y"], "function", ["None"], ["", "def", "linear_dataset", "(", "beta", ",", "num_common_causes", ",", "num_samples", ",", "num_instruments", "=", "0", ",", "\n", "num_effect_modifiers", "=", "0", ",", "\n", "num_treatments", "=", "1", ",", "\n", "num_frontdoor_variables", "=", "0", ",", "\n", "treatment_is_binary", "=", "True", ",", "\n", "treatment_is_category", "=", "False", ",", "\n", "outcome_is_binary", "=", "False", ",", "\n", "stochastic_discretization", "=", "True", ",", "\n", "num_discrete_common_causes", "=", "0", ",", "\n", "num_discrete_instruments", "=", "0", ",", "\n", "num_discrete_effect_modifiers", "=", "0", ",", "\n", "stddev_treatment_noise", "=", "1", ",", "\n", "stddev_outcome_noise", "=", "0.01", ",", "\n", "one_hot_encode", "=", "False", ")", ":", "\n", "    ", "assert", "not", "(", "treatment_is_binary", "and", "treatment_is_category", ")", "\n", "W", ",", "X", ",", "Z", ",", "FD", ",", "c1", ",", "c2", ",", "ce", ",", "cz", ",", "cfd1", ",", "cfd2", "=", "[", "None", "]", "*", "10", "\n", "W_with_dummy", ",", "X_with_categorical", "=", "(", "None", ",", "None", ")", "\n", "beta", "=", "float", "(", "beta", ")", "\n", "# Making beta an array", "\n", "if", "type", "(", "beta", ")", "not", "in", "[", "list", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "beta", "=", "np", ".", "repeat", "(", "beta", ",", "num_treatments", ")", "\n", "", "num_cont_common_causes", "=", "num_common_causes", "-", "num_discrete_common_causes", "\n", "num_cont_instruments", "=", "num_instruments", "-", "num_discrete_instruments", "\n", "num_cont_effect_modifiers", "=", "num_effect_modifiers", "-", "num_discrete_effect_modifiers", "\n", "if", "num_common_causes", ">", "0", ":", "\n", "        ", "range_c1", "=", "0.5", "+", "max", "(", "abs", "(", "beta", ")", ")", "*", "0.5", "\n", "range_c2", "=", "0.5", "+", "max", "(", "abs", "(", "beta", ")", ")", "*", "0.5", "\n", "means", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "num_common_causes", ")", "\n", "cov_mat", "=", "np", ".", "diag", "(", "np", ".", "ones", "(", "num_common_causes", ")", ")", "\n", "W", "=", "np", ".", "random", ".", "multivariate_normal", "(", "means", ",", "cov_mat", ",", "num_samples", ")", "\n", "W_with_dummy", "=", "convert_to_categorical", "(", "W", ",", "num_common_causes", ",", "num_discrete_common_causes", ",", "\n", "quantiles", "=", "[", "0.25", ",", "0.5", ",", "0.75", "]", ",", "one_hot_encode", "=", "one_hot_encode", ")", "\n", "c1", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "range_c1", ",", "(", "W_with_dummy", ".", "shape", "[", "1", "]", ",", "num_treatments", ")", ")", "\n", "c2", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "range_c2", ",", "W_with_dummy", ".", "shape", "[", "1", "]", ")", "\n", "\n", "", "if", "num_instruments", ">", "0", ":", "\n", "        ", "range_cz", "=", "1", "+", "max", "(", "abs", "(", "beta", ")", ")", "\n", "p", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "num_instruments", ")", "\n", "Z", "=", "np", ".", "zeros", "(", "(", "num_samples", ",", "num_instruments", ")", ")", "\n", "for", "i", "in", "range", "(", "num_instruments", ")", ":", "\n", "            ", "if", "(", "i", "%", "2", ")", "==", "0", ":", "\n", "                ", "Z", "[", ":", ",", "i", "]", "=", "np", ".", "random", ".", "binomial", "(", "n", "=", "1", ",", "p", "=", "p", "[", "i", "]", ",", "size", "=", "num_samples", ")", "\n", "", "else", ":", "\n", "                ", "Z", "[", ":", ",", "i", "]", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "size", "=", "num_samples", ")", "\n", "# TODO Ensure that we do not generate weak instruments", "\n", "", "", "cz", "=", "np", ".", "random", ".", "uniform", "(", "range_cz", "-", "(", "range_cz", "*", "0.05", ")", ",", "\n", "range_cz", "+", "(", "range_cz", "*", "0.05", ")", ",", "(", "num_instruments", ",", "num_treatments", ")", ")", "\n", "", "if", "num_effect_modifiers", ">", "0", ":", "\n", "        ", "range_ce", "=", "0.5", "+", "max", "(", "abs", "(", "beta", ")", ")", "*", "0.5", "\n", "means", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "num_effect_modifiers", ")", "\n", "cov_mat", "=", "np", ".", "diag", "(", "np", ".", "ones", "(", "num_effect_modifiers", ")", ")", "\n", "X", "=", "np", ".", "random", ".", "multivariate_normal", "(", "means", ",", "cov_mat", ",", "num_samples", ")", "\n", "X_with_categorical", "=", "convert_to_categorical", "(", "X", ",", "num_effect_modifiers", ",", "\n", "num_discrete_effect_modifiers", ",", "quantiles", "=", "[", "0.25", ",", "0.5", ",", "0.75", "]", ",", "\n", "one_hot_encode", "=", "one_hot_encode", ")", "\n", "ce", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "range_ce", ",", "X_with_categorical", ".", "shape", "[", "1", "]", ")", "\n", "# TODO - test all our methods with random noise added to covariates (instead of the stochastic treatment assignment)", "\n", "\n", "", "t", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "stddev_treatment_noise", ",", "(", "num_samples", ",", "num_treatments", ")", ")", "\n", "if", "num_common_causes", ">", "0", ":", "\n", "        ", "t", "+=", "W_with_dummy", "@", "c1", "# + np.random.normal(0, 0.01)", "\n", "", "if", "num_instruments", ">", "0", ":", "\n", "        ", "t", "+=", "Z", "@", "cz", "\n", "# Converting treatment to binary if required", "\n", "", "if", "treatment_is_binary", ":", "\n", "        ", "t", "=", "np", ".", "vectorize", "(", "convert_to_binary", ")", "(", "t", ")", "\n", "", "elif", "treatment_is_category", ":", "\n", "        ", "t", "=", "np", ".", "vectorize", "(", "stochastically_convert_to_three_level_categorical", ")", "(", "t", ")", "\n", "\n", "# Generating frontdoor variables if asked for", "\n", "", "if", "num_frontdoor_variables", ">", "0", ":", "\n", "        ", "range_cfd1", "=", "max", "(", "abs", "(", "beta", ")", ")", "*", "0.5", "\n", "range_cfd2", "=", "max", "(", "abs", "(", "beta", ")", ")", "*", "0.5", "\n", "cfd1", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "range_cfd1", ",", "(", "num_treatments", ",", "num_frontdoor_variables", ")", ")", "\n", "cfd2", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "range_cfd2", ",", "num_frontdoor_variables", ")", "\n", "FD_noise", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "num_samples", ",", "num_frontdoor_variables", ")", ")", "\n", "FD", "=", "FD_noise", "\n", "FD", "+=", "t", "@", "cfd1", "\n", "if", "num_common_causes", ">", "0", ":", "\n", "            ", "range_c1_frontdoor", "=", "range_c1", "/", "10.0", "\n", "c1_frontdoor", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "range_c1_frontdoor", ",", "\n", "(", "W_with_dummy", ".", "shape", "[", "1", "]", ",", "num_frontdoor_variables", ")", ")", "\n", "FD", "+=", "W_with_dummy", "@", "c1_frontdoor", "\n", "\n", "", "", "def", "_compute_y", "(", "t", ",", "W", ",", "X", ",", "FD", ",", "beta", ",", "c2", ",", "ce", ",", "cfd2", ",", "stddev_outcome_noise", ")", ":", "\n", "        ", "y", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "stddev_outcome_noise", ",", "num_samples", ")", "\n", "if", "num_frontdoor_variables", ">", "0", ":", "\n", "            ", "y", "+=", "FD", "@", "cfd2", "\n", "", "else", ":", "\n", "# NOTE: We are assuming a linear relationship *even when t is categorical* and integer coded.", "\n", "# For categorical t, this example dataset has the effect size for category 2 being exactly", "\n", "# double the effect for category 1", "\n", "# This could be changed at this stage by one-hot encoding t and using a custom beta that", "\n", "# sets a different effect for each category {0, 1, 2}", "\n", "            ", "y", "+=", "t", "@", "beta", "\n", "", "if", "num_common_causes", ">", "0", ":", "\n", "            ", "y", "+=", "W", "@", "c2", "\n", "", "if", "num_effect_modifiers", ">", "0", ":", "\n", "            ", "y", "+=", "(", "X", "@", "ce", ")", "*", "np", ".", "prod", "(", "t", ",", "axis", "=", "1", ")", "\n", "", "if", "outcome_is_binary", ":", "\n", "            ", "y", "=", "np", ".", "vectorize", "(", "convert_to_binary", ")", "(", "y", ",", "stochastic_discretization", ")", "\n", "", "return", "y", "\n", "\n", "", "y", "=", "_compute_y", "(", "t", ",", "W_with_dummy", ",", "X_with_categorical", ",", "FD", ",", "beta", ",", "c2", ",", "ce", ",", "cfd2", ",", "stddev_outcome_noise", ")", "\n", "\n", "data", "=", "np", ".", "column_stack", "(", "(", "t", ",", "y", ")", ")", "\n", "if", "num_common_causes", ">", "0", ":", "\n", "        ", "data", "=", "np", ".", "column_stack", "(", "(", "W_with_dummy", ",", "data", ")", ")", "\n", "", "if", "num_instruments", ">", "0", ":", "\n", "        ", "data", "=", "np", ".", "column_stack", "(", "(", "Z", ",", "data", ")", ")", "\n", "", "if", "num_effect_modifiers", ">", "0", ":", "\n", "        ", "data", "=", "np", ".", "column_stack", "(", "(", "X_with_categorical", ",", "data", ")", ")", "\n", "", "if", "num_frontdoor_variables", ">", "0", ":", "\n", "        ", "data", "=", "np", ".", "column_stack", "(", "(", "FD", ",", "data", ")", ")", "\n", "\n", "# Computing ATE", "\n", "", "FD_T1", ",", "FD_T0", "=", "None", ",", "None", "\n", "T1", "=", "np", ".", "ones", "(", "(", "num_samples", ",", "num_treatments", ")", ")", "\n", "T0", "=", "np", ".", "zeros", "(", "(", "num_samples", ",", "num_treatments", ")", ")", "\n", "if", "num_frontdoor_variables", ">", "0", ":", "\n", "        ", "FD_T1", "=", "FD_noise", "+", "(", "T1", "@", "cfd1", ")", "\n", "FD_T0", "=", "FD_noise", "+", "(", "T0", "@", "cfd1", ")", "\n", "", "ate", "=", "np", ".", "mean", "(", "\n", "_compute_y", "(", "T1", ",", "W_with_dummy", ",", "X_with_categorical", ",", "FD_T1", ",", "beta", ",", "c2", ",", "ce", ",", "cfd2", ",", "stddev_outcome_noise", ")", "-", "\n", "_compute_y", "(", "T0", ",", "W_with_dummy", ",", "X_with_categorical", ",", "FD_T0", ",", "beta", ",", "c2", ",", "ce", ",", "cfd2", ",", "stddev_outcome_noise", ")", ")", "\n", "\n", "treatments", "=", "[", "(", "\"v\"", "+", "str", "(", "i", ")", ")", "for", "i", "in", "range", "(", "0", ",", "num_treatments", ")", "]", "\n", "outcome", "=", "\"y\"", "\n", "# constructing column names for one-hot encoded discrete features", "\n", "common_causes", "=", "construct_col_names", "(", "\"W\"", ",", "num_common_causes", ",", "num_discrete_common_causes", ",", "\n", "num_discrete_levels", "=", "4", ",", "one_hot_encode", "=", "one_hot_encode", ")", "\n", "instruments", "=", "[", "(", "\"Z\"", "+", "str", "(", "i", ")", ")", "for", "i", "in", "range", "(", "0", ",", "num_instruments", ")", "]", "\n", "frontdoor_variables", "=", "[", "(", "\"FD\"", "+", "str", "(", "i", ")", ")", "for", "i", "in", "range", "(", "0", ",", "num_frontdoor_variables", ")", "]", "\n", "effect_modifiers", "=", "construct_col_names", "(", "\"X\"", ",", "num_effect_modifiers", ",", "\n", "num_discrete_effect_modifiers", ",", "\n", "num_discrete_levels", "=", "4", ",", "one_hot_encode", "=", "one_hot_encode", ")", "\n", "other_variables", "=", "None", "\n", "col_names", "=", "frontdoor_variables", "+", "effect_modifiers", "+", "instruments", "+", "common_causes", "+", "treatments", "+", "[", "outcome", "]", "\n", "data", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "col_names", ")", "\n", "# Specifying the correct dtypes", "\n", "if", "treatment_is_binary", ":", "\n", "        ", "data", "=", "data", ".", "astype", "(", "{", "tname", ":", "\"bool\"", "for", "tname", "in", "treatments", "}", ",", "copy", "=", "False", ")", "\n", "", "elif", "treatment_is_category", ":", "\n", "        ", "data", "=", "data", ".", "astype", "(", "{", "tname", ":", "\"category\"", "for", "tname", "in", "treatments", "}", ",", "copy", "=", "False", ")", "\n", "", "if", "outcome_is_binary", ":", "\n", "        ", "data", "=", "data", ".", "astype", "(", "{", "outcome", ":", "'bool'", "}", ",", "copy", "=", "False", ")", "\n", "", "if", "num_discrete_common_causes", ">", "0", "and", "not", "one_hot_encode", ":", "\n", "        ", "data", "=", "data", ".", "astype", "(", "{", "wname", ":", "'int64'", "for", "wname", "in", "common_causes", "[", "num_cont_common_causes", ":", "]", "}", ",", "copy", "=", "False", ")", "\n", "data", "=", "data", ".", "astype", "(", "{", "wname", ":", "'category'", "for", "wname", "in", "common_causes", "[", "num_cont_common_causes", ":", "]", "}", ",", "copy", "=", "False", ")", "\n", "", "if", "num_discrete_effect_modifiers", ">", "0", "and", "not", "one_hot_encode", ":", "\n", "        ", "data", "=", "data", ".", "astype", "(", "{", "emodname", ":", "'int64'", "for", "emodname", "in", "effect_modifiers", "[", "num_cont_effect_modifiers", ":", "]", "}", ",", "copy", "=", "False", ")", "\n", "data", "=", "data", ".", "astype", "(", "{", "emodname", ":", "'category'", "for", "emodname", "in", "effect_modifiers", "[", "num_cont_effect_modifiers", ":", "]", "}", ",", "copy", "=", "False", ")", "\n", "\n", "# Now specifying the corresponding graph strings", "\n", "", "dot_graph", "=", "create_dot_graph", "(", "treatments", ",", "outcome", ",", "common_causes", ",", "instruments", ",", "effect_modifiers", ",", "frontdoor_variables", ")", "\n", "# Now writing the gml graph", "\n", "gml_graph", "=", "create_gml_graph", "(", "treatments", ",", "outcome", ",", "common_causes", ",", "instruments", ",", "effect_modifiers", ",", "frontdoor_variables", ")", "\n", "ret_dict", "=", "{", "\n", "\"df\"", ":", "data", ",", "\n", "\"treatment_name\"", ":", "treatments", ",", "\n", "\"outcome_name\"", ":", "outcome", ",", "\n", "\"common_causes_names\"", ":", "common_causes", ",", "\n", "\"instrument_names\"", ":", "instruments", ",", "\n", "\"effect_modifier_names\"", ":", "effect_modifiers", ",", "\n", "\"frontdoor_variables_names\"", ":", "frontdoor_variables", ",", "\n", "\"dot_graph\"", ":", "dot_graph", ",", "\n", "\"gml_graph\"", ":", "gml_graph", ",", "\n", "\"ate\"", ":", "ate", "\n", "}", "\n", "return", "ret_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.simple_iv_dataset": [[232, 295], ["float", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.normal", "datasets.linear_dataset._compute_y"], "function", ["None"], ["", "def", "simple_iv_dataset", "(", "beta", ",", "num_samples", ",", "\n", "num_treatments", "=", "1", ",", "\n", "treatment_is_binary", "=", "True", ",", "\n", "outcome_is_binary", "=", "False", ")", ":", "\n", "    ", "\"\"\" Simple instrumental variable dataset with a single IV and a single confounder.\n    \"\"\"", "\n", "W", ",", "Z", ",", "c1", ",", "c2", ",", "cz", "=", "[", "None", "]", "*", "5", "\n", "num_instruments", "=", "1", "\n", "num_common_causes", "=", "1", "\n", "beta", "=", "float", "(", "beta", ")", "\n", "# Making beta an array", "\n", "if", "type", "(", "beta", ")", "not", "in", "[", "list", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "beta", "=", "np", ".", "repeat", "(", "beta", ",", "num_treatments", ")", "\n", "\n", "", "c1", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "(", "num_common_causes", ",", "num_treatments", ")", ")", "\n", "c2", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "num_common_causes", ")", "\n", "range_cz", "=", "1", "+", "max", "(", "abs", "(", "beta", ")", ")", "# cz is much higher than c1 and c2", "\n", "cz", "=", "np", ".", "random", ".", "uniform", "(", "range_cz", "-", "(", "range_cz", "*", "0.05", ")", ",", "\n", "range_cz", "+", "(", "range_cz", "*", "0.05", ")", ",", "(", "num_instruments", ",", "num_treatments", ")", ")", "\n", "W", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "(", "num_samples", ",", "num_common_causes", ")", ")", "\n", "Z", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "num_samples", ",", "num_instruments", ")", ")", "\n", "t", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "num_samples", ",", "num_treatments", ")", ")", "+", "Z", "@", "cz", "+", "W", "@", "c1", "\n", "if", "treatment_is_binary", ":", "\n", "        ", "t", "=", "np", ".", "vectorize", "(", "convert_to_binary", ")", "(", "t", ")", "\n", "\n", "", "def", "_compute_y", "(", "t", ",", "W", ",", "beta", ",", "c2", ")", ":", "\n", "        ", "y", "=", "t", "@", "beta", "+", "W", "@", "c2", "\n", "return", "y", "\n", "", "y", "=", "_compute_y", "(", "t", ",", "W", ",", "beta", ",", "c2", ")", "\n", "\n", "# creating data frame", "\n", "data", "=", "np", ".", "column_stack", "(", "(", "Z", ",", "W", ",", "t", ",", "y", ")", ")", "\n", "treatments", "=", "[", "(", "\"v\"", "+", "str", "(", "i", ")", ")", "for", "i", "in", "range", "(", "0", ",", "num_treatments", ")", "]", "\n", "outcome", "=", "\"y\"", "\n", "common_causes", "=", "[", "(", "\"W\"", "+", "str", "(", "i", ")", ")", "for", "i", "in", "range", "(", "0", ",", "num_common_causes", ")", "]", "\n", "ate", "=", "np", ".", "mean", "(", "_compute_y", "(", "np", ".", "ones", "(", "(", "num_samples", ",", "num_treatments", ")", ")", ",", "W", ",", "beta", ",", "c2", ")", "-", "_compute_y", "(", "np", ".", "zeros", "(", "(", "num_samples", ",", "num_treatments", ")", ")", ",", "W", ",", "beta", ",", "c2", ")", ")", "\n", "instruments", "=", "[", "(", "\"Z\"", "+", "str", "(", "i", ")", ")", "for", "i", "in", "range", "(", "0", ",", "num_instruments", ")", "]", "\n", "other_variables", "=", "None", "\n", "col_names", "=", "instruments", "+", "common_causes", "+", "treatments", "+", "[", "outcome", "]", "\n", "data", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "col_names", ")", "\n", "\n", "# Specifying the correct dtypes", "\n", "if", "treatment_is_binary", ":", "\n", "        ", "data", "=", "data", ".", "astype", "(", "{", "tname", ":", "'bool'", "for", "tname", "in", "treatments", "}", ",", "copy", "=", "False", ")", "\n", "", "if", "outcome_is_binary", ":", "\n", "        ", "data", "=", "data", ".", "astype", "(", "{", "outcome", ":", "'bool'", "}", ",", "copy", "=", "False", ")", "\n", "\n", "# Now specifying the corresponding graph strings", "\n", "", "dot_graph", "=", "create_dot_graph", "(", "treatments", ",", "outcome", ",", "common_causes", ",", "instruments", ")", "\n", "# Now writing the gml graph", "\n", "gml_graph", "=", "create_gml_graph", "(", "treatments", ",", "outcome", ",", "common_causes", ",", "instruments", ")", "\n", "ret_dict", "=", "{", "\n", "\"df\"", ":", "data", ",", "\n", "\"treatment_name\"", ":", "treatments", ",", "\n", "\"outcome_name\"", ":", "outcome", ",", "\n", "\"common_causes_names\"", ":", "common_causes", ",", "\n", "\"instrument_names\"", ":", "instruments", ",", "\n", "\"effect_modifier_names\"", ":", "None", ",", "\n", "\"dot_graph\"", ":", "dot_graph", ",", "\n", "\"gml_graph\"", ":", "gml_graph", ",", "\n", "\"ate\"", ":", "ate", "\n", "}", "\n", "return", "ret_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.create_dot_graph": [[296, 314], ["len"], "function", ["None"], ["", "def", "create_dot_graph", "(", "treatments", ",", "outcome", ",", "common_causes", ",", "\n", "instruments", ",", "effect_modifiers", "=", "[", "]", ",", "frontdoor_variables", "=", "[", "]", ")", ":", "\n", "    ", "dot_graph", "=", "'digraph {'", "\n", "for", "currt", "in", "treatments", ":", "\n", "        ", "if", "len", "(", "frontdoor_variables", ")", "==", "0", ":", "\n", "            ", "dot_graph", "+=", "'{0}->{1};'", ".", "format", "(", "currt", ",", "outcome", ")", "\n", "", "dot_graph", "+=", "\" \"", ".", "join", "(", "[", "v", "+", "\"-> \"", "+", "currt", "+", "\";\"", "for", "v", "in", "common_causes", "]", ")", "\n", "dot_graph", "+=", "\" \"", ".", "join", "(", "[", "v", "+", "\"-> \"", "+", "currt", "+", "\";\"", "for", "v", "in", "instruments", "]", ")", "\n", "dot_graph", "+=", "\" \"", ".", "join", "(", "[", "currt", "+", "\"-> \"", "+", "v", "+", "\";\"", "for", "v", "in", "frontdoor_variables", "]", ")", "\n", "\n", "", "dot_graph", "+=", "\" \"", ".", "join", "(", "[", "v", "+", "\"-> \"", "+", "outcome", "+", "\";\"", "for", "v", "in", "common_causes", "]", ")", "\n", "dot_graph", "+=", "\" \"", ".", "join", "(", "[", "v", "+", "\"-> \"", "+", "outcome", "+", "\";\"", "for", "v", "in", "effect_modifiers", "]", ")", "\n", "dot_graph", "+=", "\" \"", ".", "join", "(", "[", "v", "+", "\"-> \"", "+", "outcome", "+", "\";\"", "for", "v", "in", "frontdoor_variables", "]", ")", "\n", "dot_graph", "=", "dot_graph", "+", "\"}\"", "\n", "# Adding edges between common causes and the frontdoor mediator", "\n", "for", "v1", "in", "common_causes", ":", "\n", "            ", "dot_graph", "+=", "\" \"", ".", "join", "(", "[", "v1", "+", "\"-> \"", "+", "v2", "+", "\";\"", "for", "v2", "in", "frontdoor_variables", "]", ")", "\n", "", "return", "dot_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.create_gml_graph": [[315, 340], ["len"], "function", ["None"], ["", "def", "create_gml_graph", "(", "treatments", ",", "outcome", ",", "common_causes", ",", "\n", "instruments", ",", "effect_modifiers", "=", "[", "]", ",", "frontdoor_variables", "=", "[", "]", ")", ":", "\n", "    ", "gml_graph", "=", "(", "'graph[directed 1'", "\n", "'node[ id \"{0}\" label \"{0}\"]'", "\n", ")", ".", "format", "(", "outcome", ")", "\n", "\n", "gml_graph", "+=", "\" \"", ".", "join", "(", "[", "'node[ id \"{0}\" label \"{0}\"]'", ".", "format", "(", "v", ")", "for", "v", "in", "common_causes", "]", ")", "\n", "gml_graph", "+=", "\" \"", ".", "join", "(", "[", "'node[ id \"{0}\" label \"{0}\"]'", ".", "format", "(", "v", ")", "for", "v", "in", "instruments", "]", ")", "\n", "gml_graph", "+=", "\" \"", ".", "join", "(", "[", "'node[ id \"{0}\" label \"{0}\"]'", ".", "format", "(", "v", ")", "for", "v", "in", "frontdoor_variables", "]", ")", "\n", "for", "currt", "in", "treatments", ":", "\n", "        ", "gml_graph", "+=", "(", "'node[ id \"{0}\" label \"{0}\"]'", "\n", ")", ".", "format", "(", "currt", ")", "\n", "if", "len", "(", "frontdoor_variables", ")", "==", "0", ":", "\n", "            ", "gml_graph", "+=", "'edge[source \"{0}\" target \"{1}\"]'", ".", "format", "(", "currt", ",", "outcome", ")", "\n", "", "gml_graph", "+=", "\" \"", ".", "join", "(", "[", "'edge[ source \"{0}\" target \"{1}\"]'", ".", "format", "(", "v", ",", "currt", ")", "for", "v", "in", "common_causes", "]", ")", "\n", "gml_graph", "+=", "\" \"", ".", "join", "(", "[", "'edge[ source \"{0}\" target \"{1}\"]'", ".", "format", "(", "v", ",", "currt", ")", "for", "v", "in", "instruments", "]", ")", "\n", "gml_graph", "+=", "\" \"", ".", "join", "(", "[", "'edge[ source \"{0}\" target \"{1}\"]'", ".", "format", "(", "currt", ",", "v", ")", "for", "v", "in", "frontdoor_variables", "]", ")", "\n", "\n", "", "gml_graph", "=", "gml_graph", "+", "\" \"", ".", "join", "(", "[", "'edge[ source \"{0}\" target \"{1}\"]'", ".", "format", "(", "v", ",", "outcome", ")", "for", "v", "in", "common_causes", "]", ")", "\n", "gml_graph", "=", "gml_graph", "+", "\" \"", ".", "join", "(", "[", "'node[ id \"{0}\" label \"{0}\"] edge[ source \"{0}\" target \"{1}\"]'", ".", "format", "(", "v", ",", "outcome", ")", "for", "v", "in", "effect_modifiers", "]", ")", "\n", "gml_graph", "=", "gml_graph", "+", "\" \"", ".", "join", "(", "[", "'edge[ source \"{0}\" target \"{1}\"]'", ".", "format", "(", "v", ",", "outcome", ")", "for", "v", "in", "frontdoor_variables", "]", ")", "\n", "for", "v1", "in", "common_causes", ":", "\n", "        ", "gml_graph", "=", "gml_graph", "+", "\" \"", ".", "join", "(", "[", "'edge[ source \"{0}\" target \"{1}\"]'", ".", "format", "(", "v1", ",", "v2", ")", "for", "v2", "in", "frontdoor_variables", "]", ")", "\n", "", "gml_graph", "=", "gml_graph", "+", "']'", "\n", "return", "gml_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.xy_dataset": [[341, 408], ["numpy.random.normal", "numpy.random.normal", "numpy.random.uniform", "pandas.DataFrame", "numpy.random.uniform", "numpy.diag", "numpy.random.multivariate_normal", "numpy.random.uniform", "numpy.random.uniform", "range", "str", "range", "numpy.ones"], "function", ["None"], ["", "def", "xy_dataset", "(", "num_samples", ",", "effect", "=", "True", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "is_linear", "=", "True", ",", "\n", "sd_error", "=", "1", ")", ":", "\n", "    ", "treatment", "=", "'Treatment'", "\n", "outcome", "=", "'Outcome'", "\n", "common_causes", "=", "[", "'w'", "+", "str", "(", "i", ")", "for", "i", "in", "range", "(", "num_common_causes", ")", "]", "\n", "time_var", "=", "'s'", "\n", "# Error terms", "\n", "E1", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0", ",", "scale", "=", "sd_error", ",", "size", "=", "num_samples", ")", "\n", "E2", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0", ",", "scale", "=", "sd_error", ",", "size", "=", "num_samples", ")", "\n", "\n", "S", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "10", ",", "num_samples", ")", "\n", "T1", "=", "4", "-", "(", "S", "-", "3", ")", "*", "(", "S", "-", "3", ")", "\n", "T1", "[", "S", ">=", "5", "]", "=", "0", "\n", "T2", "=", "(", "S", "-", "7", ")", "*", "(", "S", "-", "7", ")", "-", "4", "\n", "T2", "[", "S", "<=", "5", "]", "=", "0", "\n", "W0", "=", "T1", "+", "T2", "# hidden confounder", "\n", "tterm", ",", "yterm", "=", "0", ",", "0", "\n", "if", "num_common_causes", ">", "1", ":", "\n", "        ", "means", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "num_common_causes", "-", "1", ")", "\n", "cov_mat", "=", "np", ".", "diag", "(", "np", ".", "ones", "(", "num_common_causes", "-", "1", ")", ")", "\n", "otherW", "=", "np", ".", "random", ".", "multivariate_normal", "(", "means", ",", "cov_mat", ",", "num_samples", ")", "\n", "c1", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "(", "otherW", ".", "shape", "[", "1", "]", ",", "1", ")", ")", "\n", "c2", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "(", "otherW", ".", "shape", "[", "1", "]", ",", "1", ")", ")", "\n", "tterm", "=", "(", "otherW", "@", "c1", ")", "[", ":", ",", "0", "]", "\n", "yterm", "=", "(", "otherW", "@", "c2", ")", "[", ":", ",", "0", "]", "\n", "\n", "", "if", "is_linear", ":", "\n", "        ", "V", "=", "6", "+", "W0", "+", "tterm", "+", "E1", "\n", "Y", "=", "6", "+", "W0", "+", "yterm", "+", "E2", "# + (V-8)*(V-8)", "\n", "if", "effect", ":", "\n", "            ", "Y", "+=", "V", "\n", "", "else", ":", "\n", "            ", "Y", "+=", "(", "6", "+", "W0", ")", "\n", "", "", "else", ":", "\n", "        ", "V", "=", "6", "+", "W0", "*", "W0", "+", "tterm", "+", "E1", "\n", "Y", "=", "6", "+", "W0", "*", "W0", "+", "yterm", "+", "E2", "# + (V-8)*(V-8)", "\n", "if", "effect", ":", "\n", "            ", "Y", "+=", "V", "#/20 # divide by 10 to scale the value of Y to be comparable to V", "\n", "", "else", ":", "\n", "            ", "Y", "+=", "(", "6", "+", "W0", ")", "\n", "#else:", "\n", "#    V = 6 + W0 + tterm + E1", "\n", "#    Y = 12 + W0*W0 + W0*W0 + yterm + E2  # E2_new", "\n", "", "", "dat", "=", "{", "\n", "treatment", ":", "V", ",", "\n", "outcome", ":", "Y", ",", "\n", "common_causes", "[", "0", "]", ":", "W0", ",", "\n", "time_var", ":", "S", "\n", "}", "\n", "if", "num_common_causes", ">", "1", ":", "\n", "        ", "for", "i", "in", "range", "(", "otherW", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "dat", "[", "common_causes", "[", "i", "+", "1", "]", "]", "=", "otherW", "[", ":", ",", "i", "]", "\n", "", "", "data", "=", "pd", ".", "DataFrame", "(", "data", "=", "dat", ")", "\n", "ret_dict", "=", "{", "\n", "\"df\"", ":", "data", ",", "\n", "\"treatment_name\"", ":", "treatment", ",", "\n", "\"outcome_name\"", ":", "outcome", ",", "\n", "\"common_causes_names\"", ":", "common_causes", ",", "\n", "\"time_val\"", ":", "time_var", ",", "\n", "\"instrument_names\"", ":", "None", ",", "\n", "\"dot_graph\"", ":", "None", ",", "\n", "\"gml_graph\"", ":", "None", ",", "\n", "\"ate\"", ":", "None", ",", "\n", "}", "\n", "return", "ret_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.create_discrete_column": [[409, 417], ["numpy.arange", "numpy.random.choice", "scipy.norm.cdf", "scipy.norm.cdf", "prob.sum"], "function", ["None"], ["", "def", "create_discrete_column", "(", "num_samples", ",", "std_dev", "=", "1", ")", ":", "\n", "#Generating a random normal distribution of integers", "\n", "    ", "x", "=", "np", ".", "arange", "(", "-", "5", ",", "6", ")", "\n", "xU", ",", "xL", "=", "x", "+", "0.5", ",", "x", "-", "0.5", "\n", "prob", "=", "ss", ".", "norm", ".", "cdf", "(", "xU", ",", "scale", "=", "std_dev", ")", "-", "ss", ".", "norm", ".", "cdf", "(", "xL", ",", "scale", "=", "std_dev", ")", "#probability of selecting a number x is p(x-0.5 < x < x+0.5) where x is a normal random variable with mean 0 and standard deviation std_dev", "\n", "prob", "=", "prob", "/", "prob", ".", "sum", "(", ")", "# normalize the probabilities so their sum is 1", "\n", "nums", "=", "choice", "(", "a", "=", "x", ",", "size", "=", "num_samples", ",", "p", "=", "prob", ")", "#pick up an element ", "\n", "return", "nums", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.convert_continuous_to_discrete": [[418, 420], ["arr.astype"], "function", ["None"], ["", "def", "convert_continuous_to_discrete", "(", "arr", ")", ":", "\n", "    ", "return", "arr", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.generate_random_graph": [[422, 439], ["dowhy.utils.graph_operations.get_simple_ordered_tree", "range", "dowhy.utils.graph_operations.get_random_node_pair", "dowhy.utils.graph_operations.get_simple_ordered_tree.has_edge", "dowhy.utils.graph_operations.del_edge", "dowhy.utils.graph_operations.add_edge"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.get_simple_ordered_tree", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.get_random_node_pair", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.del_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge"], ["", "def", "generate_random_graph", "(", "n", ",", "max_iter", "=", "10", ")", ":", "\n", "    ", "\"\"\"\n    Function to generate random Directed Acyclic Graph\n    :param n: number of nodes in the graph\n    :param max_iter: number of iterations to create graph\n\n    :returns: Directed Acyclic Graph\n    See: https://datascience.oneoffcoder.com/generate-random-bbn.html \n    \"\"\"", "\n", "g", "=", "get_simple_ordered_tree", "(", "n", ")", "\n", "for", "it", "in", "range", "(", "max_iter", ")", ":", "\n", "        ", "i", ",", "j", "=", "get_random_node_pair", "(", "n", ")", "\n", "if", "g", ".", "has_edge", "(", "i", ",", "j", ")", "is", "True", ":", "\n", "            ", "del_edge", "(", "i", ",", "j", ",", "g", ")", "\n", "", "else", ":", "\n", "            ", "add_edge", "(", "i", ",", "j", ",", "g", ")", "\n", "", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph": [[442, 547], ["numpy.random.seed", "datasets.generate_random_graph", "dict", "networkx.relabel_nodes", "list", "list.sort", "len", "dict", "numpy.random.rand", "pandas.DataFrame", "list", "list", "sum", "zip", "len", "list", "networkx.generate_gml", "list", "nx.relabel_nodes.in_degree", "list", "list.sort", "list.extend", "list", "nx.relabel_nodes.out_degree", "nx.relabel_nodes.in_degree", "list", "datasets.create_discrete_column", "discrete_cols.append", "nx.relabel_nodes.successors", "nx.relabel_nodes.predecessors", "all", "list", "list.sort", "list.extend", "df[].to_numpy", "numpy.random.uniform", "nx.relabel_nodes.successors", "list.append", "numpy.random.normal", "continuous_cols.append", "numpy.random.normal", "discrete_cols.append", "binary_cols.append", "nx.relabel_nodes.successors", "len", "numpy.random.normal", "datasets.convert_continuous_to_discrete", "discrete_cols.append", "numpy.vectorize", "continuous_cols.append", "numpy.random.normal", "discrete_cols.append", "binary_cols.append", "numpy.vectorize"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.generate_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.create_discrete_column", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.DirectedGraph.predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.convert_continuous_to_discrete"], ["", "def", "dataset_from_random_graph", "(", "num_vars", ",", "num_samples", "=", "1000", ",", "prob_edge", "=", "0.3", ",", "random_seed", "=", "100", ",", "prob_type_of_data", "=", "(", "0.333", ",", "0.333", ",", "0.334", ")", ")", ":", "\n", "    ", "\"\"\"\n    This function generates a dataset with discrete and continuous kinds of variables.\n    It creates a random graph and models the variables linearly according to the relations in the graph.\n\n    :param num_vars: Number of variables in the dataset\n    :param num_samples: Number of samples in the dataset\n    :param prob_edge : Probability of an edge between two random nodes in a graph\n    :param random_seed: Seed for generating random graph\n    :param prob_type_of_data : 3-element tuple containing the probability of data being discrete, binary and continuous respectively.\n    :returns ret_dict : dictionary with information like dataframe, outcome, treatment, graph string and continuous, discrete and binary columns\n    \"\"\"", "\n", "assert", "(", "sum", "(", "list", "(", "prob_type_of_data", ")", ")", "==", "1.0", ")", "\n", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "DAG", "=", "generate_random_graph", "(", "n", "=", "num_vars", ")", "\n", "mapping", "=", "dict", "(", "zip", "(", "DAG", ",", "string", ".", "ascii_lowercase", ")", ")", "\n", "DAG", "=", "nx", ".", "relabel_nodes", "(", "DAG", ",", "mapping", ")", "\n", "all_nodes", "=", "list", "(", "DAG", ".", "nodes", ")", "\n", "all_nodes", ".", "sort", "(", ")", "\n", "num_nodes", "=", "len", "(", "all_nodes", ")", "\n", "changed", "=", "dict", "(", ")", "\n", "discrete_cols", "=", "[", "]", "\n", "continuous_cols", "=", "[", "]", "\n", "binary_cols", "=", "[", "]", "\n", "random_numbers_array", "=", "np", ".", "random", ".", "rand", "(", "num_nodes", ")", "#Random numbers between 0 to 1 to decide if that particular node will be discrete or continuous", "\n", "\n", "for", "node", "in", "all_nodes", ":", "\n", "        ", "changed", "[", "node", "]", "=", "False", "\n", "", "df", "=", "pd", ".", "DataFrame", "(", ")", "\n", "currset", "=", "list", "(", ")", "\n", "counter", "=", "0", "\n", "\n", "#Generating data for nodes which have no incoming edges", "\n", "for", "node", "in", "all_nodes", ":", "\n", "        ", "if", "DAG", ".", "in_degree", "(", "node", ")", "==", "0", ":", "\n", "            ", "x", "=", "random_numbers_array", "[", "counter", "]", "\n", "counter", "+=", "1", "\n", "if", "x", "<=", "prob_type_of_data", "[", "0", "]", ":", "\n", "                ", "df", "[", "node", "]", "=", "create_discrete_column", "(", "num_samples", ")", "#Generating discrete data", "\n", "discrete_cols", ".", "append", "(", "node", ")", "\n", "", "elif", "x", "<=", "prob_type_of_data", "[", "0", "]", "+", "prob_type_of_data", "[", "1", "]", ":", "\n", "                ", "df", "[", "node", "]", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_samples", ")", "#Generating continuous data", "\n", "continuous_cols", ".", "append", "(", "node", ")", "\n", "", "else", ":", "\n", "                ", "nums", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_samples", ")", "\n", "df", "[", "node", "]", "=", "np", ".", "vectorize", "(", "convert_to_binary", ")", "(", "nums", ")", "#Generating binary data", "\n", "discrete_cols", ".", "append", "(", "node", ")", "\n", "binary_cols", ".", "append", "(", "node", ")", "\n", "", "successors", "=", "list", "(", "DAG", ".", "successors", "(", "node", ")", ")", "#Storing immediate successors for next level data generation", "\n", "successors", ".", "sort", "(", ")", "\n", "currset", ".", "extend", "(", "successors", ")", "\n", "changed", "[", "node", "]", "=", "True", "\n", "\n", "#\"currset\" variable currently has all the successors of the nodes which had no incoming edges", "\n", "", "", "while", "len", "(", "currset", ")", ">", "0", ":", "\n", "        ", "cs", "=", "list", "(", ")", "#Variable to store immediate children of nodes present in \"currset\"", "\n", "for", "node", "in", "currset", ":", "\n", "            ", "predecessors", "=", "list", "(", "DAG", ".", "predecessors", "(", "node", ")", ")", "#Getting all the parent nodes on which current \"node\" depends on", "\n", "if", "changed", "[", "node", "]", "==", "False", "and", "all", "(", "changed", "[", "x", "]", "==", "True", "for", "x", "in", "predecessors", ")", ":", "#Check if current \"node\" has not been processed yet and if all the parent nodes have been processed", "\n", "                ", "successors", "=", "list", "(", "DAG", ".", "successors", "(", "node", ")", ")", "\n", "successors", ".", "sort", "(", ")", "\n", "cs", ".", "extend", "(", "successors", ")", "#Storing immediate children for next level data generation", "\n", "X", "=", "df", "[", "predecessors", "]", ".", "to_numpy", "(", ")", "#Using parent nodes data ", "\n", "c", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "len", "(", "predecessors", ")", ")", "\n", "t", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_samples", ")", "+", "X", "@", "c", "#Using Linear Regression to generate data", "\n", "changed", "[", "node", "]", "=", "True", "\n", "x", "=", "random_numbers_array", "[", "counter", "]", "\n", "counter", "+=", "1", "\n", "if", "x", "<=", "prob_type_of_data", "[", "0", "]", ":", "\n", "                    ", "df", "[", "node", "]", "=", "convert_continuous_to_discrete", "(", "t", ")", "\n", "discrete_cols", ".", "append", "(", "node", ")", "\n", "", "elif", "x", "<=", "prob_type_of_data", "[", "0", "]", "+", "prob_type_of_data", "[", "1", "]", ":", "\n", "                    ", "df", "[", "node", "]", "=", "t", "\n", "continuous_cols", ".", "append", "(", "node", ")", "\n", "", "else", ":", "\n", "                    ", "nums", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_samples", ")", "\n", "df", "[", "node", "]", "=", "np", ".", "vectorize", "(", "convert_to_binary", ")", "(", "nums", ")", "\n", "discrete_cols", ".", "append", "(", "node", ")", "\n", "binary_cols", ".", "append", "(", "node", ")", "\n", "", "", "", "currset", "=", "cs", "\n", "\n", "", "outcome", "=", "None", "\n", "for", "node", "in", "all_nodes", ":", "\n", "        ", "if", "DAG", ".", "out_degree", "(", "node", ")", "==", "0", ":", "\n", "            ", "outcome", "=", "node", "#Node which has no successors is outcome", "\n", "break", "\n", "\n", "", "", "treatments", "=", "list", "(", ")", "\n", "for", "node", "in", "all_nodes", ":", "\n", "        ", "if", "DAG", ".", "in_degree", "(", "node", ")", ">", "0", ":", "\n", "            ", "children", "=", "list", "(", "DAG", ".", "successors", "(", "node", ")", ")", "\n", "if", "outcome", "in", "children", ":", "\n", "                ", "treatments", ".", "append", "(", "node", ")", "#Node which causes outcome is treatment", "\n", "\n", "", "", "", "gml_str", "=", "(", "\"\\n\"", ".", "join", "(", "nx", ".", "generate_gml", "(", "DAG", ")", ")", ")", "\n", "ret_dict", "=", "{", "\n", "\"df\"", ":", "df", ",", "\n", "\"outcome_name\"", ":", "outcome", ",", "\n", "\"treatment_name\"", ":", "treatments", ",", "\n", "\"gml_graph\"", ":", "gml_str", ",", "\n", "\"discrete_columns\"", ":", "discrete_cols", ",", "\n", "\"continuous_columns\"", ":", "continuous_cols", ",", "\n", "\"binary_columns\"", ":", "binary_cols", "\n", "}", "\n", "return", "ret_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator.__init__": [[16, 30], ["args_dict.update", "print", "dowhy.causal_estimators.regression_estimator.RegressionEstimator.__init__", "linear_regression_estimator.LinearRegressionEstimator.logger.info", "locals().items", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"For a list of args and kwargs, see documentation for\n        :class:`~dowhy.causal_estimator.CausalEstimator`.\n\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the", "\n", "# parameters to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "print", "(", "args_dict", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: Using Linear Regression Estimator\"", ")", "\n", "self", ".", "_linear_model", "=", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator.construct_symbolic_estimator": [[31, 39], ["estimand.get_backdoor_variables", "itertools.product"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "expr", "=", "\"b: \"", "+", "\",\"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", "+", "\"~\"", "\n", "var_list", "=", "estimand", ".", "treatment_variable", "+", "estimand", ".", "get_backdoor_variables", "(", ")", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "if", "self", ".", "_effect_modifier_names", ":", "\n", "            ", "interaction_terms", "=", "[", "\"{0}*{1}\"", ".", "format", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ")", "for", "x", "in", "itertools", ".", "product", "(", "estimand", ".", "treatment_variable", ",", "self", ".", "_effect_modifier_names", ")", "]", "\n", "expr", "+=", "\"+\"", "+", "\"+\"", ".", "join", "(", "interaction_terms", ")", "\n", "", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator.predict_fn": [[40, 42], ["model.predict"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "def", "predict_fn", "(", "self", ",", "model", ",", "features", ")", ":", "\n", "        ", "return", "model", ".", "predict", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator._build_model": [[43, 47], ["linear_regression_estimator.LinearRegressionEstimator._build_features", "statsmodels.OLS().fit", "statsmodels.OLS"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_estimator.RegressionEstimator._build_features", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "_build_model", "(", "self", ")", ":", "\n", "        ", "features", "=", "self", ".", "_build_features", "(", ")", "\n", "model", "=", "sm", ".", "OLS", "(", "self", ".", "_outcome", ",", "features", ")", ".", "fit", "(", ")", "\n", "return", "(", "features", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator._estimate_confidence_intervals": [[48, 65], ["linear_regression_estimator.LinearRegressionEstimator.model.conf_int", "linear_regression_estimator.LinearRegressionEstimator.to_numpy", "len"], "methods", ["None"], ["", "def", "_estimate_confidence_intervals", "(", "self", ",", "confidence_level", ",", "\n", "method", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "_effect_modifier_names", ":", "\n", "# The average treatment effect is a combination of different", "\n", "# regression coefficients. Complicated to compute the confidence", "\n", "# interval analytically. For example, if y=a + b1.t + b2.tx, then", "\n", "# the average treatment effect is b1+b2.mean(x).", "\n", "# Refer Gelman, Hill. ARM Book. Chapter 9", "\n", "# http://www.stat.columbia.edu/~gelman/arm/chap9.pdf", "\n", "# TODO: Looking for contributions", "\n", "            ", "raise", "NotImplementedError", "\n", "", "else", ":", "\n", "            ", "conf_ints", "=", "self", ".", "model", ".", "conf_int", "(", "alpha", "=", "1", "-", "confidence_level", ")", "\n", "# For a linear regression model, the causal effect of a variable is equal to the coefficient corresponding to the", "\n", "# variable. Hence, the model by default outputs the confidence interval corresponding to treatment=1 and control=0.", "\n", "# So for custom treatment and control values, we must multiply the confidence interval by the difference of the two.", "\n", "return", "(", "self", ".", "_treatment_value", "-", "self", ".", "_control_value", ")", "*", "conf_ints", ".", "to_numpy", "(", ")", "[", "1", ":", "(", "len", "(", "self", ".", "_treatment_name", ")", "+", "1", ")", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator._estimate_std_error": [[66, 76], ["std_error.to_numpy", "len"], "methods", ["None"], ["", "", "def", "_estimate_std_error", "(", "self", ",", "method", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "_effect_modifier_names", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "else", ":", "\n", "            ", "std_error", "=", "self", ".", "model", ".", "bse", "[", "1", ":", "(", "len", "(", "self", ".", "_treatment_name", ")", "+", "1", ")", "]", "\n", "\n", "# For a linear regression model, the causal effect of a variable is equal to the coefficient corresponding to the", "\n", "# variable. Hence, the model by default outputs the standard error corresponding to treatment=1 and control=0.", "\n", "# So for custom treatment and control values, we must multiply the standard error by the difference of the two.", "\n", "return", "(", "self", ".", "_treatment_value", "-", "self", ".", "_control_value", ")", "*", "std_error", ".", "to_numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.linear_regression_estimator.LinearRegressionEstimator._test_significance": [[77, 80], ["pvalue.to_numpy", "len"], "methods", ["None"], ["", "", "def", "_test_significance", "(", "self", ",", "estimate_value", ",", "method", "=", "None", ")", ":", "\n", "        ", "pvalue", "=", "self", ".", "model", ".", "pvalues", "[", "1", ":", "(", "len", "(", "self", ".", "_treatment_name", ")", "+", "1", ")", "]", "\n", "return", "{", "'p_value'", ":", "pvalue", ".", "to_numpy", "(", ")", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_estimator.PropensityScoreEstimator.__init__": [[18, 70], ["args_dict.update", "dowhy.causal_estimator.CausalEstimator.__init__", "propensity_score_estimator.PropensityScoreEstimator._data[].astype().unique", "any", "propensity_score_estimator.PropensityScoreEstimator.logger.debug", "propensity_score_estimator.PropensityScoreEstimator._target_estimand.get_backdoor_variables", "len", "Exception", "propensity_score_estimator.PropensityScoreEstimator.logger.error", "Exception", "pandas.get_dummies", "propensity_score_estimator.PropensityScoreEstimator.logger.error", "Exception", "locals().items", "str", "propensity_score_estimator.PropensityScoreEstimator._data[].astype", "propensity_score_estimator.PropensityScoreEstimator._target_estimand.get_backdoor_variables", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "propensity_score_model", "=", "None", ",", "\n", "recalculate_propensity_score", "=", "True", ",", "\n", "propensity_score_column", "=", "\"propensity_score\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param propensity_score_model: Model used to compute propensity score.\n            Can be any classification model that supports fit() and\n            predict_proba() methods. If None, LogisticRegression is used.\n        :param recalculate_propensity_score: Whether the propensity score\n            should be estimated. To use pre-computed propensity scores,\n            set this value to False. Default=True.\n        :param propensity_score_column: Column name that stores the\n            propensity score. Default='propensity_score'\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the", "\n", "# parameters to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "\n", "# Enable the user to pass params for a custom propensity model", "\n", "self", ".", "propensity_score_model", "=", "propensity_score_model", "\n", "self", ".", "recalculate_propensity_score", "=", "recalculate_propensity_score", "\n", "self", ".", "propensity_score_column", "=", "propensity_score_column", "\n", "\n", "# Check if the treatment is one-dimensional", "\n", "if", "len", "(", "self", ".", "_treatment_name", ")", ">", "1", ":", "\n", "            ", "error_msg", "=", "str", "(", "self", ".", "__class__", ")", "+", "\"cannot handle more than one treatment variable\"", "\n", "raise", "Exception", "(", "error_msg", ")", "\n", "# Checking if the treatment is binary", "\n", "", "treatment_values", "=", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ".", "astype", "(", "int", ")", ".", "unique", "(", ")", "\n", "if", "any", "(", "[", "v", "not", "in", "[", "0", ",", "1", "]", "for", "v", "in", "treatment_values", "]", ")", ":", "\n", "            ", "error_msg", "=", "\"Propensity score methods are applicable only for binary treatments\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "Exception", "(", "error_msg", ")", "\n", "\n", "", "self", ".", "logger", ".", "debug", "(", "\"Back-door variables used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ")", ")", "\n", "\n", "self", ".", "_observed_common_causes_names", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "\n", "\n", "if", "self", ".", "_observed_common_causes_names", ":", "\n", "            ", "self", ".", "_observed_common_causes", "=", "self", ".", "_data", "[", "self", ".", "_observed_common_causes_names", "]", "\n", "# Convert the categorical variables into dummy/indicator variables", "\n", "# Basically, this gives a one hot encoding for each category", "\n", "# The first category is taken to be the base line.", "\n", "self", ".", "_observed_common_causes", "=", "pd", ".", "get_dummies", "(", "self", ".", "_observed_common_causes", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_observed_common_causes", "=", "None", "\n", "error_msg", "=", "\"No common causes/confounders present. Propensity score based methods are not applicable\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "Exception", "(", "error_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_estimator.PropensityScoreEstimator.construct_symbolic_estimator": [[71, 78], ["None"], "methods", ["None"], ["", "", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "'''\n            A symbolic string that conveys what each estimator does.\n            For instance, linear regression is expressed as\n            y ~ bx + e\n        '''", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_estimator.PropensityScoreEstimator._estimate_effect": [[79, 85], ["None"], "methods", ["None"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "'''\n            A custom estimator based on the way the propensity score estimates are to be used.\n\n        '''", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.generalized_linear_model_estimator.GeneralizedLinearModelEstimator.__init__": [[15, 41], ["args_dict.update", "dowhy.causal_estimators.regression_estimator.RegressionEstimator.__init__", "generalized_linear_model_estimator.GeneralizedLinearModelEstimator.logger.info", "generalized_linear_model_estimator.GeneralizedLinearModelEstimator._data[].astype().unique", "all", "ValueError", "locals().items", "generalized_linear_model_estimator.GeneralizedLinearModelEstimator._data[].astype", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "glm_family", "=", "None", ",", "predict_score", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"For a list of args and kwargs, see documentation for\n        :class:`~dowhy.causal_estimator.CausalEstimator`.\n\n        :param glm_family: statsmodels family for the generalized linear model.\n            For example, use statsmodels.api.families.Binomial() for logistic\n            regression or statsmodels.api.families.Poisson() for count data.\n        :param predict_score: For models that have a binary output, whether\n            to output the model's score or the binary output based on the score.\n\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the", "\n", "# parameters needed to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: Using Generalized Linear Model Estimator\"", ")", "\n", "if", "glm_family", "is", "not", "None", ":", "\n", "            ", "self", ".", "family", "=", "glm_family", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Need to specify the family for the generalized linear model. Provide a 'glm_family' parameter in method_params, such as statsmodels.api.families.Binomial() for logistic regression.\"", ")", "\n", "", "self", ".", "predict_score", "=", "predict_score", "\n", "# Checking if Y is binary", "\n", "outcome_values", "=", "self", ".", "_data", "[", "self", ".", "_outcome_name", "]", ".", "astype", "(", "int", ")", ".", "unique", "(", ")", "\n", "self", ".", "outcome_is_binary", "=", "all", "(", "[", "v", "in", "[", "0", ",", "1", "]", "for", "v", "in", "outcome_values", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.generalized_linear_model_estimator.GeneralizedLinearModelEstimator._build_model": [[42, 46], ["generalized_linear_model_estimator.GeneralizedLinearModelEstimator._build_features", "statsmodels.GLM().fit", "statsmodels.GLM"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_estimator.RegressionEstimator._build_features", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "_build_model", "(", "self", ")", ":", "\n", "        ", "features", "=", "self", ".", "_build_features", "(", ")", "\n", "model", "=", "sm", ".", "GLM", "(", "self", ".", "_outcome", ",", "features", ",", "family", "=", "self", ".", "family", ")", ".", "fit", "(", ")", "\n", "return", "(", "features", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.generalized_linear_model_estimator.GeneralizedLinearModelEstimator.predict_fn": [[47, 55], ["model.predict", "model.predict", "model.predict"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "def", "predict_fn", "(", "self", ",", "model", ",", "features", ")", ":", "\n", "        ", "if", "self", ".", "outcome_is_binary", ":", "\n", "            ", "if", "self", ".", "predict_score", ":", "\n", "                ", "return", "model", ".", "predict", "(", "features", ")", "\n", "", "else", ":", "\n", "                ", "return", "(", "model", ".", "predict", "(", "features", ")", ">", "0.5", ")", ".", "astype", "(", "int", ")", "\n", "", "", "else", ":", "\n", "            ", "return", "model", ".", "predict", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.generalized_linear_model_estimator.GeneralizedLinearModelEstimator.construct_symbolic_estimator": [[56, 65], ["estimand.get_backdoor_variables", "itertools.product"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "expr", "=", "\"b: \"", "+", "\",\"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", "+", "\"~\"", "+", "\"Sigmoid(\"", "\n", "var_list", "=", "estimand", ".", "treatment_variable", "+", "estimand", ".", "get_backdoor_variables", "(", ")", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "if", "self", ".", "_effect_modifier_names", ":", "\n", "            ", "interaction_terms", "=", "[", "\"{0}*{1}\"", ".", "format", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ")", "for", "x", "in", "itertools", ".", "product", "(", "estimand", ".", "treatment_variable", ",", "self", ".", "_effect_modifier_names", ")", "]", "\n", "expr", "+=", "\"+\"", "+", "\"+\"", ".", "join", "(", "interaction_terms", ")", "\n", "", "expr", "+=", "\")\"", "\n", "return", "expr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_estimator.RegressionEstimator.__init__": [[19, 37], ["dowhy.causal_estimator.CausalEstimator.__init__", "regression_estimator.RegressionEstimator.logger.debug", "regression_estimator.RegressionEstimator._target_estimand.get_backdoor_variables", "regression_estimator.RegressionEstimator.construct_symbolic_estimator", "regression_estimator.RegressionEstimator.logger.info", "len", "pandas.get_dummies", "regression_estimator.RegressionEstimator._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"For a list of standard args and kwargs, see documentation for\n        :class:`~dowhy.causal_estimator.CausalEstimator`.\n\n        \"\"\"", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"Back-door variables used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ")", ")", "\n", "self", ".", "_observed_common_causes_names", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "\n", "if", "len", "(", "self", ".", "_observed_common_causes_names", ")", ">", "0", ":", "\n", "            ", "self", ".", "_observed_common_causes", "=", "self", ".", "_data", "[", "self", ".", "_observed_common_causes_names", "]", "\n", "self", ".", "_observed_common_causes", "=", "pd", ".", "get_dummies", "(", "self", ".", "_observed_common_causes", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_observed_common_causes", "=", "None", "\n", "", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "self", ".", "model", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_estimator.RegressionEstimator._estimate_effect": [[38, 68], ["dowhy.causal_estimator.CausalEstimate", "regression_estimator.RegressionEstimator._build_model", "regression_estimator.RegressionEstimator.logger.debug", "regression_estimator.RegressionEstimator.logger.debug", "regression_estimator.RegressionEstimator._do", "regression_estimator.RegressionEstimator._do", "regression_estimator.RegressionEstimator._estimate_conditional_effects", "regression_estimator.RegressionEstimator.model.summary", "map"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.generalized_linear_model_estimator.GeneralizedLinearModelEstimator._build_model", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._do", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._do", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator._estimate_conditional_effects", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.summary"], ["", "def", "_estimate_effect", "(", "self", ",", "data_df", "=", "None", ",", "need_conditional_estimates", "=", "None", ")", ":", "\n", "# TODO make treatment_value and control value also as local parameters", "\n", "        ", "if", "data_df", "is", "None", ":", "\n", "            ", "data_df", "=", "self", ".", "_data", "\n", "", "if", "need_conditional_estimates", "is", "None", ":", "\n", "            ", "need_conditional_estimates", "=", "self", ".", "need_conditional_estimates", "\n", "# Checking if the model is already trained", "\n", "", "if", "not", "self", ".", "model", ":", "\n", "# The model is always built on the entire data", "\n", "            ", "_", ",", "self", ".", "model", "=", "self", ".", "_build_model", "(", ")", "\n", "coefficients", "=", "self", ".", "model", ".", "params", "[", "1", ":", "]", "# first coefficient is the intercept", "\n", "self", ".", "logger", ".", "debug", "(", "\"Coefficients of the fitted model: \"", "+", "\n", "\",\"", ".", "join", "(", "map", "(", "str", ",", "coefficients", ")", ")", ")", "\n", "self", ".", "logger", ".", "debug", "(", "self", ".", "model", ".", "summary", "(", ")", ")", "\n", "# All treatments are set to the same constant value", "\n", "", "effect_estimate", "=", "self", ".", "_do", "(", "self", ".", "_treatment_value", ",", "data_df", ")", "-", "self", ".", "_do", "(", "self", ".", "_control_value", ",", "data_df", ")", "\n", "conditional_effect_estimates", "=", "None", "\n", "if", "need_conditional_estimates", ":", "\n", "            ", "conditional_effect_estimates", "=", "self", ".", "_estimate_conditional_effects", "(", "\n", "self", ".", "_estimate_effect_fn", ",", "\n", "effect_modifier_names", "=", "self", ".", "_effect_modifier_names", ")", "\n", "", "intercept_parameter", "=", "self", ".", "model", ".", "params", "[", "0", "]", "\n", "estimate", "=", "CausalEstimate", "(", "estimate", "=", "effect_estimate", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "conditional_estimates", "=", "conditional_effect_estimates", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ",", "\n", "intercept", "=", "intercept_parameter", ")", "\n", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_estimator.RegressionEstimator._estimate_effect_fn": [[69, 72], ["regression_estimator.RegressionEstimator._estimate_effect"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._estimate_effect"], ["", "def", "_estimate_effect_fn", "(", "self", ",", "data_df", ")", ":", "\n", "        ", "est", "=", "self", ".", "_estimate_effect", "(", "data_df", ",", "need_conditional_estimates", "=", "False", ")", "\n", "return", "est", ".", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_estimator.RegressionEstimator._build_features": [[74, 114], ["treatment_vals.to_numpy.to_numpy.reshape", "numpy.concatenate.astype", "statsmodels.add_constant", "pandas.get_dummies", "pandas.get_dummies", "type", "treatment_vals.to_numpy.to_numpy.to_numpy", "ValueError", "len", "numpy.concatenate", "range", "len", "pandas.get_dummies", "pandas.get_dummies", "len", "numpy.concatenate", "pandas.get_dummies.to_numpy"], "methods", ["None"], ["", "def", "_build_features", "(", "self", ",", "treatment_values", "=", "None", ",", "data_df", "=", "None", ")", ":", "\n", "# Using all data by default", "\n", "        ", "if", "data_df", "is", "None", ":", "\n", "            ", "data_df", "=", "self", ".", "_data", "\n", "treatment_vals", "=", "pd", ".", "get_dummies", "(", "self", ".", "_treatment", ",", "drop_first", "=", "True", ")", "\n", "observed_common_causes_vals", "=", "self", ".", "_observed_common_causes", "\n", "effect_modifiers_vals", "=", "self", ".", "_effect_modifiers", "\n", "", "else", ":", "\n", "            ", "treatment_vals", "=", "pd", ".", "get_dummies", "(", "data_df", "[", "self", ".", "_treatment_name", "]", ",", "drop_first", "=", "True", ")", "\n", "if", "len", "(", "self", ".", "_observed_common_causes_names", ")", ">", "0", ":", "\n", "                ", "observed_common_causes_vals", "=", "data_df", "[", "self", ".", "_observed_common_causes_names", "]", "\n", "observed_common_causes_vals", "=", "pd", ".", "get_dummies", "(", "observed_common_causes_vals", ",", "drop_first", "=", "True", ")", "\n", "", "if", "self", ".", "_effect_modifier_names", ":", "\n", "                ", "effect_modifiers_vals", "=", "data_df", "[", "self", ".", "_effect_modifier_names", "]", "\n", "effect_modifiers_vals", "=", "pd", ".", "get_dummies", "(", "effect_modifiers_vals", ",", "drop_first", "=", "True", ")", "\n", "# Fixing treatment value to the specified value, if provided", "\n", "", "", "if", "treatment_values", "is", "not", "None", ":", "\n", "            ", "treatment_vals", "=", "treatment_values", "\n", "", "if", "type", "(", "treatment_vals", ")", "is", "not", "np", ".", "ndarray", ":", "\n", "            ", "treatment_vals", "=", "treatment_vals", ".", "to_numpy", "(", ")", "\n", "# treatment_vals and data_df should have same number of rows", "\n", "", "if", "treatment_vals", ".", "shape", "[", "0", "]", "!=", "data_df", ".", "shape", "[", "0", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Provided treatment values and dataframe should have the same length.\"", ")", "\n", "# Bulding the feature matrix", "\n", "", "n_treatment_cols", "=", "1", "if", "len", "(", "treatment_vals", ".", "shape", ")", "==", "1", "else", "treatment_vals", ".", "shape", "[", "1", "]", "\n", "n_samples", "=", "treatment_vals", ".", "shape", "[", "0", "]", "\n", "treatment_2d", "=", "treatment_vals", ".", "reshape", "(", "(", "n_samples", ",", "n_treatment_cols", ")", ")", "\n", "if", "len", "(", "self", ".", "_observed_common_causes_names", ")", ">", "0", ":", "\n", "            ", "features", "=", "np", ".", "concatenate", "(", "(", "treatment_2d", ",", "observed_common_causes_vals", ")", ",", "\n", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "treatment_2d", "\n", "", "if", "self", ".", "_effect_modifier_names", ":", "\n", "            ", "for", "i", "in", "range", "(", "treatment_2d", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "curr_treatment", "=", "treatment_2d", "[", ":", ",", "i", "]", "\n", "new_features", "=", "curr_treatment", "[", ":", ",", "np", ".", "newaxis", "]", "*", "effect_modifiers_vals", ".", "to_numpy", "(", ")", "\n", "features", "=", "np", ".", "concatenate", "(", "(", "features", ",", "new_features", ")", ",", "axis", "=", "1", ")", "\n", "", "", "features", "=", "features", ".", "astype", "(", "float", ",", "copy", "=", "False", ")", "# converting to float in case of binary treatment and no other variables", "\n", "features", "=", "sm", ".", "add_constant", "(", "features", ",", "has_constant", "=", "'add'", ")", "# to add an intercept term", "\n", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_estimator.RegressionEstimator._do": [[115, 135], ["numpy.full", "pandas.concat().astype", "pandas.get_dummies", "regression_estimator.RegressionEstimator._build_features", "regression_estimator.RegressionEstimator.predict_fn", "regression_estimator.RegressionEstimator.mean", "regression_estimator.RegressionEstimator._build_model", "len", "pandas.concat", "regression_estimator.RegressionEstimator._treatment.copy", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_estimator.RegressionEstimator._build_features", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.generalized_linear_model_estimator.GeneralizedLinearModelEstimator.predict_fn", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.generalized_linear_model_estimator.GeneralizedLinearModelEstimator._build_model"], ["", "def", "_do", "(", "self", ",", "treatment_val", ",", "data_df", "=", "None", ")", ":", "\n", "        ", "if", "data_df", "is", "None", ":", "\n", "            ", "data_df", "=", "self", ".", "_data", "\n", "", "if", "not", "self", ".", "model", ":", "\n", "# The model is always built on the entire data", "\n", "            ", "_", ",", "self", ".", "model", "=", "self", ".", "_build_model", "(", ")", "\n", "# Replacing treatment values by given x", "\n", "# First, create interventional tensor in original space", "\n", "", "interventional_treatment_values", "=", "np", ".", "full", "(", "(", "data_df", ".", "shape", "[", "0", "]", ",", "len", "(", "self", ".", "_treatment_name", ")", ")", ",", "treatment_val", ")", "\n", "# Then, use pandas to ensure that the dummies are assigned correctly for a categorical treatment", "\n", "interventional_treatment_2d", "=", "pd", ".", "concat", "(", "[", "\n", "self", ".", "_treatment", ".", "copy", "(", ")", ",", "pd", ".", "DataFrame", "(", "data", "=", "interventional_treatment_values", ",", "columns", "=", "self", ".", "_treatment", ".", "columns", ")", "\n", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "self", ".", "_treatment", ".", "dtypes", ",", "copy", "=", "False", ")", "\n", "interventional_treatment_2d", "=", "pd", ".", "get_dummies", "(", "interventional_treatment_2d", ",", "drop_first", "=", "True", ")", "\n", "interventional_treatment_2d", "=", "interventional_treatment_2d", "[", "self", ".", "_treatment", ".", "shape", "[", "0", "]", ":", "]", "\n", "\n", "new_features", "=", "self", ".", "_build_features", "(", "treatment_values", "=", "interventional_treatment_2d", ",", "\n", "data_df", "=", "data_df", ")", "\n", "interventional_outcomes", "=", "self", ".", "predict_fn", "(", "self", ".", "model", ",", "new_features", ")", "\n", "return", "interventional_outcomes", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_weighting_estimator.PropensityScoreWeightingEstimator.__init__": [[21, 73], ["args_dict.update", "dowhy.causal_estimators.propensity_score_estimator.PropensityScoreEstimator.__init__", "propensity_score_weighting_estimator.PropensityScoreWeightingEstimator.logger.info", "propensity_score_weighting_estimator.PropensityScoreWeightingEstimator.construct_symbolic_estimator", "propensity_score_weighting_estimator.PropensityScoreWeightingEstimator.logger.info"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator"], ["def", "__init__", "(", "\n", "self", ",", "\n", "*", "args", ",", "\n", "min_ps_score", "=", "0.05", ",", "\n", "max_ps_score", "=", "0.95", ",", "\n", "weighting_scheme", "=", "'ips_weight'", ",", "\n", "propensity_score_model", "=", "None", ",", "\n", "recalculate_propensity_score", "=", "True", ",", "\n", "propensity_score_column", "=", "\"propensity_score\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param min_ps_score: Lower bound used to clip the propensity score.\n            Default=0.05\n        :param max_ps_score: Upper bound used to clip the propensity score.\n            Default=0.95\n        :param weighting_scheme: Weighting method to use. Can be inverse\n            propensity score (\"ips_weight\", default), stabilized IPS score\n            (\"ips_stabilized_weight\"), or normalized IPS score\n            (\"ips_normalized_weight\").\n        :param propensity_score_model: The model used to compute propensity\n            score. Can be any classification model that supports fit() and\n            predict_proba() methods. If None, use LogisticRegression model as\n            the default. Default=None\n        :param recalculate_propensity_score: If true, force the estimator to\n            estimate the propensity score. To use pre-computed propensity\n            scores, set this value to false. Default=True\n        :param propensity_score_column: Column name that stores the\n            propensity score. Default='propensity_score'\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the information", "\n", "# to create an object of this class", "\n", "args_dict", "=", "kwargs", "\n", "args_dict", ".", "update", "(", "{", "\n", "'min_ps_score'", ":", "min_ps_score", ",", "\n", "'max_ps_score'", ":", "max_ps_score", ",", "\n", "'weighting_scheme'", ":", "weighting_scheme", "\n", "}", ")", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "*", "args", ",", "\n", "propensity_score_model", "=", "propensity_score_model", ",", "\n", "recalculate_propensity_score", "=", "recalculate_propensity_score", ",", "\n", "propensity_score_column", "=", "propensity_score_column", ",", "\n", "**", "args_dict", ")", "\n", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: Using Propensity Score Weighting Estimator\"", ")", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "\n", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "# Setting method specific parameters", "\n", "self", ".", "weighting_scheme", "=", "weighting_scheme", "\n", "self", ".", "min_ps_score", "=", "min_ps_score", "\n", "self", ".", "max_ps_score", "=", "max_ps_score", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_weighting_estimator.PropensityScoreWeightingEstimator._estimate_effect": [[74, 183], ["numpy.minimum", "numpy.maximum", "sum", "sum", "len", "sum", "sum", "sum", "sum", "sum", "numpy.sum", "numpy.sum", "dowhy.causal_estimator.CausalEstimate", "propensity_score_weighting_estimator.PropensityScoreWeightingEstimator.propensity_score_model.fit", "sum", "sklearn.linear_model.LogisticRegression", "propensity_score_weighting_estimator.PropensityScoreWeightingEstimator.propensity_score_model.predict_proba", "ValueError", "propensity_score_weighting_estimator.PropensityScoreWeightingEstimator.logger.info", "propensity_score_weighting_estimator.PropensityScoreWeightingEstimator._data[].sum", "propensity_score_weighting_estimator.PropensityScoreWeightingEstimator._data[].sum", "ValueError"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "recalculate_propensity_score", "is", "True", ":", "\n", "            ", "if", "self", ".", "propensity_score_model", "is", "None", ":", "\n", "                ", "self", ".", "propensity_score_model", "=", "linear_model", ".", "LogisticRegression", "(", ")", "\n", "", "self", ".", "propensity_score_model", ".", "fit", "(", "self", ".", "_observed_common_causes", ",", "self", ".", "_treatment", ")", "\n", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "=", "self", ".", "propensity_score_model", ".", "predict_proba", "(", "self", ".", "_observed_common_causes", ")", "[", ":", ",", "1", "]", "\n", "", "else", ":", "\n", "# check if user provides the propensity score column", "\n", "            ", "if", "self", ".", "propensity_score_column", "not", "in", "self", ".", "_data", ".", "columns", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Propensity score column {self.propensity_score_column} does not exist. Please specify the column name that has your pre-computed propensity score.\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "logger", ".", "info", "(", "f\"INFO: Using pre-computed propensity score in column {self.propensity_score_column}\"", ")", "\n", "\n", "# trim propensity score weights", "\n", "", "", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "=", "np", ".", "minimum", "(", "self", ".", "max_ps_score", ",", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "=", "np", ".", "maximum", "(", "self", ".", "min_ps_score", ",", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", "\n", "# ips ==> (isTreated(y)/ps(y)) + ((1-isTreated(y))/(1-ps(y)))", "\n", "# nips ==> ips / (sum of ips over all units)", "\n", "# icps ==> ps(y)/(1-ps(y)) / (sum of (ps(y)/(1-ps(y))) over all control units)", "\n", "# itps ==> ps(y)/(1-ps(y)) / (sum of (ps(y)/(1-ps(y))) over all treatment units)", "\n", "ipst_sum", "=", "sum", "(", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "/", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", "ipsc_sum", "=", "sum", "(", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "/", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", ")", "\n", "num_units", "=", "len", "(", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "\n", "num_treatment_units", "=", "sum", "(", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "\n", "num_control_units", "=", "num_units", "-", "num_treatment_units", "\n", "\n", "# Vanilla IPS estimator", "\n", "self", ".", "_data", "[", "'ips_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "/", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "+", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "/", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", ")", "\n", "self", ".", "_data", "[", "'tips_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "+", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "*", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "/", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", ")", "\n", "self", ".", "_data", "[", "'cips_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "*", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "/", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "+", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "\n", ")", "\n", "\n", "# The Hajek estimator (or the self-normalized estimator)", "\n", "self", ".", "_data", "[", "'ips_normalized_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "/", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "/", "ipst_sum", "+", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "/", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "/", "ipsc_sum", "\n", ")", "\n", "ipst_for_att_sum", "=", "sum", "(", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "\n", "ipsc_for_att_sum", "=", "sum", "(", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "/", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "*", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", "self", ".", "_data", "[", "'tips_normalized_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "/", "ipst_for_att_sum", "+", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "*", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "/", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "/", "ipsc_for_att_sum", "\n", ")", "\n", "ipst_for_atc_sum", "=", "sum", "(", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "/", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "*", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", ")", "\n", "ipsc_for_atc_sum", "=", "sum", "(", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", ")", "\n", "self", ".", "_data", "[", "'cips_normalized_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "*", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "/", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "/", "ipst_for_atc_sum", "+", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "/", "ipsc_for_atc_sum", "\n", ")", "\n", "\n", "# Stabilized weights (from Robins, Hernan, Brumback (2000))", "\n", "# Paper: Marginal Structural Models and Causal Inference in Epidemiology", "\n", "p_treatment", "=", "sum", "(", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "/", "num_units", "\n", "self", ".", "_data", "[", "'ips_stabilized_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "/", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "*", "p_treatment", "+", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "/", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "*", "(", "1", "-", "p_treatment", ")", "\n", ")", "\n", "self", ".", "_data", "[", "'tips_stabilized_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "*", "p_treatment", "+", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "*", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "/", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "*", "(", "1", "-", "p_treatment", ")", "\n", ")", "\n", "self", ".", "_data", "[", "'cips_stabilized_weight'", "]", "=", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "*", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "/", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "*", "p_treatment", "+", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "*", "(", "1", "-", "p_treatment", ")", "\n", ")", "\n", "\n", "if", "self", ".", "_target_units", "==", "\"ate\"", ":", "\n", "            ", "weighting_scheme_name", "=", "self", ".", "weighting_scheme", "\n", "", "elif", "self", ".", "_target_units", "==", "\"att\"", ":", "\n", "            ", "weighting_scheme_name", "=", "\"t\"", "+", "self", ".", "weighting_scheme", "\n", "", "elif", "self", ".", "_target_units", "==", "\"atc\"", ":", "\n", "            ", "weighting_scheme_name", "=", "\"c\"", "+", "self", ".", "weighting_scheme", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Target units string value not supported\"", ")", "\n", "\n", "# Calculating the effect", "\n", "", "self", ".", "_data", "[", "'d_y'", "]", "=", "(", "\n", "self", ".", "_data", "[", "weighting_scheme_name", "]", "*", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "*", "\n", "self", ".", "_data", "[", "self", ".", "_outcome_name", "]", "\n", ")", "\n", "self", ".", "_data", "[", "'dbar_y'", "]", "=", "(", "\n", "self", ".", "_data", "[", "weighting_scheme_name", "]", "*", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "*", "\n", "self", ".", "_data", "[", "self", ".", "_outcome_name", "]", "\n", ")", "\n", "sum_dy_weights", "=", "np", ".", "sum", "(", "\n", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "*", "self", ".", "_data", "[", "weighting_scheme_name", "]", ")", "\n", "sum_dbary_weights", "=", "np", ".", "sum", "(", "\n", "(", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "*", "self", ".", "_data", "[", "weighting_scheme_name", "]", ")", "\n", "# Subtracting the weighted means", "\n", "est", "=", "self", ".", "_data", "[", "'d_y'", "]", ".", "sum", "(", ")", "/", "sum_dy_weights", "-", "self", ".", "_data", "[", "'dbar_y'", "]", ".", "sum", "(", ")", "/", "sum_dbary_weights", "\n", "\n", "# TODO - how can we add additional information into the returned estimate?", "\n", "estimate", "=", "CausalEstimate", "(", "estimate", "=", "est", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ",", "\n", "propensity_scores", "=", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_weighting_estimator.PropensityScoreWeightingEstimator.construct_symbolic_estimator": [[184, 190], ["estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "expr", "=", "\"b: \"", "+", "\",\"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", "+", "\"~\"", "\n", "# TODO -- fix: we are actually conditioning on positive treatment (d=1)", "\n", "var_list", "=", "estimand", ".", "treatment_variable", "+", "estimand", ".", "get_backdoor_variables", "(", ")", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "return", "expr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.__init__": [[23, 77], ["args_dict.update", "dowhy.causal_estimator.CausalEstimator.__init__", "econml.Econml.logger.info", "econml.Econml._target_estimand.get_backdoor_variables().copy", "econml.Econml._econml_methodname.rpartition", "module_name.endswith", "econml.Econml.logger.debug", "econml.Econml.construct_symbolic_estimator", "econml.Econml.logger.info", "econml.Econml.logger.debug", "pandas.get_dummies", "getattr", "dowhy.utils.api.parse_state", "pandas.get_dummies", "locals().items", "econml.Econml._target_estimand.get_backdoor_variables", "econml.Econml._effect_modifier_names.copy", "len", "econml.Econml.logger.warn", "econml.Econml.extend", "pandas.get_dummies", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "econml_methodname", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param econml_methodname: Fully qualified name of econml estimator\n            class. For example, 'econml.dml.DML'\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the", "\n", "# parameters to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "self", ".", "_econml_methodname", "=", "econml_methodname", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: Using EconML Estimator\"", ")", "\n", "self", ".", "identifier_method", "=", "self", ".", "_target_estimand", ".", "identifier_method", "\n", "self", ".", "_observed_common_causes_names", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ".", "copy", "(", ")", "\n", "# For metalearners only--issue a warning if w contains variables not in x", "\n", "(", "module_name", ",", "_", ",", "class_name", ")", "=", "self", ".", "_econml_methodname", ".", "rpartition", "(", "\".\"", ")", "\n", "if", "module_name", ".", "endswith", "(", "\"metalearners\"", ")", ":", "\n", "            ", "effect_modifier_names", "=", "[", "]", "\n", "if", "self", ".", "_effect_modifier_names", "is", "not", "None", ":", "\n", "                ", "effect_modifier_names", "=", "self", ".", "_effect_modifier_names", ".", "copy", "(", ")", "\n", "", "w_diff_x", "=", "[", "w", "for", "w", "in", "self", ".", "_observed_common_causes_names", "if", "w", "not", "in", "effect_modifier_names", "]", "\n", "if", "len", "(", "w_diff_x", ")", ">", "0", ":", "\n", "                ", "self", ".", "logger", ".", "warn", "(", "\"Concatenating common_causes and effect_modifiers and providing a single list of variables to metalearner estimator method, \"", "+", "class_name", "+", "\". EconML metalearners accept a single X argument.\"", ")", "\n", "effect_modifier_names", ".", "extend", "(", "w_diff_x", ")", "\n", "# Override the effect_modifiers set in CausalEstimator.__init__()", "\n", "# Also only update self._effect_modifiers, and create a copy of self._effect_modifier_names", "\n", "# the latter can be used by other estimator methods later", "\n", "self", ".", "_effect_modifiers", "=", "self", ".", "_data", "[", "effect_modifier_names", "]", "\n", "self", ".", "_effect_modifiers", "=", "pd", ".", "get_dummies", "(", "self", ".", "_effect_modifiers", ",", "drop_first", "=", "True", ")", "\n", "self", ".", "_effect_modifier_names", "=", "effect_modifier_names", "\n", "", "self", ".", "logger", ".", "debug", "(", "\"Effect modifiers: \"", "+", "\n", "\",\"", ".", "join", "(", "effect_modifier_names", ")", ")", "\n", "", "if", "self", ".", "_observed_common_causes_names", ":", "\n", "            ", "self", ".", "_observed_common_causes", "=", "self", ".", "_data", "[", "self", ".", "_observed_common_causes_names", "]", "\n", "self", ".", "_observed_common_causes", "=", "pd", ".", "get_dummies", "(", "self", ".", "_observed_common_causes", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_observed_common_causes", "=", "None", "\n", "", "self", ".", "logger", ".", "debug", "(", "\"Back-door variables used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_observed_common_causes_names", ")", ")", "\n", "# Instrumental variables names, if present", "\n", "# choosing the instrumental variable to use", "\n", "if", "getattr", "(", "self", ",", "'iv_instrument_name'", ",", "None", ")", "is", "None", ":", "\n", "            ", "self", ".", "estimating_instrument_names", "=", "self", ".", "_target_estimand", ".", "instrumental_variables", "\n", "", "else", ":", "\n", "            ", "self", ".", "estimating_instrument_names", "=", "parse_state", "(", "self", ".", "iv_instrument_name", ")", "\n", "", "if", "self", ".", "estimating_instrument_names", ":", "\n", "            ", "self", ".", "_estimating_instruments", "=", "self", ".", "_data", "[", "self", ".", "estimating_instrument_names", "]", "\n", "self", ".", "_estimating_instruments", "=", "pd", ".", "get_dummies", "(", "self", ".", "_estimating_instruments", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_estimating_instruments", "=", "None", "\n", "", "self", ".", "estimator", "=", "None", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._get_econml_class_object": [[78, 88], ["module_method_name.rpartition", "importlib.import_module", "getattr", "ImportError"], "methods", ["None"], ["", "def", "_get_econml_class_object", "(", "self", ",", "module_method_name", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# from https://www.bnmetrics.com/blog/factory-pattern-in-python3-simple-version", "\n", "        ", "try", ":", "\n", "            ", "(", "module_name", ",", "_", ",", "class_name", ")", "=", "module_method_name", ".", "rpartition", "(", "\".\"", ")", "\n", "estimator_module", "=", "import_module", "(", "module_name", ")", "\n", "estimator_class", "=", "getattr", "(", "estimator_module", ",", "class_name", ")", "\n", "\n", "", "except", "(", "AttributeError", ",", "AssertionError", ",", "ImportError", ")", ":", "\n", "            ", "raise", "ImportError", "(", "'Error loading {}.{}. Double-check the method name and ensure that all econml dependencies are installed.'", ".", "format", "(", "module_name", ",", "class_name", ")", ")", "\n", "", "return", "estimator_class", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._estimate_effect": [[89, 154], ["numpy.repeat", "numpy.repeat", "econml.Econml.estimator.effect", "numpy.mean", "dowhy.causal_estimator.CausalEstimate", "econml.Econml._get_econml_class_object", "econml.Econml.", "inspect.getfullargspec", "type", "type", "econml.Econml.estimator.effect_interval", "inspect.unwrap", "econml.Econml.estimator.fit", "type", "callable", "named_data_args.keys", "econml.Econml._data.where", "numpy.array", "econml.Econml.notnull"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._get_econml_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "self", ".", "_treatment", ".", "shape", "[", "0", "]", "\n", "X", "=", "None", "# Effect modifiers", "\n", "W", "=", "None", "# common causes/ confounders", "\n", "Z", "=", "None", "# Instruments", "\n", "Y", "=", "self", ".", "_outcome", "\n", "T", "=", "self", ".", "_treatment", "\n", "if", "self", ".", "_effect_modifiers", "is", "not", "None", ":", "\n", "            ", "X", "=", "self", ".", "_effect_modifiers", "\n", "", "if", "self", ".", "_observed_common_causes_names", ":", "\n", "            ", "W", "=", "self", ".", "_observed_common_causes", "\n", "", "if", "self", ".", "estimating_instrument_names", ":", "\n", "            ", "Z", "=", "self", ".", "_estimating_instruments", "\n", "", "named_data_args", "=", "{", "'Y'", ":", "Y", ",", "'T'", ":", "T", ",", "'X'", ":", "X", ",", "'W'", ":", "W", ",", "'Z'", ":", "Z", "}", "\n", "\n", "if", "self", ".", "estimator", "is", "None", ":", "\n", "            ", "estimator_class", "=", "self", ".", "_get_econml_class_object", "(", "self", ".", "_econml_methodname", ")", "\n", "self", ".", "estimator", "=", "estimator_class", "(", "**", "self", ".", "method_params", "[", "\"init_params\"", "]", ")", "\n", "# Calling the econml estimator's fit method", "\n", "estimator_argspec", "=", "inspect", ".", "getfullargspec", "(", "\n", "inspect", ".", "unwrap", "(", "self", ".", "estimator", ".", "fit", ")", ")", "\n", "# As of v0.9, econml has some kewyord only arguments", "\n", "estimator_named_args", "=", "estimator_argspec", ".", "args", "+", "estimator_argspec", ".", "kwonlyargs", "\n", "estimator_data_args", "=", "{", "\n", "arg", ":", "named_data_args", "[", "arg", "]", "for", "arg", "in", "named_data_args", ".", "keys", "(", ")", "if", "arg", "in", "estimator_named_args", "\n", "}", "\n", "if", "self", ".", "method_params", "[", "\"fit_params\"", "]", "is", "not", "False", ":", "\n", "                ", "self", ".", "estimator", ".", "fit", "(", "**", "estimator_data_args", ",", "\n", "**", "self", ".", "method_params", "[", "\"fit_params\"", "]", ")", "\n", "\n", "", "", "X_test", "=", "X", "\n", "n_target_units", "=", "n_samples", "\n", "if", "X", "is", "not", "None", ":", "\n", "            ", "if", "type", "(", "self", ".", "_target_units", ")", "is", "pd", ".", "DataFrame", ":", "\n", "                ", "X_test", "=", "self", ".", "_target_units", "\n", "", "elif", "callable", "(", "self", ".", "_target_units", ")", ":", "\n", "                ", "filtered_rows", "=", "self", ".", "_data", ".", "where", "(", "self", ".", "_target_units", ")", "\n", "boolean_criterion", "=", "np", ".", "array", "(", "filtered_rows", ".", "notnull", "(", ")", ".", "iloc", "[", ":", ",", "0", "]", ")", "\n", "X_test", "=", "X", "[", "boolean_criterion", "]", "\n", "", "n_target_units", "=", "X_test", ".", "shape", "[", "0", "]", "\n", "\n", "# Changing shape to a list for a singleton value", "\n", "", "if", "type", "(", "self", ".", "_control_value", ")", "is", "not", "list", ":", "\n", "            ", "self", ".", "_control_value", "=", "[", "self", ".", "_control_value", "]", "\n", "", "if", "type", "(", "self", ".", "_treatment_value", ")", "is", "not", "list", ":", "\n", "            ", "self", ".", "_treatment_value", "=", "[", "self", ".", "_treatment_value", "]", "\n", "", "T0_test", "=", "np", ".", "repeat", "(", "[", "self", ".", "_control_value", "]", ",", "n_target_units", ",", "axis", "=", "0", ")", "\n", "T1_test", "=", "np", ".", "repeat", "(", "[", "self", ".", "_treatment_value", "]", ",", "n_target_units", ",", "axis", "=", "0", ")", "\n", "est", "=", "self", ".", "estimator", ".", "effect", "(", "X_test", ",", "T0", "=", "T0_test", ",", "T1", "=", "T1_test", ")", "\n", "ate", "=", "np", ".", "mean", "(", "est", ")", "\n", "\n", "self", ".", "effect_intervals", "=", "None", "\n", "if", "self", ".", "_confidence_intervals", ":", "\n", "            ", "self", ".", "effect_intervals", "=", "self", ".", "estimator", ".", "effect_interval", "(", "\n", "X_test", ",", "T0", "=", "T0_test", ",", "T1", "=", "T1_test", ",", "\n", "alpha", "=", "1", "-", "self", ".", "confidence_level", ")", "\n", "", "estimate", "=", "CausalEstimate", "(", "estimate", "=", "ate", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ",", "\n", "cate_estimates", "=", "est", ",", "\n", "effect_intervals", "=", "self", ".", "effect_intervals", ",", "\n", "_estimator_object", "=", "self", ".", "estimator", ")", "\n", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._estimate_confidence_intervals": [[155, 159], ["None"], "methods", ["None"], ["", "def", "_estimate_confidence_intervals", "(", "self", ",", "confidence_level", "=", "None", ",", "method", "=", "None", ")", ":", "\n", "        ", "\"\"\" Returns None if the confidence interval has not been calculated.\n        \"\"\"", "\n", "return", "self", ".", "effect_intervals", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._do": [[160, 162], ["None"], "methods", ["None"], ["", "def", "_do", "(", "self", ",", "x", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.construct_symbolic_estimator": [[163, 175], ["econml.Econml._econml_methodname.rpartition", "module_name.endswith"], "methods", ["None"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "expr", "=", "\"b: \"", "+", "\", \"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", "+", "\"~\"", "\n", "# TODO -- fix: we are actually conditioning on positive treatment (d=1)", "\n", "(", "module_name", ",", "_", ",", "class_name", ")", "=", "self", ".", "_econml_methodname", ".", "rpartition", "(", "\".\"", ")", "\n", "if", "module_name", ".", "endswith", "(", "\"metalearners\"", ")", ":", "\n", "            ", "var_list", "=", "estimand", ".", "treatment_variable", "+", "self", ".", "_effect_modifier_names", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "", "else", ":", "\n", "            ", "var_list", "=", "estimand", ".", "treatment_variable", "+", "self", ".", "_observed_common_causes_names", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "expr", "+=", "\" | \"", "+", "\",\"", ".", "join", "(", "self", ".", "_effect_modifier_names", ")", "\n", "", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.shap_values": [[176, 179], ["econml.Econml.estimator.shap_values"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.shap_values"], ["", "def", "shap_values", "(", "self", ",", "df", ":", "pd", ".", "DataFrame", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "estimator", ".", "shap_values", "(", "\n", "df", "[", "self", ".", "_effect_modifier_names", "]", ".", "values", ",", "*", "args", ",", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.effect": [[181, 184], ["econml.Econml.estimator.effect"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.effect"], ["", "def", "effect", "(", "self", ",", "df", ":", "pd", ".", "DataFrame", ",", "*", "args", ",", "**", "kwargs", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "estimator", ".", "effect", "(", "\n", "df", "[", "self", ".", "_effect_modifier_names", "]", ".", "values", ",", "*", "args", ",", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.effect_inference": [[186, 189], ["econml.Econml.estimator.effect_inference"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml.effect_inference"], ["", "def", "effect_inference", "(", "self", ",", "df", ":", "pd", ".", "DataFrame", ",", "*", "args", ",", "**", "kwargs", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "estimator", ".", "effect_inference", "(", "\n", "df", "[", "self", ".", "_effect_modifier_names", "]", ".", "values", ",", "*", "args", ",", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_matching_estimator.PropensityScoreMatchingEstimator.__init__": [[20, 48], ["dowhy.causal_estimators.propensity_score_estimator.PropensityScoreEstimator.__init__", "propensity_score_matching_estimator.PropensityScoreMatchingEstimator.logger.info", "propensity_score_matching_estimator.PropensityScoreMatchingEstimator.construct_symbolic_estimator", "propensity_score_matching_estimator.PropensityScoreMatchingEstimator.logger.info"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator"], ["def", "__init__", "(", "\n", "self", ",", "\n", "*", "args", ",", "\n", "propensity_score_model", "=", "None", ",", "\n", "recalculate_propensity_score", "=", "True", ",", "\n", "propensity_score_column", "=", "\"propensity_score\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param propensity_score_model: Model used to compute propensity score.\n            Can be any classification model that supports fit() and\n            predict_proba() methods. If None, LogisticRegression is used.\n        :param recalculate_propensity_score: Whether the propensity score\n            should be estimated. To use pre-computed propensity scores,\n            set this value to False. Default=True.\n        :param propensity_score_column: Column name that stores the\n            propensity score. Default='propensity_score'\n\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "*", "args", ",", "\n", "propensity_score_model", "=", "propensity_score_model", ",", "\n", "recalculate_propensity_score", "=", "recalculate_propensity_score", ",", "\n", "propensity_score_column", "=", "propensity_score_column", ",", "\n", "**", "kwargs", ")", "\n", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: Using Propensity Score Matching Estimator\"", ")", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_matching_estimator.PropensityScoreMatchingEstimator._estimate_effect": [[49, 119], ["sklearn.neighbors.NearestNeighbors().fit", "sklearn.neighbors.NearestNeighbors().fit.kneighbors", "propensity_score_matching_estimator.PropensityScoreMatchingEstimator.logger.debug", "propensity_score_matching_estimator.PropensityScoreMatchingEstimator.logger.debug", "range", "sklearn.neighbors.NearestNeighbors().fit", "sklearn.neighbors.NearestNeighbors().fit.kneighbors", "range", "dowhy.causal_estimator.CausalEstimate", "propensity_score_matching_estimator.PropensityScoreMatchingEstimator.propensity_score_model.fit", "control[].values.reshape", "treated[].values.reshape", "[].item", "[].item", "treated[].values.reshape", "control[].values.reshape", "[].item", "[].item", "sklearn.linear_model.LogisticRegression", "propensity_score_matching_estimator.PropensityScoreMatchingEstimator.propensity_score_model.predict_proba", "ValueError", "propensity_score_matching_estimator.PropensityScoreMatchingEstimator.logger.info", "sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors", "ValueError"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "recalculate_propensity_score", "is", "True", ":", "\n", "            ", "if", "self", ".", "propensity_score_model", "is", "None", ":", "\n", "                ", "self", ".", "propensity_score_model", "=", "linear_model", ".", "LogisticRegression", "(", ")", "\n", "", "self", ".", "propensity_score_model", ".", "fit", "(", "self", ".", "_observed_common_causes", ",", "self", ".", "_treatment", ")", "\n", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "=", "self", ".", "propensity_score_model", ".", "predict_proba", "(", "self", ".", "_observed_common_causes", ")", "[", ":", ",", "1", "]", "\n", "", "else", ":", "\n", "# check if the user provides a propensity score column", "\n", "            ", "if", "self", ".", "propensity_score_column", "not", "in", "self", ".", "_data", ".", "columns", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Propensity score column {self.propensity_score_column} does not exist. Please specify the column name that has your pre-computed propensity score.\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "logger", ".", "info", "(", "f\"INFO: Using pre-computed propensity score in column {self.propensity_score_column}\"", ")", "\n", "\n", "\n", "# this assumes a binary treatment regime", "\n", "", "", "treated", "=", "self", ".", "_data", ".", "loc", "[", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "==", "1", "]", "\n", "control", "=", "self", ".", "_data", ".", "loc", "[", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "==", "0", "]", "\n", "\n", "\n", "# TODO remove neighbors that are more than a given radius apart", "\n", "\n", "# estimate ATT on treated by summing over difference between matched neighbors", "\n", "control_neighbors", "=", "(", "\n", "NearestNeighbors", "(", "n_neighbors", "=", "1", ",", "algorithm", "=", "'ball_tree'", ")", "\n", ".", "fit", "(", "control", "[", "self", ".", "propensity_score_column", "]", ".", "values", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", ")", "\n", "distances", ",", "indices", "=", "control_neighbors", ".", "kneighbors", "(", "treated", "[", "self", ".", "propensity_score_column", "]", ".", "values", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"distances:\"", ")", "\n", "self", ".", "logger", ".", "debug", "(", "distances", ")", "\n", "\n", "att", "=", "0", "\n", "numtreatedunits", "=", "treated", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "numtreatedunits", ")", ":", "\n", "            ", "treated_outcome", "=", "treated", ".", "iloc", "[", "i", "]", "[", "self", ".", "_outcome_name", "]", ".", "item", "(", ")", "\n", "control_outcome", "=", "control", ".", "iloc", "[", "indices", "[", "i", "]", "]", "[", "self", ".", "_outcome_name", "]", ".", "item", "(", ")", "\n", "att", "+=", "treated_outcome", "-", "control_outcome", "\n", "\n", "", "att", "/=", "numtreatedunits", "\n", "\n", "#Now computing ATC", "\n", "treated_neighbors", "=", "(", "\n", "NearestNeighbors", "(", "n_neighbors", "=", "1", ",", "algorithm", "=", "'ball_tree'", ")", "\n", ".", "fit", "(", "treated", "[", "self", ".", "propensity_score_column", "]", ".", "values", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", ")", "\n", "distances", ",", "indices", "=", "treated_neighbors", ".", "kneighbors", "(", "control", "[", "self", ".", "propensity_score_column", "]", ".", "values", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "atc", "=", "0", "\n", "numcontrolunits", "=", "control", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "numcontrolunits", ")", ":", "\n", "            ", "control_outcome", "=", "control", ".", "iloc", "[", "i", "]", "[", "self", ".", "_outcome_name", "]", ".", "item", "(", ")", "\n", "treated_outcome", "=", "treated", ".", "iloc", "[", "indices", "[", "i", "]", "]", "[", "self", ".", "_outcome_name", "]", ".", "item", "(", ")", "\n", "atc", "+=", "treated_outcome", "-", "control_outcome", "\n", "\n", "", "atc", "/=", "numcontrolunits", "\n", "\n", "if", "self", ".", "_target_units", "==", "\"att\"", ":", "\n", "            ", "est", "=", "att", "\n", "", "elif", "self", ".", "_target_units", "==", "\"atc\"", ":", "\n", "            ", "est", "=", "atc", "\n", "", "elif", "self", ".", "_target_units", "==", "\"ate\"", ":", "\n", "            ", "est", "=", "(", "att", "*", "numtreatedunits", "+", "atc", "*", "numcontrolunits", ")", "/", "(", "numtreatedunits", "+", "numcontrolunits", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Target units string value not supported\"", ")", "\n", "\n", "", "estimate", "=", "CausalEstimate", "(", "estimate", "=", "est", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ",", "\n", "propensity_scores", "=", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_matching_estimator.PropensityScoreMatchingEstimator.construct_symbolic_estimator": [[120, 126], ["estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "expr", "=", "\"b: \"", "+", "\", \"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", "+", "\"~\"", "\n", "# TODO -- fix: we are actually conditioning on positive treatment (d=1)", "\n", "var_list", "=", "estimand", ".", "treatment_variable", "+", "estimand", ".", "get_backdoor_variables", "(", ")", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "return", "expr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.instrumental_variable_estimator.InstrumentalVariableEstimator.__init__": [[23, 52], ["args_dict.update", "dowhy.causal_estimator.CausalEstimator.__init__", "instrumental_variable_estimator.InstrumentalVariableEstimator.logger.debug", "instrumental_variable_estimator.InstrumentalVariableEstimator.logger.info", "instrumental_variable_estimator.InstrumentalVariableEstimator.construct_symbolic_estimator", "instrumental_variable_estimator.InstrumentalVariableEstimator.logger.info", "dowhy.utils.api.parse_state", "ValueError", "len", "len", "ValueError", "locals().items", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "iv_instrument_name", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param iv_instrument_name: Name of the specific instrumental variable\n            to be used. Needs to be one of the IVs identified in the\n            identification step. Default is to use all the IV variables\n            from the identification step.\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the information", "\n", "# to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "# choosing the instrumental variable to use", "\n", "self", ".", "estimating_instrument_names", "=", "self", ".", "_target_estimand", ".", "instrumental_variables", "\n", "if", "iv_instrument_name", "is", "not", "None", ":", "\n", "            ", "self", ".", "estimating_instrument_names", "=", "parse_state", "(", "iv_instrument_name", ")", "\n", "", "self", ".", "logger", ".", "debug", "(", "\"Instrumental Variables used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "estimating_instrument_names", ")", ")", "\n", "if", "not", "self", ".", "estimating_instrument_names", ":", "\n", "            ", "raise", "ValueError", "(", "\"No valid instruments found. IV Method not applicable\"", ")", "\n", "", "if", "len", "(", "self", ".", "estimating_instrument_names", ")", "<", "len", "(", "self", ".", "_treatment_name", ")", ":", "\n", "# TODO move this to the identification step", "\n", "            ", "raise", "ValueError", "(", "\"Number of instruments fewer than number of treatments. 2SLS requires at least as many instruments as treatments.\"", ")", "\n", "", "self", ".", "_estimating_instruments", "=", "self", ".", "_data", "[", "self", ".", "estimating_instrument_names", "]", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: Using Instrumental Variable Estimator\"", ")", "\n", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.instrumental_variable_estimator.InstrumentalVariableEstimator._estimate_effect": [[53, 88], ["dowhy.causal_estimator.CausalEstimate", "instrumental_variable_estimator.InstrumentalVariableEstimator.logger.debug", "len", "instrumental_variable_estimator.InstrumentalVariableEstimator._treatment.astype", "instrumental_variable_estimator.InstrumentalVariableEstimator._outcome.astype", "statsmodels.sandbox.regression.gmm.IV2SLS", "statsmodels.sandbox.regression.gmm.IV2SLS.fit", "print", "sum", "len", "len", "numpy.unique", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "statsmodels.sandbox.regression.gmm.IV2SLS.fit.summary", "numpy.cov", "numpy.cov"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.summary"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "estimating_instrument_names", ")", "==", "1", "and", "len", "(", "self", ".", "_treatment_name", ")", "==", "1", ":", "\n", "            ", "instrument", "=", "self", ".", "_estimating_instruments", ".", "iloc", "[", ":", ",", "0", "]", "\n", "self", ".", "logger", ".", "debug", "(", "\"Instrument Variable values: {0}\"", ".", "format", "(", "instrument", ")", ")", "\n", "num_unique_values", "=", "len", "(", "np", ".", "unique", "(", "instrument", ")", ")", "\n", "instrument_is_binary", "=", "(", "num_unique_values", "<=", "2", ")", "\n", "if", "instrument_is_binary", ":", "\n", "# Obtain estimate by Wald Estimator", "\n", "                ", "y1_z", "=", "np", ".", "mean", "(", "self", ".", "_outcome", "[", "instrument", "==", "1", "]", ")", "\n", "y0_z", "=", "np", ".", "mean", "(", "self", ".", "_outcome", "[", "instrument", "==", "0", "]", ")", "\n", "x1_z", "=", "np", ".", "mean", "(", "self", ".", "_treatment", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "[", "instrument", "==", "1", "]", ")", "\n", "x0_z", "=", "np", ".", "mean", "(", "self", ".", "_treatment", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "[", "instrument", "==", "0", "]", ")", "\n", "num", "=", "y1_z", "-", "y0_z", "\n", "deno", "=", "x1_z", "-", "x0_z", "\n", "iv_est", "=", "num", "/", "deno", "\n", "", "else", ":", "\n", "# Obtain estimate by 2SLS estimator: Cov(y,z) / Cov(x,z)", "\n", "                ", "num_yz", "=", "np", ".", "cov", "(", "self", ".", "_outcome", ",", "instrument", ")", "[", "0", ",", "1", "]", "\n", "deno_xz", "=", "np", ".", "cov", "(", "self", ".", "_treatment", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ",", "instrument", ")", "[", "0", ",", "1", "]", "\n", "iv_est", "=", "num_yz", "/", "deno_xz", "\n", "", "", "else", ":", "\n", "# More than 1 instrument. Use 2sls.", "\n", "            ", "est_treatment", "=", "self", ".", "_treatment", ".", "astype", "(", "np", ".", "float32", ")", "\n", "est_outcome", "=", "self", ".", "_outcome", ".", "astype", "(", "np", ".", "float32", ")", "\n", "ivmodel", "=", "IV2SLS", "(", "est_outcome", ",", "est_treatment", ",", "\n", "self", ".", "_estimating_instruments", ")", "\n", "reg_results", "=", "ivmodel", ".", "fit", "(", ")", "\n", "print", "(", "reg_results", ".", "summary", "(", ")", ")", "\n", "iv_est", "=", "sum", "(", "reg_results", ".", "params", ")", "# the effect is the same for any treatment value (assume treatment goes from 0 to 1)", "\n", "", "estimate", "=", "CausalEstimate", "(", "estimate", "=", "iv_est", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ")", "\n", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.instrumental_variable_estimator.InstrumentalVariableEstimator.construct_symbolic_estimator": [[89, 119], ["sympy.Normal", "sympy.Normal", "sympy.Normal", "sympy.Normal", "sympy.Symbol", "sympy.Symbol", "sympy.Derivative", "sympy.Derivative", "sympy.Derivative", "sympy.Derivative", "dowhy.causal_estimator.RealizedEstimand", "dowhy.causal_estimator.RealizedEstimand.update_assumptions", "dowhy.causal_estimator.RealizedEstimand.update_estimand_expression", "sympy.Expectation", "sympy.Expectation", "sympy.stats.Expectation", "sympy.stats.Expectation"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.RealizedEstimand.update_assumptions", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.RealizedEstimand.update_estimand_expression"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "sym_outcome", "=", "(", "spstats", ".", "Normal", "(", "\",\"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", ",", "0", ",", "1", ")", ")", "\n", "sym_treatment", "=", "(", "spstats", ".", "Normal", "(", "\",\"", ".", "join", "(", "estimand", ".", "treatment_variable", ")", ",", "0", ",", "1", ")", ")", "\n", "sym_instrument", "=", "sp", ".", "Symbol", "(", "\",\"", ".", "join", "(", "self", ".", "estimating_instrument_names", ")", ")", "\n", "sym_outcome_derivative", "=", "sp", ".", "Derivative", "(", "sym_outcome", ",", "sym_instrument", ")", "\n", "sym_treatment_derivative", "=", "sp", ".", "Derivative", "(", "sym_treatment", ",", "sym_instrument", ")", "\n", "sym_effect", "=", "(", "\n", "spstats", ".", "Expectation", "(", "sym_outcome_derivative", ")", "/", "\n", "sp", ".", "stats", ".", "Expectation", "(", "sym_treatment_derivative", ")", "\n", ")", "\n", "estimator_assumptions", "=", "{", "\n", "\"treatment_effect_homogeneity\"", ":", "(", "\n", "\"Each unit's treatment {0} is \"", ".", "format", "(", "self", ".", "_treatment_name", ")", "+", "\n", "\"affected in the same way by common causes of \"", "\n", "\"{0} and {1}\"", ".", "format", "(", "self", ".", "_treatment_name", ",", "self", ".", "_outcome_name", ")", "\n", ")", ",", "\n", "\"outcome_effect_homogeneity\"", ":", "(", "\n", "\"Each unit's outcome {0} is \"", ".", "format", "(", "self", ".", "_outcome_name", ")", "+", "\n", "\"affected in the same way by common causes of \"", "\n", "\"{0} and {1}\"", ".", "format", "(", "self", ".", "_treatment_name", ",", "self", ".", "_outcome_name", ")", "\n", ")", ",", "\n", "}", "\n", "sym_assumptions", "=", "{", "**", "estimand", ".", "estimands", "[", "\"iv\"", "]", "[", "\"assumptions\"", "]", ",", "\n", "**", "estimator_assumptions", "}", "\n", "\n", "symbolic_estimand", "=", "RealizedEstimand", "(", "estimand", ",", "\n", "estimator_name", "=", "\"Wald Estimator\"", ")", "\n", "symbolic_estimand", ".", "update_assumptions", "(", "sym_assumptions", ")", "\n", "symbolic_estimand", ".", "update_estimand_expression", "(", "sym_effect", ")", "\n", "return", "symbolic_estimand", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.__init__.get_class_object": [[6, 29], ["string.capwords().replace", "importlib.import_module", "getattr", "issubclass", "string.capwords", "getattr", "issubclass", "estimator_name.split", "importlib.import_module", "ImportError", "estimator_name.split"], "function", ["None"], ["\n", "here", "=", "path", ".", "abspath", "(", "path", ".", "dirname", "(", "__file__", ")", ")", "\n", "# Loading version number", "\n", "with", "open", "(", "path", ".", "join", "(", "here", ",", "'VERSION'", ")", ")", "as", "version_file", ":", "\n", "    ", "__version__", "=", "version_file", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.distance_matching_estimator.DistanceMatchingEstimator.__init__": [[20, 84], ["args_dict.update", "dowhy.causal_estimator.CausalEstimator.__init__", "distance_matching_estimator.DistanceMatchingEstimator.logger.debug", "distance_matching_estimator.DistanceMatchingEstimator._target_estimand.get_backdoor_variables", "distance_matching_estimator.DistanceMatchingEstimator.logger.info", "distance_matching_estimator.DistanceMatchingEstimator.construct_symbolic_estimator", "distance_matching_estimator.DistanceMatchingEstimator.logger.info", "len", "Exception", "pandas.api.types.is_bool_dtype", "distance_matching_estimator.DistanceMatchingEstimator.logger.error", "Exception", "pandas.get_dummies", "distance_matching_estimator.DistanceMatchingEstimator.logger.error", "Exception", "getattr", "locals().items", "str", "distance_matching_estimator.DistanceMatchingEstimator._target_estimand.get_backdoor_variables", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "num_matches_per_unit", "=", "1", ",", "\n", "distance_metric", "=", "\"minkowski\"", ",", "exact_match_cols", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param num_matches_per_unit: The number of matches per data point.\n            Default=1.\n        :param distance_metric: Distance metric to use. Default=\"minkowski\"\n            that corresponds to Euclidean distance metric with p=2.\n        :param exact_match_cols: List of column names whose values should be\n        exactly matched. Typically used for columns with discrete values.\n\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the", "\n", "# parameters to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "# Check if the treatment is one-dimensional", "\n", "if", "len", "(", "self", ".", "_treatment_name", ")", ">", "1", ":", "\n", "            ", "error_msg", "=", "str", "(", "self", ".", "__class__", ")", "+", "\"cannot handle more than one treatment variable\"", "\n", "raise", "Exception", "(", "error_msg", ")", "\n", "# Checking if the treatment is binary", "\n", "", "if", "not", "pd", ".", "api", ".", "types", ".", "is_bool_dtype", "(", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", ":", "\n", "            ", "error_msg", "=", "\"Distance Matching method is applicable only for binary treatments\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "Exception", "(", "error_msg", ")", "\n", "\n", "", "self", ".", "num_matches_per_unit", "=", "num_matches_per_unit", "\n", "self", ".", "distance_metric", "=", "distance_metric", "\n", "self", ".", "exact_match_cols", "=", "exact_match_cols", "\n", "\n", "self", ".", "logger", ".", "debug", "(", "\"Back-door variables used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ")", ")", "\n", "\n", "self", ".", "_observed_common_causes_names", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "\n", "if", "self", ".", "_observed_common_causes_names", ":", "\n", "            ", "if", "self", ".", "exact_match_cols", "is", "not", "None", ":", "\n", "                ", "self", ".", "_observed_common_causes_names", "=", "[", "v", "for", "v", "in", "self", ".", "_observed_common_causes_names", "if", "v", "not", "in", "self", ".", "exact_match_cols", "]", "\n", "", "self", ".", "_observed_common_causes", "=", "self", ".", "_data", "[", "self", ".", "_observed_common_causes_names", "]", "\n", "# Convert the categorical variables into dummy/indicator variables", "\n", "# Basically, this gives a one hot encoding for each category", "\n", "# The first category is taken to be the base line.", "\n", "self", ".", "_observed_common_causes", "=", "pd", ".", "get_dummies", "(", "self", ".", "_observed_common_causes", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_observed_common_causes", "=", "None", "\n", "error_msg", "=", "\"No common causes/confounders present. Distance matching methods are not applicable\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "Exception", "(", "error_msg", ")", "\n", "\n", "\n", "# Dictionary of any user-provided params for the distance metric", "\n", "# that will be passed to sklearn nearestneighbors", "\n", "", "self", ".", "distance_metric_params", "=", "{", "}", "\n", "for", "param_name", "in", "self", ".", "Valid_Dist_Metric_Params", ":", "\n", "            ", "param_val", "=", "getattr", "(", "self", ",", "param_name", ",", "None", ")", "\n", "if", "param_val", "is", "not", "None", ":", "\n", "                ", "self", ".", "distance_metric_params", "[", "param_name", "]", "=", "param_val", "\n", "\n", "\n", "", "", "self", ".", "logger", ".", "info", "(", "\"INFO: Using Distance Matching Estimator\"", ")", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "self", ".", "matched_indices_att", "=", "None", "\n", "self", ".", "matched_indices_atc", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.distance_matching_estimator.DistanceMatchingEstimator._estimate_effect": [[85, 213], ["pandas.concat", "dowhy.causal_estimator.CausalEstimate", "pandas.concat", "sklearn.neighbors.NearestNeighbors().fit", "sklearn.neighbors.NearestNeighbors().fit.kneighbors", "range", "control.index.tolist", "range", "sklearn.neighbors.NearestNeighbors().fit", "sklearn.neighbors.NearestNeighbors().fit.kneighbors", "distance_matching_estimator.DistanceMatchingEstimator.logger.debug", "distance_matching_estimator.DistanceMatchingEstimator.logger.debug", "range", "treated.index.tolist", "range", "pandas.concat.groupby", "[].item", "numpy.mean", "treated.iloc[].index.tolist", "ValueError", "[].item", "numpy.mean", "control.iloc[].index.tolist", "sklearn.neighbors.NearestNeighbors().fit", "sklearn.neighbors.NearestNeighbors().fit.kneighbors", "distance_matching_estimator.DistanceMatchingEstimator.logger.debug", "distance_matching_estimator.DistanceMatchingEstimator.logger.debug", "range", "sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors", "[].item", "numpy.mean", "sklearn.neighbors.NearestNeighbors"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "# this assumes a binary treatment regime", "\n", "        ", "updated_df", "=", "pd", ".", "concat", "(", "[", "self", ".", "_observed_common_causes", ",", "\n", "self", ".", "_data", "[", "[", "self", ".", "_outcome_name", ",", "self", ".", "_treatment_name", "[", "0", "]", "]", "]", "]", ",", "axis", "=", "1", ")", "\n", "if", "self", ".", "exact_match_cols", "is", "not", "None", ":", "\n", "            ", "updated_df", "=", "pd", ".", "concat", "(", "[", "updated_df", ",", "self", ".", "_data", "[", "self", ".", "exact_match_cols", "]", "]", ",", "axis", "=", "1", ")", "\n", "", "treated", "=", "updated_df", ".", "loc", "[", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "==", "1", "]", "\n", "control", "=", "updated_df", ".", "loc", "[", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "==", "0", "]", "\n", "numtreatedunits", "=", "treated", ".", "shape", "[", "0", "]", "\n", "numcontrolunits", "=", "control", ".", "shape", "[", "0", "]", "\n", "\n", "fit_att", ",", "fit_atc", "=", "False", ",", "False", "\n", "est", "=", "None", "\n", "# TODO remove neighbors that are more than a given radius apart", "\n", "if", "self", ".", "_target_units", "==", "\"att\"", ":", "\n", "            ", "fit_att", "=", "True", "\n", "", "elif", "self", ".", "_target_units", "==", "\"atc\"", ":", "\n", "            ", "fit_atc", "=", "True", "\n", "", "elif", "self", ".", "_target_units", "==", "\"ate\"", ":", "\n", "            ", "fit_att", "=", "True", "\n", "fit_atc", "=", "True", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Target units string value not supported\"", ")", "\n", "\n", "", "if", "fit_att", ":", "\n", "# estimate ATT on treated by summing over difference between matched neighbors", "\n", "            ", "if", "self", ".", "exact_match_cols", "is", "None", ":", "\n", "                ", "control_neighbors", "=", "(", "\n", "NearestNeighbors", "(", "n_neighbors", "=", "self", ".", "num_matches_per_unit", ",", "\n", "metric", "=", "self", ".", "distance_metric", ",", "\n", "algorithm", "=", "'ball_tree'", ",", "\n", "**", "self", ".", "distance_metric_params", ")", "\n", ".", "fit", "(", "control", "[", "self", ".", "_observed_common_causes", ".", "columns", "]", ".", "values", ")", "\n", ")", "\n", "distances", ",", "indices", "=", "control_neighbors", ".", "kneighbors", "(", "\n", "treated", "[", "self", ".", "_observed_common_causes", ".", "columns", "]", ".", "values", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"distances:\"", ")", "\n", "self", ".", "logger", ".", "debug", "(", "distances", ")", "\n", "\n", "att", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "numtreatedunits", ")", ":", "\n", "                    ", "treated_outcome", "=", "treated", ".", "iloc", "[", "i", "]", "[", "self", ".", "_outcome_name", "]", ".", "item", "(", ")", "\n", "control_outcome", "=", "np", ".", "mean", "(", "control", ".", "iloc", "[", "indices", "[", "i", "]", "]", "[", "self", ".", "_outcome_name", "]", ".", "values", ")", "\n", "att", "+=", "treated_outcome", "-", "control_outcome", "\n", "\n", "", "att", "/=", "numtreatedunits", "\n", "if", "self", ".", "_target_units", "==", "\"att\"", ":", "\n", "                    ", "est", "=", "att", "\n", "", "elif", "self", ".", "_target_units", "==", "\"ate\"", ":", "\n", "                    ", "est", "=", "att", "*", "numtreatedunits", "\n", "\n", "# Return indices in the original dataframe", "\n", "", "self", ".", "matched_indices_att", "=", "{", "}", "\n", "treated_df_index", "=", "treated", ".", "index", ".", "tolist", "(", ")", "\n", "for", "i", "in", "range", "(", "numtreatedunits", ")", ":", "\n", "                    ", "self", ".", "matched_indices_att", "[", "treated_df_index", "[", "i", "]", "]", "=", "control", ".", "iloc", "[", "indices", "[", "i", "]", "]", ".", "index", ".", "tolist", "(", ")", "\n", "", "", "else", ":", "\n", "                ", "grouped", "=", "updated_df", ".", "groupby", "(", "self", ".", "exact_match_cols", ")", "\n", "att", "=", "0", "\n", "for", "name", ",", "group", "in", "grouped", ":", "\n", "                    ", "treated", "=", "group", ".", "loc", "[", "group", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "==", "1", "]", "\n", "control", "=", "group", ".", "loc", "[", "group", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "==", "0", "]", "\n", "if", "treated", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "control_neighbors", "=", "(", "\n", "NearestNeighbors", "(", "n_neighbors", "=", "self", ".", "num_matches_per_unit", ",", "\n", "metric", "=", "self", ".", "distance_metric", ",", "\n", "algorithm", "=", "'ball_tree'", ",", "\n", "**", "self", ".", "distance_metric_params", ")", "\n", ".", "fit", "(", "control", "[", "self", ".", "_observed_common_causes", ".", "columns", "]", ".", "values", ")", "\n", ")", "\n", "distances", ",", "indices", "=", "control_neighbors", ".", "kneighbors", "(", "\n", "treated", "[", "self", ".", "_observed_common_causes", ".", "columns", "]", ".", "values", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"distances:\"", ")", "\n", "self", ".", "logger", ".", "debug", "(", "distances", ")", "\n", "\n", "for", "i", "in", "range", "(", "numtreatedunits", ")", ":", "\n", "                        ", "treated_outcome", "=", "treated", ".", "iloc", "[", "i", "]", "[", "self", ".", "_outcome_name", "]", ".", "item", "(", ")", "\n", "control_outcome", "=", "np", ".", "mean", "(", "control", ".", "iloc", "[", "indices", "[", "i", "]", "]", "[", "self", ".", "_outcome_name", "]", ".", "values", ")", "\n", "att", "+=", "treated_outcome", "-", "control_outcome", "\n", "#self.matched_indices_att[treated_df_index[i]] = control.iloc[indices[i]].index.tolist()", "\n", "\n", "", "", "att", "/=", "numtreatedunits", "\n", "\n", "if", "self", ".", "_target_units", "==", "\"att\"", ":", "\n", "                    ", "est", "=", "att", "\n", "", "elif", "self", ".", "_target_units", "==", "\"ate\"", ":", "\n", "                    ", "est", "=", "att", "*", "numtreatedunits", "\n", "\n", "", "", "", "if", "fit_atc", ":", "\n", "#Now computing ATC", "\n", "            ", "treated_neighbors", "=", "(", "\n", "NearestNeighbors", "(", "n_neighbors", "=", "self", ".", "num_matches_per_unit", ",", "\n", "metric", "=", "self", ".", "distance_metric", ",", "\n", "algorithm", "=", "'ball_tree'", ",", "\n", "**", "self", ".", "distance_metric_params", ")", "\n", ".", "fit", "(", "treated", "[", "self", ".", "_observed_common_causes", ".", "columns", "]", ".", "values", ")", "\n", ")", "\n", "distances", ",", "indices", "=", "treated_neighbors", ".", "kneighbors", "(", "\n", "control", "[", "self", ".", "_observed_common_causes", ".", "columns", "]", ".", "values", ")", "\n", "\n", "atc", "=", "0", "\n", "for", "i", "in", "range", "(", "numcontrolunits", ")", ":", "\n", "                ", "control_outcome", "=", "control", ".", "iloc", "[", "i", "]", "[", "self", ".", "_outcome_name", "]", ".", "item", "(", ")", "\n", "treated_outcome", "=", "np", ".", "mean", "(", "treated", ".", "iloc", "[", "indices", "[", "i", "]", "]", "[", "self", ".", "_outcome_name", "]", ".", "values", ")", "\n", "atc", "+=", "treated_outcome", "-", "control_outcome", "\n", "\n", "", "atc", "/=", "numcontrolunits", "\n", "\n", "if", "self", ".", "_target_units", "==", "\"atc\"", ":", "\n", "                ", "est", "=", "atc", "\n", "", "elif", "self", ".", "_target_units", "==", "\"ate\"", ":", "\n", "                ", "est", "+=", "atc", "*", "numcontrolunits", "\n", "est", "/=", "(", "numtreatedunits", "+", "numcontrolunits", ")", "\n", "\n", "# Return indices in the original dataframe", "\n", "", "self", ".", "matched_indices_atc", "=", "{", "}", "\n", "control_df_index", "=", "control", ".", "index", ".", "tolist", "(", ")", "\n", "for", "i", "in", "range", "(", "numcontrolunits", ")", ":", "\n", "                ", "self", ".", "matched_indices_atc", "[", "control_df_index", "[", "i", "]", "]", "=", "treated", ".", "iloc", "[", "indices", "[", "i", "]", "]", ".", "index", ".", "tolist", "(", ")", "\n", "\n", "", "", "estimate", "=", "CausalEstimate", "(", "estimate", "=", "est", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ")", "\n", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.distance_matching_estimator.DistanceMatchingEstimator.construct_symbolic_estimator": [[214, 219], ["estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "expr", "=", "\"b: \"", "+", "\", \"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", "+", "\"~\"", "\n", "var_list", "=", "estimand", ".", "treatment_variable", "+", "estimand", ".", "get_backdoor_variables", "(", ")", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "return", "expr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.two_stage_regression_estimator.TwoStageRegressionEstimator.__init__": [[29, 94], ["args_dict.update", "dowhy.causal_estimator.CausalEstimator.__init__", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.info", "len", "Exception", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.debug", "two_stage_regression_estimator.TwoStageRegressionEstimator._target_estimand.get_frontdoor_variables", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.warning", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.warning", "locals().items", "str", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.error", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.debug", "two_stage_regression_estimator.TwoStageRegressionEstimator._target_estimand.get_mediator_variables", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.error", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.debug", "two_stage_regression_estimator.TwoStageRegressionEstimator._target_estimand.get_instrumental_variables", "locals", "type", "two_stage_regression_estimator.TwoStageRegressionEstimator._target_estimand.get_frontdoor_variables", "two_stage_regression_estimator.TwoStageRegressionEstimator.logger.error", "two_stage_regression_estimator.TwoStageRegressionEstimator._target_estimand.get_mediator_variables", "two_stage_regression_estimator.TwoStageRegressionEstimator._target_estimand.get_instrumental_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_frontdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_mediator_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_instrumental_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_frontdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_mediator_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_instrumental_variables"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "first_stage_model", "=", "None", ",", "\n", "second_stage_model", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param first_stage_model: First stage estimator to be used. Default is\n            linear regression.\n        :param second_stage_model: Second stage estimator to be used. Default\n            is linear regression.\n\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the", "\n", "# parameters needed to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: Using Two Stage Regression Estimator\"", ")", "\n", "# Check if the treatment is one-dimensional", "\n", "if", "len", "(", "self", ".", "_treatment_name", ")", ">", "1", ":", "\n", "            ", "error_msg", "=", "str", "(", "self", ".", "__class__", ")", "+", "\"cannot handle more than one treatment variable\"", "\n", "raise", "Exception", "(", "error_msg", ")", "\n", "\n", "", "if", "self", ".", "_target_estimand", ".", "identifier_method", "==", "\"frontdoor\"", ":", "\n", "            ", "self", ".", "logger", ".", "debug", "(", "\"Front-door variable used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_target_estimand", ".", "get_frontdoor_variables", "(", ")", ")", ")", "\n", "self", ".", "_frontdoor_variables_names", "=", "self", ".", "_target_estimand", ".", "get_frontdoor_variables", "(", ")", "\n", "\n", "if", "self", ".", "_frontdoor_variables_names", ":", "\n", "                ", "self", ".", "_frontdoor_variables", "=", "self", ".", "_data", "[", "self", ".", "_frontdoor_variables_names", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "_frontdoor_variables", "=", "None", "\n", "error_msg", "=", "\"No front-door variable present. Two stage regression is not applicable\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "", "", "elif", "self", ".", "_target_estimand", ".", "identifier_method", "==", "\"mediation\"", ":", "\n", "            ", "self", ".", "logger", ".", "debug", "(", "\"Mediators used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_target_estimand", ".", "get_mediator_variables", "(", ")", ")", ")", "\n", "self", ".", "_mediators_names", "=", "self", ".", "_target_estimand", ".", "get_mediator_variables", "(", ")", "\n", "\n", "if", "self", ".", "_mediators_names", ":", "\n", "               ", "self", ".", "_mediators", "=", "self", ".", "_data", "[", "self", ".", "_mediators_names", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "_mediators", "=", "None", "\n", "error_msg", "=", "\"No mediator variable present. Two stage regression is not applicable\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "", "", "elif", "self", ".", "_target_estimand", ".", "identifier_method", "==", "\"iv\"", ":", "\n", "            ", "self", ".", "logger", ".", "debug", "(", "\"Instrumental variables used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_target_estimand", ".", "get_instrumental_variables", "(", ")", ")", ")", "\n", "self", ".", "_instrumental_variables_names", "=", "self", ".", "_target_estimand", ".", "get_instrumental_variables", "(", ")", "\n", "\n", "if", "self", ".", "_instrumental_variables_names", ":", "\n", "                ", "self", ".", "_instrumental_variables", "=", "self", ".", "_data", "[", "self", ".", "_instrumental_variables_names", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "_instrumental_variables", "=", "None", "\n", "error_msg", "=", "\"No instrumental variable present. Two stage regression is not applicable\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "\n", "", "", "if", "first_stage_model", "is", "not", "None", ":", "\n", "            ", "self", ".", "first_stage_model", "=", "first_stage_model", "\n", "", "else", ":", "\n", "            ", "self", ".", "first_stage_model", "=", "self", ".", "__class__", ".", "DEFAULT_FIRST_STAGE_MODEL", "\n", "self", ".", "logger", ".", "warning", "(", "\"First stage model not provided. Defaulting to sklearn.linear_model.LinearRegression.\"", ")", "\n", "", "if", "second_stage_model", "is", "not", "None", ":", "\n", "            ", "self", ".", "second_stage_model", "=", "second_stage_model", "\n", "", "else", ":", "\n", "            ", "self", ".", "second_stage_model", "=", "self", ".", "__class__", ".", "DEFAULT_SECOND_STAGE_MODEL", "\n", "self", ".", "logger", ".", "warning", "(", "\"Second stage model not provided. Defaulting to backdoor.linear_regression.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.two_stage_regression_estimator.TwoStageRegressionEstimator._estimate_effect": [[95, 177], ["copy.deepcopy", "two_stage_regression_estimator.TwoStageRegressionEstimator.first_stage_model()._estimate_effect", "copy.deepcopy", "two_stage_regression_estimator.TwoStageRegressionEstimator.second_stage_model()._estimate_effect", "two_stage_regression_estimator.TwoStageRegressionEstimator.construct_symbolic_estimator", "dowhy.causal_estimator.CausalEstimate", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "copy.deepcopy", "two_stage_regression_estimator.TwoStageRegressionEstimator.second_stage_model()._estimate_effect", "two_stage_regression_estimator.TwoStageRegressionEstimator.construct_symbolic_estimator", "dowhy.utils.api.parse_state", "two_stage_regression_estimator.TwoStageRegressionEstimator.first_stage_model", "dowhy.utils.api.parse_state", "two_stage_regression_estimator.TwoStageRegressionEstimator.second_stage_model", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "two_stage_regression_estimator.TwoStageRegressionEstimator.second_stage_model", "dowhy.utils.api.parse_state"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state"], ["", "", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "estimate_value", "=", "None", "\n", "# First stage", "\n", "modified_target_estimand", "=", "copy", ".", "deepcopy", "(", "self", ".", "_target_estimand", ")", "\n", "modified_target_estimand", ".", "identifier_method", "=", "\"backdoor\"", "\n", "modified_target_estimand", ".", "backdoor_variables", "=", "self", ".", "_target_estimand", ".", "mediation_first_stage_confounders", "\n", "if", "self", ".", "_target_estimand", ".", "identifier_method", "==", "\"frontdoor\"", ":", "\n", "            ", "modified_target_estimand", ".", "outcome_variable", "=", "parse_state", "(", "self", ".", "_frontdoor_variables_names", ")", "\n", "", "elif", "self", ".", "_target_estimand", ".", "identifier_method", "==", "\"mediation\"", ":", "\n", "            ", "modified_target_estimand", ".", "outcome_variable", "=", "parse_state", "(", "self", ".", "_mediators_names", ")", "\n", "\n", "", "first_stage_estimate", "=", "self", ".", "first_stage_model", "(", "self", ".", "_data", ",", "\n", "modified_target_estimand", ",", "\n", "self", ".", "_treatment_name", ",", "\n", "parse_state", "(", "modified_target_estimand", ".", "outcome_variable", ")", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "test_significance", "=", "self", ".", "_significance_test", ",", "\n", "evaluate_effect_strength", "=", "self", ".", "_effect_strength_eval", ",", "\n", "confidence_intervals", "=", "self", ".", "_confidence_intervals", ",", "\n", "target_units", "=", "self", ".", "_target_units", ",", "\n", "effect_modifiers", "=", "self", ".", "_effect_modifier_names", ",", "\n", "**", "self", ".", "method_params", ")", ".", "_estimate_effect", "(", ")", "\n", "\n", "# Second Stage", "\n", "modified_target_estimand", "=", "copy", ".", "deepcopy", "(", "self", ".", "_target_estimand", ")", "\n", "modified_target_estimand", ".", "identifier_method", "=", "\"backdoor\"", "\n", "modified_target_estimand", ".", "backdoor_variables", "=", "self", ".", "_target_estimand", ".", "mediation_second_stage_confounders", "\n", "if", "self", ".", "_target_estimand", ".", "identifier_method", "==", "\"frontdoor\"", ":", "\n", "            ", "modified_target_estimand", ".", "treatment_variable", "=", "parse_state", "(", "self", ".", "_frontdoor_variables_names", ")", "\n", "", "elif", "self", ".", "_target_estimand", ".", "identifier_method", "==", "\"mediation\"", ":", "\n", "            ", "modified_target_estimand", ".", "treatment_variable", "=", "parse_state", "(", "self", ".", "_mediators_names", ")", "\n", "\n", "", "second_stage_estimate", "=", "self", ".", "second_stage_model", "(", "self", ".", "_data", ",", "\n", "modified_target_estimand", ",", "\n", "parse_state", "(", "modified_target_estimand", ".", "treatment_variable", ")", ",", "\n", "parse_state", "(", "self", ".", "_outcome_name", ")", ",", "# to convert it to array before passing to causal estimator", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "test_significance", "=", "self", ".", "_significance_test", ",", "\n", "evaluate_effect_strength", "=", "self", ".", "_effect_strength_eval", ",", "\n", "confidence_intervals", "=", "self", ".", "_confidence_intervals", ",", "\n", "target_units", "=", "self", ".", "_target_units", ",", "\n", "effect_modifiers", "=", "self", ".", "_effect_modifier_names", ",", "\n", "**", "self", ".", "method_params", ")", ".", "_estimate_effect", "(", ")", "\n", "# Combining the two estimates", "\n", "natural_indirect_effect", "=", "first_stage_estimate", ".", "value", "*", "second_stage_estimate", ".", "value", "\n", "# This same estimate is valid for frontdoor as well as mediation (NIE)", "\n", "estimate_value", "=", "natural_indirect_effect", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "\n", "first_stage_estimate", ".", "realized_estimand_expr", ",", "\n", "second_stage_estimate", ".", "realized_estimand_expr", ",", "\n", "estimand_type", "=", "CausalIdentifier", ".", "NONPARAMETRIC_NIE", ")", "\n", "if", "self", ".", "_target_estimand", ".", "estimand_type", "==", "CausalIdentifier", ".", "NONPARAMETRIC_NDE", ":", "\n", "# Total  effect of treatment", "\n", "            ", "modified_target_estimand", "=", "copy", ".", "deepcopy", "(", "self", ".", "_target_estimand", ")", "\n", "modified_target_estimand", ".", "identifier_method", "=", "\"backdoor\"", "\n", "\n", "total_effect_estimate", "=", "self", ".", "second_stage_model", "(", "self", ".", "_data", ",", "\n", "modified_target_estimand", ",", "\n", "self", ".", "_treatment_name", ",", "\n", "parse_state", "(", "self", ".", "_outcome_name", ")", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "test_significance", "=", "self", ".", "_significance_test", ",", "\n", "evaluate_effect_strength", "=", "self", ".", "_effect_strength_eval", ",", "\n", "confidence_intervals", "=", "self", ".", "_confidence_intervals", ",", "\n", "target_units", "=", "self", ".", "_target_units", ",", "\n", "effect_modifiers", "=", "self", ".", "_effect_modifier_names", ",", "\n", "**", "self", ".", "method_params", ")", ".", "_estimate_effect", "(", ")", "\n", "natural_direct_effect", "=", "total_effect_estimate", ".", "value", "-", "natural_indirect_effect", "\n", "estimate_value", "=", "natural_direct_effect", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "\n", "first_stage_estimate", ".", "realized_estimand_expr", ",", "\n", "second_stage_estimate", ".", "realized_estimand_expr", ",", "\n", "total_effect_estimate", ".", "realized_estimand_expr", ",", "\n", "estimand_type", "=", "self", ".", "_target_estimand", ".", "estimand_type", ")", "\n", "", "return", "CausalEstimate", "(", "estimate", "=", "estimate_value", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.two_stage_regression_estimator.TwoStageRegressionEstimator.build_first_stage_features": [[178, 208], ["two_stage_regression_estimator.TwoStageRegressionEstimator.logger.debug", "treatment_vals.to_numpy.to_numpy.reshape", "numpy.concatenate.astype", "len", "pandas.get_dummies", "pandas.get_dummies", "type", "treatment_vals.to_numpy.to_numpy.to_numpy", "ValueError", "len", "numpy.concatenate", "range", "str", "len", "numpy.concatenate", "str", "len", "pandas.get_dummies.to_numpy"], "methods", ["None"], ["", "def", "build_first_stage_features", "(", "self", ")", ":", "\n", "        ", "data_df", "=", "self", ".", "_data", "\n", "treatment_vals", "=", "data_df", "[", "self", ".", "_treatment_name", "]", "\n", "if", "len", "(", "self", ".", "_observed_common_causes_names", ")", ">", "0", ":", "\n", "            ", "observed_common_causes_vals", "=", "data_df", "[", "self", ".", "_observed_common_causes_names", "]", "\n", "observed_common_causes_vals", "=", "pd", ".", "get_dummies", "(", "observed_common_causes_vals", ",", "drop_first", "=", "True", ")", "\n", "", "if", "self", ".", "_effect_modifier_names", ":", "\n", "            ", "effect_modifiers_vals", "=", "data_df", "[", "self", ".", "_effect_modifier_names", "]", "\n", "effect_modifiers_vals", "=", "pd", ".", "get_dummies", "(", "effect_modifiers_vals", ",", "drop_first", "=", "True", ")", "\n", "", "if", "type", "(", "treatment_vals", ")", "is", "not", "np", ".", "ndarray", ":", "\n", "            ", "treatment_vals", "=", "treatment_vals", ".", "to_numpy", "(", ")", "\n", "", "if", "treatment_vals", ".", "shape", "[", "0", "]", "!=", "data_df", ".", "shape", "[", "0", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Provided treatment values and dataframe should have the same length.\"", ")", "\n", "# Bulding the feature matrix", "\n", "", "n_samples", "=", "treatment_vals", ".", "shape", "[", "0", "]", "\n", "self", ".", "logger", ".", "debug", "(", "\"Number of samples\"", "+", "str", "(", "n_samples", ")", "+", "str", "(", "len", "(", "self", ".", "_treatment_name", ")", ")", ")", "\n", "treatment_2d", "=", "treatment_vals", ".", "reshape", "(", "(", "n_samples", ",", "len", "(", "self", ".", "_treatment_name", ")", ")", ")", "\n", "if", "len", "(", "self", ".", "_observed_common_causes_names", ")", ">", "0", ":", "\n", "            ", "features", "=", "np", ".", "concatenate", "(", "(", "treatment_2d", ",", "observed_common_causes_vals", ")", ",", "\n", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "treatment_2d", "\n", "", "if", "self", ".", "_effect_modifier_names", ":", "\n", "            ", "for", "i", "in", "range", "(", "treatment_2d", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "curr_treatment", "=", "treatment_2d", "[", ":", ",", "i", "]", "\n", "new_features", "=", "curr_treatment", "[", ":", ",", "np", ".", "newaxis", "]", "*", "effect_modifiers_vals", ".", "to_numpy", "(", ")", "\n", "features", "=", "np", ".", "concatenate", "(", "(", "features", ",", "new_features", ")", ",", "axis", "=", "1", ")", "\n", "", "", "features", "=", "features", ".", "astype", "(", "float", ",", "copy", "=", "False", ")", "# converting to float in case of binary treatment and no other variables", "\n", "#features = sm.add_constant(features, has_constant='add') # to add an intercept term", "\n", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.two_stage_regression_estimator.TwoStageRegressionEstimator.construct_symbolic_estimator": [[209, 216], ["None"], "methods", ["None"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "first_stage_symbolic", ",", "\n", "second_stage_symbolic", ",", "total_effect_symbolic", "=", "None", ",", "estimand_type", "=", "None", ")", ":", "\n", "        ", "nie_symbolic", "=", "\"(\"", "+", "first_stage_symbolic", "+", "\")*(\"", "+", "second_stage_symbolic", "+", "\")\"", "\n", "if", "estimand_type", "==", "CausalIdentifier", ".", "NONPARAMETRIC_NIE", ":", "\n", "            ", "return", "nie_symbolic", "\n", "", "elif", "estimand_type", "==", "CausalIdentifier", ".", "NONPARAMETRIC_NDE", ":", "\n", "            ", "return", "\"(\"", "+", "total_effect_symbolic", "+", "\") - (\"", "+", "nie_symbolic", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.causalml.Causalml.__init__": [[19, 73], ["args_dict.update", "dowhy.causal_estimator.CausalEstimator.__init__", "causalml.Causalml.logger.debug", "causalml.Causalml.logger.debug", "causalml.Causalml._target_estimand.get_backdoor_variables", "causalml.Causalml.logger.debug", "causalml.Causalml.logger.debug", "causalml.Causalml._get_causalml_class_object", "causalml.Causalml.", "causalml.Causalml.logger.info", "causalml.Causalml.construct_symbolic_estimator", "causalml.Causalml.logger.info", "pandas.get_dummies", "pandas.get_dummies", "locals().items", "causalml.Causalml._target_estimand.get_backdoor_variables", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.causalml.Causalml._get_causalml_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "causalml_methodname", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param causalml_methodname: Fully qualified name of causalml estimator\n            class.\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the information", "\n", "# to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "self", ".", "_causalml_methodname", "=", "causalml_methodname", "\n", "# Add the identification method used in the estimator", "\n", "self", ".", "identifier_method", "=", "self", ".", "_target_estimand", ".", "identifier_method", "\n", "self", ".", "logger", ".", "debug", "(", "\"The identifier method used {}\"", ".", "format", "(", "self", ".", "identifier_method", ")", ")", "\n", "\n", "# Check the backdoor variables being used", "\n", "self", ".", "logger", ".", "debug", "(", "\"Back-door variables used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ")", ")", "\n", "\n", "# Add the observed confounders and one hot encode the categorical variables", "\n", "self", ".", "_observed_common_causes_names", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "\n", "if", "self", ".", "_observed_common_causes_names", ":", "\n", "# Get the data of the unobserved confounders", "\n", "            ", "self", ".", "_observed_common_causes", "=", "self", ".", "_data", "[", "self", ".", "_observed_common_causes_names", "]", "\n", "# One hot encode the data if they are categorical", "\n", "self", ".", "_observed_common_causes", "=", "pd", ".", "get_dummies", "(", "self", ".", "_observed_common_causes", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_observed_common_causes", "=", "[", "]", "\n", "\n", "# Check the instrumental variables involved", "\n", "", "self", ".", "logger", ".", "debug", "(", "\"Instrumental variables used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_target_estimand", ".", "instrumental_variables", ")", ")", "\n", "\n", "# Perform the same actions as the above", "\n", "self", ".", "_instrumental_variable_names", "=", "self", ".", "_target_estimand", ".", "instrumental_variables", "\n", "if", "self", ".", "_instrumental_variable_names", ":", "\n", "            ", "self", ".", "_instrumental_variables", "=", "self", ".", "_data", "[", "self", ".", "_instrumental_variable_names", "]", "\n", "self", ".", "_instrumental_variables", "=", "pd", ".", "get_dummies", "(", "self", ".", "_instrumental_variables", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_instrumental_variables", "=", "[", "]", "\n", "\n", "# Check if effect modifiers are used", "\n", "", "self", ".", "logger", ".", "debug", "(", "\"Effect Modifiers used:\"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_effect_modifier_names", ")", ")", "\n", "\n", "\n", "# Get the class corresponding the the estimator to be used", "\n", "estimator_class", "=", "self", ".", "_get_causalml_class_object", "(", "self", ".", "_causalml_methodname", ")", "\n", "# Initialize the object", "\n", "self", ".", "estimator", "=", "estimator_class", "(", "**", "self", ".", "method_params", "[", "\"init_params\"", "]", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"INFO: Using CausalML Estimator\"", ")", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.causalml.Causalml._get_causalml_class_object": [[74, 84], ["module_method_name.rpartition", "importlib.import_module", "getattr", "ImportError"], "methods", ["None"], ["", "def", "_get_causalml_class_object", "(", "self", ",", "module_method_name", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "try", ":", "\n", "            ", "(", "module_name", ",", "_", ",", "class_name", ")", "=", "module_method_name", ".", "rpartition", "(", "\".\"", ")", "\n", "estimator_module", "=", "import_module", "(", "module_name", ")", "\n", "estimator_class", "=", "getattr", "(", "estimator_module", ",", "class_name", ")", "\n", "\n", "", "except", "(", "AttributeError", ",", "AssertionError", ",", "ImportError", ")", ":", "\n", "            ", "raise", "ImportError", "(", "'Error loading {}.{}. Double-check the method name and ensure that all causalml dependencies are installed.'", ".", "format", "(", "module_name", ",", "class_name", ")", ")", "\n", "", "return", "estimator_class", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.causalml.Causalml._estimate_effect": [[85, 124], ["print", "causalml.Causalml.estimator.estimate_ate", "causalml.Causalml.estimator.fit_predict", "dowhy.causal_estimator.CausalEstimate", "inspect.getfullargspec", "inspect.getfullargspec", "func_args.keys", "func_args.keys"], "methods", ["None"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "X_names", "=", "self", ".", "_observed_common_causes_names", "+", "self", ".", "_effect_modifier_names", "\n", "\n", "# Both the outcome and the treatment have to be 1D arrays according to the CausalML API", "\n", "y_name", "=", "self", ".", "_outcome_name", "\n", "treatment_name", "=", "self", ".", "_treatment_name", "[", "0", "]", "# As we have only one treatment variable", "\n", "# We want to pass 'v0' rather than ['v0'] to prevent a shape mismatch", "\n", "\n", "func_args", "=", "{", "\n", "'X'", ":", "self", ".", "_data", "[", "X_names", "]", ",", "\n", "'y'", ":", "self", ".", "_data", "[", "y_name", "]", ",", "\n", "'treatment'", ":", "self", ".", "_data", "[", "treatment_name", "]", "\n", "}", "\n", "\n", "arg_names", "=", "inspect", ".", "getfullargspec", "(", "self", ".", "estimator", ".", "estimate_ate", ")", "[", "0", "]", "\n", "matched_args", "=", "{", "\n", "arg", ":", "func_args", "[", "arg", "]", "for", "arg", "in", "func_args", ".", "keys", "(", ")", "if", "arg", "in", "arg_names", "\n", "}", "\n", "print", "(", "matched_args", ")", "\n", "value_tuple", "=", "self", ".", "estimator", ".", "estimate_ate", "(", "**", "matched_args", ")", "\n", "\n", "# For CATEs", "\n", "arg_names", "=", "inspect", ".", "getfullargspec", "(", "self", ".", "estimator", ".", "fit_predict", ")", "[", "0", "]", "\n", "matched_args", "=", "{", "\n", "arg", ":", "func_args", "[", "arg", "]", "for", "arg", "in", "func_args", ".", "keys", "(", ")", "if", "arg", "in", "arg_names", "\n", "}", "\n", "cate_estimates", "=", "self", ".", "estimator", ".", "fit_predict", "(", "**", "matched_args", ")", "\n", "\n", "estimate", "=", "CausalEstimate", "(", "estimate", "=", "value_tuple", "[", "0", "]", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ",", "\n", "cate_estimates", "=", "cate_estimates", ",", "\n", "effect_intervals", "=", "(", "value_tuple", "[", "1", "]", ",", "value_tuple", "[", "2", "]", ")", ",", "\n", "_estimator_object", "=", "self", ".", "estimator", ")", "\n", "\n", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.causalml.Causalml.construct_symbolic_estimator": [[126, 133], ["estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "expr", "=", "\"b: \"", "+", "\",\"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", "+", "\"~\"", "\n", "# TODO we are conditioning on a postive treatment", "\n", "# TODO create an expression corresponding to each estimator used", "\n", "var_list", "=", "estimand", ".", "treatment_variable", "+", "estimand", ".", "get_backdoor_variables", "(", ")", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_discontinuity_estimator.RegressionDiscontinuityEstimator.__init__": [[21, 46], ["args_dict.update", "dowhy.causal_estimator.CausalEstimator.__init__", "regression_discontinuity_estimator.RegressionDiscontinuityEstimator.logger.info", "regression_discontinuity_estimator.RegressionDiscontinuityEstimator.construct_symbolic_estimator", "regression_discontinuity_estimator.RegressionDiscontinuityEstimator.logger.info", "locals().items", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "rd_variable_name", "=", "None", ",", "\n", "rd_threshold_value", "=", "None", ",", "rd_bandwidth", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param rd_variable_name: Name of the variable on which the\n            discontinuity occurs. This is the instrument.\n        :param rd_threshold_value: Threshold at which the discontinuity occurs.\n        :param rd_bandwidth: Distance from the threshold within which\n            confounders can be considered the same between treatment and\n            control. Considered band is (threshold +- bandwidth)\n\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the information", "\n", "# to create an object of this class", "\n", "args_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "type", "(", "self", ")", ".", "_STD_INIT_ARGS", "}", "\n", "args_dict", ".", "update", "(", "kwargs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "args_dict", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Using Regression Discontinuity Estimator\"", ")", "\n", "self", ".", "rd_variable_name", "=", "rd_variable_name", "\n", "self", ".", "rd_threshold_value", "=", "rd_threshold_value", "\n", "self", ".", "rd_bandwidth", "=", "rd_bandwidth", "\n", "self", ".", "rd_variable", "=", "self", ".", "_data", "[", "self", ".", "rd_variable_name", "]", "\n", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_discontinuity_estimator.RegressionDiscontinuityEstimator._estimate_effect": [[47, 70], ["pandas.DataFrame", "print", "dowhy.causal_estimators.instrumental_variable_estimator.InstrumentalVariableEstimator", "dowhy.causal_estimators.instrumental_variable_estimator.InstrumentalVariableEstimator.estimate_effect"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "upper_limit", "=", "self", ".", "rd_threshold_value", "+", "self", ".", "rd_bandwidth", "\n", "lower_limit", "=", "self", ".", "rd_threshold_value", "-", "self", ".", "rd_bandwidth", "\n", "rows_filter", "=", "np", ".", "s_", "[", "(", "self", ".", "rd_variable", ">=", "lower_limit", ")", "&", "(", "self", ".", "rd_variable", "<=", "upper_limit", ")", "]", "\n", "local_rd_variable", "=", "self", ".", "rd_variable", "[", "rows_filter", "]", "\n", "local_treatment_variable", "=", "self", ".", "_treatment", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "[", "rows_filter", "]", "# indexing by treatment name again since this method assumes a single-dimensional treatment", "\n", "local_outcome_variable", "=", "self", ".", "_outcome", "[", "rows_filter", "]", "\n", "local_df", "=", "pd", ".", "DataFrame", "(", "data", "=", "{", "\n", "'local_rd_variable'", ":", "local_rd_variable", ",", "\n", "'local_treatment'", ":", "local_treatment_variable", ",", "\n", "'local_outcome'", ":", "local_outcome_variable", "\n", "}", ")", "\n", "print", "(", "local_df", ")", "\n", "iv_estimator", "=", "InstrumentalVariableEstimator", "(", "\n", "local_df", ",", "\n", "self", ".", "_target_estimand", ",", "\n", "[", "'local_treatment'", "]", ",", "\n", "[", "'local_outcome'", "]", ",", "\n", "test_significance", "=", "self", ".", "_significance_test", ",", "\n", "iv_instrument_name", "=", "'local_rd_variable'", "\n", ")", "\n", "est", "=", "iv_estimator", ".", "estimate_effect", "(", ")", "\n", "return", "est", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.regression_discontinuity_estimator.RegressionDiscontinuityEstimator.construct_symbolic_estimator": [[71, 73], ["None"], "methods", ["None"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "return", "\"\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.__init__": [[21, 66], ["args_dict.update", "dowhy.causal_estimators.propensity_score_estimator.PropensityScoreEstimator.__init__", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.logger.info", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.logger.info"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator"], ["def", "__init__", "(", "\n", "self", ",", "\n", "*", "args", ",", "\n", "num_strata", "=", "\"auto\"", ",", "\n", "clipping_threshold", "=", "10", ",", "\n", "propensity_score_model", "=", "None", ",", "\n", "recalculate_propensity_score", "=", "True", ",", "\n", "propensity_score_column", "=", "\"propensity_score\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param num_strata: Number of bins by which data will be stratified.\n            Default is automatically determined.\n        :param clipping_threshold: Mininum number of treated or control units\n            per strata. Default=10\n        :param propensity_score_model: The model used to compute propensity\n            score. Can be any classification model that supports fit() and\n            predict_proba() methods. If None, use\n            LogisticRegression model as the default.\n        :param recalculate_propensity_score: If true, force the estimator to\n            estimate the propensity score. To use pre-computed propensity\n            scores, set this value to False. Default=True\n        :param propensity_score_column: Column name that stores the propensity\n        score. Default='propensity_score'\n\n        \"\"\"", "\n", "# Required to ensure that self.method_params contains all the information", "\n", "# to create an object of this class", "\n", "args_dict", "=", "kwargs", "\n", "args_dict", ".", "update", "(", "{", "\n", "'num_strata'", ":", "num_strata", ",", "\n", "'clipping_threshold'", ":", "clipping_threshold", "\n", "}", ")", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "*", "args", ",", "\n", "propensity_score_model", "=", "propensity_score_model", ",", "\n", "recalculate_propensity_score", "=", "recalculate_propensity_score", ",", "\n", "propensity_score_column", "=", "propensity_score_column", ",", "\n", "**", "args_dict", ")", "\n", "\n", "self", ".", "logger", ".", "info", "(", "\"Using Propensity Score Stratification Estimator\"", ")", "\n", "self", ".", "symbolic_estimator", "=", "self", ".", "construct_symbolic_estimator", "(", "self", ".", "_target_estimand", ")", "\n", "self", ".", "logger", ".", "info", "(", "self", ".", "symbolic_estimator", ")", "\n", "# setting method-specific parameters", "\n", "self", ".", "num_strata", "=", "num_strata", "\n", "self", ".", "clipping_threshold", "=", "clipping_threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._estimate_effect": [[68, 147], ["propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.groupby().agg", "weighted_outcomes[].sum", "weighted_outcomes[].sum", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.logger.debug", "dowhy.causal_estimator.CausalEstimate", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.propensity_score_model.fit", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._get_strata", "sklearn.linear_model.LogisticRegression", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.propensity_score_model.predict_proba", "ValueError", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.logger.info", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.logger.info", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.groupby", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.groupby().agg.columns.to_numpy().ravel", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._get_strata", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.groupby().count().reset_index", "ValueError", "int", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.logger.info", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.logger.info", "int", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.groupby().agg.columns.to_numpy", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.groupby().count", "ValueError", "ValueError", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.groupby"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._get_strata", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._get_strata"], ["", "def", "_estimate_effect", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "recalculate_propensity_score", "is", "True", ":", "\n", "            ", "if", "self", ".", "propensity_score_model", "is", "None", ":", "\n", "                ", "self", ".", "propensity_score_model", "=", "linear_model", ".", "LogisticRegression", "(", ")", "\n", "", "self", ".", "propensity_score_model", ".", "fit", "(", "self", ".", "_observed_common_causes", ",", "self", ".", "_treatment", ")", "\n", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", "=", "self", ".", "propensity_score_model", ".", "predict_proba", "(", "self", ".", "_observed_common_causes", ")", "[", ":", ",", "1", "]", "\n", "", "else", ":", "\n", "# check if the user provides the propensity score column", "\n", "            ", "if", "self", ".", "propensity_score_column", "not", "in", "self", ".", "_data", ".", "columns", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Propensity score column {self.propensity_score_column} does not exist. Please specify the column name that has your pre-computed propensity score.\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "logger", ".", "info", "(", "f\"Using pre-computed propensity score incolumn {self.propensity_score_column}\"", ")", "\n", "", "", "clipped", "=", "None", "\n", "# Infer the right strata based on clipping threshold", "\n", "if", "self", ".", "num_strata", "==", "\"auto\"", ":", "\n", "# 0.5 because there are two values for the treatment", "\n", "            ", "clipping_t", "=", "self", ".", "clipping_threshold", "\n", "num_strata", "=", "0.5", "*", "self", ".", "_data", ".", "shape", "[", "0", "]", "/", "clipping_t", "\n", "# To be conservative and allow most strata to be included in the", "\n", "# analysis", "\n", "strata_found", "=", "False", "\n", "while", "not", "strata_found", ":", "\n", "                ", "self", ".", "logger", ".", "info", "(", "\"'num_strata' selected as {}\"", ".", "format", "(", "num_strata", ")", ")", "\n", "try", ":", "\n", "                    ", "clipped", "=", "self", ".", "_get_strata", "(", "num_strata", ",", "self", ".", "clipping_threshold", ")", "\n", "num_ret_strata", "=", "clipped", ".", "groupby", "(", "[", "'strata'", "]", ")", ".", "count", "(", ")", ".", "reset_index", "(", ")", "\n", "# At least 90% of the strata should be included in analysis", "\n", "if", "num_ret_strata", ".", "shape", "[", "0", "]", ">=", "0.5", "*", "num_strata", ":", "\n", "                        ", "strata_found", "=", "True", "\n", "", "else", ":", "\n", "                        ", "num_strata", "=", "int", "(", "num_strata", "/", "2", ")", "\n", "self", ".", "logger", ".", "info", "(", "f\"Less than half the strata have at least {self.clipping_threshold} data points. Selecting fewer number of strata.\"", ")", "\n", "if", "num_strata", "<", "2", ":", "\n", "                            ", "raise", "ValueError", "(", "\"Not enough data to generate at least two strata. This error may be due to a high value of 'clipping_threshold'.\"", ")", "\n", "", "", "", "except", "ValueError", ":", "\n", "                    ", "self", ".", "logger", ".", "info", "(", "\"No strata found with at least {} data points. Selecting fewer number of strata\"", ".", "format", "(", "self", ".", "clipping_threshold", ")", ")", "\n", "num_strata", "=", "int", "(", "num_strata", "/", "2", ")", "\n", "if", "num_strata", "<", "2", ":", "\n", "                        ", "raise", "ValueError", "(", "\"Not enough data to generate at least two strata. This error may be due to a high value of 'clipping_threshold'.\"", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "clipped", "=", "self", ".", "_get_strata", "(", "self", ".", "num_strata", ",", "self", ".", "clipping_threshold", ")", "\n", "\n", "# sum weighted outcomes over all strata  (weight by treated population)", "\n", "", "weighted_outcomes", "=", "clipped", ".", "groupby", "(", "'strata'", ")", ".", "agg", "(", "{", "\n", "self", ".", "_treatment_name", "[", "0", "]", ":", "[", "'sum'", "]", ",", "\n", "'dbar'", ":", "[", "'sum'", "]", ",", "\n", "'d_y'", ":", "[", "'sum'", "]", ",", "\n", "'dbar_y'", ":", "[", "'sum'", "]", "\n", "}", ")", "\n", "weighted_outcomes", ".", "columns", "=", "[", "\"_\"", ".", "join", "(", "x", ")", "for", "x", "in", "weighted_outcomes", ".", "columns", ".", "to_numpy", "(", ")", ".", "ravel", "(", ")", "]", "\n", "treatment_sum_name", "=", "self", ".", "_treatment_name", "[", "0", "]", "+", "\"_sum\"", "\n", "control_sum_name", "=", "\"dbar_sum\"", "\n", "\n", "weighted_outcomes", "[", "'d_y_mean'", "]", "=", "weighted_outcomes", "[", "'d_y_sum'", "]", "/", "weighted_outcomes", "[", "treatment_sum_name", "]", "\n", "weighted_outcomes", "[", "'dbar_y_mean'", "]", "=", "weighted_outcomes", "[", "'dbar_y_sum'", "]", "/", "weighted_outcomes", "[", "'dbar_sum'", "]", "\n", "weighted_outcomes", "[", "'effect'", "]", "=", "weighted_outcomes", "[", "'d_y_mean'", "]", "-", "weighted_outcomes", "[", "'dbar_y_mean'", "]", "\n", "total_treatment_population", "=", "weighted_outcomes", "[", "treatment_sum_name", "]", ".", "sum", "(", ")", "\n", "total_control_population", "=", "weighted_outcomes", "[", "control_sum_name", "]", ".", "sum", "(", ")", "\n", "total_population", "=", "total_treatment_population", "+", "total_control_population", "\n", "self", ".", "logger", ".", "debug", "(", "\"Total number of data points is {0}, including {1} from treatment and {2} from control.\"", ".", "format", "(", "total_population", ",", "total_treatment_population", ",", "total_control_population", ")", ")", "\n", "\n", "if", "self", ".", "_target_units", "==", "\"att\"", ":", "\n", "            ", "est", "=", "(", "weighted_outcomes", "[", "'effect'", "]", "*", "weighted_outcomes", "[", "treatment_sum_name", "]", ")", ".", "sum", "(", ")", "/", "total_treatment_population", "\n", "", "elif", "self", ".", "_target_units", "==", "\"atc\"", ":", "\n", "            ", "est", "=", "(", "weighted_outcomes", "[", "'effect'", "]", "*", "weighted_outcomes", "[", "control_sum_name", "]", ")", ".", "sum", "(", ")", "/", "total_control_population", "\n", "", "elif", "self", ".", "_target_units", "==", "\"ate\"", ":", "\n", "            ", "est", "=", "(", "weighted_outcomes", "[", "'effect'", "]", "*", "(", "weighted_outcomes", "[", "control_sum_name", "]", "+", "weighted_outcomes", "[", "treatment_sum_name", "]", ")", ")", ".", "sum", "(", ")", "/", "total_population", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Target units string value not supported\"", ")", "\n", "\n", "# TODO - how can we add additional information into the returned estimate?", "\n", "#        such as how much clipping was done, or per-strata info for debugging?", "\n", "", "estimate", "=", "CausalEstimate", "(", "estimate", "=", "est", ",", "\n", "control_value", "=", "self", ".", "_control_value", ",", "\n", "treatment_value", "=", "self", ".", "_treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "symbolic_estimator", ",", "\n", "propensity_scores", "=", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ")", "\n", "return", "estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._get_strata": [[148, 170], ["propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._data.groupby", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.filter", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.logger.debug", "ValueError", "[].count", "min", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._data[].rank", "propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.filter.groupby"], "methods", ["None"], ["", "def", "_get_strata", "(", "self", ",", "num_strata", ",", "clipping_threshold", ")", ":", "\n", "# sort the dataframe by propensity score", "\n", "# create a column 'strata' for each element that marks what strata it belongs to", "\n", "        ", "num_rows", "=", "self", ".", "_data", "[", "self", ".", "_outcome_name", "]", ".", "shape", "[", "0", "]", "\n", "self", ".", "_data", "[", "'strata'", "]", "=", "(", "\n", "(", "self", ".", "_data", "[", "self", ".", "propensity_score_column", "]", ".", "rank", "(", "ascending", "=", "True", ")", "/", "num_rows", ")", "*", "num_strata", "\n", ")", ".", "round", "(", "0", ")", "\n", "# for each strata, count how many treated and control units there are", "\n", "# throw away strata that have insufficient treatment or control", "\n", "\n", "self", ".", "_data", "[", "'dbar'", "]", "=", "1", "-", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "# 1-Treatment", "\n", "self", ".", "_data", "[", "'d_y'", "]", "=", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "*", "self", ".", "_data", "[", "self", ".", "_outcome_name", "]", "\n", "self", ".", "_data", "[", "'dbar_y'", "]", "=", "self", ".", "_data", "[", "'dbar'", "]", "*", "self", ".", "_data", "[", "self", ".", "_outcome_name", "]", "\n", "stratified", "=", "self", ".", "_data", ".", "groupby", "(", "'strata'", ")", "\n", "clipped", "=", "stratified", ".", "filter", "(", "\n", "lambda", "strata", ":", "min", "(", "strata", ".", "loc", "[", "strata", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "==", "1", "]", ".", "shape", "[", "0", "]", ",", "\n", "strata", ".", "loc", "[", "strata", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", "==", "0", "]", ".", "shape", "[", "0", "]", ")", ">", "clipping_threshold", "\n", ")", "\n", "self", ".", "logger", ".", "debug", "(", "\"After using clipping_threshold={0}, here are the number of data points in each strata:\\n {1}\"", ".", "format", "(", "clipping_threshold", ",", "clipped", ".", "groupby", "(", "[", "'strata'", ",", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "[", "self", ".", "_outcome_name", "]", ".", "count", "(", ")", ")", ")", "\n", "if", "clipped", ".", "empty", ":", "\n", "            ", "raise", "ValueError", "(", "\"Method requires strata with number of data points per treatment > clipping_threshold (={0}). No such strata exists. Consider decreasing 'num_strata' or 'clipping_threshold' parameters.\"", ".", "format", "(", "clipping_threshold", ")", ")", "\n", "", "return", "clipped", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator": [[171, 177], ["estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "construct_symbolic_estimator", "(", "self", ",", "estimand", ")", ":", "\n", "        ", "expr", "=", "\"b: \"", "+", "\",\"", ".", "join", "(", "estimand", ".", "outcome_variable", ")", "+", "\"~\"", "\n", "# TODO -- fix: we are actually conditioning on positive treatment (d=1)", "\n", "var_list", "=", "estimand", ".", "treatment_variable", "+", "estimand", ".", "get_backdoor_variables", "(", ")", "\n", "expr", "+=", "\"+\"", ".", "join", "(", "var_list", ")", "\n", "return", "expr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_generalized_linear_model_estimator.TestGeneralizedLinearModelEstimator.test_average_treatment_effect": [[9, 35], ["pytest.mark.parametrize", "base.TestEstimator", "base.TestEstimator.average_treatment_effect_testsuite", "statsmodels.families.Binomial"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"Estimator\"", ",", "\n", "\"num_common_causes\"", ",", "\"num_instruments\"", ",", "\n", "\"num_effect_modifiers\"", ",", "\"num_treatments\"", ",", "\n", "\"treatment_is_binary\"", ",", "\"outcome_is_binary\"", ",", "\n", "\"identifier_method\"", "]", ",", "\n", "[", "(", "0.1", ",", "GeneralizedLinearModelEstimator", ",", "[", "0", ",", "]", ",", "[", "0", ",", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "]", ",", "[", "False", ",", "]", ",", "[", "True", ",", "]", ",", "\"backdoor\"", ")", "]", ")", "\n", "def", "test_average_treatment_effect", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "\n", "num_common_causes", ",", "num_instruments", ",", "num_effect_modifiers", ",", "\n", "num_treatments", ",", "treatment_is_binary", ",", "outcome_is_binary", ",", "\n", "identifier_method", "\n", ")", ":", "\n", "        ", "estimator_tester", "=", "TestEstimator", "(", "error_tolerance", ",", "Estimator", ",", "identifier_method", ")", "\n", "estimator_tester", ".", "average_treatment_effect_testsuite", "(", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ",", "\n", "confidence_intervals", "=", "[", "True", ",", "]", ",", "\n", "test_significance", "=", "[", "True", ",", "]", ",", "\n", "method_params", "=", "{", "\n", "'num_simulations'", ":", "10", ",", "\n", "'num_null_simulations'", ":", "10", ",", "\n", "'glm_family'", ":", "sm", ".", "families", ".", "Binomial", "(", ")", ",", "\n", "'predict_score'", ":", "True", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_instrumental_variable_estimator.TestInstrumentalVariableEstimator.test_average_treatment_effect": [[9, 47], ["pytest.mark.parametrize", "base.TestEstimator", "zip", "dict", "print", "pytest.raises", "base.TestEstimator.average_treatment_effect_test", "args_dict.items", "zip", "itertools.product", "base.TestEstimator.average_treatment_effect_test", "pytest.raises", "base.TestEstimator.average_treatment_effect_test"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_test", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_test", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_test"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"Estimator\"", ",", "\n", "\"num_common_causes\"", ",", "\"num_instruments\"", ",", "\n", "\"num_effect_modifiers\"", ",", "\"num_treatments\"", ",", "\n", "\"treatment_is_binary\"", ",", "\"outcome_is_binary\"", ",", "\n", "\"identifier_method\"", "]", ",", "\n", "[", "(", "0.4", ",", "InstrumentalVariableEstimator", ",", "[", "0", ",", "1", "]", ",", "[", "1", ",", "2", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "2", "]", ",", "[", "False", ",", "True", "]", ",", "[", "False", ",", "]", ",", "\"iv\"", ")", ",", "]", ")", "\n", "def", "test_average_treatment_effect", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "\n", "num_common_causes", ",", "num_instruments", ",", "num_effect_modifiers", ",", "\n", "num_treatments", ",", "treatment_is_binary", ",", "outcome_is_binary", ",", "\n", "identifier_method", "\n", ")", ":", "\n", "        ", "estimator_tester", "=", "TestEstimator", "(", "error_tolerance", ",", "Estimator", ",", "\n", "identifier_method", "=", "identifier_method", ")", "\n", "# Not using testsuite from .base/TestEstimtor, custom code below", "\n", "args_dict", "=", "{", "\n", "'num_common_causes'", ":", "num_common_causes", ",", "\n", "'num_instruments'", ":", "num_instruments", ",", "\n", "'num_effect_modifiers'", ":", "num_effect_modifiers", ",", "\n", "'num_treatments'", ":", "num_treatments", ",", "\n", "'treatment_is_binary'", ":", "treatment_is_binary", ",", "\n", "'outcome_is_binary'", ":", "outcome_is_binary", "\n", "}", "\n", "keys", ",", "values", "=", "zip", "(", "*", "args_dict", ".", "items", "(", ")", ")", "\n", "configs", "=", "[", "dict", "(", "zip", "(", "keys", ",", "v", ")", ")", "for", "v", "in", "itertools", ".", "product", "(", "*", "values", ")", "]", "\n", "for", "cfg", "in", "configs", ":", "\n", "            ", "print", "(", "\"\\nConfig:\"", ",", "cfg", ")", "\n", "cfg", "[", "'method_params'", "]", "=", "{", "}", "\n", "if", "cfg", "[", "\"num_instruments\"", "]", ">=", "cfg", "[", "\"num_treatments\"", "]", ":", "\n", "                ", "estimator_tester", ".", "average_treatment_effect_test", "(", "**", "cfg", ")", "\n", "", "else", ":", "\n", "                ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "                    ", "estimator_tester", ".", "average_treatment_effect_test", "(", "**", "cfg", ")", "\n", "\n", "# More cases where Exception  is expected", "\n", "", "", "", "cfg", "=", "configs", "[", "0", "]", "\n", "cfg", "[", "\"num_instruments\"", "]", "=", "0", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "estimator_tester", ".", "average_treatment_effect_test", "(", "**", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.__init__": [[9, 14], ["print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "identifier_method", "=", "\"backdoor\"", ")", ":", "\n", "        ", "print", "(", "\"Error tolerance is\"", ",", "error_tolerance", ")", "\n", "self", ".", "_error_tolerance", "=", "error_tolerance", "\n", "self", ".", "_Estimator", "=", "Estimator", "\n", "self", ".", "_identifier_method", "=", "identifier_method", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_test": [[15, 90], ["dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.identify_effect.set_identifier_method", "base.TestEstimator._Estimator", "base.TestEstimator.estimate_effect", "str", "abs", "print", "dowhy.datasets.linear_dataset", "base.TestEstimator.estimate_effect.get_confidence_intervals", "base.TestEstimator.estimate_effect.get_confidence_intervals", "base.TestEstimator.estimate_effect.get_confidence_intervals", "base.TestEstimator.estimate_effect.get_standard_error", "base.TestEstimator.estimate_effect.get_standard_error", "base.TestEstimator.estimate_effect.test_stat_significance", "base.TestEstimator.estimate_effect.test_stat_significance", "dowhy.datasets.simple_iv_dataset", "ValueError", "abs"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.set_identifier_method", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.get_confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.get_confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.get_confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.get_standard_error", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.get_standard_error", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.test_stat_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimate.test_stat_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.simple_iv_dataset"], ["", "def", "average_treatment_effect_test", "(", "self", ",", "dataset", "=", "\"linear\"", ",", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "1", ",", "num_instruments", "=", "1", ",", "\n", "num_effect_modifiers", "=", "0", ",", "num_treatments", "=", "1", ",", "\n", "num_frontdoor_variables", "=", "0", ",", "\n", "num_samples", "=", "100000", ",", "\n", "treatment_is_binary", "=", "True", ",", "\n", "treatment_is_category", "=", "False", ",", "\n", "outcome_is_binary", "=", "False", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "test_significance", "=", "False", ",", "\n", "method_params", "=", "None", ")", ":", "\n", "        ", "if", "dataset", "==", "\"linear\"", ":", "\n", "            ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "beta", ",", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "num_frontdoor_variables", "=", "num_frontdoor_variables", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "treatment_is_category", "=", "treatment_is_category", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ")", "\n", "", "elif", "dataset", "==", "\"simple-iv\"", ":", "\n", "            ", "data", "=", "dowhy", ".", "datasets", ".", "simple_iv_dataset", "(", "beta", "=", "beta", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Dataset type not supported.\"", ")", "\n", "\n", "", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "test_significance", "\n", ")", "\n", "target_estimand", "=", "model", ".", "identify_effect", "(", ")", "\n", "target_estimand", ".", "set_identifier_method", "(", "self", ".", "_identifier_method", ")", "\n", "estimator_ate", "=", "self", ".", "_Estimator", "(", "\n", "data", "[", "'df'", "]", ",", "\n", "identified_estimand", "=", "target_estimand", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "control_value", "=", "0", ",", "\n", "treatment_value", "=", "1", ",", "\n", "test_significance", "=", "test_significance", ",", "\n", "evaluate_effect_strength", "=", "False", ",", "\n", "confidence_intervals", "=", "confidence_intervals", ",", "\n", "target_units", "=", "\"ate\"", ",", "\n", "effect_modifiers", "=", "data", "[", "\"effect_modifier_names\"", "]", ",", "\n", "**", "method_params", "\n", ")", "\n", "\n", "true_ate", "=", "data", "[", "\"ate\"", "]", "\n", "ate_estimate", "=", "estimator_ate", ".", "estimate_effect", "(", ")", "\n", "str", "(", "ate_estimate", ")", "# checking if str output is correctly created", "\n", "error", "=", "abs", "(", "ate_estimate", ".", "value", "-", "true_ate", ")", "\n", "print", "(", "\"Error in ATE estimate = {0} with tolerance {1}%. Estimated={2},True={3}\"", ".", "format", "(", "\n", "error", ",", "self", ".", "_error_tolerance", "*", "100", ",", "ate_estimate", ".", "value", ",", "true_ate", ")", "\n", ")", "\n", "res", "=", "True", "if", "(", "error", "<", "abs", "(", "true_ate", ")", "*", "self", ".", "_error_tolerance", ")", "else", "False", "\n", "assert", "res", "\n", "# Compute confidence intervals, standard error and significance tests", "\n", "if", "confidence_intervals", ":", "\n", "            ", "ate_estimate", ".", "get_confidence_intervals", "(", ")", "\n", "ate_estimate", ".", "get_confidence_intervals", "(", "confidence_level", "=", "0.99", ")", "\n", "ate_estimate", ".", "get_confidence_intervals", "(", "method", "=", "\"bootstrap\"", ")", "\n", "ate_estimate", ".", "get_standard_error", "(", ")", "\n", "ate_estimate", ".", "get_standard_error", "(", "method", "=", "\"bootstrap\"", ")", "\n", "", "if", "test_significance", ":", "\n", "            ", "ate_estimate", ".", "test_stat_significance", "(", ")", "\n", "ate_estimate", ".", "test_stat_significance", "(", "method", "=", "\"bootstrap\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_testsuite": [[91, 121], ["zip", "dict", "print", "base.TestEstimator.average_treatment_effect_test", "args_dict.items", "zip", "itertools.product"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_test"], ["", "", "def", "average_treatment_effect_testsuite", "(", "self", ",", "tests_to_run", "=", "\"all\"", ",", "\n", "num_common_causes", "=", "[", "2", ",", "3", "]", ",", "num_instruments", "=", "[", "1", ",", "]", ",", "\n", "num_effect_modifiers", "=", "[", "0", ",", "]", ",", "num_treatments", "=", "[", "1", ",", "]", ",", "\n", "num_frontdoor_variables", "=", "[", "0", ",", "]", ",", "\n", "treatment_is_binary", "=", "[", "True", ",", "]", ",", "\n", "treatment_is_category", "=", "[", "False", ",", "]", ",", "\n", "outcome_is_binary", "=", "[", "False", ",", "]", ",", "\n", "confidence_intervals", "=", "[", "False", ",", "]", ",", "\n", "test_significance", "=", "[", "False", ",", "]", ",", "\n", "dataset", "=", "\"linear\"", ",", "\n", "method_params", "=", "None", ")", ":", "\n", "        ", "args_dict", "=", "{", "\n", "'num_common_causes'", ":", "num_common_causes", ",", "\n", "'num_instruments'", ":", "num_instruments", ",", "\n", "'num_effect_modifiers'", ":", "num_effect_modifiers", ",", "\n", "'num_treatments'", ":", "num_treatments", ",", "\n", "'num_frontdoor_variables'", ":", "num_frontdoor_variables", ",", "\n", "'treatment_is_binary'", ":", "treatment_is_binary", ",", "\n", "'treatment_is_category'", ":", "treatment_is_category", ",", "\n", "'outcome_is_binary'", ":", "outcome_is_binary", ",", "\n", "'confidence_intervals'", ":", "confidence_intervals", ",", "\n", "'test_significance'", ":", "test_significance", "\n", "}", "\n", "keys", ",", "values", "=", "zip", "(", "*", "args_dict", ".", "items", "(", ")", ")", "\n", "configs", "=", "[", "dict", "(", "zip", "(", "keys", ",", "v", ")", ")", "for", "v", "in", "itertools", ".", "product", "(", "*", "values", ")", "]", "\n", "for", "cfg", "in", "configs", ":", "\n", "            ", "print", "(", "\"\\nConfig:\"", ",", "cfg", ")", "\n", "cfg", "[", "'dataset'", "]", "=", "dataset", "\n", "cfg", "[", "'method_params'", "]", "=", "method_params", "\n", "self", ".", "average_treatment_effect_test", "(", "**", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.custom_data_average_treatment_effect_test": [[122, 147], ["dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "base.TestEstimator._Estimator", "base.TestEstimator.estimate_effect", "print"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "", "def", "custom_data_average_treatment_effect_test", "(", "self", ",", "data", ")", ":", "\n", "        ", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", "\n", ")", "\n", "target_estimand", "=", "model", ".", "identify_effect", "(", ")", "\n", "estimator_ate", "=", "self", ".", "_Estimator", "(", "\n", "data", "[", "'df'", "]", ",", "\n", "identified_estimand", "=", "target_estimand", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "test_significance", "=", "None", "\n", ")", "\n", "true_ate", "=", "data", "[", "\"ate\"", "]", "\n", "ate_estimate", "=", "estimator_ate", ".", "estimate_effect", "(", ")", "\n", "error", "=", "ate_estimate", ".", "value", "-", "true_ate", "\n", "print", "(", "\"Error in ATE estimate = {0} with tolerance {1}%. Estimated={2},True={3}\"", ".", "format", "(", "\n", "error", ",", "self", ".", "_error_tolerance", "*", "100", ",", "ate_estimate", ".", "value", ",", "true_ate", ")", "\n", ")", "\n", "res", "=", "True", "if", "(", "error", "<", "true_ate", "*", "self", ".", "_error_tolerance", ")", "else", "False", "\n", "assert", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_propensity_score_weighting_estimator.TestPropensityScoreWeightingEstimator.test_average_treatment_effect": [[12, 34], ["pytest.mark.parametrize", "base.TestEstimator", "base.TestEstimator.average_treatment_effect_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"Estimator\"", ",", "\n", "\"num_common_causes\"", ",", "\"num_instruments\"", ",", "\n", "\"num_effect_modifiers\"", ",", "\"num_treatments\"", ",", "\n", "\"treatment_is_binary\"", ",", "\"outcome_is_binary\"", "]", ",", "\n", "[", "(", "0.4", ",", "PropensityScoreWeightingEstimator", ",", "[", "1", ",", "2", "]", ",", "[", "0", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "]", ",", "[", "True", ",", "]", ",", "[", "False", ",", "]", ")", ",", "]", ")", "\n", "def", "test_average_treatment_effect", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "\n", "num_common_causes", ",", "num_instruments", ",", "num_effect_modifiers", ",", "\n", "num_treatments", ",", "treatment_is_binary", ",", "outcome_is_binary", "\n", ")", ":", "\n", "        ", "estimator_tester", "=", "TestEstimator", "(", "error_tolerance", ",", "Estimator", ")", "\n", "estimator_tester", ".", "average_treatment_effect_testsuite", "(", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ",", "\n", "confidence_intervals", "=", "[", "True", ",", "]", ",", "\n", "test_significance", "=", "[", "True", ",", "]", ",", "\n", "method_params", "=", "{", "\n", "'num_simulations'", ":", "1", ",", "\n", "'num_null_simulations'", ":", "1", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_propensity_score_stratification_estimator.TestPropensityScoreStratificationEstimator.test_average_treatment_effect": [[8, 30], ["pytest.mark.parametrize", "base.TestEstimator", "base.TestEstimator.average_treatment_effect_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"Estimator\"", ",", "\n", "\"num_common_causes\"", ",", "\"num_instruments\"", ",", "\n", "\"num_effect_modifiers\"", ",", "\"num_treatments\"", ",", "\n", "\"treatment_is_binary\"", ",", "\"outcome_is_binary\"", "]", ",", "\n", "[", "(", "0.1", ",", "PropensityScoreStratificationEstimator", ",", "[", "1", ",", "2", "]", ",", "[", "0", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "]", ",", "[", "True", ",", "]", ",", "[", "False", ",", "]", ")", ",", "]", ")", "\n", "def", "test_average_treatment_effect", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "\n", "num_common_causes", ",", "num_instruments", ",", "num_effect_modifiers", ",", "\n", "num_treatments", ",", "treatment_is_binary", ",", "outcome_is_binary", "\n", ")", ":", "\n", "        ", "estimator_tester", "=", "TestEstimator", "(", "error_tolerance", ",", "Estimator", ")", "\n", "estimator_tester", ".", "average_treatment_effect_testsuite", "(", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ",", "\n", "confidence_intervals", "=", "[", "True", ",", "]", ",", "\n", "test_significance", "=", "[", "True", ",", "]", ",", "\n", "method_params", "=", "{", "\n", "'num_simulations'", ":", "10", ",", "\n", "'num_null_simulations'", ":", "10", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_two_stage_regression_estimator.TestTwoStageRegressionEstimator.test_average_treatment_effect": [[8, 33], ["pytest.mark.parametrize", "base.TestEstimator", "base.TestEstimator.average_treatment_effect_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"Estimator\"", ",", "\n", "\"num_common_causes\"", ",", "\"num_instruments\"", ",", "\n", "\"num_effect_modifiers\"", ",", "\"num_treatments\"", ",", "\n", "\"num_frontdoor_variables\"", ",", "\n", "\"treatment_is_binary\"", ",", "\"outcome_is_binary\"", "]", ",", "\n", "[", "(", "0.1", ",", "TwoStageRegressionEstimator", ",", "[", "0", "]", ",", "[", "0", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "]", ",", "[", "1", ",", "]", ",", "[", "False", "]", ",", "[", "False", ",", "]", ")", ",", "]", ")", "\n", "def", "test_average_treatment_effect", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "\n", "num_common_causes", ",", "num_instruments", ",", "num_effect_modifiers", ",", "\n", "num_treatments", ",", "num_frontdoor_variables", ",", "treatment_is_binary", ",", "outcome_is_binary", "\n", ")", ":", "\n", "        ", "estimator_tester", "=", "TestEstimator", "(", "error_tolerance", ",", "Estimator", ",", "\n", "identifier_method", "=", "\"frontdoor\"", ")", "\n", "estimator_tester", ".", "average_treatment_effect_testsuite", "(", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "num_frontdoor_variables", "=", "num_frontdoor_variables", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ",", "\n", "confidence_intervals", "=", "[", "True", ",", "]", ",", "\n", "test_significance", "=", "[", "False", ",", "]", ",", "\n", "method_params", "=", "{", "\n", "'num_simulations'", ":", "10", ",", "\n", "'num_null_simulations'", ":", "10", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_econml_estimator.TestEconMLEstimator.test_backdoor_estimators": [[22, 84], ["dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "dowhy.CausalModel.estimate_effect", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "sklearn.ensemble.GradientBoostingRegressor", "sklearn.ensemble.GradientBoostingRegressor", "sklearn.preprocessing.PolynomialFeatures", "sklearn.linear_model.LogisticRegressionCV"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["def", "test_backdoor_estimators", "(", "self", ")", ":", "\n", "# Setup data", "\n", "        ", "data", "=", "datasets", ".", "linear_dataset", "(", "\n", "10", ",", "num_common_causes", "=", "4", ",", "num_samples", "=", "10000", ",", "\n", "num_instruments", "=", "2", ",", "num_effect_modifiers", "=", "2", ",", "\n", "num_treatments", "=", "1", ",", "\n", "treatment_is_binary", "=", "False", ")", "\n", "df", "=", "data", "[", "'df'", "]", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "\"df\"", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "\"effect_modifier_names\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", "\n", ")", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "# Test LinearDML", "\n", "dml_estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"backdoor.econml.dml.LinearDML\"", ",", "\n", "control_value", "=", "0", ",", "\n", "treatment_value", "=", "1", ",", "\n", "target_units", "=", "lambda", "df", ":", "df", "[", "\"X0\"", "]", ">", "1", ",", "# condition used for CATE", "\n", "method_params", "=", "{", "\"init_params\"", ":", "{", "\n", "'model_y'", ":", "GradientBoostingRegressor", "(", ")", ",", "\n", "'model_t'", ":", "GradientBoostingRegressor", "(", ")", ",", "\n", "'featurizer'", ":", "PolynomialFeatures", "(", "degree", "=", "1", ",", "include_bias", "=", "True", ")", "}", ",", "\n", "\"fit_params\"", ":", "{", "}", "\n", "}", "\n", ")", "\n", "# Test ContinuousTreatmentOrthoForest", "\n", "orthoforest_estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"backdoor.econml.ortho_forest.ContinuousTreatmentOrthoForest\"", ",", "\n", "target_units", "=", "lambda", "df", ":", "df", "[", "\"X0\"", "]", ">", "2", ",", "\n", "method_params", "=", "{", "\n", "\"init_params\"", ":", "{", "'n_trees'", ":", "10", "}", ",", "\n", "\"fit_params\"", ":", "{", "}", "\n", "}", "\n", ")", "\n", "# Test LinearDRLearner", "\n", "data_binary", "=", "datasets", ".", "linear_dataset", "(", "\n", "10", ",", "num_common_causes", "=", "4", ",", "num_samples", "=", "10000", ",", "\n", "num_instruments", "=", "2", ",", "num_effect_modifiers", "=", "2", ",", "\n", "treatment_is_binary", "=", "True", ",", "outcome_is_binary", "=", "True", ")", "\n", "model_binary", "=", "CausalModel", "(", "\n", "data", "=", "data_binary", "[", "\"df\"", "]", ",", "\n", "treatment", "=", "data_binary", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data_binary", "[", "\"outcome_name\"", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "\"effect_modifier_names\"", "]", ",", "\n", "graph", "=", "data_binary", "[", "\"gml_graph\"", "]", ")", "\n", "identified_estimand_binary", "=", "model_binary", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "drlearner_estimate", "=", "model_binary", ".", "estimate_effect", "(", "\n", "identified_estimand_binary", ",", "\n", "method_name", "=", "\"backdoor.econml.drlearner.LinearDRLearner\"", ",", "\n", "target_units", "=", "lambda", "df", ":", "df", "[", "\"X0\"", "]", ">", "1", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "method_params", "=", "{", "\n", "\"init_params\"", ":", "{", "'model_propensity'", ":", "LogisticRegressionCV", "(", "cv", "=", "3", ",", "solver", "=", "'lbfgs'", ",", "multi_class", "=", "'auto'", ")", "}", ",", "\n", "\"fit_params\"", ":", "{", "}", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_econml_estimator.TestEconMLEstimator.test_iv_estimators": [[86, 171], ["pytest.importorskip", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "pytest.importorskip.Sequential", "pytest.importorskip.Sequential", "dowhy.CausalModel.estimate_effect", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "len", "len", "len", "len", "pytest.importorskip.layers.Dense", "pytest.importorskip.layers.Dropout", "pytest.importorskip.layers.Dense", "pytest.importorskip.layers.Dropout", "pytest.importorskip.layers.Dense", "pytest.importorskip.layers.Dropout", "pytest.importorskip.layers.Dense", "pytest.importorskip.layers.Dropout", "pytest.importorskip.layers.Dense", "pytest.importorskip.layers.Dropout", "pytest.importorskip.layers.Dense", "pytest.importorskip.layers.Dropout", "pytest.importorskip.layers.Dense", "sklearn.ensemble.GradientBoostingClassifier", "sklearn.ensemble.GradientBoostingRegressor", "sklearn.ensemble.GradientBoostingRegressor", "sklearn.preprocessing.PolynomialFeatures", "pytest.importorskip.Sequential.", "pytest.importorskip.Sequential.", "pytest.importorskip.layers.concatenate", "pytest.importorskip.layers.concatenate"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "def", "test_iv_estimators", "(", "self", ")", ":", "\n", "        ", "keras", "=", "pytest", ".", "importorskip", "(", "\"keras\"", ")", "\n", "# Setup data", "\n", "data", "=", "datasets", ".", "linear_dataset", "(", "\n", "10", ",", "num_common_causes", "=", "4", ",", "num_samples", "=", "10000", ",", "\n", "num_instruments", "=", "2", ",", "num_effect_modifiers", "=", "2", ",", "\n", "num_treatments", "=", "1", ",", "\n", "treatment_is_binary", "=", "False", ")", "\n", "df", "=", "data", "[", "'df'", "]", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "\"df\"", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "\"effect_modifier_names\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "identify_vars", "=", "True", "\n", ")", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "# Test DeepIV", "\n", "dims_zx", "=", "len", "(", "model", ".", "_instruments", ")", "+", "len", "(", "model", ".", "_effect_modifiers", ")", "\n", "dims_tx", "=", "len", "(", "model", ".", "_treatment", ")", "+", "len", "(", "model", ".", "_effect_modifiers", ")", "\n", "treatment_model", "=", "keras", ".", "Sequential", "(", "[", "keras", ".", "layers", ".", "Dense", "(", "128", ",", "activation", "=", "'relu'", ",", "input_shape", "=", "(", "dims_zx", ",", ")", ")", ",", "# sum of dims of Z and X", "\n", "keras", ".", "layers", ".", "Dropout", "(", "0.17", ")", ",", "\n", "keras", ".", "layers", ".", "Dense", "(", "\n", "64", ",", "activation", "=", "'relu'", ")", ",", "\n", "keras", ".", "layers", ".", "Dropout", "(", "0.17", ")", ",", "\n", "keras", ".", "layers", ".", "Dense", "(", "\n", "32", ",", "activation", "=", "'relu'", ")", ",", "\n", "keras", ".", "layers", ".", "Dropout", "(", "0.17", ")", "]", ")", "\n", "response_model", "=", "keras", ".", "Sequential", "(", "[", "\n", "keras", ".", "layers", ".", "Dense", "(", "128", ",", "activation", "=", "'relu'", ",", "input_shape", "=", "(", "\n", "dims_tx", ",", ")", ")", ",", "# sum of dims of T and X", "\n", "keras", ".", "layers", ".", "Dropout", "(", "0.17", ")", ",", "\n", "keras", ".", "layers", ".", "Dense", "(", "64", ",", "activation", "=", "'relu'", ")", ",", "\n", "keras", ".", "layers", ".", "Dropout", "(", "0.17", ")", ",", "\n", "keras", ".", "layers", ".", "Dense", "(", "32", ",", "activation", "=", "'relu'", ")", ",", "\n", "keras", ".", "layers", ".", "Dropout", "(", "0.17", ")", ",", "\n", "keras", ".", "layers", ".", "Dense", "(", "1", ")", "]", ")", "\n", "deepiv_estimate", "=", "model", ".", "estimate_effect", "(", "identified_estimand", ",", "\n", "method_name", "=", "\"iv.econml.deepiv.DeepIVEstimator\"", ",", "\n", "target_units", "=", "lambda", "df", ":", "df", "[", "\"X0\"", "]", ">", "-", "1", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "method_params", "=", "{", "\n", "\"init_params\"", ":", "{", "'n_components'", ":", "10", ",", "# Number of gaussians in the mixture density networks", "\n", "# Treatment model,", "\n", "'m'", ":", "lambda", "z", ",", "x", ":", "treatment_model", "(", "keras", ".", "layers", ".", "concatenate", "(", "[", "z", ",", "x", "]", ")", ")", ",", "\n", "# Response model", "\n", "\"h\"", ":", "lambda", "t", ",", "x", ":", "response_model", "(", "keras", ".", "layers", ".", "concatenate", "(", "[", "t", ",", "x", "]", ")", ")", ",", "\n", "'n_samples'", ":", "1", ",", "# Number of samples used to estimate the response", "\n", "'first_stage_options'", ":", "{", "'epochs'", ":", "25", "}", ",", "\n", "'second_stage_options'", ":", "{", "'epochs'", ":", "25", "}", "\n", "}", ",", "\n", "\"fit_params\"", ":", "{", "}", "\n", "}", "\n", ")", "\n", "# Test IntentToTreatDRIV", "\n", "data", "=", "datasets", ".", "linear_dataset", "(", "\n", "10", ",", "num_common_causes", "=", "4", ",", "num_samples", "=", "10000", ",", "\n", "num_instruments", "=", "1", ",", "num_effect_modifiers", "=", "2", ",", "\n", "num_treatments", "=", "1", ",", "\n", "treatment_is_binary", "=", "True", ",", "\n", "num_discrete_instruments", "=", "1", ")", "\n", "df", "=", "data", "[", "'df'", "]", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "\"df\"", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "\"effect_modifier_names\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", "\n", ")", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "driv_estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"iv.econml.ortho_iv.LinearIntentToTreatDRIV\"", ",", "\n", "target_units", "=", "lambda", "df", ":", "df", "[", "\"X0\"", "]", ">", "1", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "method_params", "=", "{", "\n", "\"init_params\"", ":", "{", "'model_t_xwz'", ":", "GradientBoostingClassifier", "(", ")", ",", "\n", "'model_y_xw'", ":", "GradientBoostingRegressor", "(", ")", ",", "\n", "'flexible_model_effect'", ":", "GradientBoostingRegressor", "(", ")", ",", "\n", "'featurizer'", ":", "PolynomialFeatures", "(", "degree", "=", "1", ",", "include_bias", "=", "False", ")", "\n", "}", ",", "\n", "\"fit_params\"", ":", "{", "}", "}", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_regression_discontinuity_estimator.TestRegressionDiscontinuityEstimator.test_average_treatment_effect": [[8, 31], ["pytest.mark.parametrize", "base.TestEstimator", "base.TestEstimator.average_treatment_effect_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"Estimator\"", ",", "\n", "\"num_common_causes\"", ",", "\"num_instruments\"", ",", "\n", "\"num_effect_modifiers\"", ",", "\"num_treatments\"", ",", "\n", "\"treatment_is_binary\"", ",", "\"outcome_is_binary\"", ",", "\"identifier_method\"", "]", ",", "\n", "[", "(", "0.2", ",", "RegressionDiscontinuityEstimator", ",", "[", "1", "]", ",", "[", "1", ",", "]", ",", "[", "0", "]", ",", "[", "1", ",", "]", ",", "[", "True", ",", "]", ",", "[", "False", ",", "]", ",", "\"iv\"", ")", ",", "]", ")", "\n", "def", "test_average_treatment_effect", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "\n", "num_common_causes", ",", "num_instruments", ",", "num_effect_modifiers", ",", "\n", "num_treatments", ",", "treatment_is_binary", ",", "outcome_is_binary", ",", "\n", "identifier_method", "\n", ")", ":", "\n", "        ", "estimator_tester", "=", "TestEstimator", "(", "error_tolerance", ",", "Estimator", ",", "\n", "identifier_method", "=", "identifier_method", ")", "\n", "estimator_tester", ".", "average_treatment_effect_testsuite", "(", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ",", "\n", "dataset", "=", "\"simple-iv\"", ",", "\n", "method_params", "=", "{", "'rd_variable_name'", ":", "'Z0'", ",", "\n", "'rd_threshold_value'", ":", "0.5", ",", "\n", "'rd_bandwidth'", ":", "0.2", "}", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_causalml_estimator.TestCausalmlEstimator.test_causalml_LRSRegressor": [[32, 58], ["dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "print", "print"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["def", "test_causalml_LRSRegressor", "(", "self", ",", "init_data", ")", ":", "\n", "# Defined a linear dataset with a given set of properties", "\n", "        ", "data", "=", "init_data", "\n", "\n", "# Create a model that captures the same", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "'treatment_name'", "]", ",", "\n", "outcome", "=", "data", "[", "'outcome_name'", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "'effect_modifier_names'", "]", ",", "\n", "graph", "=", "data", "[", "'gml_graph'", "]", "\n", ")", "\n", "\n", "# Identify the effects within the model", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", "\n", ")", "\n", "\n", "lr_estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"backdoor.causalml.inference.meta.LRSRegressor\"", ",", "\n", "method_params", "=", "{", "\"init_params\"", ":", "{", "}", "}", "\n", ")", "\n", "\n", "print", "(", "\"The LR estimate obtained:\"", ")", "\n", "print", "(", "lr_estimate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_causalml_estimator.TestCausalmlEstimator.test_causalml_XGBTRegressor": [[59, 85], ["dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "print", "print"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "def", "test_causalml_XGBTRegressor", "(", "self", ",", "init_data", ")", ":", "\n", "# Defined a linear dataset with a given set of properties", "\n", "        ", "data", "=", "init_data", "\n", "\n", "# Create a model that captures the same", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "'treatment_name'", "]", ",", "\n", "outcome", "=", "data", "[", "'outcome_name'", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "'effect_modifier_names'", "]", ",", "\n", "graph", "=", "data", "[", "'gml_graph'", "]", "\n", ")", "\n", "\n", "# Identify the effects within the model", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", "\n", ")", "\n", "\n", "xgbt_estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"backdoor.causalml.inference.meta.XGBTRegressor\"", ",", "\n", "method_params", "=", "{", "\"init_params\"", ":", "{", "}", "}", "\n", ")", "\n", "\n", "print", "(", "\"The XGBT estimate obtained:\"", ")", "\n", "print", "(", "xgbt_estimate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_causalml_estimator.TestCausalmlEstimator.test_causalml_MLPTRegressor": [[86, 117], ["dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "print", "print"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "def", "test_causalml_MLPTRegressor", "(", "self", ",", "init_data", ")", ":", "\n", "# Defined a linear dataset with a given set of properties", "\n", "        ", "data", "=", "init_data", "\n", "\n", "# Create a model that captures the same", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "'treatment_name'", "]", ",", "\n", "outcome", "=", "data", "[", "'outcome_name'", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "'effect_modifier_names'", "]", ",", "\n", "graph", "=", "data", "[", "'gml_graph'", "]", "\n", ")", "\n", "\n", "# Identify the effects within the model", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", "\n", ")", "\n", "\n", "mlpt_estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"backdoor.causalml.inference.meta.MLPTRegressor\"", ",", "\n", "method_params", "=", "{", "\"init_params\"", ":", "{", "\n", "'hidden_layer_sizes'", ":", "(", "10", ",", "10", ")", ",", "\n", "'learning_rate_init'", ":", "0.1", ",", "\n", "'early_stopping'", ":", "True", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "print", "(", "\"The MLPT estimate obtained:\"", ")", "\n", "print", "(", "mlpt_estimate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_causalml_estimator.TestCausalmlEstimator.test_causalml_XLearner": [[118, 147], ["dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "print", "print", "xgboost.XGBRegressor"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "def", "test_causalml_XLearner", "(", "self", ",", "init_data", ")", ":", "\n", "# Defined a linear dataset with a given set of properties", "\n", "        ", "data", "=", "init_data", "\n", "\n", "# Create a model that captures the same", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "'treatment_name'", "]", ",", "\n", "outcome", "=", "data", "[", "'outcome_name'", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "'effect_modifier_names'", "]", ",", "\n", "graph", "=", "data", "[", "'gml_graph'", "]", "\n", ")", "\n", "\n", "# Identify the effects within the model", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", "\n", ")", "\n", "\n", "xl_estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"backdoor.causalml.inference.meta.BaseXRegressor\"", ",", "\n", "method_params", "=", "{", "\"init_params\"", ":", "{", "\n", "'learner'", ":", "XGBRegressor", "(", ")", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "print", "(", "\"The X Learner estimate obtained:\"", ")", "\n", "print", "(", "xl_estimate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_causalml_estimator.TestCausalmlEstimator.test_causalml_RLearner": [[148, 182], ["dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "print", "print", "dowhy.CausalModel.estimate_effect", "print", "xgboost.XGBRegressor"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "def", "test_causalml_RLearner", "(", "self", ",", "init_data", ")", ":", "\n", "# Defined a linear dataset with a given set of properties", "\n", "        ", "data", "=", "init_data", "\n", "\n", "# Create a model that captures the same", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "'treatment_name'", "]", ",", "\n", "outcome", "=", "data", "[", "'outcome_name'", "]", ",", "\n", "effect_modifiers", "=", "data", "[", "'effect_modifier_names'", "]", ",", "\n", "graph", "=", "data", "[", "'gml_graph'", "]", "\n", ")", "\n", "\n", "# Identify the effects within the model", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "\n", "proceed_when_unidentifiable", "=", "True", "\n", ")", "\n", "\n", "rl_estimate", "=", "None", "\n", "\n", "try", ":", "\n", "            ", "rl_estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"backdoor.causalml.inference.meta.BaseRRegressor\"", ",", "\n", "method_params", "=", "{", "\"init_params\"", ":", "{", "\n", "'learner'", ":", "XGBRegressor", "(", ")", "\n", "}", "\n", "}", "\n", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "print", "(", "\"Error with respect to the number of samples\"", ")", "\n", "\n", "", "print", "(", "\"The R Learner estimate obtained:\"", ")", "\n", "print", "(", "rl_estimate", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_causalml_estimator.init_data": [[12, 25], ["dowhy.datasets.linear_dataset"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset"], ["@", "pytest", ".", "fixture", "\n", "def", "init_data", "(", ")", ":", "\n", "    ", "data", "=", "linear_dataset", "(", "\n", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "4", ",", "\n", "num_instruments", "=", "2", ",", "\n", "num_effect_modifiers", "=", "2", ",", "\n", "num_treatments", "=", "1", ",", "\n", "num_samples", "=", "1000", ",", "\n", "treatment_is_binary", "=", "True", "\n", ")", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_linear_regression_estimator.TestLinearRegressionEstimator.test_average_treatment_effect": [[8, 42], ["pytest.mark.parametrize", "base.TestEstimator", "base.TestEstimator.average_treatment_effect_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "[", "\n", "\"error_tolerance\"", ",", "\"Estimator\"", ",", "\"num_common_causes\"", ",", "\"num_instruments\"", ",", "\n", "\"num_effect_modifiers\"", ",", "\"num_treatments\"", ",", "\"treatment_is_binary\"", ",", "\n", "\"treatment_is_category\"", ",", "\"outcome_is_binary\"", "\n", "]", ",", "\n", "[", "\n", "(", "0.1", ",", "LinearRegressionEstimator", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "2", "]", ",", "\n", "[", "True", ",", "]", ",", "[", "False", ",", "]", ",", "[", "False", ",", "]", ")", ",", "\n", "(", "0.1", ",", "LinearRegressionEstimator", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "2", "]", ",", "\n", "[", "False", ",", "]", ",", "[", "True", ",", "]", ",", "[", "False", ",", "]", ")", ",", "\n", "(", "0.1", ",", "LinearRegressionEstimator", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "2", "]", ",", "\n", "[", "False", ",", "]", ",", "[", "False", ",", "]", ",", "[", "False", ",", "]", ")", ",", "\n", "]", "\n", ")", "\n", "def", "test_average_treatment_effect", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "\n", "num_common_causes", ",", "num_instruments", ",", "num_effect_modifiers", ",", "\n", "num_treatments", ",", "treatment_is_binary", ",", "treatment_is_category", ",", "\n", "outcome_is_binary", "\n", ")", ":", "\n", "        ", "estimator_tester", "=", "TestEstimator", "(", "error_tolerance", ",", "Estimator", ")", "\n", "estimator_tester", ".", "average_treatment_effect_testsuite", "(", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "treatment_is_category", "=", "treatment_is_category", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ",", "\n", "confidence_intervals", "=", "[", "True", ",", "]", ",", "\n", "test_significance", "=", "[", "True", ",", "]", ",", "\n", "method_params", "=", "{", "\n", "'num_simulations'", ":", "10", ",", "\n", "'num_null_simulations'", ":", "10", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.test_propensity_score_matching_estimator.TestPropensityScoreMatchingEstimator.test_average_treatment_effect": [[8, 30], ["pytest.mark.parametrize", "base.TestEstimator", "base.TestEstimator.average_treatment_effect_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.base.TestEstimator.average_treatment_effect_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"Estimator\"", ",", "\n", "\"num_common_causes\"", ",", "\"num_instruments\"", ",", "\n", "\"num_effect_modifiers\"", ",", "\"num_treatments\"", ",", "\n", "\"treatment_is_binary\"", ",", "\"outcome_is_binary\"", "]", ",", "\n", "[", "(", "0.3", ",", "PropensityScoreMatchingEstimator", ",", "[", "1", ",", "2", "]", ",", "[", "0", "]", ",", "[", "0", ",", "]", ",", "[", "1", ",", "]", ",", "[", "True", ",", "]", ",", "[", "False", ",", "]", ")", ",", "]", ")", "\n", "def", "test_average_treatment_effect", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "\n", "num_common_causes", ",", "num_instruments", ",", "num_effect_modifiers", ",", "\n", "num_treatments", ",", "treatment_is_binary", ",", "outcome_is_binary", "\n", ")", ":", "\n", "        ", "estimator_tester", "=", "TestEstimator", "(", "error_tolerance", ",", "Estimator", ")", "\n", "estimator_tester", ".", "average_treatment_effect_testsuite", "(", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ",", "\n", "confidence_intervals", "=", "[", "False", ",", "]", ",", "\n", "test_significance", "=", "[", "False", ",", "]", ",", "\n", "method_params", "=", "{", "\n", "'num_simulations'", ":", "10", ",", "\n", "'num_null_simulations'", ":", "10", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cli_helpers.query_yes_no": [[1, 34], ["input().lower", "print", "input"], "function", ["None"], ["def", "query_yes_no", "(", "question", ",", "default", "=", "True", ")", ":", "\n", "    ", "\"\"\"Ask a yes/no question via standard input and return the answer.\n\n    Source: https://stackoverflow.com/questions/3041986/apt-command-line-interface-like-yes-no-input\n\n    If invalid input is given, the user will be asked until they actually give valid input.\n\n    Side Effects: Blocks program execution until valid input(y/n) is given.\n\n    :param question(str):  A question that is presented to the user.\n    :param default(bool|None): The default value when enter is pressed with no value.\n        When None, there is no default value and the query will loop.\n    :returns: A bool indicating whether user has entered yes or no.\n    \"\"\"", "\n", "yes_list", "=", "[", "\"yes\"", ",", "\"y\"", "]", "\n", "no_list", "=", "[", "\"no\"", ",", "\"n\"", "]", "\n", "default_dict", "=", "{", "# default => prompt default string", "\n", "None", ":", "\"[y/n]\"", ",", "\n", "True", ":", "\"[Y/n]\"", ",", "\n", "False", ":", "\"[y/N]\"", "\n", "}", "\n", "default_str", "=", "default_dict", "[", "default", "]", "\n", "prompt_str", "=", "\"%s %s \"", "%", "(", "question", ",", "default_str", ")", "\n", "while", "True", ":", "\n", "        ", "choice", "=", "input", "(", "prompt_str", ")", ".", "lower", "(", ")", "\n", "if", "not", "choice", "and", "default", "is", "not", "None", ":", "\n", "            ", "return", "default", "\n", "", "if", "choice", "in", "yes_list", ":", "\n", "            ", "return", "True", "\n", "", "if", "choice", "in", "no_list", ":", "\n", "            ", "return", "False", "\n", "", "notification_str", "=", "\"Please respond with 'y' or 'n'\"", "\n", "print", "(", "notification_str", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.__init__": [[6, 29], ["kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "numpy.random.seed", "kwargs.pop", "ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''\n        Base class for implementation of data generating process. \n\n        Subclasses implement functions that create various data generating processes. All data generating processes are in the package \"dowhy.utils.dgps\". \n        '''", "\n", "self", ".", "treatment", "=", "kwargs", "[", "'treatment'", "]", "\n", "self", ".", "outcome", "=", "kwargs", "[", "'outcome'", "]", "\n", "self", ".", "confounder", "=", "kwargs", "[", "'confounder'", "]", "\n", "self", ".", "effect_modifier", "=", "kwargs", "[", "'effect_modifier'", "]", "\n", "self", ".", "weights", "=", "kwargs", ".", "pop", "(", "'weights'", ",", "{", "}", ")", "\n", "self", ".", "bias", "=", "kwargs", ".", "pop", "(", "'bias'", ",", "{", "}", ")", "\n", "self", ".", "seed", "=", "kwargs", ".", "pop", "(", "'seed'", ",", "None", ")", "\n", "self", ".", "treatment_is_binary", "=", "kwargs", ".", "pop", "(", "'treatment_is_binary'", ",", "False", ")", "\n", "if", "self", ".", "treatment_is_binary", ":", "\n", "            ", "self", ".", "percentile", "=", "kwargs", ".", "pop", "(", "'percentile'", ",", "DataGeneratingProcess", ".", "DEFAULT_PERCENTILE", ")", "\n", "", "elif", "kwargs", ".", "pop", "(", "'percentile'", ",", "None", ")", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot use percentile, if the input is non-binary'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "percentile", "=", "\"NA\"", "\n", "", "self", ".", "true_value", "=", "None", "\n", "if", "self", ".", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.generate_data": [[31, 33], ["NotImplementedError"], "methods", ["None"], ["", "", "def", "generate_data", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.generation_process": [[34, 36], ["NotImplementedError"], "methods", ["None"], ["", "def", "generation_process", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.convert_to_binary": [[37, 59], ["numpy.random.binomial.astype", "numpy.percentile", "data.argsort", "numpy.empty_like", "numpy.arange", "numpy.random.binomial", "numpy.random.binomial", "numpy.random.binomial", "len", "len"], "methods", ["None"], ["", "def", "convert_to_binary", "(", "self", ",", "data", ",", "deterministic", "=", "False", ")", ":", "\n", "        ", "if", "deterministic", ":", "\n", "            ", "precentile", "=", "np", ".", "percentile", "(", "data", ",", "self", ".", "percentile", ",", "axis", "=", "0", ")", "\n", "binary_treat_value", "=", "data", "<=", "precentile", "\n", "", "else", ":", "\n", "            ", "temp", "=", "data", ".", "argsort", "(", "axis", "=", "0", ")", "\n", "ranks", "=", "np", ".", "empty_like", "(", "temp", ")", "\n", "ranks", "[", "temp", "[", ":", ",", "0", "]", ",", "0", "]", "=", "np", ".", "arange", "(", "data", ".", "shape", "[", "0", "]", ")", "\n", "prob_t", "=", "ranks", "/", "data", ".", "shape", "[", "0", "]", "\n", "# Generating data with equal 0 and 1 (since ranks are uniformly distributed)", "\n", "binary_treat_value", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "prob_t", "[", ":", ",", "0", "]", ",", "data", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# Flipping some values", "\n", "if", "self", ".", "percentile", ">=", "0.5", ":", "\n", "                ", "mask", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "(", "1", "-", "self", ".", "percentile", ")", "*", "2", ",", "len", "(", "binary_treat_value", "[", "binary_treat_value", "==", "1", "]", ")", ")", "\n", "binary_treat_value", "[", "binary_treat_value", "==", "1", "]", "=", "mask", "*", "binary_treat_value", "[", "binary_treat_value", "==", "1", "]", "\n", "", "else", ":", "\n", "                ", "mask", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "1", "-", "self", ".", "percentile", "*", "2", ",", "len", "(", "binary_treat_value", "[", "binary_treat_value", "==", "0", "]", ")", ")", "\n", "binary_treat_value", "[", "binary_treat_value", "==", "0", "]", "=", "mask", "+", "binary_treat_value", "[", "binary_treat_value", "==", "0", "]", "\n", "", "binary_treat_value", "=", "binary_treat_value", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "", "return", "binary_treat_value", ".", "astype", "(", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.__str__": [[60, 74], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "rep", "=", "\"\"\"\n        treatment:{}\n        outcome:{}\n        confounder: {}\n        effect_modifier: {}\n        weights: {}\n        bias: {}\n        seed: {}\n        treatment_is_binary: {}\n        percentile: {}\n        \"\"\"", ".", "format", "(", "self", ".", "treatment", ",", "self", ".", "outcome", ",", "self", ".", "confounder", ",", "self", ".", "effect_modifier", ",", "self", ".", "weights", ",", "self", ".", "bias", ",", "self", ".", "seed", ",", "self", ".", "treatment_is_binary", ",", "self", ".", "percentile", ")", "\n", "\n", "return", "rep", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state": [[1, 11], ["Exception", "type", "type", "type", "type", "state.keys"], "function", ["None"], ["def", "parse_state", "(", "state", ")", ":", "\n", "    ", "if", "type", "(", "state", ")", "==", "str", ":", "\n", "        ", "return", "[", "state", "]", "\n", "", "if", "type", "(", "state", ")", "==", "list", ":", "\n", "        ", "return", "state", "\n", "", "if", "type", "(", "state", ")", "==", "dict", ":", "\n", "        ", "return", "[", "xi", "for", "xi", "in", "state", ".", "keys", "(", ")", "]", "\n", "", "if", "not", "state", ":", "\n", "        ", "return", "[", "]", "\n", "", "raise", "Exception", "(", "'Input format for {} not recognized: {}'", ".", "format", "(", "state", ",", "type", "(", "state", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__init__": [[6, 13], ["ordered_set.OrderedSet.add"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add"], ["def", "__init__", "(", "self", ",", "elements", "=", "None", ")", ":", "\n", "        ", "self", ".", "_set", "=", "{", "}", "\n", "self", ".", "_start", "=", "None", "\n", "self", ".", "_end", "=", "None", "\n", "if", "elements", "is", "not", "None", ":", "\n", "            ", "for", "element", "in", "elements", ":", "\n", "                ", "self", ".", "add", "(", "element", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add": [[14, 28], ["ordered_set.OrderedSet._set.keys", "len"], "methods", ["None"], ["", "", "", "def", "add", "(", "self", ",", "element", ")", ":", "\n", "        ", "\"\"\"\n        Function to add an element to do set if it does not exit.\n        \n        :param element: element to be added.\n        \"\"\"", "\n", "if", "self", ".", "_start", "is", "None", ":", "\n", "            ", "self", ".", "_start", "=", "element", "\n", "\n", "", "if", "element", "not", "in", "self", ".", "_set", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "_set", "[", "element", "]", "=", "None", "\n", "if", "len", "(", "self", ".", "_set", ")", ">", "1", ":", "\n", "                ", "self", ".", "_set", "[", "self", ".", "_end", "]", "=", "element", "\n", "", "self", ".", "_end", "=", "element", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.get_all": [[29, 36], ["list"], "methods", ["None"], ["", "", "def", "get_all", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Function to return list of all elements in the set.\n        \n        :returns: List of all items in the set.\n        \"\"\"", "\n", "return", "list", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.is_empty": [[37, 44], ["ordered_set.OrderedSet.__len__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__len__"], ["", "def", "is_empty", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Function to determine if the set is empty or not.\n        \n        :returns: ``True`` if the set is empty, ``False`` otherwise.\n        \"\"\"", "\n", "return", "self", ".", "__len__", "(", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union": [[45, 58], ["ordered_set.OrderedSet", "ordered_set.OrderedSet.add", "ordered_set.OrderedSet.add"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add"], ["", "def", "union", "(", "self", ",", "other_set", ")", ":", "\n", "        ", "\"\"\"\n        Function to compute the union of self._set and other_set.        \n        \n        :param other_set: The set to obtain union with. Can be a list, set or OrderedSet.\n        :returns: New OrderedSet representing the set with elements from the OrderedSet object and other_set.\n        \"\"\"", "\n", "new_set", "=", "OrderedSet", "(", ")", "\n", "for", "element", "in", "self", ".", "_set", ":", "\n", "            ", "new_set", ".", "add", "(", "element", ")", "\n", "", "for", "element", "in", "other_set", ":", "\n", "            ", "new_set", ".", "add", "(", "element", ")", "\n", "", "return", "new_set", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection": [[59, 71], ["ordered_set.OrderedSet", "ordered_set.OrderedSet.add"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add"], ["", "def", "intersection", "(", "self", ",", "other_set", ")", ":", "\n", "        ", "\"\"\"\n        Function to compute the intersection of self._set and other_set.        \n\n        :param other_set: The set to obtain intersection with. Can be a list, set or OrderedSet.\n        :returns: New OrderedSet representing the set with elements common to the OrderedSet object and other_set.\n        \"\"\"", "\n", "new_set", "=", "OrderedSet", "(", ")", "\n", "for", "element", "in", "self", ".", "_set", ":", "\n", "            ", "if", "element", "in", "other_set", ":", "\n", "                ", "new_set", ".", "add", "(", "element", ")", "\n", "", "", "return", "new_set", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference": [[72, 84], ["ordered_set.OrderedSet", "ordered_set.OrderedSet.add"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add"], ["", "def", "difference", "(", "self", ",", "other_set", ")", ":", "\n", "        ", "\"\"\"\n        Function to remove elements in self._set which are also present in other_set.\n\n        :param other_set: The set to obtain difference with. Can be a list, set or OrderedSet.\n        :returns: New OrderedSet representing the difference of elements in the self._set and other_set.\n        \"\"\"", "\n", "new_set", "=", "OrderedSet", "(", ")", "\n", "for", "element", "in", "self", ".", "_set", ":", "\n", "            ", "if", "element", "not", "in", "other_set", ":", "\n", "                ", "new_set", ".", "add", "(", "element", ")", "\n", "", "", "return", "new_set", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__getitem__": [[85, 89], ["ordered_set.OrderedSet.__len__", "IndexError", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__len__"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "if", "index", ">=", "self", ".", "__len__", "(", ")", ":", "\n", "            ", "raise", "IndexError", "(", "\"Index is out of range\"", ")", "\n", "", "return", "list", "(", "self", ")", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__iter__": [[90, 93], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_iter", "=", "self", ".", "_start", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__next__": [[94, 100], ["None"], "methods", ["None"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "element", "=", "self", ".", "_iter", "\n", "if", "not", "element", ":", "\n", "            ", "raise", "StopIteration", "\n", "", "self", ".", "_iter", "=", "self", ".", "_set", "[", "element", "]", "\n", "return", "element", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__len__": [[101, 103], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__str__": [[104, 108], ["str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "elements", "=", "[", "str", "(", "i", ")", "for", "i", "in", "self", "]", "\n", "string", "=", "\"OrderedSet(\"", "+", "\",\"", ".", "join", "(", "elements", ")", "+", "\")\"", "\n", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.__eq__": [[109, 114], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "other", ",", "self", ".", "__class__", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "return", "self", ".", "_set", "==", "other", ".", "_set", "", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.propensity_of_treatment_score": [[11, 20], ["sklearn.linear_model.LogisticRegression", "propensity_score.binarize_discrete", "model.fit.fit", "data[].values.ravel", "model.fit.predict_proba"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.binarize_discrete", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["def", "propensity_of_treatment_score", "(", "data", ",", "covariates", ",", "treatment", ",", "model", "=", "'logistic'", ",", "variable_types", "=", "None", ")", ":", "\n", "    ", "if", "model", "==", "'logistic'", ":", "\n", "        ", "model", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ")", "\n", "data", ",", "covariates", "=", "binarize_discrete", "(", "data", ",", "covariates", ",", "variable_types", ")", "\n", "model", "=", "model", ".", "fit", "(", "data", "[", "covariates", "]", ",", "data", "[", "treatment", "]", ".", "values", ".", "ravel", "(", ")", ")", "\n", "scores", "=", "model", ".", "predict_proba", "(", "data", "[", "covariates", "]", ")", "[", ":", ",", "1", "]", "\n", "return", "scores", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.state_propensity_score": [[22, 49], ["enumerate", "numpy.zeros", "numpy.exp", "len", "Exception", "len", "set().intersection", "numpy.log", "propensity_score.binary_treatment_model", "numpy.log", "set", "data.copy", "propensity_score.categorical_treatment_model", "numpy.log", "Exception", "data.copy", "propensity_score.continuous_treatment_model", "data.copy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.binary_treatment_model", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.categorical_treatment_model", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.continuous_treatment_model"], ["", "", "def", "state_propensity_score", "(", "data", ",", "covariates", ",", "treatments", ",", "variable_types", "=", "None", ")", ":", "\n", "    ", "if", "len", "(", "set", "(", "covariates", ")", ".", "intersection", "(", "treatments", ")", ")", "!=", "0", ":", "\n", "        ", "raise", "Exception", "(", "\"Can't control for causal states. Remove treatment from covariates.\"", ")", "\n", "", "log_propensities", "=", "{", "}", "\n", "for", "i", ",", "treatment", "in", "enumerate", "(", "treatments", ")", ":", "\n", "        ", "if", "variable_types", "[", "treatment", "]", "in", "[", "'b'", "]", ":", "\n", "            ", "log_propensities", "[", "treatment", "]", "=", "np", ".", "log", "(", "binary_treatment_model", "(", "data", ".", "copy", "(", ")", ",", "\n", "covariates", "+", "treatments", "[", "i", "+", "1", ":", "]", ",", "\n", "treatment", ",", "\n", "variable_types", ")", ")", "\n", "", "elif", "variable_types", "[", "treatment", "]", "in", "[", "'o'", ",", "'u'", ",", "'d'", "]", ":", "\n", "            ", "log_propensities", "[", "treatment", "]", "=", "np", ".", "log", "(", "categorical_treatment_model", "(", "data", ".", "copy", "(", ")", ",", "\n", "covariates", "+", "treatments", "[", "i", "+", "1", ":", "]", ",", "\n", "treatment", ",", "\n", "variable_types", ")", ")", "\n", "", "elif", "variable_types", "[", "treatment", "]", "in", "[", "'c'", "]", ":", "\n", "            ", "log_propensities", "[", "treatment", "]", "=", "np", ".", "log", "(", "continuous_treatment_model", "(", "data", ".", "copy", "(", ")", ",", "\n", "covariates", "+", "treatments", "[", "i", "+", "1", ":", "]", ",", "\n", "treatment", ",", "\n", "variable_types", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Variable type {} for variable {} is not a recognized format type.\"", ".", "format", "(", "variable_types", "[", "treatment", "]", ",", "\n", "treatment", ")", ")", "\n", "", "", "scores", "=", "np", ".", "zeros", "(", "len", "(", "data", ")", ")", "\n", "for", "treatment", "in", "treatments", ":", "\n", "        ", "scores", "+=", "log_propensities", "[", "treatment", "]", "\n", "", "return", "np", ".", "exp", "(", "scores", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.binary_treatment_model": [[51, 58], ["propensity_score.binarize_discrete", "sklearn.linear_model.LogisticRegression", "model.fit.fit", "model.fit.predict_proba", "range", "data[].values.astype", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.binarize_discrete", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "binary_treatment_model", "(", "data", ",", "covariates", ",", "treatment", ",", "variable_types", ")", ":", "\n", "    ", "data", ",", "covariates", "=", "binarize_discrete", "(", "data", ",", "covariates", ",", "variable_types", ")", "\n", "model", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ")", "\n", "model", "=", "model", ".", "fit", "(", "data", "[", "covariates", "]", ",", "data", "[", "treatment", "]", ")", "\n", "scores", "=", "model", ".", "predict_proba", "(", "data", "[", "covariates", "]", ")", "\n", "scores", "=", "scores", "[", "range", "(", "len", "(", "scores", ")", ")", ",", "data", "[", "treatment", "]", ".", "values", ".", "astype", "(", "int", ")", "]", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.categorical_treatment_model": [[60, 68], ["propensity_score.binarize_discrete", "sklearn.linear_model.LogisticRegression", "propensity_score.discrete_to_integer", "model.fit.fit", "model.fit.predict_proba", "range", "data[].values.astype", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.binarize_discrete", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.discrete_to_integer", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "categorical_treatment_model", "(", "data", ",", "covariates", ",", "treatment", ",", "variable_types", ")", ":", "\n", "    ", "data", ",", "covariates", "=", "binarize_discrete", "(", "data", ",", "covariates", ",", "variable_types", ")", "\n", "model", "=", "LogisticRegression", "(", "multi_class", "=", "'ovr'", ",", "solver", "=", "'lbfgs'", ")", "\n", "data", "[", "treatment", "]", ",", "encoder", "=", "discrete_to_integer", "(", "data", "[", "treatment", "]", ")", "\n", "model", "=", "model", ".", "fit", "(", "data", "[", "covariates", "]", ",", "data", "[", "treatment", "]", ")", "\n", "scores", "=", "model", ".", "predict_proba", "(", "data", "[", "covariates", "]", ")", "\n", "scores", "=", "scores", "[", "range", "(", "len", "(", "data", ")", ")", ",", "data", "[", "treatment", "]", ".", "values", ".", "astype", "(", "int", ")", "]", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.continuous_treatment_model": [[70, 93], ["propensity_score.binarize_discrete", "propensity_score.get_type_string", "propensity_score.get_type_string", "statsmodels.nonparametric.kernel_density.KDEMultivariateConditional", "statsmodels.nonparametric.kernel_density.KDEMultivariateConditional.pdf", "statsmodels.nonparametric.kernel_density.EstimatorSettings", "statsmodels.nonparametric.kernel_density.EstimatorSettings", "variable_types.values", "len", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.binarize_discrete", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.get_type_string", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.get_type_string"], ["", "def", "continuous_treatment_model", "(", "data", ",", "covariates", ",", "treatment", ",", "variable_types", ")", ":", "\n", "    ", "data", ",", "covariates", "=", "binarize_discrete", "(", "data", ",", "covariates", ",", "variable_types", ")", "\n", "if", "len", "(", "data", ")", ">", "300", "or", "len", "(", "[", "treatment", "]", "+", "covariates", ")", ">=", "3", ":", "\n", "        ", "defaults", "=", "EstimatorSettings", "(", "n_jobs", "=", "4", ",", "efficient", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "defaults", "=", "EstimatorSettings", "(", "n_jobs", "=", "-", "1", ",", "efficient", "=", "False", ")", "\n", "\n", "", "if", "'c'", "not", "in", "variable_types", ".", "values", "(", ")", ":", "\n", "        ", "bw", "=", "'cv_ml'", "\n", "", "else", ":", "\n", "        ", "bw", "=", "'normal_reference'", "\n", "\n", "", "indep_type", "=", "get_type_string", "(", "covariates", ",", "variable_types", ")", "\n", "dep_type", "=", "get_type_string", "(", "[", "treatment", "]", ",", "variable_types", ")", "\n", "\n", "model", "=", "KDEMultivariateConditional", "(", "endog", "=", "data", "[", "treatment", "]", ",", "\n", "exog", "=", "data", "[", "covariates", "]", ",", "\n", "dep_type", "=", "''", ".", "join", "(", "dep_type", ")", ",", "\n", "indep_type", "=", "''", ".", "join", "(", "indep_type", ")", ",", "\n", "bw", "=", "bw", ",", "\n", "defaults", "=", "defaults", ")", "\n", "scores", "=", "model", ".", "pdf", "(", "endog_predict", "=", "data", "[", "treatment", "]", ",", "exog_predict", "=", "data", "[", "covariates", "]", ")", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.get_type_string": [[95, 109], ["var_types.append", "var_types.append", "var_types.append", "Exception"], "function", ["None"], ["", "def", "get_type_string", "(", "variables", ",", "variable_types", ")", ":", "\n", "    ", "var_types", "=", "[", "]", "\n", "for", "variable", "in", "variables", ":", "\n", "        ", "if", "variable_types", "[", "variable", "]", "in", "[", "'b'", ",", "'d'", ",", "'o'", ",", "'u'", "]", ":", "\n", "            ", "if", "variable_types", "[", "variable", "]", "in", "[", "'o'", ",", "'u'", "]", ":", "\n", "                ", "var_types", ".", "append", "(", "variable_types", "[", "variable", "]", ")", "\n", "", "else", ":", "\n", "                ", "var_types", ".", "append", "(", "'u'", ")", "\n", "", "", "elif", "variable_types", "[", "variable", "]", "in", "[", "'c'", "]", ":", "\n", "            ", "var_types", ".", "append", "(", "'c'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Variable type {} for variable {} not a recognized type.\"", ".", "format", "(", "variable_types", "[", "variable", "]", ",", "\n", "variable", ")", ")", "\n", "", "", "return", "\"\"", ".", "join", "(", "var_types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.binarize_discrete": [[111, 129], ["covariates.remove", "pandas.get_dummies", "list", "to_remove.append", "str"], "function", ["None"], ["", "def", "binarize_discrete", "(", "data", ",", "covariates", ",", "variable_types", ")", ":", "\n", "    ", "to_remove", "=", "[", "]", "\n", "if", "variable_types", ":", "\n", "        ", "for", "variable", "in", "covariates", ":", "\n", "            ", "variable_type", "=", "variable_types", "[", "variable", "]", "\n", "if", "variable_type", "in", "[", "'d'", ",", "'o'", ",", "'u'", "]", ":", "\n", "                ", "dummies", "=", "get_dummies", "(", "data", "[", "variable", "]", ")", "\n", "dummies", ".", "columns", "=", "[", "variable", "+", "str", "(", "col", ")", "for", "col", "in", "dummies", ".", "columns", "]", "\n", "dummies", "=", "dummies", "[", "dummies", ".", "columns", "[", ":", "-", "1", "]", "]", "\n", "covariates", "+=", "list", "(", "dummies", ".", "columns", ")", "\n", "for", "var_name", "in", "dummies", ".", "columns", ":", "\n", "                    ", "variable_types", "[", "var_name", "]", "=", "'b'", "\n", "", "data", "[", "dummies", ".", "columns", "]", "=", "dummies", "\n", "to_remove", ".", "append", "(", "variable", ")", "\n", "", "", "", "for", "variable", "in", "to_remove", ":", "\n", "        ", "covariates", ".", "remove", "(", "variable", ")", "\n", "del", "data", "[", "variable", "]", "\n", "", "return", "data", ",", "covariates", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.discrete_to_integer": [[131, 135], ["sklearn.preprocessing.LabelEncoder", "sklearn.preprocessing.LabelEncoder.fit_transform"], "function", ["None"], ["", "def", "discrete_to_integer", "(", "discrete", ")", ":", "\n", "    ", "encoder", "=", "LabelEncoder", "(", ")", "\n", "discrete", "=", "encoder", ".", "fit_transform", "(", "discrete", ")", "\n", "return", "discrete", ",", "encoder", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.adjacency_matrix_to_adjacency_list": [[10, 28], ["dict", "range", "list", "range", "str", "range", "adjlist[].append"], "function", ["None"], ["def", "adjacency_matrix_to_adjacency_list", "(", "adjacency_matrix", ",", "labels", "=", "None", ")", ":", "\n", "    ", "'''\n    Convert the adjacency matrix of a graph to an adjacency list.\n\n    :param adjacency_matrix: A numpy array representing the graph adjacency matrix.\n    :param labels: List of labels.\n    :returns: Adjacency list as a dictionary.\n    '''", "\n", "\n", "adjlist", "=", "dict", "(", ")", "\n", "if", "labels", "is", "None", ":", "\n", "        ", "labels", "=", "[", "str", "(", "i", "+", "1", ")", "for", "i", "in", "range", "(", "adjacency_matrix", ".", "shape", "[", "0", "]", ")", "]", "\n", "", "for", "i", "in", "range", "(", "adjacency_matrix", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "adjlist", "[", "labels", "[", "i", "]", "]", "=", "list", "(", ")", "\n", "for", "j", "in", "range", "(", "adjacency_matrix", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "if", "adjacency_matrix", "[", "i", ",", "j", "]", "!=", "0", ":", "\n", "                ", "adjlist", "[", "labels", "[", "i", "]", "]", ".", "append", "(", "labels", "[", "j", "]", ")", "\n", "", "", "", "return", "adjlist", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.adjacency_matrix_to_graph": [[29, 48], ["numpy.where", "graphviz.Digraph", "zip", "numpy.abs", "graphviz.Digraph.node", "graphviz.Digraph.edge", "range", "str", "len"], "function", ["None"], ["", "def", "adjacency_matrix_to_graph", "(", "adjacency_matrix", ",", "labels", "=", "None", ")", ":", "\n", "    ", "'''\n    Convert a given graph adjacency matrix to DOT format.\n\n    :param adjacency_matrix: A numpy array representing the graph adjacency matrix.\n    :param labels: List of labels.\n    :returns: Graph in DOT format.\n    '''", "\n", "# Only consider edges have absolute edge weight > 0.01", "\n", "idx", "=", "np", ".", "abs", "(", "adjacency_matrix", ")", ">", "0.01", "\n", "dirs", "=", "np", ".", "where", "(", "idx", ")", "\n", "import", "graphviz", "\n", "d", "=", "graphviz", ".", "Digraph", "(", "engine", "=", "'dot'", ")", "\n", "names", "=", "labels", "if", "labels", "else", "[", "f'x{i}'", "for", "i", "in", "range", "(", "len", "(", "adjacency_matrix", ")", ")", "]", "\n", "for", "name", "in", "names", ":", "\n", "        ", "d", ".", "node", "(", "name", ")", "\n", "", "for", "to", ",", "from_", ",", "coef", "in", "zip", "(", "dirs", "[", "0", "]", ",", "dirs", "[", "1", "]", ",", "adjacency_matrix", "[", "idx", "]", ")", ":", "\n", "        ", "d", ".", "edge", "(", "names", "[", "from_", "]", ",", "names", "[", "to", "]", ",", "label", "=", "str", "(", "coef", ")", ")", "\n", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.str_to_dot": [[49, 59], ["string.replace().replace", "string.replace"], "function", ["None"], ["", "def", "str_to_dot", "(", "string", ")", ":", "\n", "    ", "'''\n    Converts input string from graphviz library to valid DOT graph format.\n\n    :param string: Graph in DOT format.\n    :returns: DOT string converted to a suitable format for the DoWhy library.\n    '''", "\n", "graph", "=", "string", ".", "replace", "(", "'\\n'", ",", "';'", ")", ".", "replace", "(", "'\\t'", ",", "''", ")", "\n", "graph", "=", "graph", "[", ":", "9", "]", "+", "graph", "[", "10", ":", "-", "2", "]", "+", "graph", "[", "-", "1", "]", "# Removing unnecessary characters from string", "\n", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.find_ancestor": [[60, 88], ["dowhy.utils.ordered_set.OrderedSet", "node_set.get_all", "dowhy.utils.ordered_set.OrderedSet", "queue.LifoQueue", "queue.LifoQueue.put", "ancestors.union.union", "queue.LifoQueue.empty", "queue.LifoQueue.get", "ancestors.union.add", "range", "graph_operations.find_ancestor.find_ancestor_help"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.get_all", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add"], ["", "def", "find_ancestor", "(", "node_set", ",", "node_names", ",", "adjacency_matrix", ",", "node2idx", ",", "idx2node", ")", ":", "\n", "    ", "'''\n    Finds ancestors of a given set of nodes in a given graph.\n\n    :param node_set: Set of nodes whos ancestors must be obtained.\n    :param node_names: Name of all nodes in the graph.\n    :param adjacency_matrix: Graph adjacency matrix.\n    :param node2idx: A dictionary mapping node names to their row or column index in the adjacency matrix.\n    :param idx2node: A dictionary mapping the row or column indices in the adjacency matrix to the corresponding node names.\n    :returns: OrderedSet containing ancestors of all nodes in the node_set.\n    '''", "\n", "\n", "def", "find_ancestor_help", "(", "node_name", ",", "node_names", ",", "adjacency_matrix", ",", "node2idx", ",", "idx2node", ")", ":", "\n", "        ", "ancestors", "=", "OrderedSet", "(", ")", "\n", "nodes_to_visit", "=", "LifoQueue", "(", "maxsize", "=", "len", "(", "node_names", ")", ")", "\n", "nodes_to_visit", ".", "put", "(", "node2idx", "[", "node_name", "]", ")", "\n", "while", "not", "nodes_to_visit", ".", "empty", "(", ")", ":", "\n", "            ", "child", "=", "nodes_to_visit", ".", "get", "(", ")", "\n", "ancestors", ".", "add", "(", "idx2node", "[", "child", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "node_names", ")", ")", ":", "\n", "                ", "if", "idx2node", "[", "i", "]", "not", "in", "ancestors", "and", "adjacency_matrix", "[", "i", ",", "child", "]", "==", "1", ":", "# For edge a->b, a is along height and b is along width of adjacency matrix", "\n", "                    ", "nodes_to_visit", ".", "put", "(", "i", ")", "\n", "", "", "", "return", "ancestors", "\n", "\n", "", "ancestors", "=", "OrderedSet", "(", ")", "\n", "for", "node_name", "in", "node_set", ".", "get_all", "(", ")", ":", "\n", "        ", "ancestors", "=", "ancestors", ".", "union", "(", "find_ancestor_help", "(", "node_name", ",", "node_names", ",", "adjacency_matrix", ",", "node2idx", ",", "idx2node", ")", ")", "\n", "", "return", "ancestors", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.induced_graph": [[89, 104], ["node_idx_list.sort", "adjacency_matrix.copy"], "function", ["None"], ["", "def", "induced_graph", "(", "node_set", ",", "adjacency_matrix", ",", "node2idx", ")", ":", "\n", "    ", "'''\n    To obtain the induced graph corresponding to a subset of nodes.\n\n    :param node_set: Set of nodes whos ancestors must be obtained.\n    :param adjacency_matrix: Graph adjacency matrix.\n    :param node2idx: A dictionary mapping node names to their row or column index in the adjacency matrix.\n    :returns: Numpy array representing the adjacency matrix of the induced graph.\n    '''", "\n", "node_idx_list", "=", "[", "node2idx", "[", "node", "]", "for", "node", "in", "node_set", "]", "\n", "node_idx_list", ".", "sort", "(", ")", "\n", "adjacency_matrix_induced", "=", "adjacency_matrix", ".", "copy", "(", ")", "\n", "adjacency_matrix_induced", "=", "adjacency_matrix_induced", "[", "node_idx_list", "]", "\n", "adjacency_matrix_induced", "=", "adjacency_matrix_induced", "[", ":", ",", "node_idx_list", "]", "\n", "return", "adjacency_matrix_induced", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.find_c_components": [[105, 146], ["len", "adjacency_matrix.copy", "range", "range", "range", "dowhy.utils.ordered_set.OrderedSet.add", "range", "range", "dowhy.utils.ordered_set.OrderedSet", "graph_operations.find_c_components.dfs"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add"], ["", "def", "find_c_components", "(", "adjacency_matrix", ",", "node_set", ",", "idx2node", ")", ":", "\n", "    ", "'''\n    Obtain C-components in a graph.\n\n    :param adjacency_matrix: Graph adjacency matrix.\n    :param node_set: Set of nodes whos ancestors must be obtained.\n    :param idx2node: A dictionary mapping the row or column indices in the adjacency matrix to the corresponding node names.\n    :returns: List of C-components in the graph.\n    '''", "\n", "num_nodes", "=", "len", "(", "node_set", ")", "\n", "adj_matrix", "=", "adjacency_matrix", ".", "copy", "(", ")", "\n", "adjacency_list", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_nodes", ")", "]", "\n", "\n", "# Modify graph such that it only contains bidirected edges", "\n", "for", "h", "in", "range", "(", "0", ",", "num_nodes", "-", "1", ")", ":", "\n", "        ", "for", "w", "in", "range", "(", "h", "+", "1", ",", "num_nodes", ")", ":", "\n", "            ", "if", "adjacency_matrix", "[", "h", ",", "w", "]", "==", "1", "and", "adjacency_matrix", "[", "w", ",", "h", "]", "==", "1", ":", "\n", "                ", "adjacency_list", "[", "h", "]", ".", "append", "(", "w", ")", "\n", "adjacency_list", "[", "w", "]", ".", "append", "(", "h", ")", "\n", "", "else", ":", "\n", "                ", "adj_matrix", "[", "h", ",", "w", "]", "=", "0", "\n", "adj_matrix", "[", "w", ",", "h", "]", "=", "0", "\n", "\n", "# Find c components by finding connected components on the undirected graph", "\n", "", "", "", "visited", "=", "[", "False", "for", "_", "in", "range", "(", "num_nodes", ")", "]", "\n", "\n", "def", "dfs", "(", "node_idx", ",", "component", ")", ":", "\n", "        ", "visited", "[", "node_idx", "]", "=", "True", "\n", "component", ".", "add", "(", "idx2node", "[", "node_idx", "]", ")", "\n", "for", "neighbour", "in", "adjacency_list", "[", "node_idx", "]", ":", "\n", "            ", "if", "visited", "[", "neighbour", "]", "==", "False", ":", "\n", "                ", "dfs", "(", "neighbour", ",", "component", ")", "\n", "\n", "", "", "", "c_components", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_nodes", ")", ":", "\n", "        ", "if", "visited", "[", "i", "]", "==", "False", ":", "\n", "            ", "component", "=", "OrderedSet", "(", ")", "\n", "dfs", "(", "i", ",", "component", ")", "\n", "c_components", ".", "append", "(", "component", ")", "\n", "\n", "", "", "return", "c_components", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.daggity_to_dot": [[147, 164], ["re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub"], "function", ["None"], ["", "def", "daggity_to_dot", "(", "daggity_string", ")", ":", "\n", "    ", "'''\n    Converts the input daggity_string to valid DOT graph format.\n\n    :param daggity_string: Output graph from Daggity site\n    :returns: DOT string  \n    '''", "\n", "graph", "=", "re", ".", "sub", "(", "r'\\n'", ",", "'; '", ",", "daggity_string", ")", "\n", "graph", "=", "re", ".", "sub", "(", "r'^dag '", ",", "'digraph '", ",", "graph", ")", "\n", "graph", "=", "re", ".", "sub", "(", "'{;'", ",", "'{'", ",", "graph", ")", "\n", "graph", "=", "re", ".", "sub", "(", "'};'", ",", "'}'", ",", "graph", ")", "\n", "graph", "=", "re", ".", "sub", "(", "'outcome,*,'", ",", "''", ",", "graph", ")", "\n", "graph", "=", "re", ".", "sub", "(", "'adjusted,*'", ",", "''", ",", "graph", ")", "\n", "graph", "=", "re", ".", "sub", "(", "'exposure,*'", ",", "''", ",", "graph", ")", "\n", "graph", "=", "re", ".", "sub", "(", "'latent,*'", ",", "'observed=\"no\",'", ",", "graph", ")", "\n", "graph", "=", "re", ".", "sub", "(", "',]'", ",", "']'", ",", "graph", ")", "\n", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.get_simple_ordered_tree": [[165, 179], ["networkx.DiGraph", "range", "range", "nx.DiGraph.add_node", "nx.DiGraph.add_edges_from"], "function", ["None"], ["", "def", "get_simple_ordered_tree", "(", "n", ")", ":", "\n", "    ", "\"\"\"\n    Generates a simple-ordered tree. The tree is just a\n    directed acyclic graph of n nodes with the structure\n    0 --> 1 --> .... --> n.\n    \"\"\"", "\n", "g", "=", "nx", ".", "DiGraph", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "g", ".", "add_node", "(", "i", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n", "-", "1", ")", ":", "\n", "        ", "g", ".", "add_edges_from", "(", "[", "(", "i", ",", "i", "+", "1", ",", "{", "}", ")", "]", ")", "\n", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.is_connected": [[181, 187], ["graph_operations.convert_to_undirected_graph", "networkx.is_connected"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.convert_to_undirected_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.is_connected"], ["", "def", "is_connected", "(", "g", ")", ":", "\n", "    ", "\"\"\"\n    Checks if a the directed acyclic graph is connected.\n    \"\"\"", "\n", "u", "=", "convert_to_undirected_graph", "(", "g", ")", "\n", "return", "nx", ".", "is_connected", "(", "u", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.convert_to_undirected_graph": [[189, 196], ["networkx.Graph", "nx.Graph.add_node", "nx.Graph.add_edges_from"], "function", ["None"], ["", "def", "convert_to_undirected_graph", "(", "g", ")", ":", "\n", "    ", "u", "=", "nx", ".", "Graph", "(", ")", "\n", "for", "n", "in", "g", ".", "nodes", ":", "\n", "        ", "u", ".", "add_node", "(", "n", ")", "\n", "", "for", "e", "in", "g", ".", "edges", ":", "\n", "        ", "u", ".", "add_edges_from", "(", "[", "(", "e", "[", "0", "]", ",", "e", "[", "1", "]", ",", "{", "}", ")", "]", ")", "\n", "", "return", "u", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.get_random_node_pair": [[198, 207], ["numpy.random.randint", "numpy.random.randint"], "function", ["None"], ["", "def", "get_random_node_pair", "(", "n", ")", ":", "\n", "    ", "\"\"\"\n    Randomly generates a pair of nodes.\n    \"\"\"", "\n", "i", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "n", ")", "\n", "j", "=", "i", "\n", "while", "j", "==", "i", ":", "\n", "        ", "j", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "n", ")", "\n", "", "return", "i", ",", "j", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.find_predecessor": [[210, 224], ["list", "graph_operations.convert_to_undirected_graph", "g.predecessors", "networkx.algorithms.shortest_paths.generic.shortest_path"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.convert_to_undirected_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.DirectedGraph.predecessors"], ["", "def", "find_predecessor", "(", "i", ",", "j", ",", "g", ")", ":", "\n", "    ", "\"\"\"\n    Finds a predecessor, k, in the path between two nodes, i and j,\n    in the graph, g. \n    \"\"\"", "\n", "parents", "=", "list", "(", "g", ".", "predecessors", "(", "j", ")", ")", "\n", "u", "=", "convert_to_undirected_graph", "(", "g", ")", "\n", "for", "pa", "in", "parents", ":", "\n", "        ", "try", ":", "\n", "            ", "path", "=", "shortest_path", "(", "u", ",", "pa", ",", "i", ")", "\n", "return", "pa", "\n", "", "except", ":", "\n", "            ", "pass", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.del_edge": [[227, 238], ["g.has_edge", "g.remove_edge", "graph_operations.is_connected", "g.add_edges_from"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.is_connected"], ["", "def", "del_edge", "(", "i", ",", "j", ",", "g", ")", ":", "\n", "    ", "\"\"\"\n    Deletes the edge i --> j in the graph, g. The edge is only\n    deleted if this removal does NOT cause the graph to be\n    disconnected.\n    \"\"\"", "\n", "if", "g", ".", "has_edge", "(", "i", ",", "j", ")", "is", "True", ":", "\n", "        ", "g", ".", "remove_edge", "(", "i", ",", "j", ")", "\n", "\n", "if", "is_connected", "(", "g", ")", "is", "False", ":", "\n", "            ", "g", ".", "add_edges_from", "(", "[", "(", "i", ",", "j", ",", "{", "}", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge": [[239, 248], ["g.add_edges_from", "networkx.algorithms.dag.is_directed_acyclic_graph", "g.remove_edge"], "function", ["None"], ["", "", "", "def", "add_edge", "(", "i", ",", "j", ",", "g", ")", ":", "\n", "    ", "\"\"\"\n    Adds an edge i --> j to the graph, g. The edge is only\n    added if this addition does NOT cause the graph to have\n    cycles.\n    \"\"\"", "\n", "g", ".", "add_edges_from", "(", "[", "(", "i", ",", "j", ",", "{", "}", ")", "]", ")", "\n", "if", "is_directed_acyclic_graph", "(", "g", ")", "is", "False", ":", "\n", "        ", "g", ".", "remove_edge", "(", "i", ",", "j", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.compute_ci": [[8, 44], ["isinstance", "numpy.arctanh", "numpy.abs", "numpy.array", "numpy.tanh", "numpy.sqrt", "scipy.stats.norm.ppf"], "function", ["None"], ["def", "compute_ci", "(", "r", "=", "None", ",", "nx", "=", "None", ",", "ny", "=", "None", ",", "confidence", "=", ".95", ")", ":", "\n", "    ", "\"\"\"Compute Parametric confidence intervals around correlation coefficient.\n    See : https://online.stat.psu.edu/stat505/lesson/6/6.3\n\n    This is done by applying Fisher's r to z transform\n    z = .5[ln((1+r)/(1-r))] = arctanh(r)\n\n    The Standard error is 1/sqrt(N-3) where N is sample size\n\n    The critical value for normal distribution for a corresponding confidence\n    level is calculated from stats.norm.ppf((1 - alpha)/2) for two tailed test\n\n    The lower and upper condidence intervals in z space are calculated with the formula\n    z \u00b1 critical value*error\n\n    The confidence interval is then converted back to r space\n    \n    :param stat : correlation coefficient\n    :param nx : length of vector x\n    :param ny :length of vector y\n    :param confidence : Confidence level (0.95 = 95%)\n    \n    :returns : array containing confidence interval\n    \"\"\"", "\n", "\n", "assert", "r", "is", "not", "None", "and", "nx", "is", "not", "None", "\n", "assert", "isinstance", "(", "confidence", ",", "float", ")", "\n", "assert", "0", "<", "confidence", "<", "1", "\n", "\n", "z", "=", "np", ".", "arctanh", "(", "r", ")", "# Fisher Transform  from r to z", "\n", "se", "=", "1", "/", "np", ".", "sqrt", "(", "nx", "-", "3", ")", "# Standard error = 1/sqrt(N-3) where N is sample size", "\n", "crit", "=", "np", ".", "abs", "(", "norm", ".", "ppf", "(", "(", "1", "-", "confidence", ")", "/", "2", ")", ")", "# Z-critical value ", "\n", "ci_z", "=", "np", ".", "array", "(", "[", "z", "-", "crit", "*", "se", ",", "z", "+", "crit", "*", "se", "]", ")", "# CI = point estimator \u00b1 critical value*error", "\n", "ci", "=", "np", ".", "tanh", "(", "ci_z", ")", "# Back Transform to r-space", "\n", "\n", "return", "ci", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.partial_corr": [[45, 110], ["isinstance", "data[].dropna", "numpy.linalg.pinv", "np.linalg.pinv.diagonal", "numpy.diag", "numpy.isnan", "cit.compute_ci", "numpy.round", "combined_variables.append", "data[].dropna.rank().cov", "data[].dropna.astype().cov", "numpy.sqrt", "numpy.sqrt", "scipy.stats.t.sf", "pval.round", "numpy.abs", "data[].dropna.rank", "data[].dropna.astype"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.compute_ci"], ["", "def", "partial_corr", "(", "data", "=", "None", ",", "x", "=", "None", ",", "y", "=", "None", ",", "z", "=", "None", ",", "method", "=", "\"pearson\"", ")", ":", "\n", "    ", "\"\"\" Calculate Partial correlation which is the degree of association between \n    x and y after removing effect of z. This is done by calculating correlation\n    coefficient between the residuals of two linear regressions :\n    x\\sim z, y\\sim z\n    See : 1 https://en.wikipedia.org/wiki/Partial_correlation\n          2 https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.1467-842X.2004.00360.x?casa_token=p_D3joHC8C0AAAAA:qigIZHVfcVi8vsz1j2t7uQYOorrYaF3Tm4lpQOUzqG_J9gJgtFerOyliKBnQPVG187nJxbA-wcbXU3QcOw\n          3 https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4681537/\n          4 http://parker.ad.siu.edu/Olive/slch6.pdf\n    :param data : pandas dataframe \n    :param x : Column name in data\n    :param y : Column name in data\n    :param z : string or list\n    :param method : string denoting the correlation type - \"pearson\" or \"spearman\"\n\n    : returns: a python dictionary with keys as \n        n: Sample size\n        r: Partial correlation coefficient\n        CI95: 95% parametric confidence intervals\n        p-val: p-value\n    \"\"\"", "\n", "\n", "assert", "data", ".", "shape", "[", "0", "]", ">", "2", "# Check for atleast 3 samples", "\n", "assert", "x", "!=", "z", "# x and z should be distinct", "\n", "assert", "y", "!=", "z", "# y and z should be distinct", "\n", "assert", "x", "!=", "y", "# x and y should be distinct", "\n", "if", "isinstance", "(", "z", ",", "list", ")", ":", "\n", "        ", "assert", "x", "not", "in", "z", "# x and z should be distinct", "\n", "assert", "y", "not", "in", "z", "# y and z should be distinct", "\n", "\n", "", "combined_variables", "=", "[", "x", ",", "y", "]", "# Combine all variables - x, y and z", "\n", "for", "var", "in", "z", ":", "\n", "        ", "combined_variables", ".", "append", "(", "var", ")", "\n", "", "data", "=", "data", "[", "combined_variables", "]", ".", "dropna", "(", ")", "#Drop missing values", "\n", "n", "=", "data", ".", "shape", "[", "0", "]", "# Number of samples after dropping missing values", "\n", "k", "=", "data", ".", "shape", "[", "1", "]", "-", "2", "# Number of covariates", "\n", "assert", "n", ">", "2", "\n", "\n", "if", "method", "==", "\"spearman\"", ":", "\n", "        ", "V", "=", "data", ".", "rank", "(", "na_option", "=", "'keep'", ")", ".", "cov", "(", ")", "# Change data to rank for spearman correlation", "\n", "", "else", ":", "\n", "        ", "V", "=", "data", ".", "astype", "(", "float", ")", ".", "cov", "(", ")", "# Computing Covariance Matrix", "\n", "", "Vi", "=", "np", ".", "linalg", ".", "pinv", "(", "V", ",", "hermitian", "=", "True", ")", "# Computing Inverse Covariance Matrix", "\n", "Vi_diag", "=", "Vi", ".", "diagonal", "(", ")", "# Storing variance", "\n", "D", "=", "np", ".", "diag", "(", "np", ".", "sqrt", "(", "1", "/", "Vi_diag", ")", ")", "# Storing Standard Deviations from diagonal of inverse covariance matrix", "\n", "pcor", "=", "-", "1", "*", "(", "D", "@", "Vi", "@", "D", ")", "\n", "r", "=", "pcor", "[", "0", ",", "1", "]", "\n", "\n", "if", "np", ".", "isnan", "(", "r", ")", ":", "\n", "        ", "return", "{", "'n'", ":", "n", ",", "'r'", ":", "np", ".", "nan", ",", "'CI95%'", ":", "np", ".", "nan", ",", "'p-val'", ":", "np", ".", "nan", "}", "\n", "\n", "# Finding p-value using student T test", "\n", "", "dof", "=", "n", "-", "k", "-", "2", "# Degree of freedom for multivariate analysis", "\n", "tval", "=", "r", "*", "np", ".", "sqrt", "(", "dof", "/", "(", "1", "-", "r", "**", "2", ")", ")", "# Test statistic", "\n", "pval", "=", "2", "*", "t", ".", "sf", "(", "np", ".", "abs", "(", "tval", ")", ",", "dof", ")", "# Calculate p-value corresponding to the test statistic and degree of freedom", "\n", "\n", "ci", "=", "compute_ci", "(", "r", "=", "r", ",", "nx", "=", "(", "n", "-", "k", ")", ",", "ny", "=", "(", "n", "-", "k", ")", ")", "#Finding Confidence Interval", "\n", "ci", "=", "np", ".", "round", "(", "ci", ",", "3", ")", "\n", "stats", "=", "{", "\n", "'n'", ":", "n", ",", "\n", "'r'", ":", "r", ",", "\n", "'CI95%'", ":", "[", "ci", "]", ",", "\n", "'p-val'", ":", "pval", ".", "round", "(", "5", ")", ",", "\n", "}", "\n", "return", "stats", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy": [[111, 128], ["collections.defaultdict", "math.log"], "function", ["None"], ["", "def", "entropy", "(", "x", ")", ":", "\n", "    ", "\"\"\"\"\n    Returns entropy for a random variable x\n    H(x) = - \u03a3 p(x)log(p(x))\n    :param x : random variable to calculate entropy for\n    :returns : entropy of random variable\n    \"\"\"", "\n", "d", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "s", "=", "0.0", "\n", "entr", "=", "0.0", "\n", "for", "i", "in", "x", ":", "\n", "        ", "d", "[", "i", "]", "+=", "1", "# Calculating frequency of an event", "\n", "s", "+=", "1", "\n", "", "for", "i", "in", "d", ":", "\n", "        ", "p", "=", "d", "[", "i", "]", "/", "s", "# Calculating probability for an event", "\n", "entr", "-=", "p", "*", "log", "(", "p", ",", "2", ")", "# H(x) = - \u03a3 p(x)log(p(x))", "\n", "", "return", "entr", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.conditional_MI": [[130, 151], ["data[].astype", "data[].astype", "list", "data[].astype", "list.values.tolist", "list", "cit.entropy", "cit.entropy", "cit.entropy", "cit.entropy", "data[].itertuples", "map", "map", "map", "zip", "zip", "zip", "list", "list"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy"], ["", "def", "conditional_MI", "(", "data", "=", "None", ",", "x", "=", "None", ",", "y", "=", "None", ",", "z", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Method to return conditional mutual information between X and Y given Z\n    I(X, Y | Z) = H(X|Z) - H(X|Y,Z)\n                = H(X,Z) - H(Z) - H(X,Y,Z) + H(Y,Z)\n                = H(X,Z) + H(Y,Z) - H(X,Y,Z) - H(Z)\n    :param data : dataset \n    :param x,y,z : column names from dataset\n    :returns : conditional mutual information between X and Y given Z\n    \"\"\"", "\n", "X", "=", "data", "[", "list", "(", "x", ")", "]", ".", "astype", "(", "int", ")", "\n", "Y", "=", "data", "[", "list", "(", "y", ")", "]", ".", "astype", "(", "int", ")", "\n", "t", "=", "list", "(", "z", ")", "\n", "Z", "=", "data", "[", "t", "]", ".", "astype", "(", "int", ")", "\n", "Z", "=", "Z", ".", "values", ".", "tolist", "(", ")", "\n", "Z", "=", "list", "(", "data", "[", "t", "]", ".", "itertuples", "(", "index", "=", "False", ",", "name", "=", "None", ")", ")", "\n", "Hxz", "=", "entropy", "(", "map", "(", "lambda", "x", ":", "'%s/%s'", "%", "x", ",", "zip", "(", "X", ",", "Z", ")", ")", ")", "# Finding Joint entropy of X and Z", "\n", "Hyz", "=", "entropy", "(", "map", "(", "lambda", "x", ":", "'%s/%s'", "%", "x", ",", "zip", "(", "Y", ",", "Z", ")", ")", ")", "# Finding Joint entropy of Y and Z", "\n", "Hz", "=", "entropy", "(", "Z", ")", "# Finding Entropy of Z", "\n", "Hxyz", "=", "entropy", "(", "map", "(", "lambda", "x", ":", "'%s/%s/%s'", "%", "x", ",", "zip", "(", "X", ",", "Y", ",", "Z", ")", ")", ")", "# Finding Joint Entropy of X, Y and Z", "\n", "return", "Hxz", "+", "Hyz", "-", "Hxyz", "-", "Hz", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.cubic_dgp.CubicDataGeneratingProcess.__init__": [[13, 19], ["dowhy.utils.dgp.DataGeneratingProcess.__init__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "auto_gen", "=", "False", "\n", "\n", "if", "self", ".", "weights", "==", "{", "}", "and", "self", ".", "bias", "==", "{", "}", ":", "\n", "            ", "self", ".", "auto_gen", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.cubic_dgp.CubicDataGeneratingProcess.generate_data": [[20, 59], ["numpy.random.randn", "numpy.random.randn", "numpy.zeros", "numpy.ones", "range", "numpy.mean", "pandas.DataFrame", "len", "len", "cubic_dgp.CubicDataGeneratingProcess.append", "outcome.append", "y_control.append", "y_treatment.append", "weights.append", "bias.append", "cubic_dgp.CubicDataGeneratingProcess.convert_to_binary", "numpy.hstack", "len", "len", "cubic_dgp.CubicDataGeneratingProcess.generation_process", "numpy.matmul", "numpy.random.randn", "numpy.matmul", "numpy.matmul", "numpy.matmul", "len", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.convert_to_binary", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generation_process"], ["", "", "def", "generate_data", "(", "self", ",", "sample_size", ")", ":", "\n", "        ", "self", ".", "weights", "=", "{", "}", "\n", "self", ".", "bias", "=", "{", "}", "\n", "weights", "=", "[", "]", "\n", "bias", "=", "[", "]", "\n", "treatment", "=", "[", "]", "\n", "outcome", "=", "[", "]", "\n", "y_treatment", "=", "[", "]", "\n", "y_control", "=", "[", "]", "\n", "confounder", "=", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "confounder", ")", ")", "\n", "effect_modifier", "=", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "effect_modifier", ")", ")", "\n", "control_value", "=", "np", ".", "zeros", "(", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "treatment_value", "=", "np", ".", "ones", "(", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "CubicDataGeneratingProcess", ".", "POWER", ")", ":", "\n", "            ", "if", "self", ".", "auto_gen", ":", "\n", "                ", "self", ".", "generation_process", "(", ")", "\n", "\n", "", "treatment", ".", "append", "(", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>treatment'", "]", ")", "+", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", "+", "self", ".", "bias", "[", "'confounder=>treatment'", "]", ")", "\n", "outcome", ".", "append", "(", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "treatment", "[", "i", "]", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", ")", "\n", "y_control", ".", "append", "(", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "control_value", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", ")", "\n", "y_treatment", ".", "append", "(", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "treatment_value", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", ")", "\n", "\n", "weights", ".", "append", "(", "self", ".", "weights", ")", "\n", "bias", ".", "append", "(", "self", ".", "bias", ")", "\n", "\n", "", "treatment", "=", "treatment", "[", "0", "]", "*", "treatment", "[", "1", "]", "*", "treatment", "[", "2", "]", "\n", "if", "self", ".", "treatment_is_binary", ":", "\n", "            ", "treatment", "=", "self", ".", "convert_to_binary", "(", "treatment", ")", "\n", "\n", "", "outcome", "=", "outcome", "[", "0", "]", "*", "outcome", "[", "1", "]", "*", "outcome", "[", "2", "]", "\n", "y_control", "=", "y_control", "[", "0", "]", "*", "y_control", "[", "1", "]", "*", "y_control", "[", "2", "]", "\n", "y_treatment", "=", "y_treatment", "[", "0", "]", "*", "y_treatment", "[", "1", "]", "*", "y_treatment", "[", "2", "]", "\n", "self", ".", "true_value", "=", "np", ".", "mean", "(", "y_treatment", "-", "y_control", ",", "axis", "=", "0", ")", "\n", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "bias", "=", "bias", "\n", "\n", "return", "pd", ".", "DataFrame", "(", "np", ".", "hstack", "(", "(", "effect_modifier", ",", "confounder", ",", "treatment", ",", "outcome", ")", ")", ",", "columns", "=", "self", ".", "effect_modifier", "+", "self", ".", "confounder", "+", "self", ".", "treatment", "+", "self", ".", "outcome", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.cubic_dgp.CubicDataGeneratingProcess.generation_process": [[60, 68], ["cubic_dgp.CubicDataGeneratingProcess.generate_weights", "cubic_dgp.CubicDataGeneratingProcess.generate_weights", "cubic_dgp.CubicDataGeneratingProcess.generate_weights", "cubic_dgp.CubicDataGeneratingProcess.generate_weights", "cubic_dgp.CubicDataGeneratingProcess.generate_bias", "cubic_dgp.CubicDataGeneratingProcess.generate_bias", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias"], ["", "def", "generation_process", "(", "self", ")", ":", "\n", "        ", "self", ".", "weights", "[", "'confounder=>treatment'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "confounder", ")", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "self", ".", "weights", "[", "'confounder=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "confounder", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "effect_modifier", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "self", ".", "weights", "[", "'treatment=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "treatment", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "\n", "self", ".", "bias", "[", "'confounder=>treatment'", "]", "=", "self", ".", "generate_bias", "(", "len", "(", "self", ".", "treatment", ")", ")", "\n", "self", ".", "bias", "[", "'confounder=>outcome'", "]", "=", "self", ".", "generate_bias", "(", "len", "(", "self", ".", "outcome", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.cubic_dgp.CubicDataGeneratingProcess.generate_weights": [[69, 71], ["numpy.random.randn"], "methods", ["None"], ["", "def", "generate_weights", "(", "self", ",", "dimensions", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "randn", "(", "*", "dimensions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.cubic_dgp.CubicDataGeneratingProcess.generate_bias": [[72, 74], ["numpy.random.randn"], "methods", ["None"], ["", "def", "generate_bias", "(", "self", ",", "dimensions", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "randn", "(", "dimensions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.cubic_dgp.CubicDataGeneratingProcess.__str__": [[75, 86], ["dowhy.utils.dgp.DataGeneratingProcess.__str__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "rep", "=", "super", "(", ")", ".", "__str__", "(", ")", "\n", "\n", "header", "=", "\"\"\"\n        Cubic Data Generating Process\n        ------------------------------\n        \"\"\"", "\n", "\n", "rep", "=", "header", "+", "rep", "\n", "\n", "return", "rep", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.random_neural_network.RandomNeuralNetwork.__init__": [[19, 36], ["dowhy.utils.dgp.DataGeneratingProcess.__init__", "kwargs.pop", "kwargs.pop", "sklearn.neural_network.MLPRegressor", "sklearn.neural_network.MLPRegressor", "sklearn.neural_network.MLPRegressor", "sklearn.neural_network.MLPRegressor"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''\n        Understanding Architectures in MLP Regressor\n        https://stackoverflow.com/questions/35363530/python-scikit-learn-mlpclassifier-hidden-layer-sizes\n\n        More Information about Random State\n        https://stackoverflow.com/questions/42191717/python-random-state-in-splitting-dataset/42197534\n        https://stats.stackexchange.com/questions/80407/am-i-creating-bias-by-using-the-same-random-seed-over-and-over\n        '''", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "arch", "=", "kwargs", ".", "pop", "(", "'arch'", ",", "RandomNeuralNetwork", ".", "DEFAULT_ARCH_DICT", ")", "\n", "self", ".", "random_state", "=", "kwargs", ".", "pop", "(", "'random_state'", ",", "RandomNeuralNetwork", ".", "RANDOM_STATE", ")", "\n", "self", ".", "nn", "=", "{", "}", "\n", "self", ".", "nn", "[", "'confounder=>treatment'", "]", "=", "MLPRegressor", "(", "random_state", "=", "self", ".", "random_state", ",", "hidden_layer_sizes", "=", "self", ".", "arch", "[", "'confounder=>treatment'", "]", ")", "\n", "self", ".", "nn", "[", "'confounder=>outcome'", "]", "=", "MLPRegressor", "(", "random_state", "=", "self", ".", "random_state", ",", "hidden_layer_sizes", "=", "self", ".", "arch", "[", "'confounder=>outcome'", "]", ")", "\n", "self", ".", "nn", "[", "'effect_modifier=>outcome'", "]", "=", "MLPRegressor", "(", "random_state", "=", "self", ".", "random_state", ",", "hidden_layer_sizes", "=", "self", ".", "arch", "[", "'effect_modifier=>outcome'", "]", ")", "\n", "self", ".", "nn", "[", "'treatment=>outcome'", "]", "=", "MLPRegressor", "(", "random_state", "=", "self", ".", "random_state", ",", "hidden_layer_sizes", "=", "self", ".", "arch", "[", "'treatment=>outcome'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.random_neural_network.RandomNeuralNetwork.generate_data": [[38, 77], ["random_neural_network.RandomNeuralNetwork.generation_process", "numpy.random.randn", "numpy.random.randn", "numpy.zeros", "numpy.ones", "random_neural_network.RandomNeuralNetwork.nn[].predict", "numpy.mean", "pandas.DataFrame", "len", "len", "random_neural_network.RandomNeuralNetwork.convert_to_binary", "numpy.reshape", "random_neural_network.RandomNeuralNetwork.nn[].predict", "random_neural_network.RandomNeuralNetwork.nn[].predict", "random_neural_network.RandomNeuralNetwork.nn[].predict", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.hstack", "len", "len", "random_neural_network.RandomNeuralNetwork.nn[].predict", "random_neural_network.RandomNeuralNetwork.nn[].predict", "numpy.hstack", "random_neural_network.RandomNeuralNetwork.nn[].predict", "random_neural_network.RandomNeuralNetwork.nn[].predict", "numpy.hstack", "random_neural_network.RandomNeuralNetwork.nn[].predict", "random_neural_network.RandomNeuralNetwork.nn[].predict", "numpy.hstack", "random_neural_network.RandomNeuralNetwork.nn.keys", "random_neural_network.RandomNeuralNetwork.nn.keys", "numpy.hstack", "numpy.hstack", "numpy.hstack"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generation_process", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.convert_to_binary", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "def", "generate_data", "(", "self", ",", "sample_size", ")", ":", "\n", "        ", "self", ".", "generation_process", "(", ")", "\n", "confounder", "=", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "confounder", ")", ")", "\n", "effect_modifier", "=", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "effect_modifier", ")", ")", "\n", "control_value", "=", "np", ".", "zeros", "(", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "treatment_value", "=", "np", ".", "ones", "(", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "\n", "treatment", "=", "self", ".", "nn", "[", "'confounder=>treatment'", "]", ".", "predict", "(", "confounder", ")", "\n", "treatment", "=", "treatment", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "if", "self", ".", "treatment_is_binary", ":", "\n", "            ", "treatment", "=", "self", ".", "convert_to_binary", "(", "treatment", ")", "\n", "\n", "", "if", "treatment", ".", "ndim", "==", "1", ":", "\n", "            ", "treatment", "=", "np", ".", "reshape", "(", "treatment", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "", "outcome", "=", "self", ".", "nn", "[", "'confounder=>outcome'", "]", ".", "predict", "(", "np", ".", "hstack", "(", "(", "confounder", ",", "effect_modifier", ")", ")", ")", "+", "self", ".", "nn", "[", "'effect_modifier=>outcome'", "]", ".", "predict", "(", "effect_modifier", ")", "+", "self", ".", "nn", "[", "'treatment=>outcome'", "]", ".", "predict", "(", "np", ".", "hstack", "(", "(", "confounder", ",", "effect_modifier", ",", "treatment", ")", ")", ")", "\n", "y_control", "=", "self", ".", "nn", "[", "'confounder=>outcome'", "]", ".", "predict", "(", "np", ".", "hstack", "(", "(", "confounder", ",", "effect_modifier", ")", ")", ")", "+", "self", ".", "nn", "[", "'effect_modifier=>outcome'", "]", ".", "predict", "(", "effect_modifier", ")", "+", "self", ".", "nn", "[", "'treatment=>outcome'", "]", ".", "predict", "(", "np", ".", "hstack", "(", "(", "confounder", ",", "effect_modifier", ",", "control_value", ")", ")", ")", "\n", "y_treatment", "=", "self", ".", "nn", "[", "'confounder=>outcome'", "]", ".", "predict", "(", "np", ".", "hstack", "(", "(", "confounder", ",", "effect_modifier", ")", ")", ")", "+", "self", ".", "nn", "[", "'effect_modifier=>outcome'", "]", ".", "predict", "(", "effect_modifier", ")", "+", "self", ".", "nn", "[", "'treatment=>outcome'", "]", ".", "predict", "(", "np", ".", "hstack", "(", "(", "confounder", ",", "effect_modifier", ",", "treatment_value", ")", ")", ")", "\n", "\n", "# Understanding Neural Network weights", "\n", "# Refer to this link:https://stackoverflow.com/questions/50937628/mlp-classifier-neurons-weights", "\n", "self", ".", "weights", "=", "{", "key", ":", "self", ".", "nn", "[", "key", "]", ".", "coefs_", "for", "key", "in", "self", ".", "nn", ".", "keys", "(", ")", "}", "\n", "self", ".", "bias", "=", "{", "key", ":", "self", ".", "nn", "[", "key", "]", ".", "intercepts_", "for", "key", "in", "self", ".", "nn", ".", "keys", "(", ")", "}", "\n", "\n", "if", "outcome", ".", "ndim", "==", "1", ":", "\n", "            ", "outcome", "=", "np", ".", "reshape", "(", "outcome", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "", "if", "y_control", ".", "ndim", "==", "1", ":", "\n", "            ", "y_control", "=", "np", ".", "reshape", "(", "y_control", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "", "if", "y_treatment", ".", "ndim", "==", "1", ":", "\n", "            ", "y_treatment", "=", "np", ".", "reshape", "(", "y_treatment", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "", "self", ".", "true_value", "=", "np", ".", "mean", "(", "y_treatment", "-", "y_control", ",", "axis", "=", "0", ")", "\n", "\n", "return", "pd", ".", "DataFrame", "(", "np", ".", "hstack", "(", "(", "effect_modifier", ",", "confounder", ",", "treatment", ",", "outcome", ")", ")", ",", "columns", "=", "self", ".", "effect_modifier", "+", "self", ".", "confounder", "+", "self", ".", "treatment", "+", "self", ".", "outcome", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.random_neural_network.RandomNeuralNetwork.generation_process": [[78, 94], ["numpy.random.randn", "numpy.random.randn", "random_neural_network.RandomNeuralNetwork.nn[].fit", "numpy.random.randn", "numpy.random.randn", "random_neural_network.RandomNeuralNetwork.nn[].fit", "numpy.random.randn", "numpy.random.randn", "random_neural_network.RandomNeuralNetwork.nn[].fit", "numpy.random.randn", "numpy.random.randn", "random_neural_network.RandomNeuralNetwork.nn[].fit", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "generation_process", "(", "self", ")", ":", "\n", "        ", "X", "=", "np", ".", "random", ".", "randn", "(", "RandomNeuralNetwork", ".", "TRAINING_SAMPLE_SIZE", ",", "len", "(", "self", ".", "confounder", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "randn", "(", "RandomNeuralNetwork", ".", "TRAINING_SAMPLE_SIZE", ",", "len", "(", "self", ".", "treatment", ")", ")", "\n", "self", ".", "nn", "[", "'confounder=>treatment'", "]", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "RandomNeuralNetwork", ".", "TRAINING_SAMPLE_SIZE", ",", "len", "(", "self", ".", "confounder", ")", "+", "len", "(", "self", ".", "effect_modifier", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "randn", "(", "RandomNeuralNetwork", ".", "TRAINING_SAMPLE_SIZE", ",", "len", "(", "self", ".", "outcome", ")", ")", "\n", "self", ".", "nn", "[", "'confounder=>outcome'", "]", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "RandomNeuralNetwork", ".", "TRAINING_SAMPLE_SIZE", ",", "len", "(", "self", ".", "effect_modifier", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "randn", "(", "RandomNeuralNetwork", ".", "TRAINING_SAMPLE_SIZE", ",", "len", "(", "self", ".", "outcome", ")", ")", "\n", "self", ".", "nn", "[", "'effect_modifier=>outcome'", "]", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "RandomNeuralNetwork", ".", "TRAINING_SAMPLE_SIZE", ",", "len", "(", "self", ".", "confounder", ")", "+", "len", "(", "self", ".", "effect_modifier", ")", "+", "len", "(", "self", ".", "treatment", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "randn", "(", "RandomNeuralNetwork", ".", "TRAINING_SAMPLE_SIZE", ",", "len", "(", "self", ".", "outcome", ")", ")", "\n", "self", ".", "nn", "[", "'treatment=>outcome'", "]", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.random_neural_network.RandomNeuralNetwork.__str__": [[95, 111], ["dowhy.utils.dgp.DataGeneratingProcess.__str__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "rep", "=", "super", "(", ")", ".", "__str__", "(", ")", "\n", "\n", "header", "=", "\"\"\"\n        Random Neural Network Data Generating Process\n        ---------------------------------------------\n        \"\"\"", "\n", "rep", "+=", "\"\"\"\n        arch:{}\n        nn:{}\n        random_state:{}\n        \"\"\"", ".", "format", "(", "self", ".", "arch", ",", "self", ".", "nn", ",", "self", ".", "random_state", ")", "\n", "\n", "rep", "=", "header", "+", "rep", "\n", "\n", "return", "rep", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.linear_dgp.LinearDataGeneratingProcess.__init__": [[12, 18], ["dowhy.utils.dgp.DataGeneratingProcess.__init__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "auto_gen", "=", "False", "\n", "\n", "if", "self", ".", "weights", "==", "{", "}", "and", "self", ".", "bias", "==", "{", "}", ":", "\n", "            ", "self", ".", "auto_gen", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.linear_dgp.LinearDataGeneratingProcess.generate_data": [[19, 38], ["numpy.zeros", "numpy.ones", "numpy.random.randn", "numpy.zeros", "numpy.mean", "pandas.DataFrame", "linear_dgp.LinearDataGeneratingProcess.generation_process", "len", "linear_dgp.LinearDataGeneratingProcess.convert_to_binary", "numpy.hstack", "len", "len", "len", "numpy.matmul", "numpy.random.randn", "numpy.matmul", "numpy.matmul", "numpy.matmul", "len", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generation_process", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.convert_to_binary"], ["", "", "def", "generate_data", "(", "self", ",", "sample_size", ")", ":", "\n", "        ", "if", "self", ".", "auto_gen", ":", "\n", "            ", "self", ".", "generation_process", "(", ")", "\n", "\n", "", "control_value", "=", "np", ".", "zeros", "(", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "treatment_value", "=", "np", ".", "ones", "(", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "confounder", "=", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "confounder", ")", ")", "\n", "effect_modifier", "=", "np", ".", "zeros", "(", "(", "sample_size", ",", "len", "(", "self", ".", "effect_modifier", ")", ")", ")", "# random.randn", "\n", "\n", "treatment", "=", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>treatment'", "]", ")", "+", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", "+", "self", ".", "bias", "[", "'confounder=>treatment'", "]", "\n", "if", "self", ".", "treatment_is_binary", ":", "\n", "            ", "treatment", "=", "self", ".", "convert_to_binary", "(", "treatment", ")", "\n", "\n", "", "outcome", "=", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "treatment", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", "\n", "y_control", "=", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "control_value", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", "\n", "y_treatment", "=", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "treatment_value", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", "\n", "self", ".", "true_value", "=", "np", ".", "mean", "(", "y_treatment", "-", "y_control", ",", "axis", "=", "0", ")", "\n", "\n", "return", "pd", ".", "DataFrame", "(", "np", ".", "hstack", "(", "(", "effect_modifier", ",", "confounder", ",", "treatment", ",", "outcome", ")", ")", ",", "columns", "=", "self", ".", "effect_modifier", "+", "self", ".", "confounder", "+", "self", ".", "treatment", "+", "self", ".", "outcome", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.linear_dgp.LinearDataGeneratingProcess.generation_process": [[39, 49], ["linear_dgp.LinearDataGeneratingProcess.generate_weights", "linear_dgp.LinearDataGeneratingProcess.generate_weights", "linear_dgp.LinearDataGeneratingProcess.generate_weights", "linear_dgp.LinearDataGeneratingProcess.generate_weights", "linear_dgp.LinearDataGeneratingProcess.generate_bias", "linear_dgp.LinearDataGeneratingProcess.generate_bias", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias"], ["", "def", "generation_process", "(", "self", ")", ":", "\n", "        ", "self", ".", "weights", "[", "'confounder=>treatment'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "confounder", ")", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "self", ".", "weights", "[", "'confounder=>treatment'", "]", "[", "0", ",", "]", "=", "self", ".", "weights", "[", "'confounder=>treatment'", "]", "[", "0", ",", "]", "+", "100", "# increasing weight of the first confounder", "\n", "self", ".", "weights", "[", "'confounder=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "confounder", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "self", ".", "weights", "[", "'confounder=>outcome'", "]", "[", "0", ",", "]", "=", "self", ".", "weights", "[", "'confounder=>outcome'", "]", "[", "0", ",", "]", "+", "100", "\n", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "effect_modifier", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "self", ".", "weights", "[", "'treatment=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "treatment", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "\n", "self", ".", "bias", "[", "'confounder=>treatment'", "]", "=", "self", ".", "generate_bias", "(", "len", "(", "self", ".", "treatment", ")", ")", "\n", "self", ".", "bias", "[", "'confounder=>outcome'", "]", "=", "self", ".", "generate_bias", "(", "len", "(", "self", ".", "outcome", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.linear_dgp.LinearDataGeneratingProcess.generate_weights": [[50, 52], ["numpy.random.randn"], "methods", ["None"], ["", "def", "generate_weights", "(", "self", ",", "dimensions", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "randn", "(", "*", "dimensions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.linear_dgp.LinearDataGeneratingProcess.generate_bias": [[53, 55], ["numpy.random.randn"], "methods", ["None"], ["", "def", "generate_bias", "(", "self", ",", "dimensions", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "randn", "(", "dimensions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.linear_dgp.LinearDataGeneratingProcess.__str__": [[56, 67], ["dowhy.utils.dgp.DataGeneratingProcess.__str__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "rep", "=", "super", "(", ")", ".", "__str__", "(", ")", "\n", "\n", "header", "=", "\"\"\"\n        Linear Data Generating Process\n        -------------------------------\n        \"\"\"", "\n", "\n", "rep", "=", "header", "+", "rep", "\n", "\n", "return", "rep", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.__init__": [[13, 19], ["dowhy.utils.dgp.DataGeneratingProcess.__init__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "auto_gen", "=", "False", "\n", "\n", "if", "self", ".", "weights", "==", "{", "}", "and", "self", ".", "bias", "==", "{", "}", ":", "\n", "            ", "self", ".", "auto_gen", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_data": [[20, 62], ["numpy.random.randn", "numpy.random.randn", "numpy.zeros", "numpy.ones", "quadratic_dgp.QuadraticDataGeneratingProcess.append", "range", "numpy.mean", "pandas.DataFrame", "len", "len", "quadratic_dgp.QuadraticDataGeneratingProcess.generation_process", "outcome.append", "y_control.append", "y_treatment.append", "weights.append", "bias.append", "quadratic_dgp.QuadraticDataGeneratingProcess.convert_to_binary", "numpy.hstack", "len", "len", "quadratic_dgp.QuadraticDataGeneratingProcess.generation_process", "numpy.matmul", "numpy.random.randn", "len", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generation_process", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.dgp.DataGeneratingProcess.convert_to_binary", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generation_process"], ["", "", "def", "generate_data", "(", "self", ",", "sample_size", ")", ":", "\n", "        ", "self", ".", "weights", "=", "{", "}", "\n", "self", ".", "bias", "=", "{", "}", "\n", "weights", "=", "[", "]", "\n", "bias", "=", "[", "]", "\n", "treatment", "=", "[", "]", "\n", "outcome", "=", "[", "]", "\n", "y_treatment", "=", "[", "]", "\n", "y_control", "=", "[", "]", "\n", "confounder", "=", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "confounder", ")", ")", "\n", "effect_modifier", "=", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "effect_modifier", ")", ")", "\n", "control_value", "=", "np", ".", "zeros", "(", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "treatment_value", "=", "np", ".", "ones", "(", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "\n", "\n", "if", "self", ".", "auto_gen", ":", "\n", "            ", "self", ".", "generation_process", "(", ")", "\n", "", "treatment", ".", "append", "(", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>treatment'", "]", ")", "+", "np", ".", "random", ".", "randn", "(", "sample_size", ",", "len", "(", "self", ".", "treatment", ")", ")", "+", "self", ".", "bias", "[", "'confounder=>treatment'", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "QuadraticDataGeneratingProcess", ".", "POWER", ")", ":", "\n", "            ", "outcome", ".", "append", "(", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "treatment", "[", "0", "]", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", ")", "\n", "y_control", ".", "append", "(", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "control_value", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", ")", "\n", "y_treatment", ".", "append", "(", "np", ".", "matmul", "(", "confounder", ",", "self", ".", "weights", "[", "'confounder=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "effect_modifier", ",", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", ")", "+", "np", ".", "matmul", "(", "treatment_value", ",", "self", ".", "weights", "[", "'treatment=>outcome'", "]", ")", "+", "self", ".", "bias", "[", "'confounder=>outcome'", "]", ")", "\n", "\n", "weights", ".", "append", "(", "self", ".", "weights", ")", "\n", "bias", ".", "append", "(", "self", ".", "bias", ")", "\n", "if", "self", ".", "auto_gen", ":", "\n", "                ", "self", ".", "generation_process", "(", ")", "\n", "\n", "", "", "treatment", "=", "treatment", "[", "0", "]", "# treatment[1]", "\n", "if", "self", ".", "treatment_is_binary", ":", "\n", "            ", "treatment", "=", "self", ".", "convert_to_binary", "(", "treatment", ")", "\n", "\n", "", "outcome", "=", "outcome", "[", "0", "]", "*", "outcome", "[", "1", "]", "\n", "y_control", "=", "y_control", "[", "0", "]", "*", "y_control", "[", "1", "]", "\n", "y_treatment", "=", "y_treatment", "[", "0", "]", "*", "y_treatment", "[", "1", "]", "\n", "self", ".", "true_value", "=", "np", ".", "mean", "(", "y_treatment", "-", "y_control", ",", "axis", "=", "0", ")", "\n", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "bias", "=", "bias", "\n", "\n", "return", "pd", ".", "DataFrame", "(", "np", ".", "hstack", "(", "(", "effect_modifier", ",", "confounder", ",", "treatment", ",", "outcome", ")", ")", ",", "columns", "=", "self", ".", "effect_modifier", "+", "self", ".", "confounder", "+", "self", ".", "treatment", "+", "self", ".", "outcome", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generation_process": [[63, 71], ["quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias", "quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias", "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias"], ["", "def", "generation_process", "(", "self", ")", ":", "\n", "        ", "self", ".", "weights", "[", "'confounder=>treatment'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "confounder", ")", ",", "len", "(", "self", ".", "treatment", ")", ")", ")", "\n", "self", ".", "weights", "[", "'confounder=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "confounder", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "self", ".", "weights", "[", "'effect_modifier=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "effect_modifier", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "self", ".", "weights", "[", "'treatment=>outcome'", "]", "=", "self", ".", "generate_weights", "(", "(", "len", "(", "self", ".", "treatment", ")", ",", "len", "(", "self", ".", "outcome", ")", ")", ")", "\n", "\n", "self", ".", "bias", "[", "'confounder=>treatment'", "]", "=", "self", ".", "generate_bias", "(", "len", "(", "self", ".", "treatment", ")", ")", "\n", "self", ".", "bias", "[", "'confounder=>outcome'", "]", "=", "self", ".", "generate_bias", "(", "len", "(", "self", ".", "outcome", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_weights": [[72, 74], ["numpy.random.randn"], "methods", ["None"], ["", "def", "generate_weights", "(", "self", ",", "dimensions", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "randn", "(", "*", "dimensions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.generate_bias": [[75, 77], ["numpy.random.randn"], "methods", ["None"], ["", "def", "generate_bias", "(", "self", ",", "dimensions", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "randn", "(", "dimensions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.dgps.quadratic_dgp.QuadraticDataGeneratingProcess.__str__": [[78, 89], ["dowhy.utils.dgp.DataGeneratingProcess.__str__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "rep", "=", "super", "(", ")", ".", "__str__", "(", ")", "\n", "\n", "header", "=", "\"\"\"\n        Quadratic Data Generating Process\n        ----------------------------------\n        \"\"\"", "\n", "\n", "rep", "=", "header", "+", "rep", "\n", "\n", "return", "rep", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.weighting_sampler.WeightingSampler.__init__": [[7, 24], ["dowhy.do_sampler.DoSampler.__init__", "weighting_sampler.WeightingSampler.logger.info", "weighting_sampler.WeightingSampler.logger.info"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["    ", "def", "__init__", "(", "self", ",", "data", ",", "\n", "*", "args", ",", "params", "=", "None", ",", "\n", "variable_types", "=", "None", ",", "num_cores", "=", "1", ",", "keep_original_treatment", "=", "False", ",", "\n", "causal_model", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        g, df, data_types\n\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "data", ",", "\n", "params", "=", "params", ",", "\n", "variable_types", "=", "variable_types", ",", "num_cores", "=", "num_cores", ",", "\n", "keep_original_treatment", "=", "keep_original_treatment", ",", "\n", "causal_model", "=", "causal_model", ")", "\n", "\n", "self", ".", "logger", ".", "info", "(", "\"Using WeightingSampler for do sampling.\"", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Caution: do samplers assume iid data.\"", ")", "\n", "self", ".", "point_sampler", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.weighting_sampler.WeightingSampler.make_treatment_effective": [[25, 31], ["weighting_sampler.WeightingSampler._df.copy", "x.items"], "methods", ["None"], ["", "def", "make_treatment_effective", "(", "self", ",", "x", ")", ":", "\n", "        ", "to_sample", "=", "self", ".", "_df", ".", "copy", "(", ")", "\n", "if", "not", "self", ".", "keep_original_treatment", ":", "\n", "            ", "for", "treatment", ",", "value", "in", "x", ".", "items", "(", ")", ":", "\n", "                ", "to_sample", "=", "to_sample", "[", "to_sample", "[", "treatment", "]", "==", "value", "]", "\n", "", "", "self", ".", "_df", "=", "to_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.weighting_sampler.WeightingSampler.disrupt_causes": [[32, 38], ["dowhy.utils.propensity_score.state_propensity_score", "weighting_sampler.WeightingSampler.compute_weights", "weighting_sampler.WeightingSampler._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.state_propensity_score", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.compute_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "disrupt_causes", "(", "self", ")", ":", "\n", "        ", "self", ".", "_df", "[", "'propensity_score'", "]", "=", "state_propensity_score", "(", "self", ".", "_data", ",", "\n", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ",", "\n", "self", ".", "_treatment_names", ",", "\n", "variable_types", "=", "self", ".", "_variable_types", ")", "\n", "self", ".", "_df", "[", "'weight'", "]", "=", "self", ".", "compute_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.weighting_sampler.WeightingSampler.sample": [[39, 44], ["weighting_sampler.WeightingSampler._df.sample", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample"], ["", "def", "sample", "(", "self", ")", ":", "\n", "        ", "self", ".", "_df", "=", "self", ".", "_df", ".", "sample", "(", "len", "(", "self", ".", "_data", ")", ",", "\n", "replace", "=", "True", ",", "\n", "weights", "=", "self", ".", "_df", "[", "'weight'", "]", ")", "\n", "self", ".", "_df", ".", "index", "=", "self", ".", "_data", ".", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.weighting_sampler.WeightingSampler.compute_weights": [[45, 48], ["None"], "methods", ["None"], ["", "def", "compute_weights", "(", "self", ")", ":", "\n", "        ", "weights", "=", "1.", "/", "self", ".", "_df", "[", "'propensity_score'", "]", "\n", "return", "weights", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.__init__": [[6, 25], ["dowhy.do_sampler.DoSampler.__init__", "multivariate_weighting_sampler.MultivariateWeightingSampler.logger.info", "multivariate_weighting_sampler.MultivariateWeightingSampler.logger.info"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["    ", "def", "__init__", "(", "self", ",", "data", ",", "\n", "*", "args", ",", "params", "=", "None", ",", "variable_types", "=", "None", ",", "\n", "num_cores", "=", "1", ",", "keep_original_treatment", "=", "False", ",", "\n", "causal_model", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        g, df, data_types\n\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "data", ",", "\n", "params", "=", "params", ",", "\n", "variable_types", "=", "variable_types", ",", "num_cores", "=", "num_cores", ",", "\n", "keep_original_treatment", "=", "keep_original_treatment", ",", "\n", "causal_model", "=", "causal_model", ")", "\n", "\n", "self", ".", "logger", ".", "info", "(", "\"Using MultivariateWeightingSampler for do sampling.\"", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Caution: do samplers assume iid data.\"", ")", "\n", "\n", "self", ".", "point_sampler", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.make_treatment_effective": [[26, 32], ["multivariate_weighting_sampler.MultivariateWeightingSampler._df.copy", "x.items"], "methods", ["None"], ["", "def", "make_treatment_effective", "(", "self", ",", "x", ")", ":", "\n", "        ", "to_sample", "=", "self", ".", "_df", ".", "copy", "(", ")", "\n", "if", "not", "self", ".", "keep_original_treatment", ":", "\n", "            ", "for", "treatment", ",", "value", "in", "x", ".", "items", "(", ")", ":", "\n", "                ", "to_sample", "=", "to_sample", "[", "to_sample", "[", "treatment", "]", "==", "value", "]", "\n", "", "", "self", ".", "_df", "=", "to_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.disrupt_causes": [[33, 39], ["dowhy.utils.propensity_score.state_propensity_score", "multivariate_weighting_sampler.MultivariateWeightingSampler.compute_weights", "multivariate_weighting_sampler.MultivariateWeightingSampler._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.propensity_score.state_propensity_score", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.compute_weights", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "disrupt_causes", "(", "self", ")", ":", "\n", "        ", "self", ".", "_df", "[", "'state_propensity'", "]", "=", "state_propensity_score", "(", "self", ".", "_data", ",", "\n", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ",", "\n", "self", ".", "_treatment_names", ",", "\n", "variable_types", "=", "self", ".", "_variable_types", ")", "\n", "self", ".", "_df", "[", "'weight'", "]", "=", "self", ".", "compute_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample": [[40, 43], ["multivariate_weighting_sampler.MultivariateWeightingSampler._df.sample", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample"], ["", "def", "sample", "(", "self", ")", ":", "\n", "        ", "self", ".", "_df", "=", "self", ".", "_df", ".", "sample", "(", "len", "(", "self", ".", "_data", ")", ",", "replace", "=", "True", ",", "weights", "=", "self", ".", "_df", "[", "'weight'", "]", ")", "\n", "self", ".", "_df", ".", "index", "=", "self", ".", "_data", ".", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.compute_weights": [[44, 47], ["None"], "methods", ["None"], ["", "def", "compute_weights", "(", "self", ")", ":", "\n", "        ", "weights", "=", "1.", "/", "self", ".", "_df", "[", "'state_propensity'", "]", "\n", "return", "weights", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.__init__": [[8, 28], ["dowhy.do_sampler.DoSampler.__init__", "mcmc_sampler.McmcSampler.logger.info", "mcmc_sampler.McmcSampler._construct_sampler", "causal_model._graph.get_unconfounded_observed_subgraph", "networkx.DiGraph", "mcmc_sampler.McmcSampler.fit_causal_model"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelDensitySampler._construct_sampler", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_unconfounded_observed_subgraph", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.fit_causal_model"], ["    ", "def", "__init__", "(", "self", ",", "data", ",", "*", "args", ",", "params", "=", "None", ",", "variable_types", "=", "None", ",", "\n", "num_cores", "=", "1", ",", "keep_original_treatment", "=", "False", ",", "\n", "causal_model", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        g, df, data_types\n\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "data", ",", "params", "=", "params", ",", "variable_types", "=", "variable_types", ",", "causal_model", "=", "causal_model", ",", "\n", "num_cores", "=", "num_cores", ",", "keep_original_treatment", "=", "keep_original_treatment", ")", "\n", "\n", "self", ".", "logger", ".", "info", "(", "\"Using McmcSampler for do sampling.\"", ")", "\n", "self", ".", "point_sampler", "=", "False", "\n", "self", ".", "sampler", "=", "self", ".", "_construct_sampler", "(", ")", "\n", "\n", "self", ".", "g", "=", "causal_model", ".", "_graph", ".", "get_unconfounded_observed_subgraph", "(", ")", "\n", "g_fit", "=", "nx", ".", "DiGraph", "(", "self", ".", "g", ")", "\n", "_", ",", "self", ".", "fit_trace", "=", "self", ".", "fit_causal_model", "(", "g_fit", ",", "\n", "self", ".", "_data", ",", "\n", "self", ".", "_variable_types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_data_types": [[29, 33], ["networkx.topological_sort", "g.nodes"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes"], ["", "def", "apply_data_types", "(", "self", ",", "g", ",", "data_types", ")", ":", "\n", "        ", "for", "node", "in", "nx", ".", "topological_sort", "(", "g", ")", ":", "\n", "            ", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"variable_type\"", "]", "=", "data_types", "[", "node", "]", "\n", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_parents": [[34, 39], ["networkx.topological_sort", "[].get", "g.nodes", "g.in_edges", "g.nodes"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes"], ["", "def", "apply_parents", "(", "self", ",", "g", ")", ":", "\n", "        ", "for", "node", "in", "nx", ".", "topological_sort", "(", "g", ")", ":", "\n", "            ", "if", "not", "g", ".", "nodes", "(", ")", "[", "node", "]", ".", "get", "(", "\"parent_names\"", ")", ":", "\n", "                ", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"parent_names\"", "]", "=", "[", "parent", "for", "parent", ",", "_", "in", "g", ".", "in_edges", "(", "node", ")", "]", "\n", "", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_parameters": [[40, 56], ["networkx.topological_sort", "pymc3.Normal", "pymc3.Exponential", "g.nodes", "numpy.array", "numpy.array", "df[].std", "initialization_trace[].mean", "initialization_trace[].mean", "initialization_trace[].std", "g.nodes", "g.nodes", "len", "df[].std", "df[].std", "df[].std", "df[].std", "df[].std", "df[].std"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes"], ["", "def", "apply_parameters", "(", "self", ",", "g", ",", "df", ",", "initialization_trace", "=", "None", ")", ":", "\n", "        ", "for", "node", "in", "nx", ".", "topological_sort", "(", "g", ")", ":", "\n", "            ", "parent_names", "=", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"parent_names\"", "]", "\n", "if", "parent_names", ":", "\n", "                ", "if", "not", "initialization_trace", ":", "\n", "                    ", "sd", "=", "np", ".", "array", "(", "[", "df", "[", "node", "]", ".", "std", "(", ")", "]", "+", "(", "df", "[", "node", "]", ".", "std", "(", ")", "/", "df", "[", "parent_names", "]", ".", "std", "(", ")", ")", ".", "tolist", "(", ")", ")", "\n", "mu", "=", "np", ".", "array", "(", "[", "df", "[", "node", "]", ".", "std", "(", ")", "]", "+", "(", "df", "[", "node", "]", ".", "std", "(", ")", "/", "df", "[", "parent_names", "]", ".", "std", "(", ")", ")", ".", "tolist", "(", ")", ")", "\n", "node_sd", "=", "df", "[", "node", "]", ".", "std", "(", ")", "\n", "", "else", ":", "\n", "                    ", "node_sd", "=", "initialization_trace", "[", "\"{}_sd\"", ".", "format", "(", "node", ")", "]", ".", "mean", "(", ")", "\n", "mu", "=", "initialization_trace", "[", "\"beta_{}\"", ".", "format", "(", "node", ")", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "sd", "=", "initialization_trace", "[", "\"beta_{}\"", ".", "format", "(", "node", ")", "]", ".", "std", "(", "axis", "=", "0", ")", "\n", "", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"parameters\"", "]", "=", "pm", ".", "Normal", "(", "\"beta_{}\"", ".", "format", "(", "node", ")", ",", "mu", "=", "mu", ",", "sd", "=", "sd", ",", "\n", "shape", "=", "len", "(", "parent_names", ")", "+", "1", ")", "\n", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"sd\"", "]", "=", "pm", ".", "Exponential", "(", "\"{}_sd\"", ".", "format", "(", "node", ")", ",", "lam", "=", "node_sd", ")", "\n", "", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.build_bayesian_network": [[57, 75], ["networkx.topological_sort", "pymc3.math.dot", "g.nodes", "pymc3.Normal", "pymc3.Bernoulli", "Exception", "g.nodes", "g.nodes", "g.nodes", "g.nodes", "g.nodes", "g.nodes", "g.nodes", "g.nodes", "g.nodes"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes"], ["", "def", "build_bayesian_network", "(", "self", ",", "g", ",", "df", ")", ":", "\n", "        ", "for", "node", "in", "nx", ".", "topological_sort", "(", "g", ")", ":", "\n", "            ", "if", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"parent_names\"", "]", ":", "\n", "                ", "mu", "=", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"parameters\"", "]", "[", "0", "]", "# intercept", "\n", "mu", "+=", "pm", ".", "math", ".", "dot", "(", "df", "[", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"parent_names\"", "]", "]", ",", "\n", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"parameters\"", "]", "[", "1", ":", "]", ")", "\n", "if", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"variable_type\"", "]", "==", "'c'", ":", "\n", "                    ", "sd", "=", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"sd\"", "]", "\n", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"variable\"", "]", "=", "pm", ".", "Normal", "(", "\"{}\"", ".", "format", "(", "node", ")", ",", "\n", "mu", "=", "mu", ",", "sd", "=", "sd", ",", "\n", "observed", "=", "df", "[", "node", "]", ")", "\n", "", "elif", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"variable_type\"", "]", "==", "'b'", ":", "\n", "                    ", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"variable\"", "]", "=", "pm", ".", "Bernoulli", "(", "\"{}\"", ".", "format", "(", "node", ")", ",", "\n", "logit_p", "=", "mu", ",", "\n", "observed", "=", "df", "[", "node", "]", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "Exception", "(", "\"Unrecognized variable type: {}\"", ".", "format", "(", "g", ".", "nodes", "(", ")", "[", "node", "]", "[", "\"variable_type\"", "]", ")", ")", "\n", "", "", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.fit_causal_model": [[76, 87], ["networkx.is_directed_acyclic_graph", "Exception", "pymc3.Model", "mcmc_sampler.McmcSampler.apply_data_types", "mcmc_sampler.McmcSampler.apply_parents", "mcmc_sampler.McmcSampler.apply_parameters", "mcmc_sampler.McmcSampler.build_bayesian_network", "pymc3.sample"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_data_types", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_parents", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_parameters", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.build_bayesian_network", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample"], ["", "def", "fit_causal_model", "(", "self", ",", "g", ",", "df", ",", "data_types", ",", "initialization_trace", "=", "None", ")", ":", "\n", "        ", "if", "nx", ".", "is_directed_acyclic_graph", "(", "g", ")", ":", "\n", "            ", "with", "pm", ".", "Model", "(", ")", "as", "model", ":", "\n", "                ", "g", "=", "self", ".", "apply_data_types", "(", "g", ",", "data_types", ")", "\n", "g", "=", "self", ".", "apply_parents", "(", "g", ")", "\n", "g", "=", "self", ".", "apply_parameters", "(", "g", ",", "df", ",", "initialization_trace", "=", "initialization_trace", ")", "\n", "g", "=", "self", ".", "build_bayesian_network", "(", "g", ",", "df", ")", "\n", "trace", "=", "pm", ".", "sample", "(", "1000", ",", "tune", "=", "1000", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Graph is not a DAG!\"", ")", "\n", "", "return", "g", ",", "trace", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.sample_prior_causal_model": [[88, 99], ["networkx.is_directed_acyclic_graph", "Exception", "pymc3.Model", "mcmc_sampler.McmcSampler.apply_data_types", "mcmc_sampler.McmcSampler.apply_parents", "mcmc_sampler.McmcSampler.apply_parameters", "mcmc_sampler.McmcSampler.build_bayesian_network", "pymc3.sample_prior_predictive"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_data_types", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_parents", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.apply_parameters", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.build_bayesian_network"], ["", "def", "sample_prior_causal_model", "(", "self", ",", "g", ",", "df", ",", "data_types", ",", "initialization_trace", ")", ":", "\n", "        ", "if", "nx", ".", "is_directed_acyclic_graph", "(", "g", ")", ":", "\n", "            ", "with", "pm", ".", "Model", "(", ")", "as", "model", ":", "\n", "                ", "g", "=", "self", ".", "apply_data_types", "(", "g", ",", "data_types", ")", "\n", "g", "=", "self", ".", "apply_parents", "(", "g", ")", "\n", "g", "=", "self", ".", "apply_parameters", "(", "g", ",", "df", ",", "initialization_trace", "=", "initialization_trace", ")", "\n", "g", "=", "self", ".", "build_bayesian_network", "(", "g", ",", "df", ")", "\n", "trace", "=", "pm", ".", "sample_prior_predictive", "(", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Graph is not a DAG!\"", ")", "\n", "", "return", "g", ",", "trace", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.do_x_surgery": [[100, 105], ["x.keys", "g.remove_edges_from", "g.nodes", "g.in_edges"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes"], ["", "def", "do_x_surgery", "(", "self", ",", "g", ",", "x", ")", ":", "\n", "        ", "for", "xi", "in", "x", ".", "keys", "(", ")", ":", "\n", "            ", "g", ".", "remove_edges_from", "(", "[", "(", "parent", ",", "child", ")", "for", "(", "parent", ",", "child", ")", "in", "g", ".", "in_edges", "(", "xi", ")", "]", ")", "\n", "g", ".", "nodes", "(", ")", "[", "xi", "]", "[", "\"parent_names\"", "]", "=", "[", "]", "\n", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.make_intervention_effective": [[106, 111], ["x.items"], "methods", ["None"], ["", "def", "make_intervention_effective", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "not", "self", ".", "keep_original_treatment", ":", "\n", "            ", "for", "k", ",", "v", "in", "x", ".", "items", "(", ")", ":", "\n", "                ", "self", ".", "_df", "[", "k", "]", "=", "v", "\n", "", "", "return", "self", ".", "_df", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.do_sample": [[112, 125], ["mcmc_sampler.McmcSampler.reset", "networkx.DiGraph", "mcmc_sampler.McmcSampler.do_x_surgery", "mcmc_sampler.McmcSampler.make_intervention_effective", "mcmc_sampler.McmcSampler.sample_prior_causal_model", "mcmc_sampler.McmcSampler._df.copy"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.reset", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.do_x_surgery", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.make_intervention_effective", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.sample_prior_causal_model"], ["", "def", "do_sample", "(", "self", ",", "x", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "g_for_surgery", "=", "nx", ".", "DiGraph", "(", "self", ".", "g", ")", "\n", "g_modified", "=", "self", ".", "do_x_surgery", "(", "g_for_surgery", ",", "x", ")", "\n", "self", ".", "_df", "=", "self", ".", "make_intervention_effective", "(", "x", ")", "\n", "g_modified", ",", "trace", "=", "self", ".", "sample_prior_causal_model", "(", "g_modified", ",", "\n", "self", ".", "_df", ",", "\n", "self", ".", "_variable_types", ",", "\n", "initialization_trace", "=", "self", ".", "fit_trace", ")", "\n", "for", "col", "in", "self", ".", "_df", ":", "\n", "            ", "if", "col", "in", "trace", "and", "col", "not", "in", "self", ".", "_treatment_names", ":", "\n", "                ", "self", ".", "_df", "[", "col", "]", "=", "trace", "[", "col", "]", "\n", "", "", "return", "self", ".", "_df", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler._construct_sampler": [[126, 128], ["None"], "methods", ["None"], ["", "def", "_construct_sampler", "(", "self", ")", ":", "\n", "        ", "pass", "", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.__init__.get_class_object": [[8, 22], ["string.capwords().replace", "importlib.import_module", "getattr", "issubclass", "ImportError", "string.capwords", "isinstance"], "function", ["None"], ["# Loading version number", "\n", "with", "open", "(", "path", ".", "join", "(", "here", ",", "'VERSION'", ")", ")", "as", "version_file", ":", "\n", "    ", "__version__", "=", "version_file", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelDensitySampler.__init__": [[8, 24], ["dowhy.do_sampler.DoSampler.__init__", "kernel_density_sampler.KernelDensitySampler.logger.info", "kernel_density_sampler.KernelDensitySampler._construct_sampler", "statsmodels.nonparametric.kernel_density.EstimatorSettings", "statsmodels.nonparametric.kernel_density.EstimatorSettings", "kernel_density_sampler.KernelDensitySampler._variable_types.values", "len", "max", "len", "len", "kernel_density_sampler.KernelDensitySampler._target_estimand.get_backdoor_variables", "kernel_density_sampler.KernelDensitySampler._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelDensitySampler._construct_sampler", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "\n", "self", ".", "logger", ".", "info", "(", "\"Using KernelDensitySampler for do sampling.\"", ")", "\n", "if", "len", "(", "self", ".", "_data", ")", ">", "300", "or", "max", "(", "len", "(", "self", ".", "_treatment_names", "+", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ")", ",", "len", "(", "self", ".", "_outcome_names", "+", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ")", ")", ">=", "3", ":", "\n", "            ", "self", ".", "defaults", "=", "EstimatorSettings", "(", "n_jobs", "=", "4", ",", "efficient", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "defaults", "=", "EstimatorSettings", "(", "n_jobs", "=", "-", "1", ",", "efficient", "=", "False", ")", "\n", "\n", "", "if", "'c'", "not", "in", "self", ".", "_variable_types", ".", "values", "(", ")", ":", "\n", "            ", "self", ".", "bw", "=", "'cv_ml'", "\n", "", "else", ":", "\n", "            ", "self", ".", "bw", "=", "'normal_reference'", "\n", "\n", "", "self", ".", "sampler", "=", "self", ".", "_construct_sampler", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelDensitySampler._fit_conditional": [[25, 32], ["statsmodels.nonparametric.kernel_density.KDEMultivariateConditional", "kernel_density_sampler.KernelDensitySampler._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "_fit_conditional", "(", "self", ")", ":", "\n", "        ", "self", ".", "conditional_density", "=", "KDEMultivariateConditional", "(", "endog", "=", "self", ".", "_data", "[", "self", ".", "_outcome_names", "]", ",", "\n", "exog", "=", "self", ".", "_data", "[", "self", ".", "_treatment_names", "+", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "]", ",", "\n", "dep_type", "=", "''", ".", "join", "(", "self", ".", "dep_type", ")", ",", "\n", "indep_type", "=", "''", ".", "join", "(", "self", ".", "indep_type", ")", ",", "\n", "bw", "=", "self", ".", "bw", ",", "\n", "defaults", "=", "self", ".", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelDensitySampler._infer_variable_types": [[33, 35], ["Exception"], "methods", ["None"], ["", "def", "_infer_variable_types", "(", "self", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Variable type inference not implemented. Specify variable_types={var_name: var_type}, \"", "\n", "\"where var_type is 'o', 'c', or 'd' for ordered, continuous, or discrete, respectively.\"", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelDensitySampler._construct_sampler": [[37, 41], ["kernel_density_sampler.KernelSampler", "kernel_density_sampler.KernelDensitySampler._target_estimand.get_backdoor_variables"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables"], ["", "def", "_construct_sampler", "(", "self", ")", ":", "\n", "        ", "return", "KernelSampler", "(", "self", ".", "outcome_upper_support", ",", "self", ".", "outcome_lower_support", ",", "self", ".", "_outcome_names", ",", "self", ".", "_treatment_names", ",", "\n", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", ",", "self", ".", "_data", ",", "self", ".", "dep_type", ",", "self", ".", "indep_type", ",", "\n", "self", ".", "bw", ",", "self", ".", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelSampler.__init__": [[46, 64], ["statsmodels.nonparametric.kernel_density.KDEMultivariateConditional"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "outcome_upper_support", ",", "outcome_lower_support", ",", "outcome_names", ",", "treatment_names", ",", "backdoor_variables", ",", "\n", "data", ",", "dep_type", ",", "indep_type", ",", "bw", ",", "defaults", ")", ":", "\n", "        ", "self", ".", "_data", "=", "data", "\n", "self", ".", "_outcome_names", "=", "outcome_names", "\n", "self", ".", "_treatment_names", "=", "treatment_names", "\n", "self", ".", "_backdoor_variables", "=", "backdoor_variables", "\n", "self", ".", "dep_type", "=", "dep_type", "\n", "self", ".", "indep_type", "=", "indep_type", "\n", "self", ".", "bw", "=", "bw", "\n", "self", ".", "defaults", "=", "defaults", "\n", "self", ".", "outcome_lower_support", "=", "outcome_lower_support", "\n", "self", ".", "outcome_upper_support", "=", "outcome_upper_support", "\n", "self", ".", "conditional_density", "=", "KDEMultivariateConditional", "(", "endog", "=", "self", ".", "_data", "[", "self", ".", "_outcome_names", "]", ",", "\n", "exog", "=", "self", ".", "_data", "[", "self", ".", "_treatment_names", "+", "self", ".", "_backdoor_variables", "]", ",", "\n", "dep_type", "=", "''", ".", "join", "(", "self", ".", "dep_type", ")", ",", "\n", "indep_type", "=", "''", ".", "join", "(", "self", ".", "indep_type", ")", ",", "\n", "bw", "=", "self", ".", "bw", ",", "\n", "defaults", "=", "self", ".", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelSampler.sample_point": [[65, 90], ["numpy.meshgrid", "numpy.repeat().reshape", "kernel_density_sampler.KernelSampler._evaluate_cdf", "numpy.hstack", "numpy.vstack", "scipy.interpolate.interp1d", "numpy.random.rand", "numpy.ceil", "numpy.linspace", "numpy.array().reshape", "len", "len", "numpy.hstack.flatten", "numpy.vstack.flatten", "scipy.interpolate.interp1d.", "kernel_density_sampler.KernelSampler._data[].std", "kernel_density_sampler.KernelSampler._data[].count", "range", "len", "numpy.int", "numpy.repeat", "kernel_density_sampler.KernelSampler.sample_point", "len", "numpy.array", "len", "n.cumprod"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelSampler._evaluate_cdf", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelSampler.sample_point"], ["", "def", "sample_point", "(", "self", ",", "x_z", ")", ":", "\n", "        ", "y_bw", "=", "1.06", "*", "self", ".", "_data", "[", "self", ".", "_outcome_names", "]", ".", "std", "(", ")", "*", "(", "self", ".", "_data", "[", "self", ".", "_outcome_names", "]", ".", "count", "(", ")", ")", "**", "(", "\n", "-", "1.", "/", "5.", ")", "\n", "n", "=", "5", "*", "np", ".", "ceil", "(", "(", "self", ".", "outcome_upper_support", "-", "self", ".", "outcome_lower_support", ")", "/", "y_bw", ")", "\n", "cum_ranges", "=", "[", "np", ".", "linspace", "(", "self", ".", "outcome_lower_support", "[", "i", "]", ",", "\n", "self", ".", "outcome_upper_support", "[", "i", "]", ",", "\n", "n", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "self", ".", "_outcome_names", ")", ")", "]", "\n", "\n", "res", "=", "np", ".", "meshgrid", "(", "*", "cum_ranges", ")", "\n", "points", "=", "np", ".", "array", "(", "res", ")", ".", "reshape", "(", "len", "(", "self", ".", "_outcome_names", ")", ",", "np", ".", "int", "(", "n", ".", "cumprod", "(", ")", "[", "-", "1", "]", ")", ")", ".", "T", "\n", "\n", "x_z_repeated", "=", "np", ".", "repeat", "(", "x_z", ",", "len", "(", "points", ")", ")", ".", "reshape", "(", "len", "(", "points", ")", ",", "len", "(", "x_z", ")", ")", "\n", "cdf_vals", "=", "self", ".", "_evaluate_cdf", "(", "points", ",", "x_z_repeated", ")", "\n", "cdf_vals", "=", "np", ".", "hstack", "(", "[", "[", "0.", "]", ",", "\n", "cdf_vals", ",", "\n", "[", "1.", "]", "]", ")", "\n", "points", "=", "np", ".", "vstack", "(", "[", "[", "self", ".", "outcome_lower_support", "-", "3.", "*", "y_bw", "]", ",", "\n", "points", ",", "\n", "[", "self", ".", "outcome_upper_support", "+", "3.", "*", "y_bw", "]", "]", ")", "\n", "inv_cdf", "=", "interp1d", "(", "cdf_vals", ".", "flatten", "(", ")", ",", "points", ".", "flatten", "(", ")", ",", "fill_value", "=", "0.", ",", "axis", "=", "0", ")", "\n", "r", "=", "np", ".", "random", ".", "rand", "(", ")", "\n", "try", ":", "\n", "            ", "return", "inv_cdf", "(", "r", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "return", "self", ".", "sample_point", "(", "x_z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.kernel_density_sampler.KernelSampler._evaluate_cdf": [[91, 93], ["kernel_density_sampler.KernelSampler.conditional_density.cdf"], "methods", ["None"], ["", "", "def", "_evaluate_cdf", "(", "self", ",", "y", ",", "x_z", ")", ":", "\n", "        ", "return", "self", ".", "conditional_density", ".", "cdf", "(", "endog_predict", "=", "[", "y", "]", ",", "exog_predict", "=", "x_z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.__init__": [[10, 27], ["logging.getLogger"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data", ",", "method_name_discrete", "=", "\"conditional_mutual_information\"", ",", "method_name_continuous", "=", "\"partial_correlation\"", ")", ":", "\n", "        ", "\"\"\"\n        Initialize data for graph refutation\n\n        :param data:input dataset\n        :param method_name_discrete: name of method for testing conditional independence in discrete data\n        :param method_name_continuous: name of method for testing conditional independece in continuous data\n        :returns : instance of GraphRefutation class\n        \"\"\"", "\n", "self", ".", "_refutation_passed", "=", "None", "\n", "self", ".", "_data", "=", "data", "\n", "self", ".", "_method_name_discrete", "=", "method_name_discrete", "\n", "self", ".", "_method_name_continuous", "=", "method_name_continuous", "\n", "self", ".", "_false_implications", "=", "[", "]", "#List containing the implications from the graph which hold false for dataset", "\n", "self", ".", "_true_implications", "=", "[", "]", "#List containing the implications from the graph which hold true for dataset", "\n", "self", ".", "_results", "=", "{", "}", "#A dictionary with key as test set and value as [p-value, test_result]", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.set_refutation_result": [[28, 39], ["len", "len", "graph_refuter.GraphRefuter.logger.warn", "len"], "methods", ["None"], ["", "def", "set_refutation_result", "(", "self", ",", "number_of_constraints_model", ")", ":", "\n", "        ", "\"\"\"\n        Method to set the result for graph refutation. Set true if there are no false implications else false\n        \"\"\"", "\n", "if", "(", "len", "(", "self", ".", "_true_implications", ")", ")", "==", "number_of_constraints_model", ":", "\n", "            ", "self", ".", "_refutation_passed", "=", "True", "\n", "", "elif", "len", "(", "self", ".", "_false_implications", ")", "==", "0", ":", "\n", "            ", "self", ".", "_refutation_passed", "=", "True", "\n", "self", ".", "logger", ".", "warn", "(", "\"Some tests could not be run : config not supported\"", ")", "\n", "", "elif", "len", "(", "self", ".", "_false_implications", ")", ">", "0", ":", "\n", "            ", "self", ".", "_refutation_passed", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.partial_correlation": [[40, 51], ["dowhy.utils.cit.partial_corr", "graph_refuter.GraphRefuter._false_implications.append", "graph_refuter.GraphRefuter._true_implications.append", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.partial_corr"], ["", "", "def", "partial_correlation", "(", "self", ",", "x", "=", "None", ",", "y", "=", "None", ",", "z", "=", "None", ")", ":", "\n", "        ", "stats", "=", "partial_corr", "(", "data", "=", "self", ".", "_data", ",", "x", "=", "x", ",", "y", "=", "y", ",", "z", "=", "list", "(", "z", ")", ")", "\n", "p_value", "=", "stats", "[", "'p-val'", "]", "\n", "key", "=", "(", "(", "x", ",", "y", ")", "+", "(", "z", ",", ")", ")", "\n", "if", "(", "p_value", "<", "0.05", ")", ":", "\n", "#Reject H0", "\n", "            ", "self", ".", "_false_implications", ".", "append", "(", "[", "x", ",", "y", ",", "z", "]", ")", "\n", "self", ".", "_results", "[", "key", "]", "=", "[", "p_value", ",", "False", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "_true_implications", ".", "append", "(", "[", "x", ",", "y", ",", "z", "]", ")", "\n", "self", ".", "_results", "[", "key", "]", "=", "[", "p_value", ",", "True", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.conditional_mutual_information": [[52, 61], ["dowhy.utils.cit.conditional_MI", "graph_refuter.GraphRefuter._true_implications.append", "graph_refuter.GraphRefuter._false_implications.append", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.conditional_MI"], ["", "", "def", "conditional_mutual_information", "(", "self", ",", "x", "=", "None", ",", "y", "=", "None", ",", "z", "=", "None", ")", ":", "\n", "         ", "cmi_val", "=", "conditional_MI", "(", "data", "=", "self", ".", "_data", ",", "x", "=", "x", ",", "y", "=", "y", ",", "z", "=", "list", "(", "z", ")", ")", "\n", "key", "=", "(", "(", "x", ",", "y", ")", "+", "(", "z", ",", ")", ")", "\n", "if", "(", "cmi_val", "<=", "0.05", ")", ":", "\n", "            ", "self", ".", "_true_implications", ".", "append", "(", "[", "x", ",", "y", ",", "z", "]", ")", "\n", "self", ".", "_results", "[", "key", "]", "=", "[", "cmi_val", ",", "True", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "_false_implications", ".", "append", "(", "[", "x", ",", "y", ",", "z", "]", ")", "\n", "self", ".", "_results", "[", "key", "]", "=", "[", "cmi_val", ",", "False", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.refute_model": [[62, 128], ["graph_refuter.GraphRefutation", "list", "dict", "graph_refuter.GraphRefuter.set_refutation_result", "graph_refuter.GraphRefutation.add_conditional_independence_test_result", "discrete_columns.append", "graph_refuter.GraphRefuter._data[].isin().all", "continuous_columns.append", "all", "len", "len", "len", "binary_columns.append", "graph_refuter.GraphRefuter.partial_correlation", "graph_refuter.GraphRefuter.logger.error", "all", "graph_refuter.GraphRefuter._data[].isin", "graph_refuter.GraphRefuter.conditional_mutual_information", "graph_refuter.GraphRefuter.logger.error", "all", "graph_refuter.GraphRefuter.partial_correlation", "all", "graph_refuter.GraphRefuter.conditional_mutual_information", "graph_refuter.GraphRefuter.conditional_mutual_information", "print", "variable_types_c.append"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.set_refutation_result", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefutation.add_conditional_independence_test_result", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.partial_correlation", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.conditional_mutual_information", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.partial_correlation", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.conditional_mutual_information", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefuter.conditional_mutual_information"], ["", "", "def", "refute_model", "(", "self", ",", "independence_constraints", ")", ":", "\n", "        ", "\"\"\"\n        Method to test conditional independence using the graph refutation object on the given testing set\n\n        :param independence_constraints: List of implications to test the conditional independence on\n        :returns : GraphRefutation object\n        \"\"\"", "\n", "\n", "refute", "=", "GraphRefutation", "(", "method_name_continuous", "=", "self", ".", "_method_name_continuous", ",", "method_name_discrete", "=", "self", ".", "_method_name_discrete", ")", "\n", "\n", "all_nodes", "=", "list", "(", "self", ".", "_data", ".", "columns", ".", "values", ")", "\n", "discrete_columns", "=", "[", "]", "\n", "continuous_columns", "=", "[", "]", "\n", "binary_columns", "=", "[", "]", "\n", "variable_type", "=", "dict", "(", ")", "\n", "for", "node", "in", "all_nodes", ":", "\n", "            ", "if", "self", ".", "_data", "[", "node", "]", ".", "dtype", "==", "np", ".", "int64", "or", "self", ".", "_data", "[", "node", "]", ".", "dtype", "==", "np", ".", "int32", ":", "\n", "                ", "discrete_columns", ".", "append", "(", "node", ")", "\n", "variable_type", "[", "node", "]", "=", "\"discrete\"", "\n", "if", "self", ".", "_data", "[", "node", "]", ".", "isin", "(", "[", "0", ",", "1", "]", ")", ".", "all", "(", ")", ":", "\n", "                    ", "binary_columns", ".", "append", "(", "node", ")", "\n", "variable_type", "[", "node", "]", "=", "\"binary\"", "\n", "", "", "else", ":", "\n", "                ", "continuous_columns", ".", "append", "(", "node", ")", "\n", "variable_type", "[", "node", "]", "=", "\"continuous\"", "\n", "", "", "for", "a", ",", "b", ",", "c", "in", "independence_constraints", ":", "\n", "            ", "if", "a", "in", "continuous_columns", "and", "b", "in", "continuous_columns", "and", "all", "(", "node", "in", "continuous_columns", "for", "node", "in", "c", ")", ":", "\n", "# a, b and c are all continuous variables", "\n", "                ", "if", "self", ".", "_method_name_continuous", "is", "None", "or", "self", ".", "_method_name_continuous", "==", "\"partial_correlation\"", ":", "\n", "                    ", "self", ".", "partial_correlation", "(", "x", "=", "a", ",", "y", "=", "b", ",", "z", "=", "c", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "logger", ".", "error", "(", "\"Invalid conditional independence test for continuous data. Supported tests - partial_correlation\"", ")", "\n", "\n", "", "", "elif", "a", "in", "discrete_columns", "and", "b", "in", "discrete_columns", "and", "all", "(", "node", "in", "discrete_columns", "for", "node", "in", "c", ")", ":", "\n", "# a, b and c are all discrete variables", "\n", "                ", "if", "self", ".", "_method_name_discrete", "is", "None", "or", "self", ".", "_method_name_discrete", "==", "\"conditional_mutual_information\"", ":", "\n", "                    ", "self", ".", "conditional_mutual_information", "(", "x", "=", "a", ",", "y", "=", "b", ",", "z", "=", "c", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "logger", ".", "error", "(", "\"Invalid conditional independence test for discrete data. Supported tests - conditional_mutual_information\"", ")", "\n", "\n", "", "", "elif", "(", "a", "in", "continuous_columns", "or", "a", "in", "binary_columns", ")", "and", "(", "b", "in", "continuous_columns", "or", "b", "in", "binary_columns", ")", "and", "all", "(", "node", "in", "continuous_columns", "or", "node", "in", "binary_columns", "for", "node", "in", "c", ")", ":", "\n", "# c is set of continuous and binary variables and ", "\n", "#   1. either a and b is continuous and the other is binary", "\n", "#   2. both a and b are binary", "\n", "                ", "self", ".", "partial_correlation", "(", "x", "=", "a", ",", "y", "=", "b", ",", "z", "=", "c", ")", "\n", "\n", "", "elif", "all", "(", "node", "in", "discrete_columns", "for", "node", "in", "c", ")", "and", "(", "a", "in", "discrete_columns", "or", "b", "in", "discrete_columns", ")", ":", "\n", "# c is discrete and", "\n", "# either a or b is continuous and the other is discrete", "\n", "                ", "self", ".", "conditional_mutual_information", "(", "x", "=", "a", ",", "y", "=", "b", ",", "z", "=", "c", ")", "\n", "\n", "", "elif", "a", "in", "discrete_columns", "and", "b", "in", "discrete_columns", ":", "\n", "# a and b are discrete and c is a mixture of discrete and continuous variables. We discretize c and calculate conditional mutual information", "\n", "                ", "self", ".", "conditional_mutual_information", "(", "x", "=", "a", ",", "y", "=", "b", ",", "z", "=", "c", ")", "\n", "\n", "", "else", ":", "\n", "                ", "key", "=", "(", "(", "a", ",", "b", ")", "+", "(", "c", ",", ")", ")", "\n", "self", ".", "_results", "[", "key", "]", "=", "[", "None", ",", "\"NotImplemented\"", "]", "\n", "variable_types_c", "=", "[", "]", "\n", "for", "var", "in", "c", ":", "\n", "                    ", "variable_types_c", ".", "append", "(", "variable_type", "[", "var", "]", ")", "\n", "", "print", "(", "\"The following setting with {0} as {1}, {2} as {3}, {4} as {5} not supported\"", ".", "format", "(", "a", ",", "variable_type", "[", "a", "]", ",", "b", ",", "variable_type", "[", "b", "]", ",", "c", ",", "variable_types_c", ")", ")", "\n", "\n", "", "", "self", ".", "set_refutation_result", "(", "number_of_constraints_model", "=", "len", "(", "independence_constraints", ")", ")", "\n", "refute", ".", "add_conditional_independence_test_result", "(", "number_of_constraints_model", "=", "len", "(", "independence_constraints", ")", ",", "number_of_constraints_satisfied", "=", "len", "(", "self", ".", "_true_implications", ")", ",", "refutation_result", "=", "self", ".", "_refutation_passed", ")", "\n", "return", "refute", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefutation.__init__": [[134, 140], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "method_name_discrete", ",", "method_name_continuous", ")", ":", "\n", "        ", "self", ".", "method_name_discrete", "=", "method_name_discrete", "\n", "self", ".", "method_name_continuous", "=", "method_name_continuous", "\n", "self", ".", "number_of_constraints_model", "=", "None", "\n", "self", ".", "number_of_constraints_satisfied", "=", "None", "\n", "self", ".", "refutation_result", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefutation.add_conditional_independence_test_result": [[141, 145], ["None"], "methods", ["None"], ["", "def", "add_conditional_independence_test_result", "(", "self", ",", "number_of_constraints_model", ",", "number_of_constraints_satisfied", ",", "refutation_result", ")", ":", "\n", "        ", "self", ".", "number_of_constraints_model", "=", "number_of_constraints_model", "\n", "self", ".", "number_of_constraints_satisfied", "=", "number_of_constraints_satisfied", "\n", "self", ".", "refutation_result", "=", "refutation_result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.graph_refuter.GraphRefutation.__str__": [[146, 152], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "refutation_result", "is", "None", ":", "\n", "            ", "return", "\"Method name for discrete data:{0}\\nMethod name for continuous data:{1}\"", ".", "format", "(", "self", ".", "method_name_discrete", ",", "self", ".", "method_name_continuous", ")", "\n", "", "else", ":", "\n", "            ", "return", "\"Method name for discrete data:{0}\\nMethod name for continuous data:{1}\\nNumber of conditional independencies entailed by model:{2}\\nNumber of independences satisfied by data:{3}\\nTest passed:{4}\\n\"", ".", "format", "(", "\n", "self", ".", "method_name_discrete", ",", "self", ".", "method_name_continuous", ",", "self", ".", "number_of_constraints_model", ",", "self", ".", "number_of_constraints_satisfied", ",", "self", ".", "refutation_result", "\n", ")", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.data_subset_refuter.DataSubsetRefuter.__init__": [[23, 30], ["dowhy.causal_refuter.CausalRefuter.__init__", "kwargs.pop", "kwargs.pop", "kwargs.pop", "logging.getLogger"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_subset_fraction", "=", "kwargs", ".", "pop", "(", "\"subset_fraction\"", ",", "0.8", ")", "\n", "self", ".", "_num_simulations", "=", "kwargs", ".", "pop", "(", "\"num_simulations\"", ",", "CausalRefuter", ".", "DEFAULT_NUM_SIMULATIONS", ")", "\n", "self", ".", "_random_state", "=", "kwargs", ".", "pop", "(", "\"random_state\"", ",", "None", ")", "\n", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.data_subset_refuter.DataSubsetRefuter.refute_estimate": [[31, 65], ["numpy.zeros", "data_subset_refuter.DataSubsetRefuter.logger.info", "range", "dowhy.causal_refuter.CausalRefutation", "dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "dowhy.causal_refuter.CausalRefutation.add_refuter", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "numpy.mean", "data_subset_refuter.DataSubsetRefuter.test_significance", "data_subset_refuter.DataSubsetRefuter._data.sample", "data_subset_refuter.DataSubsetRefuter._data.sample", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample"], ["", "def", "refute_estimate", "(", "self", ")", ":", "\n", "\n", "        ", "sample_estimates", "=", "np", ".", "zeros", "(", "self", ".", "_num_simulations", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Refutation over {} simulated datasets of size {} each\"", "\n", ".", "format", "(", "self", ".", "_subset_fraction", "\n", ",", "self", ".", "_subset_fraction", "*", "len", "(", "self", ".", "_data", ".", "index", ")", ")", "\n", ")", "\n", "\n", "for", "index", "in", "range", "(", "self", ".", "_num_simulations", ")", ":", "\n", "            ", "if", "self", ".", "_random_state", "is", "None", ":", "\n", "                ", "new_data", "=", "self", ".", "_data", ".", "sample", "(", "frac", "=", "self", ".", "_subset_fraction", ")", "\n", "", "else", ":", "\n", "                ", "new_data", "=", "self", ".", "_data", ".", "sample", "(", "frac", "=", "self", ".", "_subset_fraction", ",", "\n", "random_state", "=", "self", ".", "_random_state", ")", "\n", "\n", "", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "self", ".", "_target_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "sample_estimates", "[", "index", "]", "=", "new_effect", ".", "value", "\n", "\n", "", "refute", "=", "CausalRefutation", "(", "\n", "self", ".", "_estimate", ".", "value", ",", "\n", "np", ".", "mean", "(", "sample_estimates", ")", ",", "\n", "refutation_type", "=", "\"Refute: Use a subset of data\"", "\n", ")", "\n", "\n", "# We want to see if the estimate falls in the same distribution as the one generated by the refuter", "\n", "# Ideally that should be the case as choosing a subset should not have a significant effect on the ability", "\n", "# of the treatment to affect the outcome", "\n", "refute", ".", "add_significance_test_results", "(", "\n", "self", ".", "test_significance", "(", "self", ".", "_estimate", ",", "sample_estimates", ")", "\n", ")", "\n", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "return", "refute", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.__init__": [[29, 85], ["range", "range", "dowhy.utils.api.parse_state", "range", "logging.getLogger", "len", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.treatment_name.append", "len", "len", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.benchmark_common_causes.append", "type", "numpy.array", "type", "numpy.array", "str", "str", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state"], ["def", "__init__", "(", "self", ",", "estimator", "=", "None", ",", "data", "=", "None", ",", "treatment_name", "=", "None", ",", "percent_change_estimate", "=", "1.0", ",", "significance_level", "=", "0.05", ",", "confounder_increases_estimate", "=", "True", ",", "benchmark_common_causes", "=", "None", ",", "null_hypothesis_effect", "=", "0", ",", "frac_strength_treatment", "=", "None", ",", "frac_strength_outcome", "=", "None", ",", "common_causes_order", "=", "None", ")", ":", "\n", "        ", "self", ".", "data", "=", "data", "\n", "self", ".", "treatment_name", "=", "[", "]", "\n", "# original_treatment_name: : stores original variable names for labelling", "\n", "self", ".", "original_treatment_name", "=", "treatment_name", "\n", "for", "t", "in", "range", "(", "len", "(", "treatment_name", ")", ")", ":", "\n", "            ", "self", ".", "treatment_name", ".", "append", "(", "\"x\"", "+", "str", "(", "t", "+", "1", ")", ")", "\n", "\n", "", "self", ".", "percent_change_estimate", "=", "percent_change_estimate", "\n", "self", ".", "significance_level", "=", "significance_level", "\n", "self", ".", "confounder_increases_estimate", "=", "confounder_increases_estimate", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "estimator_model", "=", "estimator", ".", "model", "\n", "self", ".", "null_hypothesis_effect", "=", "null_hypothesis_effect", "\n", "\n", "# common_causes_map : maps the original variable names to variable names in OLS regression", "\n", "self", ".", "common_causes_map", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "common_causes_order", ")", ")", ":", "\n", "            ", "self", ".", "common_causes_map", "[", "common_causes_order", "[", "i", "]", "]", "=", "\"x\"", "+", "str", "(", "len", "(", "self", ".", "treatment_name", ")", "+", "i", "+", "1", ")", "\n", "\n", "# benchmark_common_causes: stores variable names in terms of regression model variables", "\n", "", "benchmark_common_causes", "=", "parse_state", "(", "benchmark_common_causes", ")", "\n", "self", ".", "benchmark_common_causes", "=", "[", "]", "\n", "# original_benchmark_covariates: stores original variable names for labelling", "\n", "self", ".", "original_benchmark_covariates", "=", "benchmark_common_causes", "\n", "for", "i", "in", "range", "(", "len", "(", "benchmark_common_causes", ")", ")", ":", "\n", "            ", "self", ".", "benchmark_common_causes", ".", "append", "(", "self", ".", "common_causes_map", "[", "benchmark_common_causes", "[", "i", "]", "]", ")", "\n", "\n", "", "if", "type", "(", "frac_strength_treatment", ")", "in", "[", "int", ",", "list", ",", "float", "]", ":", "\n", "            ", "self", ".", "frac_strength_treatment", "=", "np", ".", "array", "(", "frac_strength_treatment", ")", "\n", "", "if", "type", "(", "frac_strength_outcome", ")", "in", "[", "int", ",", "list", ",", "float", "]", ":", "\n", "            ", "self", ".", "frac_strength_outcome", "=", "np", ".", "array", "(", "frac_strength_outcome", ")", "\n", "\n", "# estimate: estimate of regression", "\n", "", "self", ".", "estimate", "=", "None", "\n", "# degree_of_freedom: degree of freedom of error in regression", "\n", "self", ".", "degree_of_freedom", "=", "None", "\n", "# standard_error: standard error in regression", "\n", "self", ".", "standard_error", "=", "None", "\n", "# t_stats: Treatment coefficient t-value - measures how many standard errors the estimate is away from zero.", "\n", "self", ".", "t_stats", "=", "None", "\n", "# partial_f2: value to determine if a regression model and a nested version of it have a statistically significant difference between them", "\n", "self", ".", "partial_f2", "=", "None", "\n", "# r2tu_w: partial R^2  of unobserved confounder \"u\" with treatment \"t\", after conditioning on observed covariates \"w\"", "\n", "self", ".", "r2tu_w", "=", "None", "\n", "# r2yu_tw: partial R^2  of unobserved confounder \"u\" with outcome \"y\", after conditioning on observed covariates \"w\" and treatment \"t\"", "\n", "self", ".", "r2yu_tw", "=", "None", "\n", "# r2twj_w: partial R^2 of observed covariate wj with treatment \"t\", after conditioning on observed covariates \"w\" excluding wj", "\n", "self", ".", "r2twj_w", "=", "None", "\n", "# r2ywj_tw:  partial R^2 of observed covariate wj with outcome \"y\", after conditioning on observed covariates \"w\" (excluding wj) and treatment \"t\"", "\n", "self", ".", "r2ywj_tw", "=", "None", "\n", "# benchmarking_results: dataframe containing information about bounds and bias adjusted terms", "\n", "self", ".", "benchmarking_results", "=", "None", "\n", "# stats: dictionary containing information like robustness value, partial R^2, estimate, standard error , degree of freedom, partial f^2, t-statistic", "\n", "self", ".", "stats", "=", "None", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.treatment_regression": [[87, 102], ["linear_sensitivity_analyzer.LinearSensitivityAnalyzer.estimator._observed_common_causes.copy", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.estimator._treatment.copy", "statsmodels.tools.add_constant", "statsmodels.tools.add_constant.rename", "statsmodels.OLS", "statsmodels.OLS.fit"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "treatment_regression", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Function to perform regression with treatment as outcome\n\n        :returns: new OLS regression model\n        \"\"\"", "\n", "\n", "features", "=", "self", ".", "estimator", ".", "_observed_common_causes", ".", "copy", "(", ")", "\n", "treatment_df", "=", "self", ".", "estimator", ".", "_treatment", ".", "copy", "(", ")", "\n", "features", "=", "sm", ".", "tools", ".", "add_constant", "(", "features", ")", "\n", "features", ".", "rename", "(", "columns", "=", "self", ".", "common_causes_map", ",", "inplace", "=", "True", ")", "\n", "model", "=", "sm", ".", "OLS", "(", "treatment_df", ",", "features", ")", "\n", "estimator_model", "=", "model", ".", "fit", "(", ")", "\n", "\n", "return", "estimator_model", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.partial_r2_func": [[104, 126], ["int", "numpy.isscalar", "len", "numpy.matmul", "numpy.matmul", "estimator_model.cov_params", "numpy.linalg.inv"], "methods", ["None"], ["", "def", "partial_r2_func", "(", "self", ",", "estimator_model", "=", "None", ",", "treatment", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Computes the partial R^2 of regression model \n\n        :param estimator_model: Linear regression model\n        :param treatment: treatment name\n\n        :returns: partial R^2 value\n        \"\"\"", "\n", "\n", "estimate", "=", "estimator_model", ".", "params", "[", "treatment", "]", "\n", "degree_of_freedom", "=", "int", "(", "estimator_model", ".", "df_resid", ")", "\n", "\n", "if", "np", ".", "isscalar", "(", "estimate", ")", ":", "#for single covariate", "\n", "            ", "t_stats", "=", "estimator_model", ".", "tvalues", "[", "treatment", "]", "\n", "return", "(", "t_stats", "**", "2", "/", "(", "t_stats", "**", "2", "+", "degree_of_freedom", ")", ")", "\n", "\n", "", "else", ":", "#compute for a group of covariates", "\n", "            ", "covariance_matrix", "=", "estimator_model", ".", "cov_params", "(", ")", ".", "loc", "[", "treatment", ",", ":", "]", "[", "treatment", "]", "\n", "n", "=", "len", "(", "estimate", ")", "#number of parameters in model", "\n", "f_stat", "=", "np", ".", "matmul", "(", "np", ".", "matmul", "(", "estimate", ".", "values", ".", "T", ",", "np", ".", "linalg", ".", "inv", "(", "covariance_matrix", ".", "values", ")", ")", ",", "estimate", ".", "values", ")", "/", "n", "\n", "return", "f_stat", "*", "n", "/", "(", "f_stat", "*", "n", "+", "degree_of_freedom", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.robustness_value_func": [[128, 156], ["abs", "scipy.stats.t.ppf", "abs", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["None"], ["", "", "def", "robustness_value_func", "(", "self", ",", "alpha", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"\n        Function to calculate the robustness value. \n        It is the minimum strength of association that confounders must have with treatment and outcome to change conclusions.\n        Robustness value describes how strong the association must be in order to reduce the estimated effect by (100 * percent_change_estimate)%.\n        Robustness value close to 1 means the treatment effect can handle strong confounders explaining  almost all residual variation of the treatment and the outcome.\n        Robustness value close to 0 means that even very weak confounders can also change the results.\n\n        :param alpha: confidence interval (default = 1)\n\n        :returns: robustness value \n        \"\"\"", "\n", "\n", "partial_cohen_f", "=", "abs", "(", "self", ".", "t_stats", "/", "np", ".", "sqrt", "(", "self", ".", "degree_of_freedom", ")", ")", "#partial f of treatment t with outcome y. f = t_val/sqrt(dof)", "\n", "f_q", "=", "self", ".", "percent_change_estimate", "*", "partial_cohen_f", "\n", "t_alpha_df_1", "=", "t", ".", "ppf", "(", "alpha", "/", "2", ",", "self", ".", "degree_of_freedom", "-", "1", ")", "# t-value threshold with alpha significance level and dof-1 degrees of freedom", "\n", "f_critical", "=", "abs", "(", "t_alpha_df_1", ")", "/", "np", ".", "sqrt", "(", "self", ".", "degree_of_freedom", "-", "1", ")", "\n", "f_adjusted", "=", "f_q", "-", "f_critical", "\n", "\n", "if", "f_adjusted", "<", "0", ":", "\n", "            ", "r_value", "=", "0", "\n", "", "else", ":", "\n", "            ", "r_value", "=", "0.5", "*", "(", "np", ".", "sqrt", "(", "f_adjusted", "**", "4", "+", "(", "4", "*", "f_adjusted", "**", "2", ")", ")", "-", "f_adjusted", "**", "2", ")", "\n", "\n", "", "if", "f_adjusted", ">", "0", "and", "f_q", ">", "1", "/", "f_critical", ":", "\n", "            ", "r_value", "=", "(", "f_q", "**", "2", "-", "f_critical", "**", "2", ")", "/", "(", "1", "+", "f_q", "**", "2", ")", "\n", "\n", "", "return", "r_value", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.compute_bias_adjusted": [[158, 198], ["numpy.sqrt", "scipy.stats.t.ppf", "numpy.sqrt", "numpy.sqrt", "numpy.sign", "numpy.sign", "numpy.sqrt", "abs", "abs"], "methods", ["None"], ["", "def", "compute_bias_adjusted", "(", "self", ",", "r2tu_w", ",", "r2yu_tw", ")", ":", "\n", "        ", "\"\"\"\n        Computes the bias adjusted estimate, standard error, t-value,  partial R2, confidence intervals\n\n        :param r2tu_w: partial r^2 from regressing unobserved confounder u on treatment t after conditioning on observed covariates w\n        :param r2yu_tw: partial r^2 from regressing unobserved confounder u on outcome y after conditioning on observed covariates w and treatment t\n\n        :returns: Python dictionary with information about partial R^2 of confounders with treatment and outcome and bias adjusted variables\n        \"\"\"", "\n", "\n", "bias_factor", "=", "np", ".", "sqrt", "(", "(", "r2yu_tw", "*", "r2tu_w", ")", "/", "(", "1", "-", "r2tu_w", ")", ")", "\n", "bias", "=", "bias_factor", "*", "(", "self", ".", "standard_error", "*", "np", ".", "sqrt", "(", "self", ".", "degree_of_freedom", ")", ")", "\n", "\n", "if", "self", ".", "confounder_increases_estimate", ":", "\n", "            ", "bias_adjusted_estimate", "=", "np", ".", "sign", "(", "self", ".", "estimate", ")", "*", "(", "abs", "(", "self", ".", "estimate", ")", "-", "bias", ")", "\n", "", "else", ":", "\n", "            ", "bias_adjusted_estimate", "=", "np", ".", "sign", "(", "self", ".", "estimate", ")", "*", "(", "abs", "(", "self", ".", "estimate", ")", "+", "bias", ")", "\n", "\n", "", "bias_adjusted_se", "=", "np", ".", "sqrt", "(", "(", "1", "-", "r2yu_tw", ")", "/", "(", "1", "-", "r2tu_w", ")", ")", "*", "self", ".", "standard_error", "*", "np", ".", "sqrt", "(", "self", ".", "degree_of_freedom", "/", "(", "self", ".", "degree_of_freedom", "-", "1", ")", ")", "\n", "\n", "bias_adjusted_t", "=", "(", "bias_adjusted_estimate", "-", "self", ".", "null_hypothesis_effect", ")", "/", "bias_adjusted_se", "\n", "\n", "bias_adjusted_partial_r2", "=", "bias_adjusted_t", "**", "2", "/", "(", "bias_adjusted_t", "**", "2", "+", "(", "self", ".", "degree_of_freedom", "-", "1", ")", ")", "#partial r2 formula used with new t value and dof - 1", "\n", "\n", "num_se", "=", "t", ".", "ppf", "(", "self", ".", "significance_level", "/", "2", ",", "self", ".", "degree_of_freedom", ")", "# Number of standard errors within Confidence Interval", "\n", "\n", "bias_adjusted_upper_CI", "=", "bias_adjusted_estimate", "-", "num_se", "*", "bias_adjusted_se", "\n", "bias_adjusted_lower_CI", "=", "bias_adjusted_estimate", "+", "num_se", "*", "bias_adjusted_se", "\n", "\n", "benchmarking_results", "=", "{", "\n", "'r2tu_w'", ":", "r2tu_w", ",", "\n", "'r2yu_tw'", ":", "r2yu_tw", ",", "\n", "'bias_adjusted_estimate'", ":", "bias_adjusted_estimate", ",", "\n", "'bias_adjusted_se'", ":", "bias_adjusted_se", ",", "\n", "'bias_adjusted_t'", ":", "bias_adjusted_t", ",", "\n", "'bias_adjusted_lower_CI'", ":", "bias_adjusted_lower_CI", ",", "\n", "'bias_adjusted_upper_CI'", ":", "bias_adjusted_upper_CI", "\n", "}", "\n", "\n", "return", "benchmarking_results", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.check_sensitivity": [[199, 278], ["int", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.partial_r2_func", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.robustness_value_func", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.robustness_value_func", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.treatment_regression", "range", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.compute_bias_adjusted", "pandas.DataFrame.from_dict", "numpy.array", "numpy.array", "numpy.array", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.r2ywj_tw.append", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.r2twj_w.append", "len", "any", "any", "any", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.plot", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.partial_r2_func", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.partial_r2_func", "ValueError", "ValueError", "range", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.logger.warning", "len", "numpy.sqrt", "len", "len", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.partial_r2_func", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.robustness_value_func", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.robustness_value_func", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.treatment_regression", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.compute_bias_adjusted", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.partial_r2_func", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.partial_r2_func"], ["", "def", "check_sensitivity", "(", "self", ",", "plot", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Function to perform sensitivity analysis. \n        :param plot: plot = True generates a plot of point estimate and the variations with respect to unobserved confounding.\n                     plot = False overrides the setting\n        \n        :returns: instance of LinearSensitivityAnalyzer class\n        \"\"\"", "\n", "\n", "self", ".", "standard_error", "=", "np", ".", "array", "(", "self", ".", "estimator_model", ".", "bse", "[", "1", ":", "(", "len", "(", "self", ".", "treatment_name", ")", "+", "1", ")", "]", ")", "[", "0", "]", "\n", "self", ".", "degree_of_freedom", "=", "int", "(", "self", ".", "estimator_model", ".", "df_resid", ")", "\n", "self", ".", "estimate", "=", "np", ".", "array", "(", "self", ".", "estimator_model", ".", "params", "[", "1", ":", "(", "len", "(", "self", ".", "treatment_name", ")", "+", "1", ")", "]", ")", "[", "0", "]", "\n", "self", ".", "t_stats", "=", "np", ".", "array", "(", "self", ".", "estimator_model", ".", "tvalues", "[", "self", ".", "treatment_name", "]", ")", "[", "0", "]", "\n", "\n", "# partial R^2 (r2yt_w) is the proportion of variation in outcome uniquely explained by treatment", "\n", "partial_r2", "=", "self", ".", "partial_r2_func", "(", "self", ".", "estimator_model", ",", "self", ".", "treatment_name", ")", "\n", "RVq", "=", "self", ".", "robustness_value_func", "(", ")", "\n", "RV_qalpha", "=", "self", ".", "robustness_value_func", "(", "alpha", "=", "self", ".", "significance_level", ")", "\n", "\n", "if", "self", ".", "confounder_increases_estimate", ":", "\n", "            ", "self", ".", "null_hypothesis_effect", "=", "self", ".", "estimate", "*", "(", "1", "-", "self", ".", "percent_change_estimate", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "null_hypothesis_effect", "=", "self", ".", "estimate", "*", "(", "1", "+", "self", ".", "percent_change_estimate", ")", "\n", "\n", "", "self", ".", "t_stats", "=", "(", "self", ".", "estimate", "-", "self", ".", "null_hypothesis_effect", ")", "/", "self", ".", "standard_error", "\n", "self", ".", "partial_f2", "=", "self", ".", "t_stats", "**", "2", "/", "self", ".", "degree_of_freedom", "\n", "\n", "# build a new regression model by considering treatment variables as outcome ", "\n", "treatment_linear_model", "=", "self", ".", "treatment_regression", "(", ")", "\n", "\n", "# r2twj_w is partial R^2 of covariate wj with treatment \"t\", after conditioning on covariates w(excluding wj)", "\n", "# r2ywj_tw is partial R^2 of covariate wj with outcome \"y\", after conditioning on covariates w(excluding wj) and treatment \"t\"", "\n", "self", ".", "r2twj_w", "=", "[", "]", "\n", "self", ".", "r2ywj_tw", "=", "[", "]", "\n", "\n", "for", "covariate", "in", "self", ".", "benchmark_common_causes", ":", "\n", "            ", "self", ".", "r2ywj_tw", ".", "append", "(", "self", ".", "partial_r2_func", "(", "self", ".", "estimator_model", ",", "covariate", ")", ")", "\n", "self", ".", "r2twj_w", ".", "append", "(", "self", ".", "partial_r2_func", "(", "treatment_linear_model", ",", "covariate", ")", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "benchmark_common_causes", ")", ")", ":", "\n", "            ", "r2twj_w", "=", "self", ".", "r2twj_w", "[", "i", "]", "\n", "r2ywj_tw", "=", "self", ".", "r2ywj_tw", "[", "i", "]", "\n", "\n", "# r2tu_w is the partial r^2 from regressing u on t after conditioning on w", "\n", "self", ".", "r2tu_w", "=", "self", ".", "frac_strength_treatment", "*", "(", "r2twj_w", "/", "(", "1", "-", "r2twj_w", ")", ")", "\n", "if", "(", "any", "(", "val", ">=", "1", "for", "val", "in", "self", ".", "r2tu_w", ")", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"r2tu_w can not be >= 1. Try a lower frac_strength_treatment value\"", ")", "\n", "\n", "", "r2uwj_wt", "=", "self", ".", "frac_strength_treatment", "*", "(", "r2twj_w", "**", "2", ")", "/", "(", "(", "1", "-", "self", ".", "frac_strength_treatment", "*", "r2twj_w", ")", "*", "(", "1", "-", "r2twj_w", ")", ")", "\n", "if", "(", "any", "(", "val", ">=", "1", "for", "val", "in", "r2uwj_wt", ")", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"r2uwj_wt can not be >= 1. Try a lower frac_strength_treatment value\"", ")", "\n", "\n", "", "self", ".", "r2yu_tw", "=", "(", "(", "np", ".", "sqrt", "(", "self", ".", "frac_strength_outcome", ")", "+", "np", ".", "sqrt", "(", "r2uwj_wt", ")", ")", "/", "np", ".", "sqrt", "(", "1", "-", "r2uwj_wt", ")", ")", "**", "2", "*", "(", "r2ywj_tw", "/", "(", "1", "-", "r2ywj_tw", ")", ")", "\n", "if", "(", "any", "(", "val", ">", "1", "for", "val", "in", "self", ".", "r2yu_tw", ")", ")", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "r2yu_tw", ")", ")", ":", "\n", "                    ", "if", "self", ".", "r2yu_tw", "[", "i", "]", ">", "1", ":", "\n", "                        ", "self", ".", "r2yu_tw", "[", "i", "]", "=", "1", "\n", "", "", "self", ".", "logger", ".", "warning", "(", "\"Warning: r2yu_tw can not be > 1. Try a lower frac_strength_treatment. Setting r2yu_tw to 1\"", ")", "\n", "\n", "#Compute bias adjusted terms", "\n", "\n", "", "", "self", ".", "benchmarking_results", "=", "self", ".", "compute_bias_adjusted", "(", "self", ".", "r2tu_w", ",", "self", ".", "r2yu_tw", ")", "\n", "\n", "if", "plot", "==", "True", ":", "\n", "            ", "self", ".", "plot", "(", ")", "\n", "\n", "", "self", ".", "stats", "=", "{", "\n", "'estimate'", ":", "self", ".", "estimate", ",", "\n", "'standard_error'", ":", "self", ".", "standard_error", ",", "\n", "'degree of freedom'", ":", "self", ".", "degree_of_freedom", ",", "\n", "'t_statistic'", ":", "self", ".", "t_stats", ",", "\n", "'r2yt_w'", ":", "partial_r2", ",", "\n", "'partial_f2'", ":", "self", ".", "partial_f2", ",", "\n", "'robustness_value'", ":", "RVq", ",", "\n", "'robustness_value_alpha'", ":", "RV_qalpha", "\n", "}", "\n", "\n", "self", ".", "benchmarking_results", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "self", ".", "benchmarking_results", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.plot_estimate": [[279, 304], ["numpy.zeros", "range", "len", "range", "len", "len", "len", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.compute_bias_adjusted"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.compute_bias_adjusted"], ["", "def", "plot_estimate", "(", "self", ",", "r2tu_w", ",", "r2yu_tw", ")", ":", "\n", "        ", "\"\"\"\n        Computes the contours, threshold line and bounds for plotting estimates.\n        Contour lines (z - axis) correspond to the adjusted estimate values for different values of r2tu_w (x) and r2yu_tw (y).\n        :param r2tu_w: hypothetical partial R^2 of confounder with treatment(x - axis)\n        :param r2yu_tw: hypothetical partial R^2 of confounder with outcome(y - axis)\n\n        :returns:\n        contour_values : values of contour lines for the plot\n        critical_estimate : threshold point \n        estimate_bounds : estimate values for unobserved confounders (bias adjusted estimates)\n        \"\"\"", "\n", "\n", "critical_estimate", "=", "self", ".", "null_hypothesis_effect", "\n", "contour_values", "=", "np", ".", "zeros", "(", "(", "len", "(", "r2yu_tw", ")", ",", "len", "(", "r2tu_w", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "r2yu_tw", ")", ")", ":", "\n", "            ", "y", "=", "r2tu_w", "[", "i", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "r2tu_w", ")", ")", ":", "\n", "                ", "x", "=", "r2yu_tw", "[", "j", "]", "\n", "benchmarking_results", "=", "self", ".", "compute_bias_adjusted", "(", "r2tu_w", "=", "x", ",", "r2yu_tw", "=", "y", ")", "\n", "estimate", "=", "benchmarking_results", "[", "'bias_adjusted_estimate'", "]", "\n", "contour_values", "[", "i", "]", "[", "j", "]", "=", "estimate", "\n", "\n", "", "", "estimate_bounds", "=", "self", ".", "benchmarking_results", "[", "'bias_adjusted_estimate'", "]", "\n", "return", "contour_values", ",", "critical_estimate", ",", "estimate_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.plot_t": [[306, 333], ["scipy.stats.t.ppf", "abs", "numpy.sign", "contour_values.append", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.compute_bias_adjusted", "contour.append"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.compute_bias_adjusted"], ["", "def", "plot_t", "(", "self", ",", "r2tu_w", ",", "r2yu_tw", ")", ":", "\n", "        ", "\"\"\"\n        Computes the contours, threshold line and bounds for plotting t.\n        Contour lines (z - axis) correspond to the adjusted t values for different values of r2tu_w (x) and r2yu_tw (y).\n        :param r2tu_w: hypothetical partial R^2 of confounder with treatment(x - axis)\n        :param r2yu_tw: hypothetical partial R^2 of confounder with outcome(y - axis)\n\n        :returns:\n        contour_values : values of contour lines for the plot\n        critical_t : threshold point \n        t_bounds : t-value for unobserved confounders (bias adjusted t values)\n        \"\"\"", "\n", "\n", "t_alpha_df_1", "=", "t", ".", "ppf", "(", "self", ".", "significance_level", "/", "2", ",", "self", ".", "degree_of_freedom", "-", "1", ")", "# t-value threshold with alpha significance level and dof-1 degrees of freedom", "\n", "critical_t", "=", "abs", "(", "t_alpha_df_1", ")", "*", "np", ".", "sign", "(", "self", ".", "t_stats", ")", "\n", "\n", "contour_values", "=", "[", "]", "\n", "for", "x", "in", "r2tu_w", ":", "\n", "            ", "contour", "=", "[", "]", "\n", "for", "y", "in", "r2yu_tw", ":", "\n", "                ", "benchmarking_results", "=", "self", ".", "compute_bias_adjusted", "(", "r2tu_w", "=", "x", ",", "r2yu_tw", "=", "y", ")", "\n", "t_value", "=", "benchmarking_results", "[", "'bias_adjusted_t'", "]", "\n", "contour", ".", "append", "(", "t_value", ")", "\n", "", "contour_values", ".", "append", "(", "contour", ")", "\n", "\n", "", "t_bounds", "=", "self", ".", "benchmarking_results", "[", "'bias_adjusted_t'", "]", "\n", "return", "contour_values", ",", "critical_t", ",", "t_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.plot": [[335, 432], ["matplotlib.subplots", "ax.set_title", "ax.set_xlabel", "ax.set_ylabel", "range", "numpy.arange", "numpy.arange", "ax.contour", "ax.clabel", "ax.contour", "ax.clabel", "ax.scatter", "range", "ax.legend", "matplotlib.show", "len", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.plot_estimate", "len", "ax.scatter", "ax.annotate", "linear_sensitivity_analyzer.LinearSensitivityAnalyzer.plot_t", "ValueError", "str", "str", "round", "str", "str", "str", "round", "round", "str"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.plot_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.plot_t"], ["", "def", "plot", "(", "self", ",", "plot_type", "=", "'estimate'", ",", "critical_value", "=", "None", ",", "x_limit", "=", "0.8", ",", "y_limit", "=", "0.8", ",", "\n", "num_points_per_contour", "=", "200", ",", "plot_size", "=", "(", "7", ",", "7", ")", ",", "contours_color", "=", "\"blue\"", ",", "critical_contour_color", "=", "\"red\"", ",", "\n", "label_fontsize", "=", "9", ",", "contour_linewidths", "=", "0.75", ",", "contour_linestyles", "=", "\"solid\"", ",", "\n", "contours_label_color", "=", "\"black\"", ",", "critical_label_color", "=", "\"red\"", ",", "\n", "unadjusted_estimate_marker", "=", "'D'", ",", "unadjusted_estimate_color", "=", "\"black\"", ",", "\n", "adjusted_estimate_marker", "=", "'^'", ",", "adjusted_estimate_color", "=", "\"red\"", ",", "\n", "legend_position", "=", "(", "1.6", ",", "0.6", ")", ")", ":", "\n", "        ", "\"\"\"\n        Plots and summarizes the sensitivity bounds as a contour plot, as they vary with the partial R^2 of the unobserved confounder(s) with the treatment and the outcome\n        Two types of plots can be generated, based on adjusted estimates or adjusted t-values\n        X-axis: Partial R^2 of treatment and unobserved confounder(s)\n        Y-axis: Partial R^2 of outcome and unobserved confounder(s)\n        We also plot bounds on the partial R^2 of the unobserved confounders obtained from observed covariates\n\n        :param plot_type: \"estimate\" or \"t-value\"\n        :param critical_value: special reference value of the estimate or t-value that will be highlighted in the plot\n        :param x_limit: plot's maximum x_axis value (default = 0.8)\n        :param y_limit: plot's minimum y_axis value (default = 0.8)\n        :param num_points_per_contour: number of points to calculate and plot each contour line (default = 200)\n        :param plot_size: tuple denoting the size of the plot (default = (7,7))\n        :param contours_color: color of contour line (default = blue)\n                               String or array. If array, lines will be plotted with the specific color in ascending order.\n        :param critical_contour_color: color of threshold line (default = red)\n        :param label_fontsize: fontsize for labelling contours (default = 9)\n        :param contour_linewidths: linewidths for contours (default = 0.75)\n        :param contour_linestyles: linestyles for contours (default = \"solid\")\n                                   See : https://matplotlib.org/3.5.0/gallery/lines_bars_and_markers/linestyles.html for more examples\n        :param contours_label_color: color of contour line label (default = black)\n        :param critical_label_color: color of threshold line label (default = red)\n        :param unadjusted_estimate_marker: marker type for unadjusted estimate in the plot (default = 'D')\n                                           See: https://matplotlib.org/stable/api/markers_api.html \n        :parm unadjusted_estimate_color: marker color for unadjusted estimate in the plot (default = \"black\")\n        :param adjusted_estimate_marker: marker type for bias adjusted estimates in the plot (default = '^')\n        :parm adjusted_estimate_color: marker color for bias adjusted estimates in the plot (default = \"red\")\n        :param legend_position:tuple denoting the position of the legend (default = (1.6, 0.6))\n        \"\"\"", "\n", "\n", "#Plotting the contour plot", "\n", "if", "plot_type", "==", "\"estimate\"", ":", "\n", "            ", "critical_value", "=", "0", "#default value of estimate", "\n", "", "else", ":", "\n", "            ", "critical_value", "=", "2", "#default t-value (usual approx for 95% CI)", "\n", "\n", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "plot_size", ")", "\n", "ax", ".", "set_title", "(", "\"Sensitivity contour plot of %s\"", "%", "plot_type", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Partial R^2 of confounder with treatment\"", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Partial R^2 of confounder with outcome\"", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "r2tu_w", ")", ")", ":", "\n", "            ", "x", "=", "self", ".", "r2tu_w", "[", "i", "]", "\n", "y", "=", "self", ".", "r2yu_tw", "[", "i", "]", "\n", "if", "(", "x", ">", "0.8", "or", "y", ">", "0.8", ")", ":", "\n", "                ", "x_limit", "=", "0.99", "\n", "y_limit", "=", "0.99", "\n", "break", "\n", "\n", "", "", "r2tu_w", "=", "np", ".", "arange", "(", "0.0", ",", "x_limit", ",", "x_limit", "/", "num_points_per_contour", ")", "\n", "r2yu_tw", "=", "np", ".", "arange", "(", "0.0", ",", "y_limit", ",", "y_limit", "/", "num_points_per_contour", ")", "\n", "\n", "unadjusted_point_estimate", "=", "None", "\n", "\n", "if", "plot_type", "==", "\"estimate\"", ":", "\n", "            ", "contour_values", ",", "critical_value", ",", "bound_values", "=", "self", ".", "plot_estimate", "(", "r2tu_w", ",", "r2yu_tw", ")", "\n", "unadjusted_estimate", "=", "self", ".", "estimate", "\n", "unadjusted_point_estimate", "=", "unadjusted_estimate", "\n", "", "elif", "plot_type", "==", "\"t-value\"", ":", "\n", "            ", "contour_values", ",", "critical_value", ",", "bound_values", "=", "self", ".", "plot_t", "(", "r2tu_w", ",", "r2yu_tw", ")", "\n", "unadjusted_t", "=", "self", ".", "t_stats", "\n", "unadjusted_point_estimate", "=", "unadjusted_t", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Current plotting method only supports 'estimate' and 't-value' \"", ")", "\n", "\n", "#Adding contours", "\n", "", "contour_plot", "=", "ax", ".", "contour", "(", "r2tu_w", ",", "r2yu_tw", ",", "contour_values", ",", "colors", "=", "contours_color", ",", "linewidths", "=", "contour_linewidths", ",", "linestyles", "=", "contour_linestyles", ")", "\n", "ax", ".", "clabel", "(", "contour_plot", ",", "inline", "=", "1", ",", "fontsize", "=", "label_fontsize", ",", "colors", "=", "contours_label_color", ")", "\n", "\n", "#Adding threshold contour line", "\n", "contour_plot", "=", "ax", ".", "contour", "(", "r2tu_w", ",", "r2yu_tw", ",", "contour_values", ",", "colors", "=", "critical_contour_color", ",", "linewidths", "=", "contour_linewidths", ",", "levels", "=", "[", "critical_value", "]", ")", "\n", "ax", ".", "clabel", "(", "contour_plot", ",", "[", "critical_value", "]", ",", "inline", "=", "1", ",", "fontsize", "=", "label_fontsize", ",", "colors", "=", "critical_label_color", ")", "\n", "\n", "#Adding unadjusted point estimate ", "\n", "ax", ".", "scatter", "(", "[", "0", "]", ",", "[", "0", "]", ",", "marker", "=", "unadjusted_estimate_marker", ",", "color", "=", "unadjusted_estimate_color", ",", "label", "=", "\"Unadjusted({:1.2f})\"", ".", "format", "(", "unadjusted_point_estimate", ")", ")", "\n", "\n", "#Adding bounds to partial R^2 values for given strength of confounders", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "frac_strength_treatment", ")", ")", ":", "\n", "            ", "frac_strength_treatment", "=", "self", ".", "frac_strength_treatment", "[", "i", "]", "\n", "frac_strength_outcome", "=", "self", ".", "frac_strength_outcome", "[", "i", "]", "\n", "if", "(", "frac_strength_treatment", "==", "frac_strength_outcome", ")", ":", "\n", "                ", "signs", "=", "str", "(", "round", "(", "frac_strength_treatment", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "                ", "signs", "=", "str", "(", "round", "(", "frac_strength_treatment", ",", "2", ")", ")", "+", "'/'", "+", "str", "(", "round", "(", "frac_strength_outcome", ",", "2", ")", ")", "\n", "", "label", "=", "str", "(", "i", "+", "1", ")", "+", "\"  \"", "+", "signs", "+", "' X '", "+", "str", "(", "self", ".", "original_benchmark_covariates", ")", "+", "\" ({:1.2f}) \"", ".", "format", "(", "bound_values", "[", "i", "]", ")", "\n", "ax", ".", "scatter", "(", "self", ".", "r2tu_w", "[", "i", "]", ",", "self", ".", "r2yu_tw", "[", "i", "]", ",", "color", "=", "adjusted_estimate_color", ",", "marker", "=", "adjusted_estimate_marker", ",", "label", "=", "label", ")", "\n", "ax", ".", "annotate", "(", "str", "(", "i", "+", "1", ")", ",", "(", "self", ".", "r2tu_w", "[", "i", "]", "+", "0.005", ",", "self", ".", "r2yu_tw", "[", "i", "]", "+", "0.005", ")", ")", "\n", "\n", "", "ax", ".", "legend", "(", "bbox_to_anchor", "=", "legend_position", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.__str__": [[433, 449], ["round", "round", "round"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"Sensitivity Analysis to Unobserved Confounding using R^2 paramterization\\n\\n\"", "\n", "s", "+=", "\"Unadjusted Estimates of Treatment {0} :\\n\"", ".", "format", "(", "self", ".", "original_treatment_name", ")", "\n", "s", "+=", "\"Coefficient Estimate : {0}\\n\"", ".", "format", "(", "self", ".", "estimate", ")", "\n", "s", "+=", "\"Degree of Freedom : {0}\\n\"", ".", "format", "(", "self", ".", "degree_of_freedom", ")", "\n", "s", "+=", "\"Standard Error : {0}\\n\"", ".", "format", "(", "self", ".", "standard_error", ")", "\n", "s", "+=", "\"t-value : {0}\\n\"", ".", "format", "(", "self", ".", "t_stats", ")", "\n", "s", "+=", "\"F^2 value : {0}\\n\\n\"", ".", "format", "(", "self", ".", "partial_f2", ")", "\n", "s", "+=", "\"Sensitivity Statistics : \\n\"", "\n", "s", "+=", "\"Partial R2 of treatment with outcome : {0}\\n\"", ".", "format", "(", "self", ".", "stats", "[", "'r2yt_w'", "]", ")", "\n", "s", "+=", "\"Robustness Value : {0}\\n\\n\"", ".", "format", "(", "self", ".", "stats", "[", "'robustness_value'", "]", ")", "\n", "s", "+=", "\"Interpretation of results :\\n\"", "\n", "s", "+=", "\"Any confounder explaining less than {0}% percent of the residual variance of both the treatment and the outcome would not be strong enough to explain away the observed effect i.e bring down the estimate to 0 \\n\\n\"", ".", "format", "(", "round", "(", "self", ".", "stats", "[", "'robustness_value'", "]", "*", "100", ",", "2", ")", ")", "\n", "s", "+=", "\"For a significance level of {0}%, any confounder explaining more than {1}% percent of the residual variance of both the treatment and the outcome would be strong enough to make the estimated effect not 'statistically significant'\\n\\n\"", ".", "format", "(", "self", ".", "significance_level", "*", "100", ",", "round", "(", "self", ".", "stats", "[", "'robustness_value_alpha'", "]", "*", "100", ",", "2", ")", ")", "\n", "s", "+=", "\"If confounders explained 100% of the residual variance of the outcome, they would need to explain at least {0}% of the residual variance of the treatment to bring down the estimated effect to 0\\n\"", ".", "format", "(", "round", "(", "self", ".", "stats", "[", "'r2yt_w'", "]", "*", "100", ",", "2", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.placebo_treatment_refuter.PlaceboTreatmentRefuter.__init__": [[36, 45], ["dowhy.causal_refuter.CausalRefuter.__init__", "kwargs.pop", "kwargs.pop", "kwargs.pop", "logging.getLogger"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_placebo_type", "=", "kwargs", ".", "pop", "(", "\"placebo_type\"", ",", "None", ")", "\n", "if", "self", ".", "_placebo_type", "is", "None", ":", "\n", "            ", "self", ".", "_placebo_type", "=", "\"Random Data\"", "\n", "", "self", ".", "_num_simulations", "=", "kwargs", ".", "pop", "(", "\"num_simulations\"", ",", "CausalRefuter", ".", "DEFAULT_NUM_SIMULATIONS", ")", "\n", "self", ".", "_random_state", "=", "kwargs", ".", "pop", "(", "\"random_state\"", ",", "None", ")", "\n", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.placebo_treatment_refuter.PlaceboTreatmentRefuter.refute_estimate": [[47, 162], ["placebo_treatment_refuter.PlaceboTreatmentRefuter._target_estimand.identifier_method.startswith", "copy.deepcopy", "placebo_treatment_refuter.PlaceboTreatmentRefuter._target_estimand.identifier_method.startswith", "numpy.zeros", "placebo_treatment_refuter.PlaceboTreatmentRefuter.logger.info", "dict", "range", "placebo_treatment_refuter.PlaceboTreatmentRefuter._target_estimand.identifier_method.startswith", "dowhy.causal_refuter.CausalRefutation", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "dowhy.causal_refuter.CausalRefutation.add_refuter", "placebo_treatment_refuter.PlaceboTreatmentRefuter._data.assign", "placebo_treatment_refuter.PlaceboTreatmentRefuter._target_estimand.identifier_method.startswith", "placebo_treatment_refuter.PlaceboTreatmentRefuter.logger.debug", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "numpy.mean", "placebo_treatment_refuter.PlaceboTreatmentRefuter.test_significance", "placebo_treatment_refuter.PlaceboTreatmentRefuter.logger.error", "ValueError", "placebo_treatment_refuter.PlaceboTreatmentRefuter._target_estimand.identifier_method.startswith", "pandas.concat", "numpy.random.choice", "placebo_treatment_refuter.PlaceboTreatmentRefuter._random_state.choice", "pandas.DataFrame", "placebo_treatment_refuter.PlaceboTreatmentRefuter.logger.info", "s.replace", "dowhy.utils.api.parse_state", "placebo_treatment_refuter.PlaceboTreatmentRefuter.logger.info", "numpy.random.binomial().astype", "dowhy.utils.api.parse_state", "numpy.random.randn", "placebo_treatment_refuter.PlaceboTreatmentRefuter.logger.info", "numpy.random.randint", "numpy.random.binomial", "placebo_treatment_refuter.PlaceboTreatmentRefuter._data[].unique", "placebo_treatment_refuter.PlaceboTreatmentRefuter.logger.info", "numpy.random.choice", "pandas.Series().astype", "placebo_treatment_refuter.PlaceboTreatmentRefuter._data[].min", "placebo_treatment_refuter.PlaceboTreatmentRefuter._data[].max", "placebo_treatment_refuter.PlaceboTreatmentRefuter._data[].min", "placebo_treatment_refuter.PlaceboTreatmentRefuter._data[].max", "pandas.Series"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state"], ["", "def", "refute_estimate", "(", "self", ")", ":", "\n", "# only permute is supported for iv methods", "\n", "        ", "if", "self", ".", "_target_estimand", ".", "identifier_method", ".", "startswith", "(", "\"iv\"", ")", ":", "\n", "            ", "if", "self", ".", "_placebo_type", "!=", "\"permute\"", ":", "\n", "                ", "self", ".", "logger", ".", "error", "(", "\"Only placebo_type=''permute'' is supported for creating placebo for instrumental variable estimation methods\"", ")", "\n", "raise", "ValueError", "(", "\"Only placebo_type=''permute'' is supported for creating placebo for instrumental variable estimation methods.\"", ")", "\n", "\n", "# We need to change the identified estimand", "\n", "# We make a copy as a safety measure, we don't want to change the", "\n", "# original DataFrame", "\n", "", "", "identified_estimand", "=", "copy", ".", "deepcopy", "(", "self", ".", "_target_estimand", ")", "\n", "identified_estimand", ".", "treatment_variable", "=", "[", "\"placebo\"", "]", "\n", "if", "self", ".", "_target_estimand", ".", "identifier_method", ".", "startswith", "(", "\"iv\"", ")", ":", "\n", "            ", "identified_estimand", ".", "instrumental_variables", "=", "[", "\"placebo_\"", "+", "s", "for", "s", "in", "identified_estimand", ".", "instrumental_variables", "]", "\n", "# For IV methods, the estimating_instrument_names should also be", "\n", "# changed. So we change it inside the estimate and then restore it", "\n", "# back at the end of this method.", "\n", "if", "self", ".", "_estimate", ".", "params", "[", "\"method_params\"", "]", "is", "not", "None", "and", "\"iv_instrument_name\"", "in", "self", ".", "_estimate", ".", "params", "[", "\"method_params\"", "]", ":", "\n", "                ", "self", ".", "_estimate", ".", "params", "[", "\"method_params\"", "]", "[", "\"iv_instrument_name\"", "]", "=", "[", "\"placebo_\"", "+", "s", "for", "s", "in", "parse_state", "(", "self", ".", "_estimate", ".", "params", "[", "\"method_params\"", "]", "[", "\"iv_instrument_name\"", "]", ")", "]", "\n", "\n", "", "", "sample_estimates", "=", "np", ".", "zeros", "(", "self", ".", "_num_simulations", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Refutation over {} simulated datasets of {} treatment\"", "\n", ".", "format", "(", "self", ".", "_num_simulations", "\n", ",", "self", ".", "_placebo_type", ")", "\n", ")", "\n", "\n", "num_rows", "=", "self", ".", "_data", ".", "shape", "[", "0", "]", "\n", "treatment_name", "=", "self", ".", "_treatment_name", "[", "0", "]", "# Extract the name of the treatment variable", "\n", "type_dict", "=", "dict", "(", "self", ".", "_data", ".", "dtypes", ")", "\n", "\n", "for", "index", "in", "range", "(", "self", ".", "_num_simulations", ")", ":", "\n", "\n", "            ", "if", "self", ".", "_placebo_type", "==", "\"permute\"", ":", "\n", "                ", "permuted_idx", "=", "None", "\n", "if", "self", ".", "_random_state", "is", "None", ":", "\n", "                    ", "permuted_idx", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "_data", ".", "shape", "[", "0", "]", ",", "\n", "size", "=", "self", ".", "_data", ".", "shape", "[", "0", "]", ",", "replace", "=", "False", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "permuted_idx", "=", "self", ".", "_random_state", ".", "choice", "(", "self", ".", "_data", ".", "shape", "[", "0", "]", ",", "\n", "size", "=", "self", ".", "_data", ".", "shape", "[", "0", "]", ",", "replace", "=", "False", ")", "\n", "", "new_treatment", "=", "self", ".", "_data", "[", "self", ".", "_treatment_name", "]", ".", "iloc", "[", "permuted_idx", "]", ".", "values", "\n", "if", "self", ".", "_target_estimand", ".", "identifier_method", ".", "startswith", "(", "\"iv\"", ")", ":", "\n", "                    ", "new_instruments_values", "=", "self", ".", "_data", "[", "self", ".", "_estimate", ".", "estimator", ".", "estimating_instrument_names", "]", ".", "iloc", "[", "permuted_idx", "]", ".", "values", "\n", "new_instruments_df", "=", "pd", ".", "DataFrame", "(", "new_instruments_values", ",", "\n", "columns", "=", "[", "\"placebo_\"", "+", "s", "for", "s", "in", "self", ".", "_data", "[", "self", ".", "_estimate", ".", "estimator", ".", "estimating_instrument_names", "]", ".", "columns", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "if", "'float'", "in", "type_dict", "[", "treatment_name", "]", ".", "name", ":", "\n", "                    ", "self", ".", "logger", ".", "info", "(", "\"Using a Normal Distribution with Mean:{} and Variance:{}\"", "\n", ".", "format", "(", "PlaceboTreatmentRefuter", ".", "DEFAULT_MEAN_OF_NORMAL", "\n", ",", "PlaceboTreatmentRefuter", ".", "DEFAULT_STD_DEV_OF_NORMAL", ")", "\n", ")", "\n", "new_treatment", "=", "np", ".", "random", ".", "randn", "(", "num_rows", ")", "*", "PlaceboTreatmentRefuter", ".", "DEFAULT_STD_DEV_OF_NORMAL", "+", "PlaceboTreatmentRefuter", ".", "DEFAULT_MEAN_OF_NORMAL", "\n", "\n", "", "elif", "'bool'", "in", "type_dict", "[", "treatment_name", "]", ".", "name", ":", "\n", "                    ", "self", ".", "logger", ".", "info", "(", "\"Using a Binomial Distribution with {} trials and {} probability of success\"", "\n", ".", "format", "(", "PlaceboTreatmentRefuter", ".", "DEFAULT_NUMBER_OF_TRIALS", "\n", ",", "PlaceboTreatmentRefuter", ".", "DEFAULT_PROBABILITY_OF_BINOMIAL", ")", "\n", ")", "\n", "new_treatment", "=", "np", ".", "random", ".", "binomial", "(", "PlaceboTreatmentRefuter", ".", "DEFAULT_NUMBER_OF_TRIALS", ",", "\n", "PlaceboTreatmentRefuter", ".", "DEFAULT_PROBABILITY_OF_BINOMIAL", ",", "\n", "num_rows", ")", ".", "astype", "(", "bool", ")", "\n", "\n", "", "elif", "'int'", "in", "type_dict", "[", "treatment_name", "]", ".", "name", ":", "\n", "                    ", "self", ".", "logger", ".", "info", "(", "\"Using a Discrete Uniform Distribution lying between {} and {}\"", "\n", ".", "format", "(", "self", ".", "_data", "[", "treatment_name", "]", ".", "min", "(", ")", "\n", ",", "self", ".", "_data", "[", "treatment_name", "]", ".", "max", "(", ")", ")", "\n", ")", "\n", "new_treatment", "=", "np", ".", "random", ".", "randint", "(", "low", "=", "self", ".", "_data", "[", "treatment_name", "]", ".", "min", "(", ")", ",", "\n", "high", "=", "self", ".", "_data", "[", "treatment_name", "]", ".", "max", "(", ")", ",", "\n", "size", "=", "num_rows", ")", "\n", "\n", "", "elif", "'category'", "in", "type_dict", "[", "treatment_name", "]", ".", "name", ":", "\n", "                    ", "categories", "=", "self", ".", "_data", "[", "treatment_name", "]", ".", "unique", "(", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Using a Discrete Uniform Distribution with the following categories:{}\"", "\n", ".", "format", "(", "categories", ")", ")", "\n", "sample", "=", "np", ".", "random", ".", "choice", "(", "categories", ",", "size", "=", "num_rows", ")", "\n", "new_treatment", "=", "pd", ".", "Series", "(", "sample", ",", "index", "=", "self", ".", "_data", ".", "index", ")", ".", "astype", "(", "'category'", ")", "\n", "\n", "# Create a new column in the data by the name of placebo", "\n", "", "", "new_data", "=", "self", ".", "_data", ".", "assign", "(", "placebo", "=", "new_treatment", ")", "\n", "if", "self", ".", "_target_estimand", ".", "identifier_method", ".", "startswith", "(", "\"iv\"", ")", ":", "\n", "                ", "new_data", "=", "pd", ".", "concat", "(", "(", "new_data", ",", "new_instruments_df", ")", ",", "axis", "=", "1", ")", "\n", "# Sanity check the data", "\n", "", "self", ".", "logger", ".", "debug", "(", "new_data", "[", "0", ":", "10", "]", ")", "\n", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "identified_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "sample_estimates", "[", "index", "]", "=", "new_effect", ".", "value", "\n", "\n", "# Restoring the value of iv_instrument_name", "\n", "", "if", "self", ".", "_target_estimand", ".", "identifier_method", ".", "startswith", "(", "\"iv\"", ")", ":", "\n", "            ", "if", "self", ".", "_estimate", ".", "params", "[", "\"method_params\"", "]", "is", "not", "None", "and", "\"iv_instrument_name\"", "in", "self", ".", "_estimate", ".", "params", "[", "\"method_params\"", "]", ":", "\n", "                ", "self", ".", "_estimate", ".", "params", "[", "\"method_params\"", "]", "[", "\"iv_instrument_name\"", "]", "=", "[", "s", ".", "replace", "(", "\"placebo_\"", ",", "\"\"", ",", "1", ")", "for", "s", "in", "parse_state", "(", "self", ".", "_estimate", ".", "params", "[", "\"method_params\"", "]", "[", "\"iv_instrument_name\"", "]", ")", "]", "\n", "", "", "refute", "=", "CausalRefutation", "(", "self", ".", "_estimate", ".", "value", ",", "\n", "np", ".", "mean", "(", "sample_estimates", ")", ",", "\n", "refutation_type", "=", "\"Refute: Use a Placebo Treatment\"", ")", "\n", "\n", "# Note: We hardcode the estimate value to ZERO as we want to check if it falls in the distribution of the refuter", "\n", "# Ideally we should expect that ZERO should fall in the distribution of the effect estimates as we have severed any causal", "\n", "# relationship between the treatment and the outcome.", "\n", "dummy_estimator", "=", "CausalEstimate", "(", "\n", "estimate", "=", "0", ",", "\n", "control_value", "=", "self", ".", "_estimate", ".", "control_value", ",", "\n", "treatment_value", "=", "self", ".", "_estimate", ".", "treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_estimate", ".", "target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "_estimate", ".", "realized_estimand_expr", ")", "\n", "\n", "refute", ".", "add_significance_test_results", "(", "\n", "self", ".", "test_significance", "(", "dummy_estimator", ",", "sample_estimates", ")", "\n", ")", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "return", "refute", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.random_common_cause.RandomCommonCause.__init__": [[20, 26], ["dowhy.causal_refuter.CausalRefuter.__init__", "kwargs.pop", "kwargs.pop", "logging.getLogger"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_num_simulations", "=", "kwargs", ".", "pop", "(", "\"num_simulations\"", ",", "CausalRefuter", ".", "DEFAULT_NUM_SIMULATIONS", ")", "\n", "self", ".", "_random_state", "=", "kwargs", ".", "pop", "(", "\"random_state\"", ",", "None", ")", "\n", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.random_common_cause.RandomCommonCause.refute_estimate": [[27, 64], ["numpy.zeros", "random_common_cause.RandomCommonCause.logger.info", "copy.deepcopy", "copy.deepcopy.set_backdoor_variables", "range", "dowhy.causal_refuter.CausalRefutation", "dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "dowhy.causal_refuter.CausalRefutation.add_refuter", "random_common_cause.RandomCommonCause._target_estimand.get_backdoor_variables", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "numpy.mean", "random_common_cause.RandomCommonCause.test_significance", "random_common_cause.RandomCommonCause._data.assign", "random_common_cause.RandomCommonCause._data.assign", "numpy.random.randn", "random_common_cause.RandomCommonCause._random_state.normal"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.set_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance"], ["", "def", "refute_estimate", "(", "self", ")", ":", "\n", "        ", "num_rows", "=", "self", ".", "_data", ".", "shape", "[", "0", "]", "\n", "sample_estimates", "=", "np", ".", "zeros", "(", "self", ".", "_num_simulations", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Refutation over {} simulated datasets, each with a random common cause added\"", "\n", ".", "format", "(", "self", ".", "_num_simulations", ")", ")", "\n", "\n", "new_backdoor_variables", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "+", "[", "'w_random'", "]", "\n", "identified_estimand", "=", "copy", ".", "deepcopy", "(", "self", ".", "_target_estimand", ")", "\n", "# Adding a new backdoor variable to the identified estimand", "\n", "identified_estimand", ".", "set_backdoor_variables", "(", "new_backdoor_variables", ")", "\n", "for", "index", "in", "range", "(", "self", ".", "_num_simulations", ")", ":", "\n", "            ", "if", "self", ".", "_random_state", "is", "None", ":", "\n", "                ", "new_data", "=", "self", ".", "_data", ".", "assign", "(", "w_random", "=", "np", ".", "random", ".", "randn", "(", "num_rows", ")", ")", "\n", "", "else", ":", "\n", "                ", "new_data", "=", "self", ".", "_data", ".", "assign", "(", "w_random", "=", "self", ".", "_random_state", ".", "normal", "(", "size", "=", "num_rows", "\n", ")", ")", "\n", "\n", "", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "identified_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "\n", "sample_estimates", "[", "index", "]", "=", "new_effect", ".", "value", "\n", "\n", "", "refute", "=", "CausalRefutation", "(", "\n", "self", ".", "_estimate", ".", "value", ",", "\n", "np", ".", "mean", "(", "sample_estimates", ")", ",", "\n", "refutation_type", "=", "\"Refute: Add a random common cause\"", "\n", ")", "\n", "\n", "# We want to see if the estimate falls in the same distribution as the one generated by the refuter", "\n", "# Ideally that should be the case as choosing a subset should not have a significant effect on the ability", "\n", "# of the treatment to affect the outcome", "\n", "refute", ".", "add_significance_test_results", "(", "\n", "self", ".", "test_significance", "(", "self", ".", "_estimate", ",", "sample_estimates", ")", "\n", ")", "\n", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "return", "refute", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.__init__": [[197, 216], ["dowhy.causal_refuter.CausalRefuter.__init__", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "dummy_outcome_refuter.DummyOutcomeRefuter.choose_variables", "logging.getLogger", "ValueError"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.choose_variables"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "_num_simulations", "=", "kwargs", ".", "pop", "(", "\"num_simulations\"", ",", "CausalRefuter", ".", "DEFAULT_NUM_SIMULATIONS", ")", "\n", "self", ".", "_transformation_list", "=", "kwargs", ".", "pop", "(", "\"transformation_list\"", ",", "DummyOutcomeRefuter", ".", "DEFAULT_TRANSFORMATION", ")", "\n", "self", ".", "_true_causal_effect", "=", "kwargs", ".", "pop", "(", "\"true_causal_effect\"", ",", "DummyOutcomeRefuter", ".", "DEFAULT_TRUE_CAUSAL_EFFECT", ")", "\n", "self", ".", "_bucket_size_scale_factor", "=", "kwargs", ".", "pop", "(", "\"bucket_size_scale_factor\"", ",", "DummyOutcomeRefuter", ".", "DEFAULT_BUCKET_SCALE_FACTOR", ")", "\n", "self", ".", "_min_data_point_threshold", "=", "kwargs", ".", "pop", "(", "\"min_data_point_threshold\"", ",", "DummyOutcomeRefuter", ".", "MIN_DATA_POINT_THRESHOLD", ")", "\n", "self", ".", "_test_fraction", "=", "kwargs", ".", "pop", "(", "\"_test_fraction\"", ",", "DummyOutcomeRefuter", ".", "DEFAULT_TEST_FRACTION", ")", "\n", "self", ".", "_unobserved_confounder_values", "=", "kwargs", ".", "pop", "(", "\"unobserved_confounder_values\"", ",", "DummyOutcomeRefuter", ".", "DEFAULT_NEW_DATA_WITH_UNOBSERVED_CONFOUNDING", ")", "\n", "required_variables", "=", "kwargs", ".", "pop", "(", "\"required_variables\"", ",", "True", ")", "\n", "\n", "if", "required_variables", "is", "False", ":", "\n", "            ", "raise", "ValueError", "(", "\"The value of required_variables cannot be False\"", ")", "\n", "\n", "", "self", ".", "_chosen_variables", "=", "self", ".", "choose_variables", "(", "required_variables", ")", "\n", "# Assuming that outcome is one-dimensional", "\n", "self", ".", "_outcome_name_str", "=", "self", ".", "_outcome_name", "[", "0", "]", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.refute_estimate": [[217, 405], ["copy.deepcopy", "dummy_outcome_refuter.DummyOutcomeRefuter.logger.info", "dummy_outcome_refuter.DummyOutcomeRefuter.logger.info", "collections.OrderedDict", "dummy_outcome_refuter.DummyOutcomeRefuter._has_estimator", "range", "numpy.array", "numpy.array.append", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_refuter.CausalRefutation", "dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "dowhy.causal_refuter.CausalRefutation.add_refuter", "refute_list.append", "list", "range", "dummy_outcome_refuter.DummyOutcomeRefuter.process_data", "pandas.concat.assign", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "estimates.append", "dummy_outcome_refuter.DummyOutcomeRefuter.preprocess_data_by_treatment", "numpy.mean", "dummy_outcome_refuter.DummyOutcomeRefuter.test_significance", "collections.OrderedDict.values", "dowhy.causal_estimator.CausalEstimate", "dowhy.causal_refuter.CausalRefutation", "dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "dowhy.causal_refuter.CausalRefutation.add_refuter", "refute_list.append", "dummy_outcome_refuter.DummyOutcomeRefuter.logger.warning", "dummy_outcome_refuter.DummyOutcomeRefuter._chosen_variables.append", "dummy_outcome_refuter.DummyOutcomeRefuter._true_causal_effect", "len", "dummy_outcome_refuter.DummyOutcomeRefuter.get_group().sample", "set", "set", "pandas.DataFrame", "pandas.concat.append", "pandas.concat", "dummy_outcome_refuter.DummyOutcomeRefuter.process_data", "pandas.concat.assign", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "estimates.append", "numpy.ravel", "numpy.mean", "dummy_outcome_refuter.DummyOutcomeRefuter.test_significance", "len", "list", "dummy_outcome_refuter.DummyOutcomeRefuter.logger.warning", "dummy_outcome_refuter.DummyOutcomeRefuter.logger.warning", "dummy_outcome_refuter.DummyOutcomeRefuter._true_causal_effect", "dummy_outcome_refuter.DummyOutcomeRefuter.get_group", "tuple", "tuple", "set.difference", "pandas.concat.append", "dummy_outcome_refuter.DummyOutcomeRefuter.get_group().sample", "dummy_outcome_refuter.DummyOutcomeRefuter.get_group", "dummy_outcome_refuter.DummyOutcomeRefuter.get_group"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter._has_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.process_data", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.preprocess_data_by_treatment", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.process_data", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample"], ["", "def", "refute_estimate", "(", "self", ")", ":", "\n", "\n", "# We need to change the identified estimand", "\n", "# We thus, make a copy. This is done as we don't want", "\n", "# to change the original DataFrame", "\n", "        ", "identified_estimand", "=", "copy", ".", "deepcopy", "(", "self", ".", "_target_estimand", ")", "\n", "identified_estimand", ".", "outcome_variable", "=", "[", "\"dummy_outcome\"", "]", "\n", "\n", "self", ".", "logger", ".", "info", "(", "\"Refutation over {} simulated datasets\"", ".", "format", "(", "self", ".", "_num_simulations", ")", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"The transformation passed: {}\"", ".", "format", "(", "self", ".", "_transformation_list", ")", ")", "\n", "\n", "simulation_results", "=", "[", "]", "\n", "refute_list", "=", "[", "]", "\n", "\n", "# We use collections.OrderedDict to maintain the order in which the data is stored", "\n", "causal_effect_map", "=", "OrderedDict", "(", ")", "\n", "\n", "# Check if we are using an estimator in the transformation list", "\n", "estimator_present", "=", "self", ".", "_has_estimator", "(", ")", "\n", "\n", "# The rationale behind ordering of the loops is the fact that we induce randomness everytime we create the", "\n", "# Train and the Validation Datasets. Thus, we run the simulation loop followed by the training and the validation", "\n", "# loops. Thus, we can get different values everytime we get the estimator.", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "_num_simulations", ")", ":", "\n", "            ", "estimates", "=", "[", "]", "\n", "\n", "if", "estimator_present", "==", "False", ":", "\n", "\n", "# Warn the user that the specified parameter is not applicable when no estimator is present in the transformation", "\n", "                ", "if", "self", ".", "_test_fraction", "!=", "DummyOutcomeRefuter", ".", "DEFAULT_TEST_FRACTION", ":", "\n", "                    ", "self", ".", "logger", ".", "warning", "(", "\"'test_fraction' is not applicable as there is no base treatment value.\"", ")", "\n", "\n", "# Adding an unobserved confounder if provided by the user", "\n", "", "if", "self", ".", "_unobserved_confounder_values", "is", "not", "None", ":", "\n", "                    ", "self", ".", "_data", "[", "'simulated'", "]", "=", "self", ".", "_unobserved_confounder_values", "\n", "self", ".", "_chosen_variables", ".", "append", "(", "'simulated'", ")", "\n", "# We set X_train = 0 and outcome_train to be 0", "\n", "", "validation_df", "=", "self", ".", "_data", "\n", "X_train", "=", "None", "\n", "outcome_train", "=", "None", "\n", "X_validation_df", "=", "validation_df", "[", "self", ".", "_chosen_variables", "]", "\n", "\n", "\n", "X_validation", "=", "X_validation_df", ".", "values", "\n", "outcome_validation", "=", "validation_df", "[", "self", ".", "_outcome_name_str", "]", ".", "values", "\n", "\n", "# Get the final outcome, after running through all the values in the transformation list", "\n", "outcome_validation", "=", "self", ".", "process_data", "(", "X_train", ",", "outcome_train", ",", "X_validation", ",", "outcome_validation", ",", "self", ".", "_transformation_list", ")", "\n", "\n", "# Check if the value of true effect has been already stored", "\n", "# We use None as the key as we have no base category for this refutation", "\n", "if", "None", "not", "in", "causal_effect_map", ":", "\n", "# As we currently support only one treatment", "\n", "                    ", "causal_effect_map", "[", "None", "]", "=", "self", ".", "_true_causal_effect", "(", "validation_df", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "\n", "\n", "", "outcome_validation", "+=", "causal_effect_map", "[", "None", "]", "\n", "\n", "\n", "new_data", "=", "validation_df", ".", "assign", "(", "dummy_outcome", "=", "outcome_validation", ")", "\n", "\n", "\n", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "identified_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "estimates", ".", "append", "(", "new_effect", ".", "value", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "groups", "=", "self", ".", "preprocess_data_by_treatment", "(", ")", "\n", "group_count", "=", "0", "\n", "\n", "if", "len", "(", "self", ".", "_test_fraction", ")", "==", "1", ":", "\n", "                    ", "self", ".", "_test_fraction", "=", "len", "(", "groups", ")", "*", "self", ".", "_test_fraction", "\n", "\n", "", "for", "key_train", ",", "_", "in", "groups", ":", "\n", "                    ", "base_train", "=", "groups", ".", "get_group", "(", "key_train", ")", ".", "sample", "(", "frac", "=", "self", ".", "_test_fraction", "[", "group_count", "]", ".", "base", ")", "\n", "train_set", "=", "set", "(", "[", "tuple", "(", "line", ")", "for", "line", "in", "base_train", ".", "values", "]", ")", "\n", "total_set", "=", "set", "(", "[", "tuple", "(", "line", ")", "for", "line", "in", "groups", ".", "get_group", "(", "key_train", ")", ".", "values", "]", ")", "\n", "base_validation", "=", "pd", ".", "DataFrame", "(", "list", "(", "total_set", ".", "difference", "(", "train_set", ")", ")", ",", "columns", "=", "base_train", ".", "columns", ")", "\n", "X_train_df", "=", "base_train", "[", "self", ".", "_chosen_variables", "]", "\n", "\n", "X_train", "=", "X_train_df", ".", "values", "\n", "outcome_train", "=", "base_train", "[", "self", ".", "_outcome_name_str", "]", ".", "values", "\n", "\n", "validation_df", "=", "[", "]", "\n", "transformation_list", "=", "self", ".", "_transformation_list", "\n", "validation_df", ".", "append", "(", "base_validation", ")", "\n", "\n", "for", "key_validation", ",", "_", "in", "groups", ":", "\n", "                        ", "if", "key_validation", "!=", "key_train", ":", "\n", "                            ", "validation_df", ".", "append", "(", "groups", ".", "get_group", "(", "key_validation", ")", ".", "sample", "(", "frac", "=", "self", ".", "_test_fraction", "[", "group_count", "]", ".", "other", ")", ")", "\n", "\n", "", "", "validation_df", "=", "pd", ".", "concat", "(", "validation_df", ")", "\n", "X_validation_df", "=", "validation_df", "[", "self", ".", "_chosen_variables", "]", "\n", "\n", "X_validation", "=", "X_validation_df", ".", "values", "\n", "outcome_validation", "=", "validation_df", "[", "self", ".", "_outcome_name_str", "]", ".", "values", "\n", "\n", "# If the number of data points is too few, run the default transformation: [(\"zero\",\"\"),(\"noise\", {'std_dev':1} )]", "\n", "if", "X_train", ".", "shape", "[", "0", "]", "<=", "self", ".", "_min_data_point_threshold", ":", "\n", "                        ", "transformation_list", "=", "DummyOutcomeRefuter", ".", "DEFAULT_TRANSFORMATION", "\n", "self", ".", "logger", ".", "warning", "(", "\"The number of data points in X_train:{} for category:{} is less than threshold:{}\"", ".", "format", "(", "X_train", ".", "shape", "[", "0", "]", ",", "key_train", ",", "self", ".", "_min_data_point_threshold", ")", ")", "\n", "self", ".", "logger", ".", "warning", "(", "\"Therefore, defaulting to the minimal set of transformations:{}\"", ".", "format", "(", "transformation_list", ")", ")", "\n", "\n", "", "outcome_validation", "=", "self", ".", "process_data", "(", "X_train", ",", "outcome_train", ",", "X_validation", ",", "outcome_validation", ",", "transformation_list", ")", "\n", "\n", "# Check if the value of true effect has been already stored", "\n", "# This ensures that we calculate the causal effect only once.", "\n", "# We use key_train as we map data with respect to the base category of the data", "\n", "\n", "if", "key_train", "not", "in", "causal_effect_map", ":", "\n", "# As we currently support only one treatment", "\n", "                        ", "causal_effect_map", "[", "key_train", "]", "=", "self", ".", "_true_causal_effect", "(", "validation_df", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ")", "\n", "\n", "# Add h(t) to f(W) to get the dummy outcome", "\n", "", "outcome_validation", "+=", "causal_effect_map", "[", "key_train", "]", "\n", "\n", "new_data", "=", "validation_df", ".", "assign", "(", "dummy_outcome", "=", "outcome_validation", ")", "\n", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "identified_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "\n", "estimates", ".", "append", "(", "new_effect", ".", "value", ")", "\n", "group_count", "+=", "1", "\n", "\n", "\n", "", "", "simulation_results", ".", "append", "(", "estimates", ")", "\n", "\n", "\n", "# We convert to ndarray for ease in indexing", "\n", "# The data is of the form", "\n", "# sim1: cat1 cat2 ... catn", "\n", "# sim2: cat1 cat2 ... catn", "\n", "", "simulation_results", "=", "np", ".", "array", "(", "simulation_results", ")", "\n", "\n", "# Note: We would like the causal_estimator to find the true causal estimate that we have specified through this", "\n", "# refuter. Let the value of the true causal effect be h(t). In the following section of code, we wish to find out if h(t) falls in the", "\n", "# distribution of the refuter.", "\n", "\n", "if", "estimator_present", "==", "False", ":", "\n", "\n", "            ", "dummy_estimate", "=", "CausalEstimate", "(", "\n", "estimate", "=", "causal_effect_map", "[", "None", "]", ",", "\n", "control_value", "=", "self", ".", "_estimate", ".", "control_value", ",", "\n", "treatment_value", "=", "self", ".", "_estimate", ".", "treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_estimate", ".", "target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "_estimate", ".", "realized_estimand_expr", ")", "\n", "\n", "refute", "=", "CausalRefutation", "(", "\n", "dummy_estimate", ".", "value", ",", "\n", "np", ".", "mean", "(", "simulation_results", ")", ",", "\n", "refutation_type", "=", "\"Refute: Use a Dummy Outcome\"", "\n", ")", "\n", "\n", "refute", ".", "add_significance_test_results", "(", "\n", "self", ".", "test_significance", "(", "dummy_estimate", ",", "np", ".", "ravel", "(", "simulation_results", ")", ")", "\n", ")", "\n", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "\n", "refute_list", ".", "append", "(", "refute", ")", "\n", "\n", "", "else", ":", "\n", "# True Causal Effect list", "\n", "            ", "causal_effect_list", "=", "list", "(", "causal_effect_map", ".", "values", "(", ")", ")", "\n", "# Iterating through the refutation for each category", "\n", "for", "train_category", "in", "range", "(", "simulation_results", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "dummy_estimate", "=", "CausalEstimate", "(", "\n", "estimate", "=", "causal_effect_list", "[", "train_category", "]", ",", "\n", "control_value", "=", "self", ".", "_estimate", ".", "control_value", ",", "\n", "treatment_value", "=", "self", ".", "_estimate", ".", "treatment_value", ",", "\n", "target_estimand", "=", "self", ".", "_estimate", ".", "target_estimand", ",", "\n", "realized_estimand_expr", "=", "self", ".", "_estimate", ".", "realized_estimand_expr", ")", "\n", "\n", "refute", "=", "CausalRefutation", "(", "\n", "dummy_estimate", ".", "value", ",", "\n", "np", ".", "mean", "(", "simulation_results", "[", ":", ",", "train_category", "]", ")", ",", "\n", "refutation_type", "=", "\"Refute: Use a Dummy Outcome\"", "\n", ")", "\n", "\n", "refute", ".", "add_significance_test_results", "(", "\n", "self", ".", "test_significance", "(", "dummy_estimate", ",", "simulation_results", "[", ":", ",", "train_category", "]", ")", "\n", ")", "\n", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "refute_list", ".", "append", "(", "refute", ")", "\n", "\n", "\n", "", "", "return", "refute_list", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.process_data": [[406, 452], ["callable", "action", "dummy_outcome_refuter.DummyOutcomeRefuter.", "dummy_outcome_refuter.DummyOutcomeRefuter.", "dummy_outcome_refuter.DummyOutcomeRefuter._estimate_dummy_outcome", "dummy_outcome_refuter.DummyOutcomeRefuter.", "dummy_outcome_refuter.DummyOutcomeRefuter.", "dummy_outcome_refuter.DummyOutcomeRefuter.noise", "dummy_outcome_refuter.DummyOutcomeRefuter.noise", "dummy_outcome_refuter.DummyOutcomeRefuter.permute", "dummy_outcome_refuter.DummyOutcomeRefuter.permute", "numpy.zeros", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter._estimate_dummy_outcome", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.noise", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.noise", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.permute", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.permute"], ["", "def", "process_data", "(", "self", ",", "X_train", ",", "outcome_train", ",", "X_validation", ",", "outcome_validation", ",", "transformation_list", ")", ":", "\n", "        ", "\"\"\"\n        We process the data by first training the estimators in the transformation_list on ``X_train`` and ``outcome_train``.\n        We then apply the estimators on ``X_validation`` to get the value of the dummy outcome, which we store in ``outcome_validation``.\n\n        :param X_train: The data of the covariates which is used to train an estimator. It corresponds to the data of a single category of the treatment\n        :type X_train: np.ndarray\n        :param outcome_train: This is used to hold the intermediate values of the outcome variable in the transformation list\n        :type outcome_train: np.ndarray\n\n        For Example:\n\n        ``[ ('permute', {'permute_fraction': val} ), (func,func_params)]``\n\n        The value obtained from permutation is used as an input for the custom estimator.\n\n        :param X_validation: The data of the covariates that is fed to a trained estimator to generate a dummy outcome\n        :type X_validation: np.ndarray\n        :param outcome_validation: This variable stores the dummy_outcome generated by the transformations\n        :type outcome_validation: np.ndarray\n        :param transformation_list: The list of transformations on the outcome data required to produce a dummy outcome\n        :type transformation_list: np.ndarray\n        \"\"\"", "\n", "for", "action", ",", "func_args", "in", "transformation_list", ":", "\n", "            ", "if", "callable", "(", "action", ")", ":", "\n", "                ", "estimator", "=", "action", "(", "X_train", ",", "outcome_train", ",", "**", "func_args", ")", "\n", "outcome_train", "=", "estimator", "(", "X_train", ")", "\n", "outcome_validation", "=", "estimator", "(", "X_validation", ")", "\n", "", "elif", "action", "in", "DummyOutcomeRefuter", ".", "SUPPORTED_ESTIMATORS", ":", "\n", "                ", "estimator", "=", "self", ".", "_estimate_dummy_outcome", "(", "action", ",", "X_train", ",", "outcome_train", ",", "**", "func_args", ")", "\n", "outcome_train", "=", "estimator", "(", "X_train", ")", "\n", "outcome_validation", "=", "estimator", "(", "X_validation", ")", "\n", "", "elif", "action", "==", "'noise'", ":", "\n", "                ", "if", "X_train", "is", "not", "None", ":", "\n", "                    ", "outcome_train", "=", "self", ".", "noise", "(", "outcome_train", ",", "**", "func_args", ")", "\n", "", "outcome_validation", "=", "self", ".", "noise", "(", "outcome_validation", ",", "**", "func_args", ")", "\n", "", "elif", "action", "==", "'permute'", ":", "\n", "                ", "if", "X_train", "is", "not", "None", ":", "\n", "                    ", "outcome_train", "=", "self", ".", "permute", "(", "outcome_train", ",", "**", "func_args", ")", "\n", "", "outcome_validation", "=", "self", ".", "permute", "(", "outcome_validation", ",", "**", "func_args", ")", "\n", "", "elif", "action", "==", "'zero'", ":", "\n", "                ", "if", "X_train", "is", "not", "None", ":", "\n", "                    ", "outcome_train", "=", "np", ".", "zeros", "(", "outcome_train", ".", "shape", ")", "\n", "", "outcome_validation", "=", "np", ".", "zeros", "(", "outcome_validation", ".", "shape", ")", "\n", "\n", "", "", "return", "outcome_validation", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter._has_estimator": [[453, 465], ["callable"], "methods", ["None"], ["", "def", "_has_estimator", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This function checks if there is an estimator in the transformation list.\n\n        If there are no estimators, we can optimize processing by skipping the\n        data preprocessing and running the transformations on the whole dataset.\n        \"\"\"", "\n", "for", "action", ",", "_", "in", "self", ".", "_transformation_list", ":", "\n", "            ", "if", "callable", "(", "action", ")", "or", "action", "in", "DummyOutcomeRefuter", ".", "SUPPORTED_ESTIMATORS", ":", "\n", "                ", "return", "True", "\n", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.preprocess_data_by_treatment": [[466, 511], ["len", "dummy_outcome_refuter.DummyOutcomeRefuter._chosen_variables.append", "dummy_outcome_refuter.DummyOutcomeRefuter._data.groupby", "data[].std", "pandas.cut", "data.groupby", "data.drop", "data.groupby", "data.groupby", "ValueError", "data.max", "data.min"], "methods", ["None"], ["", "def", "preprocess_data_by_treatment", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This function groups data based on the data type of the treatment.\n\n        Expected variable types supported for the treatment:\n\n        * bool\n        * pd.categorical\n        * float\n        * int\n\n        :returns: ``pandas.core.groupby.generic.DataFrameGroupBy``\n        \"\"\"", "\n", "assert", "len", "(", "self", ".", "_treatment_name", ")", "==", "1", ",", "\"At present, DoWhy supports a simgle treatment variable\"", "\n", "\n", "\n", "if", "self", ".", "_unobserved_confounder_values", "is", "not", "None", ":", "\n", "            ", "self", ".", "_data", "[", "'simulated'", "]", "=", "self", ".", "_unobserved_confounder_values", "\n", "self", ".", "_chosen_variables", ".", "append", "(", "'simulated'", ")", "\n", "\n", "", "treatment_variable_name", "=", "self", ".", "_treatment_name", "[", "0", "]", "# As we only have a single treatment", "\n", "variable_type", "=", "self", ".", "_data", "[", "treatment_variable_name", "]", ".", "dtypes", "\n", "\n", "if", "bool", "==", "variable_type", ":", "\n", "            ", "groups", "=", "self", ".", "_data", ".", "groupby", "(", "treatment_variable_name", ")", "\n", "return", "groups", "\n", "# We use string arguments to account for both 32 and 64 bit varaibles", "\n", "", "elif", "'float'", "in", "variable_type", ".", "name", "or", "'int'", "in", "variable_type", ".", "name", ":", "\n", "# action for continuous variables", "\n", "            ", "data", "=", "self", ".", "_data", "\n", "std_dev", "=", "data", "[", "treatment_variable_name", "]", ".", "std", "(", ")", "\n", "num_bins", "=", "(", "data", ".", "max", "(", ")", "-", "data", ".", "min", "(", ")", ")", "/", "(", "self", ".", "_bucket_size_scale_factor", "*", "std_dev", ")", "\n", "data", "[", "'bins'", "]", "=", "pd", ".", "cut", "(", "data", "[", "treatment_variable_name", "]", ",", "num_bins", ")", "\n", "groups", "=", "data", ".", "groupby", "(", "'bins'", ")", "\n", "data", ".", "drop", "(", "'bins'", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "return", "groups", "\n", "\n", "", "elif", "'categorical'", "in", "variable_type", ".", "name", ":", "\n", "# Action for categorical variables", "\n", "            ", "groups", "=", "data", ".", "groupby", "(", "treatment_variable_name", ")", "\n", "groups", "=", "data", ".", "groupby", "(", "'bins'", ")", "\n", "return", "groups", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Passed {}. Expected bool, float, int or categorical.\"", ".", "format", "(", "variable_type", ".", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter._estimate_dummy_outcome": [[512, 532], ["dummy_outcome_refuter.DummyOutcomeRefuter._get_regressor_object", "estimator.fit.fit.fit"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter._get_regressor_object", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "", "def", "_estimate_dummy_outcome", "(", "self", ",", "action", ",", "X_train", ",", "outcome", ",", "**", "func_args", ")", ":", "\n", "        ", "\"\"\"\n        A function that takes in any sklearn estimator and returns a trained estimator\n\n        :param 'action': str\n            The sklearn estimator to be used.\n        :param 'X_train': np.ndarray\n            The variable used to estimate the value of outcome.\n        :param 'outcome': np.ndarray\n            The variable which we wish to estimate.\n        :param 'func_args': variable length keyworded argument\n            The parameters passed to the estimator.\n        \"\"\"", "\n", "estimator", "=", "self", ".", "_get_regressor_object", "(", "action", ",", "**", "func_args", ")", "\n", "X", "=", "X_train", "\n", "y", "=", "outcome", "\n", "\n", "estimator", "=", "estimator", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n", "return", "estimator", ".", "predict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter._get_regressor_object": [[533, 554], ["sklearn.linear_model.LinearRegression", "sklearn.neighbors.KNeighborsRegressor", "sklearn.svm.SVR", "sklearn.ensemble.RandomForestRegressor", "sklearn.neural_network.MLPRegressor", "ValueError"], "methods", ["None"], ["", "def", "_get_regressor_object", "(", "self", ",", "action", ",", "**", "func_args", ")", ":", "\n", "        ", "\"\"\"\n        Return a sklearn estimator object based on the estimator and corresponding parameters\n\n        :param 'action': str\n            The sklearn estimator used.\n        :param 'func_args': variable length keyworded argument\n            The parameters passed to the sklearn estimator.\n        \"\"\"", "\n", "if", "action", "==", "\"linear_regression\"", ":", "\n", "            ", "return", "LinearRegression", "(", "**", "func_args", ")", "\n", "", "elif", "action", "==", "\"knn\"", ":", "\n", "            ", "return", "KNeighborsRegressor", "(", "**", "func_args", ")", "\n", "", "elif", "action", "==", "\"svm\"", ":", "\n", "            ", "return", "SVR", "(", "**", "func_args", ")", "\n", "", "elif", "action", "==", "\"random_forest\"", ":", "\n", "            ", "return", "RandomForestRegressor", "(", "**", "func_args", ")", "\n", "", "elif", "action", "==", "\"neural_network\"", ":", "\n", "            ", "return", "MLPRegressor", "(", "**", "func_args", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"The function: {} is not supported by dowhy at the moment.\"", ".", "format", "(", "action", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.permute": [[555, 583], ["pandas.DataFrame", "outcome[].sample", "ValueError", "numpy.where", "numpy.random.randint", "numpy.random.uniform"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample"], ["", "", "def", "permute", "(", "self", ",", "outcome", ",", "permute_fraction", ")", ":", "\n", "        ", "'''\n        If the permute_fraction is 1, we permute all the values in the outcome.\n        Otherwise we make use of the Fisher Yates shuffle.\n        Refer to https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle for more details.\n\n        :param 'outcome': np.ndarray\n            The outcome variable to be permuted.\n        :param 'permute_fraction': float [0, 1]\n            The fraction of rows permuted.\n        '''", "\n", "if", "permute_fraction", "==", "1", ":", "\n", "            ", "outcome", "=", "pd", ".", "DataFrame", "(", "outcome", ")", "\n", "outcome", ".", "columns", "=", "[", "self", ".", "_outcome_name_str", "]", "\n", "return", "outcome", "[", "self", ".", "_outcome_name_str", "]", ".", "sample", "(", "frac", "=", "1", ")", ".", "values", "\n", "", "elif", "permute_fraction", "<", "1", ":", "\n", "            ", "permute_fraction", "/=", "2", "# We do this as every swap leads to two changes", "\n", "changes", "=", "np", ".", "where", "(", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "outcome", ".", "shape", "[", "0", "]", ")", "<=", "permute_fraction", ")", "[", "0", "]", "# As this is tuple containing a single element (array[...])", "\n", "num_rows", "=", "outcome", ".", "shape", "[", "0", "]", "\n", "for", "change", "in", "changes", ":", "\n", "                ", "if", "change", "+", "1", "<", "num_rows", ":", "\n", "                    ", "index", "=", "np", ".", "random", ".", "randint", "(", "change", "+", "1", ",", "num_rows", ")", "\n", "temp", "=", "outcome", "[", "change", "]", "\n", "outcome", "[", "change", "]", "=", "outcome", "[", "index", "]", "\n", "outcome", "[", "index", "]", "=", "temp", "\n", "", "", "return", "outcome", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"The value of permute_fraction is {}. Which is greater than 1.\"", ".", "format", "(", "permute_fraction", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.dummy_outcome_refuter.DummyOutcomeRefuter.noise": [[584, 596], ["numpy.random.normal"], "methods", ["None"], ["", "", "def", "noise", "(", "self", ",", "outcome", ",", "std_dev", ")", ":", "\n", "        ", "\"\"\"\n        Add white noise with mean 0 and standard deviation = std_dev\n\n        :param 'outcome': np.ndarray\n            The outcome variable, to which the white noise is added.\n        :param 'std_dev': float\n            The standard deviation of the white noise.\n\n        :returns: outcome with added noise\n        \"\"\"", "\n", "return", "outcome", "+", "np", ".", "random", ".", "normal", "(", "scale", "=", "std_dev", ",", "size", "=", "outcome", ".", "shape", "[", "0", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.bootstrap_refuter.BootstrapRefuter.__init__": [[55, 83], ["dowhy.causal_refuter.CausalRefuter.__init__", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "kwargs.pop", "logging.getLogger", "bootstrap_refuter.BootstrapRefuter.choose_variables", "len", "bootstrap_refuter.BootstrapRefuter.logger.info", "bootstrap_refuter.BootstrapRefuter.logger.info", "bootstrap_refuter.BootstrapRefuter.logger.error", "ValueError", "bootstrap_refuter.BootstrapRefuter.logger.error", "ValueError"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.choose_variables"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_num_simulations", "=", "kwargs", ".", "pop", "(", "\"num_simulations\"", ",", "CausalRefuter", ".", "DEFAULT_NUM_SIMULATIONS", ")", "\n", "self", ".", "_sample_size", "=", "kwargs", ".", "pop", "(", "\"sample_size\"", ",", "len", "(", "self", ".", "_data", ")", ")", "\n", "required_variables", "=", "kwargs", ".", "pop", "(", "\"required_variables\"", ",", "True", ")", "\n", "self", ".", "_noise", "=", "kwargs", ".", "pop", "(", "\"noise\"", ",", "BootstrapRefuter", ".", "DEFAULT_STD_DEV", ")", "\n", "self", ".", "_probability_of_change", "=", "kwargs", ".", "pop", "(", "\"probability_of_change\"", ",", "None", ")", "\n", "self", ".", "_random_state", "=", "kwargs", ".", "pop", "(", "\"random_state\"", ",", "None", ")", "\n", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "self", ".", "_chosen_variables", "=", "self", ".", "choose_variables", "(", "required_variables", ")", "\n", "\n", "if", "self", ".", "_chosen_variables", "is", "None", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"INFO: There are no chosen variables\"", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"INFO: The chosen variables are: \"", "+", "\n", "\",\"", ".", "join", "(", "self", ".", "_chosen_variables", ")", ")", "\n", "\n", "", "if", "self", ".", "_probability_of_change", "is", "None", ":", "\n", "            ", "if", "self", ".", "_noise", ">", "1", ":", "\n", "                ", "self", ".", "logger", ".", "error", "(", "\"Error in using noise:{} for Binary Flip. The value is greater than 1\"", ".", "format", "(", "self", ".", "_noise", ")", ")", "\n", "raise", "ValueError", "(", "\"The value for Binary Flip cannot be greater than 1\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_probability_of_change", "=", "self", ".", "_noise", "\n", "", "", "elif", "self", ".", "_probability_of_change", ">", "1", ":", "\n", "            ", "self", ".", "logger", ".", "error", "(", "\"The probability of flip is: {}, However, this value cannot be greater than 1\"", ".", "format", "(", "self", ".", "_probability_of_change", ")", ")", "\n", "raise", "ValueError", "(", "\"Probability of Flip cannot be greater than 1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.bootstrap_refuter.BootstrapRefuter.refute_estimate": [[85, 145], ["numpy.zeros", "bootstrap_refuter.BootstrapRefuter.logger.info", "range", "dowhy.causal_refuter.CausalRefutation", "dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "dowhy.causal_refuter.CausalRefutation.add_refuter", "len", "bootstrap_refuter.BootstrapRefuter.logger.warning", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "numpy.mean", "bootstrap_refuter.BootstrapRefuter.test_significance", "sklearn.utils.resample", "sklearn.utils.resample", "new_data[].std", "numpy.random.normal", "numpy.random.uniform", "numpy.where", "numpy.logical_not", "new_data[].unique", "new_data[].apply", "changed_data.apply.apply.apply", "numpy.where", "new_data[].astype", "list", "random.choice", "set", "set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_significance_test_results", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.test_significance"], ["", "", "def", "refute_estimate", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "self", ".", "_sample_size", ">", "len", "(", "self", ".", "_data", ")", ":", "\n", "                ", "self", ".", "logger", ".", "warning", "(", "\"The sample size is larger than the population size\"", ")", "\n", "\n", "", "sample_estimates", "=", "np", ".", "zeros", "(", "self", ".", "_num_simulations", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Refutation over {} simulated datasets of size {} each\"", "\n", ".", "format", "(", "self", ".", "_num_simulations", "\n", ",", "self", ".", "_sample_size", ")", "\n", ")", "\n", "\n", "for", "index", "in", "range", "(", "self", ".", "_num_simulations", ")", ":", "\n", "            ", "if", "self", ".", "_random_state", "is", "None", ":", "\n", "                ", "new_data", "=", "resample", "(", "self", ".", "_data", ",", "\n", "n_samples", "=", "self", ".", "_sample_size", ")", "\n", "", "else", ":", "\n", "                ", "new_data", "=", "resample", "(", "self", ".", "_data", ",", "\n", "n_samples", "=", "self", ".", "_sample_size", ",", "\n", "random_state", "=", "self", ".", "_random_state", ")", "\n", "\n", "", "if", "self", ".", "_chosen_variables", "is", "not", "None", ":", "\n", "                ", "for", "variable", "in", "self", ".", "_chosen_variables", ":", "\n", "\n", "                    ", "if", "(", "'float'", "or", "'int'", ")", "in", "new_data", "[", "variable", "]", ".", "dtype", ".", "name", ":", "\n", "                        ", "scaling_factor", "=", "new_data", "[", "variable", "]", ".", "std", "(", ")", "\n", "new_data", "[", "variable", "]", "+=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "self", ".", "_noise", "*", "scaling_factor", ",", "size", "=", "self", ".", "_sample_size", ")", "\n", "\n", "", "elif", "'bool'", "in", "new_data", "[", "variable", "]", ".", "dtype", ".", "name", ":", "\n", "                        ", "probs", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "self", ".", "_sample_size", ")", "\n", "new_data", "[", "variable", "]", "=", "np", ".", "where", "(", "probs", "<", "self", ".", "_probability_of_change", ",", "\n", "np", ".", "logical_not", "(", "new_data", "[", "variable", "]", ")", ",", "\n", "new_data", "[", "variable", "]", ")", "\n", "\n", "", "elif", "'category'", "in", "new_data", "[", "variable", "]", ".", "dtype", ".", "name", ":", "\n", "                        ", "categories", "=", "new_data", "[", "variable", "]", ".", "unique", "(", ")", "\n", "# Find the set difference for each row", "\n", "changed_data", "=", "new_data", "[", "variable", "]", ".", "apply", "(", "lambda", "row", ":", "list", "(", "set", "(", "categories", ")", "-", "set", "(", "[", "row", "]", ")", ")", ")", "\n", "# Choose one out of the remaining", "\n", "changed_data", "=", "changed_data", ".", "apply", "(", "lambda", "row", ":", "random", ".", "choice", "(", "row", ")", ")", "\n", "new_data", "[", "variable", "]", "=", "np", ".", "where", "(", "probs", "<", "self", ".", "_probability_of_change", ",", "changed_data", ")", "\n", "new_data", "[", "variable", "]", ".", "astype", "(", "'category'", ")", "\n", "\n", "", "", "", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "self", ".", "_target_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "sample_estimates", "[", "index", "]", "=", "new_effect", ".", "value", "\n", "\n", "", "refute", "=", "CausalRefutation", "(", "\n", "self", ".", "_estimate", ".", "value", ",", "\n", "np", ".", "mean", "(", "sample_estimates", ")", ",", "\n", "refutation_type", "=", "\"Refute: Bootstrap Sample Dataset\"", "\n", ")", "\n", "\n", "# We want to see if the estimate falls in the same distribution as the one generated by the refuter", "\n", "# Ideally that should be the case as running bootstrap should not have a significant effect on the ability", "\n", "# of the treatment to affect the outcome", "\n", "refute", ".", "add_significance_test_results", "(", "\n", "self", ".", "test_significance", "(", "self", ".", "_estimate", ",", "sample_estimates", ")", "\n", ")", "\n", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "return", "refute", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.__init__.get_class_object": [[7, 21], ["string.capwords().replace", "importlib.import_module", "getattr", "issubclass", "ImportError", "string.capwords"], "function", ["None"], ["here", "=", "path", ".", "abspath", "(", "path", ".", "dirname", "(", "__file__", ")", ")", "\n", "# Loading version number", "\n", "with", "open", "(", "path", ".", "join", "(", "here", ",", "'VERSION'", ")", ")", "as", "version_file", ":", "\n", "    ", "__version__", "=", "version_file", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.__init__": [[31, 74], ["dowhy.causal_refuter.CausalRefuter.__init__", "logging.getLogger"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the parameters required for the refuter.\n\n        If effect_strength_on_treatment or effect_strength_on_outcome is not\n        given, it is calculated automatically as a range between the\n        minimum and maximum effect strength of observed confounders on treatment\n        and outcome respectively.\n\n        :param confounders_effect_on_treatment: str : The type of effect on the treatment due to the unobserved confounder. Possible values are ['binary_flip', 'linear']\n        :param confounders_effect_on_outcome: str : The type of effect on the outcome due to the unobserved confounder. Possible values are ['binary_flip', 'linear']\n        :param effect_strength_on_treatment: float, numpy.ndarray: This refers to the strength of the confounder on treatment. For a linear effect, it behaves like the regression coeffecient. For a binary flip it is the probability with which it can invert the value of the treatment.\n        :param effect_strength_on_outcome: float, numpy.ndarray: This refers to the strength of the confounder on outcome. For a linear effect, it behaves like the regression coefficient. For a binary flip, it is the probability with which it can invert the value of the outcome.\n        :param effect_fraction_on_treatment: float: If effect_strength_on_treatment is not provided, this parameter decides the effect strength of the simulated confounder as a fraction of the effect strength of observed confounders on treatment. Defaults to 1.\n        :param effect_fraction_on_outcome: float: If effect_strength_on_outcome is not provided, this parameter decides the effect strength of the simulated confounder as a fraction of the effect strength of observed confounders on outcome. Defaults to 1.\n        :param plotmethod: string: Type of plot to be shown. If None, no plot is generated. This parameter is used only only when more than one treatment confounder effect values or outcome confounder effect values are provided. Default is \"colormesh\". Supported values are \"contour\", \"colormesh\" when more than one value is provided for both confounder effect value parameters; \"line\" when provided for only one of them.\n        :param simulated_method_name: method type to add unobserved common cause. \"linear-partial-R2\" for linear sensitivity analysis\n        :param percent_change_estimate: It is the percentage of reduction of treatment estimate that could alter the results (default = 1)\n                                        if percent_change_estimate = 1, the robustness value describes the strength of association of confounders with treatment and outcome in order to reduce the estimate by 100% i.e bring it down to 0.\n        :param confounder_increases_estimate: True implies that confounder increases the absolute value of estimate and vice versa. (Default = False)\n        :param benchmark_common_causes: names of variables for bounding strength of confounders\n        :param significance_level: confidence interval for statistical inference(default = 0.05)\n        :param null_hypothesis_effect: assumed effect under the null hypothesis\n        :param plot_estimate: Generate contour plot for estimate while performing sensitivity analysis. (default = True). \n                              To override the setting, set plot_estimate = False.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "effect_on_t", "=", "kwargs", "[", "\"confounders_effect_on_treatment\"", "]", "if", "\"confounders_effect_on_treatment\"", "in", "kwargs", "else", "\"binary_flip\"", "\n", "self", ".", "effect_on_y", "=", "kwargs", "[", "\"confounders_effect_on_outcome\"", "]", "if", "\"confounders_effect_on_outcome\"", "in", "kwargs", "else", "\"linear\"", "\n", "self", ".", "kappa_t", "=", "kwargs", "[", "\"effect_strength_on_treatment\"", "]", "if", "\"effect_strength_on_treatment\"", "in", "kwargs", "else", "None", "\n", "self", ".", "kappa_y", "=", "kwargs", "[", "\"effect_strength_on_outcome\"", "]", "if", "\"effect_strength_on_outcome\"", "in", "kwargs", "else", "None", "\n", "self", ".", "frac_strength_treatment", "=", "kwargs", "[", "\"effect_fraction_on_treatment\"", "]", "if", "\"effect_fraction_on_treatment\"", "in", "kwargs", "else", "1", "\n", "self", ".", "frac_strength_outcome", "=", "kwargs", "[", "\"effect_fraction_on_outcome\"", "]", "if", "\"effect_fraction_on_outcome\"", "in", "kwargs", "else", "1", "\n", "self", ".", "simulated_method_name", "=", "kwargs", "[", "\"simulated_method_name\"", "]", "if", "\"simulated_method_name\"", "in", "kwargs", "else", "\"linear_based\"", "\n", "self", ".", "plotmethod", "=", "kwargs", "[", "'plotmethod'", "]", "if", "\"plotmethod\"", "in", "kwargs", "else", "\"colormesh\"", "\n", "self", ".", "percent_change_estimate", "=", "kwargs", "[", "\"percent_change_estimate\"", "]", "if", "'percent_change_estimate'", "in", "kwargs", "else", "1.0", "\n", "self", ".", "significance_level", "=", "kwargs", "[", "\"significance_level\"", "]", "if", "\"significance_level\"", "in", "kwargs", "else", "0.05", "\n", "self", ".", "confounder_increases_estimate", "=", "kwargs", "[", "\"confounder_increases_estimate\"", "]", "if", "\"confounder_increases_estimate\"", "in", "kwargs", "else", "False", "\n", "self", ".", "benchmark_common_causes", "=", "kwargs", "[", "\"benchmark_common_causes\"", "]", "if", "\"benchmark_common_causes\"", "in", "kwargs", "else", "None", "\n", "self", ".", "null_hypothesis_effect", "=", "kwargs", "[", "\"null_hypothesis_effect\"", "]", "if", "\"null_hypothesis_effect\"", "in", "kwargs", "else", "0", "\n", "self", ".", "plot_estimate", "=", "kwargs", "[", "\"plot_estimate\"", "]", "if", "\"plot_estimate\"", "in", "kwargs", "else", "True", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.infer_default_kappa_t": [[76, 126], ["add_unobserved_common_cause.AddUnobservedCommonCause._target_estimand.get_backdoor_variables", "sklearn.preprocessing.StandardScaler().fit_transform", "add_unobserved_common_cause.AddUnobservedCommonCause._compute_min_max_coeff", "add_unobserved_common_cause.AddUnobservedCommonCause.logger.info", "numpy.equal", "len", "pandas.get_dummies", "ValueError", "sklearn.linear_model.LogisticRegression().fit", "sklearn.linear_model.LogisticRegression().fit.predict().astype", "range", "numpy.arange", "sklearn.preprocessing.StandardScaler", "numpy.copy", "sklearn.linear_model.LogisticRegression().fit.predict().astype", "flips.append", "min", "max", "NotImplementedError", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression().fit.predict", "numpy.corrcoef", "numpy.std", "max", "min", "sklearn.linear_model.LogisticRegression().fit.predict", "numpy.sum", "abs"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause._compute_min_max_coeff", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "def", "infer_default_kappa_t", "(", "self", ",", "len_kappa_t", "=", "10", ")", ":", "\n", "        ", "\"\"\" Infer default effect strength of simulated confounder on treatment.\n\n        \"\"\"", "\n", "observed_common_causes_names", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "\n", "if", "len", "(", "observed_common_causes_names", ")", ">", "0", ":", "\n", "            ", "observed_common_causes", "=", "self", ".", "_data", "[", "observed_common_causes_names", "]", "\n", "observed_common_causes", "=", "pd", ".", "get_dummies", "(", "observed_common_causes", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"There needs to be at least one common cause to\"", "+", "\n", "\"automatically compute the default value of kappa_t.\"", "+", "\n", "\" Provide a value for kappa_t\"", ")", "\n", "", "t", "=", "self", ".", "_data", "[", "self", ".", "_treatment_name", "]", "\n", "# Standardizing the data", "\n", "observed_common_causes", "=", "StandardScaler", "(", ")", ".", "fit_transform", "(", "observed_common_causes", ")", "\n", "if", "self", ".", "effect_on_t", "==", "\"binary_flip\"", ":", "\n", "# Fit a model containing all confounders and compare predictions", "\n", "# using all features compared to all features except a given", "\n", "# confounder.", "\n", "            ", "tmodel", "=", "LogisticRegression", "(", ")", ".", "fit", "(", "observed_common_causes", ",", "t", ")", "\n", "tpred", "=", "tmodel", ".", "predict", "(", "observed_common_causes", ")", ".", "astype", "(", "int", ")", "\n", "flips", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "observed_common_causes", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "oldval", "=", "np", ".", "copy", "(", "observed_common_causes", "[", ":", ",", "i", "]", ")", "\n", "observed_common_causes", "[", ":", ",", "i", "]", "=", "0", "\n", "tcap", "=", "tmodel", ".", "predict", "(", "observed_common_causes", ")", ".", "astype", "(", "int", ")", "\n", "observed_common_causes", "[", ":", ",", "i", "]", "=", "oldval", "\n", "flips", ".", "append", "(", "np", ".", "sum", "(", "abs", "(", "tcap", "-", "tpred", ")", ")", "/", "tpred", ".", "shape", "[", "0", "]", ")", "\n", "", "min_coeff", ",", "max_coeff", "=", "min", "(", "flips", ")", ",", "max", "(", "flips", ")", "\n", "", "elif", "self", ".", "effect_on_t", "==", "\"linear\"", ":", "\n", "# Estimating the regression coefficient from standardized features to t", "\n", "            ", "corrcoef_var_t", "=", "np", ".", "corrcoef", "(", "observed_common_causes", ",", "t", ",", "rowvar", "=", "False", ")", "[", "-", "1", ",", ":", "-", "1", "]", "\n", "std_dev_t", "=", "np", ".", "std", "(", "t", ")", "[", "0", "]", "\n", "max_coeff", "=", "max", "(", "corrcoef_var_t", ")", "*", "std_dev_t", "\n", "min_coeff", "=", "min", "(", "corrcoef_var_t", ")", "*", "std_dev_t", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"'\"", "+", "self", ".", "effect_on_t", "+", "\n", "\"' method not supported for confounders' effect on treatment\"", ")", "\n", "\n", "", "min_coeff", ",", "max_coeff", "=", "self", ".", "_compute_min_max_coeff", "(", "min_coeff", ",", "max_coeff", ",", "\n", "self", ".", "frac_strength_treatment", ")", "\n", "# By default, return a plot with 10 points", "\n", "# consider 10 values of the effect of the unobserved confounder", "\n", "step", "=", "(", "max_coeff", "-", "min_coeff", ")", "/", "len_kappa_t", "\n", "self", ".", "logger", ".", "info", "(", "\"(Min, Max) kappa_t for observed common causes, ({0}, {1})\"", ".", "format", "(", "\n", "min_coeff", ",", "max_coeff", ")", ")", "\n", "if", "np", ".", "equal", "(", "max_coeff", ",", "min_coeff", ")", ":", "\n", "            ", "return", "max_coeff", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "arange", "(", "min_coeff", ",", "max_coeff", ",", "step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause._compute_min_max_coeff": [[127, 132], ["None"], "methods", ["None"], ["", "", "def", "_compute_min_max_coeff", "(", "self", ",", "\n", "min_coeff", ",", "max_coeff", ",", "effect_strength_fraction", ")", ":", "\n", "        ", "max_coeff", "=", "effect_strength_fraction", "*", "max_coeff", "\n", "min_coeff", "=", "effect_strength_fraction", "*", "min_coeff", "\n", "return", "min_coeff", ",", "max_coeff", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.infer_default_kappa_y": [[133, 181], ["add_unobserved_common_cause.AddUnobservedCommonCause._target_estimand.get_backdoor_variables", "sklearn.preprocessing.StandardScaler().fit_transform", "add_unobserved_common_cause.AddUnobservedCommonCause._compute_min_max_coeff", "add_unobserved_common_cause.AddUnobservedCommonCause.logger.info", "numpy.equal", "len", "pandas.get_dummies", "ValueError", "sklearn.linear_model.LogisticRegression().fit", "sklearn.linear_model.LogisticRegression().fit.predict().astype", "range", "numpy.arange", "sklearn.preprocessing.StandardScaler", "numpy.copy", "sklearn.linear_model.LogisticRegression().fit.predict().astype", "flips.append", "min", "max", "NotImplementedError", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression().fit.predict", "numpy.corrcoef", "numpy.std", "max", "min", "sklearn.linear_model.LogisticRegression().fit.predict", "numpy.sum", "abs"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.get_backdoor_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause._compute_min_max_coeff", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "def", "infer_default_kappa_y", "(", "self", ",", "len_kappa_y", "=", "10", ")", ":", "\n", "        ", "\"\"\" Infer default effect strength of simulated confounder on treatment.\n\n        \"\"\"", "\n", "observed_common_causes_names", "=", "self", ".", "_target_estimand", ".", "get_backdoor_variables", "(", ")", "\n", "if", "len", "(", "observed_common_causes_names", ")", ">", "0", ":", "\n", "            ", "observed_common_causes", "=", "self", ".", "_data", "[", "observed_common_causes_names", "]", "\n", "observed_common_causes", "=", "pd", ".", "get_dummies", "(", "observed_common_causes", ",", "drop_first", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"There needs to be at least one common cause to\"", "+", "\n", "\"automatically compute the default value of kappa_y.\"", "+", "\n", "\" Provide a value for kappa_y\"", ")", "\n", "", "y", "=", "self", ".", "_data", "[", "self", ".", "_outcome_name", "]", "\n", "# Standardizing the data", "\n", "observed_common_causes", "=", "StandardScaler", "(", ")", ".", "fit_transform", "(", "observed_common_causes", ")", "\n", "if", "self", ".", "effect_on_y", "==", "\"binary_flip\"", ":", "\n", "# Fit a model containing all confounders and compare predictions", "\n", "# using all features compared to all features except a given", "\n", "# confounder.", "\n", "            ", "ymodel", "=", "LogisticRegression", "(", ")", ".", "fit", "(", "observed_common_causes", ",", "y", ")", "\n", "ypred", "=", "ymodel", ".", "predict", "(", "observed_common_causes", ")", ".", "astype", "(", "int", ")", "\n", "flips", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "observed_common_causes", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "oldval", "=", "np", ".", "copy", "(", "observed_common_causes", "[", ":", ",", "i", "]", ")", "\n", "observed_common_causes", "[", ":", ",", "i", "]", "=", "0", "\n", "ycap", "=", "ymodel", ".", "predict", "(", "observed_common_causes", ")", ".", "astype", "(", "int", ")", "\n", "observed_common_causes", "[", ":", ",", "i", "]", "=", "oldval", "\n", "flips", ".", "append", "(", "np", ".", "sum", "(", "abs", "(", "ycap", "-", "ypred", ")", ")", "/", "ypred", ".", "shape", "[", "0", "]", ")", "\n", "", "min_coeff", ",", "max_coeff", "=", "min", "(", "flips", ")", ",", "max", "(", "flips", ")", "\n", "", "elif", "self", ".", "effect_on_y", "==", "\"linear\"", ":", "\n", "            ", "corrcoef_var_y", "=", "np", ".", "corrcoef", "(", "observed_common_causes", ",", "y", ",", "rowvar", "=", "False", ")", "[", "-", "1", ",", ":", "-", "1", "]", "\n", "std_dev_y", "=", "np", ".", "std", "(", "y", ")", "[", "0", "]", "\n", "max_coeff", "=", "max", "(", "corrcoef_var_y", ")", "*", "std_dev_y", "\n", "min_coeff", "=", "min", "(", "corrcoef_var_y", ")", "*", "std_dev_y", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"'\"", "+", "self", ".", "effect_on_y", "+", "\n", "\"' method not supported for confounders' effect on outcome\"", ")", "\n", "", "min_coeff", ",", "max_coeff", "=", "self", ".", "_compute_min_max_coeff", "(", "min_coeff", ",", "max_coeff", ",", "\n", "self", ".", "frac_strength_outcome", ")", "\n", "# By default, return a plot with 10 points", "\n", "# consider 10 values of the effect of the unobserved confounder", "\n", "step", "=", "(", "max_coeff", "-", "min_coeff", ")", "/", "len_kappa_y", "\n", "self", ".", "logger", ".", "info", "(", "\"(Min, Max) kappa_y for observed common causes, ({0}, {1})\"", ".", "format", "(", "\n", "min_coeff", ",", "max_coeff", ")", ")", "\n", "if", "np", ".", "equal", "(", "max_coeff", ",", "min_coeff", ")", ":", "\n", "            ", "return", "max_coeff", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "arange", "(", "min_coeff", ",", "max_coeff", ",", "step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate": [[182, 348], ["dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer", "dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.check_sensitivity", "add_unobserved_common_cause.AddUnobservedCommonCause.infer_default_kappa_t", "add_unobserved_common_cause.AddUnobservedCommonCause.infer_default_kappa_y", "copy.deepcopy", "add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "dowhy.causal_refuter.CausalRefutation", "numpy.array", "dowhy.causal_refuter.CausalRefutation.add_refuter", "isinstance", "NotImplementedError", "len", "NotImplementedError", "isinstance", "isinstance", "isinstance", "isinstance", "numpy.random.rand", "copy.deepcopy", "range", "dowhy.causal_refuter.CausalRefutation.add_refuter", "plt.figure", "plt.figure.add_axes", "contour_levels.extend", "plt.figure.add_axes.yaxis.set_ticks", "plt.figure.add_axes.xaxis.set_ticks", "plt.xticks", "plt.figure.add_axes.set_title", "plt.figure.add_axes.set_ylabel", "plt.figure.add_axes.set_xlabel", "plt.show", "isinstance", "len", "len", "len", "range", "numpy.min", "numpy.max", "plt.contourf", "plt.clabel", "plt.colorbar", "numpy.random.rand", "copy.deepcopy", "range", "dowhy.causal_refuter.CausalRefutation.add_refuter", "plt.figure", "plt.figure.add_axes", "plt.plot", "plt.axhline", "plt.figure.add_axes.set_title", "plt.figure.add_axes.set_xlabel", "plt.figure.add_axes.set_ylabel", "plt.show", "isinstance", "len", "add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "dowhy.causal_refuter.CausalRefutation", "numpy.min", "numpy.max", "plt.pcolormesh", "plt.colorbar", "len", "len", "add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "dowhy.causal_refuter.CausalRefutation", "add_unobserved_common_cause.AddUnobservedCommonCause.logger.debug", "numpy.min", "numpy.max", "numpy.random.rand", "copy.deepcopy", "range", "dowhy.causal_refuter.CausalRefutation.add_refuter", "plt.figure", "plt.figure.add_axes", "plt.plot", "plt.axhline", "plt.figure.add_axes.set_title", "plt.figure.add_axes.set_xlabel", "plt.figure.add_axes.set_ylabel", "plt.show", "sorted", "numpy.where", "len", "len", "add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect", "dowhy.causal_estimator.CausalEstimator.get_estimator_object", "dowhy.causal_estimator.CausalEstimator.get_estimator_object.estimate_effect", "dowhy.causal_refuter.CausalRefutation", "add_unobserved_common_cause.AddUnobservedCommonCause.logger.debug", "numpy.min", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.check_sensitivity", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.infer_default_kappa_t", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.infer_default_kappa_y", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefutation.add_refuter", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.get_estimator_object", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["", "", "def", "refute_estimate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This function attempts to add an unobserved common cause to the outcome and the treatment. At present, we have implemented the behavior for one dimensional behaviors for continuous\n        and binary variables. This function can either take single valued inputs or a range of inputs. The function then looks at the data type of the input and then decides on the course of\n        action.\n\n        :return: CausalRefuter: An object that contains the estimated effect and a new effect and the name of the refutation used.\n        \"\"\"", "\n", "if", "self", ".", "simulated_method_name", "==", "\"linear-partial-R2\"", ":", "\n", "            ", "if", "not", "(", "isinstance", "(", "self", ".", "_estimate", ".", "estimator", ",", "LinearRegressionEstimator", ")", ")", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\"Currently only LinearRegressionEstimator is supported for Sensitivity Analysis\"", ")", "\n", "\n", "", "if", "(", "len", "(", "self", ".", "_estimate", ".", "estimator", ".", "_effect_modifier_names", ")", ">", "0", ")", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\"The current implementation does not support effect modifiers\"", ")", "\n", "\n", "", "if", "(", "self", ".", "frac_strength_outcome", "==", "1", ")", ":", "\n", "                ", "self", ".", "frac_strength_outcome", "=", "self", ".", "frac_strength_treatment", "\n", "\n", "", "analyzer", "=", "LinearSensitivityAnalyzer", "(", "estimator", "=", "self", ".", "_estimate", ".", "estimator", ",", "\n", "data", "=", "self", ".", "_data", ",", "treatment_name", "=", "self", ".", "_treatment_name", ",", "\n", "percent_change_estimate", "=", "self", ".", "percent_change_estimate", ",", "significance_level", "=", "self", ".", "significance_level", ",", "benchmark_common_causes", "=", "self", ".", "benchmark_common_causes", ",", "null_hypothesis_effect", "=", "self", ".", "null_hypothesis_effect", ",", "\n", "frac_strength_treatment", "=", "self", ".", "frac_strength_treatment", ",", "frac_strength_outcome", "=", "self", ".", "frac_strength_outcome", ",", "common_causes_order", "=", "self", ".", "_estimate", ".", "estimator", ".", "_observed_common_causes", ".", "columns", ")", "\n", "\n", "analyzer", ".", "check_sensitivity", "(", "plot", "=", "self", ".", "plot_estimate", ")", "\n", "return", "analyzer", "\n", "", "if", "self", ".", "kappa_t", "is", "None", ":", "\n", "            ", "self", ".", "kappa_t", "=", "self", ".", "infer_default_kappa_t", "(", ")", "\n", "", "if", "self", ".", "kappa_y", "is", "None", ":", "\n", "            ", "self", ".", "kappa_y", "=", "self", ".", "infer_default_kappa_y", "(", ")", "\n", "", "if", "not", "isinstance", "(", "self", ".", "kappa_t", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", "and", "not", "isinstance", "(", "self", ".", "kappa_y", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", ":", "# Deal with single value inputs", "\n", "            ", "new_data", "=", "copy", ".", "deepcopy", "(", "self", ".", "_data", ")", "\n", "new_data", "=", "self", ".", "include_confounders_effect", "(", "new_data", ",", "self", ".", "kappa_t", ",", "self", ".", "kappa_y", ")", "\n", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "self", ".", "_target_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "refute", "=", "CausalRefutation", "(", "self", ".", "_estimate", ".", "value", ",", "new_effect", ".", "value", ",", "\n", "refutation_type", "=", "\"Refute: Add an Unobserved Common Cause\"", ")", "\n", "\n", "refute", ".", "new_effect_array", "=", "np", ".", "array", "(", "new_effect", ".", "value", ")", "\n", "refute", ".", "new_effect", "=", "new_effect", ".", "value", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "return", "refute", "\n", "\n", "", "else", ":", "# Deal with multiple value inputs", "\n", "\n", "            ", "if", "isinstance", "(", "self", ".", "kappa_t", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", "and", "isinstance", "(", "self", ".", "kappa_y", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", ":", "# Deal with range inputs", "\n", "# Get a 2D matrix of values", "\n", "#x,y =  np.meshgrid(self.kappa_t, self.kappa_y) # x,y are both MxN", "\n", "\n", "                ", "results_matrix", "=", "np", ".", "random", ".", "rand", "(", "len", "(", "self", ".", "kappa_t", ")", ",", "len", "(", "self", ".", "kappa_y", ")", ")", "# Matrix to hold all the results of NxM", "\n", "orig_data", "=", "copy", ".", "deepcopy", "(", "self", ".", "_data", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "kappa_t", ")", ")", ":", "\n", "                    ", "for", "j", "in", "range", "(", "len", "(", "self", ".", "kappa_y", ")", ")", ":", "\n", "                        ", "new_data", "=", "self", ".", "include_confounders_effect", "(", "orig_data", ",", "self", ".", "kappa_t", "[", "i", "]", ",", "self", ".", "kappa_y", "[", "j", "]", ")", "\n", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "self", ".", "_target_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "refute", "=", "CausalRefutation", "(", "self", ".", "_estimate", ".", "value", ",", "new_effect", ".", "value", ",", "\n", "refutation_type", "=", "\"Refute: Add an Unobserved Common Cause\"", ")", "\n", "results_matrix", "[", "i", "]", "[", "j", "]", "=", "refute", ".", "new_effect", "# Populate the results", "\n", "\n", "", "", "refute", ".", "new_effect_array", "=", "results_matrix", "\n", "refute", ".", "new_effect", "=", "(", "np", ".", "min", "(", "results_matrix", ")", ",", "np", ".", "max", "(", "results_matrix", ")", ")", "\n", "# Store the values into the refute object", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "if", "self", ".", "plotmethod", "is", "None", ":", "\n", "                    ", "return", "refute", "\n", "\n", "", "import", "matplotlib", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "6", ",", "5", ")", ")", "\n", "left", ",", "bottom", ",", "width", ",", "height", "=", "0.1", ",", "0.1", ",", "0.8", ",", "0.8", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "left", ",", "bottom", ",", "width", ",", "height", "]", ")", "\n", "\n", "oe", "=", "self", ".", "_estimate", ".", "value", "\n", "contour_levels", "=", "[", "oe", "/", "4.0", ",", "oe", "/", "2.0", ",", "(", "3.0", "/", "4", ")", "*", "oe", ",", "oe", "]", "\n", "contour_levels", ".", "extend", "(", "[", "0", ",", "np", ".", "min", "(", "results_matrix", ")", ",", "np", ".", "max", "(", "results_matrix", ")", "]", ")", "\n", "if", "self", ".", "plotmethod", "==", "\"contour\"", ":", "\n", "                    ", "cp", "=", "plt", ".", "contourf", "(", "self", ".", "kappa_y", ",", "self", ".", "kappa_t", ",", "results_matrix", ",", "\n", "levels", "=", "sorted", "(", "contour_levels", ")", ")", "\n", "# Adding a label on the contour line for the original estimate", "\n", "fmt", "=", "{", "}", "\n", "trueeffect_index", "=", "np", ".", "where", "(", "cp", ".", "levels", "==", "oe", ")", "[", "0", "]", "[", "0", "]", "\n", "fmt", "[", "cp", ".", "levels", "[", "trueeffect_index", "]", "]", "=", "\"Estimated Effect\"", "\n", "# Label every other level using strings", "\n", "plt", ".", "clabel", "(", "cp", ",", "[", "cp", ".", "levels", "[", "trueeffect_index", "]", "]", ",", "inline", "=", "True", ",", "fmt", "=", "fmt", ")", "\n", "plt", ".", "colorbar", "(", "cp", ")", "\n", "", "elif", "self", ".", "plotmethod", "==", "\"colormesh\"", ":", "\n", "                    ", "cp", "=", "plt", ".", "pcolormesh", "(", "self", ".", "kappa_y", ",", "self", ".", "kappa_t", ",", "results_matrix", ",", "\n", "shading", "=", "\"nearest\"", ")", "\n", "plt", ".", "colorbar", "(", "cp", ",", "ticks", "=", "contour_levels", ")", "\n", "", "ax", ".", "yaxis", ".", "set_ticks", "(", "self", ".", "kappa_t", ")", "\n", "ax", ".", "xaxis", ".", "set_ticks", "(", "self", ".", "kappa_y", ")", "\n", "plt", ".", "xticks", "(", "rotation", "=", "45", ")", "\n", "ax", ".", "set_title", "(", "'Effect of Unobserved Common Cause'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Value of Linear Constant on Treatment'", ")", "\n", "ax", ".", "set_xlabel", "(", "'Value of Linear Constant on Outcome'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "return", "refute", "\n", "\n", "", "elif", "isinstance", "(", "self", ".", "kappa_t", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", ":", "\n", "                ", "outcomes", "=", "np", ".", "random", ".", "rand", "(", "len", "(", "self", ".", "kappa_t", ")", ")", "\n", "orig_data", "=", "copy", ".", "deepcopy", "(", "self", ".", "_data", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "kappa_t", ")", ")", ":", "\n", "                    ", "new_data", "=", "self", ".", "include_confounders_effect", "(", "orig_data", ",", "self", ".", "kappa_t", "[", "i", "]", ",", "self", ".", "kappa_y", ")", "\n", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "self", ".", "_target_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "refute", "=", "CausalRefutation", "(", "self", ".", "_estimate", ".", "value", ",", "new_effect", ".", "value", ",", "\n", "refutation_type", "=", "\"Refute: Add an Unobserved Common Cause\"", ")", "\n", "self", ".", "logger", ".", "debug", "(", "refute", ")", "\n", "outcomes", "[", "i", "]", "=", "refute", ".", "new_effect", "# Populate the results", "\n", "\n", "", "refute", ".", "new_effect_array", "=", "outcomes", "\n", "refute", ".", "new_effect", "=", "(", "np", ".", "min", "(", "outcomes", ")", ",", "np", ".", "max", "(", "outcomes", ")", ")", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "if", "self", ".", "plotmethod", "is", "None", ":", "\n", "                    ", "return", "refute", "\n", "\n", "", "import", "matplotlib", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "6", ",", "5", ")", ")", "\n", "left", ",", "bottom", ",", "width", ",", "height", "=", "0.1", ",", "0.1", ",", "0.8", ",", "0.8", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "left", ",", "bottom", ",", "width", ",", "height", "]", ")", "\n", "\n", "plt", ".", "plot", "(", "self", ".", "kappa_t", ",", "outcomes", ")", "\n", "plt", ".", "axhline", "(", "self", ".", "_estimate", ".", "value", ",", "linestyle", "=", "'--'", ",", "color", "=", "\"gray\"", ")", "\n", "ax", ".", "set_title", "(", "'Effect of Unobserved Common Cause'", ")", "\n", "ax", ".", "set_xlabel", "(", "'Value of Linear Constant on Treatment'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Estimated Effect after adding the common cause'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "return", "refute", "\n", "\n", "", "elif", "isinstance", "(", "self", ".", "kappa_y", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", ":", "\n", "                ", "outcomes", "=", "np", ".", "random", ".", "rand", "(", "len", "(", "self", ".", "kappa_y", ")", ")", "\n", "orig_data", "=", "copy", ".", "deepcopy", "(", "self", ".", "_data", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "kappa_y", ")", ")", ":", "\n", "                    ", "new_data", "=", "self", ".", "include_confounders_effect", "(", "orig_data", ",", "self", ".", "kappa_t", ",", "self", ".", "kappa_y", "[", "i", "]", ")", "\n", "new_estimator", "=", "CausalEstimator", ".", "get_estimator_object", "(", "new_data", ",", "self", ".", "_target_estimand", ",", "self", ".", "_estimate", ")", "\n", "new_effect", "=", "new_estimator", ".", "estimate_effect", "(", ")", "\n", "refute", "=", "CausalRefutation", "(", "self", ".", "_estimate", ".", "value", ",", "new_effect", ".", "value", ",", "\n", "refutation_type", "=", "\"Refute: Add an Unobserved Common Cause\"", ")", "\n", "self", ".", "logger", ".", "debug", "(", "refute", ")", "\n", "outcomes", "[", "i", "]", "=", "refute", ".", "new_effect", "# Populate the results", "\n", "\n", "", "refute", ".", "new_effect_array", "=", "outcomes", "\n", "refute", ".", "new_effect", "=", "(", "np", ".", "min", "(", "outcomes", ")", ",", "np", ".", "max", "(", "outcomes", ")", ")", "\n", "refute", ".", "add_refuter", "(", "self", ")", "\n", "if", "self", ".", "plotmethod", "is", "None", ":", "\n", "                    ", "return", "refute", "\n", "\n", "", "import", "matplotlib", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "6", ",", "5", ")", ")", "\n", "left", ",", "bottom", ",", "width", ",", "height", "=", "0.1", ",", "0.1", ",", "0.8", ",", "0.8", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "left", ",", "bottom", ",", "width", ",", "height", "]", ")", "\n", "\n", "plt", ".", "plot", "(", "self", ".", "kappa_y", ",", "outcomes", ")", "\n", "plt", ".", "axhline", "(", "self", ".", "_estimate", ".", "value", ",", "linestyle", "=", "'--'", ",", "color", "=", "\"gray\"", ")", "\n", "ax", ".", "set_title", "(", "'Effect of Unobserved Common Cause'", ")", "\n", "ax", ".", "set_xlabel", "(", "'Value of Linear Constant on Outcome'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Estimated Effect after adding the common cause'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "return", "refute", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.include_confounders_effect": [[349, 401], ["scipy.stats.norm", "scipy.stats.norm.rvs", "scipy.stats.norm.interval", "scipy.stats.norm.interval", "pandas.api.types.is_bool_dtype", "NotImplementedError", "pandas.api.types.is_bool_dtype", "NotImplementedError", "new_data.astype.astype.astype", "numpy.ndarray", "new_data.astype.astype.astype", "numpy.ndarray"], "methods", ["None"], ["", "", "", "def", "include_confounders_effect", "(", "self", ",", "new_data", ",", "kappa_t", ",", "kappa_y", ")", ":", "\n", "        ", "\"\"\"\n        This function deals with the change in the value of the data due to the effect of the unobserved confounder.\n        In the case of a binary flip, we flip only if the random number is greater than the threshold set.\n        In the case of a linear effect, we use the variable as the linear regression constant.\n\n        :param new_data: pandas.DataFrame: The data to be changed due to the effects of the unobserved confounder.\n        :param kappa_t: numpy.float64: The value of the threshold for binary_flip or the value of the regression coefficient for linear effect.\n        :param kappa_y: numpy.float64: The value of the threshold for binary_flip or the value of the regression coefficient for linear effect.\n\n        :return: pandas.DataFrame: The DataFrame that includes the effects of the unobserved confounder.\n        \"\"\"", "\n", "num_rows", "=", "self", ".", "_data", ".", "shape", "[", "0", "]", "\n", "stdnorm", "=", "scipy", ".", "stats", ".", "norm", "(", ")", "\n", "w_random", "=", "stdnorm", ".", "rvs", "(", "num_rows", ")", "\n", "\n", "if", "self", ".", "effect_on_t", "==", "\"binary_flip\"", ":", "\n", "            ", "alpha", "=", "2", "*", "kappa_t", "-", "1", "if", "kappa_t", ">=", "0.5", "else", "1", "-", "2", "*", "kappa_t", "\n", "interval", "=", "stdnorm", ".", "interval", "(", "alpha", ")", "\n", "rel_interval", "=", "interval", "[", "0", "]", "if", "kappa_t", ">=", "0.5", "else", "interval", "[", "1", "]", "\n", "new_data", ".", "loc", "[", "rel_interval", "<=", "w_random", ",", "self", ".", "_treatment_name", "]", "=", "1", "-", "new_data", ".", "loc", "[", "rel_interval", "<=", "w_random", ",", "self", ".", "_treatment_name", "]", "\n", "for", "tname", "in", "self", ".", "_treatment_name", ":", "\n", "                ", "if", "pd", ".", "api", ".", "types", ".", "is_bool_dtype", "(", "self", ".", "_data", "[", "tname", "]", ")", ":", "\n", "                    ", "new_data", "=", "new_data", ".", "astype", "(", "{", "tname", ":", "'bool'", "}", ",", "copy", "=", "False", ")", "\n", "", "", "", "elif", "self", ".", "effect_on_t", "==", "\"linear\"", ":", "\n", "            ", "confounder_t_effect", "=", "kappa_t", "*", "w_random", "\n", "# By default, we add the effect of simulated confounder for treatment.", "\n", "# But subtract it from outcome to create a negative correlation", "\n", "# assuming that the original confounder's effect was positive on both.", "\n", "# This is to remove the effect of the original confounder.", "\n", "new_data", "[", "self", ".", "_treatment_name", "]", "=", "new_data", "[", "self", ".", "_treatment_name", "]", ".", "values", "+", "np", ".", "ndarray", "(", "shape", "=", "(", "num_rows", ",", "1", ")", ",", "buffer", "=", "confounder_t_effect", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"'\"", "+", "self", ".", "effect_on_t", "+", "\"' method not supported for confounders' effect on treatment\"", ")", "\n", "\n", "", "if", "self", ".", "effect_on_y", "==", "\"binary_flip\"", ":", "\n", "            ", "alpha", "=", "2", "*", "kappa_y", "-", "1", "if", "kappa_y", ">=", "0.5", "else", "1", "-", "2", "*", "kappa_y", "\n", "interval", "=", "stdnorm", ".", "interval", "(", "alpha", ")", "\n", "rel_interval", "=", "interval", "[", "0", "]", "if", "kappa_y", ">=", "0.5", "else", "interval", "[", "1", "]", "\n", "new_data", ".", "loc", "[", "rel_interval", "<=", "w_random", ",", "self", ".", "_outcome_name", "]", "=", "1", "-", "new_data", ".", "loc", "[", "rel_interval", "<=", "w_random", ",", "self", ".", "_outcome_name", "]", "\n", "for", "yname", "in", "self", ".", "_outcome_name", ":", "\n", "                ", "if", "pd", ".", "api", ".", "types", ".", "is_bool_dtype", "(", "self", ".", "_data", "[", "yname", "]", ")", ":", "\n", "                    ", "new_data", "=", "new_data", ".", "astype", "(", "{", "yname", ":", "'bool'", "}", ",", "copy", "=", "False", ")", "\n", "", "", "", "elif", "self", ".", "effect_on_y", "==", "\"linear\"", ":", "\n", "            ", "confounder_y_effect", "=", "(", "-", "1", ")", "*", "kappa_y", "*", "w_random", "\n", "# By default, we add the effect of simulated confounder for treatment.", "\n", "# But subtract it from outcome to create a negative correlation", "\n", "# assuming that the original confounder's effect was positive on both.", "\n", "# This is to remove the effect of the original confounder.", "\n", "new_data", "[", "self", ".", "_outcome_name", "]", "=", "new_data", "[", "self", ".", "_outcome_name", "]", ".", "values", "+", "np", ".", "ndarray", "(", "shape", "=", "(", "num_rows", ",", "1", ")", ",", "buffer", "=", "confounder_y_effect", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"'\"", "+", "self", ".", "effect_on_y", "+", "\"' method not supported for confounders' effect on outcome\"", ")", "\n", "", "return", "new_data", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.include_simulated_confounder": [[404, 581], ["add_unobserved_common_cause.AddUnobservedCommonCause.choose_variables", "statsmodels.OLS", "statsmodels.OLS.fit", "list", "add_unobserved_common_cause.AddUnobservedCommonCause._data[].astype", "statsmodels.OLS", "statsmodels.OLS.fit", "list", "int", "range", "math.sqrt", "math.sqrt", "add_unobserved_common_cause.AddUnobservedCommonCause.generate_confounder_from_residuals", "X.astype", "pandas.Series", "pandas.Series", "current_obs_confounder.corr", "current_obs_confounder.corr", "int", "math.sqrt", "add_unobserved_common_cause.AddUnobservedCommonCause.generate_confounder_from_residuals", "current_simulated_confounder.corr", "correlation_y_list.append", "current_simulated_confounder.corr", "correlation_t_list.append", "product_cor_metric_simulated_list.append", "x_list.append", "len", "add_unobserved_common_cause.AddUnobservedCommonCause.generate_confounder_from_residuals", "current_simulated_confounder.corr", "current_simulated_confounder.corr", "abs", "abs"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_refuter.CausalRefuter.choose_variables", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.generate_confounder_from_residuals", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.generate_confounder_from_residuals", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.generate_confounder_from_residuals"], ["", "def", "include_simulated_confounder", "(", "self", ",", "convergence_threshold", "=", "0.1", ",", "c_star_max", "=", "1000", ")", ":", "\n", "        ", "'''\n        This function simulates an unobserved confounder based on the data using the following steps:\n        1. It calculates the \"residuals\"  from the treatment and outcome model\n        i.) The outcome model has outcome as the dependent variable and all the observed variables including treatment as independent variables\n        ii.) The treatment model has treatment as the dependent variable and all the observed variables as independent variables.\n\n        2. U is an intermediate random variable drawn from the normal distribution with the weighted average of residuals as mean and a unit variance\n        U ~ N(c1*d_y + c2*d_t, 1)\n        where\n        *d_y and d_t are residuals from the treatment and outcome model\n        *c1 and c2 are coefficients to the residuals\n\n        3. The final U, which is the simulated unobserved confounder is obtained by debiasing the intermediate variable U by residualising it with X\n\n\n        Choosing the coefficients c1 and c2:\n        The coefficients are chosen based on these basic assumptions:\n        1. There is a hyperbolic relationship satisfying c1*c2 = c_star\n        2. c_star is chosen from a range of possible values based on the correlation of the obtained simulated variable with outcome and treatment.\n        3. The product of correlations with treatment and outcome should be at a minimum distance to the maximum correlations with treatment and outcome in any of the observed confounders\n        4. The ratio of the weights should be such that they maintain the ratio of the maximum possible observed coefficients within some confidence interval\n\n        :param c_star_max: The maximum possible value for the hyperbolic curve on which the coefficients to the residuals lie. It defaults to 1000 in the code if not specified by the user.\n            :type int\n        :param convergence_threshold: The threshold to check the plateauing of the correlation while selecting a c_star. It defaults to 0.1 in the code if not specified by the user\n            :type float\n\n        :returns: The simulated values of the unobserved confounder based on the data\n            :type pandas.core.series.Series\n\n        '''", "\n", "\n", "\n", "#Obtaining the list of observed variables", "\n", "required_variables", "=", "True", "\n", "observed_variables", "=", "self", ".", "choose_variables", "(", "required_variables", ")", "\n", "\n", "observed_variables_with_treatment_and_outcome", "=", "observed_variables", "+", "self", ".", "_treatment_name", "+", "self", ".", "_outcome_name", "\n", "\n", "#Taking a subset of the dataframe that has only observed variables", "\n", "self", ".", "_data", "=", "self", ".", "_data", "[", "observed_variables_with_treatment_and_outcome", "]", "\n", "\n", "#Residuals from the outcome model obtained by fitting a linear model", "\n", "y", "=", "self", ".", "_data", "[", "self", ".", "_outcome_name", "[", "0", "]", "]", "\n", "observed_variables_with_treatment", "=", "observed_variables", "+", "self", ".", "_treatment_name", "\n", "X", "=", "self", ".", "_data", "[", "observed_variables_with_treatment", "]", "\n", "model", "=", "sm", ".", "OLS", "(", "y", ",", "X", ".", "astype", "(", "'float'", ")", ")", "\n", "results", "=", "model", ".", "fit", "(", ")", "\n", "residuals_y", "=", "y", "-", "results", ".", "fittedvalues", "\n", "d_y", "=", "list", "(", "pd", ".", "Series", "(", "residuals_y", ")", ")", "\n", "\n", "\n", "#Residuals from the treatment model obtained by fitting a linear model", "\n", "t", "=", "self", ".", "_data", "[", "self", ".", "_treatment_name", "[", "0", "]", "]", ".", "astype", "(", "'int64'", ")", "\n", "X", "=", "self", ".", "_data", "[", "observed_variables", "]", "\n", "model", "=", "sm", ".", "OLS", "(", "t", ",", "X", ")", "\n", "results", "=", "model", ".", "fit", "(", ")", "\n", "residuals_t", "=", "t", "-", "results", ".", "fittedvalues", "\n", "d_t", "=", "list", "(", "pd", ".", "Series", "(", "residuals_t", ")", ")", "\n", "\n", "\n", "#Initialising product_cor_metric_observed with a really low value as finding maximum", "\n", "product_cor_metric_observed", "=", "-", "10000000000", "\n", "\n", "for", "i", "in", "observed_variables", ":", "\n", "            ", "current_obs_confounder", "=", "self", ".", "_data", "[", "i", "]", "\n", "outcome_values", "=", "self", ".", "_data", "[", "self", ".", "_outcome_name", "[", "0", "]", "]", "\n", "correlation_y", "=", "current_obs_confounder", ".", "corr", "(", "outcome_values", ")", "\n", "treatment_values", "=", "t", "\n", "correlation_t", "=", "current_obs_confounder", ".", "corr", "(", "treatment_values", ")", "\n", "product_cor_metric_current", "=", "correlation_y", "*", "correlation_t", "\n", "if", "product_cor_metric_current", ">=", "product_cor_metric_observed", ":", "\n", "                ", "product_cor_metric_observed", "=", "product_cor_metric_current", "\n", "correlation_t_observed", "=", "correlation_t", "\n", "correlation_y_observed", "=", "correlation_y", "\n", "\n", "\n", "#The user has an option to give the the effect_strength_on_y and effect_strength_on_t which can be then used instead of maximum correlation with treatment and outcome in the observed variables as it specifies the desired effect.", "\n", "", "", "if", "self", ".", "kappa_t", "is", "not", "None", ":", "\n", "            ", "correlation_t_observed", "=", "self", ".", "kappa_t", "\n", "", "if", "self", ".", "kappa_y", "is", "not", "None", ":", "\n", "            ", "correlation_y_observed", "=", "self", ".", "kappa_y", "\n", "\n", "\n", "#Choosing a c_star based on the data.", "\n", "#The correlations stop increasing upon increasing c_star after a certain value, that is it plateaus and we choose the value of c_star to be the value it plateaus.", "\n", "\n", "", "correlation_y_list", "=", "[", "]", "\n", "correlation_t_list", "=", "[", "]", "\n", "product_cor_metric_simulated_list", "=", "[", "]", "\n", "x_list", "=", "[", "]", "\n", "\n", "\n", "step", "=", "int", "(", "c_star_max", "/", "10", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "int", "(", "c_star_max", ")", ",", "step", ")", ":", "\n", "            ", "c1", "=", "math", ".", "sqrt", "(", "i", ")", "\n", "c2", "=", "c1", "\n", "final_U", "=", "self", ".", "generate_confounder_from_residuals", "(", "c1", ",", "c2", ",", "d_y", ",", "d_t", ",", "X", ")", "\n", "current_simulated_confounder", "=", "final_U", "\n", "outcome_values", "=", "self", ".", "_data", "[", "self", ".", "_outcome_name", "[", "0", "]", "]", "\n", "correlation_y", "=", "current_simulated_confounder", ".", "corr", "(", "outcome_values", ")", "\n", "correlation_y_list", ".", "append", "(", "correlation_y", ")", "\n", "\n", "treatment_values", "=", "t", "\n", "correlation_t", "=", "current_simulated_confounder", ".", "corr", "(", "treatment_values", ")", "\n", "correlation_t_list", ".", "append", "(", "correlation_t", ")", "\n", "\n", "product_cor_metric_simulated", "=", "correlation_y", "*", "correlation_t", "\n", "product_cor_metric_simulated_list", ".", "append", "(", "product_cor_metric_simulated", ")", "\n", "\n", "\n", "x_list", ".", "append", "(", "i", ")", "\n", "\n", "\n", "", "index", "=", "1", "\n", "while", "index", "<", "len", "(", "correlation_y_list", ")", ":", "\n", "            ", "if", "(", "correlation_y_list", "[", "index", "]", "-", "correlation_y_list", "[", "index", "-", "1", "]", ")", "<=", "convergence_threshold", ":", "\n", "                ", "c_star", "=", "x_list", "[", "index", "]", "\n", "break", "\n", "", "index", "=", "index", "+", "1", "\n", "\n", "#Choosing c1 and c2 based on the hyperbolic relationship once c_star is chosen by going over various combinations of c1 and c2 values and choosing the combination which", "\n", "#which maintains the minimum distance between the product of correlations of the simulated variable and the product of maximum correlations of one of the observed variables", "\n", "# and additionally checks if the ratio of the weights are such that they maintain the ratio of the maximum possible observed coefficients within some confidence interval", "\n", "\n", "\n", "#c1_final and c2_final are initialised to the values on the hyperbolic curve such that c1_final = c2_final  and c1_final*c2_final = c_star", "\n", "", "c1_final", "=", "math", ".", "sqrt", "(", "c_star", ")", "\n", "c2_final", "=", "math", ".", "sqrt", "(", "c_star", ")", "\n", "\n", "\n", "#initialising min_distance_between_product_cor_metrics to be a value greater than 1", "\n", "min_distance_between_product_cor_metrics", "=", "1.5", "\n", "i", "=", "0.05", "\n", "\n", "threshold", "=", "c_star", "/", "0.05", "\n", "\n", "while", "i", "<=", "threshold", ":", "\n", "            ", "c2", "=", "i", "\n", "c1", "=", "c_star", "/", "c2", "\n", "final_U", "=", "self", ".", "generate_confounder_from_residuals", "(", "c1", ",", "c2", ",", "d_y", ",", "d_t", ",", "X", ")", "\n", "\n", "current_simulated_confounder", "=", "final_U", "\n", "outcome_values", "=", "self", ".", "_data", "[", "self", ".", "_outcome_name", "[", "0", "]", "]", "\n", "correlation_y", "=", "current_simulated_confounder", ".", "corr", "(", "outcome_values", ")", "\n", "\n", "treatment_values", "=", "t", "\n", "correlation_t", "=", "current_simulated_confounder", ".", "corr", "(", "treatment_values", ")", "\n", "\n", "product_cor_metric_simulated", "=", "correlation_y", "*", "correlation_t", "\n", "\n", "if", "min_distance_between_product_cor_metrics", ">=", "abs", "(", "product_cor_metric_simulated", "-", "product_cor_metric_observed", ")", ":", "\n", "                ", "min_distance_between_product_cor_metrics", "=", "abs", "(", "product_cor_metric_simulated", "-", "product_cor_metric_observed", ")", "\n", "additional_condition", "=", "(", "correlation_y_observed", "/", "correlation_t_observed", ")", "\n", "if", "(", "(", "c1", "/", "c2", ")", "<=", "(", "additional_condition", "+", "0.3", "*", "additional_condition", ")", ")", "and", "(", "(", "c1", "/", "c2", ")", ">=", "(", "additional_condition", "-", "0.3", "*", "additional_condition", ")", ")", ":", "#choose minimum positive value", "\n", "                    ", "c1_final", "=", "c1", "\n", "c2_final", "=", "c2", "\n", "\n", "", "", "i", "=", "i", "*", "1.5", "\n", "\n", "", "'''#closed form solution\n\n        print(\"c_star_max before closed form\", c_star_max)\n\n        if max_correlation_with_t == -1000:\n            c2 = 0\n            c1 = c_star_max\n        else:\n            additional_condition = abs(max_correlation_with_y/max_correlation_with_t)\n            print(\"additional_condition\", additional_condition)\n            c2 = math.sqrt(c_star_max/additional_condition)\n            c1 = c_star_max/c2'''", "\n", "\n", "final_U", "=", "self", ".", "generate_confounder_from_residuals", "(", "c1_final", ",", "c2_final", ",", "d_y", ",", "d_t", ",", "X", ")", "\n", "\n", "return", "final_U", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.generate_confounder_from_residuals": [[583, 616], ["range", "numpy.array", "statsmodels.OLS", "statsmodels.OLS.fit", "U.reshape.reshape.reshape", "pandas.Series", "len", "U.reshape.reshape.append", "numpy.random.normal"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "generate_confounder_from_residuals", "(", "self", ",", "c1", ",", "c2", ",", "d_y", ",", "d_t", ",", "X", ")", ":", "\n", "        ", "'''\n        This function takes the residuals from the treatment and outcome model and their coefficients and simulates the intermediate random variable U by taking\n        the row wise normal distribution corresponding to each residual value and then debiasing the intermediate variable to get the final variable.\n\n        :param c1: coefficient to the residual from the outcome model\n        :type float\n        :param c2: coefficient to the residual from the treatment model\n        :type float\n        :param d_y: residuals from the outcome model\n        :type list\n        :param d_t: residuals from the treatment model\n        :type list\n\n        :returns: The simulated values of the unobserved confounder based on the data\n        :type pandas.core.series.Series\n\n        '''", "\n", "U", "=", "[", "]", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "d_t", ")", ")", ":", "\n", "            ", "simulated_variable_mean", "=", "c1", "*", "d_y", "[", "j", "]", "+", "c2", "*", "d_t", "[", "j", "]", "\n", "simulated_variable_stddev", "=", "1", "\n", "U", ".", "append", "(", "np", ".", "random", ".", "normal", "(", "simulated_variable_mean", ",", "simulated_variable_stddev", ",", "1", ")", ")", "\n", "\n", "", "U", "=", "np", ".", "array", "(", "U", ")", "\n", "model", "=", "sm", ".", "OLS", "(", "U", ",", "X", ")", "\n", "results", "=", "model", ".", "fit", "(", ")", "\n", "U", "=", "U", ".", "reshape", "(", "-", "1", ",", ")", "\n", "final_U", "=", "U", "-", "results", ".", "fittedvalues", ".", "values", "\n", "final_U", "=", "pd", ".", "Series", "(", "U", ")", "\n", "\n", "return", "final_U", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.__init__": [[8, 24], ["logging.getLogger", "base.TestRefuter.logger.debug", "estimator_method.split"], "methods", ["None"], ["class", "TestEstimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "identifier_method", "=", "\"backdoor\"", ")", ":", "\n", "        ", "print", "(", "\"Error tolerance is\"", ",", "error_tolerance", ")", "\n", "self", ".", "_error_tolerance", "=", "error_tolerance", "\n", "self", ".", "_Estimator", "=", "Estimator", "\n", "self", ".", "_identifier_method", "=", "identifier_method", "\n", "\n", "", "def", "average_treatment_effect_test", "(", "self", ",", "dataset", "=", "\"linear\"", ",", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "1", ",", "num_instruments", "=", "1", ",", "\n", "num_effect_modifiers", "=", "0", ",", "num_treatments", "=", "1", ",", "\n", "num_frontdoor_variables", "=", "0", ",", "\n", "num_samples", "=", "100000", ",", "\n", "treatment_is_binary", "=", "True", ",", "\n", "treatment_is_category", "=", "False", ",", "\n", "outcome_is_binary", "=", "False", ",", "\n", "confidence_intervals", "=", "False", ",", "\n", "test_significance", "=", "False", ",", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.null_refutation_test": [[25, 192], ["print", "print", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.identify_effect.set_identifier_method", "dowhy.CausalModel.estimate_effect", "base.TestRefuter.logger.debug", "dowhy.datasets.linear_dataset", "dowhy.CausalModel.refute_estimate", "base.TestRefuter.logger.debug", "dowhy.CausalModel.refute_estimate", "abs", "print", "abs", "print", "print", "dowhy.CausalModel.refute_estimate", "dowhy.CausalModel.refute_estimate", "abs", "print", "print", "abs", "dowhy.CausalModel.refute_estimate", "dowhy.CausalModel.refute_estimate", "abs", "print", "print", "dowhy.CausalModel.refute_estimate", "dowhy.CausalModel.refute_estimate", "abs", "print", "print", "abs", "dowhy.CausalModel.refute_estimate", "dowhy.CausalModel.refute_estimate", "abs"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.IdentifiedEstimand.set_identifier_method", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate"], ["method_params", "=", "None", ")", ":", "\n", "        ", "if", "dataset", "==", "\"linear\"", ":", "\n", "            ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "beta", ",", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_effect_modifiers", "=", "num_effect_modifiers", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "num_frontdoor_variables", "=", "num_frontdoor_variables", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "treatment_is_category", "=", "treatment_is_category", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ")", "\n", "", "elif", "dataset", "==", "\"simple-iv\"", ":", "\n", "            ", "data", "=", "dowhy", ".", "datasets", ".", "simple_iv_dataset", "(", "beta", "=", "beta", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "treatment_is_binary", "=", "treatment_is_binary", ",", "\n", "outcome_is_binary", "=", "outcome_is_binary", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Dataset type not supported.\"", ")", "\n", "\n", "", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "test_significance", "\n", ")", "\n", "target_estimand", "=", "model", ".", "identify_effect", "(", ")", "\n", "target_estimand", ".", "set_identifier_method", "(", "self", ".", "_identifier_method", ")", "\n", "estimator_ate", "=", "self", ".", "_Estimator", "(", "\n", "data", "[", "'df'", "]", ",", "\n", "identified_estimand", "=", "target_estimand", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "control_value", "=", "0", ",", "\n", "treatment_value", "=", "1", ",", "\n", "test_significance", "=", "test_significance", ",", "\n", "evaluate_effect_strength", "=", "False", ",", "\n", "confidence_intervals", "=", "confidence_intervals", ",", "\n", "target_units", "=", "\"ate\"", ",", "\n", "effect_modifiers", "=", "data", "[", "\"effect_modifier_names\"", "]", ",", "\n", "**", "method_params", "\n", ")", "\n", "\n", "true_ate", "=", "data", "[", "\"ate\"", "]", "\n", "ate_estimate", "=", "estimator_ate", ".", "estimate_effect", "(", ")", "\n", "str", "(", "ate_estimate", ")", "# checking if str output is correctly created", "\n", "error", "=", "abs", "(", "ate_estimate", ".", "value", "-", "true_ate", ")", "\n", "print", "(", "\"Error in ATE estimate = {0} with tolerance {1}%. Estimated={2},True={3}\"", ".", "format", "(", "\n", "error", ",", "self", ".", "_error_tolerance", "*", "100", ",", "ate_estimate", ".", "value", ",", "true_ate", ")", "\n", ")", "\n", "res", "=", "True", "if", "(", "error", "<", "abs", "(", "true_ate", ")", "*", "self", ".", "_error_tolerance", ")", "else", "False", "\n", "assert", "res", "\n", "# Compute confidence intervals, standard error and significance tests", "\n", "if", "confidence_intervals", ":", "\n", "            ", "ate_estimate", ".", "get_confidence_intervals", "(", ")", "\n", "ate_estimate", ".", "get_confidence_intervals", "(", "confidence_level", "=", "0.99", ")", "\n", "ate_estimate", ".", "get_confidence_intervals", "(", "method", "=", "\"bootstrap\"", ")", "\n", "ate_estimate", ".", "get_standard_error", "(", ")", "\n", "ate_estimate", ".", "get_standard_error", "(", "method", "=", "\"bootstrap\"", ")", "\n", "", "if", "test_significance", ":", "\n", "            ", "ate_estimate", ".", "test_stat_significance", "(", ")", "\n", "ate_estimate", ".", "test_stat_significance", "(", "method", "=", "\"bootstrap\"", ")", "\n", "\n", "", "", "def", "average_treatment_effect_testsuite", "(", "self", ",", "tests_to_run", "=", "\"all\"", ",", "\n", "num_common_causes", "=", "[", "2", ",", "3", "]", ",", "num_instruments", "=", "[", "1", ",", "]", ",", "\n", "num_effect_modifiers", "=", "[", "0", ",", "]", ",", "num_treatments", "=", "[", "1", ",", "]", ",", "\n", "num_frontdoor_variables", "=", "[", "0", ",", "]", ",", "\n", "treatment_is_binary", "=", "[", "True", ",", "]", ",", "\n", "treatment_is_category", "=", "[", "False", ",", "]", ",", "\n", "outcome_is_binary", "=", "[", "False", ",", "]", ",", "\n", "confidence_intervals", "=", "[", "False", ",", "]", ",", "\n", "test_significance", "=", "[", "False", ",", "]", ",", "\n", "dataset", "=", "\"linear\"", ",", "\n", "method_params", "=", "None", ")", ":", "\n", "        ", "args_dict", "=", "{", "\n", "'num_common_causes'", ":", "num_common_causes", ",", "\n", "'num_instruments'", ":", "num_instruments", ",", "\n", "'num_effect_modifiers'", ":", "num_effect_modifiers", ",", "\n", "'num_treatments'", ":", "num_treatments", ",", "\n", "'num_frontdoor_variables'", ":", "num_frontdoor_variables", ",", "\n", "'treatment_is_binary'", ":", "treatment_is_binary", ",", "\n", "'treatment_is_category'", ":", "treatment_is_category", ",", "\n", "'outcome_is_binary'", ":", "outcome_is_binary", ",", "\n", "'confidence_intervals'", ":", "confidence_intervals", ",", "\n", "'test_significance'", ":", "test_significance", "\n", "}", "\n", "keys", ",", "values", "=", "zip", "(", "*", "args_dict", ".", "items", "(", ")", ")", "\n", "configs", "=", "[", "dict", "(", "zip", "(", "keys", ",", "v", ")", ")", "for", "v", "in", "itertools", ".", "product", "(", "*", "values", ")", "]", "\n", "for", "cfg", "in", "configs", ":", "\n", "            ", "print", "(", "\"\\nConfig:\"", ",", "cfg", ")", "\n", "cfg", "[", "'dataset'", "]", "=", "dataset", "\n", "cfg", "[", "'method_params'", "]", "=", "method_params", "\n", "self", ".", "average_treatment_effect_test", "(", "**", "cfg", ")", "\n", "\n", "", "", "def", "custom_data_average_treatment_effect_test", "(", "self", ",", "data", ")", ":", "\n", "        ", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", "\n", ")", "\n", "target_estimand", "=", "model", ".", "identify_effect", "(", ")", "\n", "estimator_ate", "=", "self", ".", "_Estimator", "(", "\n", "data", "[", "'df'", "]", ",", "\n", "identified_estimand", "=", "target_estimand", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "test_significance", "=", "None", "\n", ")", "\n", "true_ate", "=", "data", "[", "\"ate\"", "]", "\n", "ate_estimate", "=", "estimator_ate", ".", "estimate_effect", "(", ")", "\n", "error", "=", "ate_estimate", ".", "value", "-", "true_ate", "\n", "print", "(", "\"Error in ATE estimate = {0} with tolerance {1}%. Estimated={2},True={3}\"", ".", "format", "(", "\n", "error", ",", "self", ".", "_error_tolerance", "*", "100", ",", "ate_estimate", ".", "value", ",", "true_ate", ")", "\n", ")", "\n", "res", "=", "True", "if", "(", "error", "<", "true_ate", "*", "self", ".", "_error_tolerance", ")", "else", "False", "\n", "assert", "res", "\n", "\n", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite": [[193, 202], ["base.TestRefuter.null_refutation_test", "base.TestRefuter.null_refutation_test"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.null_refutation_test", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.null_refutation_test"], []], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite": [[203, 214], ["base.TestRefuter.null_refutation_test", "base.TestRefuter.null_refutation_test"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.null_refutation_test", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.null_refutation_test"], []], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.categorical_treatment_testsuite": [[215, 226], ["base.TestRefuter.null_refutation_test", "base.TestRefuter.null_refutation_test"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.null_refutation_test", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.null_refutation_test"], []], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_bootstrap_refuter.TestDataSubsetRefuter.test_refutation_bootstrap_refuter_continuous": [[13, 18], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.05", ",", "\"iv.instrumental_variable\"", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_bootstrap_refuter_continuous", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\"bootstrap_refuter\"", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "num_samples", "=", "num_samples", ")", "# Run both", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_bootstrap_refuter.TestDataSubsetRefuter.test_refutation_bootstrap_refuter_binary": [[19, 24], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.05", ",", "\"backdoor.propensity_score_matching\"", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_bootstrap_refuter_binary", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\"bootstrap_refuter\"", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_bootstrap_refuter.TestDataSubsetRefuter.test_refutation_bootstrap_refuter_continuous_integer_argument": [[26, 35], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_common_causes\"", ",", "\"required_variables\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.05", ",", "\"iv.instrumental_variable\"", ",", "5", ",", "3", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_bootstrap_refuter_continuous_integer_argument", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "num_common_causes", ",", "required_variables", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "\n", "estimator_method", ",", "\n", "\"bootstrap_refuter\"", ",", "\n", "required_variables", "=", "required_variables", ",", "\n", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "num_common_causes", "=", "num_common_causes", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "# Run atleast one common cause", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_bootstrap_refuter.TestDataSubsetRefuter.test_refutation_bootstrap_refuter_continuous_list_argument": [[36, 44], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_common_causes\"", ",", "\"required_variables\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.05", ",", "\"iv.instrumental_variable\"", ",", "5", ",", "[", "\"W0\"", ",", "\"W1\"", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_bootstrap_refuter_continuous_list_argument", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "num_common_causes", ",", "required_variables", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "\n", "estimator_method", ",", "\n", "\"bootstrap_refuter\"", ",", "\n", "required_variables", "=", "required_variables", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "num_common_causes", "=", "num_common_causes", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "# Run atleast one common cause", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_bootstrap_refuter.TestDataSubsetRefuter.test_refutation_bootstrap_refuter_binary_integer_argument": [[45, 53], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_common_causes\"", ",", "\"required_variables\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.propensity_score_matching\"", ",", "5", ",", "3", ",", "5000", ")", "]", ")", "\n", "def", "test_refutation_bootstrap_refuter_binary_integer_argument", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "num_common_causes", ",", "required_variables", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "\n", "estimator_method", ",", "\n", "\"bootstrap_refuter\"", ",", "\n", "required_variables", "=", "required_variables", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "num_common_causes", "=", "num_common_causes", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_bootstrap_refuter.TestDataSubsetRefuter.test_refutation_bootstrap_refuter_binary_list_argument": [[54, 62], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_common_causes\"", ",", "\"required_variables\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.propensity_score_matching\"", ",", "5", ",", "[", "\"W0\"", ",", "\"W1\"", "]", ",", "5000", ")", "]", ")", "\n", "def", "test_refutation_bootstrap_refuter_binary_list_argument", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "num_common_causes", ",", "required_variables", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "\n", "estimator_method", ",", "\n", "\"bootstrap_refuter\"", ",", "\n", "required_variables", "=", "required_variables", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "num_common_causes", "=", "num_common_causes", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_bootstrap_refuter.TestDataSubsetRefuter.test_refutation_bootstrap_refuter_continuous_list_negative_argument": [[63, 71], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_common_causes\"", ",", "\"required_variables\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"iv.instrumental_variable\"", ",", "5", ",", "[", "\"-W0\"", ",", "\"-W1\"", "]", ",", "5000", ")", "]", ")", "\n", "def", "test_refutation_bootstrap_refuter_continuous_list_negative_argument", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "num_common_causes", ",", "required_variables", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "\n", "estimator_method", ",", "\n", "\"bootstrap_refuter\"", ",", "\n", "required_variables", "=", "required_variables", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "num_common_causes", "=", "num_common_causes", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "# Run atleast one common cause", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_bootstrap_refuter.TestDataSubsetRefuter.test_refutation_bootstrap_refuter_binary_list_negative_argument": [[72, 80], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_common_causes\"", ",", "\"required_variables\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.propensity_score_matching\"", ",", "5", ",", "[", "\"-W0\"", ",", "\"-W1\"", "]", ",", "5000", ")", "]", ")", "\n", "def", "test_refutation_bootstrap_refuter_binary_list_negative_argument", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "num_common_causes", ",", "required_variables", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "\n", "estimator_method", ",", "\n", "\"bootstrap_refuter\"", ",", "\n", "required_variables", "=", "required_variables", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "num_common_causes", "=", "num_common_causes", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_data_subset_refuter.TestDataSubsetRefuter.test_refutation_data_subset_refuter_continuous": [[7, 12], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ")", "]", ")", "\n", "def", "test_refutation_data_subset_refuter_continuous", "(", "self", ",", "error_tolerance", ",", "estimator_method", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\"data_subset_refuter\"", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", ")", "# Run both", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_data_subset_refuter.TestDataSubsetRefuter.test_refutation_data_subset_refuter_binary": [[13, 18], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"backdoor.propensity_score_matching\"", ")", "]", ")", "\n", "def", "test_refutation_data_subset_refuter_binary", "(", "self", ",", "error_tolerance", ",", "estimator_method", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\"data_subset_refuter\"", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_placebo_refuter.TestPlaceboRefuter.test_refutation_placebo_refuter_continuous": [[10, 16], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.03", ",", "\"backdoor.linear_regression\"", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_placebo_refuter_continuous", "(", "self", ",", "error_tolerance", ",", "\n", "estimator_method", ",", "num_samples", ")", ":", "\n", "            ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\"placebo_treatment_refuter\"", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "num_samples", "=", "num_samples", ")", "# Run both", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_placebo_refuter.TestPlaceboRefuter.test_refutation_placebo_refuter_binary": [[17, 23], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.propensity_score_matching\"", ",", "5000", ")", "]", ")", "\n", "def", "test_refutation_placebo_refuter_binary", "(", "self", ",", "error_tolerance", ",", "\n", "estimator_method", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\"placebo_treatment_refuter\"", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_placebo_refuter.TestPlaceboRefuter.test_refutation_placebo_refuter_category": [[24, 30], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.categorical_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.categorical_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.linear_regression\"", ",", "5000", ")", "]", ")", "\n", "def", "test_refutation_placebo_refuter_category", "(", "self", ",", "error_tolerance", ",", "\n", "estimator_method", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\"placebo_treatment_refuter\"", ")", "\n", "refuter_tester", ".", "categorical_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_placebo_refuter.TestPlaceboRefuter.test_refutation_placebo_refuter_category_non_consecutive_index": [[31, 45], ["pytest.mark.parametrize", "base.TestRefuter", "dowhy.datasets.linear_dataset", "random.sample", "base.TestRefuter.null_refutation_test", "range"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.null_refutation_test"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.linear_regression\"", ",", "5000", ")", "]", ")", "\n", "def", "test_refutation_placebo_refuter_category_non_consecutive_index", "(", "self", ",", "error_tolerance", ",", "\n", "estimator_method", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\"placebo_treatment_refuter\"", ")", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "num_instruments", "=", "1", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "treatment_is_binary", "=", "False", ",", "\n", "treatment_is_category", "=", "True", ")", "\n", "random_index", "=", "random", ".", "sample", "(", "range", "(", "1", ",", "10", "*", "num_samples", ")", ",", "num_samples", ")", "\n", "data", "[", "'df'", "]", ".", "index", "=", "random_index", "\n", "refuter_tester", ".", "null_refutation_test", "(", "data", "=", "data", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_default_continuous_treatment": [[14, 19], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", "]", ",", "\n", "[", "(", "0.03", ",", "\"iv.instrumental_variable\"", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_default_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "estimator_method", ",", "\"dummy_outcome_refuter\"", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "num_dummyoutcome_simulations", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_default_binary_treatment": [[20, 25], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.propensity_score_matching\"", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_default_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "estimator_method", ",", "\"dummy_outcome_refuter\"", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_randomly_generated_continuous_treatment": [[26, 35], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", "]", ",", "\n", "[", "(", "0.05", ",", "\"iv.instrumental_variable\"", ",", "[", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_randomly_generated_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_randomly_generated_binary_treatment": [[36, 45], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.05", ",", "\"backdoor.propensity_score_matching\"", ",", "[", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_randomly_generated_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_permute_data_continuous_treatment": [[46, 55], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", "]", ",", "\n", "[", "(", "0.03", ",", "\"iv.instrumental_variable\"", ",", "[", "(", "\"permute\"", ",", "{", "'permute_fraction'", ":", "1", "}", ")", "]", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_permute_data_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_permute_data_binary_treatment": [[56, 65], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.linear_regression\"", ",", "[", "(", "\"permute\"", ",", "{", "'permute_fraction'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_permute_data_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_custom_function_linear_regression_with_noise_continuous_treatment": [[66, 74], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", "]", ",", "\n", "[", "(", "0.2", ",", "\"iv.instrumental_variable\"", ",", "[", "(", "simple_linear_outcome_model", ",", "{", "}", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_custom_function_linear_regression_with_noise_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_custom_function_linear_regression_with_noise_binary_treatment": [[75, 84], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "xfail", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.2", ",", "\"backdoor.linear_regression\"", ",", "[", "(", "simple_linear_outcome_model", ",", "{", "}", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_custom_function_linear_regression_with_noise_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_custom_function_linear_regression_with_permute_continuous_treatment": [[85, 93], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", "]", ",", "\n", "[", "(", "0.2", ",", "\"backdoor.linear_regression\"", ",", "[", "(", "\"permute\"", ",", "{", "'permute_fraction'", ":", "0.5", "}", ")", ",", "(", "simple_linear_outcome_model", ",", "{", "}", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_custom_function_linear_regression_with_permute_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_custom_function_linear_regression_with_permute_binary_treatment": [[94, 103], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "xfail", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.2", ",", "\"backdoor.propensity_score_matching\"", ",", "[", "(", "\"permute\"", ",", "{", "'permute_fraction'", ":", "0.5", "}", ")", ",", "(", "simple_linear_outcome_model", ",", "{", "}", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_custom_function_linear_regression_with_permute_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_linear_regression_continuous_treatment": [[105, 113], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ",", "[", "(", "\"linear_regression\"", ",", "{", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_linear_regression_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_linear_regression_binary_treatment": [[114, 122], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.2", ",", "\"backdoor.propensity_score_matching\"", ",", "[", "(", "\"linear_regression\"", ",", "{", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_linear_regression_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_knn_continuous_treatment": [[123, 131], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", "]", ",", "\n", "[", "(", "0.2", ",", "\"iv.instrumental_variable\"", ",", "[", "(", "\"knn\"", ",", "{", "'n_neighbors'", ":", "5", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_knn_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_knn_binary_treatment": [[132, 140], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.2", ",", "\"backdoor.propensity_score_matching\"", ",", "[", "(", "\"knn\"", ",", "{", "'n_neighbors'", ":", "5", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_knn_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_svm_continuous_treatment": [[141, 149], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ",", "[", "(", "\"svm\"", ",", "{", "'C'", ":", "1", ",", "'epsilon'", ":", "0.2", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "10000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_svm_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_svm_binary_treatment": [[150, 158], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.propensity_score_matching\"", ",", "[", "(", "\"svm\"", ",", "{", "'C'", ":", "1", ",", "'epsilon'", ":", "0.2", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_svm_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_random_forest_continuous_treatment": [[159, 167], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ",", "[", "(", "\"random_forest\"", ",", "{", "'max_depth'", ":", "20", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "10000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_random_forest_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "num_samples", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_random_forest_binary_treatment": [[168, 176], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.propensity_score_matching\"", ",", "[", "(", "\"random_forest\"", ",", "{", "'max_depth'", ":", "20", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_random_forest_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "num_samples", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_neural_network_continuous_treatment": [[178, 186], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ",", "[", "(", "\"neural_network\"", ",", "{", "'solver'", ":", "'lbfgs'", ",", "'alpha'", ":", "1e-5", ",", "'hidden_layer_sizes'", ":", "(", "5", ",", "2", ")", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_neural_network_continuous_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.TestDummyOutcomeRefuter.test_refutation_dummy_outcome_refuter_internal_neural_network_binary_treatment": [[187, 195], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerence\"", ",", "\"estimator_method\"", ",", "\"transformations\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "0.1", ",", "\"backdoor.propensity_score_matching\"", ",", "[", "(", "\"neural_network\"", ",", "{", "'solver'", ":", "'lbfgs'", ",", "'alpha'", ":", "1e-5", ",", "'hidden_layer_sizes'", ":", "(", "5", ",", "2", ")", "}", ")", ",", "(", "\"zero\"", ",", "\"\"", ")", ",", "(", "\"noise\"", ",", "{", "'std_dev'", ":", "1", "}", ")", "]", ",", "1000", ")", "]", ")", "\n", "def", "test_refutation_dummy_outcome_refuter_internal_neural_network_binary_treatment", "(", "self", ",", "error_tolerence", ",", "estimator_method", ",", "transformations", ",", "num_samples", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerence", ",", "\n", "estimator_method", ",", "\n", "\"dummy_outcome_refuter\"", ",", "\n", "transformations", "=", "transformations", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "num_samples", "=", "num_samples", ",", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_dummy_outcome_refuter.simple_linear_outcome_model": [[6, 10], ["None"], "function", ["None"], ["def", "simple_linear_outcome_model", "(", "X_train", ",", "output_train", ")", ":", "\n", "# The outcome is a linear function of the confounder", "\n", "# The slope is 1,2 and the intercept is 3", "\n", "    ", "return", "lambda", "X_train", ":", "X_train", "[", ":", ",", "0", "]", "+", "2", "*", "X_train", "[", ":", ",", "1", "]", "+", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_add_unobserved_common_cause.TestAddUnobservedCommonCauseRefuter.test_refutation_binary_treatment": [[10, 21], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.binary_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.binary_treatment_testsuite"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"effect_strength_on_t\"", ",", "\"effect_strength_on_y\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"backdoor.propensity_score_matching\"", ",", "0.01", ",", "0.02", ")", ",", "]", ")", "\n", "def", "test_refutation_binary_treatment", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "\n", "effect_strength_on_t", ",", "effect_strength_on_y", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\n", "\"add_unobserved_common_cause\"", ",", "\n", "confounders_effect_on_t", "=", "\"binary_flip\"", ",", "\n", "confounders_effect_on_y", "=", "\"linear\"", ",", "\n", "effect_strength_on_t", "=", "effect_strength_on_t", ",", "\n", "effect_strength_on_y", "=", "effect_strength_on_y", ")", "\n", "refuter_tester", ".", "binary_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_add_unobserved_common_cause.TestAddUnobservedCommonCauseRefuter.test_refutation_continuous_treatment": [[22, 33], ["pytest.mark.parametrize", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"effect_strength_on_t\"", ",", "\"effect_strength_on_y\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ",", "0.01", ",", "0.02", ")", ",", "]", ")", "\n", "def", "test_refutation_continuous_treatment", "(", "self", ",", "error_tolerance", ",", "estimator_method", ",", "\n", "effect_strength_on_t", ",", "effect_strength_on_y", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\n", "\"add_unobserved_common_cause\"", ",", "\n", "confounders_effect_on_t", "=", "\"linear\"", ",", "\n", "confounders_effect_on_y", "=", "\"linear\"", ",", "\n", "effect_strength_on_t", "=", "effect_strength_on_t", ",", "\n", "effect_strength_on_y", "=", "effect_strength_on_y", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_add_unobserved_common_cause.TestAddUnobservedCommonCauseRefuter.test_refutation_continuous_treatment_range_both_treatment_outcome": [[34, 47], ["pytest.mark.parametrize", "unittest.mock.patch", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite", "numpy.arange", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"effect_strength_on_t\"", ",", "\"effect_strength_on_y\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ",", "np", ".", "arange", "(", "0.01", ",", "0.02", ",", "0.001", ")", ",", "np", ".", "arange", "(", "0.02", ",", "0.03", ",", "0.001", ")", ")", ",", "]", ")", "\n", "@", "patch", "(", "\"matplotlib.pyplot.figure\"", ")", "\n", "def", "test_refutation_continuous_treatment_range_both_treatment_outcome", "(", "self", ",", "mock_fig", ",", "error_tolerance", ",", "estimator_method", ",", "\n", "effect_strength_on_t", ",", "effect_strength_on_y", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\n", "\"add_unobserved_common_cause\"", ",", "\n", "confounders_effect_on_t", "=", "\"linear\"", ",", "\n", "confounders_effect_on_y", "=", "\"linear\"", ",", "\n", "effect_strength_on_t", "=", "effect_strength_on_t", ",", "\n", "effect_strength_on_y", "=", "effect_strength_on_y", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "assert", "mock_fig", ".", "call_count", ">", "0", "# we patched figure plotting call to avoid drawing plots during tests", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_add_unobserved_common_cause.TestAddUnobservedCommonCauseRefuter.test_refutation_continuous_treatment_range_treatment": [[48, 61], ["pytest.mark.parametrize", "unittest.mock.patch", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"effect_strength_on_t\"", ",", "\"effect_strength_on_y\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ",", "np", ".", "arange", "(", "0.01", ",", "0.02", ",", "0.001", ")", ",", "0.02", ")", ",", "]", ")", "\n", "@", "patch", "(", "\"matplotlib.pyplot.figure\"", ")", "\n", "def", "test_refutation_continuous_treatment_range_treatment", "(", "self", ",", "mock_fig", ",", "error_tolerance", ",", "estimator_method", ",", "\n", "effect_strength_on_t", ",", "effect_strength_on_y", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\n", "\"add_unobserved_common_cause\"", ",", "\n", "confounders_effect_on_t", "=", "\"linear\"", ",", "\n", "confounders_effect_on_y", "=", "\"linear\"", ",", "\n", "effect_strength_on_t", "=", "effect_strength_on_t", ",", "\n", "effect_strength_on_y", "=", "effect_strength_on_y", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "assert", "mock_fig", ".", "call_count", ">", "0", "# we patched figure plotting call to avoid drawing plots during tests", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_add_unobserved_common_cause.TestAddUnobservedCommonCauseRefuter.test_refutation_continuous_treatment_range_outcome": [[62, 75], ["pytest.mark.parametrize", "unittest.mock.patch", "base.TestRefuter", "base.TestRefuter.continuous_treatment_testsuite", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.base.TestRefuter.continuous_treatment_testsuite"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"error_tolerance\"", ",", "\"estimator_method\"", ",", "\"effect_strength_on_t\"", ",", "\"effect_strength_on_y\"", "]", ",", "\n", "[", "(", "0.01", ",", "\"iv.instrumental_variable\"", ",", "0.01", ",", "np", ".", "arange", "(", "0.02", ",", "0.03", ",", "0.001", ")", ")", ",", "]", ")", "\n", "@", "patch", "(", "\"matplotlib.pyplot.figure\"", ")", "\n", "def", "test_refutation_continuous_treatment_range_outcome", "(", "self", ",", "mock_fig", ",", "error_tolerance", ",", "estimator_method", ",", "\n", "effect_strength_on_t", ",", "effect_strength_on_y", ")", ":", "\n", "        ", "refuter_tester", "=", "TestRefuter", "(", "error_tolerance", ",", "estimator_method", ",", "\n", "\"add_unobserved_common_cause\"", ",", "\n", "confounders_effect_on_t", "=", "\"linear\"", ",", "\n", "confounders_effect_on_y", "=", "\"linear\"", ",", "\n", "effect_strength_on_t", "=", "effect_strength_on_t", ",", "\n", "effect_strength_on_y", "=", "effect_strength_on_y", ")", "\n", "refuter_tester", ".", "continuous_treatment_testsuite", "(", "tests_to_run", "=", "\"atleast-one-common-cause\"", ")", "\n", "assert", "mock_fig", ".", "call_count", ">", "0", "# we patched figure plotting call to avoid drawing plots during tests", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_add_unobserved_common_cause.TestAddUnobservedCommonCauseRefuter.test_linear_sensitivity_with_confounders": [[76, 121], ["pytest.mark.parametrize", "unittest.mock.patch", "numpy.random.seed", "dowhy.datasets.linear_dataset", "data[].drop", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "dowhy.CausalModel.refute_estimate", "all", "all", "all", "all"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"estimator_method\"", ",", "\"effect_strength_on_t\"", ",", "\"benchmark_common_causes\"", ",", "\"simulated_method_name\"", "]", ",", "\n", "[", "(", "\"backdoor.linear_regression\"", ",", "[", "1", ",", "2", ",", "3", "]", ",", "[", "\"W3\"", "]", ",", "\"linear-partial-R2\"", ")", ",", "]", ")", "\n", "@", "patch", "(", "\"matplotlib.pyplot.figure\"", ")", "\n", "def", "test_linear_sensitivity_with_confounders", "(", "self", ",", "mock_fig", ",", "estimator_method", ",", "\n", "effect_strength_on_t", ",", "benchmark_common_causes", ",", "simulated_method_name", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "7", ",", "\n", "num_samples", "=", "500", ",", "\n", "num_treatments", "=", "1", ",", "\n", "stddev_treatment_noise", "=", "10", ",", "\n", "stddev_outcome_noise", "=", "1", "\n", ")", "\n", "data", "[", "\"df\"", "]", "=", "data", "[", "\"df\"", "]", ".", "drop", "(", "\"W4\"", ",", "axis", "=", "1", ")", "\n", "graph_str", "=", "'graph[directed 1node[ id \"y\" label \"y\"]node[ id \"W0\" label \"W0\"] node[ id \"W1\" label \"W1\"] node[ id \"W2\" label \"W2\"] node[ id \"W3\" label \"W3\"]  node[ id \"W5\" label \"W5\"] node[ id \"W6\" label \"W6\"]node[ id \"v0\" label \"v0\"]edge[source \"v0\" target \"y\"]edge[ source \"W0\" target \"v0\"] edge[ source \"W1\" target \"v0\"] edge[ source \"W2\" target \"v0\"] edge[ source \"W3\" target \"v0\"] edge[ source \"W5\" target \"v0\"] edge[ source \"W6\" target \"v0\"]edge[ source \"W0\" target \"y\"] edge[ source \"W1\" target \"y\"] edge[ source \"W2\" target \"y\"] edge[ source \"W3\" target \"y\"] edge[ source \"W5\" target \"y\"] edge[ source \"W6\" target \"y\"]]'", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "\"df\"", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "graph_str", ",", "\n", "test_significance", "=", "None", ",", "\n", ")", "\n", "target_estimand", "=", "model", ".", "identify_effect", "(", "proceed_when_unidentifiable", "=", "True", ")", "\n", "estimate", "=", "model", ".", "estimate_effect", "(", "target_estimand", ",", "method_name", "=", "estimator_method", ")", "\n", "ate_estimate", "=", "data", "[", "'ate'", "]", "\n", "refute", "=", "model", ".", "refute_estimate", "(", "target_estimand", ",", "estimate", ",", "\n", "method_name", "=", "\"add_unobserved_common_cause\"", ",", "\n", "simulated_method_name", "=", "simulated_method_name", ",", "\n", "benchmark_common_causes", "=", "benchmark_common_causes", ",", "\n", "effect_fraction_on_treatment", "=", "effect_strength_on_t", ")", "\n", "\n", "if", "refute", ".", "confounder_increases_estimate", "==", "True", ":", "\n", "                ", "bias_adjusted_estimate", "=", "refute", ".", "benchmarking_results", "[", "'bias_adjusted_estimate'", "]", "\n", "assert", "all", "(", "estimate", "<=", "refute", ".", "estimate", "for", "estimate", "in", "bias_adjusted_estimate", ")", "#if confounder_increases_estimate is True, adjusted estimate should be lower than original estimate", "\n", "", "else", ":", "\n", "                ", "bias_adjusted_estimate", "=", "refute", ".", "benchmarking_results", "[", "'bias_adjusted_estimate'", "]", "\n", "assert", "all", "(", "estimate", ">=", "refute", ".", "estimate", "for", "estimate", "in", "bias_adjusted_estimate", ")", "\n", "\n", "#check if all partial R^2 values are between 0 and 1", "\n", "", "assert", "all", "(", "(", "val", ">=", "0", "and", "val", "<=", "1", ")", "for", "val", "in", "refute", ".", "benchmarking_results", "[", "'r2tu_w'", "]", ")", "\n", "assert", "all", "(", "(", "val", ">=", "0", "and", "val", "<=", "1", ")", "for", "val", "in", "refute", ".", "benchmarking_results", "[", "'r2yu_tw'", "]", ")", "\n", "assert", "refute", ".", "stats", "[", "'r2yt_w'", "]", ">=", "0", "and", "refute", ".", "stats", "[", "'r2yt_w'", "]", "<=", "1", "\n", "\n", "assert", "refute", ".", "stats", "[", "'robustness_value'", "]", ">=", "0", "and", "refute", ".", "stats", "[", "'robustness_value'", "]", "<=", "1", "\n", "assert", "mock_fig", ".", "call_count", ">", "0", "# we patched figure plotting call to avoid drawing plots during tests", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_add_unobserved_common_cause.TestAddUnobservedCommonCauseRefuter.test_linear_sensitivity_given_strength_of_confounding": [[122, 162], ["pytest.mark.parametrize", "unittest.mock.patch", "numpy.random.seed", "dowhy.datasets.linear_dataset", "data[].drop", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "dowhy.CausalModel.refute_estimate", "dowhy.CausalModel.refute_estimate.compute_bias_adjusted", "print", "abs", "abs", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.linear_sensitivity_analyzer.LinearSensitivityAnalyzer.compute_bias_adjusted"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"estimator_method\"", ",", "\"effect_strength_on_t\"", ",", "\"benchmark_common_causes\"", ",", "\"simulated_method_name\"", "]", ",", "\n", "[", "(", "\"backdoor.linear_regression\"", ",", "[", "1", ",", "2", ",", "3", "]", ",", "[", "\"W3\"", "]", ",", "\"linear-partial-R2\"", ")", ",", "]", ")", "\n", "@", "patch", "(", "\"matplotlib.pyplot.figure\"", ")", "\n", "def", "test_linear_sensitivity_given_strength_of_confounding", "(", "self", ",", "mock_fig", ",", "estimator_method", ",", "\n", "effect_strength_on_t", ",", "benchmark_common_causes", ",", "simulated_method_name", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "7", ",", "\n", "num_samples", "=", "500", ",", "\n", "num_treatments", "=", "1", ",", "\n", "stddev_treatment_noise", "=", "10", ",", "\n", "stddev_outcome_noise", "=", "1", "\n", ")", "\n", "data", "[", "\"df\"", "]", "=", "data", "[", "\"df\"", "]", ".", "drop", "(", "\"W4\"", ",", "axis", "=", "1", ")", "\n", "graph_str", "=", "'graph[directed 1node[ id \"y\" label \"y\"]node[ id \"W0\" label \"W0\"] node[ id \"W1\" label \"W1\"] node[ id \"W2\" label \"W2\"] node[ id \"W3\" label \"W3\"]  node[ id \"W5\" label \"W5\"] node[ id \"W6\" label \"W6\"]node[ id \"v0\" label \"v0\"]edge[source \"v0\" target \"y\"]edge[ source \"W0\" target \"v0\"] edge[ source \"W1\" target \"v0\"] edge[ source \"W2\" target \"v0\"] edge[ source \"W3\" target \"v0\"] edge[ source \"W5\" target \"v0\"] edge[ source \"W6\" target \"v0\"]edge[ source \"W0\" target \"y\"] edge[ source \"W1\" target \"y\"] edge[ source \"W2\" target \"y\"] edge[ source \"W3\" target \"y\"] edge[ source \"W5\" target \"y\"] edge[ source \"W6\" target \"y\"]]'", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "\"df\"", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "graph_str", ",", "\n", "test_significance", "=", "None", ",", "\n", ")", "\n", "target_estimand", "=", "model", ".", "identify_effect", "(", "proceed_when_unidentifiable", "=", "True", ")", "\n", "estimate", "=", "model", ".", "estimate_effect", "(", "target_estimand", ",", "method_name", "=", "estimator_method", ")", "\n", "ate_estimate", "=", "data", "[", "'ate'", "]", "\n", "refute", "=", "model", ".", "refute_estimate", "(", "target_estimand", ",", "estimate", ",", "\n", "method_name", "=", "\"add_unobserved_common_cause\"", ",", "\n", "simulated_method_name", "=", "simulated_method_name", ",", "\n", "benchmark_common_causes", "=", "benchmark_common_causes", ",", "\n", "effect_fraction_on_treatment", "=", "effect_strength_on_t", ")", "\n", "\n", "# We calculate adjusted estimates for two sets of partial R^2 values. ", "\n", "bias_adjusted_terms", "=", "refute", ".", "compute_bias_adjusted", "(", "r2tu_w", "=", "np", ".", "array", "(", "[", "0.7", ",", "0.2", "]", ")", ",", "r2yu_tw", "=", "np", ".", "array", "(", "[", "0.9", ",", "0.3", "]", ")", ")", "\n", "estimate1", "=", "bias_adjusted_terms", "[", "'bias_adjusted_estimate'", "]", "[", "0", "]", "#adjusted estimate for confounder u1 where r2tu_w = 0.7 and r2yu_tw = 0.9", "\n", "estimate2", "=", "bias_adjusted_terms", "[", "'bias_adjusted_estimate'", "]", "[", "1", "]", "#adjusted estimate for confounder u2 where r2tu_w = 0.2 and r2yu_tw = 0.3", "\n", "print", "(", "estimate1", ",", "estimate2", ")", "\n", "original_estimate", "=", "refute", ".", "estimate", "\n", "#Test if hypothetical confounding by unobserved confounder u1 leads to an adjusted effect that is farther from the original estimate as compared to u2 ", "\n", "assert", "abs", "(", "original_estimate", "-", "estimate1", ")", ">", "abs", "(", "original_estimate", "-", "estimate2", ")", "\n", "assert", "mock_fig", ".", "call_count", ">", "0", "# we patched figure plotting call to avoid drawing plots during tests", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.test_add_unobserved_common_cause.TestAddUnobservedCommonCauseRefuter.test_linear_sensitivity_dataset_without_confounders": [[163, 209], ["pytest.mark.parametrize", "unittest.mock.patch", "numpy.random.seed", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "dowhy.CausalModel.refute_estimate", "all", "all", "print", "all", "all"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"estimator_method\"", ",", "\"effect_strength_on_t\"", ",", "\"benchmark_common_causes\"", ",", "\"simulated_method_name\"", ",", "\"rvalue_threshold\"", "]", ",", "\n", "[", "(", "\"backdoor.linear_regression\"", ",", "[", "1", ",", "2", ",", "3", "]", ",", "[", "\"W3\"", "]", ",", "\"linear-partial-R2\"", ",", "0.95", ")", ",", "]", ")", "\n", "@", "patch", "(", "\"matplotlib.pyplot.figure\"", ")", "\n", "def", "test_linear_sensitivity_dataset_without_confounders", "(", "self", ",", "mock_fig", ",", "estimator_method", ",", "\n", "effect_strength_on_t", ",", "benchmark_common_causes", ",", "simulated_method_name", ",", "rvalue_threshold", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "7", ",", "\n", "num_samples", "=", "500", ",", "\n", "num_treatments", "=", "1", ",", "\n", "stddev_treatment_noise", "=", "10", ",", "\n", "stddev_outcome_noise", "=", "1", "\n", ")", "\n", "#Creating a model with no unobserved confounders", "\n", "model2", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "\"df\"", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "test_significance", "=", "None", ",", "\n", ")", "\n", "target_estimand2", "=", "model2", ".", "identify_effect", "(", "proceed_when_unidentifiable", "=", "True", ")", "\n", "estimate2", "=", "model2", ".", "estimate_effect", "(", "target_estimand2", ",", "method_name", "=", "estimator_method", ")", "\n", "ate_estimate", "=", "data", "[", "'ate'", "]", "\n", "refute2", "=", "model2", ".", "refute_estimate", "(", "target_estimand2", ",", "estimate2", ",", "\n", "method_name", "=", "\"add_unobserved_common_cause\"", ",", "\n", "simulated_method_name", "=", "simulated_method_name", ",", "\n", "benchmark_common_causes", "=", "benchmark_common_causes", ",", "\n", "effect_fraction_on_treatment", "=", "effect_strength_on_t", ")", "\n", "\n", "if", "refute2", ".", "confounder_increases_estimate", "==", "True", ":", "\n", "                ", "bias_adjusted_estimate", "=", "refute2", ".", "benchmarking_results", "[", "'bias_adjusted_estimate'", "]", "\n", "assert", "all", "(", "estimate", "<=", "refute2", ".", "estimate", "for", "estimate", "in", "bias_adjusted_estimate", ")", "#if confounder_increases_estimate is True, adjusted estimate should be lower than original estimate", "\n", "", "else", ":", "\n", "                ", "bias_adjusted_estimate", "=", "refute2", ".", "benchmarking_results", "[", "'bias_adjusted_estimate'", "]", "\n", "assert", "all", "(", "estimate", ">=", "refute2", ".", "estimate", "for", "estimate", "in", "bias_adjusted_estimate", ")", "\n", "\n", "#check if all partial R^2 values are between 0 and 1", "\n", "", "assert", "all", "(", "(", "val", ">=", "0", "and", "val", "<=", "1", ")", "for", "val", "in", "refute2", ".", "benchmarking_results", "[", "'r2tu_w'", "]", ")", "\n", "assert", "all", "(", "(", "val", ">=", "0", "and", "val", "<=", "1", ")", "for", "val", "in", "refute2", ".", "benchmarking_results", "[", "'r2yu_tw'", "]", ")", "\n", "assert", "refute2", ".", "stats", "[", "'r2yt_w'", "]", ">=", "0", "and", "refute2", ".", "stats", "[", "'r2yt_w'", "]", "<=", "1", "\n", "\n", "print", "(", "refute2", ".", "stats", "[", "'robustness_value'", "]", ")", "\n", "#for a dataset with no confounders, the robustness value should be higher than a given threshold (0.95 in our case)", "\n", "assert", "refute2", ".", "stats", "[", "'robustness_value'", "]", ">=", "rvalue_threshold", "and", "refute2", ".", "stats", "[", "'robustness_value'", "]", "<=", "1", "\n", "assert", "mock_fig", ".", "call_count", ">", "0", "# we patched figure plotting call to avoid drawing plots during tests", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.NodePair.__init__": [[8, 14], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "node1", ",", "node2", ")", ":", "\n", "        ", "self", ".", "_node1", "=", "node1", "\n", "self", ".", "_node2", "=", "node2", "\n", "self", ".", "_is_blocked", "=", "None", "# To store if all paths between node1 and node2 are blocked", "\n", "self", ".", "_condition_vars", "=", "[", "]", "# To store variable to be conditioned on to block all paths between node1 and node2", "\n", "self", ".", "_complete", "=", "False", "# To store to paths between node pair have been completely explored.", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.NodePair.update": [[15, 29], ["list", "backdoor.NodePair._condition_vars.append", "path.is_blocked", "path.is_blocked", "backdoor.NodePair._condition_vars.append", "set", "path.is_blocked", "path.get_condition_vars"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.is_blocked", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.is_blocked", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.is_blocked", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.get_condition_vars"], ["", "def", "update", "(", "self", ",", "path", ",", "condition_vars", "=", "None", ")", ":", "\n", "        ", "if", "condition_vars", "is", "None", ":", "\n", "            ", "'''path is a Path variable'''", "\n", "if", "self", ".", "_is_blocked", "is", "None", ":", "\n", "                ", "self", ".", "_is_blocked", "=", "path", ".", "is_blocked", "(", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_is_blocked", "=", "self", ".", "_is_blocked", "and", "path", ".", "is_blocked", "(", ")", "\n", "", "if", "not", "path", ".", "is_blocked", "(", ")", ":", "\n", "                ", "self", ".", "_condition_vars", ".", "append", "(", "path", ".", "get_condition_vars", "(", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "'''path is a list'''", "\n", "condition_vars", "=", "list", "(", "condition_vars", ")", "\n", "self", ".", "_condition_vars", ".", "append", "(", "set", "(", "[", "*", "path", "[", "1", ":", "]", ",", "*", "condition_vars", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.NodePair.get_condition_vars": [[30, 32], ["None"], "methods", ["None"], ["", "", "def", "get_condition_vars", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_condition_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.NodePair.set_complete": [[33, 35], ["None"], "methods", ["None"], ["", "def", "set_complete", "(", "self", ")", ":", "\n", "        ", "self", ".", "_complete", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.NodePair.is_complete": [[36, 38], ["None"], "methods", ["None"], ["", "def", "is_complete", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_complete", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.NodePair.__str__": [[39, 46], ["str", "str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "string", "=", "\"\"", "\n", "string", "+=", "\"Blocked: \"", "+", "str", "(", "self", ".", "_is_blocked", ")", "+", "\"\\n\"", "\n", "if", "not", "self", ".", "_is_blocked", ":", "\n", "            ", "condition_vars", "=", "[", "str", "(", "s", ")", "for", "s", "in", "self", ".", "_condition_vars", "]", "\n", "string", "+=", "\"To block path, condition on: \"", "+", "\",\"", ".", "join", "(", "condition_vars", ")", "+", "\"\\n\"", "\n", "", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.__init__": [[52, 55], ["set"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_is_blocked", "=", "None", "# To store if path is blocked", "\n", "self", ".", "_condition_vars", "=", "set", "(", ")", "# To store variables needed to block the path", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update": [[56, 63], ["backdoor.Path._condition_vars.union", "set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union"], ["", "def", "update", "(", "self", ",", "path", ",", "is_blocked", ")", ":", "\n", "        ", "'''\n        path is a list\n        '''", "\n", "self", ".", "_is_blocked", "=", "is_blocked", "\n", "if", "not", "is_blocked", ":", "\n", "            ", "self", ".", "_condition_vars", "=", "self", ".", "_condition_vars", ".", "union", "(", "set", "(", "path", "[", "1", ":", "-", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.is_blocked": [[64, 66], ["None"], "methods", ["None"], ["", "", "def", "is_blocked", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_is_blocked", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.get_condition_vars": [[67, 69], ["None"], "methods", ["None"], ["", "def", "get_condition_vars", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_condition_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.__str__": [[70, 76], ["str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "string", "=", "\"\"", "\n", "string", "+=", "\"Blocked: \"", "+", "str", "(", "self", ".", "_is_blocked", ")", "+", "\"\\n\"", "\n", "if", "not", "self", ".", "_is_blocked", ":", "\n", "            ", "string", "+=", "\"To block path, condition on: \"", "+", "\",\"", ".", "join", "(", "self", ".", "_condition_vars", ")", "+", "\"\\n\"", "\n", "", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.__init__": [[81, 87], ["set().union", "set", "set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union"], ["def", "__init__", "(", "self", ",", "graph", ",", "nodes1", ",", "nodes2", ")", ":", "\n", "        ", "self", ".", "_graph", "=", "graph", "\n", "self", ".", "_nodes1", "=", "nodes1", "\n", "self", ".", "_nodes2", "=", "nodes2", "\n", "self", ".", "_nodes12", "=", "set", "(", "self", ".", "_nodes1", ")", ".", "union", "(", "self", ".", "_nodes2", ")", "# Total set of nodes", "\n", "self", ".", "_colliders", "=", "set", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars": [[88, 115], ["backdoor.Backdoor._graph.to_undirected", "dowhy.utils.graph_operations.adjacency_matrix_to_adjacency_list", "networkx.to_numpy_matrix", "list", "backdoor.Backdoor._path_search", "len", "backdoor.HittingSetAlgorithm", "tuple", "backdoor.HittingSetAlgorithm.num_sets", "backdoor_sets.append", "path_dict[].get_condition_vars", "backdoor.HittingSetAlgorithm.find_set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.adjacency_matrix_to_adjacency_list", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor._path_search", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm.num_sets", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.get_condition_vars", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm.find_set"], ["", "def", "get_backdoor_vars", "(", "self", ")", ":", "\n", "        ", "'''\n        Obtains sets of backdoor variable to condition on for each node pair.\n\n        :returns:  List of sets with each set containing backdoor variable corresponding to a given node pair.\n        '''", "\n", "undirected_graph", "=", "self", ".", "_graph", ".", "to_undirected", "(", ")", "\n", "\n", "# Get adjacency list", "\n", "adjlist", "=", "adjacency_matrix_to_adjacency_list", "(", "nx", ".", "to_numpy_matrix", "(", "undirected_graph", ")", ",", "labels", "=", "list", "(", "undirected_graph", ".", "nodes", ")", ")", "\n", "path_dict", "=", "{", "}", "\n", "backdoor_sets", "=", "[", "]", "# Put in backdoor sets format", "\n", "\n", "for", "node1", "in", "self", ".", "_nodes1", ":", "\n", "            ", "for", "node2", "in", "self", ".", "_nodes2", ":", "\n", "                ", "if", "(", "node1", ",", "node2", ")", "in", "path_dict", ":", "\n", "                    ", "continue", "\n", "", "self", ".", "_path_search", "(", "adjlist", ",", "node1", ",", "node2", ",", "path_dict", ")", "\n", "if", "len", "(", "path_dict", ")", "!=", "0", ":", "\n", "                    ", "obj", "=", "HittingSetAlgorithm", "(", "path_dict", "[", "(", "node1", ",", "node2", ")", "]", ".", "get_condition_vars", "(", ")", ",", "self", ".", "_colliders", ")", "\n", "\n", "backdoor_set", "=", "{", "}", "\n", "backdoor_set", "[", "'backdoor_set'", "]", "=", "tuple", "(", "obj", ".", "find_set", "(", ")", ")", "\n", "backdoor_set", "[", "'num_paths_blocked_by_observed_nodes'", "]", "=", "obj", ".", "num_sets", "(", ")", "\n", "backdoor_sets", ".", "append", "(", "backdoor_set", ")", "\n", "\n", "", "", "", "return", "backdoor_sets", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.is_backdoor": [[116, 125], ["len", "backdoor.Backdoor._graph.has_edge"], "methods", ["None"], ["", "def", "is_backdoor", "(", "self", ",", "path", ")", ":", "\n", "        ", "'''\n        Check if path is a backdoor path.\n\n        :param path: List of nodes comprising the path.\n        '''", "\n", "if", "len", "(", "path", ")", "<", "2", ":", "\n", "            ", "return", "False", "\n", "", "return", "True", "if", "self", ".", "_graph", ".", "has_edge", "(", "path", "[", "1", "]", ",", "path", "[", "0", "]", ")", "else", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor._path_search_util": [[126, 178], ["path_dict[].is_complete", "range", "path.append", "vis.add", "path.pop", "vis.remove", "path_dict[].set_complete", "len", "backdoor.HittingSetAlgorithm", "set", "s.union.union.union", "path_dict[].update", "backdoor.NodePair", "path_dict[].get_condition_vars", "backdoor.HittingSetAlgorithm.find_set", "backdoor.Backdoor.is_backdoor", "range", "len", "backdoor.Path", "backdoor.Path.update", "path_dict[].update", "backdoor.Backdoor._path_search_util", "backdoor.Backdoor._nodes12.intersection", "len", "backdoor.NodePair", "path[].copy", "backdoor.Backdoor._graph.has_edge", "backdoor.Backdoor._colliders.add", "set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.NodePair.is_complete", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.NodePair.set_complete", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.get_condition_vars", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm.find_set", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.is_backdoor", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor._path_search_util", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add"], ["", "def", "_path_search_util", "(", "self", ",", "graph", ",", "node1", ",", "node2", ",", "vis", ",", "path", ",", "path_dict", ",", "is_blocked", "=", "False", ",", "prev_arrow", "=", "None", ")", ":", "\n", "        ", "'''\n        :param graph: Adjacency list of the graph under consideration.\n        :param node1: Current node being considered.\n        :param node2: Target node.\n        :param vis: Set of already visited nodes.\n        :param path: List of nodes comprising the path upto node1.\n        :path path_dict: Dictionary of node pairs.\n        :param is_blocked: True is path is blocked by a collider, else False.\n        :param prev_arrow: Described state of previous arrow. True if arrow incoming, False if arrow outgoing.\n        '''", "\n", "if", "is_blocked", ":", "\n", "            ", "return", "\n", "\n", "# If node pair has been fully explored", "\n", "", "if", "(", "(", "node1", ",", "node2", ")", "in", "path_dict", ")", "and", "(", "path_dict", "[", "(", "node1", ",", "node2", ")", "]", ".", "is_complete", "(", ")", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "path", ")", ")", ":", "\n", "                ", "if", "(", "path", "[", "i", "]", ",", "node2", ")", "not", "in", "path_dict", ":", "\n", "                    ", "path_dict", "[", "(", "path", "[", "i", "]", ",", "node2", ")", "]", "=", "NodePair", "(", "path", "[", "i", "]", ",", "node2", ")", "\n", "", "obj", "=", "HittingSetAlgorithm", "(", "path_dict", "[", "(", "node1", ",", "node2", ")", "]", ".", "get_condition_vars", "(", ")", ",", "self", ".", "_colliders", ")", "\n", "# Add node1 to backdoor set of node_pair", "\n", "s", "=", "set", "(", "[", "node1", "]", ")", "\n", "s", "=", "s", ".", "union", "(", "obj", ".", "find_set", "(", ")", ")", "\n", "path_dict", "[", "(", "path", "[", "i", "]", ",", "node2", ")", "]", ".", "update", "(", "path", "[", "i", ":", "]", ",", "s", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "path", ".", "append", "(", "node1", ")", "\n", "vis", ".", "add", "(", "node1", ")", "\n", "if", "node1", "==", "node2", ":", "\n", "# Check if path is backdoor and does not have nodes1\\node1 or nodes2\\node2 as intermediate nodes", "\n", "                ", "if", "self", ".", "is_backdoor", "(", "path", ")", "and", "len", "(", "self", ".", "_nodes12", ".", "intersection", "(", "set", "(", "path", "[", "1", ":", "-", "1", "]", ")", ")", ")", "==", "0", ":", "\n", "                    ", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "                        ", "if", "(", "path", "[", "i", "]", ",", "node2", ")", "not", "in", "path_dict", ":", "\n", "                            ", "path_dict", "[", "(", "path", "[", "i", "]", ",", "node2", ")", "]", "=", "NodePair", "(", "path", "[", "i", "]", ",", "node2", ")", "\n", "", "path_var", "=", "Path", "(", ")", "\n", "path_var", ".", "update", "(", "path", "[", "i", ":", "]", ".", "copy", "(", ")", ",", "is_blocked", ")", "\n", "path_dict", "[", "(", "path", "[", "i", "]", ",", "node2", ")", "]", ".", "update", "(", "path_var", ")", "\n", "", "", "", "else", ":", "\n", "                ", "for", "neighbour", "in", "graph", "[", "node1", "]", ":", "\n", "                    ", "if", "neighbour", "not", "in", "vis", ":", "\n", "# True if arrow incoming, False if arrow outgoing", "\n", "                        ", "next_arrow", "=", "False", "if", "self", ".", "_graph", ".", "has_edge", "(", "node1", ",", "neighbour", ")", "else", "True", "\n", "if", "next_arrow", "==", "True", "and", "prev_arrow", "==", "True", ":", "\n", "                            ", "is_blocked", "=", "True", "\n", "self", ".", "_colliders", ".", "add", "(", "node1", ")", "\n", "", "self", ".", "_path_search_util", "(", "graph", ",", "neighbour", ",", "node2", ",", "vis", ",", "path", ",", "path_dict", ",", "is_blocked", ",", "not", "next_arrow", ")", "# Since incoming for current node is outgoing for the next", "\n", "", "", "", "path", ".", "pop", "(", ")", "\n", "vis", ".", "remove", "(", "node1", ")", "\n", "\n", "# Mark pair (node1, node2) complete", "\n", "", "if", "(", "node1", ",", "node2", ")", "in", "path_dict", ":", "\n", "            ", "path_dict", "[", "(", "node1", ",", "node2", ")", "]", ".", "set_complete", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor._path_search": [[179, 190], ["set", "backdoor.Backdoor._path_search_util"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor._path_search_util"], ["", "", "def", "_path_search", "(", "self", ",", "graph", ",", "node1", ",", "node2", ",", "path_dict", ")", ":", "\n", "        ", "'''\n        Path search using DFS.\n        \n        :param graph: Adjacency list of the graph under consideration.\n        :param node1: Current node being considered.\n        :param node2: Target node.\n        :path path_dict: Dictionary of node pairs.\n        '''", "\n", "vis", "=", "set", "(", ")", "\n", "self", ".", "_path_search_util", "(", "graph", ",", "node1", ",", "node2", ",", "vis", ",", "[", "]", ",", "path_dict", ",", "is_blocked", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm.__init__": [[196, 203], ["set", "backdoor.HittingSetAlgorithm._count_vars"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._count_vars"], ["def", "__init__", "(", "self", ",", "list_of_sets", ",", "colliders", "=", "set", "(", ")", ")", ":", "\n", "        ", "'''\n        :param list_of_sets: List of sets such that each set comprises nodes representing a single backdoor path between a source node and a target node.\n        '''", "\n", "self", ".", "_list_of_sets", "=", "list_of_sets", "\n", "self", ".", "_colliders", "=", "colliders", "\n", "self", ".", "_var_count", "=", "self", ".", "_count_vars", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm.num_sets": [[204, 209], ["len"], "methods", ["None"], ["", "def", "num_sets", "(", "self", ")", ":", "\n", "        ", "'''\n        Obtain number of backdoor paths between a node pair.\n        '''", "\n", "return", "len", "(", "self", ".", "_list_of_sets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm.find_set": [[210, 233], ["set", "len", "set", "set", "backdoor.HittingSetAlgorithm._is_covered", "backdoor.HittingSetAlgorithm._max_occurence_var", "set.add", "backdoor.HittingSetAlgorithm._indices_covered", "backdoor.HittingSetAlgorithm._modify_count", "indices_covered.union.union.union", "range"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._is_covered", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._max_occurence_var", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._indices_covered", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._modify_count", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union"], ["", "def", "find_set", "(", "self", ")", ":", "\n", "        ", "'''\n        Find approximate minimal set of nodes such that there is atleast one node from each set in list_of_sets.\n\n        :returns: Approximate minimal set of nodes.\n        '''", "\n", "var_set", "=", "set", "(", ")", "\n", "num_indices", "=", "len", "(", "self", ".", "_list_of_sets", ")", "\n", "indices_covered", "=", "set", "(", ")", "\n", "all_set_indices", "=", "set", "(", "[", "i", "for", "i", "in", "range", "(", "num_indices", ")", "]", ")", "\n", "\n", "while", "not", "self", ".", "_is_covered", "(", "indices_covered", ",", "num_indices", ")", ":", "\n", "            ", "set_index", "=", "all_set_indices", "-", "indices_covered", "\n", "max_el", "=", "self", ".", "_max_occurence_var", "(", "var_dict", "=", "self", ".", "_var_count", ")", "\n", "if", "max_el", "is", "None", ":", "\n", "                ", "break", "\n", "", "var_set", ".", "add", "(", "max_el", ")", "\n", "\n", "# Modify variable count and indices covered", "\n", "covered_present", "=", "self", ".", "_indices_covered", "(", "el", "=", "max_el", ",", "set_index", "=", "set_index", ")", "\n", "self", ".", "_modify_count", "(", "covered_present", ")", "\n", "indices_covered", "=", "indices_covered", ".", "union", "(", "covered_present", ")", "\n", "", "return", "var_set", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._count_vars": [[234, 255], ["set", "range", "len"], "methods", ["None"], ["", "def", "_count_vars", "(", "self", ",", "set_index", "=", "None", ")", ":", "\n", "        ", "'''\n        Obtain count of number of sets each particular node belongs to.\n\n        :param set_index: Set of indices to consider for calculating the number of sets \"hit\" by a variable..\n        '''", "\n", "var_dict", "=", "{", "}", "\n", "\n", "if", "set_index", "==", "None", ":", "\n", "            ", "set_index", "=", "set", "(", "[", "i", "for", "i", "in", "range", "(", "len", "(", "self", ".", "_list_of_sets", ")", ")", "]", ")", "\n", "\n", "", "for", "idx", "in", "set_index", ":", "\n", "            ", "s", "=", "self", ".", "_list_of_sets", "[", "idx", "]", "\n", "\n", "for", "el", "in", "s", ":", "\n", "                ", "if", "el", "not", "in", "self", ".", "_colliders", ":", "\n", "                    ", "if", "el", "not", "in", "var_dict", ":", "\n", "                        ", "var_dict", "[", "el", "]", "=", "0", "\n", "", "var_dict", "[", "el", "]", "+=", "1", "\n", "\n", "", "", "", "return", "var_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._modify_count": [[256, 264], ["None"], "methods", ["None"], ["", "def", "_modify_count", "(", "self", ",", "indices_covered", ")", ":", "\n", "        ", "'''\n        Modify count of number of sets each particular node belongs to based on nodes already covered in the previous iteration of the algorithm.\n        '''", "\n", "for", "idx", "in", "indices_covered", ":", "\n", "            ", "for", "el", "in", "self", ".", "_list_of_sets", "[", "idx", "]", ":", "\n", "                ", "if", "el", "not", "in", "self", ".", "_colliders", ":", "\n", "                    ", "self", ".", "_var_count", "[", "el", "]", "-=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._max_occurence_var": [[265, 276], ["var_dict.items"], "methods", ["None"], ["", "", "", "", "def", "_max_occurence_var", "(", "self", ",", "var_dict", ")", ":", "\n", "        ", "'''\n        Find the node contained in most number of sets.\n        '''", "\n", "max_el", "=", "None", "\n", "max_count", "=", "0", "\n", "for", "key", ",", "val", "in", "var_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "val", ">", "max_count", ":", "\n", "                ", "max_count", "=", "val", "\n", "max_el", "=", "key", "\n", "", "", "return", "max_el", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._indices_covered": [[277, 289], ["set", "set", "set.add", "range", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.add"], ["", "def", "_indices_covered", "(", "self", ",", "el", ",", "set_index", "=", "None", ")", ":", "\n", "        ", "'''\n        Obtain indices covered in a particular iteration of the algorithm.\n        '''", "\n", "covered", "=", "set", "(", ")", "\n", "if", "set_index", "==", "None", ":", "\n", "            ", "set_index", "=", "set", "(", "[", "i", "for", "i", "in", "range", "(", "len", "(", "self", ".", "_list_of_sets", ")", ")", "]", ")", "\n", "\n", "", "for", "idx", "in", "set_index", ":", "\n", "            ", "if", "el", "in", "self", ".", "_list_of_sets", "[", "idx", "]", ":", "\n", "                ", "covered", ".", "add", "(", "idx", ")", "\n", "", "", "return", "covered", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.HittingSetAlgorithm._is_covered": [[290, 299], ["all", "range"], "methods", ["None"], ["", "def", "_is_covered", "(", "self", ",", "indices_covered", ",", "num_indices", ")", ":", "\n", "        ", "'''\n        List of sets is covered by the variable set.\n        '''", "\n", "\n", "covered", "=", "[", "False", "for", "i", "in", "range", "(", "num_indices", ")", "]", "\n", "for", "idx", "in", "indices_covered", ":", "\n", "            ", "covered", "[", "idx", "]", "=", "True", "\n", "", "return", "all", "(", "covered", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.__init__": [[14, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_product", "=", "[", "]", "\n", "self", ".", "_sum", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_product": [[18, 25], ["id_identifier.IDExpression._product.append"], "methods", ["None"], ["", "def", "add_product", "(", "self", ",", "element", ")", ":", "\n", "        ", "'''\n        Add an estimator to the list of product.\n\n        :param element: Estimator to append to the product list.\n        '''", "\n", "self", ".", "_product", ".", "append", "(", "element", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_sum": [[26, 34], ["id_identifier.IDExpression._sum.append"], "methods", ["None"], ["", "def", "add_sum", "(", "self", ",", "element", ")", ":", "\n", "        ", "'''\n        Add variables to the list.\n\n        :param element: Set of variables to append to the list self._sum.\n        '''", "\n", "for", "el", "in", "element", ":", "\n", "            ", "self", ".", "_sum", ".", "append", "(", "el", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.get_val": [[35, 47], ["Exception"], "methods", ["None"], ["", "", "def", "get_val", "(", "self", ",", "return_type", ")", ":", "\n", "        ", "\"\"\"\n        Get either the list of estimators (for product) or list of variables (for the marginalization).\n\n        :param return_type: \"prod\" to return the list of estimators or \"sum\" to return the list of variables.\n        \"\"\"", "\n", "if", "return_type", "==", "\"prod\"", ":", "\n", "            ", "return", "self", ".", "_product", "\n", "", "elif", "return_type", "==", "\"sum\"", ":", "\n", "            ", "return", "self", ".", "_sum", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Provide correct return type.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression._print_estimator": [[48, 78], ["isinstance", "estimator.get_val", "list", "list", "id_identifier.IDExpression._print_estimator", "len", "len", "estimator.get_val", "estimator.get_val"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.get_val", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression._print_estimator", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.get_val", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.get_val"], ["", "", "def", "_print_estimator", "(", "self", ",", "prefix", ",", "estimator", "=", "None", ",", "start", "=", "False", ")", ":", "\n", "        ", "'''\n        Print the IDExpression object.\n        '''", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "return", "None", "\n", "\n", "", "string", "=", "\"\"", "\n", "if", "isinstance", "(", "estimator", ",", "IDExpression", ")", ":", "\n", "            ", "s", "=", "True", "if", "len", "(", "estimator", ".", "get_val", "(", "return_type", "=", "\"sum\"", ")", ")", ">", "0", "else", "False", "\n", "if", "s", ":", "\n", "                ", "sum_vars", "=", "\"{\"", "+", "\",\"", ".", "join", "(", "estimator", ".", "get_val", "(", "return_type", "=", "\"sum\"", ")", ")", "+", "\"}\"", "\n", "string", "+=", "prefix", "+", "\"Sum over \"", "+", "sum_vars", "+", "\":\\n\"", "\n", "prefix", "+=", "\"\\t\"", "\n", "", "for", "expression", "in", "estimator", ".", "get_val", "(", "return_type", "=", "'prod'", ")", ":", "\n", "                ", "add_string", "=", "self", ".", "_print_estimator", "(", "prefix", ",", "expression", ")", "\n", "if", "add_string", "is", "None", ":", "\n", "                    ", "return", "None", "\n", "", "else", ":", "\n", "                    ", "string", "+=", "add_string", "\n", "", "", "", "else", ":", "\n", "            ", "outcome_vars", "=", "list", "(", "estimator", "[", "'outcome_vars'", "]", ")", "\n", "condition_vars", "=", "list", "(", "estimator", "[", "'condition_vars'", "]", ")", "\n", "string", "+=", "prefix", "+", "\"Predictor: P(\"", "+", "\",\"", ".", "join", "(", "outcome_vars", ")", "\n", "if", "len", "(", "condition_vars", ")", ">", "0", ":", "\n", "                ", "string", "+=", "\"|\"", "+", "\",\"", ".", "join", "(", "condition_vars", ")", "\n", "", "string", "+=", "\")\\n\"", "\n", "", "if", "start", ":", "\n", "            ", "string", "=", "string", "[", ":", "-", "1", "]", "\n", "", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.__str__": [[79, 85], ["id_identifier.IDExpression._print_estimator"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression._print_estimator"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "string", "=", "self", ".", "_print_estimator", "(", "prefix", "=", "\"\"", ",", "estimator", "=", "self", ",", "start", "=", "True", ")", "\n", "if", "string", "is", "None", ":", "\n", "            ", "return", "\"The graph is not identifiable.\"", "\n", "", "else", ":", "\n", "            ", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.__init__": [[88, 114], ["dowhy.causal_identifier.CausalIdentifier.__init__", "dowhy.utils.ordered_set.OrderedSet", "dowhy.utils.ordered_set.OrderedSet", "graph.get_adjacency_matrix", "dowhy.utils.ordered_set.OrderedSet", "Exception", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.utils.ordered_set.OrderedSet", "list", "Exception", "networkx.topological_sort"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_adjacency_matrix", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state"], ["    ", "def", "__init__", "(", "self", ",", "graph", ",", "estimand_type", ",", "\n", "method_name", "=", "\"default\"", ",", "\n", "proceed_when_unidentifiable", "=", "None", ")", ":", "\n", "        ", "'''\n        Class to perform identification using the ID algorithm.\n\n        :param self: instance of the IDIdentifier class.\n        :param estimand_type: Type of estimand (\"nonparametric-ate\", \"nonparametric-nde\" or \"nonparametric-nie\").\n        :param method_name: Identification method (\"id-algorithm\" in this case).\n        :param proceed_when_unidentifiable: If True, proceed with identification even in the presence of unobserved/missing variables.\n        '''", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "graph", ",", "estimand_type", ",", "method_name", ",", "proceed_when_unidentifiable", ")", "\n", "\n", "if", "self", ".", "estimand_type", "!=", "CausalIdentifier", ".", "NONPARAMETRIC_ATE", ":", "\n", "            ", "raise", "Exception", "(", "\"The estimand type should be 'non-parametric ate' for the ID method type.\"", ")", "\n", "\n", "", "self", ".", "_treatment_names", "=", "OrderedSet", "(", "parse_state", "(", "graph", ".", "treatment_name", ")", ")", "\n", "self", ".", "_outcome_names", "=", "OrderedSet", "(", "parse_state", "(", "graph", ".", "outcome_name", ")", ")", "\n", "self", ".", "_adjacency_matrix", "=", "graph", ".", "get_adjacency_matrix", "(", ")", "\n", "\n", "try", ":", "\n", "            ", "self", ".", "_tsort_node_names", "=", "OrderedSet", "(", "list", "(", "nx", ".", "topological_sort", "(", "graph", ".", "_graph", ")", ")", ")", "# topological sorting of graph nodes", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "\"The graph must be a directed acyclic graph (DAG).\"", ")", "\n", "", "self", ".", "_node_names", "=", "OrderedSet", "(", "graph", ".", "_graph", ".", "nodes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect": [[115, 223], ["id_identifier.IDIdentifier._idx_node_mapping", "id_identifier.IDExpression", "dowhy.utils.graph_operations.find_ancestor", "dowhy.utils.graph_operations.induced_graph.copy", "dowhy.utils.graph_operations.find_ancestor", "node_names.intersection.intersection.difference().difference", "node_names.intersection.intersection.difference", "id_identifier.IDIdentifier._idx_node_mapping", "dowhy.utils.graph_operations.induced_graph", "dowhy.utils.graph_operations.find_c_components", "dowhy.utils.graph_operations.find_c_components", "len", "id_identifier.IDExpression", "dowhy.utils.ordered_set.OrderedSet", "id_identifier.IDExpression.add_product", "id_identifier.IDExpression.add_sum", "id_identifier.IDExpression.add_product", "len", "treatment_names.intersection.intersection.intersection", "node_names.intersection.intersection.intersection", "dowhy.utils.graph_operations.induced_graph", "id_identifier.IDIdentifier.identify_effect", "range", "len", "id_identifier.IDIdentifier.identify_effect", "len", "id_identifier.IDExpression", "node_names.intersection.intersection.difference", "id_identifier.IDExpression.add_sum", "id_identifier.IDExpression.add_product", "S.difference", "S.difference", "node_names.intersection.intersection.difference", "node_names.intersection.intersection.difference", "len", "node_names.intersection.intersection.difference", "outcome_names.union", "id_identifier.IDIdentifier.identify_effect", "id_identifier.IDIdentifier.get_val", "len", "prev_nodes.append", "S.difference.is_empty", "id_identifier.IDIdentifier.identify_effect", "treatment_names.intersection.intersection.union", "id_identifier.IDExpression.add_product", "id_identifier.IDExpression", "dowhy.utils.ordered_set.OrderedSet", "dowhy.utils.ordered_set.OrderedSet", "id_identifier.IDExpression.add_product", "id_identifier.IDExpression.add_sum", "id_identifier.IDExpression.add_product", "node_names.intersection.intersection.difference", "dowhy.utils.ordered_set.OrderedSet", "treatment_names.intersection.intersection.intersection", "dowhy.utils.graph_operations.induced_graph", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier._idx_node_mapping", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.find_ancestor", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.find_ancestor", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier._idx_node_mapping", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.induced_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.find_c_components", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.find_c_components", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_product", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_sum", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_product", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.induced_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_sum", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_product", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.get_val", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.is_empty", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_product", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_product", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_sum", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDExpression.add_product", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.intersection", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.induced_graph"], ["", "def", "identify_effect", "(", "self", ",", "treatment_names", "=", "None", ",", "outcome_names", "=", "None", ",", "adjacency_matrix", "=", "None", ",", "node_names", "=", "None", ")", ":", "\n", "        ", "'''\n        Implementation of the ID algorithm.\n        Link - https://ftp.cs.ucla.edu/pub/stat_ser/shpitser-thesis.pdf\n        The pseudo code has been provided on Pg 40.\n\n        :param self: instance of the IDIdentifier class.\n        :param treatment_names: OrderedSet comprising names of treatment variables.\n        :param outcome_names:OrderedSet comprising names of outcome variables.\n        :param adjacency_matrix: Graph adjacency matrix.\n        :param node_names: OrderedSet comprising names of all nodes in the graph\n\n        :returns:  target estimand, an instance of the IDExpression class.\n        '''", "\n", "if", "adjacency_matrix", "is", "None", ":", "\n", "            ", "adjacency_matrix", "=", "self", ".", "_adjacency_matrix", "\n", "", "if", "treatment_names", "is", "None", ":", "\n", "            ", "treatment_names", "=", "self", ".", "_treatment_names", "\n", "", "if", "outcome_names", "is", "None", ":", "\n", "            ", "outcome_names", "=", "self", ".", "_outcome_names", "\n", "", "if", "node_names", "is", "None", ":", "\n", "            ", "node_names", "=", "self", ".", "_node_names", "\n", "", "node2idx", ",", "idx2node", "=", "self", ".", "_idx_node_mapping", "(", "node_names", ")", "\n", "\n", "# Estimators list for returning after identification", "\n", "estimators", "=", "IDExpression", "(", ")", "\n", "\n", "# Line 1", "\n", "# If no action has been taken, the effect on Y is just the marginal of the observational distribution P(v) on Y.", "\n", "if", "len", "(", "treatment_names", ")", "==", "0", ":", "\n", "            ", "identifier", "=", "IDExpression", "(", ")", "\n", "estimator", "=", "{", "}", "\n", "estimator", "[", "'outcome_vars'", "]", "=", "node_names", "\n", "estimator", "[", "'condition_vars'", "]", "=", "OrderedSet", "(", ")", "\n", "identifier", ".", "add_product", "(", "estimator", ")", "\n", "identifier", ".", "add_sum", "(", "node_names", ".", "difference", "(", "outcome_names", ")", ")", "\n", "estimators", ".", "add_product", "(", "identifier", ")", "\n", "return", "estimators", "\n", "\n", "# Line 2", "\n", "# If we are interested in the effect on Y, it is sufficient to restrict our attention on the parts of the model ancestral to Y.", "\n", "", "ancestors", "=", "find_ancestor", "(", "outcome_names", ",", "node_names", ",", "adjacency_matrix", ",", "node2idx", ",", "idx2node", ")", "\n", "if", "len", "(", "node_names", ".", "difference", "(", "ancestors", ")", ")", "!=", "0", ":", "# If there are elements which are not the ancestor of the outcome variables", "\n", "# Modify list of valid nodes", "\n", "            ", "treatment_names", "=", "treatment_names", ".", "intersection", "(", "ancestors", ")", "\n", "node_names", "=", "node_names", ".", "intersection", "(", "ancestors", ")", "\n", "adjacency_matrix", "=", "induced_graph", "(", "node_set", "=", "node_names", ",", "adjacency_matrix", "=", "adjacency_matrix", ",", "node2idx", "=", "node2idx", ")", "\n", "return", "self", ".", "identify_effect", "(", "treatment_names", "=", "treatment_names", ",", "outcome_names", "=", "outcome_names", ",", "adjacency_matrix", "=", "adjacency_matrix", ",", "node_names", "=", "node_names", ")", "\n", "\n", "# Line 3 - forces an action on any node where such an action would have no effect on Y \u2013 assuming we already acted on X.", "\n", "# Modify adjacency matrix to obtain that corresponding to do(X)", "\n", "", "adjacency_matrix_do_x", "=", "adjacency_matrix", ".", "copy", "(", ")", "\n", "for", "x", "in", "treatment_names", ":", "\n", "            ", "x_idx", "=", "node2idx", "[", "x", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "node_names", ")", ")", ":", "\n", "                ", "adjacency_matrix_do_x", "[", "i", ",", "x_idx", "]", "=", "0", "\n", "", "", "ancestors", "=", "find_ancestor", "(", "outcome_names", ",", "node_names", ",", "adjacency_matrix_do_x", ",", "node2idx", ",", "idx2node", ")", "\n", "W", "=", "node_names", ".", "difference", "(", "treatment_names", ")", ".", "difference", "(", "ancestors", ")", "\n", "if", "len", "(", "W", ")", "!=", "0", ":", "\n", "            ", "return", "self", ".", "identify_effect", "(", "treatment_names", "=", "treatment_names", ".", "union", "(", "W", ")", ",", "outcome_names", "=", "outcome_names", ",", "adjacency_matrix", "=", "adjacency_matrix", ",", "node_names", "=", "node_names", ")", "\n", "\n", "# Line 4 - Decomposes the problem into a set of smaller problems using the key property of C-component factorization of causal models.", "\n", "# If the entire graph is a single C-component already, further problem decomposition is impossible, and we must provide base cases.", "\n", "# Modify adjacency matrix to remove treatment variables", "\n", "", "node_names_minus_x", "=", "node_names", ".", "difference", "(", "treatment_names", ")", "\n", "node2idx_minus_x", ",", "idx2node_minus_x", "=", "self", ".", "_idx_node_mapping", "(", "node_names_minus_x", ")", "\n", "adjacency_matrix_minus_x", "=", "induced_graph", "(", "node_set", "=", "node_names_minus_x", ",", "adjacency_matrix", "=", "adjacency_matrix", ",", "node2idx", "=", "node2idx", ")", "\n", "c_components", "=", "find_c_components", "(", "adjacency_matrix", "=", "adjacency_matrix_minus_x", ",", "node_set", "=", "node_names_minus_x", ",", "idx2node", "=", "idx2node_minus_x", ")", "\n", "if", "len", "(", "c_components", ")", ">", "1", ":", "\n", "            ", "identifier", "=", "IDExpression", "(", ")", "\n", "sum_over_set", "=", "node_names", ".", "difference", "(", "outcome_names", ".", "union", "(", "treatment_names", ")", ")", "\n", "for", "component", "in", "c_components", ":", "\n", "                ", "expressions", "=", "self", ".", "identify_effect", "(", "treatment_names", "=", "node_names", ".", "difference", "(", "component", ")", ",", "outcome_names", "=", "OrderedSet", "(", "list", "(", "component", ")", ")", ",", "adjacency_matrix", "=", "adjacency_matrix", ",", "node_names", "=", "node_names", ")", "\n", "for", "expression", "in", "expressions", ".", "get_val", "(", "return_type", "=", "\"prod\"", ")", ":", "\n", "                    ", "identifier", ".", "add_product", "(", "expression", ")", "\n", "", "", "identifier", ".", "add_sum", "(", "sum_over_set", ")", "\n", "estimators", ".", "add_product", "(", "identifier", ")", "\n", "return", "estimators", "\n", "\n", "\n", "# Line 5 - The algorithms fails due to the presence of a hedge - the graph G, and a subgraph S that does not contain any X nodes.", "\n", "", "S", "=", "c_components", "[", "0", "]", "\n", "c_components_G", "=", "find_c_components", "(", "adjacency_matrix", "=", "adjacency_matrix", ",", "node_set", "=", "node_names", ",", "idx2node", "=", "idx2node", ")", "\n", "if", "len", "(", "c_components_G", ")", "==", "1", "and", "c_components_G", "[", "0", "]", "==", "node_names", ":", "\n", "            ", "return", "None", "\n", "\n", "# Line 6 - If there are no bidirected arcs from X to the other nodes in the current subproblem under consideration, then we can replace acting on X by conditioning, and thus solve the subproblem.", "\n", "", "if", "S", "in", "c_components_G", ":", "\n", "            ", "sum_over_set", "=", "S", ".", "difference", "(", "outcome_names", ")", "\n", "prev_nodes", "=", "[", "]", "\n", "for", "node", "in", "self", ".", "_tsort_node_names", ":", "\n", "                ", "if", "node", "in", "S", ":", "\n", "                    ", "identifier", "=", "IDExpression", "(", ")", "\n", "estimator", "=", "{", "}", "\n", "estimator", "[", "'outcome_vars'", "]", "=", "OrderedSet", "(", "[", "node", "]", ")", "\n", "estimator", "[", "'condition_vars'", "]", "=", "OrderedSet", "(", "prev_nodes", ")", "\n", "identifier", ".", "add_product", "(", "estimator", ")", "\n", "identifier", ".", "add_sum", "(", "sum_over_set", ")", "\n", "estimators", ".", "add_product", "(", "identifier", ")", "\n", "", "prev_nodes", ".", "append", "(", "node", ")", "\n", "", "return", "estimators", "\n", "\n", "\n", "# Line 7 - This is the most complicated case in the algorithm. Explain in the second last paragraph on Pg 41 of the link provided in the docstring above.", "\n", "", "for", "component", "in", "c_components_G", ":", "\n", "            ", "C", "=", "S", ".", "difference", "(", "component", ")", "\n", "if", "C", ".", "is_empty", "(", ")", "is", "None", ":", "\n", "                ", "return", "self", ".", "identify_effect", "(", "treatment_names", "=", "treatment_names", ".", "intersection", "(", "component", ")", ",", "outcome_names", "=", "outcome_names", ",", "adjacency_matrix", "=", "induced_graph", "(", "node_set", "=", "component", ",", "adjacency_matrix", "=", "adjacency_matrix", ",", "node2idx", "=", "node2idx", ")", ",", "node_names", "=", "node_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier._idx_node_mapping": [[224, 237], ["enumerate", "node_names.get_all"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.get_all"], ["", "", "", "def", "_idx_node_mapping", "(", "self", ",", "node_names", ")", ":", "\n", "        ", "'''\n        Obtain the node name to index and index to node name mappings.\n\n        :param node_names: Name of all nodes in the graph.\n        :return: node to index and index to node mappings.\n        '''", "\n", "node2idx", "=", "{", "}", "\n", "idx2node", "=", "{", "}", "\n", "for", "i", ",", "node", "in", "enumerate", "(", "node_names", ".", "get_all", "(", ")", ")", ":", "\n", "            ", "node2idx", "[", "node", "]", "=", "i", "\n", "idx2node", "[", "i", "]", "=", "node", "\n", "", "return", "node2idx", ",", "idx2node", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.base.IdentificationTestGraphSolution.__init__": [[9, 16], ["dowhy.causal_graph.CausalGraph"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "error_tolerance", ",", "Estimator", ",", "identifier_method", "=", "\"backdoor\"", ")", ":", "\n", "        ", "print", "(", "\"Error tolerance is\"", ",", "error_tolerance", ")", "\n", "self", ".", "_error_tolerance", "=", "error_tolerance", "\n", "self", ".", "_Estimator", "=", "Estimator", "\n", "self", ".", "_identifier_method", "=", "identifier_method", "\n", "\n", "", "def", "average_treatment_effect_test", "(", "self", ",", "dataset", "=", "\"linear\"", ",", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "1", ",", "num_instruments", "=", "1", ",", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.base.example_graph_solution": [[18, 21], ["pytest.fixture", "base.IdentificationTestGraphSolution", "example_graphs.TEST_GRAPH_SOLUTIONS.keys"], "function", ["None"], ["num_frontdoor_variables", "=", "0", ",", "\n", "num_samples", "=", "100000", ",", "\n", "treatment_is_binary", "=", "True", ",", "\n", "treatment_is_category", "=", "False", ",", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_id_identifier.TestIDIdentifier.test_1": [[9, 24], ["pandas.DataFrame", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.identify_effect.__str__", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__"], ["    ", "def", "test_1", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "causal_graph", "=", "\"digraph{T->Y;}\"", "\n", "columns", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "columns", ")", "\n", "\n", "# Calculate causal effect twice: once for unit (t=1, c=0), once for specific increase (t=100, c=50)", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "identified_estimand", "=", "causal_model", ".", "identify_effect", "(", "method_name", "=", "\"id-algorithm\"", ")", "\n", "\n", "# Only P(Y|T) should be present for test to succeed.", "\n", "identified_str", "=", "identified_estimand", ".", "__str__", "(", ")", "\n", "gt_str", "=", "\"Predictor: P(Y|T)\"", "\n", "assert", "identified_str", "==", "gt_str", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_id_identifier.TestIDIdentifier.test_2": [[25, 41], ["pandas.DataFrame", "dowhy.CausalModel", "list", "list", "pytest.raises", "dowhy.CausalModel.identify_effect"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect"], ["", "def", "test_2", "(", "self", ")", ":", "\n", "        ", "'''\n        Test undirected edge between treatment and outcome.\n        '''", "\n", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "causal_graph", "=", "\"digraph{T->Y; Y->T;}\"", "\n", "columns", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "columns", ")", "\n", "\n", "# Calculate causal effect twice: once for unit (t=1, c=0), once for specific increase (t=100, c=50)", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "\n", "# Since undirected graph, identify effect must throw an error.", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", ":", "\n", "            ", "identified_estimand", "=", "causal_model", ".", "identify_effect", "(", "method_name", "=", "\"id-algorithm\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_id_identifier.TestIDIdentifier.test_3": [[42, 58], ["pandas.DataFrame", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.identify_effect.__str__", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__"], ["", "", "def", "test_3", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", "]", "\n", "causal_graph", "=", "\"digraph{T->X1;X1->Y;}\"", "\n", "columns", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "columns", ")", "\n", "\n", "# Calculate causal effect twice: once for unit (t=1, c=0), once for specific increase (t=100, c=50)", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "identified_estimand", "=", "causal_model", ".", "identify_effect", "(", "method_name", "=", "\"id-algorithm\"", ")", "\n", "\n", "# Compare with ground truth", "\n", "identified_str", "=", "identified_estimand", ".", "__str__", "(", ")", "\n", "gt_str", "=", "\"Sum over {X1}:\\n\\tPredictor: P(X1|T)\\n\\tPredictor: P(Y|T,X1)\"", "\n", "assert", "identified_str", "==", "gt_str", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_id_identifier.TestIDIdentifier.test_4": [[59, 75], ["pandas.DataFrame", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.identify_effect.__str__", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__"], ["", "def", "test_4", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", "]", "\n", "causal_graph", "=", "\"digraph{T->Y;T->X1;X1->Y;}\"", "\n", "columns", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "columns", ")", "\n", "\n", "# Calculate causal effect twice: once for unit (t=1, c=0), once for specific increase (t=100, c=50)", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "identified_estimand", "=", "causal_model", ".", "identify_effect", "(", "method_name", "=", "\"id-algorithm\"", ")", "\n", "\n", "# Compare with ground truth", "\n", "identified_str", "=", "identified_estimand", ".", "__str__", "(", ")", "\n", "gt_str", "=", "\"Sum over {X1}:\\n\\tPredictor: P(Y|T,X1)\\n\\tPredictor: P(X1|T)\"", "\n", "assert", "identified_str", "==", "gt_str", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_id_identifier.TestIDIdentifier.test_5": [[77, 99], ["pandas.DataFrame", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "set", "set", "set", "set", "list", "len", "len", "len", "len", "list", "list", "set.difference", "set.difference", "set.difference"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference"], ["", "def", "test_5", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", ",", "\"X2\"", "]", "\n", "causal_graph", "=", "\"digraph{T->Y;X1->T;X1->Y;X2->T;}\"", "\n", "columns", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "columns", ")", "\n", "\n", "# Calculate causal effect twice: once for unit (t=1, c=0), once for specific increase (t=100, c=50)", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "identified_estimand", "=", "causal_model", ".", "identify_effect", "(", "method_name", "=", "\"id-algorithm\"", ")", "\n", "\n", "# Compare with ground truth", "\n", "set_a", "=", "set", "(", "identified_estimand", ".", "_product", "[", "0", "]", ".", "_product", "[", "0", "]", ".", "_product", "[", "0", "]", "[", "'outcome_vars'", "]", ".", "_set", ")", "\n", "set_b", "=", "set", "(", "identified_estimand", ".", "_product", "[", "0", "]", ".", "_product", "[", "0", "]", ".", "_product", "[", "0", "]", "[", "'condition_vars'", "]", ".", "_set", ")", "\n", "set_c", "=", "set", "(", "identified_estimand", ".", "_product", "[", "0", "]", ".", "_product", "[", "1", "]", ".", "_product", "[", "0", "]", "[", "'outcome_vars'", "]", ".", "_set", ")", "\n", "set_d", "=", "set", "(", "identified_estimand", ".", "_product", "[", "0", "]", ".", "_product", "[", "1", "]", ".", "_product", "[", "0", "]", "[", "'condition_vars'", "]", ".", "_set", ")", "\n", "assert", "identified_estimand", ".", "_product", "[", "0", "]", ".", "_sum", "==", "[", "'X1'", "]", "\n", "assert", "len", "(", "set_a", ".", "difference", "(", "{", "'Y'", "}", ")", ")", "==", "0", "\n", "assert", "len", "(", "set_b", ".", "difference", "(", "{", "'X1'", ",", "'X2'", ",", "'T'", "}", ")", ")", "==", "0", "\n", "assert", "len", "(", "set_c", ".", "difference", "(", "{", "'X1'", "}", ")", ")", "==", "0", "\n", "assert", "len", "(", "set_d", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_id_identifier.TestIDIdentifier.test_6": [[100, 116], ["pandas.DataFrame", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.identify_effect.__str__", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__"], ["", "def", "test_6", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", "]", "\n", "causal_graph", "=", "\"digraph{T;X1->Y;}\"", "\n", "columns", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "columns", ")", "\n", "\n", "# Calculate causal effect twice: once for unit (t=1, c=0), once for specific increase (t=100, c=50)", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "identified_estimand", "=", "causal_model", ".", "identify_effect", "(", "method_name", "=", "\"id-algorithm\"", ")", "\n", "\n", "# Compare with ground truth", "\n", "identified_str", "=", "identified_estimand", ".", "__str__", "(", ")", "\n", "gt_str", "=", "\"Sum over {X1}:\\n\\tPredictor: P(X1,Y)\"", "\n", "assert", "identified_str", "==", "gt_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_backdoor_identifier.TestBackdoorIdentification.test_identify_backdoor_no_biased_sets": [[10, 28], ["dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "set", "all", "len", "len", "len", "set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor"], ["    ", "def", "test_identify_backdoor_no_biased_sets", "(", "self", ",", "example_graph_solution", ":", "IdentificationTestGraphSolution", ")", ":", "\n", "        ", "graph", "=", "example_graph_solution", ".", "graph", "\n", "biased_sets", "=", "example_graph_solution", ".", "biased_sets", "\n", "identifier", "=", "CausalIdentifier", "(", "graph", ",", "\"nonparametric-ate\"", ",", "method_name", "=", "\"exhaustive-search\"", ")", "\n", "\n", "backdoor_results", "=", "identifier", ".", "identify_backdoor", "(", "\"X\"", ",", "\"Y\"", ",", "include_unobserved", "=", "False", ")", "\n", "backdoor_sets", "=", "[", "\n", "set", "(", "backdoor_result_dict", "[", "\"backdoor_set\"", "]", ")", "\n", "for", "backdoor_result_dict", "in", "backdoor_results", "\n", "if", "len", "(", "backdoor_result_dict", "[", "\"backdoor_set\"", "]", ")", ">", "0", "\n", "]", "\n", "\n", "assert", "(", "\n", "(", "len", "(", "backdoor_sets", ")", "==", "0", "and", "len", "(", "biased_sets", ")", "==", "0", ")", "# No biased sets exist and that's expected.", "\n", "or", "\n", "all", "(", "[", "\n", "set", "(", "biased_backdoor_set", ")", "not", "in", "backdoor_sets", "\n", "for", "biased_backdoor_set", "in", "biased_sets", "\n", "]", ")", "# No sets that would induce biased results are present in the solution.", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_backdoor_identifier.TestBackdoorIdentification.test_identify_backdoor_unobserved_not_in_backdoor_set": [[31, 44], ["dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "all", "set", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor"], ["", "def", "test_identify_backdoor_unobserved_not_in_backdoor_set", "(", "self", ",", "example_graph_solution", ":", "IdentificationTestGraphSolution", ")", ":", "\n", "        ", "graph", "=", "example_graph_solution", ".", "graph", "\n", "observed_variables", "=", "example_graph_solution", ".", "observed_variables", "\n", "identifier", "=", "CausalIdentifier", "(", "graph", ",", "\"nonparametric-ate\"", ",", "method_name", "=", "\"exhaustive-search\"", ")", "\n", "\n", "backdoor_results", "=", "identifier", ".", "identify_backdoor", "(", "\"X\"", ",", "\"Y\"", ",", "include_unobserved", "=", "False", ")", "\n", "backdoor_sets", "=", "[", "\n", "set", "(", "backdoor_result_dict", "[", "\"backdoor_set\"", "]", ")", "\n", "for", "backdoor_result_dict", "in", "backdoor_results", "\n", "if", "len", "(", "backdoor_result_dict", "[", "\"backdoor_set\"", "]", ")", ">", "0", "\n", "]", "\n", "\n", "assert", "all", "(", "[", "variable", "in", "observed_variables", "for", "backdoor_set", "in", "backdoor_sets", "for", "variable", "in", "backdoor_set", "]", ")", "# All variables used in the backdoor sets must be observed.", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_backdoor_identifier.TestBackdoorIdentification.test_identify_backdoor_minimal_adjustment": [[45, 62], ["dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "set", "all", "len", "len", "set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor"], ["", "def", "test_identify_backdoor_minimal_adjustment", "(", "self", ",", "example_graph_solution", ":", "IdentificationTestGraphSolution", ")", ":", "\n", "        ", "graph", "=", "example_graph_solution", ".", "graph", "\n", "expected_sets", "=", "example_graph_solution", ".", "minimal_adjustment_sets", "\n", "identifier", "=", "CausalIdentifier", "(", "graph", ",", "\"nonparametric-ate\"", ",", "method_name", "=", "\"minimal-adjustment\"", ",", "proceed_when_unidentifiable", "=", "False", ")", "\n", "\n", "backdoor_results", "=", "identifier", ".", "identify_backdoor", "(", "\"X\"", ",", "\"Y\"", ",", "include_unobserved", "=", "False", ")", "\n", "backdoor_sets", "=", "[", "\n", "set", "(", "backdoor_result_dict", "[", "\"backdoor_set\"", "]", ")", "\n", "for", "backdoor_result_dict", "in", "backdoor_results", "\n", "]", "\n", "\n", "assert", "(", "\n", "(", "(", "len", "(", "backdoor_sets", ")", "==", "0", ")", "and", "(", "len", "(", "expected_sets", ")", "==", "0", ")", ")", "# No adjustments exist and that's expected.", "\n", "or", "\n", "all", "(", "[", "\n", "set", "(", "expected_set", ")", "in", "backdoor_sets", "\n", "for", "expected_set", "in", "expected_sets", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_backdoor_identifier.TestBackdoorIdentification.test_identify_backdoor_maximal_adjustment": [[65, 83], ["dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifier.CausalIdentifier.identify_backdoor", "print", "set", "all", "len", "len", "set"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_identifier.CausalIdentifier.identify_backdoor"], ["", "def", "test_identify_backdoor_maximal_adjustment", "(", "self", ",", "example_graph_solution", ":", "IdentificationTestGraphSolution", ")", ":", "\n", "        ", "graph", "=", "example_graph_solution", ".", "graph", "\n", "expected_sets", "=", "example_graph_solution", ".", "maximal_adjustment_sets", "\n", "identifier", "=", "CausalIdentifier", "(", "graph", ",", "\"nonparametric-ate\"", ",", "method_name", "=", "\"maximal-adjustment\"", ",", "proceed_when_unidentifiable", "=", "False", ")", "\n", "\n", "backdoor_results", "=", "identifier", ".", "identify_backdoor", "(", "\"X\"", ",", "\"Y\"", ",", "include_unobserved", "=", "False", ")", "\n", "\n", "backdoor_sets", "=", "[", "\n", "set", "(", "backdoor_result_dict", "[", "\"backdoor_set\"", "]", ")", "\n", "for", "backdoor_result_dict", "in", "backdoor_results", "\n", "]", "\n", "print", "(", "backdoor_sets", ",", "expected_sets", ",", "example_graph_solution", ".", "graph_str", ")", "\n", "assert", "(", "\n", "(", "(", "len", "(", "backdoor_sets", ")", "==", "0", ")", "and", "(", "len", "(", "expected_sets", ")", "==", "0", ")", ")", "# No adjustments exist and that's expected.", "\n", "or", "\n", "all", "(", "[", "\n", "set", "(", "expected_set", ")", "in", "backdoor_sets", "\n", "for", "expected_set", "in", "expected_sets", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_optimize_backdoor.TestOptimizeBackdoorIdentifier.test_1": [[9, 43], ["pandas.DataFrame", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.CausalModel", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifiers.backdoor.Backdoor", "dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "print", "dowhy.causal_identifier.CausalIdentifier._graph.get_backdoor_paths", "set", "dowhy.causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "print", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_backdoor_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set"], ["    ", "def", "test_1", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", ",", "\"X2\"", "]", "\n", "causal_graph", "=", "\"digraph{X1->T;X2->T;X1->X2;X2->Y;T->Y}\"", "\n", "\n", "vars", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "vars", ")", "\n", "\n", "treatment_name", "=", "parse_state", "(", "treatment", ")", "\n", "outcome_name", "=", "parse_state", "(", "outcome", ")", "\n", "\n", "# Causal model initialization", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "\n", "# Causal identifier identification", "\n", "identifier", "=", "CausalIdentifier", "(", "causal_model", ".", "_graph", ",", "\n", "estimand_type", "=", "None", ",", "\n", "method_name", "=", "\"default\"", ",", "\n", "proceed_when_unidentifiable", "=", "None", ")", "\n", "\n", "# Obtain backdoor sets", "\n", "path", "=", "Backdoor", "(", "identifier", ".", "_graph", ".", "_graph", ",", "treatment_name", ",", "outcome_name", ")", "\n", "backdoor_sets", "=", "path", ".", "get_backdoor_vars", "(", ")", "\n", "print", "(", "backdoor_sets", ")", "\n", "# Check if backdoor sets are valid i.e. if they block all paths between the treatment and the outcome", "\n", "backdoor_paths", "=", "identifier", ".", "_graph", ".", "get_backdoor_paths", "(", "treatment_name", ",", "outcome_name", ")", "\n", "check_set", "=", "set", "(", "backdoor_sets", "[", "0", "]", "[", "'backdoor_set'", "]", ")", "\n", "check", "=", "identifier", ".", "_graph", ".", "check_valid_backdoor_set", "(", "\n", "treatment_name", ",", "outcome_name", ",", "check_set", ",", "\n", "backdoor_paths", "=", "backdoor_paths", ",", "\n", "dseparation_algo", "=", "\"naive\"", ")", "\n", "print", "(", "check", ")", "\n", "assert", "check", "[", "\"is_dseparated\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_optimize_backdoor.TestOptimizeBackdoorIdentifier.test_2": [[44, 70], ["pandas.DataFrame", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.CausalModel", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifiers.backdoor.Backdoor", "dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "list", "len", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars"], ["", "def", "test_2", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", ",", "\"X2\"", "]", "\n", "causal_graph", "=", "\"digraph{T->X1;T->X2;X1->X2;X2->Y;T->Y}\"", "\n", "\n", "vars", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "vars", ")", "\n", "\n", "treatment_name", "=", "parse_state", "(", "treatment", ")", "\n", "outcome_name", "=", "parse_state", "(", "outcome", ")", "\n", "\n", "# Causal model initialization", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "\n", "# Causal identifier identification", "\n", "identifier", "=", "CausalIdentifier", "(", "causal_model", ".", "_graph", ",", "\n", "estimand_type", "=", "None", ",", "\n", "method_name", "=", "\"default\"", ",", "\n", "proceed_when_unidentifiable", "=", "None", ")", "\n", "\n", "# Obtain backdoor sets", "\n", "path", "=", "Backdoor", "(", "identifier", ".", "_graph", ".", "_graph", ",", "treatment_name", ",", "outcome_name", ")", "\n", "backdoor_sets", "=", "path", ".", "get_backdoor_vars", "(", ")", "\n", "\n", "assert", "len", "(", "backdoor_sets", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_optimize_backdoor.TestOptimizeBackdoorIdentifier.test_3": [[71, 102], ["pandas.DataFrame", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.CausalModel", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifiers.backdoor.Backdoor", "dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "dowhy.causal_identifier.CausalIdentifier._graph.get_backdoor_paths", "set", "dowhy.causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_backdoor_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set"], ["", "def", "test_3", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", ",", "\"X2\"", ",", "\"X3\"", "]", "\n", "causal_graph", "=", "\"digraph{X1->T;X1->X2;Y->X2;X3->T;X3->Y;T->Y}\"", "\n", "\n", "vars", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "vars", ")", "\n", "\n", "treatment_name", "=", "parse_state", "(", "treatment", ")", "\n", "outcome_name", "=", "parse_state", "(", "outcome", ")", "\n", "\n", "# Causal model initialization", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "\n", "# Causal identifier identification", "\n", "identifier", "=", "CausalIdentifier", "(", "causal_model", ".", "_graph", ",", "\n", "estimand_type", "=", "None", ",", "\n", "method_name", "=", "\"default\"", ",", "\n", "proceed_when_unidentifiable", "=", "None", ")", "\n", "\n", "# Obtain backdoor sets", "\n", "path", "=", "Backdoor", "(", "identifier", ".", "_graph", ".", "_graph", ",", "treatment_name", ",", "outcome_name", ")", "\n", "backdoor_sets", "=", "path", ".", "get_backdoor_vars", "(", ")", "\n", "\n", "# Check if backdoor sets are valid i.e. if they block all paths between the treatment and the outcome", "\n", "backdoor_paths", "=", "identifier", ".", "_graph", ".", "get_backdoor_paths", "(", "treatment_name", ",", "outcome_name", ")", "\n", "check_set", "=", "set", "(", "backdoor_sets", "[", "0", "]", "[", "'backdoor_set'", "]", ")", "\n", "check", "=", "identifier", ".", "_graph", ".", "check_valid_backdoor_set", "(", "treatment_name", ",", "outcome_name", ",", "check_set", ",", "backdoor_paths", "=", "backdoor_paths", ")", "\n", "\n", "assert", "check", "[", "\"is_dseparated\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_optimize_backdoor.TestOptimizeBackdoorIdentifier.test_4": [[103, 134], ["pandas.DataFrame", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.CausalModel", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifiers.backdoor.Backdoor", "dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "dowhy.causal_identifier.CausalIdentifier._graph.get_backdoor_paths", "set", "dowhy.causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_backdoor_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set"], ["", "def", "test_4", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", ",", "\"X2\"", "]", "\n", "causal_graph", "=", "\"digraph{T->Y;X1->T;X1->Y;X2->T;}\"", "\n", "\n", "vars", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "vars", ")", "\n", "\n", "treatment_name", "=", "parse_state", "(", "treatment", ")", "\n", "outcome_name", "=", "parse_state", "(", "outcome", ")", "\n", "\n", "# Causal model initialization", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "\n", "# Causal identifier identification", "\n", "identifier", "=", "CausalIdentifier", "(", "causal_model", ".", "_graph", ",", "\n", "estimand_type", "=", "None", ",", "\n", "method_name", "=", "\"default\"", ",", "\n", "proceed_when_unidentifiable", "=", "None", ")", "\n", "\n", "# Obtain backdoor sets", "\n", "path", "=", "Backdoor", "(", "identifier", ".", "_graph", ".", "_graph", ",", "treatment_name", ",", "outcome_name", ")", "\n", "backdoor_sets", "=", "path", ".", "get_backdoor_vars", "(", ")", "\n", "\n", "# Check if backdoor sets are valid i.e. if they block all paths between the treatment and the outcome", "\n", "backdoor_paths", "=", "identifier", ".", "_graph", ".", "get_backdoor_paths", "(", "treatment_name", ",", "outcome_name", ")", "\n", "check_set", "=", "set", "(", "backdoor_sets", "[", "0", "]", "[", "'backdoor_set'", "]", ")", "\n", "check", "=", "identifier", ".", "_graph", ".", "check_valid_backdoor_set", "(", "treatment_name", ",", "outcome_name", ",", "check_set", ",", "backdoor_paths", "=", "backdoor_paths", ")", "\n", "\n", "assert", "check", "[", "\"is_dseparated\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_optimize_backdoor.TestOptimizeBackdoorIdentifier.test_5": [[135, 166], ["pandas.DataFrame", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.CausalModel", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifiers.backdoor.Backdoor", "dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "dowhy.causal_identifier.CausalIdentifier._graph.get_backdoor_paths", "set", "dowhy.causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_backdoor_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set"], ["", "def", "test_5", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", ",", "\"X2\"", ",", "\"X3\"", ",", "\"X4\"", "]", "\n", "causal_graph", "=", "\"digraph{X1->T;X1->X2;X2->Y;X3->T;X3->X4;X4->Y;T->Y}\"", "\n", "\n", "vars", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "vars", ")", "\n", "\n", "treatment_name", "=", "parse_state", "(", "treatment", ")", "\n", "outcome_name", "=", "parse_state", "(", "outcome", ")", "\n", "\n", "# Causal model initialization", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "\n", "# Causal identifier identification", "\n", "identifier", "=", "CausalIdentifier", "(", "causal_model", ".", "_graph", ",", "\n", "estimand_type", "=", "None", ",", "\n", "method_name", "=", "\"default\"", ",", "\n", "proceed_when_unidentifiable", "=", "None", ")", "\n", "\n", "# Obtain backdoor sets", "\n", "path", "=", "Backdoor", "(", "identifier", ".", "_graph", ".", "_graph", ",", "treatment_name", ",", "outcome_name", ")", "\n", "backdoor_sets", "=", "path", ".", "get_backdoor_vars", "(", ")", "\n", "\n", "# Check if backdoor sets are valid i.e. if they block all paths between the treatment and the outcome", "\n", "backdoor_paths", "=", "identifier", ".", "_graph", ".", "get_backdoor_paths", "(", "treatment_name", ",", "outcome_name", ")", "\n", "check_set", "=", "set", "(", "backdoor_sets", "[", "0", "]", "[", "'backdoor_set'", "]", ")", "\n", "check", "=", "identifier", ".", "_graph", ".", "check_valid_backdoor_set", "(", "treatment_name", ",", "outcome_name", ",", "check_set", ",", "backdoor_paths", "=", "backdoor_paths", ")", "\n", "\n", "assert", "check", "[", "\"is_dseparated\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.test_optimize_backdoor.TestOptimizeBackdoorIdentifier.test_6": [[167, 198], ["pandas.DataFrame", "dowhy.utils.api.parse_state", "dowhy.utils.api.parse_state", "dowhy.CausalModel", "dowhy.causal_identifier.CausalIdentifier", "dowhy.causal_identifiers.backdoor.Backdoor", "dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "dowhy.causal_identifier.CausalIdentifier._graph.get_backdoor_paths", "set", "dowhy.causal_identifier.CausalIdentifier._graph.check_valid_backdoor_set", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Backdoor.get_backdoor_vars", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_backdoor_paths", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.check_valid_backdoor_set"], ["", "def", "test_6", "(", "self", ")", ":", "\n", "        ", "treatment", "=", "\"T\"", "\n", "outcome", "=", "\"Y\"", "\n", "variables", "=", "[", "\"X1\"", ",", "\"X2\"", ",", "\"X3\"", ",", "\"X4\"", "]", "\n", "causal_graph", "=", "\"digraph{X1->T;X1->X2;Y->X2;X3->T;X3->X4;X4->Y;T->Y}\"", "\n", "\n", "vars", "=", "list", "(", "treatment", ")", "+", "list", "(", "outcome", ")", "+", "list", "(", "variables", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "vars", ")", "\n", "\n", "treatment_name", "=", "parse_state", "(", "treatment", ")", "\n", "outcome_name", "=", "parse_state", "(", "outcome", ")", "\n", "\n", "# Causal model initialization", "\n", "causal_model", "=", "CausalModel", "(", "df", ",", "treatment", ",", "outcome", ",", "graph", "=", "causal_graph", ")", "\n", "\n", "# Causal identifier identification", "\n", "identifier", "=", "CausalIdentifier", "(", "causal_model", ".", "_graph", ",", "\n", "estimand_type", "=", "None", ",", "\n", "method_name", "=", "\"default\"", ",", "\n", "proceed_when_unidentifiable", "=", "None", ")", "\n", "\n", "# Obtain backdoor sets", "\n", "path", "=", "Backdoor", "(", "identifier", ".", "_graph", ".", "_graph", ",", "treatment_name", ",", "outcome_name", ")", "\n", "backdoor_sets", "=", "path", ".", "get_backdoor_vars", "(", ")", "\n", "\n", "# Check if backdoor sets are valid i.e. if they block all paths between the treatment and the outcome", "\n", "backdoor_paths", "=", "identifier", ".", "_graph", ".", "get_backdoor_paths", "(", "treatment_name", ",", "outcome_name", ")", "\n", "check_set", "=", "set", "(", "backdoor_sets", "[", "0", "]", "[", "'backdoor_set'", "]", ")", "\n", "check", "=", "identifier", ".", "_graph", ".", "check_valid_backdoor_set", "(", "treatment_name", ",", "outcome_name", ",", "check_set", ",", "backdoor_paths", "=", "backdoor_paths", ")", "\n", "\n", "assert", "check", "[", "\"is_dseparated\"", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_using_discretization": [[16, 32], ["dowhy.gcm.util.general.shape_into_2d", "numpy.max", "numpy.min", "max", "RuntimeError", "int", "numpy.sum", "numpy.log", "numpy.histogram", "numpy.linspace().reshape", "numpy.linspace"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["def", "estimate_entropy_using_discretization", "(", "X", ":", "np", ".", "ndarray", ",", "bin_width", ":", "float", "=", "1", ")", "->", "float", ":", "\n", "# TODO: Add method for auto select a bin_width/width based on the data. Make sure that the auto selection method is", "\n", "#  theoretically sound, i.e. make entropy results from different data comparable.", "\n", "    ", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "if", "X", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "        ", "raise", "RuntimeError", "(", "'The discrete entropy estimator can only handle one dimensional data, but the input data is '", "\n", "'%d dimensional!'", "%", "X", ".", "shape", "[", "1", "]", ")", "\n", "\n", "", "max_value", "=", "np", ".", "max", "(", "X", ")", "\n", "min_value", "=", "np", ".", "min", "(", "X", ")", "\n", "number_of_bins", "=", "max", "(", "1", ",", "int", "(", "(", "max_value", "-", "min_value", ")", "/", "bin_width", ")", ")", "\n", "num_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "return", "-", "np", ".", "sum", "(", "[", "(", "i", "/", "num_samples", "*", "np", ".", "log", "(", "i", "/", "num_samples", ")", ")", "if", "i", ">", "0", "else", "0", "\n", "for", "i", "in", "\n", "np", ".", "histogram", "(", "X", ",", "bins", "=", "np", ".", "linspace", "(", "min_value", ",", "max_value", ",", "number_of_bins", ")", ".", "reshape", "(", "-", "1", ")", ")", "[", "0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_kmeans": [[34, 50], ["dowhy.gcm.util.general.shape_into_2d", "int", "sklearn.neighbors.NearestNeighbors().fit", "NearestNeighbors().fit.kneighbors", "numpy.sum", "numpy.sqrt", "numpy.log", "sklearn.neighbors.NearestNeighbors", "scipy.special.digamma", "scipy.special.digamma", "float"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "estimate_entropy_kmeans", "(", "X", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "\"\"\"Related paper:\n           Kozachenko, L., & Leonenko, N. (1987). Sample estimate of the entropy of a random vector. Problemy Peredachi\n           Informatsii, 23(2), 9\u201316.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "k", "=", "int", "(", "np", ".", "sqrt", "(", "X", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "x_neighbourhood", "=", "NearestNeighbors", "(", "n_neighbors", "=", "k", "+", "1", ")", ".", "fit", "(", "X", ")", "\n", "distances", ",", "_", "=", "x_neighbourhood", ".", "kneighbors", "(", "X", ",", "k", "+", "1", ")", "\n", "distances", "=", "distances", "[", ":", ",", "-", "1", "]", "\n", "\n", "sum_log_dist", "=", "np", ".", "sum", "(", "np", ".", "log", "(", "2", "*", "distances", "+", "EPS", ")", ")", "\n", "\n", "return", "-", "digamma", "(", "k", ")", "+", "digamma", "(", "X", ".", "shape", "[", "0", "]", ")", "+", "(", "X", ".", "shape", "[", "1", "]", "/", "float", "(", "X", ".", "shape", "[", "0", "]", ")", ")", "*", "sum_log_dist", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_gaussian_entropy": [[52, 60], ["dowhy.gcm.util.general.shape_into_2d", "numpy.log", "numpy.log", "uncertainty.estimate_variance", "uncertainty.estimate_variance"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance"], ["", "def", "estimate_gaussian_entropy", "(", "X", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "\"\"\"Entropy with respect to standardized variables.\"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "if", "X", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "        ", "return", "0.5", "*", "np", ".", "log", "(", "(", "2", "*", "np", ".", "pi", "*", "np", ".", "e", ")", "**", "X", ".", "shape", "[", "1", "]", "*", "estimate_variance", "(", "X", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "0.5", "*", "np", ".", "log", "(", "2", "*", "np", ".", "pi", "*", "np", ".", "e", "*", "estimate_variance", "(", "X", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance": [[62, 72], ["dowhy.gcm.util.general.shape_into_2d", "max", "numpy.dual.det", "numpy.var", "numpy.cov"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "", "def", "estimate_variance", "(", "X", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "if", "X", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "        ", "result", "=", "det", "(", "np", ".", "cov", "(", "X", ",", "rowvar", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "        ", "result", "=", "np", ".", "var", "(", "X", ")", "\n", "\n", "# Extremely small values can somehow result in negative values.", "\n", "", "return", "max", "(", "0.0", ",", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities": [[74, 79], ["float", "numpy.mean", "scipy.stats.entropy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy"], ["", "def", "estimate_entropy_of_probabilities", "(", "X", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "\"\"\"Estimates the entropy of each probability vector (row wise) in X separately and returns the mean over all\n    results.\n    \"\"\"", "\n", "return", "float", "(", "np", ".", "mean", "(", "entropy", "(", "X", ",", "axis", "=", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_discrete": [[81, 91], ["dowhy.gcm.util.general.shape_into_2d", "numpy.unique", "scipy.stats.entropy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy"], ["", "def", "estimate_entropy_discrete", "(", "X", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "\"\"\"Estimates the entropy assuming the data in X is discrete.\n\n    :param X: Discrete samples.\n    :return: Entropy of X.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "_", ",", "counts", "=", "np", ".", "unique", "(", "X", ",", "return_counts", "=", "True", ",", "axis", "=", "0", ")", "\n", "return", "entropy", "(", "counts", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.conditional_anomaly_scores": [[19, 46], ["dowhy.gcm.util.general.shape_into_2d", "numpy.zeros", "range", "ValueError", "causal_mechanism.draw_samples", "anomaly_scorer_factory", "anomaly_scorer_factory.fit", "numpy.matlib.repmat", "anomaly_scorer_factory.score"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["def", "conditional_anomaly_scores", "(", "parent_samples", ":", "np", ".", "ndarray", ",", "\n", "target_samples", ":", "np", ".", "ndarray", ",", "\n", "causal_mechanism", ":", "ConditionalStochasticModel", ",", "\n", "anomaly_scorer_factory", ":", "Callable", "[", "[", "]", ",", "AnomalyScorer", "]", "=", "MedianCDFQuantileScorer", ",", "\n", "num_samples_conditional", ":", "int", "=", "10000", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Estimates the conditional anomaly scores based on the expected outcomes of the causal model.\n\n    :param parent_samples: Samples from all parents of the target node.\n    :param target_samples: Samples from the target node.\n    :param causal_mechanism: Causal mechanism of the target node.\n    :param anomaly_scorer_factory: A callable that returns an anomaly scorer.\n    :param num_samples_conditional: Number of samples drawn from the conditional distribution based on the given\n                                    parent samples. The more samples, the more accurate the results.\n    :return: The conditional anomaly score for each sample in target_samples.\n    \"\"\"", "\n", "parent_samples", ",", "target_samples", "=", "shape_into_2d", "(", "parent_samples", ",", "target_samples", ")", "\n", "if", "parent_samples", ".", "shape", "[", "0", "]", "!=", "target_samples", ".", "shape", "[", "0", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"There should be as many parent samples as target samples!\"", ")", "\n", "\n", "", "result", "=", "np", ".", "zeros", "(", "parent_samples", ".", "shape", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "parent_samples", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "samples_from_conditional", "=", "causal_mechanism", ".", "draw_samples", "(", "repmat", "(", "parent_samples", "[", "i", "]", ",", "num_samples_conditional", ",", "1", ")", ")", "\n", "anomaly_scorer", "=", "anomaly_scorer_factory", "(", ")", "\n", "anomaly_scorer", ".", "fit", "(", "samples_from_conditional", ")", "\n", "result", "[", "i", "]", "=", "anomaly_scorer", ".", "score", "(", "target_samples", "[", "i", "]", ")", "[", "0", "]", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores": [[48, 77], ["isinstance", "dowhy.gcm.graph.validate_causal_dag", "tqdm.tqdm", "pandas.DataFrame", "dowhy.gcm.graph.is_root_node", "anomaly_scorer_factory", "anomaly_scorer_factory.fit", "anomaly_scorer_factory.score", "anomaly_data[].to_numpy", "anomaly_data[].to_numpy", "anomaly.conditional_anomaly_scores", "causal_model.causal_mechanism().draw_samples", "anomaly_data[].to_numpy", "causal_model.causal_mechanism", "causal_model.causal_mechanism", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.conditional_anomaly_scores", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "def", "anomaly_scores", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "\n", "anomaly_data", ":", "pd", ".", "DataFrame", ",", "\n", "num_samples_conditional", ":", "int", "=", "10000", ",", "\n", "num_samples_unconditional", ":", "int", "=", "10000", ",", "\n", "anomaly_scorer_factory", ":", "Callable", "[", "[", "]", ",", "AnomalyScorer", "]", "=", "RescaledMedianCDFQuantileScorer", ")", "->", "Dict", "[", "Any", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "if", "isinstance", "(", "anomaly_data", ",", "pd", ".", "Series", ")", ":", "\n", "        ", "anomaly_data", "=", "pd", ".", "DataFrame", "(", "[", "anomaly_data", "]", ")", "\n", "\n", "", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "results", "=", "{", "}", "\n", "for", "node", "in", "tqdm", "(", "causal_model", ".", "graph", ".", "nodes", ",", "desc", "=", "'Estimating conditional anomaly scores'", ",", "position", "=", "0", ",", "leave", "=", "True", ",", "\n", "disable", "=", "not", "config", ".", "show_progress_bars", ")", ":", "\n", "\n", "        ", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "node", ")", ":", "\n", "            ", "anomaly_scorer", "=", "anomaly_scorer_factory", "(", ")", "\n", "anomaly_scorer", ".", "fit", "(", "causal_model", ".", "causal_mechanism", "(", "node", ")", ".", "draw_samples", "(", "num_samples_unconditional", ")", ")", "\n", "results", "[", "node", "]", "=", "anomaly_scorer", ".", "score", "(", "anomaly_data", "[", "node", "]", ".", "to_numpy", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "tmp_anomaly_parent_samples", "=", "anomaly_data", "[", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", "\n", "tmp_anomaly_target_samples", "=", "anomaly_data", "[", "node", "]", ".", "to_numpy", "(", ")", "\n", "results", "[", "node", "]", "=", "conditional_anomaly_scores", "(", "tmp_anomaly_parent_samples", ",", "\n", "tmp_anomaly_target_samples", ",", "\n", "causal_model", ".", "causal_mechanism", "(", "node", ")", ",", "\n", "anomaly_scorer_factory", ",", "\n", "num_samples_conditional", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.attribute_anomalies": [[79, 137], ["dowhy.gcm.graph.validate_causal_dag", "dowhy.gcm._noise.compute_noise_from_data", "dowhy.gcm._noise.noise_samples_of_ancestors", "dowhy.gcm._noise.get_noise_dependent_function", "dowhy.gcm.anomaly_scorers.MedianCDFQuantileScorer.fit", "anomaly.attribute_anomaly_scores", "dowhy.gcm.anomaly_scorers.MedianCDFQuantileScorer", "node_samples[].to_numpy", "noise_of_anomaly_samples[].to_numpy", "noise_samples[].to_numpy", "dowhy.gcm.anomaly_scorers.MedianCDFQuantileScorer.score", "enumerate", "noise_dependent_function"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.compute_noise_from_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.noise_samples_of_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.get_noise_dependent_function", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.attribute_anomaly_scores", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["", "def", "attribute_anomalies", "(", "causal_model", ":", "InvertibleStructuralCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "anomaly_samples", ":", "pd", ".", "DataFrame", ",", "\n", "anomaly_scorer", ":", "Optional", "[", "AnomalyScorer", "]", "=", "None", ",", "\n", "attribute_mean_deviation", ":", "bool", "=", "False", ",", "\n", "num_distribution_samples", ":", "int", "=", "5000", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ")", "->", "Dict", "[", "Any", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"Estimates the contributions of upstream nodes to the anomaly score of the target_node for each sample in\n    anomaly_samples. By default, the anomaly score is based on the information theoretic (IT) score\n    -log(P(g(X) >= g(x))), where g is the anomaly_scorer, X samples from the marginal\n    distribution of the target_node and x an observation of the target_node in anomaly_samples. If\n    attribute_mean_deviation is set to True, the contribution to g(x) - E[g(X)] is estimated instead, i.e. the feature\n    relevance for the given scoring function. The underlying algorithm utilizes the reconstructed noise of upstream\n    nodes (including the target_node itself) for the given anomaly_samples. By this, it is possible to estimate how\n    much of the anomaly score can be explained by upstream anomalies with respect to anomalous noise values.\n\n    Note: This function requires that the noise can be recovered from samples, i.e. the causal models of non-root nodes\n    need to be an InvertibleNoiseModel (e.g. AdditiveNoiseModel).\n\n    Related paper:\n    Janzing, D., Budhathoki, K., Minorics, L., & Bloebaum, P. (2019).\n    Causal structure based root cause analysis of outliers\n    https://arxiv.org/abs/1912.02724\n\n    :param causal_model: The fitted InvertibleStructuralCausalModel.\n    :param target_node: Target node for which the contributions are estimated.\n    :param anomaly_samples: Anomalous observations for which the contributions are estimated.\n    :param anomaly_scorer: Anomaly scorer g. If None is given, a MedianCDFQuantileScorer is used.\n    :param attribute_mean_deviation: If set to False, the contribution is estimated based on the IT score and if it is\n                                     set to True, the contribution is based on the feature relevance with respect to the given scoring function.\n    :param num_distribution_samples: Number of samples from X, the marginal distribution of the target. These are used\n                                     for evaluating the tail probability in case of the IT score\n                                     (attribute_mean_deviation is False) or as samples for randomization in case of\n                                     feature relevance (attribute_mean_deviation is True).\n    :param shapley_config: :class:`~dowhy.gcm.shapley.ShapleyConfig` for the Shapley estimator.\n    :return: A dictionary that assigns a numpy array to each upstream node including the target_node itself. The\n             i-th entry of an array indicates the contribution of the corresponding node to the anomaly score of the target\n             for the i-th observation in anomaly_samples.\n    \"\"\"", "\n", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "if", "anomaly_scorer", "is", "None", ":", "\n", "        ", "anomaly_scorer", "=", "MedianCDFQuantileScorer", "(", ")", "\n", "\n", "", "noise_of_anomaly_samples", "=", "compute_noise_from_data", "(", "causal_model", ",", "anomaly_samples", ")", "\n", "node_samples", ",", "noise_samples", "=", "noise_samples_of_ancestors", "(", "causal_model", ",", "\n", "target_node", ",", "\n", "num_distribution_samples", ")", "\n", "noise_dependent_function", ",", "nodes_order", "=", "get_noise_dependent_function", "(", "causal_model", ",", "target_node", ")", "\n", "anomaly_scorer", ".", "fit", "(", "node_samples", "[", "target_node", "]", ".", "to_numpy", "(", ")", ")", "\n", "\n", "attributions", "=", "attribute_anomaly_scores", "(", "noise_of_anomaly_samples", "[", "nodes_order", "]", ".", "to_numpy", "(", ")", ",", "\n", "noise_samples", "[", "nodes_order", "]", ".", "to_numpy", "(", ")", ",", "\n", "lambda", "x", ":", "anomaly_scorer", ".", "score", "(", "noise_dependent_function", "(", "x", ")", ")", ",", "\n", "attribute_mean_deviation", ",", "\n", "shapley_config", ")", "\n", "\n", "return", "{", "node", ":", "attributions", "[", ":", ",", "i", "]", "for", "i", ",", "node", "in", "enumerate", "(", "nodes_order", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.attribute_anomaly_scores": [[139, 194], ["dowhy.gcm.shapley.estimate_shapley_values", "numpy.mean", "anomaly_scoring_func", "dowhy.gcm.stats.permute_features", "numpy.zeros", "range", "anomaly_scoring_func", "numpy.arange", "numpy.log", "numpy.mean", "anomaly._relative_frequency", "anomaly_scoring_func", "anomaly_scoring_func"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.permute_features", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly._relative_frequency"], ["", "def", "attribute_anomaly_scores", "(", "anomaly_samples", ":", "np", ".", "ndarray", ",", "\n", "distribution_samples", ":", "np", ".", "ndarray", ",", "\n", "anomaly_scoring_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "attribute_mean_deviation", ":", "bool", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Estimates the contributions of the features for each sample in anomaly_samples to the anomaly score obtained\n    by the anomaly_scoring_func. If attribute_mean_deviation is set to False, the anomaly score is based on the\n    information theoretic (IT) score -log(P(g(X) >= g(x))), where g is the anomaly_scoring_func, X samples from the\n    marginal distribution of the target_node and x an observation of the target_node in anomaly_samples. If\n    attribute_mean_deviation is set to True, the contribution to g(x) - E[g(X)] is estimated instead, i.e. the\n    feature relevance for the given scorer.\n\n    Note that the anomaly scoring function needs to handle the dimension and modality of the data. An example for a\n    function for multidimensional continues data would be:\n        density_estimator = GaussianMixtureDensityEstimator()\n        density_estimator.fit(original_observations)\n        anomaly_scoring_func = lambda x, y: estimate_inverse_density_score(x, y, density_estimator)\n\n    Related paper:\n    Janzing, D., Budhathoki, K., Minorics, L., & Bloebaum, P. (2022).\n    Causal structure based root cause analysis of outliers\n    https://arxiv.org/abs/1912.02724\n\n    :param anomaly_samples: Samples x for which the contributions are estimated. The dimensionality of these samples\n                            doesn't matter as long as the anomaly_scoring_func supports it.\n    :param distribution_samples: Samples from the (non-anomalous) distribution X.\n    :param anomaly_scoring_func: A function g that takes a sample from X as input and returns an anomaly score.\n    :param attribute_mean_deviation: If set to False, the contribution is estimated based on the IT score and if it is\n                                     set to True, the contribution is based on the feature relevance with respect to the\n                                     given scoring function.\n    :param shapley_config: :class:`~dowhy.gcm.shapley.ShapleyConfig` for the Shapley estimator.\n    :return: A numpy array with the feature contributions to the anomaly score for each sample in anomaly_samples.\n    \"\"\"", "\n", "if", "attribute_mean_deviation", ":", "\n", "        ", "expectation_of_score", "=", "np", ".", "mean", "(", "anomaly_scoring_func", "(", "distribution_samples", ")", ")", "\n", "", "else", ":", "\n", "        ", "anomaly_scores", "=", "anomaly_scoring_func", "(", "anomaly_samples", ")", "\n", "\n", "", "def", "set_function", "(", "subset", ":", "np", ".", "ndarray", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "float", "]", ":", "\n", "        ", "feature_samples", "=", "permute_features", "(", "distribution_samples", ",", "np", ".", "arange", "(", "0", ",", "subset", ".", "shape", "[", "0", "]", ")", "[", "subset", "==", "0", "]", ",", "True", ")", "\n", "\n", "result", "=", "np", ".", "zeros", "(", "anomaly_samples", ".", "shape", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "anomaly_samples", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "feature_samples", "[", ":", ",", "subset", "==", "1", "]", "=", "anomaly_samples", "[", "i", ",", "subset", "==", "1", "]", "\n", "\n", "if", "attribute_mean_deviation", ":", "\n", "# Usual feature relevance using the mean deviation as set function, i.e. g(x) - E[g(X)]", "\n", "                ", "result", "[", "i", "]", "=", "np", ".", "mean", "(", "anomaly_scoring_func", "(", "feature_samples", ")", ")", "-", "expectation_of_score", "\n", "", "else", ":", "\n", "                ", "result", "[", "i", "]", "=", "np", ".", "log", "(", "_relative_frequency", "(", "anomaly_scoring_func", "(", "feature_samples", ")", "\n", ">=", "anomaly_scores", "[", "i", "]", ")", ")", "\n", "\n", "", "", "return", "result", "\n", "\n", "", "return", "estimate_shapley_values", "(", "set_function", ",", "anomaly_samples", ".", "shape", "[", "1", "]", ",", "shapley_config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly._relative_frequency": [[196, 198], ["numpy.sum", "len"], "function", ["None"], ["", "def", "_relative_frequency", "(", "conditions", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "return", "(", "np", ".", "sum", "(", "conditions", ")", "+", "0.5", ")", "/", "(", "len", "(", "conditions", ")", "+", "0.5", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.config.enable_progress_bars": [[5, 8], ["None"], "function", ["None"], ["def", "enable_progress_bars", "(", ")", ":", "\n", "    ", "global", "show_progress_bars", "\n", "show_progress_bars", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.config.disable_progress_bars": [[10, 13], ["None"], "function", ["None"], ["", "def", "disable_progress_bars", "(", ")", ":", "\n", "    ", "global", "show_progress_bars", "\n", "show_progress_bars", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.config.set_default_n_jobs": [[15, 18], ["None"], "function", ["None"], ["", "def", "set_default_n_jobs", "(", "n_jobs", ":", "int", ")", "->", "None", ":", "\n", "    ", "global", "default_n_jobs", "\n", "default_n_jobs", "=", "n_jobs", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling.fit": [[19, 35], ["tqdm.tqdm", "tqdm.tqdm.set_description", "fitting_sampling.fit_causal_model_of_target", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling.fit_causal_model_of_target"], ["def", "fit", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "data", ":", "pd", ".", "DataFrame", ")", ":", "\n", "    ", "\"\"\"Learns generative causal models of nodes in the causal graph from data.\n\n    :param causal_model: The causal model containing the mechanisms that will be fitted.\n    :param data: Observations of nodes in the causal model.\n    \"\"\"", "\n", "progress_bar", "=", "tqdm", "(", "causal_model", ".", "graph", ".", "nodes", ",", "desc", "=", "'Fitting causal models'", ",", "position", "=", "0", ",", "leave", "=", "True", ",", "\n", "disable", "=", "not", "config", ".", "show_progress_bars", ")", "\n", "for", "node", "in", "progress_bar", ":", "\n", "        ", "if", "node", "not", "in", "data", ":", "\n", "            ", "raise", "RuntimeError", "(", "'Could not find data for node %s in the given training data! There should be a column '", "\n", "'containing samples for node %s.'", "%", "(", "node", ",", "node", ")", ")", "\n", "\n", "", "progress_bar", ".", "set_description", "(", "'Fitting causal mechanism of node %s'", "%", "node", ")", "\n", "\n", "fit_causal_model_of_target", "(", "causal_model", ",", "node", ",", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling.fit_causal_model_of_target": [[37, 63], ["dowhy.gcm.graph.validate_causal_model_assignment", "dowhy.gcm.graph.is_root_node", "dowhy.gcm.graph.get_ordered_predecessors", "causal_model.causal_mechanism().fit", "causal_model.causal_mechanism().fit", "causal_model.causal_mechanism", "training_data[].to_numpy", "causal_model.causal_mechanism", "training_data[].to_numpy", "training_data[].to_numpy", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_model_assignment", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "", "def", "fit_causal_model_of_target", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "training_data", ":", "pd", ".", "DataFrame", ")", "->", "None", ":", "\n", "    ", "\"\"\"Fits only the causal mechanism of the given target node based on the training data.\n\n    :param causal_model: The causal model containing the target node.\n    :param target_node: Target node for which the mechanism is fitted.\n    :param training_data: Training data for fitting the causal mechanism.\n    :return: None\n    \"\"\"", "\n", "validate_causal_model_assignment", "(", "causal_model", ".", "graph", ",", "target_node", ")", "\n", "\n", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "target_node", ")", ":", "\n", "        ", "causal_model", ".", "causal_mechanism", "(", "target_node", ")", ".", "fit", "(", "X", "=", "training_data", "[", "target_node", "]", ".", "to_numpy", "(", ")", ")", "\n", "", "else", ":", "\n", "        ", "causal_model", ".", "causal_mechanism", "(", "target_node", ")", ".", "fit", "(", "\n", "X", "=", "training_data", "[", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "target_node", ")", "]", ".", "to_numpy", "(", ")", ",", "\n", "Y", "=", "training_data", "[", "target_node", "]", ".", "to_numpy", "(", ")", ")", "\n", "\n", "# To be able to validate that the graph structure did not change between fitting and causal query, we store the", "\n", "# parents of a node during fit. That way, before sampling, we can verify the parents are still the same. While", "\n", "# this would automatically fail when the number of parents is different, there are other more subtle cases,", "\n", "# where the number is still the same, but it's different parents, and therefore different data. That would yield", "\n", "# wrong results, but would not fail.", "\n", "", "causal_model", ".", "graph", ".", "nodes", "[", "target_node", "]", "[", "PARENTS_DURING_FIT", "]", "=", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "target_node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling.draw_samples": [[65, 87], ["dowhy.gcm.graph.validate_causal_dag", "list", "pandas.DataFrame", "networkx.topological_sort", "numpy.empty", "causal_model.causal_mechanism", "dowhy.gcm.graph.is_root_node", "causal_model.causal_mechanism.draw_samples", "causal_model.causal_mechanism.draw_samples", "len", "fitting_sampling._parent_samples_of"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._parent_samples_of"], ["", "def", "draw_samples", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "num_samples", ":", "int", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "\"\"\"Draws new joint samples from the given graphical causal model. This is done by first generating random samples\n    from root nodes and then propagating causal downstream effects through the graph.\n\n    :param causal_model: New samples are generated based on the given causal model.\n    :param num_samples: Number of samples to draw.\n    :return: A pandas data frame where columns correspond to the nodes in the graph and rows to the drawn joint samples.\n    \"\"\"", "\n", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "sorted_nodes", "=", "list", "(", "nx", ".", "topological_sort", "(", "causal_model", ".", "graph", ")", ")", "\n", "drawn_samples", "=", "pd", ".", "DataFrame", "(", "np", ".", "empty", "(", "(", "num_samples", ",", "len", "(", "sorted_nodes", ")", ")", ")", ",", "columns", "=", "sorted_nodes", ")", "\n", "\n", "for", "node", "in", "sorted_nodes", ":", "\n", "        ", "causal_mechanism", "=", "causal_model", ".", "causal_mechanism", "(", "node", ")", "\n", "\n", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "node", ")", ":", "\n", "            ", "drawn_samples", "[", "node", "]", "=", "causal_mechanism", ".", "draw_samples", "(", "num_samples", ")", "\n", "", "else", ":", "\n", "            ", "drawn_samples", "[", "node", "]", "=", "causal_mechanism", ".", "draw_samples", "(", "_parent_samples_of", "(", "node", ",", "causal_model", ",", "drawn_samples", ")", ")", "\n", "\n", "", "", "return", "drawn_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling._parent_samples_of": [[89, 91], ["samples[].to_numpy", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "def", "_parent_samples_of", "(", "node", ":", "Any", ",", "scm", ":", "ProbabilisticCausalModel", ",", "samples", ":", "pd", ".", "DataFrame", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "return", "samples", "[", "get_ordered_predecessors", "(", "scm", ".", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasNodes.nodes": [[26, 31], ["None"], "methods", ["None"], ["@", "property", "\n", "@", "abstractmethod", "\n", "def", "nodes", "(", "self", ")", ":", "\n", "        ", "\"\"\":returns Dict[Any, Dict[Any, Any]]\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasEdges.edges": [[36, 41], ["None"], "methods", ["None"], ["@", "property", "\n", "@", "abstractmethod", "\n", "def", "edges", "(", "self", ")", ":", "\n", "        ", "\"\"\":returns a Dict[Tuple[Any, Any], Dict[Any, Any]]\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.DirectedGraph.predecessors": [[51, 54], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "predecessors", "(", "self", ",", "node", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.StochasticModel.fit": [[59, 63], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"Fits the model according to the data.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.StochasticModel.draw_samples": [[64, 68], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "draw_samples", "(", "self", ",", "num_samples", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Draws samples for the fitted model.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.StochasticModel.clone": [[69, 72], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "clone", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.ConditionalStochasticModel.fit": [[78, 82], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"Fits the model according to the data.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.ConditionalStochasticModel.draw_samples": [[83, 87], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "draw_samples", "(", "self", ",", "parent_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Draws samples for the fitted model.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.ConditionalStochasticModel.clone": [[88, 91], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "clone", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.FunctionalCausalModel.draw_samples": [[99, 101], ["graph.FunctionalCausalModel.evaluate", "graph.FunctionalCausalModel.draw_noise_samples"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.draw_noise_samples"], ["def", "draw_samples", "(", "self", ",", "parent_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "evaluate", "(", "parent_samples", ",", "self", ".", "draw_noise_samples", "(", "parent_samples", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.FunctionalCausalModel.draw_noise_samples": [[102, 105], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "draw_noise_samples", "(", "self", ",", "num_samples", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.FunctionalCausalModel.evaluate": [[106, 109], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "evaluate", "(", "self", ",", "parent_samples", ":", "np", ".", "ndarray", ",", "noise_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.InvertibleFunctionalCausalModel.estimate_noise": [[112, 115], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "estimate_noise", "(", "self", ",", "target_samples", ":", "np", ".", "ndarray", ",", "parent_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node": [[117, 119], ["list", "causal_graph.predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.DirectedGraph.predecessors"], ["", "", "def", "is_root_node", "(", "causal_graph", ":", "DirectedGraph", ",", "node", ":", "Any", ")", "->", "bool", ":", "\n", "    ", "return", "list", "(", "causal_graph", ".", "predecessors", "(", "node", ")", ")", "==", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors": [[121, 128], ["sorted", "causal_graph.predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.DirectedGraph.predecessors"], ["", "def", "get_ordered_predecessors", "(", "causal_graph", ":", "DirectedGraph", ",", "node", ":", "Any", ")", "->", "List", "[", "Any", "]", ":", "\n", "    ", "\"\"\"This function returns predecessors of a node in a well-defined order.\n\n    This is necessary, because we select subsets of columns in Dataframes by using a node's parents, and these parents\n    might not be returned in a reliable order.\n    \"\"\"", "\n", "return", "sorted", "(", "causal_graph", ".", "predecessors", "(", "node", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view": [[130, 135], ["networkx.induced_subgraph", "networkx.has_path"], "function", ["None"], ["", "def", "node_connected_subgraph_view", "(", "g", ":", "DirectedGraph", ",", "node", ":", "Any", ")", "->", "Any", ":", "\n", "    ", "\"\"\"Returns a view of the provided graph g that contains only nodes connected to the node passed in\"\"\"", "\n", "# can't use nx.node_connected_component, because it doesn't work with DiGraphs.", "\n", "# Hence a manual loop:", "\n", "return", "nx", ".", "induced_subgraph", "(", "g", ",", "[", "n", "for", "n", "in", "g", ".", "nodes", "if", "nx", ".", "has_path", "(", "g", ",", "n", ",", "node", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.clone_causal_models": [[137, 141], ["[].clone"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone"], ["", "def", "clone_causal_models", "(", "source", ":", "HasNodes", ",", "destination", ":", "HasNodes", ")", ":", "\n", "    ", "for", "node", "in", "destination", ".", "nodes", ":", "\n", "        ", "if", "CAUSAL_MECHANISM", "in", "source", ".", "nodes", "[", "node", "]", ":", "\n", "            ", "destination", ".", "nodes", "[", "node", "]", "[", "CAUSAL_MECHANISM", "]", "=", "source", ".", "nodes", "[", "node", "]", "[", "CAUSAL_MECHANISM", "]", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_acyclic": [[143, 146], ["networkx.algorithms.dag.has_cycle", "RuntimeError"], "function", ["None"], ["", "", "", "def", "validate_acyclic", "(", "causal_graph", ":", "DirectedGraph", ")", "->", "None", ":", "\n", "    ", "if", "has_cycle", "(", "causal_graph", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "'The graph contains a cycle, but an acyclic graph is expected!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag": [[148, 151], ["graph.validate_acyclic", "graph.validate_causal_graph"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_acyclic", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_graph"], ["", "", "def", "validate_causal_dag", "(", "causal_graph", ":", "DirectedGraph", ")", "->", "None", ":", "\n", "    ", "validate_acyclic", "(", "causal_graph", ")", "\n", "validate_causal_graph", "(", "causal_graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_graph": [[153, 156], ["graph.validate_node"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node"], ["", "def", "validate_causal_graph", "(", "causal_graph", ":", "DirectedGraph", ")", "->", "None", ":", "\n", "    ", "for", "node", "in", "causal_graph", ".", "nodes", ":", "\n", "        ", "validate_node", "(", "causal_graph", ",", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node": [[158, 161], ["graph.validate_causal_model_assignment", "graph.validate_local_structure"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_model_assignment", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_local_structure"], ["", "", "def", "validate_node", "(", "causal_graph", ":", "DirectedGraph", ",", "node", ":", "Any", ")", "->", "None", ":", "\n", "    ", "validate_causal_model_assignment", "(", "causal_graph", ",", "node", ")", "\n", "validate_local_structure", "(", "causal_graph", ",", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_model_assignment": [[163, 175], ["graph.validate_node_has_causal_model", "graph.is_root_node", "isinstance", "RuntimeError", "isinstance", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node_has_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node"], ["", "def", "validate_causal_model_assignment", "(", "causal_graph", ":", "DirectedGraph", ",", "target_node", ":", "Any", ")", "->", "None", ":", "\n", "    ", "validate_node_has_causal_model", "(", "causal_graph", ",", "target_node", ")", "\n", "\n", "causal_model", "=", "causal_graph", ".", "nodes", "[", "target_node", "]", "[", "CAUSAL_MECHANISM", "]", "\n", "\n", "if", "is_root_node", "(", "causal_graph", ",", "target_node", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "causal_model", ",", "StochasticModel", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'Node %s is a root node and, thus, requires a StochasticModel, '", "\n", "'but a %s was found!'", "%", "(", "target_node", ",", "causal_model", ")", ")", "\n", "", "", "elif", "not", "isinstance", "(", "causal_model", ",", "ConditionalStochasticModel", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "'Node %s has parents and, thus, requires a ConditionalStochasticModel, '", "\n", "'but a %s was found!'", "%", "(", "target_node", ",", "causal_model", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_local_structure": [[177, 184], ["RuntimeError", "graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "", "def", "validate_local_structure", "(", "causal_graph", ":", "DirectedGraph", ",", "node", ":", "Any", ")", "->", "None", ":", "\n", "    ", "if", "PARENTS_DURING_FIT", "not", "in", "causal_graph", ".", "nodes", "[", "node", "]", "or", "causal_graph", ".", "nodes", "[", "node", "]", "[", "PARENTS_DURING_FIT", "]", "!=", "get_ordered_predecessors", "(", "causal_graph", ",", "node", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "'The causal mechanism of node %s is not fitted to the graphical structure! Fit all'", "\n", "'causal models in the graph first. If the mechanism is already fitted based on the causal'", "\n", "'parents, consider to update the persisted parents for that node manually.'", "%", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node_has_causal_model": [[186, 191], ["graph.validate_node_in_graph", "ValueError"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node_in_graph"], ["", "", "def", "validate_node_has_causal_model", "(", "causal_graph", ":", "HasNodes", ",", "node", ":", "Any", ")", "->", "None", ":", "\n", "    ", "validate_node_in_graph", "(", "causal_graph", ",", "node", ")", "\n", "\n", "if", "CAUSAL_MECHANISM", "not", "in", "causal_graph", ".", "nodes", "[", "node", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"Node %s has no assigned causal mechanism!\"", "%", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node_in_graph": [[193, 196], ["ValueError"], "function", ["None"], ["", "", "def", "validate_node_in_graph", "(", "causal_graph", ":", "HasNodes", ",", "node", ":", "Any", ")", "->", "None", ":", "\n", "    ", "if", "node", "not", "in", "causal_graph", ".", "nodes", ":", "\n", "        ", "raise", "ValueError", "(", "\"Node %s can not be found in the given graph!\"", "%", "node", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MedianCDFQuantileScorer.__init__": [[41, 43], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_distribution_samples", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MedianCDFQuantileScorer.fit": [[44, 49], ["X.reshape", "ValueError"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "if", "(", "X", ".", "ndim", "==", "2", "and", "X", ".", "shape", "[", "1", "]", ">", "1", ")", "or", "X", ".", "ndim", ">", "2", ":", "\n", "            ", "raise", "ValueError", "(", "'The MedianCDFQuantileScorer currently only supports one-dimensional data!'", ")", "\n", "\n", "", "self", ".", "_distribution_samples", "=", "X", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MedianCDFQuantileScorer.score": [[50, 62], ["dowhy.gcm.util.general.shape_into_2d", "numpy.sum", "ValueError", "numpy.sum", "numpy.sum", "numpy.amin", "numpy.vstack"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "score", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "_distribution_samples", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Scorer has not been fitted!\"", ")", "\n", "\n", "", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "equal_samples", "=", "np", ".", "sum", "(", "X", "==", "self", ".", "_distribution_samples", ",", "axis", "=", "1", ")", "\n", "greater_samples", "=", "np", ".", "sum", "(", "X", ">", "self", ".", "_distribution_samples", ",", "axis", "=", "1", ")", "+", "equal_samples", "/", "2", "\n", "smaller_samples", "=", "np", ".", "sum", "(", "X", "<", "self", ".", "_distribution_samples", ",", "axis", "=", "1", ")", "+", "equal_samples", "/", "2", "\n", "\n", "return", "1", "-", "2", "*", "np", ".", "amin", "(", "np", ".", "vstack", "(", "[", "greater_samples", ",", "smaller_samples", "]", ")", ",", "axis", "=", "0", ")", "/", "self", ".", "_distribution_samples", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.RescaledMedianCDFQuantileScorer.__init__": [[77, 79], ["anomaly_scorers.MedianCDFQuantileScorer"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_scorer", "=", "MedianCDFQuantileScorer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.RescaledMedianCDFQuantileScorer.fit": [[80, 82], ["anomaly_scorers.RescaledMedianCDFQuantileScorer._scorer.fit"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "self", ".", "_scorer", ".", "fit", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.RescaledMedianCDFQuantileScorer.score": [[83, 88], ["anomaly_scorers.RescaledMedianCDFQuantileScorer._scorer.score", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["", "def", "score", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "scores", "=", "1", "-", "self", ".", "_scorer", ".", "score", "(", "X", ")", "\n", "scores", "[", "scores", "==", "0", "]", "=", "EPS", "\n", "\n", "return", "-", "np", ".", "log", "(", "scores", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.ITAnomalyScorer.__init__": [[111, 115], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "anomaly_scorer", ":", "AnomalyScorer", ")", ":", "\n", "        ", "self", ".", "_anomaly_scorer", "=", "anomaly_scorer", "\n", "self", ".", "_distribution_samples", "=", "None", "\n", "self", ".", "_scores_of_distribution_samples", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.ITAnomalyScorer.fit": [[116, 120], ["dowhy.gcm.util.general.shape_into_2d", "anomaly_scorers.ITAnomalyScorer._anomaly_scorer.fit", "anomaly_scorers.ITAnomalyScorer._anomaly_scorer.score().reshape", "anomaly_scorers.ITAnomalyScorer._anomaly_scorer.score"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "self", ".", "_distribution_samples", "=", "shape_into_2d", "(", "X", ")", "\n", "self", ".", "_anomaly_scorer", ".", "fit", "(", "self", ".", "_distribution_samples", ")", "\n", "self", ".", "_scores_of_distribution_samples", "=", "self", ".", "_anomaly_scorer", ".", "score", "(", "self", ".", "_distribution_samples", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.ITAnomalyScorer.score": [[121, 126], ["dowhy.gcm.util.general.shape_into_2d", "anomaly_scorers.ITAnomalyScorer._anomaly_scorer.score().reshape", "numpy.log", "anomaly_scorers.ITAnomalyScorer._anomaly_scorer.score", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["", "def", "score", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "scores_of_samples_to_score", "=", "self", ".", "_anomaly_scorer", ".", "score", "(", "X", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "return", "-", "np", ".", "log", "(", "(", "np", ".", "sum", "(", "self", ".", "_scores_of_distribution_samples", ">=", "scores_of_samples_to_score", ",", "axis", "=", "1", ")", "+", "0.5", ")", "\n", "/", "(", "self", ".", "_scores_of_distribution_samples", ".", "shape", "[", "0", "]", "+", "0.5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MeanDeviationScorer.__init__": [[138, 141], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_mean", "=", "None", "\n", "self", ".", "_std", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MeanDeviationScorer.fit": [[142, 145], ["numpy.mean", "numpy.std"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "self", ".", "_mean", "=", "np", ".", "mean", "(", "X", ")", "\n", "self", ".", "_std", "=", "np", ".", "std", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MeanDeviationScorer.score": [[146, 151], ["ValueError", "abs"], "methods", ["None"], ["", "def", "score", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "_mean", "is", "None", "or", "self", ".", "_std", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Scorer has not been fitted!\"", ")", "\n", "\n", "", "return", "abs", "(", "X", "-", "self", ".", "_mean", ")", "/", "self", ".", "_std", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MedianDeviationScorer.__init__": [[163, 166], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_median", "=", "None", "\n", "self", ".", "_mad", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MedianDeviationScorer.fit": [[167, 170], ["numpy.median", "statsmodels.robust.mad"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "self", ".", "_median", "=", "np", ".", "median", "(", "X", ")", "\n", "self", ".", "_mad", "=", "mad", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.MedianDeviationScorer.score": [[171, 176], ["ValueError", "abs"], "methods", ["None"], ["", "def", "score", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "_median", "is", "None", "or", "self", ".", "_mad", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Scorer has not been fitted!\"", ")", "\n", "\n", "", "return", "abs", "(", "X", "-", "self", ".", "_median", ")", "/", "self", ".", "_mad", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.InverseDensityScorer.__init__": [[188, 194], ["GaussianMixtureDensityEstimator"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "density_estimator", ":", "Optional", "[", "DensityEstimator", "]", "=", "None", ")", ":", "\n", "        ", "if", "density_estimator", "is", "None", ":", "\n", "            ", "from", "dowhy", ".", "gcm", ".", "density_estimators", "import", "GaussianMixtureDensityEstimator", "\n", "density_estimator", "=", "GaussianMixtureDensityEstimator", "(", ")", "\n", "", "self", ".", "_density_estimator", "=", "density_estimator", "\n", "self", ".", "_fitted", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.InverseDensityScorer.fit": [[195, 198], ["anomaly_scorers.InverseDensityScorer._density_estimator.fit"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "self", ".", "_density_estimator", ".", "fit", "(", "X", ")", "\n", "self", ".", "_fitted", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorers.InverseDensityScorer.score": [[199, 204], ["ValueError", "anomaly_scorers.InverseDensityScorer._density_estimator.density"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimator.DensityEstimator.density"], ["", "def", "score", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "not", "self", ".", "_fitted", ":", "\n", "            ", "raise", "ValueError", "(", "\"Scorer has not been fitted!\"", ")", "\n", "\n", "", "return", "1", "/", "self", ".", "_density_estimator", ".", "density", "(", "X", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.parent_relevance": [[22, 107], ["dowhy.gcm.graph.validate_node", "dowhy.gcm.graph.is_root_node", "dowhy.gcm.graph.get_ordered_predecessors", "dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.shape_into_2d", "numpy.column_stack", "feature.feature_relevance_distribution", "ValueError", "isinstance", "parent_samples[].to_numpy", "causal_model.causal_mechanism().draw_noise_samples", "causal_model.causal_mechanism().evaluate", "dowhy.gcm.fitting_sampling.draw_samples", "causal_model.causal_mechanism", "dowhy.gcm.util.general.shape_into_2d.astype", "dowhy.gcm.util.general.shape_into_2d.astype", "enumerate", "max", "causal_model.causal_mechanism", "causal_model.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_distribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.draw_noise_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["def", "parent_relevance", "(", "causal_model", ":", "StructuralCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "parent_samples", ":", "Optional", "[", "pd", ".", "DataFrame", "]", "=", "None", ",", "\n", "subset_scoring_func", ":", "\n", "Optional", "[", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", "]", "=", "None", ",", "\n", "num_samples_randomization", ":", "int", "=", "5000", ",", "\n", "num_samples_baseline", ":", "int", "=", "500", ",", "\n", "max_batch_size", ":", "int", "=", "100", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ")", "->", "Tuple", "[", "Dict", "[", "Any", ",", "Any", "]", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"Estimates the distribution based relevance of the direct parents of the given target_node. This is, the \n    relevance of direct parents as input features of the the underlying causal model of target_node. Here, the \n    unobserved noise is considered as a direct parent (input) as well. Samples utilized for the estimation are drawn \n    from the given causal graph.\n    \n    By default, the used subset_scoring_func is based on the variance between Y and Y', where Y is the outputs of\n    the causal model and Y' the outputs of the models when certain features are randomized. In case of continuous data,\n    the feature relevance adds up to Var(Y - Y').\n    \n    Note: The feature relevance based on the distribution cannot be directly compared with the feature relevance for \n    single samples. If this is desired, the set function needs to be defined accordingly.\n    \n    Related paper:\n    Janzing, D., Minorics, L., & Bloebaum, P. (2020). \n    Feature relevance quantification in explainable AI: A causal problem. \n    In International Conference on Artificial Intelligence and Statistics (pp. 2907-2916). PMLR.\n    \n    :param causal_model: The fitted structural causal model.\n    :param target_node: Node with the causal model of interest.\n    :param parent_samples: Samples for the parents of the given target_node. If None is given, new samples are\n                           generated based on the graph. These samples are used for randomizing features that are not in the subset.\n    :param subset_scoring_func: Set function for estimating the quantity of interest based on the model outcomes. This function\n                                expects two inputs; the outcome of the causal model for some samples if certain features are permuted and the \n                                outcome of the model for the same samples when no features were permuted. The set functions represents the \n                                comparison between the samples, for instance, the variance of deviations. This is then used as the 'characteristic function'\n                                in coalition games when estimating the Shapley values.\n    :param num_samples_randomization: Number of samples used as background parent samples for evaluating the set function.\n                                      If no parent_samples are given, this represents the number of generated samples from\n                                      the joint distribution of the parents and are used for randomizing features that are \n                                      not in the subset. Consider increasing this number for more accurate results or reducing it for less memory consumption and faster runtime.\n    :param num_samples_baseline: Number of samples on which the set functions are evaluated on. These samples are used as fixed observations for\n                                 parents that are in the subset. Consider increasing this number for more accurate results or reducing it for less memory consumption and faster runtime.\n    :param max_batch_size: Maximum batch size for estimating multiple predictions at once. This has a significant influence on the\n                          overall memory usage. If set to -1, all samples are used in one batch.\n    :param shapley_config: :class:`~dowhy.gcm.shapley.ShapleyConfig` for the Shapley estimator.\n    :return: There are two return vales. A dictionary with the feature relevance for each direct parent of the given \n             target_node and the feature relevance of noise.\n    \"\"\"", "\n", "validate_node", "(", "causal_model", ".", "graph", ",", "target_node", ")", "\n", "\n", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "target_node", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Cannot compute feature relevance of parents for the target node %s as it is a root node.\"", "\n", "\"It does not have parents.\"", "%", "target_node", ")", "\n", "\n", "", "ordered_predecessors", "=", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "target_node", ")", "\n", "\n", "if", "parent_samples", "is", "None", ":", "\n", "        ", "parent_samples", "=", "draw_samples", "(", "causal_model", ",", "max", "(", "num_samples_randomization", ",", "num_samples_baseline", ")", ")", "[", "ordered_predecessors", "]", "\n", "\n", "", "if", "subset_scoring_func", "is", "None", ":", "\n", "        ", "if", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "target_node", ")", ",", "ProbabilityEstimatorModel", ")", ":", "\n", "            ", "subset_scoring_func", "=", "variance_of_matching_values", "\n", "", "else", ":", "\n", "            ", "subset_scoring_func", "=", "variance_of_deviations", "\n", "\n", "", "", "parent_samples", "=", "shape_into_2d", "(", "parent_samples", "[", "ordered_predecessors", "]", ".", "to_numpy", "(", ")", ")", "\n", "noise_samples", "=", "shape_into_2d", "(", "\n", "causal_model", ".", "causal_mechanism", "(", "target_node", ")", ".", "draw_noise_samples", "(", "parent_samples", ".", "shape", "[", "0", "]", ")", ")", "\n", "samples_features", "=", "np", ".", "column_stack", "(", "[", "parent_samples", ".", "astype", "(", "object", ")", ",", "noise_samples", ".", "astype", "(", "object", ")", "]", ")", "\n", "\n", "def", "model", "(", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "causal_model", ".", "causal_mechanism", "(", "target_node", ")", ".", "evaluate", "(", "X", "[", ":", ",", ":", "-", "noise_samples", ".", "shape", "[", "1", "]", "]", ",", "\n", "X", "[", ":", ",", "-", "noise_samples", ".", "shape", "[", "1", "]", ":", "]", ")", "\n", "\n", "", "shapley_vales", "=", "feature_relevance_distribution", "(", "model", ",", "\n", "feature_samples", "=", "samples_features", ",", "\n", "subset_scoring_func", "=", "subset_scoring_func", ",", "\n", "max_num_samples_randomization", "=", "num_samples_randomization", ",", "\n", "max_num_baseline_samples", "=", "num_samples_baseline", ",", "\n", "max_batch_size", "=", "max_batch_size", ",", "\n", "shapley_config", "=", "shapley_config", ")", "\n", "\n", "result", "=", "{", "(", "predecessor", ",", "target_node", ")", ":", "shapley_vales", "[", "i", "]", "for", "i", ",", "predecessor", "in", "enumerate", "(", "ordered_predecessors", ")", "}", "\n", "\n", "return", "result", ",", "shapley_vales", "[", "-", "noise_samples", ".", "shape", "[", "1", "]", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_distribution": [[109, 179], ["dowhy.gcm.util.general.shape_into_2d", "feature.feature_relevance_sample", "dowhy.gcm.shapley.ShapleyConfig", "numpy.random.choice", "numpy.random.choice", "min", "min"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_sample"], ["", "def", "feature_relevance_distribution", "(", "prediction_method", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "feature_samples", ":", "np", ".", "ndarray", ",", "\n", "subset_scoring_func", ":", "\n", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", ",", "\n", "max_num_samples_randomization", ":", "int", "=", "5000", ",", "\n", "max_num_baseline_samples", ":", "int", "=", "500", ",", "\n", "max_batch_size", ":", "int", "=", "100", ",", "\n", "randomize_features_jointly", ":", "bool", "=", "True", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Estimates the population based feature relevance of the input features for the given prediction_method. This\n    method uses all samples given in feature_samples by comparing the output of the prediction_method given certain\n    features are randomized with the outputs when no features are randomized. The subset_scoring_func defines\n    how these predictions are compared. For instance, the variance of deviations.\n    \n    If the randomized predictions should rather be compared to the original data, this has (and can) be defined via\n    the set function by ignoring the second input parameter (the predicted values using all feauters). Instead, the\n    original data can be used.\n    \n    Note: The distribution level relevance is estimated by taking the expectation of the outcome of the set functions\n    when applied to multiple samples. Due to the linearity of the Shapley value estimation, this is equivalent to taking\n    the expectation over the Shapley values.\n\n    Related paper:\n    Janzing, D., Minorics, L., & Bloebaum, P. (2020).\n    Feature relevance quantification in explainable AI: A causal problem.\n    In International Conference on Artificial Intelligence and Statistics (pp. 2907-2916). PMLR.\n\n    :param prediction_method: A callable that is expected to return a prediction for given samples.\n    :param feature_samples: Samples from the joint distribution.\n    :param subset_scoring_func: Set function for estimating the quantity of interest based on the model outcomes. This function\n                                expects two inputs; the outcome of the prediction model for some samples if certain features are permuted and the\n                                outcome of the model for the same samples when no features were permuted. The set functions represents the\n                                comparison between the samples, for instance, the variance of deviations. This is then used as the 'characteristic function'\n                                in coalition games when estimating the Shapley values.\n    :param max_num_samples_randomization: Maximum number of samples used for randomizing the feature that are not in the susbet. Consider increasing this \n                                          number for more accurate results (if enough samples are available) or reducing it for less memory consumption and \n                                          faster runtime.\n    :param max_num_baseline_samples: Maximum number of samples on which the set function is evaluated on. These samples are used as fixed observations for\n                                     features that are in the subset. For instance, in case of taking the mean as set_function_summary_func, this defines the maximum number \n                                     of samples used to estimate the mean. Consider increasing this number for more accurate results (if enough samples are \n                                     available) or reducing it for less memory consumption and faster runtime.\n    :param max_batch_size: Maximum batch size for a estimating the predictions. This has a significant influence on the\n                           overall memory usage. If set to -1, all samples are used in one batch.\n    :param randomize_features_jointly: If set to True, features that are not in a subset are jointly permuted. \n                                       Note that this still represents an interventional distribution. If set to False, features that are not in a subset \n                                       are independently permuted. Note: The theory in the linked publication assumes that this is set to True.\n    :param shapley_config: Config for the Shapley estimator.\n    :return: A numpy array with the feature relevance of each input feature.\n    \"\"\"", "\n", "feature_samples", "=", "shape_into_2d", "(", "feature_samples", ")", "\n", "\n", "if", "shapley_config", "is", "None", ":", "\n", "        ", "shapley_config", "=", "ShapleyConfig", "(", ")", "\n", "\n", "", "baseline_samples", "=", "feature_samples", "[", "np", ".", "random", ".", "choice", "(", "feature_samples", ".", "shape", "[", "0", "]", ",", "\n", "min", "(", "max_num_baseline_samples", ",", "feature_samples", ".", "shape", "[", "0", "]", ")", ",", "\n", "replace", "=", "False", ")", "]", "\n", "feature_samples", "=", "feature_samples", "[", "np", ".", "random", ".", "choice", "(", "feature_samples", ".", "shape", "[", "0", "]", ",", "\n", "min", "(", "max_num_samples_randomization", ",", "feature_samples", ".", "shape", "[", "0", "]", ")", ",", "\n", "replace", "=", "False", ")", "]", "\n", "\n", "return", "feature_relevance_sample", "(", "prediction_method", ",", "\n", "feature_samples", ",", "\n", "baseline_samples", ",", "\n", "subset_scoring_func", ",", "\n", "None", ",", "\n", "True", ",", "\n", "max_batch_size", ",", "\n", "randomize_features_jointly", ",", "\n", "shapley_config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_sample": [[181, 259], ["dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.shapley.estimate_shapley_values", "prediction_method", "dowhy.gcm.shapley.ShapleyConfig", "numpy.zeros", "dowhy.gcm.stats.marginal_expectation", "range", "ValueError", "subset_scoring_func", "numpy.mean", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation"], ["", "def", "feature_relevance_sample", "(", "prediction_method", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "feature_samples", ":", "np", ".", "ndarray", ",", "\n", "baseline_samples", ":", "np", ".", "ndarray", ",", "\n", "subset_scoring_func", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "\n", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", ",", "\n", "baseline_target_values", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "average_set_function", ":", "bool", "=", "False", ",", "\n", "max_batch_size", ":", "int", "=", "100", ",", "\n", "randomize_features_jointly", ":", "bool", "=", "True", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Estimates the feature relevance of the prediction_method for each sample in baseline_noise_samples. This\n    method uses all samples given in feature_samples as 'background' samples. This is, they should represent samples\n    from the joint distribution of the input features. The subset_scoring_func defines the comparison between the\n    output of the prediction_method when certain features are randomized and the outputs when no features are\n    randomized. The most common function would be the difference between the expectations.\n\n    If the randomized predictions should rather be compared to the original data, this has (and can) be defined via\n    the set function by ignoring the second input parameter (the predicted values using all feauters). Instead, the\n    original data can be used.\n\n    Related paper:\n    Janzing, D., Minorics, L., & Bloebaum, P. (2020).\n    Feature relevance quantification in explainable AI: A causal problem.\n    In International Conference on Artificial Intelligence and Statistics (pp. 2907-2916). PMLR.\n\n    :param prediction_method: A callable that is expected to return a prediction for given samples.\n    :param feature_samples: Samples from the joint distribution. These are used as 'background samples' to randomize features that are not in a subset.\n    :param baseline_samples: Samples for which the feature relevance should be estimated.\n    :param subset_scoring_func: Set function for estimating the quantity of interest based on the model outcomes. This function\n                                expects two inputs; the outcome of the prediction model for some samples if certain features are permuted and the\n                                outcome of the model for the same samples when no features were permuted. A typical choice for regression models\n                                would be the difference between expectations. This is then used as the 'characteristic function'\n                                in coalition games when estimating the Shapley values.\n    :param baseline_target_values: These baseline values are compared with the subset specific outcomes of the prediction method. If set to None (default),\n                                   the baseline values are the outcomes of the given prediction_method applied to the baseline_noise_samples, i.e. the outcome of the empty subset.\n    :param max_batch_size: Maximum batch size for a estimating the predictions. This has a significant influence on the\n                           overall memory usage. If set to -1, all samples are used in one batch.\n    :param average_set_function: If set to True, the averaged result of the set function applied to each sample of\n                                 interest is used for estimating the Shapley values. If set to False, Shapley values for each sample of interest\n                                 are estimated separately.\n    :param randomize_features_jointly: If set to True, features that are not in a subset are jointly permuted.\n                                       Note that this still represents an interventional distribution. If set to False, features that are not in a subset\n                                       are independently permuted. Note: The theory in the linked publication assumes that this is set to True.\n    :param shapley_config: Config for the Shapley estimator.\n    :return: A numpy array with the feature relevance for each sample in baseline_noise_samples.\n    \"\"\"", "\n", "feature_samples", "=", "shape_into_2d", "(", "feature_samples", ")", "\n", "if", "baseline_target_values", "is", "None", ":", "\n", "        ", "baseline_target_values", "=", "prediction_method", "(", "baseline_samples", ")", "\n", "", "else", ":", "\n", "        ", "if", "baseline_samples", ".", "shape", "[", "0", "]", "!=", "baseline_target_values", ".", "shape", "[", "0", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Samples of interest and the given baseline values need to have the same sample size! \"", "\n", "\"Make sure that the given baseline values correspond to the samples of interest.\"", ")", "\n", "\n", "", "", "if", "shapley_config", "is", "None", ":", "\n", "        ", "shapley_config", "=", "ShapleyConfig", "(", ")", "\n", "\n", "", "def", "single_sample_set_function", "(", "subset", ":", "np", ".", "ndarray", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "float", "]", ":", "\n", "        ", "results", "=", "np", ".", "zeros", "(", "baseline_target_values", ".", "shape", "[", "0", "]", ")", "\n", "predictions", "=", "marginal_expectation", "(", "prediction_method", ",", "\n", "feature_samples", "=", "feature_samples", ",", "\n", "baseline_samples", "=", "baseline_samples", ",", "\n", "baseline_feature_indices", "=", "\n", "np", ".", "arange", "(", "0", ",", "feature_samples", ".", "shape", "[", "1", "]", ")", "[", "subset", "==", "1", "]", ",", "\n", "return_averaged_results", "=", "False", ",", "\n", "feature_perturbation", "=", "'randomize_columns_jointly'", "\n", "if", "randomize_features_jointly", "else", "'randomize_columns_independently'", ",", "\n", "max_batch_size", "=", "max_batch_size", ")", "\n", "\n", "for", "i", "in", "range", "(", "baseline_target_values", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "results", "[", "i", "]", "=", "subset_scoring_func", "(", "predictions", "[", "i", "]", ",", "baseline_target_values", "[", "i", "]", ")", "\n", "\n", "", "if", "average_set_function", ":", "\n", "            ", "return", "np", ".", "mean", "(", "results", ")", "\n", "", "else", ":", "\n", "            ", "return", "results", "\n", "\n", "", "", "return", "estimate_shapley_values", "(", "single_sample_set_function", ",", "feature_samples", ".", "shape", "[", "1", "]", ",", "shapley_config", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PredictionModel.fit": [[21, 24], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PredictionModel.predict": [[25, 28], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PredictionModel.clone": [[29, 37], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "clone", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Clones the prediction model using the same hyper parameters but not fitted.\n\n        :return: An unfitted clone of the prediction model.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassificationModel.predict_probabilities": [[41, 44], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "predict_probabilities", "(", "self", ",", "X", ":", "np", ".", "array", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassificationModel.classes": [[45, 49], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "classes", "(", "self", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.InvertibleFunction.evaluate": [[53, 57], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "evaluate", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\" Applies the function on the input. \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.InvertibleFunction.evaluate_inverse": [[58, 62], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "evaluate_inverse", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\" Returns the outcome of applying the inverse of the function on the inputs. \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.__init__": [[72, 84], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "prediction_model", ":", "PredictionModel", ",", "\n", "noise_model", ":", "StochasticModel", ",", "\n", "invertible_function", ":", "InvertibleFunction", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param prediction_model: The prediction model f.\n        :param invertible_function: The invertible function g.\n        :param noise_model: The StochasticModel to describe the distribution of the noise N.\n        \"\"\"", "\n", "self", ".", "_prediction_model", "=", "prediction_model", "\n", "self", ".", "_noise_model", "=", "noise_model", "\n", "self", ".", "_invertible_function", "=", "invertible_function", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.fit": [[85, 103], ["dowhy.gcm.util.general.shape_into_2d", "fcms.PostNonlinearModel._prediction_model.fit", "fcms.PostNonlinearModel._noise_model.fit", "fcms.PostNonlinearModel._invertible_function.evaluate_inverse", "fcms.PostNonlinearModel.estimate_noise"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate_inverse", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.estimate_noise"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"Fits the post non-linear model of the form Y = g(f(X) + N). Here, this consists of three steps given\n        samples from (X, Y):\n\n            1. Transform Y via the inverse of g: g^-1(Y) = f(X) + N\n            2. Fit the model for f on (X, g^-1(Y))\n            3. Reconstruct N based on the residual N = g^-1(Y) - f(X)\n\n        Note that the noise here can be inferred uniquely if the model assumption holds.\n\n        :param X: Samples from the input X.\n        :param Y: Samples from the target Y.\n        :return: None\n        \"\"\"", "\n", "X", ",", "Y", "=", "shape_into_2d", "(", "X", ",", "Y", ")", "\n", "\n", "self", ".", "_prediction_model", ".", "fit", "(", "X", "=", "X", ",", "Y", "=", "self", ".", "_invertible_function", ".", "evaluate_inverse", "(", "Y", ")", ")", "\n", "self", ".", "_noise_model", ".", "fit", "(", "X", "=", "self", ".", "estimate_noise", "(", "Y", ",", "X", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.estimate_noise": [[104, 120], ["dowhy.gcm.util.general.shape_into_2d", "fcms.PostNonlinearModel._invertible_function.evaluate_inverse", "fcms.PostNonlinearModel._prediction_model.predict"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate_inverse", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "def", "estimate_noise", "(", "self", ",", "\n", "target_samples", ":", "np", ".", "ndarray", ",", "\n", "parent_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Reconstruct the noise given samples from (X, Y). This is done by:\n\n            1. Transform Y via the inverse of g: g^-1(Y) = f(X) + N\n            2. Return the residual g^-1(Y) - f(X)\n\n        :param target_samples: Samples from the input X.\n        :param parent_samples: Samples from the target Y.\n        :return: The reconstructed noise based on the given samples.\n        \"\"\"", "\n", "target_samples", ",", "parent_samples", "=", "shape_into_2d", "(", "target_samples", ",", "parent_samples", ")", "\n", "\n", "return", "self", ".", "_invertible_function", ".", "evaluate_inverse", "(", "target_samples", ")", "-", "self", ".", "_prediction_model", ".", "predict", "(", "\n", "parent_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.draw_noise_samples": [[121, 128], ["fcms.PostNonlinearModel._noise_model.draw_samples"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["", "def", "draw_noise_samples", "(", "self", ",", "num_samples", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Draws samples from the noise distribution N.\n\n        :param num_samples: Number of noise samples.\n        :return: A numpy array containing num_samples samples from the noise.\n        \"\"\"", "\n", "return", "self", ".", "_noise_model", ".", "draw_samples", "(", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.evaluate": [[129, 144], ["dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.shape_into_2d", "fcms.PostNonlinearModel._invertible_function.evaluate", "fcms.PostNonlinearModel._prediction_model.predict"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "def", "evaluate", "(", "self", ",", "parent_samples", ":", "np", ".", "ndarray", ",", "noise_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Evaluates the post non-linear model given samples (X, N). This is done by:\n\n            1. Evaluate f(X)\n            2. Evaluate f(X) + N\n            3. Return g(f(X) + N)\n\n        :param parent_samples: Samples from the inputs X.\n        :param noise_samples: Samples from the noise N.\n        :return: The Y values based on the given samples.\n        \"\"\"", "\n", "parent_samples", ",", "noise_samples", "=", "shape_into_2d", "(", "parent_samples", ",", "noise_samples", ")", "\n", "predictions", "=", "shape_into_2d", "(", "self", ".", "_prediction_model", ".", "predict", "(", "parent_samples", ")", ")", "\n", "\n", "return", "self", ".", "_invertible_function", ".", "evaluate", "(", "predictions", "+", "noise_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.__str__": [[145, 149], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "'%s with %s and an %s'", "%", "(", "self", ".", "__class__", ".", "__name__", ",", "\n", "self", ".", "_prediction_model", ".", "__class__", ".", "__name__", ",", "\n", "self", ".", "_invertible_function", ".", "__class__", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.clone": [[150, 154], ["fcms.PostNonlinearModel", "fcms.PostNonlinearModel._prediction_model.clone", "fcms.PostNonlinearModel._noise_model.clone", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "return", "PostNonlinearModel", "(", "prediction_model", "=", "self", ".", "_prediction_model", ".", "clone", "(", ")", ",", "\n", "noise_model", "=", "self", ".", "_noise_model", ".", "clone", "(", ")", ",", "\n", "invertible_function", "=", "copy", ".", "deepcopy", "(", "self", ".", "_invertible_function", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.prediction_model": [[155, 158], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "prediction_model", "(", "self", ")", "->", "PredictionModel", ":", "\n", "        ", "return", "self", ".", "_prediction_model", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.noise_model": [[159, 162], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "noise_model", "(", "self", ")", "->", "StochasticModel", ":", "\n", "        ", "return", "self", ".", "_noise_model", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.invertible_function": [[163, 166], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "invertible_function", "(", "self", ")", "->", "InvertibleFunction", ":", "\n", "        ", "return", "self", ".", "_invertible_function", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.AdditiveNoiseModel.__init__": [[179, 190], ["fcms.PostNonlinearModel.__init__", "EmpiricalDistribution", "InvertibleIdentityFunction"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "\n", "prediction_model", ":", "PredictionModel", ",", "\n", "noise_model", ":", "Optional", "[", "StochasticModel", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "if", "noise_model", "is", "None", ":", "\n", "            ", "from", "dowhy", ".", "gcm", ".", "stochastic_models", "import", "EmpiricalDistribution", "\n", "noise_model", "=", "EmpiricalDistribution", "(", ")", "\n", "\n", "", "from", "dowhy", ".", "gcm", ".", "ml", ".", "regression", "import", "InvertibleIdentityFunction", "\n", "super", "(", "AdditiveNoiseModel", ",", "self", ")", ".", "__init__", "(", "prediction_model", "=", "prediction_model", ",", "\n", "noise_model", "=", "noise_model", ",", "\n", "invertible_function", "=", "InvertibleIdentityFunction", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.AdditiveNoiseModel.clone": [[191, 194], ["fcms.AdditiveNoiseModel", "fcms.AdditiveNoiseModel.prediction_model.clone", "fcms.AdditiveNoiseModel.noise_model.clone"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "return", "AdditiveNoiseModel", "(", "prediction_model", "=", "self", ".", "prediction_model", ".", "clone", "(", ")", ",", "\n", "noise_model", "=", "self", ".", "noise_model", ".", "clone", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ProbabilityEstimatorModel.estimate_probabilities": [[197, 200], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "estimate_probabilities", "(", "self", ",", "parent_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.__init__": [[212, 218], ["create_hist_gradient_boost_classifier"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier"], ["def", "__init__", "(", "self", ",", "classifier_model", ":", "Optional", "[", "ClassificationModel", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "self", ".", "_classifier_model", "=", "classifier_model", "\n", "\n", "if", "classifier_model", "is", "None", ":", "\n", "            ", "from", "dowhy", ".", "gcm", ".", "ml", ".", "classification", "import", "create_hist_gradient_boost_classifier", "\n", "self", ".", "_classifier_model", "=", "create_hist_gradient_boost_classifier", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.draw_noise_samples": [[219, 226], ["dowhy.gcm.util.general.shape_into_2d", "numpy.random.uniform"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "", "def", "draw_noise_samples", "(", "self", ",", "num_samples", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Returns uniformly sampled values on [0, 1].\n\n        :param num_samples: Number of noise samples.\n        :return: Noise samples on [0, 1].\n        \"\"\"", "\n", "return", "shape_into_2d", "(", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "num_samples", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.evaluate": [[227, 244], ["dowhy.gcm.util.general.shape_into_2d", "fcms.ClassifierFCM.estimate_probabilities", "dowhy.gcm.util.general.shape_into_2d", "numpy.cumsum", "numpy.array", "fcms.ClassifierFCM.get_class_names", "numpy.argmin"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.estimate_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.get_class_names"], ["", "def", "evaluate", "(", "self", ",", "parent_samples", ":", "np", ".", "ndarray", ",", "noise_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Evaluates the model Y = f(X, N), where X are the parent_samples and N the noise_samples. Here, the\n        cumulative distribution functions are defined by the parent_samples. For instance, lets say we have 2\n        classes, n = 0.7 and an input x with p(y = 0| x) = 0.6 and p(y = 1| x) = 0.4, then we get y = 1 as a return\n        value. This is because p(y = 0| x) < n <= 1.0, i.e. n falls into the bucket that is spanned by p(y = 1| x).\n\n        :param parent_samples: Samples from the inputs X.\n        :param noise_samples: Samples from the noise on [0, 1].\n        :return: Class labels Y based on the inputs and noise.\n        \"\"\"", "\n", "noise_samples", "=", "shape_into_2d", "(", "noise_samples", ")", "\n", "probabilities", "=", "self", ".", "estimate_probabilities", "(", "parent_samples", ")", "\n", "\n", "probabilities", "=", "np", ".", "cumsum", "(", "probabilities", ",", "axis", "=", "1", ")", "-", "noise_samples", "\n", "probabilities", "[", "probabilities", "<", "0", "]", "=", "1", "\n", "\n", "return", "shape_into_2d", "(", "np", ".", "array", "(", "self", ".", "get_class_names", "(", "np", ".", "argmin", "(", "probabilities", ",", "axis", "=", "1", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.estimate_probabilities": [[245, 254], ["fcms.ClassifierFCM._classifier_model.predict_probabilities"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities"], ["", "def", "estimate_probabilities", "(", "self", ",", "parent_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Returns the class probabilities for the given parent_samples.\n\n        :param parent_samples: Samples from inputs X.\n        :return: A nxd numpy matrix with class probabilities for each sample, where n is the number of samples and d\n                 the number of classes. Here, array entry A[i][j] corresponds to the i-th sample indicating the\n                 probability of the j-th class.\n        \"\"\"", "\n", "return", "self", ".", "_classifier_model", ".", "predict_probabilities", "(", "parent_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.fit": [[255, 268], ["dowhy.gcm.util.general.shape_into_2d", "fcms.ClassifierFCM._classifier_model.fit", "dowhy.gcm.util.general.is_categorical", "ValueError"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"Fits the underlying classification model.\n\n        :param X: Input samples.\n        :param Y: Target labels.\n        :return: None\n        \"\"\"", "\n", "X", ",", "Y", "=", "shape_into_2d", "(", "X", ",", "Y", ")", "\n", "\n", "if", "not", "is_categorical", "(", "Y", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"The target data needs to be categorical in the form of strings!\"", ")", "\n", "\n", "", "self", ".", "_classifier_model", ".", "fit", "(", "X", "=", "X", ",", "Y", "=", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.clone": [[269, 271], ["fcms.ClassifierFCM", "fcms.ClassifierFCM._classifier_model.clone"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "return", "ClassifierFCM", "(", "classifier_model", "=", "self", ".", "_classifier_model", ".", "clone", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.get_class_names": [[272, 274], ["None"], "methods", ["None"], ["", "def", "get_class_names", "(", "self", ",", "class_indices", ":", "np", ".", "ndarray", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "return", "[", "self", ".", "_classifier_model", ".", "classes", "[", "index", "]", "for", "index", "in", "class_indices", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.classifier_model": [[275, 278], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "classifier_model", "(", "self", ")", "->", "ClassificationModel", ":", "\n", "        ", "return", "self", ".", "_classifier_model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals_cms.bootstrap_training_and_sampling": [[46, 91], ["causal_model.clone", "dowhy.gcm.fitting_sampling.fit", "f", "numpy.random.choice", "int"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["def", "bootstrap_training_and_sampling", "(", "f", ":", "Callable", "[", "[", "Union", "[", "ProbabilisticCausalModel", ",", "\n", "StructuralCausalModel", ",", "\n", "InvertibleStructuralCausalModel", "]", ",", "Any", "]", ",", "\n", "Dict", "[", "Any", ",", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", "]", ",", "\n", "causal_model", ":", "Union", "[", "ProbabilisticCausalModel", ",", "\n", "StructuralCausalModel", ",", "\n", "InvertibleStructuralCausalModel", "]", ",", "\n", "bootstrap_training_data", ":", "pd", ".", "DataFrame", ",", "\n", "bootstrap_data_subset_size_fraction", ":", "float", "=", "0.75", ",", "\n", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"A convenience function when computing confidence intervals specifically for causal queries. This function\n    specifically bootstraps training *and* sampling.\n\n    **Example usage:**\n\n        >>> scores_median, scores_intervals = gcm.confidence_intervals(\n        >>>     gcm.bootstrap_training_and_sampling(gcm.arrow_strength,\n        >>>                                         causal_model,\n        >>>                                         bootstrap_training_data=data,\n        >>>                                         target_node='Y'))\n\n    :param f: The causal query to perform. A causal query is a function taking a graphical causal model as first\n              parameter and an arbitrary number of remaining parameters. It must return a dictionary with\n              attribution-like data.\n    :param causal_model: A graphical causal model to perform the causal query on. It need not be fitted.\n    :param bootstrap_training_data: The training data to use when fitting. A random subset from this data set is used\n                                    in every iteration when calling fit.\n    :param bootstrap_data_subset_size_fraction: The fraction defines the fractional size of the subset compared to\n                                                the total training data.\n    :param args: Args passed through verbatim to the causal queries.\n    :param kwargs: Keyword args passed through verbatim to the causal queries.\n    :return: A tuple containing (1) the median of causal query results and (2) the confidence intervals.\n    \"\"\"", "\n", "\n", "def", "snapshot", "(", ")", ":", "\n", "        ", "causal_model_copy", "=", "causal_model", ".", "clone", "(", ")", "\n", "sampled_data", "=", "bootstrap_training_data", ".", "iloc", "[", "\n", "np", ".", "random", ".", "choice", "(", "bootstrap_training_data", ".", "shape", "[", "0", "]", ",", "\n", "int", "(", "bootstrap_training_data", ".", "shape", "[", "0", "]", "*", "bootstrap_data_subset_size_fraction", ")", ",", "\n", "replace", "=", "False", ")", "\n", "]", "\n", "fit", "(", "causal_model_copy", ",", "sampled_data", ")", "\n", "return", "f", "(", "causal_model_copy", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "snapshot", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator.__init__": [[22, 25], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_components", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "self", ".", "_gmm_model", "=", "None", "\n", "self", ".", "_num_components", "=", "num_components", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator.fit": [[26, 32], ["sklearn.mixture.BayesianGaussianMixture().fit", "int", "dowhy.gcm.util.general.shape_into_2d", "numpy.ceil", "sklearn.mixture.BayesianGaussianMixture", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "if", "self", ".", "_num_components", "is", "None", ":", "\n", "            ", "self", ".", "_num_components", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "sqrt", "(", "X", ".", "shape", "[", "0", "]", "/", "2", ")", ")", ")", "\n", "\n", "", "self", ".", "_gmm_model", "=", "BayesianGaussianMixture", "(", "n_components", "=", "self", ".", "_num_components", ",", "\n", "covariance_type", "=", "'full'", ")", ".", "fit", "(", "shape_into_2d", "(", "X", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator.density": [[33, 39], ["numpy.exp", "RuntimeError", "density_estimators.GaussianMixtureDensityEstimator._gmm_model.score_samples", "dowhy.gcm.util.general.shape_into_2d"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "density", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "_gmm_model", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "'%s has not been fitted!'", "%", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n", "# Note, the output of score_samples are log values.", "\n", "", "return", "np", ".", "exp", "(", "self", ".", "_gmm_model", ".", "score_samples", "(", "shape_into_2d", "(", "X", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.KernelDensityEstimator1D.__init__": [[45, 47], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_kde_model", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.KernelDensityEstimator1D.fit": [[48, 56], ["dowhy.gcm.util.general.shape_into_2d", "density_estimators.KernelDensityEstimator1D._validate_data", "sklearn.neighbors.KernelDensity().fit", "numpy.std", "numpy.power", "dowhy.gcm.util.general.shape_into_2d.reshape", "sklearn.neighbors.KernelDensity"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.KernelDensityEstimator1D._validate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "self", ".", "_validate_data", "(", "X", ")", "\n", "\n", "bandwidth", "=", "np", ".", "std", "(", "X", ")", "*", "np", ".", "power", "(", "4", "/", "3", "/", "X", ".", "shape", "[", "0", "]", ",", "1", "/", "5", ")", "\n", "\n", "self", ".", "_kde_model", "=", "KernelDensity", "(", "kernel", "=", "'gaussian'", ",", "\n", "bandwidth", "=", "bandwidth", ")", ".", "fit", "(", "X", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.KernelDensityEstimator1D._validate_data": [[57, 60], ["RuntimeError"], "methods", ["None"], ["", "def", "_validate_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "if", "X", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "'%s only supports one dimensional data!'", "%", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.KernelDensityEstimator1D.density": [[61, 70], ["dowhy.gcm.util.general.shape_into_2d", "density_estimators.KernelDensityEstimator1D._validate_data", "numpy.exp", "RuntimeError", "density_estimators.KernelDensityEstimator1D._kde_model.score_samples", "dowhy.gcm.util.general.shape_into_2d.reshape"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimators.KernelDensityEstimator1D._validate_data"], ["", "", "def", "density", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "_kde_model", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "'%s has not been fitted!'", "%", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n", "", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "self", ".", "_validate_data", "(", "X", ")", "\n", "\n", "# Note, the output of score_samples are log values.", "\n", "return", "np", ".", "exp", "(", "self", ".", "_kde_model", ".", "score_samples", "(", "X", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms": [[54, 105], ["dowhy.gcm.graph.is_root_node", "dowhy.gcm.graph.validate_causal_model_assignment", "causal_model.set_causal_mechanism", "auto.select_model", "isinstance", "dowhy.gcm.stochastic_models.EmpiricalDistribution", "based_on[].to_numpy", "based_on[].to_numpy", "causal_model.set_causal_mechanism", "causal_model.set_causal_mechanism", "dowhy.gcm.fcms.ClassifierFCM", "dowhy.gcm.fcms.AdditiveNoiseModel", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_model_assignment", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.select_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "def", "assign_causal_mechanisms", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "\n", "based_on", ":", "pd", ".", "DataFrame", ",", "\n", "quality", ":", "AssignmentQuality", "=", "AssignmentQuality", ".", "GOOD", ",", "\n", "override_models", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "    ", "\"\"\"Automatically assigns appropriate causal models. If causal models are already assigned to nodes and\n    override_models is set to False, this function only validates the assignments with respect to the graph structure.\n    Here, the validation checks whether root nodes have StochasticModels and non-root ConditionalStochasticModels\n    assigned.\n\n    :param causal_model: The causal model to whose nodes to assign causal models.\n    :param based_on: Jointly sampled data corresponding to the nodes of the given graph.\n    :param quality: AssignmentQuality for the automatic model selection and model accuracy. This changes the type of\n    prediction model and time spent on the selection. Options are:\n        - AssignmentQuality.GOOD: Checks whether the data is linear. If the data is linear, an OLS model is\n            used, otherwise a gradient boost model.\n            Model selection speed: Fast\n            Model training speed: Fast\n            Model inference speed: Fast\n            Model accuracy: Medium\n        - AssignmentQuality.BETTER: Compares multiple model types and uses the one with the best performance\n            averaged over multiple splits of the training data. By default, the model with the smallest root mean\n            squared error is selected for regression problems and the model with the highest F1 score is selected for\n            classification problems. For a list of possible models, see _LIST_OF_POTENTIAL_REGRESSORS and\n            _LIST_OF_POTENTIAL_CLASSIFIERS, respectively.\n            Model selection speed: Medium\n            Model training speed: Fast\n            Model inference speed: Fast\n            Model accuracy: Good\n        :param override_models: If set to True, existing model assignments are replaced with automatically selected\n        ones. If set to False, the assigned models are only validated with respect to the graph structure.\n\n    :return: None\n    \"\"\"", "\n", "\n", "for", "node", "in", "causal_model", ".", "graph", ".", "nodes", ":", "\n", "        ", "if", "not", "override_models", "and", "CAUSAL_MECHANISM", "in", "causal_model", ".", "graph", ".", "nodes", "[", "node", "]", ":", "\n", "            ", "validate_causal_model_assignment", "(", "causal_model", ".", "graph", ",", "node", ")", "\n", "continue", "\n", "\n", "", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "node", ")", ":", "\n", "            ", "causal_model", ".", "set_causal_mechanism", "(", "node", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "prediction_model", "=", "select_model", "(", "based_on", "[", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", ",", "\n", "based_on", "[", "node", "]", ".", "to_numpy", "(", ")", ",", "\n", "quality", ")", "\n", "\n", "if", "isinstance", "(", "prediction_model", ",", "ClassificationModel", ")", ":", "\n", "                ", "causal_model", ".", "set_causal_mechanism", "(", "node", ",", "ClassifierFCM", "(", "prediction_model", ")", ")", "\n", "", "else", ":", "\n", "                ", "causal_model", ".", "set_causal_mechanism", "(", "node", ",", "AdditiveNoiseModel", "(", "prediction_model", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.select_model": [[107, 129], ["dowhy.gcm.util.general.is_categorical", "auto.has_linear_relationship", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_hist_gradient_boost_classifier", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_hist_gradient_boost_regressor", "auto.find_best_model", "auto.find_best_model"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.has_linear_relationship", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.find_best_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.find_best_model"], ["", "", "", "", "def", "select_model", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ",", "model_selection_quality", ":", "AssignmentQuality", ")", "->", "Union", "[", "PredictionModel", ",", "ClassificationModel", "]", ":", "\n", "    ", "target_is_categorical", "=", "is_categorical", "(", "Y", ")", "\n", "\n", "if", "model_selection_quality", "==", "AssignmentQuality", ".", "GOOD", ":", "\n", "        ", "use_linear_prediction_models", "=", "has_linear_relationship", "(", "X", ",", "Y", ")", "\n", "\n", "if", "target_is_categorical", ":", "\n", "            ", "if", "use_linear_prediction_models", ":", "\n", "                ", "return", "create_logistic_regression_classifier", "(", "max_iter", "=", "1000", ")", "\n", "", "else", ":", "\n", "                ", "return", "create_hist_gradient_boost_classifier", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "use_linear_prediction_models", ":", "\n", "                ", "return", "create_linear_regressor", "(", ")", "\n", "", "else", ":", "\n", "                ", "return", "create_hist_gradient_boost_regressor", "(", ")", "\n", "", "", "", "elif", "model_selection_quality", "==", "AssignmentQuality", ".", "BETTER", ":", "\n", "        ", "if", "target_is_categorical", ":", "\n", "            ", "return", "find_best_model", "(", "_LIST_OF_POTENTIAL_CLASSIFIERS", ",", "X", ",", "Y", ")", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "find_best_model", "(", "_LIST_OF_POTENTIAL_REGRESSORS", ",", "X", ",", "Y", ")", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.has_linear_relationship": [[131, 177], ["dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.is_categorical", "min", "min", "dowhy.gcm.util.general.fit_one_hot_encoders", "dowhy.gcm.util.general.apply_one_hot_encoding", "dowhy.gcm.util.general.apply_one_hot_encoding", "round", "numpy.unique", "range", "sklearn.model_selection.train_test_split", "sklearn.model_selection.train_test_split", "numpy.row_stack", "sklearn.linear_model.LogisticRegression", "dowhy.gcm.ml.create_hist_gradient_boost_classifier", "sklearn.linear_model.LinearRegression.fit", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.fit", "sklearn.linear_model.LinearRegression", "dowhy.gcm.ml.create_hist_gradient_boost_regressor", "sklearn.linear_model.LinearRegression.fit", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.fit", "y_train.squeeze", "y_train.squeeze", "numpy.sum", "numpy.sum", "y_train.squeeze", "y_train.squeeze", "numpy.mean", "numpy.mean", "numpy.row_stack", "numpy.row_stack", "dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.shape_into_2d", "sklearn.linear_model.LinearRegression.predict", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict", "dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.shape_into_2d", "sklearn.linear_model.LinearRegression.predict", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "", "", "def", "has_linear_relationship", "(", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "max_num_samples", ":", "int", "=", "3000", ")", "->", "bool", ":", "\n", "    ", "X", ",", "Y", "=", "shape_into_2d", "(", "X", ",", "Y", ")", "\n", "\n", "target_is_categorical", "=", "is_categorical", "(", "Y", ")", "\n", "# Making sure there are at least 30% test samples.", "\n", "num_trainings_samples", "=", "min", "(", "max_num_samples", ",", "round", "(", "X", ".", "shape", "[", "0", "]", "*", "0.7", ")", ")", "\n", "num_test_samples", "=", "min", "(", "X", ".", "shape", "[", "0", "]", "-", "num_trainings_samples", ",", "max_num_samples", ")", "\n", "\n", "if", "target_is_categorical", ":", "\n", "        ", "all_classes", ",", "indices", ",", "counts", "=", "np", ".", "unique", "(", "Y", ",", "return_counts", "=", "True", ",", "return_index", "=", "True", ")", "\n", "for", "i", "in", "range", "(", "all_classes", ".", "size", ")", ":", "\n", "# Making sure that there are at least 2 samples from one class (here, simply duplicate the point).", "\n", "            ", "if", "counts", "[", "i", "]", "==", "1", ":", "\n", "                ", "X", "=", "np", ".", "row_stack", "(", "[", "X", ",", "X", "[", "indices", "[", "i", "]", ",", ":", "]", "]", ")", "\n", "Y", "=", "np", ".", "row_stack", "(", "[", "Y", ",", "Y", "[", "indices", "[", "i", "]", ",", ":", "]", "]", ")", "\n", "\n", "", "", "x_train", ",", "x_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "X", ",", "Y", ",", "train_size", "=", "num_trainings_samples", ",", "test_size", "=", "num_test_samples", ",", "stratify", "=", "Y", ")", "\n", "\n", "", "else", ":", "\n", "        ", "x_train", ",", "x_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "X", ",", "Y", ",", "train_size", "=", "num_trainings_samples", ",", "test_size", "=", "num_test_samples", ")", "\n", "\n", "", "one_hot_encoder", "=", "fit_one_hot_encoders", "(", "np", ".", "row_stack", "(", "[", "x_train", ",", "x_test", "]", ")", ")", "\n", "x_train", "=", "apply_one_hot_encoding", "(", "x_train", ",", "one_hot_encoder", ")", "\n", "x_test", "=", "apply_one_hot_encoding", "(", "x_test", ",", "one_hot_encoder", ")", "\n", "\n", "if", "target_is_categorical", ":", "\n", "        ", "linear_mdl", "=", "LogisticRegression", "(", "max_iter", "=", "1000", ")", "\n", "nonlinear_mdl", "=", "create_hist_gradient_boost_classifier", "(", ")", "\n", "linear_mdl", ".", "fit", "(", "x_train", ",", "y_train", ".", "squeeze", "(", ")", ")", "\n", "nonlinear_mdl", ".", "fit", "(", "x_train", ",", "y_train", ".", "squeeze", "(", ")", ")", "\n", "\n", "# Compare number of correct classifications.", "\n", "return", "np", ".", "sum", "(", "shape_into_2d", "(", "linear_mdl", ".", "predict", "(", "x_test", ")", ")", "==", "y_test", ")", ">=", "np", ".", "sum", "(", "shape_into_2d", "(", "nonlinear_mdl", ".", "predict", "(", "x_test", ")", ")", "==", "y_test", ")", "\n", "", "else", ":", "\n", "        ", "linear_mdl", "=", "LinearRegression", "(", ")", "\n", "nonlinear_mdl", "=", "create_hist_gradient_boost_regressor", "(", ")", "\n", "linear_mdl", ".", "fit", "(", "x_train", ",", "y_train", ".", "squeeze", "(", ")", ")", "\n", "nonlinear_mdl", ".", "fit", "(", "x_train", ",", "y_train", ".", "squeeze", "(", ")", ")", "\n", "\n", "return", "np", ".", "mean", "(", "(", "y_test", "-", "shape_into_2d", "(", "linear_mdl", ".", "predict", "(", "x_test", ")", ")", ")", "**", "2", ")", "<=", "np", ".", "mean", "(", "(", "y_test", "-", "shape_into_2d", "(", "nonlinear_mdl", ".", "predict", "(", "x_test", ")", ")", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.find_best_model": [[179, 232], ["dowhy.gcm.util.general.shape_into_2d", "isinstance", "list", "numpy.random.randint", "sklearn.preprocessing.MultiLabelBinarizer", "sklearn.preprocessing.MultiLabelBinarizer.fit", "sklearn.model_selection.KFold().split", "dowhy.gcm.util.general.set_random_seed", "joblib.Parallel", "range", "warnings.catch_warnings", "warnings.filterwarnings", "numpy.iinfo", "len", "sorted", "sklearn.model_selection.KFold", "prediction_model_factory", "prediction_model_factory.fit", "prediction_model_factory.predict", "metric", "joblib.delayed", "zip", "zip", "sklearn.metrics.f1_score", "sklearn.preprocessing.MultiLabelBinarizer.transform", "sklearn.preprocessing.MultiLabelBinarizer.transform"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "", "def", "find_best_model", "(", "prediction_model_factories", ":", "List", "[", "Callable", "[", "[", "]", ",", "PredictionModel", "]", "]", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "metric", ":", "Optional", "[", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", "]", "=", "None", ",", "\n", "max_samples_per_split", ":", "int", "=", "10000", ",", "\n", "model_selection_splits", ":", "int", "=", "5", ",", "\n", "n_jobs", ":", "int", "=", "-", "1", ")", "->", "Callable", "[", "[", "]", ",", "PredictionModel", "]", ":", "\n", "    ", "X", ",", "Y", "=", "shape_into_2d", "(", "X", ",", "Y", ")", "\n", "\n", "is_classification_problem", "=", "isinstance", "(", "prediction_model_factories", "[", "0", "]", "(", ")", ",", "ClassificationModel", ")", "\n", "\n", "if", "metric", "is", "None", ":", "\n", "        ", "if", "is_classification_problem", ":", "\n", "            ", "metric", "=", "lambda", "y_true", ",", "y_preds", ":", "-", "metrics", ".", "f1_score", "(", "y_true", ",", "y_preds", ",", "average", "=", "'macro'", ",", "zero_division", "=", "0", ")", "# Higher score is better", "\n", "", "else", ":", "\n", "            ", "metric", "=", "metrics", ".", "mean_squared_error", "\n", "\n", "", "", "labelBinarizer", "=", "None", "\n", "if", "is_classification_problem", ":", "\n", "        ", "labelBinarizer", "=", "MultiLabelBinarizer", "(", ")", "\n", "labelBinarizer", ".", "fit", "(", "Y", ")", "\n", "\n", "", "kfolds", "=", "list", "(", "KFold", "(", "n_splits", "=", "model_selection_splits", ")", ".", "split", "(", "range", "(", "X", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "\n", "def", "estimate_average_score", "(", "prediction_model_factory", ":", "Callable", "[", "[", "]", ",", "PredictionModel", "]", ",", "random_seed", ":", "int", ")", "->", "float", ":", "\n", "        ", "set_random_seed", "(", "random_seed", ")", "\n", "\n", "average_result", "=", "0", "\n", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ",", "category", "=", "ConvergenceWarning", ")", "\n", "for", "train_indices", ",", "test_indices", "in", "kfolds", ":", "\n", "                ", "model_instance", "=", "prediction_model_factory", "(", ")", "\n", "model_instance", ".", "fit", "(", "X", "[", "train_indices", "[", ":", "max_samples_per_split", "]", "]", ",", "Y", "[", "train_indices", "[", ":", "max_samples_per_split", "]", "]", ")", "\n", "\n", "y_true", "=", "Y", "[", "test_indices", "[", ":", "max_samples_per_split", "]", "]", "\n", "y_pred", "=", "model_instance", ".", "predict", "(", "X", "[", "test_indices", "[", ":", "max_samples_per_split", "]", "]", ")", "\n", "if", "labelBinarizer", "is", "not", "None", ":", "\n", "                    ", "y_true", "=", "labelBinarizer", ".", "transform", "(", "y_true", ")", "\n", "y_pred", "=", "labelBinarizer", ".", "transform", "(", "y_pred", ")", "\n", "\n", "", "average_result", "+=", "metric", "(", "y_true", ",", "y_pred", ")", "\n", "\n", "", "", "return", "average_result", "/", "model_selection_splits", "\n", "\n", "", "random_seeds", "=", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "len", "(", "prediction_model_factories", ")", ")", "\n", "average_metric_scores", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "\n", "delayed", "(", "estimate_average_score", ")", "(", "prediction_model_factory", ",", "random_seed", ")", "\n", "for", "prediction_model_factory", ",", "random_seed", "\n", "in", "zip", "(", "prediction_model_factories", ",", "random_seeds", ")", ")", "\n", "\n", "return", "sorted", "(", "zip", "(", "prediction_model_factories", ",", "average_metric_scores", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "[", "0", "]", "[", "0", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples": [[19, 48], ["dowhy.gcm.graph.validate_causal_dag", "whatif._interventional_samples", "dowhy.gcm.graph.validate_node_in_graph", "ValueError", "ValueError", "dowhy.gcm.fitting_sampling.draw_samples"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._interventional_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node_in_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["def", "interventional_samples", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "\n", "interventions", ":", "Dict", "[", "Any", ",", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", "]", ",", "\n", "observed_data", ":", "Optional", "[", "pd", ".", "DataFrame", "]", "=", "None", ",", "\n", "num_samples_to_draw", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "\"\"\"Performs intervention on nodes in the causal graph.\n\n    :param causal_model: The probabilistic causal model we perform this intervention on .\n    :param interventions: Dictionary containing the interventions we want to perform, keyed by node name. An\n                          intervention is a function that takes a value as input and returns another value.\n                          For example, `{'X': lambda x: 2}` mimics the atomic intervention *do(X:=2)*.\n                          A soft intervention can be formulated as `{'X': lambda x: 0.2 * x}`.\n    :param observed_data: Optionally, data on which to perform interventions. If None are given, data is generated based\n                          on the generative models.\n    :param num_samples_to_draw: Sample size to draw from the interventional distribution.\n    :return: Samples from the interventional distribution.\n    \"\"\"", "\n", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "for", "node", "in", "interventions", ":", "\n", "        ", "validate_node_in_graph", "(", "causal_model", ".", "graph", ",", "node", ")", "\n", "\n", "", "if", "observed_data", "is", "None", "and", "num_samples_to_draw", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"Either observed_samples or num_samples_to_draw need to be set!\"", ")", "\n", "", "if", "observed_data", "is", "not", "None", "and", "num_samples_to_draw", "is", "not", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"Either observed_samples or num_samples_to_draw need to be set, not both!\"", ")", "\n", "\n", "", "if", "num_samples_to_draw", "is", "not", "None", ":", "\n", "        ", "observed_data", "=", "draw_samples", "(", "causal_model", ",", "num_samples_to_draw", ")", "\n", "\n", "", "return", "_interventional_samples", "(", "causal_model", ",", "observed_data", ",", "interventions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._interventional_samples": [[50, 75], ["observed_data.copy", "whatif._get_nodes_affected_by_intervention", "networkx.topological_sort", "interventions.keys", "dowhy.gcm.graph.is_root_node", "whatif._evaluate_intervention", "samples[].to_numpy", "pcm.causal_mechanism().draw_samples", "pcm.causal_mechanism().draw_samples.reshape", "whatif._parent_samples_of", "pcm.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._get_nodes_affected_by_intervention", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._evaluate_intervention", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._parent_samples_of", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "def", "_interventional_samples", "(", "pcm", ":", "ProbabilisticCausalModel", ",", "\n", "observed_data", ":", "pd", ".", "DataFrame", ",", "\n", "interventions", ":", "Dict", "[", "Any", ",", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", "]", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "samples", "=", "observed_data", ".", "copy", "(", ")", "\n", "\n", "affected_nodes", "=", "_get_nodes_affected_by_intervention", "(", "pcm", ".", "graph", ",", "interventions", ".", "keys", "(", ")", ")", "\n", "sorted_nodes", "=", "nx", ".", "topological_sort", "(", "pcm", ".", "graph", ")", "\n", "\n", "# Simulating interventions by propagating the effects through the graph. For this, we iterate over the nodes based", "\n", "# on their topological order.", "\n", "for", "node", "in", "sorted_nodes", ":", "\n", "        ", "if", "node", "not", "in", "affected_nodes", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "is_root_node", "(", "pcm", ".", "graph", ",", "node", ")", ":", "\n", "            ", "node_data", "=", "samples", "[", "node", "]", ".", "to_numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "node_data", "=", "pcm", ".", "causal_mechanism", "(", "node", ")", ".", "draw_samples", "(", "_parent_samples_of", "(", "node", ",", "pcm", ",", "samples", ")", ")", "\n", "\n", "# After drawing samples of the node based on the data generation process, we apply the corresponding", "\n", "# intervention. The inputs of downstream nodes are therefore based on the outcome of the intervention in this", "\n", "# node.", "\n", "", "samples", "[", "node", "]", "=", "_evaluate_intervention", "(", "node", ",", "interventions", ",", "node_data", ".", "reshape", "(", "-", "1", ")", ")", "\n", "\n", "", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._get_nodes_affected_by_intervention": [[77, 91], ["networkx.topological_sort", "result.append", "networkx.ancestors", "result.append"], "function", ["None"], ["", "def", "_get_nodes_affected_by_intervention", "(", "causal_graph", ":", "DirectedGraph", ",", "target_nodes", ":", "Iterable", "[", "Any", "]", ")", "->", "List", "[", "Any", "]", ":", "\n", "    ", "result", "=", "[", "]", "\n", "\n", "for", "node", "in", "nx", ".", "topological_sort", "(", "causal_graph", ")", ":", "\n", "        ", "if", "node", "in", "target_nodes", ":", "\n", "            ", "result", ".", "append", "(", "node", ")", "\n", "continue", "\n", "\n", "", "for", "target_node", "in", "target_nodes", ":", "\n", "            ", "if", "target_node", "in", "nx", ".", "ancestors", "(", "causal_graph", ",", "source", "=", "node", ")", ":", "\n", "                ", "result", ".", "append", "(", "node", ")", "\n", "break", "\n", "\n", "", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.counterfactual_samples": [[93, 131], ["dowhy.gcm.graph.validate_causal_dag", "whatif._counterfactual_samples", "dowhy.gcm.graph.validate_node_in_graph", "ValueError", "ValueError", "dowhy.gcm._noise.compute_noise_from_data", "isinstance", "ValueError"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._counterfactual_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node_in_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.compute_noise_from_data"], ["", "def", "counterfactual_samples", "(", "causal_model", ":", "Union", "[", "StructuralCausalModel", ",", "InvertibleStructuralCausalModel", "]", ",", "\n", "interventions", ":", "Dict", "[", "Any", ",", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", "]", ",", "\n", "observed_data", ":", "Optional", "[", "pd", ".", "DataFrame", "]", "=", "None", ",", "\n", "noise_data", ":", "Optional", "[", "pd", ".", "DataFrame", "]", "=", "None", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "\"\"\"Estimates counterfactual data for observed data if we were to perform specified interventions. This function\n    implements the 3-step process for computing counterfactuals by Pearl (see https://ftp.cs.ucla.edu/pub/stat_ser/r485.pdf).\n\n    :param causal_model: The (invertible) structural causal model we perform this intervention on. If noise_data is\n                         None and observed_data is provided, this must be an invertible structural model, otherwise,\n                         this can be either a structural causal model or an invertible one.\n    :param interventions: Dictionary containing the interventions we want to perform keyed by node name. An\n                          intervention is a function that takes a value as input and returns another value.\n                          For example, `{'X': lambda x: 2}` mimics the atomic intervention *do(X:=2)*.\n    :param observed_data: Factual data that we observe for the nodes in the causal graph.\n    :param noise_data: Data of noise terms corresponding to nodes in the causal graph. If not provided,\n                       these have to be estimated from observed data. Then we require causal models of nodes to be\n                       invertible.\n    :return: Estimated counterfactual data.\n    \"\"\"", "\n", "for", "node", "in", "interventions", ":", "\n", "        ", "validate_node_in_graph", "(", "causal_model", ".", "graph", ",", "node", ")", "\n", "\n", "", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "if", "observed_data", "is", "None", "and", "noise_data", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"Either observed_data or noise_data need to be given!\"", ")", "\n", "", "if", "observed_data", "is", "not", "None", "and", "noise_data", "is", "not", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"Either observed_data or noise_data can be given, not both!\"", ")", "\n", "\n", "", "if", "noise_data", "is", "None", "and", "observed_data", "is", "not", "None", ":", "\n", "        ", "if", "not", "isinstance", "(", "causal_model", ",", "InvertibleStructuralCausalModel", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Since no noise_data is given, this has to be estimated from the given \"", "\n", "\"observed_data. This can only be done with InvertibleStructuralCausalModel.\"", ")", "\n", "# Abduction: For invertible SCMs, we recover exact noise values from data.", "\n", "", "noise_data", "=", "compute_noise_from_data", "(", "causal_model", ",", "observed_data", ")", "\n", "\n", "# Action + Prediction: Propagate the intervention downstream using recovered noise values.", "\n", "", "return", "_counterfactual_samples", "(", "causal_model", ",", "interventions", ",", "noise_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._counterfactual_samples": [[133, 150], ["list", "pandas.DataFrame", "networkx.topological_sort", "numpy.empty", "dowhy.gcm.graph.is_root_node", "whatif._evaluate_intervention", "noise_data[].to_numpy", "scm.causal_mechanism().evaluate", "scm.causal_mechanism().evaluate.reshape", "len", "whatif._parent_samples_of", "noise_data[].to_numpy", "scm.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._evaluate_intervention", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._parent_samples_of", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "def", "_counterfactual_samples", "(", "scm", ":", "StructuralCausalModel", ",", "\n", "interventions", ":", "Dict", "[", "Any", ",", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", "]", ",", "\n", "noise_data", ":", "pd", ".", "DataFrame", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "topologically_sorted_nodes", "=", "list", "(", "nx", ".", "topological_sort", "(", "scm", ".", "graph", ")", ")", "\n", "samples", "=", "pd", ".", "DataFrame", "(", "np", ".", "empty", "(", "(", "noise_data", ".", "shape", "[", "0", "]", ",", "len", "(", "topologically_sorted_nodes", ")", ")", ")", ",", "\n", "columns", "=", "topologically_sorted_nodes", ")", "\n", "\n", "for", "node", "in", "topologically_sorted_nodes", ":", "\n", "        ", "if", "is_root_node", "(", "scm", ".", "graph", ",", "node", ")", ":", "\n", "            ", "node_data", "=", "noise_data", "[", "node", "]", ".", "to_numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "node_data", "=", "scm", ".", "causal_mechanism", "(", "node", ")", ".", "evaluate", "(", "_parent_samples_of", "(", "node", ",", "scm", ",", "samples", ")", ",", "\n", "noise_data", "[", "node", "]", ".", "to_numpy", "(", ")", ")", "\n", "\n", "", "samples", "[", "node", "]", "=", "_evaluate_intervention", "(", "node", ",", "interventions", ",", "node_data", ".", "reshape", "(", "-", "1", ")", ")", "\n", "\n", "", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._evaluate_intervention": [[152, 169], ["numpy.array", "list", "RuntimeError", "map"], "function", ["None"], ["", "def", "_evaluate_intervention", "(", "node", ":", "Any", ",", "\n", "interventions", ":", "Dict", "[", "Any", ",", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "pre_intervention_data", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "# Check if we need to apply an intervention on the given node.", "\n", "    ", "if", "node", "in", "interventions", ":", "\n", "# Apply intervention function to the data of the node.", "\n", "        ", "post_intervention_data", "=", "np", ".", "array", "(", "list", "(", "map", "(", "interventions", "[", "node", "]", ",", "pre_intervention_data", ")", ")", ")", "\n", "\n", "# Check if the intervention function changes the shape of the data.", "\n", "if", "pre_intervention_data", ".", "shape", "!=", "post_intervention_data", ".", "shape", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "'Dimension of data corresponding to the node `%s` after intervention is different than before '", "\n", "'intervention.'", "%", "node", ")", "\n", "\n", "", "return", "post_intervention_data", "\n", "", "else", ":", "\n", "        ", "return", "pre_intervention_data", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif._parent_samples_of": [[171, 173], ["samples[].to_numpy", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "", "def", "_parent_samples_of", "(", "node", ":", "Any", ",", "scm", ":", "ProbabilisticCausalModel", ",", "samples", ":", "pd", ".", "DataFrame", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "return", "samples", "[", "get_ordered_predecessors", "(", "scm", ".", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.__init__": [[41, 60], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "scipy_distribution", ":", "Optional", "[", "Union", "[", "rv_continuous", ",", "rv_discrete", "]", "]", "=", "None", ",", "\n", "**", "parameters", ")", "->", "None", ":", "\n", "        ", "\"\"\"Initializes a stochastic model that allows to sample from a parametric distribution implemented in Scipy.\n\n        For instance, to use a beta distribution with parameters a=2 and b=0.5:\n            ScipyDistribution(stats.beta, a=2, b=0.5)\n        Or a Gaussian distribution with mean=0 and standard deviation 2:\n            ScipyDistribution(stats.norm, loc=2, scale=0.5)\n\n        Note that the parameter names need to coincide with the parameter names in the corresponding Scipy\n        implementations. See https://docs.scipy.org/doc/scipy/tutorial/stats.html for more information.\n\n        :param scipy_distribution: A continuous or discrete distribution parametric distribution implemented in Scipy.\n        :param parameters: Set of parameters of the parametric distribution.\n        \"\"\"", "\n", "self", ".", "_distribution", "=", "scipy_distribution", "\n", "self", ".", "_parameters", "=", "parameters", "\n", "self", ".", "_fixed_parameters", "=", "len", "(", "parameters", ")", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.draw_samples": [[61, 67], ["dowhy.gcm.util.general.shape_into_2d", "ValueError", "stochastic_models.ScipyDistribution._distribution.rvs", "len"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "draw_samples", "(", "self", ",", "num_samples", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "len", "(", "self", ".", "_parameters", ")", "==", "0", "or", "self", ".", "_distribution", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot draw samples. Model has not been fit!'", ")", "\n", "\n", "", "return", "shape_into_2d", "(", "self", ".", "_distribution", ".", "rvs", "(", "size", "=", "num_samples", ",", "\n", "**", "self", ".", "parameters", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.fit": [[68, 78], ["stochastic_models.ScipyDistribution.find_suitable_continuous_distribution", "stochastic_models.ScipyDistribution.map_scipy_distribution_parameters_to_names", "stochastic_models.ScipyDistribution._distribution.fit", "dowhy.gcm.util.general.shape_into_2d"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.find_suitable_continuous_distribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.map_scipy_distribution_parameters_to_names", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "if", "self", ".", "_distribution", "is", "None", ":", "\n", "# Currently only support continuous distributions for auto selection.", "\n", "            ", "best_model", ",", "best_parameters", "=", "self", ".", "find_suitable_continuous_distribution", "(", "X", ")", "\n", "self", ".", "_distribution", "=", "best_model", "\n", "self", ".", "_parameters", "=", "best_parameters", "\n", "", "elif", "not", "self", ".", "_fixed_parameters", ":", "\n", "            ", "self", ".", "_parameters", "=", "self", ".", "map_scipy_distribution_parameters_to_names", "(", "self", ".", "_distribution", ",", "\n", "self", ".", "_distribution", ".", "fit", "(", "shape_into_2d", "(", "X", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.parameters": [[79, 82], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "parameters", "(", "self", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "return", "self", ".", "_parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.scipy_distribution": [[83, 86], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "scipy_distribution", "(", "self", ")", "->", "Optional", "[", "Union", "[", "rv_continuous", ",", "rv_discrete", "]", "]", ":", "\n", "        ", "return", "self", ".", "_distribution", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.clone": [[87, 92], ["stochastic_models.ScipyDistribution", "stochastic_models.ScipyDistribution"], "methods", ["None"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_fixed_parameters", ":", "\n", "            ", "return", "ScipyDistribution", "(", "scipy_distribution", "=", "self", ".", "_distribution", ",", "**", "self", ".", "_parameters", ")", "\n", "", "else", ":", "\n", "            ", "return", "ScipyDistribution", "(", "scipy_distribution", "=", "self", ".", "_distribution", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.find_suitable_continuous_distribution": [[93, 147], ["dowhy.gcm.util.general.shape_into_2d", "_CONTINUOUS_DISTRIBUTIONS.values", "stochastic_models.ScipyDistribution.map_scipy_distribution_parameters_to_names", "warnings.catch_warnings", "warnings.filterwarnings", "distribution.rvs", "dowhy.gcm.divergence.estimate_kl_divergence_continuous", "distribution.fit"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.map_scipy_distribution_parameters_to_names", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_continuous", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "", "@", "staticmethod", "\n", "def", "find_suitable_continuous_distribution", "(", "distribution_samples", ":", "np", ".", "ndarray", ",", "\n", "divergence_threshold", ":", "float", "=", "10", "**", "-", "2", ")", "->", "Tuple", "[", "rv_continuous", ",", "Dict", "[", "str", ",", "float", "]", "]", ":", "\n", "        ", "\"\"\" Tries to find the best fitting continuous parametric distribution of given samples. This is done by fitting\n        different parametric models and selecting the one with the smallest KL divergence between observed and generated\n        samples.\n        \"\"\"", "\n", "distribution_samples", "=", "shape_into_2d", "(", "distribution_samples", ")", "\n", "\n", "currently_best_distribution", "=", "norm", "\n", "currently_best_parameters", "=", "(", "0.0", ",", "1.0", ")", "\n", "currently_smallest_divergence", "=", "np", ".", "inf", "\n", "\n", "# Estimate distribution parameters from data.", "\n", "for", "distribution", "in", "_CONTINUOUS_DISTRIBUTIONS", ".", "values", "(", ")", ":", "\n", "# Ignore warnings from fitting process.", "\n", "            ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "                ", "warnings", ".", "filterwarnings", "(", "'ignore'", ")", "\n", "\n", "try", ":", "\n", "# Fit distribution to data.", "\n", "                    ", "params", "=", "distribution", ".", "fit", "(", "distribution_samples", ")", "\n", "", "except", "ValueError", ":", "\n", "# Some distributions might not be compatible with the data.", "\n", "                    ", "continue", "\n", "\n", "# Separate parts of parameters.", "\n", "", "arg", "=", "params", "[", ":", "-", "2", "]", "\n", "loc", "=", "params", "[", "-", "2", "]", "\n", "scale", "=", "params", "[", "-", "1", "]", "\n", "\n", "generated_samples", "=", "distribution", ".", "rvs", "(", "size", "=", "distribution_samples", ".", "shape", "[", "0", "]", ",", "\n", "loc", "=", "loc", ",", "\n", "scale", "=", "scale", ",", "\n", "*", "arg", ")", "\n", "\n", "# Check the KL divergence between the distribution of the given and fitted distribution.", "\n", "divergence", "=", "estimate_kl_divergence_continuous", "(", "distribution_samples", ",", "generated_samples", ")", "\n", "if", "divergence", "<", "divergence_threshold", ":", "\n", "                    ", "currently_best_distribution", "=", "distribution", "\n", "currently_best_parameters", "=", "params", "\n", "break", "\n", "\n", "# Identify if this distribution is better.", "\n", "", "if", "currently_smallest_divergence", ">", "divergence", ":", "\n", "                    ", "currently_best_distribution", "=", "distribution", "\n", "currently_best_parameters", "=", "params", "\n", "currently_smallest_divergence", "=", "divergence", "\n", "\n", "", "", "", "return", "currently_best_distribution", ",", "ScipyDistribution", ".", "map_scipy_distribution_parameters_to_names", "(", "currently_best_distribution", ",", "\n", "currently_best_parameters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.ScipyDistribution.map_scipy_distribution_parameters_to_names": [[148, 177], ["enumerate", "name.strip", "ValueError", "scipy_distribution.shapes.split"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "map_scipy_distribution_parameters_to_names", "(", "scipy_distribution", ":", "Union", "[", "rv_continuous", ",", "rv_discrete", "]", ",", "\n", "parameters", ":", "Tuple", "[", "float", "]", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "\"\"\"Helper function to obtain a mapping from parameter name to parameter value. Depending whether the\n        distribution is discrete or continuous, there are slightly different parameter names. The given parameters are\n        assumed to follow the order as provided by the scipy fit function.\n\n        :param scipy_distribution: The scipy distribution.\n        :param parameters: The values of the corresponding parameters of the distribution. Here, it is expected to\n                           follow the same order as defined by the scipy fit function.\n        :return: A dictionary that maps a parameter name to its value.\n        \"\"\"", "\n", "if", "scipy_distribution", ".", "shapes", ":", "\n", "            ", "parameter_list", "=", "[", "name", ".", "strip", "(", ")", "for", "name", "in", "scipy_distribution", ".", "shapes", ".", "split", "(", "','", ")", "]", "\n", "", "else", ":", "\n", "            ", "parameter_list", "=", "[", "]", "\n", "", "if", "scipy_distribution", ".", "name", "in", "_DISCRETE_DISTRIBUTIONS", ":", "\n", "            ", "parameter_list", "+=", "[", "'loc'", "]", "\n", "", "elif", "scipy_distribution", ".", "name", "in", "_CONTINUOUS_DISTRIBUTIONS", ":", "\n", "            ", "parameter_list", "+=", "[", "'loc'", ",", "'scale'", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Distribution %s not found in the list of continuous and discrete distributions!\"", "\n", "%", "scipy_distribution", ".", "name", ")", "\n", "\n", "", "parameters_dictionary", "=", "{", "}", "\n", "for", "i", ",", "parameter_name", "in", "enumerate", "(", "parameter_list", ")", ":", "\n", "            ", "parameters_dictionary", "[", "parameter_name", "]", "=", "parameters", "[", "i", "]", "\n", "\n", "", "return", "parameters_dictionary", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.EmpiricalDistribution.__init__": [[185, 187], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_data", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.EmpiricalDistribution.data": [[188, 191], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "data", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "_data", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.EmpiricalDistribution.fit": [[192, 194], ["dowhy.gcm.util.general.shape_into_2d"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "self", ".", "_data", "=", "shape_into_2d", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.EmpiricalDistribution.draw_samples": [[195, 200], ["RuntimeError", "numpy.random.choice"], "methods", ["None"], ["", "def", "draw_samples", "(", "self", ",", "num_samples", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "data", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "'%s has not been fitted!'", "%", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n", "", "return", "self", ".", "data", "[", "np", ".", "random", ".", "choice", "(", "self", ".", "data", ".", "shape", "[", "0", "]", ",", "size", "=", "num_samples", ",", "replace", "=", "True", ")", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.EmpiricalDistribution.clone": [[201, 203], ["stochastic_models.EmpiricalDistribution"], "methods", ["None"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "return", "EmpiricalDistribution", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__init__": [[206, 208], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "__gmm_model", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.fit": [[209, 215], ["dowhy.gcm.util.general.shape_into_2d", "sklearn.mixture.BayesianGaussianMixture().fit", "sklearn.mixture.BayesianGaussianMixture", "stochastic_models.BayesianGaussianMixtureDistribution.__get_optimal_number_of_components"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__get_optimal_number_of_components"], ["", "def", "fit", "(", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "self", ".", "__gmm_model", "=", "BayesianGaussianMixture", "(", "\n", "n_components", "=", "BayesianGaussianMixtureDistribution", ".", "__get_optimal_number_of_components", "(", "X", ")", ",", "\n", "max_iter", "=", "1000", ")", ".", "fit", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__get_optimal_number_of_components": [[216, 242], ["range", "int", "sklearn.cluster.KMeans().fit", "sklearn.metrics.silhouette_score", "numpy.sqrt", "sklearn.cluster.KMeans"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "@", "staticmethod", "\n", "def", "__get_optimal_number_of_components", "(", "X", ":", "np", ".", "ndarray", ")", "->", "int", ":", "\n", "        ", "current_best", "=", "0", "\n", "current_best_num_components", "=", "1", "\n", "num_best_in_succession", "=", "0", "\n", "try", ":", "\n", "            ", "for", "i", "in", "range", "(", "2", ",", "int", "(", "np", ".", "sqrt", "(", "X", ".", "shape", "[", "0", "]", "/", "2", ")", ")", ")", ":", "\n", "                ", "kmeans", "=", "KMeans", "(", "n_clusters", "=", "i", ")", ".", "fit", "(", "X", ")", "\n", "coefficient", "=", "silhouette_score", "(", "X", ",", "kmeans", ".", "labels_", ",", "sample_size", "=", "5000", ")", "\n", "\n", "if", "coefficient", ">", "current_best", ":", "\n", "                    ", "current_best", "=", "coefficient", "\n", "current_best_num_components", "=", "i", "\n", "num_best_in_succession", "=", "0", "\n", "", "else", ":", "\n", "                    ", "num_best_in_succession", "+=", "1", "\n", "\n", "", "if", "num_best_in_succession", ">=", "3", ":", "\n", "                    ", "break", "\n", "", "", "", "except", "ValueError", ":", "\n", "# This error is typically raised when the data is discrete and all points are assigned to less cluster than", "\n", "# specified. It can also happen due to duplicated points. In these cases, the current best solution should", "\n", "# be sufficient.", "\n", "            ", "return", "current_best_num_components", "\n", "\n", "", "return", "current_best_num_components", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples": [[243, 248], ["dowhy.gcm.util.general.shape_into_2d", "RuntimeError", "stochastic_models.BayesianGaussianMixtureDistribution.__gmm_model.sample"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.multivariate_weighting_sampler.MultivariateWeightingSampler.sample"], ["", "def", "draw_samples", "(", "self", ",", "num_samples", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "__gmm_model", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "'%s has not been fitted!'", "%", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n", "", "return", "shape_into_2d", "(", "self", ".", "__gmm_model", ".", "sample", "(", "num_samples", ")", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.__str__": [[249, 251], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "'Approximated data distribution'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.clone": [[252, 254], ["stochastic_models.BayesianGaussianMixtureDistribution"], "methods", ["None"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "return", "BayesianGaussianMixtureDistribution", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.mechanism_change_test": [[28, 78], ["min", "numpy.ones", "data_set_indices.astype.astype", "numpy.random.choice", "numpy.random.choice", "numpy.vstack", "ValueError", "ValueError", "independence_test", "numpy.vstack", "independence_test", "dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.shape_into_2d"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.__init__.independence_test", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.__init__.independence_test", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["def", "mechanism_change_test", "(", "target_original_data", ":", "np", ".", "ndarray", ",", "\n", "target_new_data", ":", "np", ".", "ndarray", ",", "\n", "parents_original_data", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "parents_new_data", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "independence_test", ":", "\n", "Union", "[", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", ",", "\n", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", "]", "\n", "=", "kernel_based", ")", "->", "float", ":", "\n", "    ", "\"\"\"Estimates a p-value for the null hypothesis that the original and new data were generated by the same mechanism. \n    Here, we check the dependency between binary labels indicating whether a sample is from the original or a new \n    data set. If the labels do not provide information to determine if a sample is coming from the original/new \n    distribution, then it is likely that the mechanism has not changed.\n    \n    For non-root nodes, samples from parent variables are needed as conditioning variables. This is, testing the\n    null hypothesis that the data were generated by the same mechanism given the parent samples. By this, we incorporate\n    upstream changes that might have impacted the parents, but not the target node itself.\n    \n    :param target_original_data: Samples of the node from the original data set.\n    :param target_new_data: Samples of the node from the new data set.\n    :param parents_original_data: Samples from parents of the node from the original data set.\n    :param parents_new_data: Samples from parents of the node from the new data set.\n    :param independence_test: Pairwise/conditional independence test.\n    :return: A p-value for the null hypothesis that the mechanism has not changed.\n    \"\"\"", "\n", "causal_graph", ":", "DirectedGraph", "\n", "\n", "if", "parents_original_data", "is", "not", "None", "and", "parents_new_data", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"Original parents data were given, but no new parents data!\"", ")", "\n", "", "if", "parents_original_data", "is", "None", "and", "parents_new_data", "is", "not", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"New parents data were given, but no original parents data!\"", ")", "\n", "\n", "", "num_samples_for_testing", "=", "min", "(", "target_original_data", ".", "shape", "[", "0", "]", ",", "target_new_data", ".", "shape", "[", "0", "]", ")", "\n", "data_set_indices", "=", "np", ".", "ones", "(", "num_samples_for_testing", "*", "2", ")", "\n", "data_set_indices", "[", "num_samples_for_testing", ":", "]", "=", "-", "1", "\n", "data_set_indices", "=", "data_set_indices", ".", "astype", "(", "str", ")", "\n", "\n", "original_indices", "=", "np", ".", "random", ".", "choice", "(", "target_original_data", ".", "shape", "[", "0", "]", ",", "num_samples_for_testing", ",", "replace", "=", "False", ")", "\n", "new_indices", "=", "np", ".", "random", ".", "choice", "(", "target_new_data", ".", "shape", "[", "0", "]", ",", "num_samples_for_testing", ",", "replace", "=", "False", ")", "\n", "\n", "joint_target_samples", "=", "np", ".", "vstack", "(", "[", "shape_into_2d", "(", "target_original_data", "[", "original_indices", "]", ")", ",", "\n", "shape_into_2d", "(", "target_new_data", "[", "new_indices", "]", ")", "]", ")", "\n", "\n", "if", "parents_original_data", "is", "None", ":", "\n", "        ", "return", "independence_test", "(", "joint_target_samples", ",", "data_set_indices", ")", "\n", "", "else", ":", "\n", "        ", "parents_new_data", ":", "np", ".", "ndarray", "\n", "joint_parent_data", "=", "np", ".", "vstack", "(", "[", "shape_into_2d", "(", "parents_original_data", "[", "original_indices", "]", ")", ",", "\n", "shape_into_2d", "(", "parents_new_data", "[", "new_indices", "]", ")", "]", ")", "\n", "\n", "return", "independence_test", "(", "joint_target_samples", ",", "data_set_indices", ",", "joint_parent_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.distribution_change": [[80, 165], ["graph_factory", "dowhy.gcm.graph.clone_causal_models", "dowhy.gcm.cms.ProbabilisticCausalModel", "graph_factory", "dowhy.gcm.graph.clone_causal_models", "dowhy.gcm.cms.ProbabilisticCausalModel", "distribution_change._fit_accounting_for_mechanism_change", "distribution_change.distribution_change_of_graphs", "dowhy.gcm.graph.node_connected_subgraph_view", "list", "list"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.clone_causal_models", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.clone_causal_models", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change._fit_accounting_for_mechanism_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.distribution_change_of_graphs", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view"], ["", "", "def", "distribution_change", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "\n", "old_data", ":", "pd", ".", "DataFrame", ",", "\n", "new_data", ":", "pd", ".", "DataFrame", ",", "\n", "target_node", ":", "Any", ",", "\n", "num_samples", ":", "int", "=", "2000", ",", "\n", "difference_estimation_func", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", "\n", "=", "auto_estimate_kl_divergence", ",", "\n", "mechanism_change_test_func", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "\n", "np", ".", "ndarray", ",", "\n", "Optional", "[", "np", ".", "ndarray", "]", ",", "\n", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "float", "]", "\n", "=", "mechanism_change_test", ",", "\n", "mechanism_change_test_significance_level", ":", "float", "=", "0.05", ",", "\n", "mechanism_change_test_fdr_control_method", ":", "Optional", "[", "str", "]", "=", "'fdr_bh'", ",", "\n", "return_additional_info", ":", "bool", "=", "False", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ",", "\n", "graph_factory", ":", "Callable", "[", "[", "Any", "]", ",", "DirectedGraph", "]", "=", "nx", ".", "DiGraph", ")", "->", "Union", "[", "Dict", "[", "Any", ",", "float", "]", ",", "\n", "Tuple", "[", "Dict", "[", "Any", ",", "float", "]", ",", "Dict", "[", "Any", ",", "bool", "]", ",", "ProbabilisticCausalModel", ",", "ProbabilisticCausalModel", "]", "]", ":", "\n", "    ", "\"\"\"Attributes the change in the marginal distribution of the target_node to nodes upstream in the causal DAG.\n\n    Note that this method creates two copies of the causal DAG. The causal models of one causal DAG are learned from\n    old data and those of another DAG are learned from new data.\n\n    **Research Paper**:\n    Kailash Budhathoki, Dominik Janzing, Patrick Bloebaum, Hoiyi Ng. *Why did the distribution change?*. Proceedings\n    of The 24th International Conference on Artificial Intelligence and Statistics, PMLR 130:1666-1674, 2021.\n\n    :param causal_model: Reference causal model.\n    :param old_data: Joint samples from the 'old' distribution.\n    :param new_data: Joint samples from the 'new' distribution.\n    :param target_node: Target node of interest for attributing the marginal distribution change.\n    :param num_samples: Number of samples used for estimating Shapley values. This can have a significant influence\n                        on runtime and accuracy.\n    :param difference_estimation_func: Function for quantifying the distribution change. This function should expect\n                                       two inputs which represent samples from two different distributions,\n                                       e.g. difference in average values.\n    :param mechanism_change_test_func: Function for testing whether the causal mechanism of a node has changed. This\n                                       function should return a p\u2013value for the null hypothesis that the mechanism has\n                                       not changed.\n    :param mechanism_change_test_significance_level: A significance level for rejecting the null hypothesis that the\n                                                     causal mechanism of a node has not changed.\n    :param mechanism_change_test_fdr_control_method: The false discovery rate control method for mechanism change\n                                                     tests. For more options, checkout `statsmodels manual\n                                                     <https://www.statsmodels.org/dev/generated/statsmodels.stats.multitest.multipletests.html>`_.\n    :param return_additional_info: If set to True, three additional items are returned: a dictionary indicating\n                                   whether each node's mechanism changed, the causal DAG whose causal models are\n                                   learned from old data, and the causal DAG whose causal models are learned from new\n                                   data.\n    :param shapley_config: Configuration for the Shapley estimator.\n    :param graph_factory: Allows customization in case a graph class different than networkx.DiGraph should be used.\n                          This function *must* copy nodes and edges. Attributes of nodes will be overridden in the copy,\n                          so the algorithm is independent of the attribute copy behavior of this factory.\n    :return: By default, if `return_additional_info` is set to False, only the dictionary containing contribution of\n             each upstream node is returned. If `return_additional_info` is set to True, three additional items are\n             returned: a dictionary indicating whether each node's mechanism changed, the causal DAG whose causal models\n             learned from old data, and the causal DAG whose causal models are learned from new data.\n    \"\"\"", "\n", "causal_graph_old", "=", "graph_factory", "(", "node_connected_subgraph_view", "(", "causal_model", ".", "graph", ",", "target_node", ")", ")", "\n", "clone_causal_models", "(", "causal_model", ".", "graph", ",", "causal_graph_old", ")", "\n", "causal_model_old", "=", "ProbabilisticCausalModel", "(", "causal_graph_old", ")", "\n", "\n", "causal_graph_new", "=", "graph_factory", "(", "causal_graph_old", ")", "\n", "clone_causal_models", "(", "causal_graph_old", ",", "causal_graph_new", ")", "\n", "causal_model_new", "=", "ProbabilisticCausalModel", "(", "causal_graph_new", ")", "\n", "\n", "mechanism_changes", "=", "_fit_accounting_for_mechanism_change", "(", "causal_model_old", ",", "\n", "causal_model_new", ",", "\n", "old_data", "[", "list", "(", "causal_graph_old", ".", "nodes", ")", "]", ",", "\n", "new_data", "[", "list", "(", "causal_graph_new", ".", "nodes", ")", "]", ",", "\n", "mechanism_change_test_func", ",", "\n", "mechanism_change_test_significance_level", ",", "\n", "mechanism_change_test_fdr_control_method", ")", "\n", "\n", "attributions", "=", "distribution_change_of_graphs", "(", "causal_model_old", ",", "\n", "causal_model_new", ",", "\n", "target_node", ",", "\n", "num_samples", ",", "\n", "difference_estimation_func", ",", "\n", "shapley_config", ",", "\n", "graph_factory", ")", "\n", "if", "return_additional_info", ":", "\n", "        ", "return", "attributions", ",", "mechanism_changes", ",", "causal_model_old", ",", "causal_model_new", "\n", "", "else", ":", "\n", "        ", "return", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.distribution_change_of_graphs": [[167, 211], ["dowhy.gcm.graph.validate_causal_dag", "dowhy.gcm.graph.validate_causal_dag", "distribution_change.__estimate_marginal_distribution_change", "dowhy.gcm.cms.ProbabilisticCausalModel", "dowhy.gcm.cms.ProbabilisticCausalModel", "dowhy.gcm.graph.node_connected_subgraph_view", "dowhy.gcm.graph.node_connected_subgraph_view"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.__estimate_marginal_distribution_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view"], ["", "", "def", "distribution_change_of_graphs", "(", "causal_model_old", ":", "ProbabilisticCausalModel", ",", "\n", "causal_model_new", ":", "ProbabilisticCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "num_samples", ":", "int", "=", "2000", ",", "\n", "difference_estimation_func", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", "\n", "=", "auto_estimate_kl_divergence", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ",", "\n", "graph_factory", ":", "Callable", "[", "[", "Any", "]", ",", "DirectedGraph", "]", "=", "nx", ".", "DiGraph", ")", "->", "Dict", "[", "Any", ",", "float", "]", ":", "\n", "    ", "\"\"\" Attributes the change of the marginal distribution of target_node to upstream nodes based on the distributions\n    generated by the 'old' and 'new' causal graphs. These graphs are assumed to represent the same causal structure and\n    to be fitted on the respective data.\n\n    Note: This method creates a copy of the given causal models, i.e. the original objects will not be modified.\n\n    Related paper:\n    Budhathoki, K., Janzing, D., Bloebaum, P., & Ng, H. (2021). Why did the distribution change?\n    arXiv preprint arXiv:2102.13384.\n\n    :param causal_model_old: The ProbabilisticCausalModel fitted on the 'old' data.\n    :param causal_model_new: The ProbabilisticCausalModel fitted on the 'new' data.\n    :param target_node: Node of interest for attributing the marginal distribution change.\n    :param num_samples: Number of samples used for the estimation. This can have a significant influence on the runtime\n                        and accuracy.\n    :param difference_estimation_func: Function for quantifying the distribution change. This function should expect\n                                       two inputs which represent samples from two different distributions. An example\n                                       could be the KL divergence.\n    :param shapley_config: Config for the Shapley estimator.\n    :param graph_factory: Allows customization in case a graph class different than networkx.DiGraph should be used.\n                          This function *must* copy nodes and edges. Attributes of nodes will be overridden in the copy,\n                          so the algorithm is independent of the attribute copy behavior of this factory.\n    :return: A dictionary containing the contributions of upstream nodes to the marginal distribution change in the\n             target node.\n    \"\"\"", "\n", "validate_causal_dag", "(", "causal_model_old", ".", "graph", ")", "\n", "validate_causal_dag", "(", "causal_model_new", ".", "graph", ")", "\n", "\n", "return", "__estimate_marginal_distribution_change", "(", "\n", "ProbabilisticCausalModel", "(", "node_connected_subgraph_view", "(", "causal_model_old", ".", "graph", ",", "target_node", ")", ")", ",", "\n", "ProbabilisticCausalModel", "(", "node_connected_subgraph_view", "(", "causal_model_new", ".", "graph", ",", "target_node", ")", ")", ",", "\n", "target_node", ",", "\n", "num_samples", ",", "\n", "difference_estimation_func", ",", "\n", "shapley_config", ",", "\n", "graph_factory", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change._fit_accounting_for_mechanism_change": [[213, 242], ["distribution_change._check_significant_mechanism_change", "old_data.append", "dowhy.gcm.fitting_sampling.fit_causal_model_of_target", "dowhy.gcm.fitting_sampling.fit_causal_model_of_target", "dowhy.gcm.fitting_sampling.fit_causal_model_of_target", "dowhy.gcm.fitting_sampling.fit_causal_model_of_target"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change._check_significant_mechanism_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling.fit_causal_model_of_target", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling.fit_causal_model_of_target", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling.fit_causal_model_of_target", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fitting_sampling.fit_causal_model_of_target"], ["", "def", "_fit_accounting_for_mechanism_change", "(", "causal_model_old", ":", "ProbabilisticCausalModel", ",", "\n", "causal_model_new", ":", "ProbabilisticCausalModel", ",", "\n", "old_data", ":", "pd", ".", "DataFrame", ",", "\n", "new_data", ":", "pd", ".", "DataFrame", ",", "\n", "mechanism_change_func", ":", "\n", "Callable", "[", "[", "np", ".", "ndarray", ",", "\n", "np", ".", "ndarray", ",", "\n", "Optional", "[", "np", ".", "ndarray", "]", ",", "\n", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "float", "]", ",", "\n", "significance_level", ":", "float", ",", "\n", "fdr_control_method", ":", "Optional", "[", "str", "]", ")", "->", "Dict", "[", "Any", ",", "bool", "]", ":", "\n", "    ", "mechanism_changed_for_node", "=", "_check_significant_mechanism_change", "(", "causal_model_old", ".", "graph", ",", "\n", "old_data", ",", "\n", "new_data", ",", "\n", "mechanism_change_func", ",", "\n", "significance_level", ",", "\n", "fdr_control_method", ")", "\n", "\n", "joint_data", "=", "old_data", ".", "append", "(", "new_data", ",", "ignore_index", "=", "True", ",", "sort", "=", "True", ")", "\n", "\n", "for", "node", "in", "causal_model_new", ".", "graph", ".", "nodes", ":", "\n", "        ", "if", "mechanism_changed_for_node", "[", "node", "]", ":", "\n", "            ", "fit_causal_model_of_target", "(", "causal_model_old", ",", "node", ",", "old_data", ")", "\n", "fit_causal_model_of_target", "(", "causal_model_new", ",", "node", ",", "new_data", ")", "\n", "", "else", ":", "\n", "            ", "fit_causal_model_of_target", "(", "causal_model_old", ",", "node", ",", "joint_data", ")", "\n", "fit_causal_model_of_target", "(", "causal_model_new", ",", "node", ",", "joint_data", ")", "\n", "\n", "", "", "return", "mechanism_changed_for_node", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.__estimate_marginal_distribution_change": [[244, 280], ["[].to_numpy", "dowhy.gcm.shapley.estimate_shapley_values", "causal_model_old.causal_mechanism", "causal_model_new.causal_mechanism", "numpy.all", "dowhy.gcm.cms.ProbabilisticCausalModel", "sorted", "range", "[].to_numpy", "difference_estimation_func", "len", "sorted", "sorted", "graph_factory", "list", "len", "dowhy.gcm.graph.get_ordered_predecessors", "enumerate", "dowhy.gcm.fitting_sampling.draw_samples", "dowhy.gcm.cms.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.cms.ProbabilisticCausalModel.set_causal_mechanism", "sorted", "dowhy.gcm.fitting_sampling.draw_samples"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["", "def", "__estimate_marginal_distribution_change", "(", "causal_model_old", ":", "ProbabilisticCausalModel", ",", "\n", "causal_model_new", ":", "ProbabilisticCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "num_samples", ":", "int", ",", "\n", "difference_estimation_func", ":", "\n", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", ",", "\n", "graph_factory", ":", "Callable", "[", "[", "Any", "]", ",", "DirectedGraph", "]", ")", "->", "Dict", "[", "Any", ",", "float", "]", ":", "\n", "    ", "old_causal_models", "=", "[", "causal_model_old", ".", "causal_mechanism", "(", "x", ")", "for", "x", "in", "sorted", "(", "causal_model_old", ".", "graph", ".", "nodes", ")", "]", "\n", "new_causal_models", "=", "[", "causal_model_new", ".", "causal_mechanism", "(", "x", ")", "for", "x", "in", "sorted", "(", "causal_model_new", ".", "graph", ".", "nodes", ")", "]", "\n", "\n", "target_samples_old", "=", "draw_samples", "(", "causal_model_old", ",", "num_samples", ")", "[", "target_node", "]", ".", "to_numpy", "(", ")", "\n", "\n", "def", "attribution_set_function", "(", "subset", ")", ":", "\n", "        ", "if", "np", ".", "all", "(", "subset", "==", "0", ")", ":", "\n", "            ", "return", "0", "\n", "\n", "", "causal_model", "=", "ProbabilisticCausalModel", "(", "graph_factory", "(", "causal_model_old", ".", "graph", ")", ")", "\n", "nodes", "=", "sorted", "(", "list", "(", "causal_model", ".", "graph", ".", "nodes", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "old_causal_models", ")", ")", ":", "\n", "            ", "if", "subset", "[", "i", "]", "==", "1", ":", "\n", "                ", "causal_model", ".", "set_causal_mechanism", "(", "nodes", "[", "i", "]", ",", "new_causal_models", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                ", "causal_model", ".", "set_causal_mechanism", "(", "nodes", "[", "i", "]", ",", "old_causal_models", "[", "i", "]", ")", "\n", "\n", "", "", "for", "node", "in", "causal_model", ".", "graph", ".", "nodes", ":", "\n", "            ", "causal_model", ".", "graph", ".", "nodes", "[", "node", "]", "[", "PARENTS_DURING_FIT", "]", "=", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "node", ")", "\n", "\n", "", "target_samples_new", "=", "draw_samples", "(", "causal_model", ",", "num_samples", ")", "[", "target_node", "]", ".", "to_numpy", "(", ")", "\n", "\n", "return", "difference_estimation_func", "(", "target_samples_old", ",", "target_samples_new", ")", "\n", "\n", "", "attributions", "=", "estimate_shapley_values", "(", "attribution_set_function", ",", "len", "(", "old_causal_models", ")", ",", "shapley_config", ")", "\n", "\n", "return", "{", "x", ":", "attributions", "[", "i", "]", "for", "i", ",", "x", "in", "enumerate", "(", "sorted", "(", "causal_model_old", ".", "graph", ".", "nodes", ")", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.estimate_distribution_change_scores": [[282, 362], ["dowhy.gcm.graph.validate_causal_dag", "distribution_change._check_significant_mechanism_change", "tqdm.tqdm", "dowhy.gcm.graph.is_root_node", "difference_estimation_func", "dowhy.gcm.graph.get_ordered_predecessors", "distribution_change._estimate_distribution_change_score", "original_data[].to_numpy", "new_data[].to_numpy", "original_data[].to_numpy", "new_data[].to_numpy", "new_data[].to_numpy", "causal_model.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change._check_significant_mechanism_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change._estimate_distribution_change_score", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "def", "estimate_distribution_change_scores", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "\n", "original_data", ":", "pd", ".", "DataFrame", ",", "\n", "new_data", ":", "pd", ".", "DataFrame", ",", "\n", "difference_estimation_func", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "\n", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", "\n", "=", "auto_estimate_kl_divergence", ",", "\n", "max_num_evaluation_samples", ":", "int", "=", "1000", ",", "\n", "num_joint_samples", ":", "int", "=", "500", ",", "\n", "early_stopping_percentage", ":", "float", "=", "0.01", ",", "\n", "mechanism_change_test_func", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "\n", "np", ".", "ndarray", ",", "\n", "Optional", "[", "np", ".", "ndarray", "]", ",", "\n", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "float", "]", "\n", "=", "mechanism_change_test", ",", "\n", "mechanism_change_test_significance_level", ":", "float", "=", "0.05", ",", "\n", "mechanism_change_test_fdr_control_method", ":", "Optional", "[", "str", "]", "=", "'fdr_bh'", ")", "->", "Dict", "[", "Any", ",", "float", "]", ":", "\n", "    ", "\"\"\"Given newly observed and original samples from the joint distribution of the given causal graphical model, this\n    method estimates a score for each node that quantifies how much the distribution of the node has changed. For this,\n    it first checks whether the underlying causal mechanism has changed at all and, if this is the case, it estimates\n    the difference between the new and original distributions. The score is based on the quantity measured by the\n    provided difference_estimation_func or 0 if no mechanism change has been detected.\n\n    Note that for each parent sample, num_joint_samples conditional samples are generated based on the original and new\n    causal mechanism and evaluated by the given difference_estimation_func function. These results are then averaged\n    over multiple different parent samples.\n\n    :param causal_model: The underlying causal model based on the original data.\n    :param original_data: Samples from the original data.\n    :param new_data: Samples from the new data.\n    :param difference_estimation_func: Function for quantifying the distribution change. This function should expect\n                                       two inputs which represent samples from two different distributions. An example\n                                       could be the KL divergence.\n    :param max_num_evaluation_samples: Maximum number of (parent) samples for evaluating the difference in\n                                       distributions.\n    :param num_joint_samples: Number of samples generated in a node per parent sample.\n    :param early_stopping_percentage: If the change in percentage between multiple consecutive runs is below this\n                                      threshold, the evaluation stops before evaluating all max_num_evaluation_samples.\n    :param mechanism_change_test_func: Function for testing whether the causal mechanism of a node has changed. This\n                                       function should return a p\u2013value for the null hypothesis that the mechanism has\n                                       not changed.\n    :param mechanism_change_test_significance_level: A significance level for rejecting the null hypothesis that the\n                                                     causal mechanism of a node has not changed.\n    :param mechanism_change_test_fdr_control_method: The false discovery rate control method for mechanism change\n                                                     tests. For more options, checkout `statsmodels manual\n                                                     <https://www.statsmodels.org/dev/generated/statsmodels.stats.multitest.multipletests.html>`_.\n    :return: A dictionary assining a score to each node in the causal graph.\n    \"\"\"", "\n", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "mechanism_changed_for_node", "=", "_check_significant_mechanism_change", "(", "causal_model", ".", "graph", ",", "\n", "original_data", ",", "\n", "new_data", ",", "\n", "mechanism_change_test_func", ",", "\n", "mechanism_change_test_significance_level", ",", "\n", "mechanism_change_test_fdr_control_method", ")", "\n", "\n", "results", "=", "{", "}", "\n", "for", "node", "in", "tqdm", "(", "causal_model", ".", "graph", ".", "nodes", ",", "desc", "=", "'Estimating mechanism change anomaly scores'", ",", "position", "=", "0", ",", "\n", "leave", "=", "True", ")", ":", "\n", "        ", "if", "mechanism_changed_for_node", "[", "node", "]", ":", "\n", "            ", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "node", ")", ":", "\n", "                ", "results", "[", "node", "]", "=", "difference_estimation_func", "(", "original_data", "[", "node", "]", ".", "to_numpy", "(", ")", ",", "\n", "new_data", "[", "node", "]", ".", "to_numpy", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "parent_nodes", "=", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "node", ")", "\n", "results", "[", "node", "]", "=", "_estimate_distribution_change_score", "(", "\n", "original_data", "[", "parent_nodes", "]", ".", "to_numpy", "(", ")", ",", "\n", "new_data", "[", "parent_nodes", "]", ".", "to_numpy", "(", ")", ",", "\n", "new_data", "[", "node", "]", ".", "to_numpy", "(", ")", ",", "\n", "causal_model", ".", "causal_mechanism", "(", "node", ")", ",", "\n", "difference_estimation_func", ",", "\n", "max_num_evaluation_samples", ",", "\n", "num_joint_samples", ",", "\n", "early_stopping_percentage", ")", "\n", "", "", "else", ":", "\n", "            ", "results", "[", "node", "]", "=", "0", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change._check_significant_mechanism_change": [[364, 394], ["dict", "dowhy.gcm.graph.is_root_node", "all_p_values.append", "zip", "old_data[].to_numpy", "new_data[].to_numpy", "mechanism_change_func", "numpy.array", "statsmodels.stats.multitest.multipletests", "old_data[].to_numpy", "new_data[].to_numpy", "dowhy.gcm.graph.get_ordered_predecessors", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "def", "_check_significant_mechanism_change", "(", "graph", ":", "DirectedGraph", ",", "\n", "old_data", ":", "pd", ".", "DataFrame", ",", "\n", "new_data", ":", "pd", ".", "DataFrame", ",", "\n", "mechanism_change_func", ":", "\n", "Callable", "[", "[", "np", ".", "ndarray", ",", "\n", "np", ".", "ndarray", ",", "\n", "Optional", "[", "np", ".", "ndarray", "]", ",", "\n", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "float", "]", ",", "\n", "significance_level", ":", "float", ",", "\n", "fdr_control_method", ":", "Optional", "[", "str", "]", ")", "->", "Dict", "[", "Any", ",", "bool", "]", ":", "\n", "    ", "all_p_values", "=", "[", "]", "\n", "for", "node", "in", "graph", ".", "nodes", ":", "\n", "        ", "if", "is_root_node", "(", "graph", ",", "node", ")", ":", "\n", "            ", "parents_org_data", "=", "None", "\n", "parents_new_data", "=", "None", "\n", "", "else", ":", "\n", "            ", "parents_org_data", "=", "old_data", "[", "get_ordered_predecessors", "(", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", "\n", "parents_new_data", "=", "new_data", "[", "get_ordered_predecessors", "(", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", "\n", "\n", "", "all_p_values", ".", "append", "(", "mechanism_change_func", "(", "old_data", "[", "node", "]", ".", "to_numpy", "(", ")", ",", "\n", "new_data", "[", "node", "]", ".", "to_numpy", "(", ")", ",", "\n", "parents_org_data", ",", "\n", "parents_new_data", ")", ")", "\n", "\n", "", "if", "fdr_control_method", "is", "None", ":", "\n", "        ", "successes", "=", "np", ".", "array", "(", "all_p_values", ")", "<=", "significance_level", "\n", "", "else", ":", "\n", "        ", "successes", "=", "multipletests", "(", "all_p_values", ",", "significance_level", ",", "method", "=", "fdr_control_method", ")", "[", "0", "]", "\n", "\n", "", "return", "dict", "(", "zip", "(", "graph", ".", "nodes", ",", "successes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change._estimate_distribution_change_score": [[396, 434], ["dowhy.gcm.util.general.shape_into_2d", "causal_model_original.clone", "causal_model_original.clone.fit", "numpy.vstack", "numpy.matlib.repmat", "difference_estimation_func", "numpy.random.choice", "causal_model_original.draw_samples", "causal_model_original.clone.draw_samples", "_logger.info", "min"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["", "def", "_estimate_distribution_change_score", "(", "parent_original_data", ":", "np", ".", "ndarray", ",", "\n", "parent_new_data", ":", "np", ".", "ndarray", ",", "\n", "target_new_data", ":", "np", ".", "ndarray", ",", "\n", "causal_model_original", ":", "ConditionalStochasticModel", ",", "\n", "difference_estimation_func", ":", "\n", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", ",", "\n", "max_num_evaluation_samples", ":", "int", ",", "\n", "num_joint_samples", ":", "int", ",", "\n", "early_stopping_percentage", ":", "float", ")", "->", "float", ":", "\n", "    ", "parent_original_data", ",", "parent_new_data", ",", "target_new_data", "=", "shape_into_2d", "(", "parent_original_data", ",", "parent_new_data", ",", "target_new_data", ")", "\n", "causal_model_new", "=", "causal_model_original", ".", "clone", "(", ")", "\n", "causal_model_new", ".", "fit", "(", "X", "=", "parent_new_data", ",", "Y", "=", "target_new_data", ")", "\n", "\n", "joint_parent_samples", "=", "np", ".", "vstack", "(", "[", "parent_original_data", ",", "parent_new_data", "]", ")", "\n", "joint_parent_samples", "=", "joint_parent_samples", "[", "np", ".", "random", ".", "choice", "(", "joint_parent_samples", ".", "shape", "[", "0", "]", ",", "\n", "min", "(", "joint_parent_samples", ".", "shape", "[", "0", "]", ",", "\n", "max_num_evaluation_samples", ")", ",", "\n", "replace", "=", "False", ")", "]", "\n", "\n", "result", "=", "0", "\n", "run", "=", "0", "\n", "for", "joint_parent_sample", "in", "joint_parent_samples", ":", "\n", "        ", "old_result", "=", "result", "\n", "\n", "samples", "=", "repmat", "(", "joint_parent_sample", ",", "num_joint_samples", ",", "1", ")", "\n", "result", "+=", "difference_estimation_func", "(", "causal_model_original", ".", "draw_samples", "(", "samples", ")", ",", "\n", "causal_model_new", ".", "draw_samples", "(", "samples", ")", ")", "\n", "\n", "run", "+=", "1", "\n", "if", "old_result", "!=", "0", "and", "(", "1", "-", "result", "/", "old_result", ")", "<=", "early_stopping_percentage", ":", "\n", "# If the relative change of the score is less than the given threshold, we stop the estimation early.", "\n", "            ", "_logger", ".", "info", "(", "\"Early stopping: Result only changed by %f percent and a threshold of %f is set.\"", "\n", "%", "(", "1", "-", "result", "/", "old_result", ",", "early_stopping_percentage", ")", ")", "\n", "break", "\n", "\n", "", "", "return", "result", "/", "run", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.ProbabilisticCausalModel.__init__": [[19, 31], ["networkx.DiGraph"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "graph", ":", "Optional", "[", "DirectedGraph", "]", "=", "None", ",", "\n", "graph_copier", ":", "Callable", "[", "[", "DirectedGraph", "]", ",", "DirectedGraph", "]", "=", "nx", ".", "DiGraph", ")", ":", "\n", "        ", "\"\"\"\n        :param graph: Optional graph object to be used as causal graph.\n        :param graph_copier: Optional function that can copy a causal graph. Defaults to a networkx.DiGraph\n                             constructor.\n        \"\"\"", "\n", "if", "graph", "is", "None", ":", "\n", "            ", "graph", "=", "nx", ".", "DiGraph", "(", ")", "\n", "", "self", ".", "graph", "=", "graph", "\n", "self", ".", "graph_copier", "=", "graph_copier", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.ProbabilisticCausalModel.set_causal_mechanism": [[32, 43], ["ValueError"], "methods", ["None"], ["", "def", "set_causal_mechanism", "(", "self", ",", "node", ":", "Any", ",", "mechanism", ":", "Union", "[", "StochasticModel", ",", "ConditionalStochasticModel", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"Assigns the generative causal model of node in the causal graph.\n\n        :param node: Target node whose causal model is to be assigned.\n        :param mechanism: Causal mechanism to be assigned. A root node must be a\n                          :class:`~dowhy.gcm.graph.StochasticModel`, whereas a non-root node must be a\n                          :class:`~dowhy.gcm.graph.ConditionalStochasticModel`.\n        \"\"\"", "\n", "if", "node", "not", "in", "self", ".", "graph", ".", "nodes", ":", "\n", "            ", "raise", "ValueError", "(", "\"Node %s can not be found in the given graph!\"", "%", "node", ")", "\n", "", "self", ".", "graph", ".", "nodes", "[", "node", "]", "[", "CAUSAL_MECHANISM", "]", "=", "mechanism", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.ProbabilisticCausalModel.causal_mechanism": [[44, 53], ["None"], "methods", ["None"], ["", "def", "causal_mechanism", "(", "self", ",", "node", ":", "Any", ")", "->", "Union", "[", "StochasticModel", ",", "ConditionalStochasticModel", "]", ":", "\n", "        ", "\"\"\"Returns the generative causal model of node in the causal graph.\n\n        :param node: Target node whose causal model is to be assigned.\n        :returns: The causal mechanism for this node. A root node is of type\n                  :class:`~dowhy.gcm.graph.StochasticModel`, whereas a non-root node is of type\n                  :class:`~dowhy.gcm.graph.ConditionalStochasticModel`.\n        \"\"\"", "\n", "return", "self", ".", "graph", ".", "nodes", "[", "node", "]", "[", "CAUSAL_MECHANISM", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.ProbabilisticCausalModel.clone": [[54, 59], ["cms.ProbabilisticCausalModel.graph_copier", "dowhy.gcm.graph.clone_causal_models", "cms.ProbabilisticCausalModel.__class__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.clone_causal_models"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "\"\"\"Clones the causal model, but keeps causal mechanisms untrained.\"\"\"", "\n", "graph_copy", "=", "self", ".", "graph_copier", "(", "self", ".", "graph", ")", "\n", "clone_causal_models", "(", "self", ".", "graph", ",", "graph_copy", ")", "\n", "return", "self", ".", "__class__", "(", "graph_copy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.StructuralCausalModel.set_causal_mechanism": [[67, 69], ["cms.ProbabilisticCausalModel.set_causal_mechanism"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism"], ["def", "set_causal_mechanism", "(", "self", ",", "node", ":", "Any", ",", "mechanism", ":", "Union", "[", "StochasticModel", ",", "FunctionalCausalModel", "]", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "set_causal_mechanism", "(", "node", ",", "mechanism", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.StructuralCausalModel.causal_mechanism": [[70, 72], ["cms.ProbabilisticCausalModel.causal_mechanism"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "def", "causal_mechanism", "(", "self", ",", "node", ":", "Any", ")", "->", "Union", "[", "StochasticModel", ",", "FunctionalCausalModel", "]", ":", "\n", "        ", "return", "super", "(", ")", ".", "causal_mechanism", "(", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism": [[82, 85], ["cms.StructuralCausalModel.set_causal_mechanism"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism"], ["def", "set_causal_mechanism", "(", "self", ",", "target_node", ":", "Any", ",", "\n", "mechanism", ":", "Union", "[", "StochasticModel", ",", "InvertibleFunctionalCausalModel", "]", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "set_causal_mechanism", "(", "target_node", ",", "mechanism", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism": [[86, 88], ["cms.StructuralCausalModel.causal_mechanism"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "def", "causal_mechanism", "(", "self", ",", "node", ":", "Any", ")", "->", "Union", "[", "StochasticModel", ",", "InvertibleFunctionalCausalModel", "]", ":", "\n", "        ", "return", "super", "(", ")", ".", "causal_mechanism", "(", "node", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer": [[16, 52], ["numpy.array", "ValueError", "numpy.ones", "ValueError", "float", "float", "abs", "min", "numpy.isnan", "numpy.isnan", "numpy.quantile"], "function", ["None"], ["def", "quantile_based_fwer", "(", "p_values", ":", "Union", "[", "np", ".", "ndarray", ",", "List", "[", "float", "]", "]", ",", "\n", "p_values_scaling", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "quantile", ":", "float", "=", "0.5", ")", "->", "float", ":", "\n", "    ", "\"\"\"Applies a quantile based family wise error rate (FWER) control to the given p-values. This is based on the\n    approach described in:\n\n    Meinshausen, N., Meier, L. and Buehlmann, P. (2009).\n    p-values for high-dimensional regression. J. Amer. Statist. Assoc.104 1671\u20131681\n\n    :param p_values: A list or array of p-values.\n    :param p_values_scaling: An optional list of scaling factors for each p-value.\n    :param quantile: The quantile used for the p-value adjustment. By default, this is the median (0.5).\n    :return: The p-value that lies on the quantile threshold. Note that this is the quantile based on scaled values\n             p_values / quantile.\n    \"\"\"", "\n", "\n", "if", "quantile", "<=", "0", "or", "abs", "(", "quantile", "-", "1", ")", ">=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"The given quantile is %f, but it needs to be on (0, 1]!\"", "%", "quantile", ")", "\n", "\n", "", "p_values", "=", "np", ".", "array", "(", "p_values", ")", "\n", "if", "p_values_scaling", "is", "None", ":", "\n", "        ", "p_values_scaling", "=", "np", ".", "ones", "(", "p_values", ".", "shape", "[", "0", "]", ")", "\n", "\n", "", "if", "p_values", ".", "shape", "!=", "p_values_scaling", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "\"The p-value scaling array needs to have the same dimension as the given p-values.\"", ")", "\n", "\n", "", "p_values_scaling", "=", "p_values_scaling", "[", "~", "np", ".", "isnan", "(", "p_values", ")", "]", "\n", "p_values", "=", "p_values", "[", "~", "np", ".", "isnan", "(", "p_values", ")", "]", "\n", "\n", "p_values", "=", "p_values", "*", "p_values_scaling", "\n", "p_values", "[", "p_values", ">", "1", "]", "=", "1.0", "\n", "\n", "if", "p_values", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "        ", "return", "float", "(", "p_values", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "float", "(", "min", "(", "1.0", ",", "np", ".", "quantile", "(", "p_values", "/", "quantile", ",", "quantile", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation": [[54, 149], ["dowhy.gcm.util.general.shape_into_2d", "numpy.array", "numpy.delete", "numpy.matlib.repmat", "range", "numpy.array", "numpy.arange", "stats.permute_features", "range", "numpy.array", "range", "stats.permute_features", "ValueError", "prediction_method", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.permute_features", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.permute_features"], ["", "", "def", "marginal_expectation", "(", "prediction_method", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "feature_samples", ":", "np", ".", "ndarray", ",", "\n", "baseline_samples", ":", "np", ".", "ndarray", ",", "\n", "baseline_feature_indices", ":", "List", "[", "int", "]", ",", "\n", "return_averaged_results", ":", "bool", "=", "True", ",", "\n", "feature_perturbation", ":", "str", "=", "'randomize_columns_jointly'", ",", "\n", "max_batch_size", ":", "int", "=", "-", "1", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Estimates the marginal expectation for samples in baseline_noise_samples when randomizing features that are not\n    part of baseline_feature_indices. This is, this function estimates\n        y^i = E[Y | do(x^i_s)] := \\\\int_x_s' E[Y | x^i_s, x_s'] p(x_s') d x_s',\n    where x^i_s is the i-th sample from baseline_noise_samples, s denotes the baseline_feature_indices and\n    x_s' ~ X_s' denotes the randomized features that are not in s. For an approximation of the integral, the given\n    prediction_method is evaluated multiple times for the same x^i_s, but different x_s' ~ X_s'.\n\n    :param prediction_method: Prediction method of interest. This should expect a numpy array as input for making\n    predictions.\n    :param feature_samples: Samples from the joint distribution. These are used for randomizing the features that are not in\n                            baseline_feature_indices.\n    :param baseline_samples: Samples for which the marginal expectation should be estimated.\n    :param baseline_feature_indices: Column indices of the features in s. These values for these features are remain constant\n                                     when estimating the expectation.\n    :param return_averaged_results: If set to True, the expectation over all evaluated samples for the i-th\n    baseline_noise_samples is returned. If set to False, all corresponding results for the i-th sample are returned.\n    :param feature_perturbation: Type of feature permutation:\n        'randomize_columns_independently': Each feature not in s is randomly permuted separately.\n        'randomize_columns_jointly': All features not in s are jointly permuted. Note that this still represents an\n        interventional distribution.\n    :param max_batch_size: Maximum batch size for a estimating the predictions. This has a significant influence on the\n    overall memory usage. If set to -1, all samples are used in one batch.\n    :return: If return_averaged_results is False, a numpy array where the i-th entry belongs to the marginal expectation\n    of x^i_s when randomizing the remaining features.\n    If return_averaged_results is True, a two dimensional numpy array where the i-th entry contains all\n    predictions for x^i_s when randomizing the remaining features.\n    \"\"\"", "\n", "feature_samples", ",", "baseline_samples", "=", "shape_into_2d", "(", "feature_samples", ",", "baseline_samples", ")", "\n", "\n", "batch_size", "=", "baseline_samples", ".", "shape", "[", "0", "]", "if", "max_batch_size", "==", "-", "1", "else", "max_batch_size", "\n", "result", "=", "[", "np", ".", "nan", "]", "*", "baseline_samples", ".", "shape", "[", "0", "]", "\n", "\n", "# Make copy to avoid manipulating the original matrix.", "\n", "feature_samples", "=", "np", ".", "array", "(", "feature_samples", ")", "\n", "\n", "features_to_randomize", "=", "np", ".", "delete", "(", "np", ".", "arange", "(", "0", ",", "feature_samples", ".", "shape", "[", "1", "]", ")", ",", "baseline_feature_indices", ")", "\n", "\n", "if", "feature_perturbation", "==", "'randomize_columns_independently'", ":", "\n", "        ", "feature_samples", "=", "permute_features", "(", "feature_samples", ",", "features_to_randomize", ",", "False", ")", "\n", "", "elif", "feature_perturbation", "==", "'randomize_columns_jointly'", ":", "\n", "        ", "feature_samples", "=", "permute_features", "(", "feature_samples", ",", "features_to_randomize", ",", "True", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown argument %s as feature_perturbation type!\"", "%", "feature_perturbation", ")", "\n", "\n", "# The given prediction method has to be evaluated multiple times on a large amount of different inputs. Typically,", "\n", "# the batch evaluation of a prediction model on multiple inputs at the same time is significantly faster", "\n", "# than evaluating it on single simples in a for-loop. To make use of this, we try to evaluate as many samples as", "\n", "# possible in one batch call of the prediction method. However, this also requires a lot of memory for many samples.", "\n", "# To overcome potential memory issues, multiple batch calls are performed, each with at most batch_size many", "\n", "# samples. The number of samples that are evaluated is normally", "\n", "# baseline_noise_samples.shape[0] * feature_samples.shape[0]. Here, we reduce it to", "\n", "# batch_size * feature_samples.shape[0]. If the batch_size would be set 1, then each baseline_noise_samples is", "\n", "# evaluated one by one in a for-loop.", "\n", "", "inputs", "=", "repmat", "(", "feature_samples", ",", "batch_size", ",", "1", ")", "\n", "for", "offset", "in", "range", "(", "0", ",", "baseline_samples", ".", "shape", "[", "0", "]", ",", "batch_size", ")", ":", "\n", "# Each batch consist of at most batch_size * feature_samples.shape[0] many samples. If there are multiple", "\n", "# batches, the offset indicates the index of the current baseline_noise_samples that has not been evaluated yet.", "\n", "        ", "if", "offset", "+", "batch_size", ">", "baseline_samples", ".", "shape", "[", "0", "]", ":", "\n", "# If the batch size would be larger than the remaining amount of samples, it is reduced to only include the", "\n", "# remaining baseline_noise_samples.", "\n", "            ", "adjusted_batch_size", "=", "baseline_samples", ".", "shape", "[", "0", "]", "-", "offset", "\n", "inputs", "=", "inputs", "[", ":", "adjusted_batch_size", "*", "feature_samples", ".", "shape", "[", "0", "]", "]", "\n", "", "else", ":", "\n", "            ", "adjusted_batch_size", "=", "batch_size", "\n", "\n", "", "for", "index", "in", "range", "(", "adjusted_batch_size", ")", ":", "\n", "# The inputs consist of batch_size many copies of feature_samples. Here, we set the columns of the features", "\n", "# in baseline_feature_indices to their respective values in baseline_noise_samples.", "\n", "            ", "inputs", "[", "index", "*", "feature_samples", ".", "shape", "[", "0", "]", ":", "(", "index", "+", "1", ")", "*", "feature_samples", ".", "shape", "[", "0", "]", ",", "\n", "baseline_feature_indices", "]", "=", "baseline_samples", "[", "offset", "+", "index", ",", "baseline_feature_indices", "]", "\n", "\n", "# After creating the (potentially large) input data matrix, we can evaluate the prediction method.", "\n", "", "predictions", "=", "np", ".", "array", "(", "prediction_method", "(", "inputs", ")", ")", "\n", "\n", "for", "index", "in", "range", "(", "adjusted_batch_size", ")", ":", "\n", "# Here, offset + index now indicates the sample index in baseline_noise_samples.", "\n", "            ", "if", "return_averaged_results", ":", "\n", "# This would average all prediction results obtained for the 'offset + index'-th sample in", "\n", "# baseline_noise_samples. This is, y^(offset + index) = E[Y | do(x^(offset + index)_s)].", "\n", "                ", "result", "[", "offset", "+", "index", "]", "=", "np", ".", "mean", "(", "predictions", "[", "index", "*", "feature_samples", ".", "shape", "[", "0", "]", ":", "\n", "(", "index", "+", "1", ")", "*", "feature_samples", ".", "shape", "[", "0", "]", "]", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "# This would return all prediction results obtained for the 'offset + index'-th sample in", "\n", "# baseline_noise_samples, i.e. the results are not averaged.", "\n", "                ", "result", "[", "offset", "+", "index", "]", "=", "predictions", "[", "index", "*", "feature_samples", ".", "shape", "[", "0", "]", ":", "\n", "(", "index", "+", "1", ")", "*", "feature_samples", ".", "shape", "[", "0", "]", "]", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.permute_features": [[151, 169], ["numpy.array", "numpy.random.shuffle", "numpy.random.choice"], "function", ["None"], ["", "def", "permute_features", "(", "feature_samples", ":", "np", ".", "ndarray", ",", "\n", "features_to_permute", ":", "Union", "[", "List", "[", "int", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "randomize_features_jointly", ":", "bool", ")", "->", "np", ".", "ndarray", ":", "\n", "# Making copy to ensure that the original object is not modified.", "\n", "    ", "feature_samples", "=", "np", ".", "array", "(", "feature_samples", ")", "\n", "\n", "if", "randomize_features_jointly", ":", "\n", "# Permute samples jointly. This still represents an interventional distribution.", "\n", "        ", "feature_samples", "[", ":", ",", "features_to_permute", "]", "=", "feature_samples", "[", "np", ".", "random", ".", "choice", "(", "feature_samples", ".", "shape", "[", "0", "]", ",", "\n", "feature_samples", ".", "shape", "[", "0", "]", ",", "\n", "replace", "=", "False", ")", "]", "[", ":", ",", "features_to_permute", "]", "\n", "", "else", ":", "\n", "# Permute samples independently.", "\n", "        ", "for", "feature", "in", "features_to_permute", ":", "\n", "            ", "np", ".", "random", ".", "shuffle", "(", "feature_samples", "[", ":", ",", "feature", "]", ")", "\n", "\n", "", "", "return", "feature_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.estimate_ftest_pvalue": [[171, 232], ["dowhy.gcm.util.general.shape_into_2d", "numpy.sum", "scipy.stats.f.sf", "dowhy.gcm.util.general.shape_into_2d", "X_training_b.reshape.reshape", "X_test_b.reshape.reshape", "ValueError", "numpy.sum", "numpy.sum", "sklearn.linear_model.LinearRegression().fit().predict", "sklearn.linear_model.LinearRegression().fit().predict", "numpy.mean", "sklearn.linear_model.LinearRegression().fit", "sklearn.linear_model.LinearRegression().fit", "sklearn.linear_model.LinearRegression", "sklearn.linear_model.LinearRegression"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "estimate_ftest_pvalue", "(", "X_training_a", ":", "np", ".", "ndarray", ",", "\n", "X_training_b", ":", "np", ".", "ndarray", ",", "\n", "Y_training", ":", "np", ".", "ndarray", ",", "\n", "X_test_a", ":", "np", ".", "ndarray", ",", "\n", "X_test_b", ":", "np", ".", "ndarray", ",", "\n", "Y_test", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "\"\"\"Estimates the p-value for the null hypothesis that the same regression error with less parameters can be\n    achieved. This is, a linear model trained on a data set A with d number of features has the same performance\n    (in terms of squared error) relative to the number of features as a model trained on a data set B with k number\n    features, where k < d. Here, both data sets need to have the same target values. A small p-value would\n    indicate that the model performances are significantly different.\n\n    Note that all given test samples are utilized in the f-test.\n\n    See https://en.wikipedia.org/wiki/F-test#Regression_problems for more details.\n\n    :param X_training_a: Input training samples for model A.\n    :param X_training_b: Input training samples for model B. These samples should have less features than samples in X_training_a.\n    :param Y_training: Target training values.\n    :param X_test_a: Test samples for model A.\n    :param X_test_b: Test samples for model B.\n    :param Y_test: Test values.\n    :return: A p-value on [0, 1].\n    \"\"\"", "\n", "X_training_a", ",", "X_test_a", "=", "shape_into_2d", "(", "X_training_a", ",", "X_test_a", ")", "\n", "\n", "if", "X_training_b", ".", "size", ">", "0", ":", "\n", "        ", "X_training_b", ",", "X_test_b", "=", "shape_into_2d", "(", "X_training_b", ",", "X_test_b", ")", "\n", "", "else", ":", "\n", "        ", "X_training_b", "=", "X_training_b", ".", "reshape", "(", "0", ",", "0", ")", "\n", "X_test_b", "=", "X_test_b", ".", "reshape", "(", "0", ",", "0", ")", "\n", "\n", "", "if", "X_training_a", ".", "shape", "[", "1", "]", "<=", "X_training_b", ".", "shape", "[", "1", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"The data X_training_a should have more dimensions (model parameters) than the data \"", "\n", "\"X_training_b!\"", ")", "\n", "\n", "", "ssr_a", "=", "np", ".", "sum", "(", "\n", "(", "Y_test", "-", "LinearRegression", "(", ")", ".", "fit", "(", "X_training_a", ",", "Y_training", ")", ".", "predict", "(", "X_test_a", ")", ")", "**", "2", ")", "\n", "\n", "if", "X_training_b", ".", "shape", "[", "1", "]", ">", "0", ":", "\n", "        ", "ssr_b", "=", "np", ".", "sum", "(", "\n", "(", "Y_test", "-", "LinearRegression", "(", ")", ".", "fit", "(", "X_training_b", ",", "Y_training", ")", ".", "predict", "(", "X_test_b", ")", ")", "**", "2", ")", "\n", "", "else", ":", "\n", "        ", "ssr_b", "=", "np", ".", "sum", "(", "(", "Y_test", "-", "np", ".", "mean", "(", "Y_test", ")", ")", "**", "2", ")", "\n", "\n", "", "dof_diff_1", "=", "(", "X_test_a", ".", "shape", "[", "1", "]", "-", "X_test_b", ".", "shape", "[", "1", "]", ")", "# p1 - p2", "\n", "dof_diff_2", "=", "(", "X_test_a", ".", "shape", "[", "0", "]", "-", "X_test_a", ".", "shape", "[", "1", "]", "-", "1", ")", "# n - p2 (parameters include intercept)", "\n", "\n", "f_statistic", "=", "(", "ssr_b", "-", "ssr_a", ")", "/", "dof_diff_1", "*", "dof_diff_2", "\n", "\n", "if", "ssr_a", "<", "EPS", ":", "\n", "        ", "ssr_a", "=", "0", "\n", "", "if", "ssr_b", "<", "EPS", ":", "\n", "        ", "ssr_b", "=", "0", "\n", "\n", "", "if", "ssr_a", "==", "0", "and", "ssr_b", "==", "0", ":", "\n", "        ", "f_statistic", "=", "0", "\n", "", "elif", "ssr_a", "!=", "0", ":", "\n", "        ", "f_statistic", "/=", "ssr_a", "\n", "\n", "", "return", "stats", ".", "f", ".", "sf", "(", "f_statistic", ",", "dof_diff_1", ",", "dof_diff_2", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.compute_data_from_noise": [[13, 29], ["dowhy.gcm.graph.validate_causal_dag", "list", "pandas.DataFrame", "networkx.topological_sort", "numpy.empty", "dowhy.gcm.graph.is_root_node", "noise_data[].to_numpy", "causal_model.causal_mechanism().evaluate", "len", "data[].to_numpy", "noise_data[].to_numpy", "causal_model.causal_mechanism", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["def", "compute_data_from_noise", "(", "causal_model", ":", "StructuralCausalModel", ",", "\n", "noise_data", ":", "pd", ".", "DataFrame", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "sorted_nodes", "=", "list", "(", "nx", ".", "topological_sort", "(", "causal_model", ".", "graph", ")", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "np", ".", "empty", "(", "(", "noise_data", ".", "shape", "[", "0", "]", ",", "len", "(", "sorted_nodes", ")", ")", ")", ",", "columns", "=", "sorted_nodes", ")", "\n", "\n", "for", "node", "in", "sorted_nodes", ":", "\n", "        ", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "node", ")", ":", "\n", "            ", "data", "[", "node", "]", "=", "noise_data", "[", "node", "]", ".", "to_numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "data", "[", "node", "]", "=", "causal_model", ".", "causal_mechanism", "(", "node", ")", ".", "evaluate", "(", "\n", "data", "[", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", ",", "\n", "noise_data", "[", "node", "]", ".", "to_numpy", "(", ")", ")", "\n", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.compute_noise_from_data": [[31, 46], ["dowhy.gcm.graph.validate_causal_dag", "list", "pandas.DataFrame", "networkx.topological_sort", "numpy.empty", "dowhy.gcm.graph.is_root_node", "observed_data[].to_numpy", "causal_model.causal_mechanism().estimate_noise", "len", "observed_data[].to_numpy", "_noise._parent_samples_of", "causal_model.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.estimate_noise", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._parent_samples_of", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "def", "compute_noise_from_data", "(", "causal_model", ":", "InvertibleStructuralCausalModel", ",", "observed_data", ":", "pd", ".", "DataFrame", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "sorted_noise", "=", "list", "(", "nx", ".", "topological_sort", "(", "causal_model", ".", "graph", ")", ")", "\n", "noise", "=", "pd", ".", "DataFrame", "(", "np", ".", "empty", "(", "(", "observed_data", ".", "shape", "[", "0", "]", ",", "len", "(", "sorted_noise", ")", ")", ")", ",", "columns", "=", "sorted_noise", ")", "\n", "\n", "for", "node", "in", "sorted_noise", ":", "\n", "        ", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "node", ")", ":", "\n", "            ", "noise", "[", "node", "]", "=", "observed_data", "[", "node", "]", ".", "to_numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "noise", "[", "node", "]", "=", "causal_model", ".", "causal_mechanism", "(", "node", ")", ".", "estimate_noise", "(", "\n", "observed_data", "[", "node", "]", ".", "to_numpy", "(", ")", ",", "\n", "_parent_samples_of", "(", "node", ",", "causal_model", ",", "observed_data", ")", ")", "\n", "\n", "", "", "return", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.get_noise_dependent_function": [[48, 93], ["dowhy.gcm.graph.validate_causal_dag", "_noise._get_approx_noise_dependent_function", "_noise._get_exact_noise_dependent_function", "dowhy.gcm.cms.StructuralCausalModel", "dowhy.gcm.cms.StructuralCausalModel", "dowhy.gcm.graph.node_connected_subgraph_view", "dowhy.gcm.graph.node_connected_subgraph_view"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._get_approx_noise_dependent_function", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._get_exact_noise_dependent_function", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view"], ["", "def", "get_noise_dependent_function", "(", "causal_model", ":", "StructuralCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "approx_prediction_model", ":", "Optional", "[", "PredictionModel", "]", "=", "None", ",", "\n", "num_training_samples", ":", "int", "=", "20000", ")", "->", "Tuple", "[", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "List", "[", "Any", "]", "]", ":", "\n", "    ", "\"\"\"Returns a function that represents the given target_node and that is only dependent on upstream noise nodes.\n    This is, Y = f(N_0, N_1, ..., N_n), where Y is the target node and N_i the noise node of an upstream node. Since\n    the order of the noise variables can be ambiguous, this method also returns a list with the expected order of the\n    noise variables indicated by the name of the corresponding node. For instance:\n    Lets say we have a target variable X4 which has only 2 other upstream variables X1 and X3, then this methods returns\n    a callable that represents X4 = f(N_1, N_3, N_4). This callable expects a numpy array as input. Since the order\n    of the columns in this array is unclear, the method also returns a list with the names of the corresponding columns,\n    e.g. ['X1', 'X3', 'X4']. Note that the noise of X4 will also be an input variable here.\n\n    If an approx_prediction_model is given, the model is used instead to train a model from scratch to represent f.\n    Typically, it would be much faster to evaluate this model than propagating through the graph. The model is trained\n    based on generated noise and target samples from the given causal graph. In theory, the approximated version of f\n    should be close to the \"true\" one based on the underlying SCMs, but there can still be (significant) differences,\n    especially if the provided model is inappropriate for representing f.\n\n    Note: All nodes in the graph that have no direct path to the target node are omitted. The noise node of the\n          target variable itself will also be included here.\n\n    :param causal_model: A structural causal model.\n    :param target_node: The target node for which the function f should be returned.\n    :param approx_prediction_model: Prediction model for approximating f. The model is trained based on drawn noise and\n                                    target samples.\n    :param num_training_samples: Number of drawn samples for training the predictor based on the provided\n                                 approx_prediction_model.\n                                 Note: This parameter is ignored if approx_prediction_model is None.\n    :return: A tuple, where the first value is a callable (the function f) that expects a numpy array X as input and\n    the second value is a list with nodes that represents the expected order of the columns in X.\n    \"\"\"", "\n", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "if", "approx_prediction_model", "is", "not", "None", ":", "\n", "        ", "return", "_get_approx_noise_dependent_function", "(", "\n", "StructuralCausalModel", "(", "node_connected_subgraph_view", "(", "causal_model", ".", "graph", ",", "target_node", ")", ")", ",", "\n", "target_node", ",", "\n", "approx_prediction_model", ",", "\n", "num_training_samples", ")", "\n", "", "else", ":", "\n", "        ", "return", "_get_exact_noise_dependent_function", "(", "\n", "StructuralCausalModel", "(", "node_connected_subgraph_view", "(", "causal_model", ".", "graph", ",", "target_node", ")", ")", ",", "\n", "target_node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._get_exact_noise_dependent_function": [[95, 106], ["list", "networkx.topological_sort", "[].to_numpy", "_noise.compute_data_from_noise", "pandas.DataFrame"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.compute_data_from_noise"], ["", "", "def", "_get_exact_noise_dependent_function", "(", "causal_model", ":", "StructuralCausalModel", ",", "\n", "target_node", ":", "Any", ")", "->", "Tuple", "[", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "List", "[", "Any", "]", "]", ":", "\n", "    ", "nodes_order", "=", "list", "(", "nx", ".", "topological_sort", "(", "causal_model", ".", "graph", ")", ")", "\n", "\n", "def", "predict_method", "(", "noise_samples", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "compute_data_from_noise", "(", "causal_model", ",", "\n", "pd", ".", "DataFrame", "(", "noise_samples", ",", "\n", "columns", "=", "[", "x", "for", "x", "in", "nodes_order", "]", ")", ")", "[", "target_node", "]", ".", "to_numpy", "(", ")", "\n", "\n", "", "return", "predict_method", ",", "nodes_order", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._get_approx_noise_dependent_function": [[108, 122], ["list", "_noise.noise_samples_of_ancestors", "approx_prediction_model.fit", "networkx.topological_sort", "dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.shape_into_2d", "noise_samples[].to_numpy", "node_samples[].to_numpy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.noise_samples_of_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "_get_approx_noise_dependent_function", "(", "causal_model", ":", "StructuralCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "approx_prediction_model", ":", "PredictionModel", ",", "\n", "num_training_samples", ":", "int", ")", "->", "Tuple", "[", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "List", "[", "Any", "]", "]", ":", "\n", "    ", "nodes_order", "=", "list", "(", "nx", ".", "topological_sort", "(", "causal_model", ".", "graph", ")", ")", "\n", "\n", "node_samples", ",", "noise_samples", "=", "noise_samples_of_ancestors", "(", "causal_model", ",", "target_node", ",", "num_training_samples", ")", "\n", "\n", "approx_prediction_model", ".", "fit", "(", "shape_into_2d", "(", "noise_samples", "[", "nodes_order", "]", ".", "to_numpy", "(", ")", ")", ",", "\n", "shape_into_2d", "(", "node_samples", "[", "target_node", "]", ".", "to_numpy", "(", ")", ")", ")", "\n", "\n", "return", "approx_prediction_model", ".", "predict", ",", "nodes_order", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.noise_samples_of_ancestors": [[124, 153], ["list", "networkx.ancestors", "nx.ancestors.update", "pandas.DataFrame", "pandas.DataFrame", "networkx.topological_sort", "numpy.empty", "numpy.empty", "dowhy.gcm.graph.is_root_node", "causal_model.causal_mechanism().draw_samples", "causal_model.causal_mechanism().draw_noise_samples", "causal_model.causal_mechanism().evaluate", "len", "len", "_noise._parent_samples_of", "causal_model.causal_mechanism", "causal_model.causal_mechanism", "causal_model.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.draw_noise_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._parent_samples_of", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "def", "noise_samples_of_ancestors", "(", "causal_model", ":", "StructuralCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "num_samples", ":", "int", ")", "->", "Tuple", "[", "pd", ".", "DataFrame", ",", "pd", ".", "DataFrame", "]", ":", "\n", "    ", "sorted_nodes", "=", "list", "(", "nx", ".", "topological_sort", "(", "causal_model", ".", "graph", ")", ")", "\n", "all_ancestors_of_node", "=", "nx", ".", "ancestors", "(", "causal_model", ".", "graph", ",", "target_node", ")", "\n", "all_ancestors_of_node", ".", "update", "(", "{", "target_node", "}", ")", "\n", "\n", "drawn_samples", "=", "pd", ".", "DataFrame", "(", "np", ".", "empty", "(", "(", "num_samples", ",", "len", "(", "sorted_nodes", ")", ")", ")", ",", "columns", "=", "sorted_nodes", ")", "\n", "drawn_noise_samples", "=", "pd", ".", "DataFrame", "(", "np", ".", "empty", "(", "(", "num_samples", ",", "len", "(", "sorted_nodes", ")", ")", ")", ",", "columns", "=", "sorted_nodes", ")", "\n", "\n", "for", "node", "in", "sorted_nodes", ":", "\n", "        ", "if", "node", "not", "in", "all_ancestors_of_node", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "node", ")", ":", "\n", "            ", "noise", "=", "causal_model", ".", "causal_mechanism", "(", "node", ")", ".", "draw_samples", "(", "num_samples", ")", "\n", "drawn_noise_samples", "[", "node", "]", "=", "noise", "\n", "drawn_samples", "[", "node", "]", "=", "noise", "\n", "", "else", ":", "\n", "            ", "noise", "=", "causal_model", ".", "causal_mechanism", "(", "node", ")", ".", "draw_noise_samples", "(", "num_samples", ")", "\n", "drawn_noise_samples", "[", "node", "]", "=", "noise", "\n", "drawn_samples", "[", "node", "]", "=", "causal_model", ".", "causal_mechanism", "(", "node", ")", ".", "evaluate", "(", "\n", "_parent_samples_of", "(", "node", ",", "causal_model", ",", "drawn_samples", ")", ",", "\n", "noise", ")", "\n", "\n", "", "if", "node", "==", "target_node", ":", "\n", "            ", "break", "\n", "\n", "", "", "return", "drawn_samples", ",", "drawn_noise_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise._parent_samples_of": [[155, 157], ["samples[].to_numpy", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "def", "_parent_samples_of", "(", "node", ":", "Any", ",", "scm", ":", "ProbabilisticCausalModel", ",", "samples", ":", "pd", ".", "DataFrame", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "return", "samples", "[", "get_ordered_predecessors", "(", "scm", ".", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.fit": [[7, 16], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"Fits the anomaly scorer to the given data. Depending on the definition of the scorer, this can imply\n        different things, such as fitting a (parametric) distribution to the data or estimating certain properties\n        such as mean, variance, median etc. that are used for computing a score.\n\n        :param X: Samples from the underlying data distribution.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score": [[17, 20], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "score", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals.estimate_geometric_median": [[17, 22], ["numpy.sum", "scipy.optimize.minimize", "numpy.sqrt", "numpy.sum", "numpy.sum"], "function", ["None"], ["def", "estimate_geometric_median", "(", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "def", "distance_function", "(", "x_input", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "sum", "(", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "(", "x_input", "-", "X", ")", "**", "2", ",", "axis", "=", "1", ")", ")", ")", "\n", "\n", "", "return", "minimize", "(", "distance_function", ",", "np", ".", "sum", "(", "X", ",", "axis", "=", "0", ")", "/", "X", ".", "shape", "[", "0", "]", ")", ".", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals.confidence_intervals": [[24, 116], ["numpy.random.randint", "isinstance", "ValueError", "dowhy.gcm.util.general.set_random_seed", "estimation_func", "joblib.Parallel", "bootstrap_results_summary_func", "dowhy.gcm.util.general.shape_into_2d", "numpy.iinfo", "result.items", "numpy.column_stack", "numpy.array", "bootstrap_results_summary_func", "numpy.array", "joblib.delayed", "enumerate", "tmp_dict.setdefault().append", "confidence_intervals._estimate_percentile_bounds", "tqdm.tqdm", "enumerate", "numpy.array().squeeze", "confidence_intervals._estimate_percentile_bounds", "tmp_dict.setdefault", "tmp_dict.values", "range", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals._estimate_percentile_bounds", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals._estimate_percentile_bounds"], ["", "def", "confidence_intervals", "(", "estimation_func", ":", "Union", "[", "Callable", "[", "[", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "Callable", "[", "[", "]", ",", "Dict", "[", "Any", ",", "float", "]", "]", "]", ",", "\n", "confidence_level", ":", "float", "=", "0.95", ",", "\n", "num_bootstrap_resamples", ":", "int", "=", "20", ",", "\n", "bootstrap_results_summary_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", "\n", "=", "estimate_geometric_median", ",", "\n", "n_jobs", ":", "int", "=", "1", ")", "->", "Tuple", "[", "Union", "[", "np", ".", "ndarray", ",", "Dict", "[", "Any", ",", "np", ".", "ndarray", "]", "]", ",", "Union", "[", "np", ".", "ndarray", ",", "Dict", "[", "Any", ",", "np", ".", "ndarray", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Estimates confidence intervals based on the outputs generated by calling the given estimation_func. Since one result\n    for each repetition is produced, all results can be summarized by the method defined in\n    summary_method_of_bootstrap_results.\n    For instance, summary_method_of_bootstrap_results = lambda x: numpy.mean(x, axis=0) to get the mean over all runs.\n    By default, the geometric median is returned.\n\n    Currently, the confidence intervals are empirically estimated based on the n-th estimated quantiles (without bias\n    correction) of the results, where the quantiles are determined by the given confidence_level.\n\n    NOTE: The outputs of estimation_func are assumed to be pairwise independent. For multidimensional outputs of\n    estimation_func, this could be violated and should be kept in mind. For instance, when evaluating the outcome of\n    interventions in a graph like X -> Y -> Z, the confidence intervals are estimate independently for X, Y and Z\n    although they have a strong dependency. If estimation_func returns one dimensional results, as for instance when\n    estimating the direct arrow strength, then there should be no problem.\n\n    **Example usage with numpy array output:**\n\n        >>> def estimation_func() -> np.ndarray:\n        >>>     return direct_arrow_strength_of_model(causal_model, parent_data)\n        >>>\n        >>> arrow_strengths, confidence_intervals = confidence_intervals(estimation_func)\n\n    **Example usage with dictionary output:**\n\n        >>> def estimation_func() -> Dict[Any, float]:\n        >>>     return distribution_change(\n        >>>             causal_dag, original_observations, outlier_observations, 'X3')\n        >>>\n        >>> mean_contributions, confidence_intervals = confidence_intervals(estimation_func)\n\n    More details about the estimation of confidence intervals via bootstrapping can be found `here <https://ocw.mit.edu/courses/mathematics/18-05-introduction-to-probability-and-statistics-spring-2014/readings/MIT18_05S14_Reading24.pdf>`_.\n\n    :param estimation_func: Function that generates a non-deterministic output for which the confidence interval(s) are\n           estimated.\n    :param confidence_level: Confidence level of the interval.\n    :param num_bootstrap_resamples: Number of samples generated by estimation_func, i.e. number of times\n           is called. The higher the number, the more accurate the results and intervals,\n           but the slower the runtime.\n    :param bootstrap_results_summary_func: Function that takes a numpy array with all results as an input and returns\n           a single (potentially multidimensional) value/vector. For instance, the mean or median\n           over all results.\n    :param n_jobs: Number of parallel jobs. Each repetition can be estimated in parallel.\n           However, since many other functions of the library are already running in parallel (\n           such as distribution change), this is set to 1 by default. Only if it is certain that\n           the estimation_func is not running in parallel internally (e.g. when performing\n           interventions), this should be set to a different value.\n    :return: A tuple (summarized result over all repetitions based on\n             summary_method_of_bootstrap_results, confidence interval for each dimension/variable)\n    \"\"\"", "\n", "if", "num_bootstrap_resamples", "<", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"Number of repetitions should be greater than 0, but got %d\"", "%", "num_bootstrap_resamples", ")", "\n", "\n", "", "def", "estimation_func_with_random_seed", "(", "random_seed", ":", "int", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "Dict", "[", "Any", ",", "float", "]", "]", ":", "\n", "        ", "set_random_seed", "(", "random_seed", ")", "\n", "return", "estimation_func", "(", ")", "\n", "\n", "", "random_seeds", "=", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "num_bootstrap_resamples", ")", "\n", "all_results", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "delayed", "(", "estimation_func_with_random_seed", ")", "(", "random_seed", ")", "\n", "for", "i", ",", "random_seed", "in", "\n", "enumerate", "(", "tqdm", "(", "random_seeds", ",", "\n", "position", "=", "0", ",", "\n", "leave", "=", "True", ",", "\n", "disable", "=", "not", "config", ".", "show_progress_bars", ",", "\n", "desc", "=", "'Estimating boostrap interval...'", ")", ")", ")", "\n", "\n", "if", "isinstance", "(", "all_results", "[", "0", "]", ",", "dict", ")", ":", "\n", "        ", "all_results", ":", "List", "[", "Dict", "[", "Any", ",", "float", "]", "]", "\n", "tmp_dict", "=", "{", "}", "\n", "for", "result", "in", "all_results", ":", "\n", "            ", "for", "key", ",", "value", "in", "result", ".", "items", "(", ")", ":", "\n", "                ", "tmp_dict", ".", "setdefault", "(", "key", ",", "[", "]", ")", ".", "append", "(", "value", ")", "\n", "\n", "", "", "summary_result", "=", "bootstrap_results_summary_func", "(", "np", ".", "column_stack", "(", "[", "v", "for", "v", "in", "tmp_dict", ".", "values", "(", ")", "]", ")", ")", "\n", "\n", "return", "{", "key", ":", "summary_result", "[", "i", "]", "for", "i", ",", "key", "in", "enumerate", "(", "tmp_dict", ")", "}", ",", "{", "key", ":", "_estimate_percentile_bounds", "(", "np", ".", "array", "(", "tmp_dict", "[", "key", "]", ")", ".", "squeeze", "(", ")", ",", "confidence_level", ")", "\n", "for", "key", "in", "tmp_dict", "}", "\n", "", "else", ":", "\n", "        ", "all_results", ":", "np", ".", "ndarray", "=", "shape_into_2d", "(", "np", ".", "array", "(", "all_results", ")", ")", "\n", "\n", "return", "bootstrap_results_summary_func", "(", "all_results", ")", ",", "np", ".", "array", "(", "[", "_estimate_percentile_bounds", "(", "all_results", "[", ":", ",", "i", "]", ",", "confidence_level", ")", "for", "i", "in", "\n", "range", "(", "all_results", ".", "shape", "[", "1", "]", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals._estimate_percentile_bounds": [[118, 123], ["numpy.array", "ValueError", "numpy.percentile", "numpy.percentile"], "function", ["None"], ["", "", "def", "_estimate_percentile_bounds", "(", "X", ":", "np", ".", "ndarray", ",", "quantile", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "if", "X", ".", "ndim", ">", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"Estimate bounds currently only supports one dimensional inputs!\"", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "[", "np", ".", "percentile", "(", "X", ",", "(", "1", "-", "quantile", ")", "*", "100", ")", ",", "np", ".", "percentile", "(", "X", ",", "quantile", "*", "100", ")", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.auto_estimate_kl_divergence": [[12, 19], ["dowhy.gcm.util.general.is_categorical", "divergence.estimate_kl_divergence_categorical", "divergence.is_probability_matrix", "divergence.estimate_kl_divergence_of_probabilities", "divergence.estimate_kl_divergence_continuous"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_categorical", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.is_probability_matrix", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_continuous"], ["def", "auto_estimate_kl_divergence", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "if", "is_categorical", "(", "X", ")", ":", "\n", "        ", "return", "estimate_kl_divergence_categorical", "(", "X", ",", "Y", ")", "\n", "", "elif", "is_probability_matrix", "(", "X", ")", ":", "\n", "        ", "return", "estimate_kl_divergence_of_probabilities", "(", "X", ",", "Y", ")", "\n", "", "else", ":", "\n", "        ", "return", "estimate_kl_divergence_continuous", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_continuous": [[21, 58], ["dowhy.gcm.util.general.shape_into_2d", "float", "int", "sklearn.neighbors.NearestNeighbors().fit", "sklearn.neighbors.NearestNeighbors().fit", "NearestNeighbors().fit.kneighbors", "NearestNeighbors().fit.kneighbors", "RuntimeError", "numpy.sqrt", "numpy.sum", "numpy.log", "sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors", "numpy.log"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "", "def", "estimate_kl_divergence_continuous", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "\"\"\"Estimates KL-Divergence using k-nearest neighbours (Wang et al., 2009).\n\n    Q. Wang, S. R. Kulkarni, and S. Verd\u00fa,\n    \"Divergence estimation for multidimensional densities via k-nearest-neighbor distances\",\n    IEEE Transactions on Information Theory, vol. 55, no. 5, pp. 2392-2405, May 2009.\n\n    :param X: (N_1,D) Sample drawn from distribution P_X\n    :param Y: (N_2,D) Sample drawn from distribution P_Y\n    return: Estimated value of D(P_X||P_Y).\n    \"\"\"", "\n", "X", ",", "Y", "=", "shape_into_2d", "(", "X", ",", "Y", ")", "\n", "\n", "if", "X", ".", "shape", "[", "1", "]", "!=", "Y", ".", "shape", "[", "1", "]", ":", "\n", "        ", "raise", "RuntimeError", "(", "'Samples from X and Y need to have the same dimension, but X has dimension %d and Y has '", "'dimension %d.'", "%", "(", "X", ".", "shape", "[", "1", "]", ",", "Y", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "n", ",", "m", "=", "X", ".", "shape", "[", "0", "]", ",", "Y", ".", "shape", "[", "0", "]", "\n", "d", "=", "float", "(", "X", ".", "shape", "[", "1", "]", ")", "\n", "\n", "k", "=", "int", "(", "np", ".", "sqrt", "(", "n", ")", ")", "\n", "\n", "x_neighbourhood", "=", "NearestNeighbors", "(", "n_neighbors", "=", "k", "+", "1", ")", ".", "fit", "(", "X", ")", "\n", "y_neighbourhood", "=", "NearestNeighbors", "(", "n_neighbors", "=", "k", ")", ".", "fit", "(", "Y", ")", "\n", "\n", "distances_x", ",", "_", "=", "x_neighbourhood", ".", "kneighbors", "(", "X", ",", "n_neighbors", "=", "k", "+", "1", ")", "\n", "distances_y", ",", "_", "=", "y_neighbourhood", ".", "kneighbors", "(", "X", ",", "n_neighbors", "=", "k", ")", "\n", "\n", "rho", "=", "distances_x", "[", ":", ",", "-", "1", "]", "\n", "nu", "=", "distances_y", "[", ":", ",", "-", "1", "]", "\n", "\n", "result", "=", "np", ".", "sum", "(", "(", "d", "/", "n", ")", "*", "np", ".", "log", "(", "(", "nu", "+", "EPS", ")", "/", "(", "rho", "+", "EPS", ")", ")", ")", "+", "np", ".", "log", "(", "m", "/", "(", "n", "-", "1", ")", ")", "\n", "\n", "if", "result", "<", "0", ":", "\n", "        ", "result", "=", "0", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_categorical": [[60, 73], ["dowhy.gcm.util.general.shape_into_2d", "numpy.unique", "numpy.array", "numpy.array", "float", "RuntimeError", "numpy.vstack", "numpy.sum", "numpy.log", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "estimate_kl_divergence_categorical", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "X", ",", "Y", "=", "shape_into_2d", "(", "X", ",", "Y", ")", "\n", "\n", "if", "X", ".", "shape", "[", "1", "]", "!=", "Y", ".", "shape", "[", "1", "]", ":", "\n", "        ", "raise", "RuntimeError", "(", "'Samples from X and Y need to have the same dimension, but X has dimension %d and Y has '", "'dimension %d.'", "%", "(", "X", ".", "shape", "[", "1", "]", ",", "Y", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "all_uniques", "=", "np", ".", "unique", "(", "np", ".", "vstack", "(", "[", "X", ",", "Y", "]", ")", ")", "\n", "\n", "p", "=", "np", ".", "array", "(", "[", "(", "np", ".", "sum", "(", "X", "==", "i", ")", "+", "EPS", ")", "/", "(", "X", ".", "shape", "[", "0", "]", "+", "EPS", ")", "for", "i", "in", "all_uniques", "]", ")", "\n", "q", "=", "np", ".", "array", "(", "[", "(", "np", ".", "sum", "(", "Y", "==", "i", ")", "+", "EPS", ")", "/", "(", "Y", ".", "shape", "[", "0", "]", "+", "EPS", ")", "for", "i", "in", "all_uniques", "]", ")", "\n", "\n", "return", "float", "(", "np", ".", "sum", "(", "p", "*", "np", ".", "log", "(", "p", "/", "q", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_of_probabilities": [[75, 85], ["dowhy.gcm.util.general.shape_into_2d", "float", "RuntimeError", "numpy.mean", "scipy.stats.entropy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy"], ["", "def", "estimate_kl_divergence_of_probabilities", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "\"\"\" Estimates the Kullback-Leibler divergence between each pair of probability vectors (row wise) in X and Y\n    separately and returns the mean over all results. \"\"\"", "\n", "X", ",", "Y", "=", "shape_into_2d", "(", "X", ",", "Y", ")", "\n", "\n", "if", "X", ".", "shape", "[", "1", "]", "!=", "Y", ".", "shape", "[", "1", "]", ":", "\n", "        ", "raise", "RuntimeError", "(", "'Samples from X and Y need to have the same dimension, but X has dimension %d and Y has '", "'dimension %d.'", "%", "(", "X", ".", "shape", "[", "1", "]", ",", "Y", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "return", "float", "(", "np", ".", "mean", "(", "entropy", "(", "X", "+", "EPS", ",", "Y", "+", "EPS", ",", "axis", "=", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.is_probability_matrix": [[87, 92], ["numpy.all", "numpy.all", "numpy.isclose", "numpy.isclose", "numpy.sum", "numpy.sum", "abs", "abs"], "function", ["None"], ["", "def", "is_probability_matrix", "(", "X", ":", "np", ".", "ndarray", ")", "->", "bool", ":", "\n", "    ", "if", "X", ".", "ndim", "==", "1", ":", "\n", "        ", "return", "np", ".", "all", "(", "np", ".", "isclose", "(", "np", ".", "sum", "(", "abs", "(", "X", ")", ",", "axis", "=", "0", ")", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "all", "(", "np", ".", "isclose", "(", "np", ".", "sum", "(", "abs", "(", "X", ")", ",", "axis", "=", "1", ")", ",", "1", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimator.DensityEstimator.fit": [[8, 11], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimator.DensityEstimator.density": [[12, 16], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "density", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Returns the density of each input.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_causal_structure": [[24, 111], ["dict", "dowhy.gcm.graph.get_ordered_predecessors", "validation._get_non_descendants", "dict", "dict", "dict", "numpy.empty", "statsmodels.stats.multitest.multipletests", "dowhy.gcm.graph.get_ordered_predecessors", "conditional_independence_test", "dict", "all_p_values.append", "independence_test", "dict", "all_p_values.append", "numpy.array", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation._get_non_descendants", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.__init__.independence_test"], ["", "def", "refute_causal_structure", "(", "causal_graph", ":", "DirectedGraph", ",", "\n", "data", ":", "pd", ".", "DataFrame", ",", "\n", "independence_test", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", "=", "kernel_based", ",", "\n", "conditional_independence_test", ":", "Callable", "[", "\n", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", "\n", "=", "kernel_based", ",", "\n", "significance_level", ":", "float", "=", "0.05", ",", "\n", "fdr_control_method", ":", "Optional", "[", "str", "]", "=", "'fdr_bh'", ")", "->", "Tuple", "[", "RejectionResult", ",", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Union", "[", "bool", ",", "float", ",", "Dict", "[", "str", ",", "Union", "[", "bool", ",", "float", "]", "]", "]", "]", "]", "]", "]", ":", "\n", "    ", "\"\"\"Validates the assumptions in a causal graph against data. To this end, at each node, we test if the node is dependent on each of its parents, and test the local Markov condition.\n    Note that valid local Markov conditions also imply a valid global Markov condition.\n\n    :param causal_graph: A directed acyclic graph (DAG).\n    :param data: Observations of variables in the DAG.\n    :param independence_test: Independence test to use for checking edge dependencies.\n    :param conditional_independence_test: Conditional independence test to use for checking local Markov condition.\n    :param significance_level: Significance level for (conditional) independence tests.\n    :param fdr_control_method: Method for false discovery rate (FDR) control. For various options, please refer to `this page <https://www.statsmodels.org/dev/generated/statsmodels.stats.multitest.multipletests.html>`_.\n    :return: Outcome of the validation process. The first element of the tuple indicates whether the graph is valid w.r.t. given data, and the second element gives the summary of tests at each node. An example for X->Y->Z:\n\n    .. code-block:: python\n\n        [True, {'X': {'local_markov_test': {}, 'edge_dependence_test': {}},\n                'Y': {'local_markov_test': {}, 'edge_dependence_test': {'X': {'p_value': 0.5, 'fdr_adjusted_p_value': 0.5, 'success': True}}},\n                'Z': {'local_markov_test': {'p_value': 0.0, 'fdr_adjusted_p_value': 0.5, 'success': False},\n                      'edge_dependence_test': {'Y': {'p_value': 0.5, 'fdr_adjusted_p_value': 0.5, 'success': True}}}}]\n    \"\"\"", "\n", "is_dag_valid", "=", "True", "\n", "validation_summary", "=", "dict", "(", ")", "\n", "all_p_values", "=", "[", "]", "\n", "\n", "for", "node", "in", "causal_graph", ".", "nodes", ":", "\n", "        ", "parents", "=", "get_ordered_predecessors", "(", "causal_graph", ",", "node", ")", "\n", "non_descendants", "=", "_get_non_descendants", "(", "causal_graph", ",", "node", ",", "exclude_parents", "=", "True", ")", "\n", "\n", "lmc_test_result", "=", "dict", "(", ")", "\n", "if", "parents", "and", "non_descendants", ":", "\n", "# test local Markov condition, null hypothesis: conditional independence", "\n", "            ", "lmc_p_value", "=", "conditional_independence_test", "(", "data", "[", "node", "]", ".", "values", ",", "\n", "data", "[", "non_descendants", "]", ".", "values", ",", "\n", "data", "[", "parents", "]", ".", "values", ")", "\n", "lmc_test_result", "=", "dict", "(", "p_value", "=", "lmc_p_value", ")", "\n", "all_p_values", ".", "append", "(", "lmc_p_value", ")", "\n", "\n", "# test edge dependence, null hypothesis: independence", "\n", "", "edge_dependence_result", "=", "dict", "(", ")", "\n", "for", "parent", "in", "parents", ":", "\n", "            ", "edge_p_value", "=", "independence_test", "(", "data", "[", "parent", "]", ".", "values", ",", "data", "[", "node", "]", ".", "values", ")", "\n", "edge_dependence_result", "[", "parent", "]", "=", "dict", "(", "p_value", "=", "edge_p_value", ")", "\n", "all_p_values", ".", "append", "(", "edge_p_value", ")", "\n", "\n", "", "validation_summary", "[", "node", "]", "=", "dict", "(", "\n", "local_markov_test", "=", "lmc_test_result", ",", "\n", "edge_dependence_test", "=", "edge_dependence_result", "\n", ")", "\n", "\n", "", "if", "fdr_control_method", "is", "None", ":", "\n", "        ", "successes", "=", "np", ".", "array", "(", "all_p_values", ")", "<=", "significance_level", "\n", "adjusted_p_values", "=", "np", ".", "empty", "(", "len", "(", "successes", ")", ")", "\n", "adjusted_p_values", "[", ":", "]", "=", "np", ".", "nan", "\n", "", "else", ":", "\n", "        ", "multipletests_result", "=", "multipletests", "(", "all_p_values", ",", "significance_level", ",", "method", "=", "fdr_control_method", ")", "\n", "successes", "=", "multipletests_result", "[", "0", "]", "\n", "adjusted_p_values", "=", "multipletests_result", "[", "1", "]", "\n", "\n", "# The order of the p-values added to the list is deterministic.", "\n", "", "index", "=", "0", "\n", "for", "node", "in", "causal_graph", ".", "nodes", ":", "\n", "        ", "if", "'p_value'", "in", "validation_summary", "[", "node", "]", "[", "'local_markov_test'", "]", ":", "\n", "            ", "validation_summary", "[", "node", "]", "[", "'local_markov_test'", "]", "[", "'fdr_adjusted_p_value'", "]", "=", "adjusted_p_values", "[", "index", "]", "\n", "validation_summary", "[", "node", "]", "[", "'local_markov_test'", "]", "[", "'success'", "]", "=", "not", "successes", "[", "index", "]", "\n", "is_dag_valid", "&=", "not", "successes", "[", "index", "]", "\n", "index", "+=", "1", "\n", "\n", "", "for", "parent", "in", "get_ordered_predecessors", "(", "causal_graph", ",", "node", ")", ":", "\n", "            ", "validation_summary", "[", "node", "]", "[", "'edge_dependence_test'", "]", "[", "parent", "]", "[", "'fdr_adjusted_p_value'", "]", "=", "adjusted_p_values", "[", "index", "]", "\n", "validation_summary", "[", "node", "]", "[", "'edge_dependence_test'", "]", "[", "parent", "]", "[", "'success'", "]", "=", "successes", "[", "index", "]", "\n", "is_dag_valid", "&=", "successes", "[", "index", "]", "\n", "index", "+=", "1", "\n", "", "", "if", "is_dag_valid", ":", "\n", "        ", "return", "RejectionResult", ".", "NOT_REJECTED", ",", "validation_summary", "\n", "", "else", ":", "\n", "        ", "return", "RejectionResult", ".", "REJECTED", ",", "validation_summary", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_invertible_model": [[113, 162], ["dowhy.gcm.graph.validate_causal_graph", "dowhy.gcm.graph.is_root_node", "data[].to_numpy", "causal_model.causal_mechanism().estimate_noise", "all_p_values.append", "len", "numpy.all", "numpy.any", "data[].to_numpy", "independence_test", "causal_model.causal_mechanism", "numpy.array", "statsmodels.stats.multitest.multipletests", "dowhy.gcm.graph.get_ordered_predecessors"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.estimate_noise", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.__init__.independence_test", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors"], ["", "", "def", "refute_invertible_model", "(", "causal_model", ":", "InvertibleStructuralCausalModel", ",", "\n", "data", ":", "pd", ".", "DataFrame", ",", "\n", "independence_test", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", "=", "kernel_based", ",", "\n", "significance_level", ":", "float", "=", "0.05", ",", "\n", "fdr_control_method", ":", "Optional", "[", "str", "]", "=", "None", ")", "->", "RejectionResult", ":", "\n", "    ", "\"\"\"Validate the assumption that the structural causal models can be represented by a\n    :py:class:`InvertibleFunctionalCausalModel <dowhy.gcm.graph.InvertibleFunctionalCausalModel>` (e.g. the causal mechanisms are\n    :py:class:`AdditiveNoiseModels <dowhy.gcm.AdditiveNoiseModel>` and/or :py:class:`PostNonlinearModels <dowhy.gcm.PostNonlinearModel>`).\n    For this, it is checked if the residual of a causal mechanism is independent of the mechanism's input\n    (i.e. we assume causal sufficiency here). For instance, :py:class:`PostNonlinearModels <dowhy.gcm.PostNonlinearModel>` represent\n        Y = f(g(X) + N),\n    where f is invertible (g does not need to be), X are the parents of Y and N is (assumed to be) independent noise.\n    The latter point is important here. For given data, we can then reconstruct N and perform an independence test between X and N.\n\n    Note that this method only validates the causal mechanisms and not the graph structure.\n\n    For the case of post non-linear models, see the following paper for more details:\n        Zhang, K., and A. Hyv\u00e4rinen.\n        On the Identifiability of the Post-Nonlinear Causal Model.\n        25th Conference on Uncertainty in Artificial Intelligence (UAI 2009). AUAI Press, 2009.\n\n    :param causal_model: A fitted invertible structural causal model.\n    :param data: Observations of variables in the DAG.\n    :param independence_test: Independence test to use for checking if residual and input are dependent.\n    :param significance_level: Significance level for deciding whether input and residual is dependent.\n    :param fdr_control_method: Method for false discovery rate (FDR) control. For various options, please refer to `this page <https://www.statsmodels.org/dev/generated/statsmodels.stats.multitest.multipletests.html>`_.\n    :return: The outcome of the validation. The causal model can not be rejected if all causal mechanisms are consistent with\n             the invertible model assumption.\n    \"\"\"", "\n", "validate_causal_graph", "(", "causal_model", ".", "graph", ")", "\n", "\n", "all_p_values", "=", "[", "]", "\n", "\n", "for", "node", "in", "causal_model", ".", "graph", ".", "nodes", ":", "\n", "        ", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "node", ")", ":", "\n", "            ", "continue", "\n", "", "else", ":", "\n", "            ", "parents_samples", "=", "data", "[", "get_ordered_predecessors", "(", "causal_model", ".", "graph", ",", "node", ")", "]", ".", "to_numpy", "(", ")", "\n", "residuals", "=", "causal_model", ".", "causal_mechanism", "(", "node", ")", ".", "estimate_noise", "(", "data", "[", "node", "]", ".", "to_numpy", "(", ")", ",", "parents_samples", ")", "\n", "\n", "all_p_values", ".", "append", "(", "independence_test", "(", "parents_samples", ",", "residuals", ")", ")", "\n", "\n", "", "", "if", "fdr_control_method", "is", "None", "or", "len", "(", "all_p_values", ")", "==", "0", ":", "\n", "        ", "return", "RejectionResult", ".", "NOT_REJECTED", "if", "np", ".", "all", "(", "np", ".", "array", "(", "all_p_values", ")", ">", "significance_level", ")", "else", "RejectionResult", ".", "REJECTED", "\n", "", "else", ":", "\n", "        ", "return", "RejectionResult", ".", "REJECTED", "if", "np", ".", "any", "(", "multipletests", "(", "all_p_values", ",", "significance_level", ",", "method", "=", "fdr_control_method", ")", "[", "0", "]", ")", "else", "RejectionResult", ".", "NOT_REJECTED", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation._get_non_descendants": [[164, 169], ["networkx.descendants().union", "set().difference", "nodes_to_exclude.union.union", "networkx.descendants", "causal_graph.predecessors", "set"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.difference", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.ordered_set.OrderedSet.union", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.DirectedGraph.predecessors"], ["", "", "def", "_get_non_descendants", "(", "causal_graph", ":", "DirectedGraph", ",", "node", ":", "Any", ",", "exclude_parents", ":", "bool", "=", "False", ")", "->", "Set", "[", "Any", "]", ":", "\n", "    ", "nodes_to_exclude", "=", "nx", ".", "descendants", "(", "causal_graph", ",", "node", ")", ".", "union", "(", "{", "node", "}", ")", "\n", "if", "exclude_parents", ":", "\n", "        ", "nodes_to_exclude", "=", "nodes_to_exclude", ".", "union", "(", "causal_graph", ".", "predecessors", "(", "node", ")", ")", "\n", "", "return", "set", "(", "causal_graph", ".", "nodes", ")", ".", "difference", "(", "nodes_to_exclude", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.ShapleyConfig.__init__": [[46, 70], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "approximation_method", ":", "ShapleyApproximationMethods", "=", "ShapleyApproximationMethods", ".", "AUTO", ",", "\n", "num_samples", ":", "int", "=", "5000", ",", "\n", "min_percentage_change_threshold", ":", "float", "=", "0.01", ",", "\n", "n_jobs", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"Config for estimating Shapley values.\n\n        :param approximation_method: Type of approximation methods (see :py:class:`ShapleyApproximationMethods <dowhy.gcm.shapley.ShapleyApproximationMethods>`).\n        :param num_samples: Number of samples used for approximating the Shapley values. Depending on the approximation\n                            method, this can either represent the number of drawn subsets (in SUBSET_SAMPLING) or the\n                            number of drawn permutations (in EARLY_STOPPING and PERMUTATION). In case of EARLY_STOPPING,\n                            this also represents a limit on the evaluation runs.\n        :param min_percentage_change_threshold: This parameter is only relevant for EARLY_STOPPING and indicates the\n                                                minimum required change of the Shapley values between two runs\n                                                (i.e. evaluation of permutations) before the estimation stops.\n                                                For instance, if the Shapley value changes less than the given value for\n                                                a certain number of consecutive runs, the algorithm stops and returns\n                                                the current result.\n        :param n_jobs: Number of parallel jobs.\n        \"\"\"", "\n", "self", ".", "approximation_method", "=", "approximation_method", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "self", ".", "min_percentage_change_threshold", "=", "min_percentage_change_threshold", "\n", "self", ".", "n_jobs", "=", "config", ".", "default_n_jobs", "if", "n_jobs", "is", "None", "else", "n_jobs", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values": [[72, 141], ["shapley.ShapleyConfig", "shapley._estimate_shapley_values_exact", "shapley._approximate_shapley_values_via_permutation_sampling", "shapley._approximate_shapley_values_via_early_stopping", "max", "shapley._approximate_shapley_values_via_least_squares_regression", "shapley._approximate_shapley_values_via_least_squares_regression", "ValueError"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_shapley_values_exact", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._approximate_shapley_values_via_permutation_sampling", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._approximate_shapley_values_via_early_stopping", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._approximate_shapley_values_via_least_squares_regression", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._approximate_shapley_values_via_least_squares_regression"], ["", "", "def", "estimate_shapley_values", "(", "set_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "num_players", ":", "int", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Estimates the Shapley values based on the provided set function. A set function here is defined by taking a\n    (subset) of players and returning a certain utility value. This is in the context of attributing the\n    value of the i-th player to a subset of players S by evaluating v(S u {i}) - v(S), where v is the\n    set function and i is not in S. While we use the term 'player' here, this is often a certain feature/variable.\n\n    The input of the set function is a binary vector indicating which player is part of the set. For instance, given 4\n    players (1,2,3,4) and a subset only contains players 1,2,4, then this is indicated by the vector [1, 1, 0, 1]. The\n    function is expected to return a numeric value based on this input.\n\n    Note: The set function can be arbitrary and can resemble computationally complex operations. Keep in mind\n    that the estimation of Shapley values can become computationally expensive and requires a lot of memory. If the\n    runtime is too slow, consider changing the default config.\n\n    :param set_func: A set function that expects a binary vector as input which specifies which player is part of the\n                     subset.\n    :param num_players: Total number of players.\n    :param shapley_config: A config object for indicating the approximation method and other parameters. If None is\n                           given, a default config is used. For faster runtime or more accurate results, consider\n                           creating a custom config.\n    :return: A numpy array representing the Shapley values for each player, i.e. there are as many Shapley values as\n             num_players. The i-th entry belongs to the i-th player. Here, the set function defines which index belongs\n             to which player and is responsible to keep it consistent.\n    \"\"\"", "\n", "if", "shapley_config", "is", "None", ":", "\n", "        ", "shapley_config", "=", "ShapleyConfig", "(", ")", "\n", "\n", "", "approximation_method", "=", "shapley_config", ".", "approximation_method", "\n", "if", "approximation_method", "==", "ShapleyApproximationMethods", ".", "AUTO", ":", "\n", "        ", "if", "num_players", "<=", "5", ":", "\n", "            ", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EXACT", "\n", "", "else", ":", "\n", "            ", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EARLY_STOPPING", "\n", "\n", "", "", "if", "approximation_method", "==", "ShapleyApproximationMethods", ".", "EXACT", ":", "\n", "        ", "return", "_estimate_shapley_values_exact", "(", "set_func", "=", "set_func", ",", "\n", "num_players", "=", "num_players", ",", "\n", "n_jobs", "=", "shapley_config", ".", "n_jobs", ")", "\n", "", "elif", "approximation_method", "==", "ShapleyApproximationMethods", ".", "PERMUTATION", ":", "\n", "        ", "return", "_approximate_shapley_values_via_permutation_sampling", "(", "\n", "set_func", "=", "set_func", ",", "\n", "num_players", "=", "num_players", ",", "\n", "num_permutations", "=", "max", "(", "1", ",", "shapley_config", ".", "num_samples", "//", "num_players", ")", ",", "\n", "n_jobs", "=", "shapley_config", ".", "n_jobs", ")", "\n", "", "elif", "approximation_method", "==", "ShapleyApproximationMethods", ".", "EARLY_STOPPING", ":", "\n", "        ", "return", "_approximate_shapley_values_via_early_stopping", "(", "\n", "set_func", "=", "set_func", ",", "\n", "num_players", "=", "num_players", ",", "\n", "max_runs", "=", "shapley_config", ".", "num_samples", ",", "\n", "min_percentage_change_threshold", "=", "shapley_config", ".", "min_percentage_change_threshold", ",", "\n", "n_jobs", "=", "shapley_config", ".", "n_jobs", ")", "\n", "", "elif", "approximation_method", "==", "ShapleyApproximationMethods", ".", "SUBSET_SAMPLING", ":", "\n", "        ", "return", "_approximate_shapley_values_via_least_squares_regression", "(", "\n", "set_func", "=", "set_func", ",", "\n", "num_players", "=", "num_players", ",", "\n", "use_subset_approximation", "=", "True", ",", "\n", "num_samples_for_approximation", "=", "shapley_config", ".", "num_samples", ",", "\n", "n_jobs", "=", "shapley_config", ".", "n_jobs", ")", "\n", "", "elif", "approximation_method", "==", "ShapleyApproximationMethods", ".", "EXACT_FAST", ":", "\n", "        ", "return", "_approximate_shapley_values_via_least_squares_regression", "(", "\n", "set_func", "=", "set_func", ",", "\n", "num_players", "=", "num_players", ",", "\n", "use_subset_approximation", "=", "False", ",", "\n", "num_samples_for_approximation", "=", "shapley_config", ".", "num_samples", ",", "\n", "n_jobs", "=", "shapley_config", ".", "n_jobs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown method for Shapley approximation!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_shapley_values_exact": [[143, 184], ["numpy.array", "range", "tuple", "joblib.Parallel", "shapley._evaluate_set_function", "list", "range", "numpy.array", "itertools.product", "itertools.product", "tuple", "tuple", "len", "int", "scipy.special.comb", "numpy.insert", "numpy.insert", "numpy.sum", "shapley._estimate_shapley_values_exact.compute_subset_weight"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._evaluate_set_function"], ["", "", "def", "_estimate_shapley_values_exact", "(", "set_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "num_players", ":", "int", ",", "\n", "n_jobs", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Following Eq. (2) in\n    Janzing, D., Minorics, L., & Bloebaum, P. (2020).\n    Feature relevance quantification in explainable AI: A causal problem.\n    In International Conference on Artificial Intelligence and Statistics (pp. 2907-2916). PMLR. \"\"\"", "\n", "all_subsets", "=", "[", "tuple", "(", "subset", ")", "for", "subset", "in", "itertools", ".", "product", "(", "[", "0", ",", "1", "]", ",", "repeat", "=", "num_players", ")", "]", "\n", "\n", "with", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "as", "parallel", ":", "\n", "        ", "subset_to_result_map", "=", "_evaluate_set_function", "(", "set_func", ",", "all_subsets", ",", "parallel", ")", "\n", "\n", "", "def", "compute_subset_weight", "(", "length", ":", "int", ")", "->", "float", ":", "\n", "        ", "return", "1", "/", "(", "num_players", "*", "comb", "(", "num_players", "-", "1", ",", "length", ")", ")", "\n", "\n", "", "subset_weight_cache", "=", "{", "}", "\n", "\n", "shapley_values", "=", "[", "None", "]", "*", "num_players", "\n", "subsets_missing_one_player", "=", "np", ".", "array", "(", "list", "(", "itertools", ".", "product", "(", "[", "0", ",", "1", "]", ",", "repeat", "=", "num_players", "-", "1", ")", ")", ")", "\n", "for", "player_index", "in", "range", "(", "num_players", ")", ":", "\n", "        ", "subsets_with_player", "=", "[", "tuple", "(", "subset", ")", "\n", "for", "subset", "in", "np", ".", "insert", "(", "subsets_missing_one_player", ",", "player_index", ",", "1", ",", "axis", "=", "1", ")", "]", "\n", "subsets_without_player", "=", "[", "tuple", "(", "subset", ")", "\n", "for", "subset", "in", "np", ".", "insert", "(", "subsets_missing_one_player", ",", "player_index", ",", "0", ",", "axis", "=", "1", ")", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "subsets_with_player", ")", ")", ":", "\n", "            ", "subset_length", "=", "int", "(", "np", ".", "sum", "(", "subsets_without_player", "[", "i", "]", ")", ")", "\n", "if", "subset_length", "not", "in", "subset_weight_cache", ":", "\n", "                ", "subset_weight_cache", "[", "subset_length", "]", "=", "compute_subset_weight", "(", "subset_length", ")", "\n", "\n", "", "weighted_diff", "=", "subset_weight_cache", "[", "subset_length", "]", "*", "(", "subset_to_result_map", "[", "subsets_with_player", "[", "i", "]", "]", "\n", "-", "subset_to_result_map", "[", "subsets_without_player", "[", "i", "]", "]", ")", "\n", "# For estimating Shapley values for multiple samples (e.g. in feature relevance) and the number of samples", "\n", "# is unknown beforehand.", "\n", "if", "shapley_values", "[", "player_index", "]", "is", "None", ":", "\n", "                ", "shapley_values", "[", "player_index", "]", "=", "weighted_diff", "\n", "", "else", ":", "\n", "                ", "shapley_values", "[", "player_index", "]", "+=", "weighted_diff", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "shapley_values", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._approximate_shapley_values_via_least_squares_regression": [[186, 220], ["shapley._create_subsets_and_weights_exact", "shapley._create_subsets_and_weights_approximation", "dowhy.gcm.util.general.set_random_seed", "set_func", "joblib.Parallel", "numpy.random.randint", "parallel", "sklearn.linear_model.LinearRegression().fit", "numpy.array", "numpy.iinfo", "len", "sklearn.linear_model.LinearRegression", "joblib.delayed", "tqdm.tqdm", "zip"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._create_subsets_and_weights_exact", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._create_subsets_and_weights_approximation", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "_approximate_shapley_values_via_least_squares_regression", "(", "set_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "\n", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "num_players", ":", "int", ",", "\n", "use_subset_approximation", ":", "bool", ",", "\n", "num_samples_for_approximation", ":", "int", ",", "\n", "n_jobs", ":", "int", ",", "\n", "full_and_empty_subset_weight", ":", "float", "=", "10", "**", "20", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" For more details about this approximation, see Section 4.1.1 in\n    Janzing, D., Minorics, L., & Bloebaum, P. (2020).\n    Feature relevance quantification in explainable AI: A causal problem.\n    In International Conference on Artificial Intelligence and Statistics (pp. 2907-2916). PMLR. \"\"\"", "\n", "if", "not", "use_subset_approximation", ":", "\n", "        ", "all_subsets", ",", "weights", "=", "_create_subsets_and_weights_exact", "(", "num_players", ",", "\n", "full_and_empty_subset_weight", ")", "\n", "", "else", ":", "\n", "        ", "all_subsets", ",", "weights", "=", "_create_subsets_and_weights_approximation", "(", "num_players", ",", "\n", "full_and_empty_subset_weight", ",", "\n", "num_samples_for_approximation", ")", "\n", "\n", "", "def", "parallel_job", "(", "subset", ":", "np", ".", "ndarray", ",", "parallel_random_seed", ":", "int", ")", ":", "\n", "        ", "set_random_seed", "(", "parallel_random_seed", ")", "\n", "\n", "return", "set_func", "(", "subset", ")", "\n", "\n", "", "with", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "as", "parallel", ":", "\n", "        ", "random_seeds", "=", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "len", "(", "all_subsets", ")", ")", "\n", "set_function_results", "=", "parallel", "(", "delayed", "(", "parallel_job", ")", "(", "subset", ",", "random_seed", ")", "\n", "for", "subset", ",", "random_seed", "in", "\n", "tqdm", "(", "zip", "(", "all_subsets", ",", "random_seeds", ")", ",", "\n", "desc", "=", "\"Estimate shapley values as least squares solution\"", ",", "\n", "position", "=", "0", ",", "leave", "=", "True", ",", "disable", "=", "not", "config", ".", "show_progress_bars", ")", ")", "\n", "\n", "", "return", "LinearRegression", "(", ")", ".", "fit", "(", "all_subsets", ",", "np", ".", "array", "(", "set_function_results", ")", ",", "sample_weight", "=", "weights", ")", ".", "coef_", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._approximate_shapley_values_via_permutation_sampling": [[222, 251], ["shapley._estimate_full_and_emtpy_subset_results", "set", "range", "shapley._estimate_shapley_values_of_permutation", "range", "numpy.random.choice", "all_permutations.append", "set.update", "joblib.Parallel", "shapley._evaluate_set_function", "len", "shapley._estimate_shapley_values_of_permutation", "len", "shapley._create_index_order_and_subset_tuples"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_full_and_emtpy_subset_results", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_shapley_values_of_permutation", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._evaluate_set_function", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_shapley_values_of_permutation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._create_index_order_and_subset_tuples"], ["", "def", "_approximate_shapley_values_via_permutation_sampling", "(", "\n", "set_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "num_players", ":", "int", ",", "\n", "num_permutations", ":", "int", ",", "\n", "n_jobs", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" For more details about this approximation, see\n    Strumbelj, E., Kononenko, I. (2014).\n    Explaining prediction models and individual predictions with feature contributions.\n    In Knowledge and information systems, 41(3):647\u2013665 \"\"\"", "\n", "full_subset_result", ",", "empty_subset_result", "=", "_estimate_full_and_emtpy_subset_results", "(", "set_func", ",", "num_players", ")", "\n", "\n", "subsets_to_evaluate", "=", "set", "(", ")", "\n", "all_permutations", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_permutations", ")", ":", "\n", "        ", "permutation", "=", "np", ".", "random", ".", "choice", "(", "num_players", ",", "num_players", ",", "replace", "=", "False", ")", "\n", "all_permutations", ".", "append", "(", "permutation", ")", "\n", "\n", "subsets_to_evaluate", ".", "update", "(", "_create_index_order_and_subset_tuples", "(", "permutation", ")", ")", "\n", "\n", "", "with", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "as", "parallel", ":", "\n", "        ", "evaluated_subsets", "=", "_evaluate_set_function", "(", "set_func", ",", "subsets_to_evaluate", ",", "parallel", ")", "\n", "\n", "", "shapley_values", "=", "_estimate_shapley_values_of_permutation", "(", "all_permutations", "[", "0", "]", ",", "evaluated_subsets", ",", "\n", "full_subset_result", ",", "empty_subset_result", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "all_permutations", ")", ")", ":", "\n", "        ", "shapley_values", "+=", "_estimate_shapley_values_of_permutation", "(", "all_permutations", "[", "i", "]", ",", "evaluated_subsets", ",", "\n", "full_subset_result", ",", "empty_subset_result", ")", "\n", "\n", "", "return", "shapley_values", "/", "len", "(", "all_permutations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._approximate_shapley_values_via_early_stopping": [[253, 349], ["shapley._estimate_full_and_emtpy_subset_results", "numpy.zeros", "tqdm.tqdm", "joblib.Parallel", "tqdm.tqdm.update", "tqdm.tqdm.close", "set", "evaluated_subsets.update", "numpy.array", "numpy.random.choice", "set.update", "shapley._evaluate_set_function", "range", "shapley._estimate_shapley_values_of_permutation", "shapley._estimate_shapley_values_of_permutation", "tqdm.tqdm.set_description", "numpy.mean", "shapley._create_index_order_and_subset_tuples", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_full_and_emtpy_subset_results", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._evaluate_set_function", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_shapley_values_of_permutation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_shapley_values_of_permutation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._create_index_order_and_subset_tuples"], ["", "def", "_approximate_shapley_values_via_early_stopping", "(", "\n", "set_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "num_players", ":", "int", ",", "\n", "max_runs", ":", "int", ",", "\n", "min_percentage_change_threshold", ":", "float", ",", "\n", "n_jobs", ":", "int", ",", "\n", "num_permutations_per_run", ":", "int", "=", "5", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Combines the approximation method described in\n\n    Strumbelj, E., Kononenko, I. (2014).\n    Explaining prediction models and individual predictions with feature contributions.\n    In Knowledge and information systems, 41(3):647\u2013665\n\n    with an early stopping criteria. This is, if the Shapley values change less than a certain threshold on average\n    between two runs, then stop the estimation.\n    \"\"\"", "\n", "full_subset_result", ",", "empty_subset_result", "=", "_estimate_full_and_emtpy_subset_results", "(", "set_func", ",", "num_players", ")", "\n", "\n", "shapley_values", "=", "None", "\n", "old_shap_proxy", "=", "np", ".", "zeros", "(", "num_players", ")", "\n", "evaluated_subsets", "=", "{", "}", "\n", "num_generated_permutations", "=", "0", "\n", "run_counter", "=", "0", "\n", "converged_run", "=", "0", "\n", "\n", "if", "config", ".", "show_progress_bars", ":", "\n", "        ", "pbar", "=", "tqdm", "(", "total", "=", "1", ")", "\n", "\n", "", "with", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "as", "parallel", ":", "\n", "# The method stops if either the change between some consecutive runs is below the given threshold or the", "\n", "# maximum number of runs is reached.", "\n", "        ", "while", "True", ":", "\n", "            ", "run_counter", "+=", "1", "\n", "subsets_to_evaluate", "=", "set", "(", ")", "\n", "\n", "# In each run, we create one random permutation of players. For instance, given 4 players, a permutation", "\n", "# could be [3,1,4,2].", "\n", "permutations", "=", "[", "np", ".", "random", ".", "choice", "(", "num_players", ",", "num_players", ",", "replace", "=", "False", ")", "\n", "for", "_", "in", "range", "(", "num_permutations_per_run", ")", "]", "\n", "for", "permutation", "in", "permutations", ":", "\n", "                ", "num_generated_permutations", "+=", "1", "\n", "# Create all subsets belonging to the generated permutation. This is, if we have [3,1,4,2], then the", "\n", "# subsets are [3], [3,1], [3,1,4] [3,1,4,2].", "\n", "subsets_to_evaluate", ".", "update", "(", "[", "subset_tuple", "for", "subset_tuple", "\n", "in", "_create_index_order_and_subset_tuples", "(", "permutation", ")", "\n", "if", "subset_tuple", "not", "in", "evaluated_subsets", "]", ")", "\n", "\n", "# The result for each subset is cached such that if a subset that has already been evaluated appears again,", "\n", "# we can take this result directly.", "\n", "", "evaluated_subsets", ".", "update", "(", "_evaluate_set_function", "(", "set_func", ",", "\n", "subsets_to_evaluate", ",", "\n", "parallel", ",", "\n", "False", ")", ")", "\n", "\n", "for", "permutation", "in", "permutations", ":", "\n", "# To improve the runtime, multiple permutations are evaluated in each run.", "\n", "                ", "if", "shapley_values", "is", "None", ":", "\n", "                    ", "shapley_values", "=", "_estimate_shapley_values_of_permutation", "(", "permutation", ",", "evaluated_subsets", ",", "\n", "full_subset_result", ",", "empty_subset_result", ")", "\n", "", "else", ":", "\n", "                    ", "shapley_values", "+=", "_estimate_shapley_values_of_permutation", "(", "permutation", ",", "evaluated_subsets", ",", "\n", "full_subset_result", ",", "empty_subset_result", ")", "\n", "\n", "", "", "if", "run_counter", ">", "max_runs", ":", "\n", "                ", "break", "\n", "\n", "", "new_shap_proxy", "=", "np", ".", "array", "(", "shapley_values", ")", "\n", "new_shap_proxy", "[", "new_shap_proxy", "==", "0", "]", "=", "EPS", "\n", "# The current Shapley values are the average of the estimated values, i.e. we need to divide by the number", "\n", "# of generated permutations here.", "\n", "new_shap_proxy", "/=", "num_generated_permutations", "\n", "\n", "if", "run_counter", ">", "1", ":", "\n", "                ", "percentage_changes", "=", "1", "-", "new_shap_proxy", "/", "old_shap_proxy", "\n", "if", "config", ".", "show_progress_bars", ":", "\n", "                    ", "pbar", ".", "set_description", "(", "f'Estimating Shapley Values. '", "\n", "f'Average change of Shapley values in run {run_counter} '", "\n", "f'({num_generated_permutations} evaluated permutations): '", "\n", "f'{np.mean(percentage_changes) * 100}%'", ")", "\n", "\n", "", "if", "np", ".", "mean", "(", "percentage_changes", ")", "<", "min_percentage_change_threshold", ":", "\n", "# Here, the change between two runs is below the minimum threshold, but to reduce the likelihood", "\n", "# that this just happened by chance, we require that this happens at least for two runs in a row.", "\n", "                    ", "converged_run", "+=", "1", "\n", "if", "converged_run", ">=", "2", ":", "\n", "                        ", "break", "\n", "", "", "else", ":", "\n", "                    ", "converged_run", "=", "0", "\n", "\n", "", "", "old_shap_proxy", "=", "new_shap_proxy", "\n", "\n", "", "", "if", "config", ".", "show_progress_bars", ":", "\n", "        ", "pbar", ".", "update", "(", "1", ")", "\n", "pbar", ".", "close", "(", ")", "\n", "\n", "", "return", "shapley_values", "/", "num_generated_permutations", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._create_subsets_and_weights_exact": [[351, 398], ["int", "range", "numpy.zeros", "enumerate", "numpy.ceil", "all_subsets.extend", "all_subsets.extend", "len", "numpy.sum", "numpy.array", "np.zeros.astype", "numpy.array", "numpy.array", "all_subsets.extend", "numpy.array", "numpy.bincount", "numpy.bincount", "itertools.combinations", "itertools.combinations", "numpy.bincount", "scipy.special.binom", "range", "range", "itertools.combinations", "range"], "function", ["None"], ["", "def", "_create_subsets_and_weights_exact", "(", "num_players", ":", "int", ",", "high_weight", ":", "float", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"Creates all subsets and the exact weights of each subset. See Section 4.1.1. in\n\n    Janzing, D., Minorics, L., & Bloebaum, P. (2020).\n    Feature relevance quantification in explainable AI: A causal problem.\n    In International Conference on Artificial Intelligence and Statistics (pp. 2907-2916). PMLR.\n\n    for more details on this.\n\n    :param num_players: Total number of players.\n    :param high_weight: A 'high' weight for computational purposes. This is used to resemble 'infinity', but needs to be\n                        selected carefully to avoid numerical issues.\n    :return: A tuple, where the first entry is a numpy array with all subsets and the second entry is an array with the\n             corresponding weights to each subset.\n    \"\"\"", "\n", "all_subsets", "=", "[", "]", "\n", "\n", "num_iterations", "=", "int", "(", "np", ".", "ceil", "(", "num_players", "/", "2", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_iterations", ")", ":", "\n", "# Create all (unique) subsets)", "\n", "        ", "all_subsets", ".", "extend", "(", "np", ".", "array", "(", "[", "np", ".", "bincount", "(", "combs", ",", "minlength", "=", "num_players", ")", "for", "combs", "in", "\n", "itertools", ".", "combinations", "(", "range", "(", "num_players", ")", ",", "i", ")", "]", ")", ")", "\n", "\n", "all_subsets", ".", "extend", "(", "np", ".", "array", "(", "[", "np", ".", "bincount", "(", "combs", ",", "minlength", "=", "num_players", ")", "for", "combs", "in", "\n", "itertools", ".", "combinations", "(", "range", "(", "num_players", ")", ",", "num_players", "-", "i", ")", "]", ")", ")", "\n", "\n", "if", "i", "==", "num_iterations", "-", "1", "and", "num_players", "%", "2", "==", "0", ":", "\n", "            ", "all_subsets", ".", "extend", "(", "np", ".", "array", "(", "[", "np", ".", "bincount", "(", "combs", ",", "minlength", "=", "num_players", ")", "for", "combs", "in", "\n", "itertools", ".", "combinations", "(", "range", "(", "num_players", ")", ",", "i", "+", "1", ")", "]", ")", ")", "\n", "\n", "", "", "weights", "=", "np", ".", "zeros", "(", "len", "(", "all_subsets", ")", ")", "\n", "\n", "for", "i", ",", "subset", "in", "enumerate", "(", "all_subsets", ")", ":", "\n", "        ", "subset_size", "=", "np", ".", "sum", "(", "subset", ")", "\n", "if", "subset_size", "==", "num_players", "or", "subset_size", "==", "0", ":", "\n", "# Assigning a 'high' weight, since this resembles \"infinity\".", "\n", "            ", "weights", "[", "i", "]", "=", "high_weight", "\n", "", "else", ":", "\n", "# The weight for a subset with a specific length (see paper mentioned in the docstring for more", "\n", "# information).", "\n", "            ", "weights", "[", "i", "]", "=", "(", "num_players", "-", "1", ")", "/", "(", "\n", "scipy", ".", "special", ".", "binom", "(", "num_players", ",", "subset_size", ")", "\n", "*", "subset_size", "\n", "*", "(", "num_players", "-", "subset_size", ")", ")", "\n", "\n", "", "", "return", "np", ".", "array", "(", "all_subsets", ",", "dtype", "=", "np", ".", "int", ")", ",", "weights", ".", "astype", "(", "np", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._create_subsets_and_weights_approximation": [[400, 435], ["numpy.zeros", "range", "range", "numpy.array", "numpy.zeros", "numpy.ones", "tuple", "tuple", "numpy.sum", "shapley._convert_list_of_indices_to_binary_vector_as_tuple", "numpy.array", "np.array.astype", "numpy.random.choice", "all_subsets.append", "numpy.random.choice", "numpy.array", "tuple"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._convert_list_of_indices_to_binary_vector_as_tuple"], ["", "def", "_create_subsets_and_weights_approximation", "(", "num_players", ":", "int", ",", "high_weight", ":", "float", ",", "\n", "num_subset_samples", ":", "int", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"Randomly samples subsets and weights them based on the number of how often they appear.\n\n    :param num_players: Total number of players.\n    :param high_weight: A 'high' weight for computational purposes. This is used to resemble 'infinity', but needs to be\n                        selected carefully to avoid numerical issues.\n    :param num_subset_samples: Number of subset samples.\n    :return: A tuple, where the first entry is a numpy array with the sampled subsets and the second entry is an array\n             with the corresponding weights to each subset.\n    \"\"\"", "\n", "all_subsets", "=", "[", "np", ".", "zeros", "(", "num_players", ")", ",", "np", ".", "ones", "(", "num_players", ")", "]", "\n", "weights", "=", "{", "tuple", "(", "all_subsets", "[", "0", "]", ")", ":", "high_weight", ",", "tuple", "(", "all_subsets", "[", "1", "]", ")", ":", "high_weight", "}", "\n", "\n", "probabilities_of_subset_length", "=", "np", ".", "zeros", "(", "num_players", "+", "1", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "num_players", ")", ":", "\n", "        ", "probabilities_of_subset_length", "[", "i", "]", "=", "(", "num_players", "-", "1", ")", "/", "(", "i", "*", "(", "num_players", "-", "i", ")", ")", "\n", "\n", "", "probabilities_of_subset_length", "=", "probabilities_of_subset_length", "/", "np", ".", "sum", "(", "probabilities_of_subset_length", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_subset_samples", ")", ":", "\n", "        ", "subset_as_tuple", "=", "_convert_list_of_indices_to_binary_vector_as_tuple", "(", "\n", "np", ".", "random", ".", "choice", "(", "num_players", ",", "\n", "np", ".", "random", ".", "choice", "(", "num_players", "+", "1", ",", "1", ",", "p", "=", "probabilities_of_subset_length", ")", ",", "\n", "replace", "=", "False", ")", ",", "num_players", ")", "\n", "\n", "if", "subset_as_tuple", "not", "in", "weights", ":", "\n", "            ", "weights", "[", "subset_as_tuple", "]", "=", "0", "\n", "all_subsets", ".", "append", "(", "np", ".", "array", "(", "subset_as_tuple", ")", ")", "\n", "\n", "", "weights", "[", "subset_as_tuple", "]", "+=", "1", "\n", "\n", "", "weights", "=", "np", ".", "array", "(", "[", "weights", "[", "tuple", "(", "x", ")", "]", "for", "x", "in", "all_subsets", "]", ")", "\n", "\n", "return", "np", ".", "array", "(", "all_subsets", ",", "dtype", "=", "np", ".", "int", ")", ",", "weights", ".", "astype", "(", "np", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._convert_list_of_indices_to_binary_vector_as_tuple": [[437, 442], ["numpy.zeros", "tuple"], "function", ["None"], ["", "def", "_convert_list_of_indices_to_binary_vector_as_tuple", "(", "list_of_indices", ":", "List", "[", "int", "]", ",", "num_players", ":", "int", ")", "->", "Tuple", "[", "int", "]", ":", "\n", "    ", "subset", "=", "np", ".", "zeros", "(", "num_players", ",", "dtype", "=", "np", ".", "int", ")", "\n", "subset", "[", "list_of_indices", "]", "=", "1", "\n", "\n", "return", "tuple", "(", "subset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._evaluate_set_function": [[444, 466], ["numpy.random.randint", "parallel_context", "zip", "dowhy.gcm.util.general.set_random_seed", "set_func", "numpy.array", "numpy.iinfo", "len", "joblib.delayed", "tqdm.tqdm", "zip"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed"], ["", "def", "_evaluate_set_function", "(", "set_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "evaluation_subsets", ":", "Union", "[", "Set", "[", "Tuple", "[", "int", "]", "]", ",", "List", "[", "Tuple", "[", "int", "]", "]", "]", ",", "\n", "parallel_context", ":", "Parallel", ",", "\n", "show_progressbar", ":", "bool", "=", "True", ")", "->", "Dict", "[", "Tuple", "[", "int", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ":", "\n", "    ", "def", "parallel_job", "(", "input_subset", ":", "Tuple", "[", "int", "]", ",", "parallel_random_seed", ":", "int", ")", "->", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "set_random_seed", "(", "parallel_random_seed", ")", "\n", "\n", "return", "set_func", "(", "np", ".", "array", "(", "input_subset", ")", ")", "\n", "\n", "", "random_seeds", "=", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "len", "(", "evaluation_subsets", ")", ")", "\n", "subset_results", "=", "parallel_context", "(", "delayed", "(", "parallel_job", ")", "(", "subset_to_evaluate", ",", "random_seed", ")", "\n", "for", "subset_to_evaluate", ",", "random_seed", "in", "\n", "tqdm", "(", "zip", "(", "evaluation_subsets", ",", "random_seeds", ")", ",", "\n", "desc", "=", "\"Evaluate set function\"", ",", "\n", "position", "=", "0", ",", "\n", "leave", "=", "True", ",", "disable", "=", "not", "config", ".", "show_progress_bars", "or", "not", "show_progressbar", ")", ")", "\n", "\n", "subset_to_result_map", "=", "{", "}", "\n", "for", "(", "subset", ",", "result", ")", "in", "zip", "(", "evaluation_subsets", ",", "subset_results", ")", ":", "\n", "        ", "subset_to_result_map", "[", "subset", "]", "=", "result", "\n", "\n", "", "return", "subset_to_result_map", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_full_and_emtpy_subset_results": [[468, 473], ["set_func", "set_func", "numpy.ones", "numpy.zeros"], "function", ["None"], ["", "def", "_estimate_full_and_emtpy_subset_results", "(", "set_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "num_players", ":", "int", ")", "->", "Tuple", "[", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ":", "\n", "    ", "return", "set_func", "(", "np", ".", "ones", "(", "num_players", ",", "dtype", "=", "np", ".", "int", ")", ")", ",", "set_func", "(", "np", ".", "zeros", "(", "num_players", ",", "dtype", "=", "np", ".", "int", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._create_index_order_and_subset_tuples": [[475, 484], ["range", "index_tuples.append", "len", "shapley._convert_list_of_indices_to_binary_vector_as_tuple", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._convert_list_of_indices_to_binary_vector_as_tuple"], ["", "def", "_create_index_order_and_subset_tuples", "(", "permutation", ":", "List", "[", "int", "]", ")", "->", "List", "[", "Tuple", "[", "int", "]", "]", ":", "\n", "    ", "indices", "=", "[", "]", "\n", "index_tuples", "=", "[", "]", "\n", "\n", "for", "var", "in", "range", "(", "len", "(", "permutation", ")", "-", "1", ")", ":", "\n", "        ", "indices", "+=", "[", "permutation", "[", "var", "]", "]", "\n", "index_tuples", ".", "append", "(", "_convert_list_of_indices_to_binary_vector_as_tuple", "(", "indices", ",", "len", "(", "permutation", ")", ")", ")", "\n", "\n", "", "return", "index_tuples", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._estimate_shapley_values_of_permutation": [[486, 504], ["range", "len", "numpy.array", "len", "shapley._convert_list_of_indices_to_binary_vector_as_tuple", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley._convert_list_of_indices_to_binary_vector_as_tuple"], ["", "def", "_estimate_shapley_values_of_permutation", "(", "permutation", ":", "List", "[", "int", "]", ",", "\n", "evaluated_subsets", ":", "Dict", "[", "Tuple", "[", "int", "]", ",", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "full_subset_result", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ",", "\n", "empty_subset_result", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "current_variable_set", "=", "[", "]", "\n", "shapley_values", "=", "[", "[", "]", "]", "*", "len", "(", "permutation", ")", "\n", "previous_result", "=", "empty_subset_result", "\n", "for", "n", "in", "range", "(", "len", "(", "permutation", ")", "-", "1", ")", ":", "\n", "        ", "current_variable_set", "+=", "[", "permutation", "[", "n", "]", "]", "\n", "current_result", "=", "evaluated_subsets", "[", "\n", "_convert_list_of_indices_to_binary_vector_as_tuple", "(", "current_variable_set", ",", "len", "(", "permutation", ")", ")", "]", "\n", "\n", "shapley_values", "[", "permutation", "[", "n", "]", "]", "=", "current_result", "-", "previous_result", "\n", "previous_result", "=", "current_result", "\n", "\n", "", "shapley_values", "[", "permutation", "[", "-", "1", "]", "]", "=", "full_subset_result", "-", "previous_result", "\n", "\n", "return", "np", ".", "array", "(", "shapley_values", ")", ".", "T", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.arrow_strength": [[31, 91], ["dowhy.gcm.graph.is_root_node", "dowhy.gcm.cms.ProbabilisticCausalModel", "dowhy.gcm.graph.validate_node", "dowhy.gcm.graph.get_ordered_predecessors", "influence.arrow_strength_of_model", "ValueError", "ValueError", "dowhy.gcm.graph.node_connected_subgraph_view", "dowhy.gcm.cms.ProbabilisticCausalModel.causal_mechanism", "parent_samples[].to_numpy", "dowhy.gcm.fitting_sampling.draw_samples", "enumerate"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.get_ordered_predecessors", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.arrow_strength_of_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["def", "arrow_strength", "(", "causal_model", ":", "ProbabilisticCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "parent_samples", ":", "Optional", "[", "pd", ".", "DataFrame", "]", "=", "None", ",", "\n", "num_samples_conditional", ":", "int", "=", "1000", ",", "\n", "max_num_runs", ":", "int", "=", "5000", ",", "\n", "tolerance", ":", "float", "=", "10", "**", "-", "4", ",", "\n", "n_jobs", ":", "int", "=", "1", ",", "\n", "difference_estimation_func", ":", "\n", "Optional", "[", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", "]", "=", "None", ")", "->", "Dict", "[", "Tuple", "[", "Any", ",", "Any", "]", ",", "float", "]", ":", "\n", "    ", "\"\"\"Computes the causal strength of each edge directed to the target node.\n    The strength of an edge is quantified in terms of distance between conditional distributions of the target node in\n    the original graph and the imputed graph wherein the edge has been removed and the target node is fed a random\n    permutation of the observations of the source node. For more scientific details behind this API, please refer to\n    the research paper below.\n\n    **Research Paper**:\n    Dominik Janzing, David Balduzzi, Moritz Grosse-Wentrup, Bernhard Sch\u00f6lkopf. *Quantifying Causal Influences*. The\n    Annals of Statistics, Vol. 41, No. 5, 2324-2358, 2013.\n\n    :param causal_model: The probabilistic causal model for whose target node we compute the strength of incoming\n                         edges for.\n    :param target_node: The target node whose incoming edges' strength is to be computed.\n    :param parent_samples: Optional samples from the parents of the target_node. If None are given, they are generated\n                           based on the provided causal model. Providing observational data can help to mitigate\n                           misspecifications in the graph, such as missing interactions between root nodes or \n                           confounders.\n    :param num_samples_conditional: Sample size to use for estimating the distance between distributions.\n    :param max_num_runs: The maximum number of times to resample and estimate the strength to report the average\n                         strength.\n    :param tolerance: The difference in average strength between two successive runs to terminate early without\n                      running it max_num_runs times.\n    :param n_jobs: The number of jobs to run in parallel. Set it to -1 to use all processors.\n    :param difference_estimation_func: Optional: How to measure the distance between two distributions. By default,\n                                       the difference of the variance is estimated for a continuous target node\n                                       and the KL divergence for a categorical target node.\n    :return: Causal strength of each edge.\n    \"\"\"", "\n", "if", "target_node", "not", "in", "causal_model", ".", "graph", ".", "nodes", ":", "\n", "        ", "raise", "ValueError", "(", "\"Target node %s can not be found in given graph!\"", "%", "target_node", ")", "\n", "", "if", "is_root_node", "(", "causal_model", ".", "graph", ",", "target_node", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Target node %s is a root node, but it requires to have ancestors!\"", "%", "target_node", ")", "\n", "\n", "# Creating a smaller subgraph, which only contains upstream nodes that are connected to the target node.", "\n", "", "sub_causal_model", "=", "ProbabilisticCausalModel", "(", "node_connected_subgraph_view", "(", "causal_model", ".", "graph", ",", "target_node", ")", ")", "\n", "validate_node", "(", "sub_causal_model", ".", "graph", ",", "target_node", ")", "\n", "\n", "ordered_predecessors", "=", "get_ordered_predecessors", "(", "sub_causal_model", ".", "graph", ",", "target_node", ")", "\n", "\n", "if", "parent_samples", "is", "None", ":", "\n", "        ", "parent_samples", "=", "draw_samples", "(", "sub_causal_model", ",", "num_samples_conditional", "*", "10", ")", "[", "ordered_predecessors", "]", "\n", "\n", "", "direct_influences", "=", "arrow_strength_of_model", "(", "sub_causal_model", ".", "causal_mechanism", "(", "target_node", ")", ",", "\n", "parent_samples", "[", "ordered_predecessors", "]", ".", "to_numpy", "(", ")", ",", "\n", "num_samples_from_conditional", "=", "num_samples_conditional", ",", "\n", "max_num_runs", "=", "max_num_runs", ",", "\n", "tolerance", "=", "tolerance", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "difference_estimation_func", "=", "difference_estimation_func", ")", "\n", "return", "{", "(", "predecessor", ",", "target_node", ")", ":", "direct_influences", "[", "i", "]", "for", "i", ",", "predecessor", "in", "enumerate", "(", "ordered_predecessors", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.arrow_strength_of_model": [[93, 144], ["dowhy.gcm.util.general.shape_into_2d", "isinstance", "numpy.any", "numpy.array", "isinstance", "warnings.catch_warnings", "warnings.filterwarnings", "numpy.random.randint", "_logger.warning", "dowhy.gcm.util.general.set_random_seed", "influence._estimate_direct_strength", "joblib.Parallel", "range", "numpy.iinfo", "len", "numpy.var", "numpy.var", "joblib.delayed", "zip"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence._estimate_direct_strength"], ["", "def", "arrow_strength_of_model", "(", "conditional_stochastic_model", ":", "ConditionalStochasticModel", ",", "\n", "input_samples", ":", "np", ".", "ndarray", ",", "\n", "num_samples_from_conditional", ":", "int", "=", "1000", ",", "\n", "max_num_runs", ":", "int", "=", "5000", ",", "\n", "tolerance", ":", "float", "=", "10", "**", "-", "4", ",", "\n", "n_jobs", ":", "int", "=", "1", ",", "\n", "difference_estimation_func", ":", "\n", "Optional", "[", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", "]", "=", "None", ",", "\n", "input_subsets", ":", "Optional", "[", "List", "[", "List", "[", "int", "]", "]", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "input_samples", "=", "shape_into_2d", "(", "input_samples", ")", "\n", "\n", "if", "input_subsets", "is", "None", ":", "\n", "        ", "input_subsets", "=", "[", "[", "i", "]", "for", "i", "in", "range", "(", "input_samples", ".", "shape", "[", "1", "]", ")", "]", "\n", "\n", "", "if", "difference_estimation_func", "is", "None", ":", "\n", "        ", "if", "isinstance", "(", "conditional_stochastic_model", ",", "ProbabilityEstimatorModel", ")", ":", "\n", "            ", "difference_estimation_func", "=", "estimate_kl_divergence_of_probabilities", "\n", "", "else", ":", "\n", "            ", "def", "difference_estimation_func", "(", "old", ",", "new", ")", ":", "\n", "                ", "return", "np", ".", "var", "(", "new", ")", "-", "np", ".", "var", "(", "old", ")", "\n", "\n", "", "", "", "if", "isinstance", "(", "conditional_stochastic_model", ",", "ProbabilityEstimatorModel", ")", ":", "\n", "        ", "samples_creation_method", "=", "conditional_stochastic_model", ".", "estimate_probabilities", "\n", "", "else", ":", "\n", "        ", "samples_creation_method", "=", "conditional_stochastic_model", ".", "draw_samples", "\n", "\n", "", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "filterwarnings", "(", "'ignore'", ")", "\n", "\n", "def", "parallel_job", "(", "subset", ":", "List", "[", "int", "]", ",", "\n", "parallel_random_seed", ":", "int", ")", ":", "\n", "            ", "set_random_seed", "(", "parallel_random_seed", ")", "\n", "\n", "return", "_estimate_direct_strength", "(", "\n", "samples_creation_method", ",", "\n", "input_samples", ",", "\n", "subset", ",", "\n", "difference_estimation_func", ",", "\n", "num_samples_from_conditional", ",", "\n", "max_num_runs", ",", "\n", "tolerance", ")", "\n", "\n", "", "random_seeds", "=", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "len", "(", "input_subsets", ")", ")", "\n", "results", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "delayed", "(", "parallel_job", ")", "(", "subset", ",", "random_seed", ")", "\n", "for", "subset", ",", "random_seed", "in", "zip", "(", "input_subsets", ",", "random_seeds", ")", ")", "\n", "\n", "", "if", "np", ".", "any", "(", "results", "==", "np", ".", "inf", ")", ":", "\n", "        ", "_logger", ".", "warning", "(", "'At least one arrow strength is infinite. This typically happens if the causal models are '", "\n", "'deterministic, i.e. there is no noise or it is extremely small.'", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence._estimate_direct_strength": [[146, 196], ["dowhy.gcm.util.general.shape_into_2d", "enumerate", "numpy.matlib.repmat", "numpy.random.choice", "draw_samples_func", "draw_samples_func", "influence.arrow_strength_of_model.difference_estimation_func", "abs"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "_estimate_direct_strength", "(", "draw_samples_func", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "distribution_samples", ":", "np", ".", "ndarray", ",", "\n", "parents_subset", ":", "List", "[", "int", "]", ",", "\n", "difference_estimation_func", ":", "\n", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "Union", "[", "np", ".", "ndarray", ",", "float", "]", "]", ",", "\n", "num_samples_conditional", ":", "int", ",", "\n", "max_num_runs", ":", "int", ",", "\n", "tolerance", ":", "float", ")", "->", "float", ":", "\n", "    ", "distribution_samples", "=", "shape_into_2d", "(", "distribution_samples", ")", "\n", "\n", "aggregated_conditional_difference_result", "=", "0", "\n", "average_difference_result", "=", "0", "\n", "converged_run", "=", "0", "\n", "for", "run", ",", "sample", "in", "enumerate", "(", "distribution_samples", ")", ":", "\n", "        ", "tmp_samples", "=", "repmat", "(", "sample", ",", "num_samples_conditional", ",", "1", ")", "\n", "\n", "rnd_permutation", "=", "np", ".", "random", ".", "choice", "(", "distribution_samples", ".", "shape", "[", "0", "]", ",", "\n", "num_samples_conditional", ",", "\n", "replace", "=", "False", ")", "\n", "\n", "# Sampling from the conditional distribution based on the current sample.", "\n", "conditional_distribution_samples", "=", "draw_samples_func", "(", "tmp_samples", ")", "\n", "\n", "# Sampling from the conditional based on the current sample, but randomizing the inputs of all variables that", "\n", "# are in the given subset. By this, we can simulate the impact on the conditional distribution when removing", "\n", "# only the incoming edges of the variables in the subset.", "\n", "tmp_samples", "[", ":", ",", "parents_subset", "]", "=", "distribution_samples", "[", ":", ",", "parents_subset", "]", "[", "rnd_permutation", "]", "\n", "cond_dist_removed_arr_samples", "=", "draw_samples_func", "(", "tmp_samples", ")", "\n", "\n", "old_average_difference_result", "=", "average_difference_result", "\n", "\n", "aggregated_conditional_difference_result", "+=", "difference_estimation_func", "(", "conditional_distribution_samples", ",", "\n", "cond_dist_removed_arr_samples", ")", "\n", "\n", "average_difference_result", "=", "aggregated_conditional_difference_result", "/", "(", "run", "+", "1", ")", "\n", "\n", "if", "run", ">=", "max_num_runs", ":", "\n", "            ", "break", "\n", "", "elif", "run", ">", "0", ":", "\n", "            ", "if", "old_average_difference_result", "==", "0", ":", "\n", "                ", "old_average_difference_result", "=", "EPS", "\n", "\n", "", "if", "abs", "(", "1", "-", "average_difference_result", "/", "old_average_difference_result", ")", "<", "tolerance", ":", "\n", "                ", "converged_run", "+=", "1", "\n", "if", "converged_run", ">=", "3", ":", "\n", "                    ", "break", "\n", "", "", "else", ":", "\n", "                ", "converged_run", "=", "0", "\n", "\n", "", "", "", "return", "average_difference_result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence": [[198, 311], ["dowhy.gcm.graph.validate_causal_dag", "dowhy.gcm.cms.StructuralCausalModel", "dowhy.gcm._noise.noise_samples_of_ancestors", "dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.util.general.is_categorical", "dowhy.gcm._noise.noise_samples_of_ancestors", "dowhy.gcm.util.general.shape_into_2d", "influence._estimate_iccs", "dowhy.gcm.graph.node_connected_subgraph_view", "dowhy.gcm.util.general.shape_into_2d.to_numpy", "data_samples[].to_numpy", "data_samples[].to_numpy", "dowhy.select_model", "auto.select_model.fit", "dowhy.gcm.util.general.shape_into_2d.to_numpy", "isinstance", "dowhy.gcm.shapley.ShapleyConfig", "enumerate", "[].to_numpy", "ValueError", "auto.select_model.fit", "dowhy.gcm.uncertainty.estimate_variance", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "typing.cast", "dowhy.gcm._noise.compute_data_from_noise", "dowhy.gcm.cms.StructuralCausalModel.causal_mechanism", "pandas.DataFrame", "dowhy.gcm.util.general.shape_into_2d", "influence.intrinsic_causal_influence.exact_model"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.validate_causal_dag", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.noise_samples_of_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.noise_samples_of_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence._estimate_iccs", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.select_model", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.compute_data_from_noise", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "intrinsic_causal_influence", "(", "causal_model", ":", "StructuralCausalModel", ",", "\n", "target_node", ":", "Any", ",", "\n", "prediction_model", ":", "Union", "[", "PredictionModel", ",", "ClassificationModel", ",", "str", "]", "=", "'approx'", ",", "\n", "attribution_func", ":", "Optional", "[", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", "]", "=", "None", ",", "\n", "num_training_samples", ":", "int", "=", "100000", ",", "\n", "num_samples_randomization", ":", "int", "=", "7500", ",", "\n", "num_samples_baseline", ":", "int", "=", "1000", ",", "\n", "max_batch_size", ":", "int", "=", "100", ",", "\n", "auto_assign_quality", ":", "auto", ".", "AssignmentQuality", "=", "auto", ".", "AssignmentQuality", ".", "GOOD", ",", "\n", "shapley_config", ":", "Optional", "[", "ShapleyConfig", "]", "=", "None", ")", "->", "Dict", "[", "Any", ",", "float", "]", ":", "\n", "    ", "\"\"\"Computes the causal contribution of each upstream noise term of the target node (including the noise of the\n    target itself) to the statistical property (e.g. mean, variance) of the target. We call this contribution\n    *intrinsic* as noise terms, by definition, do not inherit properties of observed parents. The contribution of each\n    noise term is then the *intrinsic* causal contribution of the corresponding node. For more scientific details,\n    please refer to the paper below.\n\n    **Research Paper**:\n    Janzing et al. *Quantifying causal contributions via structure preserving interventions*. arXiv:2007.00714, 2021.\n\n    :param causal_model: The structural causal model for whose target node we compute the intrinsic causal influence\n                         of its ancestors.\n    :param target_node: Target node whose statistical property is to be attributed.\n    :param prediction_model: Prediction model for estimating the functional relationship between subsets of ancestor\n                             noise terms and the target node. This can be an instance of a PredictionModel, the string\n                             'approx' or the string 'exact'. With 'exact', the underlying causal models in the graph\n                             are utilized directly by propagating given noise inputs through the graph. This is\n                             generally more accurate but slow. With 'approx', an appropriate model is selected and\n                             trained based on sampled data from the graph, which is less accurate but faster. A more\n                             detailed treatment on why we need this parameter is also provided in :ref:`icc`.\n    :param attribution_func: Optional attribution function to measure the statistical property of the target node. This\n                             function expects two inputs; predictions after the randomization of certain features (i.e.\n                             samples from noise nodes) and a baseline where no features were randomized. The baseline\n                             predictions can be typically ignored if one is interested in uncertainty measures such as\n                             entropy or variance, but they might be relevant if, for instance, these shall be estimated\n                             based on the residuals. By default, entropy is used if prediction model is a classifier,\n                             variance otherwise.\n    :param num_training_samples: Number of samples drawn from the graphical causal model that are used for fitting the\n                                 prediction_model (if necessary).\n    :param num_samples_randomization: Number of noise samples drawn from the graphical causal model that are used for\n                                      evaluating the set function. Here, these samples are samples from\n                                      the noise distributions used for randomizing features that are not in the subset.\n    :param num_samples_baseline: Number of noise samples drawn from the graphical causal model that are used for\n                                 evaluating the set function. Here, these samples are used as fixed observations for\n                                 features that are in the subset.\n    :param max_batch_size: Maximum batch size for estimating the predictions from evaluation samples. This has a\n                           significant impact on the overall memory usage. If set to -1, all samples are used in one\n                           batch.\n    :param auto_assign_quality: Auto assign quality for the 'approx' prediction_model option.\n    :param shapley_config: :class:`~dowhy.gcm.shapley.ShapleyConfig` for the Shapley estimator.\n    :return: Intrinsic causal contribution of each ancestor node to the statistical property defined by the\n             attribution_func of the target node.\n    \"\"\"", "\n", "validate_causal_dag", "(", "causal_model", ".", "graph", ")", "\n", "\n", "# Creating a smaller subgraph, which only contains upstream nodes that are connected to the target node.", "\n", "sub_causal_model", "=", "StructuralCausalModel", "(", "node_connected_subgraph_view", "(", "causal_model", ".", "graph", ",", "target_node", ")", ")", "\n", "\n", "data_samples", ",", "noise_samples", "=", "noise_samples_of_ancestors", "(", "sub_causal_model", ",", "target_node", ",", "num_training_samples", ")", "\n", "node_names", "=", "noise_samples", ".", "columns", "\n", "noise_samples", ",", "target_samples", "=", "shape_into_2d", "(", "noise_samples", ".", "to_numpy", "(", ")", ",", "data_samples", "[", "target_node", "]", ".", "to_numpy", "(", ")", ")", "\n", "\n", "target_is_categorical", "=", "is_categorical", "(", "data_samples", "[", "target_node", "]", ".", "to_numpy", "(", ")", ")", "\n", "\n", "if", "prediction_model", "==", "'approx'", ":", "\n", "        ", "prediction_model", "=", "auto", ".", "select_model", "(", "noise_samples", ",", "target_samples", ",", "auto_assign_quality", ")", "\n", "prediction_model", ".", "fit", "(", "noise_samples", ",", "target_samples", ")", "\n", "\n", "if", "target_is_categorical", ":", "\n", "            ", "prediction_method", "=", "prediction_model", ".", "predict_probabilities", "\n", "", "else", ":", "\n", "            ", "prediction_method", "=", "prediction_model", ".", "predict", "\n", "", "", "elif", "prediction_model", "==", "'exact'", ":", "\n", "        ", "def", "exact_model", "(", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "            ", "return", "compute_data_from_noise", "(", "sub_causal_model", ",", "\n", "pd", ".", "DataFrame", "(", "X", ",", "columns", "=", "[", "x", "for", "x", "in", "node_names", "]", ")", ")", "[", "target_node", "]", ".", "to_numpy", "(", ")", "\n", "\n", "", "if", "target_is_categorical", ":", "\n", "            ", "list_of_classes", "=", "cast", "(", "ClassifierFCM", ",", "sub_causal_model", ".", "causal_mechanism", "(", "target_node", ")", ")", ".", "classifier_model", ".", "classes", "\n", "\n", "def", "prediction_method", "(", "X", ")", ":", "\n", "                ", "return", "(", "shape_into_2d", "(", "exact_model", "(", "X", ")", ")", "==", "list_of_classes", ")", ".", "astype", "(", "float", ")", "\n", "", "", "else", ":", "\n", "            ", "prediction_method", "=", "exact_model", "\n", "", "", "elif", "isinstance", "(", "prediction_model", ",", "str", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Invalid value for prediction_model: %s! This should either be an instance of a PredictionModel or\"", "\n", "\"one of the two string options 'exact' or 'approx'.\"", "%", "prediction_model", ")", "\n", "", "else", ":", "\n", "        ", "prediction_model", ".", "fit", "(", "noise_samples", ",", "target_samples", ")", "\n", "prediction_method", "=", "prediction_model", ".", "predict", "\n", "\n", "", "if", "attribution_func", "is", "None", ":", "\n", "        ", "if", "target_is_categorical", ":", "\n", "            ", "def", "attribution_func", "(", "x", ",", "_", ")", ":", "\n", "                ", "return", "-", "estimate_entropy_of_probabilities", "(", "x", ")", "\n", "", "", "else", ":", "\n", "            ", "def", "attribution_func", "(", "x", ",", "_", ")", ":", "\n", "                ", "return", "estimate_variance", "(", "x", ")", "\n", "\n", "", "", "", "_", ",", "noise_samples", "=", "noise_samples_of_ancestors", "(", "sub_causal_model", ",", "\n", "target_node", ",", "\n", "num_samples_randomization", "+", "num_samples_baseline", ")", "\n", "noise_samples", "=", "shape_into_2d", "(", "noise_samples", ".", "to_numpy", "(", ")", ")", "\n", "\n", "iccs", "=", "_estimate_iccs", "(", "attribution_func", ",", "\n", "prediction_method", ",", "\n", "noise_samples", "[", ":", "num_samples_randomization", "]", ",", "\n", "noise_samples", "[", "num_samples_randomization", ":", "num_samples_randomization", "+", "num_samples_baseline", "]", ",", "\n", "max_batch_size", ",", "\n", "ShapleyConfig", "(", ")", "if", "shapley_config", "is", "None", "else", "shapley_config", ")", "\n", "\n", "return", "{", "node", ":", "iccs", "[", "i", "]", "for", "i", ",", "node", "in", "enumerate", "(", "node_names", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence._estimate_iccs": [[313, 345], ["dowhy.gcm.util.general.shape_into_2d", "dowhy.gcm.shapley.estimate_shapley_values", "influence.intrinsic_causal_influence.prediction_method", "numpy.all", "influence.intrinsic_causal_influence.attribution_func", "numpy.all", "dowhy.gcm.util.general.shape_into_2d", "numpy.matlib.repmat", "dowhy.gcm.stats.marginal_expectation", "numpy.mean", "influence.intrinsic_causal_influence.prediction_method", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation"], ["", "def", "_estimate_iccs", "(", "attribution_func", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "float", "]", ",", "\n", "prediction_method", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "noise_samples", ":", "np", ".", "ndarray", ",", "\n", "baseline_noise_samples", ":", "np", ".", "ndarray", ",", "\n", "max_batch_size", ":", "int", ",", "\n", "shapley_config", ":", "ShapleyConfig", ")", ":", "\n", "    ", "target_values", "=", "shape_into_2d", "(", "prediction_method", "(", "baseline_noise_samples", ")", ")", "\n", "\n", "def", "icc_set_function", "(", "subset", ":", "np", ".", "ndarray", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "float", "]", ":", "\n", "        ", "if", "np", ".", "all", "(", "subset", "==", "1", ")", ":", "\n", "# In case of the full subset (no randomization), we get the same predictions as when we apply the", "\n", "# prediction method to the samples of interest, since all noise samples are replaced with a sample of", "\n", "# interest.", "\n", "            ", "predictions", "=", "target_values", "\n", "", "elif", "np", ".", "all", "(", "subset", "==", "0", ")", ":", "\n", "# In case of the empty subset (all are jointly randomize), it boils down to taking the average over all", "\n", "# predictions, seeing that the randomization yields the same values for each sample of interest (none of the", "\n", "# samples of interest are used to replace a (jointly) 'randomized' sample).", "\n", "            ", "predictions", "=", "repmat", "(", "np", ".", "mean", "(", "prediction_method", "(", "noise_samples", ")", ",", "axis", "=", "0", ")", ",", "baseline_noise_samples", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "predictions", "=", "marginal_expectation", "(", "prediction_method", ",", "\n", "feature_samples", "=", "noise_samples", ",", "\n", "baseline_samples", "=", "baseline_noise_samples", ",", "\n", "baseline_feature_indices", "=", "\n", "np", ".", "arange", "(", "0", ",", "noise_samples", ".", "shape", "[", "1", "]", ")", "[", "subset", "==", "1", "]", ",", "\n", "return_averaged_results", "=", "True", ",", "\n", "feature_perturbation", "=", "'randomize_columns_jointly'", ",", "\n", "max_batch_size", "=", "max_batch_size", ")", "\n", "", "return", "attribution_func", "(", "shape_into_2d", "(", "predictions", ")", ",", "target_values", ")", "\n", "\n", "", "return", "estimate_shapley_values", "(", "icc_set_function", ",", "noise_samples", ".", "shape", "[", "1", "]", ",", "shapley_config", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly_scorers.test_given_simple_toy_data_when_using_MedianCDFQuantileScorer_then_returns_expected_scores": [[7, 15], ["dowhy.gcm.MedianCDFQuantileScorer", "dowhy.gcm.MedianCDFQuantileScorer.fit", "dowhy.gcm.MedianCDFQuantileScorer.fit", "numpy.array", "pytest.approx", "dowhy.gcm.MedianCDFQuantileScorer.score", "pytest.approx", "numpy.array", "dowhy.gcm.MedianCDFQuantileScorer.score", "pytest.approx", "range", "dowhy.gcm.MedianCDFQuantileScorer.score", "numpy.array", "numpy.array", "numpy.array", "range"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["def", "test_given_simple_toy_data_when_using_MedianCDFQuantileScorer_then_returns_expected_scores", "(", ")", ":", "\n", "    ", "anomaly_scorer", "=", "MedianCDFQuantileScorer", "(", ")", "\n", "anomaly_scorer", ".", "fit", "(", "np", ".", "array", "(", "range", "(", "0", ",", "20", ")", ")", ")", "\n", "assert", "anomaly_scorer", ".", "score", "(", "np", ".", "array", "(", "[", "8", ",", "17", "]", ")", ")", "[", "0", "]", "==", "approx", "(", "1", "-", "17", "/", "20", ",", "abs", "=", "0.01", ")", "\n", "assert", "anomaly_scorer", ".", "score", "(", "np", ".", "array", "(", "[", "0", "]", ")", ")", "==", "approx", "(", "1", "-", "1", "/", "20", ",", "abs", "=", "0.01", ")", "\n", "\n", "anomaly_scorer", ".", "fit", "(", "np", ".", "array", "(", "[", "4.0", "for", "i", "in", "range", "(", "200", ")", "]", ")", ")", "\n", "assert", "anomaly_scorer", ".", "score", "(", "np", ".", "array", "(", "[", "4", "]", ")", ")", "==", "approx", "(", "0", ",", "abs", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly_scorers.test_given_simple_toy_data_when_using_MedianDeviationScorer_then_returns_expected_scores": [[17, 21], ["dowhy.gcm.MedianDeviationScorer", "dowhy.gcm.MedianDeviationScorer.fit", "dowhy.gcm.MedianDeviationScorer.score().reshape", "pytest.approx", "numpy.array", "numpy.array", "range", "dowhy.gcm.MedianDeviationScorer.score", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["", "def", "test_given_simple_toy_data_when_using_MedianDeviationScorer_then_returns_expected_scores", "(", ")", ":", "\n", "    ", "anomaly_scorer", "=", "MedianDeviationScorer", "(", ")", "\n", "anomaly_scorer", ".", "fit", "(", "np", ".", "array", "(", "range", "(", "0", ",", "20", ")", ")", "/", "10", ")", "\n", "assert", "anomaly_scorer", ".", "score", "(", "np", ".", "array", "(", "[", "0.8", ",", "1.7", "]", ")", ")", ".", "reshape", "(", "-", "1", ")", "==", "approx", "(", "np", ".", "array", "(", "[", "0.2", ",", "1", "]", ")", ",", "abs", "=", "0.1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change.test_distribution_change": [[13, 40], ["flaky.flaky", "numpy.random.uniform", "pandas.DataFrame", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.ProbabilisticCausalModel", "test_distribution_change._assign_causal_mechanisms", "dowhy.gcm.distribution_change", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "pytest.approx", "dowhy.gcm.shapley.ShapleyConfig"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change._assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.distribution_change"], ["@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_distribution_change", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "3", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "_assign_causal_mechanisms", "(", "causal_model", ")", "\n", "\n", "results", "=", "distribution_change", "(", "causal_model", ",", "\n", "original_observations", ",", "\n", "outlier_observations", ",", "\n", "'X3'", ",", "\n", "shapley_config", "=", "ShapleyConfig", "(", "n_jobs", "=", "1", ")", ")", "\n", "\n", "assert", "results", "[", "'X3'", "]", ">", "results", "[", "'X2'", "]", "\n", "assert", "results", "[", "'X2'", "]", ">", "results", "[", "'X0'", "]", "\n", "assert", "'X1'", "not", "in", "results", "\n", "assert", "results", "[", "'X0'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.15", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change.test_distribution_change_of_graphs": [[42, 69], ["flaky.flaky", "numpy.random.uniform", "pandas.DataFrame", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.ProbabilisticCausalModel", "test_distribution_change._assign_causal_mechanisms", "dowhy.gcm.ProbabilisticCausalModel", "test_distribution_change._assign_causal_mechanisms", "dowhy.gcm.fit", "dowhy.gcm.fit", "dowhy.gcm.distribution_change_of_graphs", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "networkx.DiGraph", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change._assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change._assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.distribution_change_of_graphs"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_distribution_change_of_graphs", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "3", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "causal_model_old", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "_assign_causal_mechanisms", "(", "causal_model_old", ")", "\n", "causal_model_new", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "_assign_causal_mechanisms", "(", "causal_model_new", ")", "\n", "\n", "fit", "(", "causal_model_old", ",", "original_observations", ")", "\n", "fit", "(", "causal_model_new", ",", "outlier_observations", ")", "\n", "\n", "results", "=", "distribution_change_of_graphs", "(", "causal_model_old", ",", "causal_model_new", ",", "'X3'", ")", "\n", "\n", "assert", "results", "[", "'X3'", "]", ">", "results", "[", "'X2'", "]", ">", "results", "[", "'X0'", "]", "\n", "assert", "'X1'", "not", "in", "results", "\n", "assert", "results", "[", "'X0'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change.test_when_using_distribution_change_without_fdrc_then_returns_valid_results": [[71, 96], ["flaky.flaky", "numpy.random.uniform", "pandas.DataFrame", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.ProbabilisticCausalModel", "test_distribution_change._assign_causal_mechanisms", "dowhy.gcm.distribution_change", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change._assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.distribution_change"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_when_using_distribution_change_without_fdrc_then_returns_valid_results", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "3", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "_assign_causal_mechanisms", "(", "causal_model", ")", "\n", "\n", "results", "=", "distribution_change", "(", "causal_model", ",", "\n", "original_observations", ",", "\n", "outlier_observations", ",", "\n", "'X3'", ",", "\n", "mechanism_change_test_fdr_control_method", "=", "None", ")", "\n", "\n", "assert", "results", "[", "'X3'", "]", ">", "results", "[", "'X2'", "]", ">", "results", "[", "'X0'", "]", "\n", "assert", "'X1'", "not", "in", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change.test_when_using_distribution_change_with_return_additional_info_then_returns_additional_info": [[98, 138], ["flaky.flaky", "numpy.random.uniform", "pandas.DataFrame", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.ProbabilisticCausalModel", "test_distribution_change._assign_causal_mechanisms", "dowhy.gcm.distribution_change", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "type", "type", "causal_model_old.causal_mechanism", "causal_model_new.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change._assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.distribution_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_when_using_distribution_change_with_return_additional_info_then_returns_additional_info", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "3", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "_assign_causal_mechanisms", "(", "causal_model", ")", "\n", "\n", "attributions", ",", "mechanism_changes", ",", "causal_model_old", ",", "causal_model_new", "=", "distribution_change", "(", "\n", "causal_model", ",", "\n", "original_observations", ",", "\n", "outlier_observations", ",", "\n", "'X3'", ",", "\n", "mechanism_change_test_fdr_control_method", "=", "None", ",", "\n", "return_additional_info", "=", "True", ")", "\n", "\n", "assert", "attributions", "[", "'X3'", "]", ">", "attributions", "[", "'X2'", "]", ">", "attributions", "[", "'X0'", "]", "\n", "assert", "'X1'", "not", "in", "attributions", "\n", "\n", "assert", "not", "mechanism_changes", "[", "'X0'", "]", "\n", "assert", "mechanism_changes", "[", "'X2'", "]", "\n", "assert", "mechanism_changes", "[", "'X3'", "]", "\n", "\n", "assert", "'X1'", "not", "in", "causal_model_old", ".", "graph", ".", "nodes", "\n", "assert", "'X1'", "not", "in", "causal_model_new", ".", "graph", ".", "nodes", "\n", "\n", "for", "node", "in", "causal_model", ".", "graph", ".", "nodes", ":", "\n", "        ", "if", "node", "==", "'X1'", ":", "\n", "            ", "continue", "\n", "", "assert", "type", "(", "causal_model_old", ".", "causal_mechanism", "(", "node", ")", ")", "==", "type", "(", "causal_model_new", ".", "causal_mechanism", "(", "node", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_distribution_change._assign_causal_mechanisms": [[140, 145], ["causal_model.set_causal_mechanism", "causal_model.set_causal_mechanism", "causal_model.set_causal_mechanism", "causal_model.set_causal_mechanism", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["", "", "def", "_assign_causal_mechanisms", "(", "causal_model", ")", ":", "\n", "    ", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "AdditiveNoiseModel", "(", "create_linear_regressor", "(", ")", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "create_linear_regressor", "(", ")", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X3'", ",", "AdditiveNoiseModel", "(", "create_linear_regressor", "(", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_linear_regression_data": [[13, 18], ["numpy.random.normal", "numpy.sum", "numpy.random.uniform"], "function", ["None"], ["def", "__generate_linear_regression_data", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "5", ")", ")", "\n", "Y", "=", "np", ".", "sum", "(", "X", "*", "np", ".", "random", ".", "uniform", "(", "-", "5", ",", "5", ",", "X", ".", "shape", "[", "1", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_non_linear_regression_data": [[20, 25], ["numpy.random.normal", "numpy.sum"], "function", ["None"], ["", "def", "__generate_non_linear_regression_data", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "5", ")", ")", "\n", "Y", "=", "np", ".", "sum", "(", "X", "**", "2", ",", "axis", "=", "1", ")", "\n", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_linear_classification_data": [[27, 32], ["numpy.random.normal", "numpy.sum", "numpy.random.uniform"], "function", ["None"], ["", "def", "__generate_linear_classification_data", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "5", ")", ")", "\n", "Y", "=", "(", "np", ".", "sum", "(", "X", "*", "np", ".", "random", ".", "uniform", "(", "-", "5", ",", "5", ",", "X", ".", "shape", "[", "1", "]", ")", ",", "axis", "=", "1", ")", ">", "0", ")", ".", "astype", "(", "str", ")", "\n", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_non_classification_data": [[34, 39], ["numpy.random.normal", "numpy.sum", "numpy.median", "numpy.exp", "numpy.sum", "numpy.exp"], "function", ["None"], ["", "def", "__generate_non_classification_data", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "5", ")", ")", "\n", "Y", "=", "(", "np", ".", "sum", "(", "np", ".", "exp", "(", "X", ")", ",", "axis", "=", "1", ")", ">", "np", ".", "median", "(", "np", ".", "sum", "(", "np", ".", "exp", "(", "X", ")", ",", "axis", "=", "1", ")", ")", ")", ".", "astype", "(", "str", ")", "\n", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_given_linear_regression_problem_when_auto_assign_causal_models_with_good_quality_returns_linear_model": [[41, 52], ["flaky.flaky", "test_auto.__generate_linear_regression_data", "dowhy.gcm.ProbabilisticCausalModel", "data.update", "dowhy.gcm.auto.assign_causal_mechanisms", "isinstance", "networkx.DiGraph", "pandas.DataFrame", "str", "range", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_linear_regression_data", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_linear_regression_problem_when_auto_assign_causal_models_with_good_quality_returns_linear_model", "(", ")", ":", "\n", "    ", "X", ",", "Y", "=", "__generate_linear_regression_data", "(", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "\n", "'Y'", ")", "]", ")", ")", "\n", "data", "=", "{", "'X'", "+", "str", "(", "i", ")", ":", "X", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", "}", "\n", "data", ".", "update", "(", "{", "'Y'", ":", "Y", "}", ")", "\n", "\n", "assign_causal_mechanisms", "(", "causal_model", ",", "pd", ".", "DataFrame", "(", "data", ")", ",", "quality", "=", "AssignmentQuality", ".", "GOOD", ")", "\n", "assert", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "prediction_model", ".", "sklearn_model", ",", "LinearRegression", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_given_linear_regression_problem_when_auto_assign_causal_models_with_better_quality_returns_linear_model": [[54, 65], ["flaky.flaky", "test_auto.__generate_linear_regression_data", "dowhy.gcm.ProbabilisticCausalModel", "data.update", "dowhy.gcm.auto.assign_causal_mechanisms", "isinstance", "networkx.DiGraph", "pandas.DataFrame", "str", "range", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_linear_regression_data", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_linear_regression_problem_when_auto_assign_causal_models_with_better_quality_returns_linear_model", "(", ")", ":", "\n", "    ", "X", ",", "Y", "=", "__generate_linear_regression_data", "(", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "\n", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "'Y'", ")", "]", ")", ")", "\n", "data", "=", "{", "'X'", "+", "str", "(", "i", ")", ":", "X", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", "}", "\n", "data", ".", "update", "(", "{", "'Y'", ":", "Y", "}", ")", "\n", "\n", "assign_causal_mechanisms", "(", "causal_model", ",", "pd", ".", "DataFrame", "(", "data", ")", ",", "quality", "=", "AssignmentQuality", ".", "BETTER", ")", "\n", "assert", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "prediction_model", ".", "sklearn_model", ",", "LinearRegression", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_given_non_linear_regression_problem_when_auto_assign_causal_models_with_good_quality_returns_non_linear_model": [[67, 78], ["flaky.flaky", "test_auto.__generate_non_linear_regression_data", "dowhy.gcm.ProbabilisticCausalModel", "data.update", "dowhy.gcm.auto.assign_causal_mechanisms", "isinstance", "networkx.DiGraph", "pandas.DataFrame", "str", "range", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_non_linear_regression_data", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_non_linear_regression_problem_when_auto_assign_causal_models_with_good_quality_returns_non_linear_model", "(", ")", ":", "\n", "    ", "X", ",", "Y", "=", "__generate_non_linear_regression_data", "(", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "\n", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "'Y'", ")", "]", ")", ")", "\n", "data", "=", "{", "'X'", "+", "str", "(", "i", ")", ":", "X", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", "}", "\n", "data", ".", "update", "(", "{", "'Y'", ":", "Y", "}", ")", "\n", "\n", "assign_causal_mechanisms", "(", "causal_model", ",", "pd", ".", "DataFrame", "(", "data", ")", ",", "quality", "=", "AssignmentQuality", ".", "GOOD", ")", "\n", "assert", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "prediction_model", ".", "sklearn_model", ",", "HistGradientBoostingRegressor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_given_non_linear_regression_problem_when_auto_assign_causal_models_with_better_quality_returns_non_linear_model": [[80, 94], ["flaky.flaky", "test_auto.__generate_non_linear_regression_data", "dowhy.gcm.ProbabilisticCausalModel", "data.update", "dowhy.gcm.auto.assign_causal_mechanisms", "networkx.DiGraph", "pandas.DataFrame", "isinstance", "isinstance", "isinstance", "isinstance", "str", "range", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_non_linear_regression_data", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_non_linear_regression_problem_when_auto_assign_causal_models_with_better_quality_returns_non_linear_model", "(", ")", ":", "\n", "    ", "X", ",", "Y", "=", "__generate_non_linear_regression_data", "(", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "\n", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "'Y'", ")", "]", ")", ")", "\n", "data", "=", "{", "'X'", "+", "str", "(", "i", ")", ":", "X", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", "}", "\n", "data", ".", "update", "(", "{", "'Y'", ":", "Y", "}", ")", "\n", "\n", "assign_causal_mechanisms", "(", "causal_model", ",", "pd", ".", "DataFrame", "(", "data", ")", ",", "quality", "=", "AssignmentQuality", ".", "BETTER", ")", "\n", "assert", "not", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "prediction_model", ".", "sklearn_model", ",", "LinearRegression", ")", "\n", "assert", "not", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "prediction_model", ".", "sklearn_model", ",", "LassoCV", ")", "\n", "assert", "not", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "prediction_model", ".", "sklearn_model", ",", "ElasticNetCV", ")", "\n", "assert", "not", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "prediction_model", ".", "sklearn_model", ",", "RidgeCV", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_given_linear_classification_problem_when_auto_assign_causal_models_with_good_quality_returns_linear_model": [[96, 107], ["flaky.flaky", "test_auto.__generate_linear_classification_data", "dowhy.gcm.ProbabilisticCausalModel", "data.update", "dowhy.gcm.auto.assign_causal_mechanisms", "isinstance", "networkx.DiGraph", "pandas.DataFrame", "str", "range", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_linear_classification_data", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_linear_classification_problem_when_auto_assign_causal_models_with_good_quality_returns_linear_model", "(", ")", ":", "\n", "    ", "X", ",", "Y", "=", "__generate_linear_classification_data", "(", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "\n", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "'Y'", ")", "]", ")", ")", "\n", "data", "=", "{", "'X'", "+", "str", "(", "i", ")", ":", "X", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", "}", "\n", "data", ".", "update", "(", "{", "'Y'", ":", "Y", "}", ")", "\n", "\n", "assign_causal_mechanisms", "(", "causal_model", ",", "pd", ".", "DataFrame", "(", "data", ")", ",", "quality", "=", "AssignmentQuality", ".", "GOOD", ")", "\n", "assert", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "classifier_model", ".", "sklearn_model", ",", "LogisticRegression", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_given_linear_classification_problem_when_auto_assign_causal_models_with_better_quality_returns_linear_model": [[109, 120], ["flaky.flaky", "test_auto.__generate_linear_classification_data", "dowhy.gcm.ProbabilisticCausalModel", "data.update", "dowhy.gcm.auto.assign_causal_mechanisms", "isinstance", "networkx.DiGraph", "pandas.DataFrame", "str", "range", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_linear_classification_data", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_linear_classification_problem_when_auto_assign_causal_models_with_better_quality_returns_linear_model", "(", ")", ":", "\n", "    ", "X", ",", "Y", "=", "__generate_linear_classification_data", "(", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "\n", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "'Y'", ")", "]", ")", ")", "\n", "data", "=", "{", "'X'", "+", "str", "(", "i", ")", ":", "X", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", "}", "\n", "data", ".", "update", "(", "{", "'Y'", ":", "Y", "}", ")", "\n", "\n", "assign_causal_mechanisms", "(", "causal_model", ",", "pd", ".", "DataFrame", "(", "data", ")", ",", "quality", "=", "AssignmentQuality", ".", "BETTER", ")", "\n", "assert", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "classifier_model", ".", "sklearn_model", ",", "LogisticRegression", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_given_non_linear_classification_problem_when_auto_assign_causal_models_with_good_quality_returns_non_linear_model": [[122, 133], ["flaky.flaky", "test_auto.__generate_non_classification_data", "dowhy.gcm.ProbabilisticCausalModel", "data.update", "dowhy.gcm.auto.assign_causal_mechanisms", "isinstance", "networkx.DiGraph", "pandas.DataFrame", "str", "range", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_non_classification_data", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_non_linear_classification_problem_when_auto_assign_causal_models_with_good_quality_returns_non_linear_model", "(", ")", ":", "\n", "    ", "X", ",", "Y", "=", "__generate_non_classification_data", "(", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "\n", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "'Y'", ")", "]", ")", ")", "\n", "data", "=", "{", "'X'", "+", "str", "(", "i", ")", ":", "X", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", "}", "\n", "data", ".", "update", "(", "{", "'Y'", ":", "Y", "}", ")", "\n", "\n", "assign_causal_mechanisms", "(", "causal_model", ",", "pd", ".", "DataFrame", "(", "data", ")", ",", "quality", "=", "AssignmentQuality", ".", "GOOD", ")", "\n", "assert", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "classifier_model", ".", "sklearn_model", ",", "HistGradientBoostingClassifier", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_given_non_linear_classification_problem_when_auto_assign_causal_models_with_better_quality_returns_non_linear_model": [[135, 147], ["flaky.flaky", "test_auto.__generate_non_classification_data", "dowhy.gcm.ProbabilisticCausalModel", "data.update", "dowhy.gcm.auto.assign_causal_mechanisms", "networkx.DiGraph", "pandas.DataFrame", "isinstance", "isinstance", "str", "range", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.__generate_non_classification_data", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.backdoor.Path.update", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_non_linear_classification_problem_when_auto_assign_causal_models_with_better_quality_returns_non_linear_model", "(", ")", ":", "\n", "    ", "X", ",", "Y", "=", "__generate_non_classification_data", "(", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "\n", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "'Y'", ")", "]", ")", ")", "\n", "data", "=", "{", "'X'", "+", "str", "(", "i", ")", ":", "X", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", "}", "\n", "data", ".", "update", "(", "{", "'Y'", ":", "Y", "}", ")", "\n", "\n", "assign_causal_mechanisms", "(", "causal_model", ",", "pd", ".", "DataFrame", "(", "data", ")", ",", "quality", "=", "AssignmentQuality", ".", "BETTER", ")", "\n", "assert", "not", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "classifier_model", ".", "sklearn_model", ",", "LogisticRegression", ")", "\n", "assert", "not", "isinstance", "(", "causal_model", ".", "causal_mechanism", "(", "'Y'", ")", ".", "classifier_model", ".", "sklearn_model", ",", "GaussianNB", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_auto.test_when_auto_called_from_main_namespace_returns_no_attribute_error": [[149, 152], ["None"], "function", ["None"], ["", "def", "test_when_auto_called_from_main_namespace_returns_no_attribute_error", "(", ")", ":", "\n", "    ", "from", "dowhy", "import", "gcm", "\n", "_", "=", "gcm", ".", "auto", ".", "AssignmentQuality", ".", "GOOD", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_fit_causal_graph_using_post_nonlinear_models": [[20, 40], ["dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism().draw_samples().squeeze", "pandas.DataFrame", "dowhy.gcm.fit", "numpy.array", "numpy.zeros", "range", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism().draw_samples", "pytest.approx", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism().draw_samples", "dowhy.gcm.ml.create_linear_regressor", "numpy.random.normal", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["def", "test_fit_causal_graph_using_post_nonlinear_models", "(", ")", ":", "\n", "    ", "scm", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", "]", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X1'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "X0", "=", "scm", ".", "causal_mechanism", "(", "'X0'", ")", ".", "draw_samples", "(", "1000", ")", ".", "squeeze", "(", ")", "\n", "\n", "test_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X0", "*", "2", "+", "2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "}", ")", "\n", "\n", "fit", "(", "scm", ",", "test_data", ")", "\n", "\n", "test_parent_samples", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", "]", ")", "\n", "target_values", "=", "test_parent_samples", "*", "2", "+", "2", "\n", "\n", "mean_samples", "=", "np", ".", "zeros", "(", "target_values", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "100", ")", ":", "\n", "        ", "mean_samples", "+=", "scm", ".", "causal_mechanism", "(", "'X1'", ")", ".", "draw_samples", "(", "test_parent_samples", ")", "\n", "", "mean_samples", "/=", "100", "\n", "\n", "assert", "mean_samples", "==", "approx", "(", "target_values", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_fit_causal_graph_using_post_nonlinear_models_with_categorical_features": [[42, 76], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "numpy.random.normal", "numpy.random.choice().astype", "range", "pandas.DataFrame", "dowhy.gcm.fit", "pd.DataFrame.to_numpy", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.AdditiveNoiseModel", "X2.append", "dowhy.gcm.StructuralCausalModel.causal_mechanism().evaluate", "pytest.approx", "dowhy.gcm.StructuralCausalModel.causal_mechanism().evaluate", "pytest.approx", "numpy.random.choice", "numpy.array", "numpy.array", "numpy.array", "test_data[].astype().reshape", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.StructuralCausalModel.causal_mechanism", "dowhy.gcm.StructuralCausalModel.causal_mechanism", "test_data[].astype"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_fit_causal_graph_using_post_nonlinear_models_with_categorical_features", "(", ")", ":", "\n", "    ", "scm", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X1'", ",", "'X2'", ")", "]", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X1'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "choice", "(", "3", ",", "1000", ")", ".", "astype", "(", "str", ")", "\n", "X2", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "1000", ")", ":", "\n", "        ", "tmp_value", "=", "2", "*", "X0", "[", "i", "]", "\n", "\n", "if", "X1", "[", "i", "]", "==", "'0'", ":", "\n", "            ", "tmp_value", "-=", "5", "\n", "", "elif", "X1", "[", "i", "]", "==", "'1'", ":", "\n", "            ", "tmp_value", "+=", "10", "\n", "", "else", ":", "\n", "            ", "tmp_value", "+=", "5", "\n", "\n", "", "X2", ".", "append", "(", "tmp_value", ")", "\n", "\n", "", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", "}", ")", "\n", "\n", "fit", "(", "scm", ",", "data", "=", "training_data", ")", "\n", "\n", "assert", "scm", ".", "causal_mechanism", "(", "'X2'", ")", ".", "evaluate", "(", "np", ".", "array", "(", "[", "[", "2", ",", "'1'", "]", "]", ",", "dtype", "=", "object", ")", ",", "np", ".", "array", "(", "[", "0", "]", ")", ")", "==", "approx", "(", "14", ")", "\n", "\n", "test_data", "=", "training_data", ".", "to_numpy", "(", ")", "\n", "\n", "assert", "scm", ".", "causal_mechanism", "(", "'X2'", ")", ".", "evaluate", "(", "test_data", "[", ":", ",", ":", "2", "]", ",", "np", ".", "array", "(", "[", "0", "]", "*", "1", ")", ")", "==", "approx", "(", "test_data", "[", ":", ",", "2", "]", ".", "astype", "(", "float", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_fit_causal_graph_using_additive_noise_model": [[78, 98], ["dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.causal_mechanism().draw_samples().squeeze", "pandas.DataFrame", "dowhy.gcm.fit", "numpy.array", "numpy.zeros", "range", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.StructuralCausalModel.causal_mechanism().draw_samples", "pytest.approx", "dowhy.gcm.StructuralCausalModel.causal_mechanism().draw_samples", "dowhy.gcm.ml.create_linear_regressor", "numpy.random.normal", "dowhy.gcm.StructuralCausalModel.causal_mechanism", "dowhy.gcm.StructuralCausalModel.causal_mechanism"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism"], ["", "def", "test_fit_causal_graph_using_additive_noise_model", "(", ")", ":", "\n", "    ", "scm", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", "]", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X1'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "X0", "=", "scm", ".", "causal_mechanism", "(", "'X0'", ")", ".", "draw_samples", "(", "1000", ")", ".", "squeeze", "(", ")", "\n", "\n", "test_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X0", "*", "2", "+", "2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "}", ")", "\n", "\n", "fit", "(", "scm", ",", "test_data", ")", "\n", "\n", "test_parent_samples", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", "]", ")", "\n", "target_values", "=", "test_parent_samples", "*", "2", "+", "2", "\n", "\n", "mean_samples", "=", "np", ".", "zeros", "(", "target_values", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "100", ")", ":", "\n", "        ", "mean_samples", "+=", "scm", ".", "causal_mechanism", "(", "'X1'", ")", ".", "draw_samples", "(", "test_parent_samples", ")", "\n", "", "mean_samples", "/=", "100", "\n", "\n", "assert", "mean_samples", "==", "approx", "(", "target_values", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_classifier_sem_throws_error_when_non_string_targets": [[100, 110], ["dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "numpy.random.normal", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ClassifierFCM", "pytest.raises", "dowhy.gcm.fit", "dowhy.gcm.ml.create_logistic_regression_classifier", "numpy.median", "pandas.DataFrame"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier"], ["", "def", "test_classifier_sem_throws_error_when_non_string_targets", "(", ")", ":", "\n", "    ", "scm", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", "]", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X1'", ",", "ClassifierFCM", "(", "classifier_model", "=", "create_logistic_regression_classifier", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "(", "X0", ">", "np", ".", "median", "(", "X0", ")", ")", ".", "astype", "(", "int", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "fit", "(", "scm", ",", "data", "=", "(", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", "}", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_classifier_sem_produces_strings": [[112, 126], ["dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.fit", "dowhy.gcm.StructuralCausalModel.causal_mechanism().draw_samples", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ClassifierFCM", "isinstance", "dowhy.gcm.StructuralCausalModel.causal_mechanism", "dowhy.gcm.ml.create_logistic_regression_classifier", "numpy.median"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier"], ["", "", "def", "test_classifier_sem_produces_strings", "(", ")", ":", "\n", "    ", "scm", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", "]", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X1'", ",", "ClassifierFCM", "(", "classifier_model", "=", "create_logistic_regression_classifier", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "(", "X0", ">", "np", ".", "median", "(", "X0", ")", ")", ".", "astype", "(", "str", ")", "\n", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", "}", ")", "\n", "\n", "fit", "(", "scm", ",", "training_data", ")", "\n", "\n", "for", "val", "in", "scm", ".", "causal_mechanism", "(", "'X1'", ")", ".", "draw_samples", "(", "X0", ")", ":", "\n", "        ", "assert", "isinstance", "(", "val", "[", "0", "]", ",", "str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_classifier_sem_with_categorical_inputs": [[128, 169], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "numpy.random.normal", "numpy.random.choice().astype", "range", "pandas.DataFrame", "dowhy.gcm.fit", "typing.cast", "pd.DataFrame.to_numpy", "numpy.unique", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ClassifierFCM", "X2.append", "dowhy.gcm.StructuralCausalModel.causal_mechanism", "typing.cast.estimate_probabilities", "pytest.approx", "numpy.sum", "typing.cast.draw_samples", "pytest.approx", "numpy.random.choice", "numpy.array", "numpy.array", "numpy.array", "dowhy.gcm.ml.create_logistic_regression_classifier", "numpy.median", "numpy.argmax", "X2.astype", "typing.cast.estimate_probabilities"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.estimate_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.ClassifierFCM.estimate_probabilities"], ["", "", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_classifier_sem_with_categorical_inputs", "(", ")", ":", "\n", "    ", "scm", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X1'", ",", "'X2'", ")", "]", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X1'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X2'", ",", "ClassifierFCM", "(", "classifier_model", "=", "create_logistic_regression_classifier", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "choice", "(", "3", ",", "1000", ")", ".", "astype", "(", "str", ")", "\n", "X2", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "1000", ")", ":", "\n", "        ", "tmp_value", "=", "2", "*", "X0", "[", "i", "]", "\n", "\n", "if", "X1", "[", "i", "]", "==", "'0'", ":", "\n", "            ", "tmp_value", "-=", "5", "\n", "", "elif", "X1", "[", "i", "]", "==", "'1'", ":", "\n", "            ", "tmp_value", "+=", "10", "\n", "", "else", ":", "\n", "            ", "tmp_value", "+=", "5", "\n", "\n", "", "X2", ".", "append", "(", "tmp_value", ")", "\n", "\n", "", "X2", "=", "(", "X2", ">", "np", ".", "median", "(", "X2", ")", ")", ".", "astype", "(", "str", ")", "\n", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X2", "}", ")", "\n", "\n", "fit", "(", "scm", ",", "training_data", ")", "\n", "\n", "x2_fcm", "=", "cast", "(", "ClassifierFCM", ",", "scm", ".", "causal_mechanism", "(", "'X2'", ")", ")", "\n", "assert", "x2_fcm", ".", "estimate_probabilities", "(", "np", ".", "array", "(", "[", "[", "2", ",", "'1'", "]", "]", ",", "dtype", "=", "object", ")", ")", "==", "approx", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", "]", ")", ",", "abs", "=", "0.01", ")", "\n", "\n", "test_data", "=", "training_data", ".", "to_numpy", "(", ")", "\n", "X2", "[", "X2", "==", "'True'", "]", "=", "1", "\n", "X2", "[", "X2", "==", "'False'", "]", "=", "0", "\n", "assert", "np", ".", "sum", "(", "np", ".", "argmax", "(", "x2_fcm", ".", "estimate_probabilities", "(", "test_data", "[", ":", ",", ":", "2", "]", ")", ",", "axis", "=", "1", ")", "!=", "X2", ".", "astype", "(", "int", ")", ")", "<", "20", "\n", "\n", "_", ",", "counts", "=", "np", ".", "unique", "(", "x2_fcm", ".", "draw_samples", "(", "test_data", "[", ":", ",", ":", "2", "]", ")", ",", "return_counts", "=", "True", ")", "\n", "assert", "counts", "/", "1000", "==", "approx", "(", "np", ".", "array", "(", "[", "0.5", ",", "0.5", "]", ")", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_clone_sem_model_with_scipy_distribution": [[171, 186], ["dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel.clone", "dowhy.gcm.AdditiveNoiseModel.clone", "dowhy.gcm.AdditiveNoiseModel.fit", "org_model.clone.fit", "org_model.clone.fit", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ScipyDistribution", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["", "def", "test_clone_sem_model_with_scipy_distribution", "(", ")", ":", "\n", "    ", "org_model", "=", "AdditiveNoiseModel", "(", "create_linear_regressor", "(", ")", ",", "ScipyDistribution", "(", "norm", ")", ")", "\n", "clone_1", "=", "org_model", ".", "clone", "(", ")", "\n", "clone_2", "=", "org_model", ".", "clone", "(", ")", "\n", "\n", "org_model", ".", "fit", "(", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", ")", "\n", "clone_1", ".", "fit", "(", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", ")", "\n", "clone_2", ".", "fit", "(", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", ")", "\n", "\n", "assert", "isinstance", "(", "clone_1", ",", "AdditiveNoiseModel", ")", "\n", "assert", "isinstance", "(", "clone_1", ".", "prediction_model", ",", "SklearnRegressionModel", ")", "\n", "assert", "isinstance", "(", "clone_1", ".", "noise_model", ",", "ScipyDistribution", ")", "\n", "assert", "isinstance", "(", "clone_2", ",", "AdditiveNoiseModel", ")", "\n", "assert", "isinstance", "(", "clone_2", ".", "prediction_model", ",", "SklearnRegressionModel", ")", "\n", "assert", "isinstance", "(", "clone_2", ".", "noise_model", ",", "ScipyDistribution", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_post_non_linear_sem_with_invertible_identity": [[188, 208], ["numpy.random.normal", "numpy.random.normal", "dowhy.gcm.PostNonlinearModel", "dowhy.gcm.PostNonlinearModel", "dowhy.gcm.PostNonlinearModel.fit", "dowhy.gcm.ml.create_linear_regressor_with_given_parameters", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ml.regression.InvertibleIdentityFunction", "dowhy.gcm.PostNonlinearModel.estimate_noise().reshape", "pytest.approx", "dowhy.gcm.PostNonlinearModel.evaluate().squeeze", "dowhy.gcm.PostNonlinearModel.evaluate().squeeze", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ml.regression.InvertibleIdentityFunction", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.array", "dowhy.gcm.PostNonlinearModel.draw_samples", "numpy.array", "dowhy.gcm.PostNonlinearModel.estimate_noise", "dowhy.gcm.PostNonlinearModel.evaluate", "dowhy.gcm.PostNonlinearModel.evaluate", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor_with_given_parameters", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.estimate_noise", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate"], ["", "def", "test_post_non_linear_sem_with_invertible_identity", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "N", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "Y", "=", "2", "*", "X", "+", "N", "\n", "\n", "sem_ground_truth", "=", "PostNonlinearModel", "(", "create_linear_regressor_with_given_parameters", "(", "coefficients", "=", "np", ".", "array", "(", "[", "2", "]", ")", ")", ",", "\n", "EmpiricalDistribution", "(", ")", ",", "\n", "InvertibleIdentityFunction", "(", ")", ")", "\n", "\n", "assert", "sem_ground_truth", ".", "estimate_noise", "(", "Y", ",", "X", ")", ".", "reshape", "(", "-", "1", ")", "==", "approx", "(", "N", ")", "\n", "assert", "sem_ground_truth", ".", "evaluate", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "np", ".", "array", "(", "[", "0", "]", ")", ")", ".", "squeeze", "(", ")", "==", "4", "\n", "assert", "sem_ground_truth", ".", "evaluate", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", ".", "squeeze", "(", ")", "==", "4", "+", "1", "\n", "\n", "sem_fitted", "=", "PostNonlinearModel", "(", "create_linear_regressor", "(", ")", ",", "\n", "EmpiricalDistribution", "(", ")", ",", "\n", "InvertibleIdentityFunction", "(", ")", ")", "\n", "sem_fitted", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n", "assert", "sem_fitted", ".", "prediction_model", ".", "sklearn_model", ".", "coef_", "==", "approx", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "abs", "=", "0.05", ")", "\n", "assert", "np", ".", "mean", "(", "sem_fitted", ".", "draw_samples", "(", "np", ".", "array", "(", "[", "2", "]", "*", "1000", ")", ")", ")", "==", "approx", "(", "4", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_post_non_linear_sem_with_invertible_exponential": [[210, 229], ["numpy.random.normal", "numpy.random.normal", "numpy.exp", "dowhy.gcm.PostNonlinearModel", "dowhy.gcm.PostNonlinearModel", "dowhy.gcm.PostNonlinearModel.fit", "dowhy.gcm.ml.create_linear_regressor_with_given_parameters", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ml.regression.InvertibleExponentialFunction", "dowhy.gcm.PostNonlinearModel.estimate_noise().reshape", "pytest.approx", "dowhy.gcm.PostNonlinearModel.evaluate().squeeze", "numpy.exp", "dowhy.gcm.PostNonlinearModel.evaluate().squeeze", "numpy.exp", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ml.regression.InvertibleExponentialFunction", "pytest.approx", "numpy.array", "numpy.array", "dowhy.gcm.PostNonlinearModel.estimate_noise", "dowhy.gcm.PostNonlinearModel.evaluate", "dowhy.gcm.PostNonlinearModel.evaluate", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor_with_given_parameters", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.estimate_noise", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate"], ["", "def", "test_post_non_linear_sem_with_invertible_exponential", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "N", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "Y", "=", "np", ".", "exp", "(", "2", "*", "X", "+", "N", ")", "\n", "\n", "sem_ground_truth", "=", "PostNonlinearModel", "(", "create_linear_regressor_with_given_parameters", "(", "coefficients", "=", "np", ".", "array", "(", "[", "2", "]", ")", ")", ",", "\n", "EmpiricalDistribution", "(", ")", ",", "\n", "InvertibleExponentialFunction", "(", ")", ")", "\n", "\n", "assert", "sem_ground_truth", ".", "estimate_noise", "(", "Y", ",", "X", ")", ".", "reshape", "(", "-", "1", ")", "==", "approx", "(", "N", ")", "\n", "assert", "sem_ground_truth", ".", "evaluate", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "np", ".", "array", "(", "[", "0", "]", ")", ")", ".", "squeeze", "(", ")", "==", "np", ".", "exp", "(", "4", ")", "\n", "assert", "sem_ground_truth", ".", "evaluate", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", ".", "squeeze", "(", ")", "==", "np", ".", "exp", "(", "4", "+", "1", ")", "\n", "\n", "sem_fitted", "=", "PostNonlinearModel", "(", "create_linear_regressor", "(", ")", ",", "\n", "EmpiricalDistribution", "(", ")", ",", "\n", "InvertibleExponentialFunction", "(", ")", ")", "\n", "sem_fitted", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n", "assert", "sem_fitted", ".", "prediction_model", ".", "sklearn_model", ".", "coef_", "==", "approx", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_fcms.test_post_non_linear_sem_with_invertible_logarithmic": [[231, 250], ["abs", "abs", "numpy.log", "dowhy.gcm.PostNonlinearModel", "dowhy.gcm.PostNonlinearModel", "dowhy.gcm.PostNonlinearModel.fit", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.ml.create_linear_regressor_with_given_parameters", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ml.regression.InvertibleLogarithmicFunction", "dowhy.gcm.PostNonlinearModel.estimate_noise().reshape", "pytest.approx", "dowhy.gcm.PostNonlinearModel.evaluate().squeeze", "numpy.log", "dowhy.gcm.PostNonlinearModel.evaluate().squeeze", "numpy.log", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ml.regression.InvertibleLogarithmicFunction", "pytest.approx", "numpy.array", "numpy.array", "dowhy.gcm.PostNonlinearModel.estimate_noise", "dowhy.gcm.PostNonlinearModel.evaluate", "dowhy.gcm.PostNonlinearModel.evaluate", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor_with_given_parameters", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.fcms.PostNonlinearModel.estimate_noise", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate"], ["", "def", "test_post_non_linear_sem_with_invertible_logarithmic", "(", ")", ":", "\n", "    ", "X", "=", "abs", "(", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", ")", "\n", "N", "=", "abs", "(", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", ")", "\n", "Y", "=", "np", ".", "log", "(", "2", "*", "X", "+", "N", ")", "\n", "\n", "sem_ground_truth", "=", "PostNonlinearModel", "(", "create_linear_regressor_with_given_parameters", "(", "coefficients", "=", "np", ".", "array", "(", "[", "2", "]", ")", ")", ",", "\n", "EmpiricalDistribution", "(", ")", ",", "\n", "InvertibleLogarithmicFunction", "(", ")", ")", "\n", "\n", "assert", "sem_ground_truth", ".", "estimate_noise", "(", "Y", ",", "X", ")", ".", "reshape", "(", "-", "1", ")", "==", "approx", "(", "N", ")", "\n", "assert", "sem_ground_truth", ".", "evaluate", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "np", ".", "array", "(", "[", "0", "]", ")", ")", ".", "squeeze", "(", ")", "==", "np", ".", "log", "(", "4", ")", "\n", "assert", "sem_ground_truth", ".", "evaluate", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", ".", "squeeze", "(", ")", "==", "np", ".", "log", "(", "4", "+", "1", ")", "\n", "\n", "sem_fitted", "=", "PostNonlinearModel", "(", "create_linear_regressor", "(", ")", ",", "\n", "EmpiricalDistribution", "(", ")", ",", "\n", "InvertibleLogarithmicFunction", "(", ")", ")", "\n", "sem_fitted", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n", "assert", "sem_fitted", ".", "prediction_model", ".", "sklearn_model", ".", "coef_", "==", "approx", "(", "np", ".", "array", "(", "[", "2", "]", ")", ",", "abs", "=", "0.05", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model": [[13, 30], ["numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.InvertibleStructuralCausalModel", "dowhy.gcm.InvertibleStructuralCausalModel.set_causal_mechanism", "dowhy.gcm.InvertibleStructuralCausalModel.set_causal_mechanism", "dowhy.gcm.InvertibleStructuralCausalModel.set_causal_mechanism", "dowhy.gcm.InvertibleStructuralCausalModel.set_causal_mechanism", "dowhy.gcm.fit", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["def", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "10000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "10000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "10000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "10000", ")", "\n", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "causal_model", "=", "InvertibleStructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X3'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "fit", "(", "causal_model", ",", "original_observations", ")", "\n", "\n", "return", "causal_model", ",", "original_observations", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_interventional_samples_atomic": [[32, 44], ["flaky.flaky", "test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pandas.DataFrame", "dowhy.gcm.interventional_samples().to_numpy", "sample.squeeze.squeeze", "pytest.approx", "dowhy.gcm.interventional_samples", "dict", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_interventional_samples_atomic", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "observed_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "[", "0", "]", ",", "'X1'", ":", "[", "1", "]", ",", "'X2'", ":", "[", "2", "]", ",", "'X3'", ":", "[", "3", "]", "}", ")", "\n", "\n", "sample", "=", "interventional_samples", "(", "causal_model", ",", "dict", "(", "X2", "=", "lambda", "x", ":", "np", ".", "array", "(", "10", ")", ")", ",", "observed_data", ")", ".", "to_numpy", "(", ")", "\n", "sample", "=", "sample", ".", "squeeze", "(", ")", "\n", "assert", "sample", "[", "0", "]", "==", "0", "\n", "assert", "sample", "[", "1", "]", "==", "1", "\n", "assert", "sample", "[", "2", "]", "==", "10", "\n", "assert", "sample", "[", "3", "]", "==", "approx", "(", "5", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_interventional_samples_conditional": [[46, 58], ["flaky.flaky", "test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pandas.DataFrame", "dowhy.gcm.interventional_samples().to_numpy", "sample.squeeze.squeeze", "pytest.approx", "pytest.approx", "dowhy.gcm.interventional_samples", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_interventional_samples_conditional", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "observed_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "[", "0", "]", ",", "'X1'", ":", "[", "1", "]", ",", "'X2'", ":", "[", "2", "]", ",", "'X3'", ":", "[", "3", "]", "}", ")", "\n", "\n", "sample", "=", "interventional_samples", "(", "causal_model", ",", "dict", "(", "X2", "=", "lambda", "x", ":", "x", "+", "10", ")", ",", "observed_data", ")", ".", "to_numpy", "(", ")", "\n", "sample", "=", "sample", ".", "squeeze", "(", ")", "\n", "assert", "sample", "[", "0", "]", "==", "0", "\n", "assert", "sample", "[", "1", "]", "==", "1", "\n", "assert", "sample", "[", "2", "]", "==", "approx", "(", "10", ",", "abs", "=", "0.2", ")", "\n", "assert", "sample", "[", "3", "]", "==", "approx", "(", "5", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_interventional_samples_atomic_draw": [[60, 66], ["flaky.flaky", "test_whatif.__create_and_fit_simple_probabilistic_causal_model", "dowhy.gcm.interventional_samples", "dict", "samples[].to_numpy", "pytest.approx", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_interventional_samples_atomic_draw", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "samples", "=", "interventional_samples", "(", "causal_model", ",", "dict", "(", "X2", "=", "lambda", "x", ":", "np", ".", "array", "(", "10", ")", ")", ",", "num_samples_to_draw", "=", "10", ")", "\n", "assert", "samples", "[", "'X2'", "]", ".", "to_numpy", "(", ")", "==", "approx", "(", "10", ",", "abs", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_interventional_samples_conditional_draw": [[68, 74], ["flaky.flaky", "test_whatif.__create_and_fit_simple_probabilistic_causal_model", "dowhy.gcm.interventional_samples", "dict", "samples[].to_numpy", "pytest.approx", "numpy.mean", "training_data[].to_numpy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_interventional_samples_conditional_draw", "(", ")", ":", "\n", "    ", "causal_model", ",", "training_data", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "samples", "=", "interventional_samples", "(", "causal_model", ",", "dict", "(", "X2", "=", "lambda", "x", ":", "x", "+", "10", ")", ",", "num_samples_to_draw", "=", "10", ")", "\n", "assert", "samples", "[", "'X2'", "]", ".", "to_numpy", "(", ")", "==", "approx", "(", "np", ".", "mean", "(", "training_data", "[", "'X2'", "]", ".", "to_numpy", "(", ")", ")", "+", "10", ",", "abs", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_interventional_samples_with_categorical_variables_draw": [[76, 117], ["flaky.flaky", "dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "numpy.random.normal", "numpy.random.choice().astype", "zip", "numpy.array().astype", "numpy.array().astype", "pandas.DataFrame", "dowhy.gcm.fit", "dowhy.gcm.interventional_samples", "networkx.DiGraph", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ClassifierFCM", "dowhy.gcm.ClassifierFCM", "dict", "intervention_results[].to_numpy", "pytest.approx", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.random.choice", "np.array().astype.append", "np.array().astype.append", "numpy.array", "np.array().astype.append", "np.array().astype.append", "numpy.array", "numpy.array", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_logistic_regression_classifier", "intervention_results[].to_numpy", "intervention_results[].to_numpy", "intervention_results[].to_numpy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_interventional_samples_with_categorical_variables_draw", "(", ")", ":", "\n", "    ", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "ClassifierFCM", "(", "classifier_model", "=", "create_logistic_regression_classifier", "(", ")", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X3'", ",", "ClassifierFCM", "(", "classifier_model", "=", "create_logistic_regression_classifier", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "choice", "(", "2", ",", "1000", ")", ".", "astype", "(", "str", ")", "\n", "\n", "X2", "=", "[", "]", "\n", "for", "(", "x0", ",", "x1", ")", "in", "zip", "(", "X0", ",", "X1", ")", ":", "\n", "        ", "if", "x1", "==", "'0'", ":", "\n", "            ", "X2", ".", "append", "(", "x0", "+", "2", ">", "0", ")", "\n", "", "else", ":", "\n", "            ", "X2", ".", "append", "(", "x0", "-", "2", ">", "0", ")", "\n", "\n", "", "", "X2", "=", "np", ".", "array", "(", "X2", ")", ".", "astype", "(", "str", ")", "\n", "\n", "X3", "=", "[", "]", "\n", "for", "x2", "in", "X2", ":", "\n", "        ", "if", "x2", "==", "'True'", ":", "\n", "            ", "X3", ".", "append", "(", "'False'", ")", "\n", "", "else", ":", "\n", "            ", "X3", ".", "append", "(", "'True'", ")", "\n", "\n", "", "", "X3", "=", "np", ".", "array", "(", "X3", ")", ".", "astype", "(", "str", ")", "\n", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "intervention_results", "=", "interventional_samples", "(", "causal_model", ",", "\n", "dict", "(", "X0", "=", "lambda", "x", ":", "0", ",", "X1", "=", "lambda", "x", ":", "'0'", ")", ",", "\n", "num_samples_to_draw", "=", "100", ")", "\n", "\n", "assert", "intervention_results", "[", "'X0'", "]", ".", "to_numpy", "(", ")", "==", "approx", "(", "np", ".", "array", "(", "[", "0", "]", "*", "100", ")", ")", "\n", "assert", "np", ".", "sum", "(", "intervention_results", "[", "'X1'", "]", ".", "to_numpy", "(", ")", "==", "'0'", ")", ">", "95", "\n", "assert", "np", ".", "sum", "(", "intervention_results", "[", "'X2'", "]", ".", "to_numpy", "(", ")", "==", "'True'", ")", ">", "95", "\n", "assert", "np", ".", "sum", "(", "intervention_results", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "==", "'False'", ")", ">", "95", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_interventional_samples_atomic_multiple_interventions": [[119, 132], ["flaky.flaky", "test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pandas.DataFrame", "dowhy.gcm.interventional_samples().to_numpy", "sample.squeeze.squeeze", "pytest.approx", "pytest.approx", "pytest.approx", "dowhy.gcm.interventional_samples", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_interventional_samples_atomic_multiple_interventions", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "observed_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "[", "0", "]", ",", "'X1'", ":", "[", "1", "]", ",", "'X2'", ":", "[", "2", "]", ",", "'X3'", ":", "[", "3", "]", "}", ")", "\n", "\n", "sample", "=", "interventional_samples", "(", "causal_model", ",", "dict", "(", "X0", "=", "lambda", "x", ":", "10", ",", "\n", "X2", "=", "lambda", "x", ":", "x", "+", "5", ")", ",", "observed_data", ")", ".", "to_numpy", "(", ")", "\n", "sample", "=", "sample", ".", "squeeze", "(", ")", "\n", "assert", "sample", "[", "0", "]", "==", "10", "\n", "assert", "sample", "[", "1", "]", "==", "approx", "(", "20", ",", "abs", "=", "0.3", ")", "\n", "assert", "sample", "[", "2", "]", "==", "approx", "(", "10", ",", "abs", "=", "0.3", ")", "\n", "assert", "sample", "[", "3", "]", "==", "approx", "(", "5", ",", "abs", "=", "0.3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_interventional_samples_raise_error_all_parameter_none": [[134, 139], ["test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pytest.raises", "dowhy.gcm.interventional_samples", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples"], ["", "def", "test_interventional_samples_raise_error_all_parameter_none", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "interventional_samples", "(", "causal_model", ",", "dict", "(", "X0", "=", "lambda", "x", ":", "10", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_interventional_samples_raise_error_both_parameter_given": [[141, 148], ["test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pandas.DataFrame", "pytest.raises", "dowhy.gcm.interventional_samples", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.interventional_samples"], ["", "", "def", "test_interventional_samples_raise_error_both_parameter_given", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "observed_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "[", "0", "]", ",", "'X1'", ":", "[", "1", "]", ",", "'X2'", ":", "[", "2", "]", ",", "'X3'", ":", "[", "3", "]", "}", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "interventional_samples", "(", "causal_model", ",", "dict", "(", "X0", "=", "lambda", "x", ":", "10", ")", ",", "observed_data", "=", "observed_data", ",", "num_samples_to_draw", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_counterfactual_samples_with_observed_samples": [[150, 163], ["test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pandas.DataFrame", "dowhy.gcm.counterfactual_samples", "dict", "sample[].to_numpy().squeeze", "sample[].to_numpy().squeeze", "sample[].to_numpy().squeeze", "sample[].to_numpy().squeeze", "pytest.approx", "sample[].to_numpy", "sample[].to_numpy", "sample[].to_numpy", "sample[].to_numpy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.counterfactual_samples"], ["", "", "def", "test_counterfactual_samples_with_observed_samples", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "observed_samples", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "[", "1", "]", ",", "\n", "'X1'", ":", "[", "3", "]", ",", "\n", "'X2'", ":", "[", "3", "]", ",", "\n", "'X3'", ":", "[", "4", "]", "}", ")", "\n", "\n", "sample", "=", "counterfactual_samples", "(", "causal_model", ",", "dict", "(", "X2", "=", "lambda", "x", ":", "2", ")", ",", "observed_data", "=", "observed_samples", ")", "\n", "assert", "sample", "[", "'X0'", "]", ".", "to_numpy", "(", ")", ".", "squeeze", "(", ")", "==", "1", "\n", "assert", "sample", "[", "'X1'", "]", ".", "to_numpy", "(", ")", ".", "squeeze", "(", ")", "==", "3", "\n", "assert", "sample", "[", "'X2'", "]", ".", "to_numpy", "(", ")", ".", "squeeze", "(", ")", "==", "2", "\n", "assert", "sample", "[", "'X3'", "]", ".", "to_numpy", "(", ")", ".", "squeeze", "(", ")", "==", "approx", "(", "3.5", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_counterfactual_samples_with_noise_samples": [[165, 178], ["test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pandas.DataFrame", "dowhy.gcm.counterfactual_samples", "dict", "sample[].to_numpy().squeeze", "sample[].to_numpy().squeeze", "pytest.approx", "sample[].to_numpy().squeeze", "sample[].to_numpy().squeeze", "pytest.approx", "sample[].to_numpy", "sample[].to_numpy", "sample[].to_numpy", "sample[].to_numpy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.counterfactual_samples"], ["", "def", "test_counterfactual_samples_with_noise_samples", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "noise_samples", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "[", "1", "]", ",", "\n", "'X1'", ":", "[", "2", "]", ",", "\n", "'X2'", ":", "[", "3", "]", ",", "\n", "'X3'", ":", "[", "4", "]", "}", ")", "\n", "\n", "sample", "=", "counterfactual_samples", "(", "causal_model", ",", "dict", "(", "X2", "=", "lambda", "x", ":", "2", ")", ",", "noise_data", "=", "noise_samples", ")", "\n", "assert", "sample", "[", "'X0'", "]", ".", "to_numpy", "(", ")", ".", "squeeze", "(", ")", "==", "1", "\n", "assert", "sample", "[", "'X1'", "]", ".", "to_numpy", "(", ")", ".", "squeeze", "(", ")", "==", "approx", "(", "4", ",", "abs", "=", "0.05", ")", "\n", "assert", "sample", "[", "'X2'", "]", ".", "to_numpy", "(", ")", ".", "squeeze", "(", ")", "==", "2", "\n", "assert", "sample", "[", "'X3'", "]", ".", "to_numpy", "(", ")", ".", "squeeze", "(", ")", "==", "approx", "(", "5", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_counterfactual_samples_raises_error_all_parameter_none": [[180, 185], ["test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pytest.raises", "dowhy.gcm.counterfactual_samples", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.counterfactual_samples"], ["", "def", "test_counterfactual_samples_raises_error_all_parameter_none", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "counterfactual_samples", "(", "causal_model", ",", "dict", "(", "X0", "=", "lambda", "x", ":", "10", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.test_counterfactual_samples_raises_error_both_parameter_given": [[187, 195], ["test_whatif.__create_and_fit_simple_probabilistic_causal_model", "pytest.raises", "dowhy.gcm.counterfactual_samples", "dict", "pandas.DataFrame", "pandas.DataFrame"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_whatif.__create_and_fit_simple_probabilistic_causal_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.whatif.counterfactual_samples"], ["", "", "def", "test_counterfactual_samples_raises_error_both_parameter_given", "(", ")", ":", "\n", "    ", "causal_model", ",", "_", "=", "__create_and_fit_simple_probabilistic_causal_model", "(", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "counterfactual_samples", "(", "causal_model", ",", "\n", "dict", "(", "X0", "=", "lambda", "x", ":", "10", ")", ",", "\n", "observed_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "[", "1", "]", ",", "'X1'", ":", "[", "3", "]", ",", "'X2'", ":", "[", "3", "]", ",", "'X3'", ":", "[", "4", "]", "}", ")", ",", "\n", "noise_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "[", "1", "]", ",", "'X1'", ":", "[", "4", "]", ",", "'X2'", ":", "[", "3", "]", ",", "'X3'", ":", "[", "4", "]", "}", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_density_estimators.test_gaussian_mixture_density_estimator": [[7, 18], ["numpy.array", "dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator", "dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator.fit", "dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator.density", "pytest.raises", "dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator.density", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimator.DensityEstimator.density", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimator.DensityEstimator.density"], ["def", "test_gaussian_mixture_density_estimator", "(", ")", ":", "\n", "    ", "test_data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "2", "]", ",", "[", "1", ",", "0", "]", ",", "[", "2", ",", "3", "]", "]", ")", "\n", "\n", "density_estimator_model", "=", "GaussianMixtureDensityEstimator", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "density_estimator_model", ".", "density", "(", "test_data", ")", "\n", "\n", "", "density_estimator_model", ".", "fit", "(", "test_data", ")", "\n", "results", "=", "density_estimator_model", ".", "density", "(", "test_data", ")", "\n", "\n", "assert", "len", "(", "results", ")", "==", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_density_estimators.test_kernel_based_density_estimator_1d": [[20, 35], ["numpy.array", "dowhy.gcm.density_estimators.KernelDensityEstimator1D", "numpy.array", "dowhy.gcm.density_estimators.KernelDensityEstimator1D.fit", "dowhy.gcm.density_estimators.KernelDensityEstimator1D.density", "pytest.raises", "dowhy.gcm.density_estimators.KernelDensityEstimator1D.density", "pytest.raises", "dowhy.gcm.density_estimators.KernelDensityEstimator1D.fit", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimator.DensityEstimator.density", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.density_estimator.DensityEstimator.density", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "test_kernel_based_density_estimator_1d", "(", ")", ":", "\n", "    ", "test_data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "2", "]", ",", "[", "1", ",", "0", "]", ",", "[", "2", ",", "3", "]", "]", ")", "\n", "\n", "density_estimator_model", "=", "KernelDensityEstimator1D", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "density_estimator_model", ".", "density", "(", "test_data", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "density_estimator_model", ".", "fit", "(", "test_data", ")", "\n", "\n", "", "test_data", "=", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "2", "]", ",", "[", "1", "]", ",", "[", "3", "]", "]", ")", "\n", "density_estimator_model", ".", "fit", "(", "test_data", ")", "\n", "results", "=", "density_estimator_model", ".", "density", "(", "test_data", ")", "\n", "\n", "assert", "len", "(", "results", ")", "==", "4", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_confidence_intervals.test_given_simple_counter_as_estimation_func_when_confidence_interval_then_returns_mean_and_interval_counter": [[7, 19], ["dowhy.gcm.confidence_intervals", "numpy.allclose", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals.confidence_intervals"], ["def", "test_given_simple_counter_as_estimation_func_when_confidence_interval_then_returns_mean_and_interval_counter", "(", ")", ":", "\n", "    ", "i", "=", "0.0", "\n", "\n", "def", "simple_counter", "(", ")", ":", "\n", "        ", "nonlocal", "i", "\n", "i", "+=", "1.0", "\n", "return", "{", "\"X\"", ":", "i", "}", "\n", "\n", "", "median", ",", "interval", "=", "confidence_intervals", "(", "simple_counter", ",", "num_bootstrap_resamples", "=", "20", ")", "\n", "\n", "assert", "median", "[", "'X'", "]", "==", "pytest", ".", "approx", "(", "10.5", ")", "\n", "assert", "np", ".", "allclose", "(", "interval", "[", "'X'", "]", ",", "[", "1.95", ",", "19.05", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stochastic_models.test_bayesian_gaussian_mixture_distribution": [[10, 16], ["numpy.array", "dowhy.gcm.BayesianGaussianMixtureDistribution", "dowhy.gcm.BayesianGaussianMixtureDistribution.fit", "dowhy.gcm.BayesianGaussianMixtureDistribution.draw_samples"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["def", "test_bayesian_gaussian_mixture_distribution", "(", ")", ":", "\n", "    ", "test_data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "1", ",", "2", "]", ",", "[", "1", ",", "2", "]", "]", ")", "\n", "\n", "approximated_data_distribution_model", "=", "BayesianGaussianMixtureDistribution", "(", ")", "\n", "approximated_data_distribution_model", ".", "fit", "(", "test_data", ")", "\n", "assert", "approximated_data_distribution_model", ".", "draw_samples", "(", "5", ")", ".", "shape", "==", "(", "5", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stochastic_models.test_bayesian_gaussian_mixture_distribution_runtime_error": [[18, 22], ["dowhy.gcm.BayesianGaussianMixtureDistribution", "pytest.raises", "dowhy.gcm.BayesianGaussianMixtureDistribution.draw_samples"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["", "def", "test_bayesian_gaussian_mixture_distribution_runtime_error", "(", ")", ":", "\n", "    ", "approximated_data_distribution_model", "=", "BayesianGaussianMixtureDistribution", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "approximated_data_distribution_model", ".", "draw_samples", "(", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stochastic_models.test_scipy_fixed_parametric_distribution": [[24, 29], ["dowhy.gcm.ScipyDistribution"], "function", ["None"], ["", "", "def", "test_scipy_fixed_parametric_distribution", "(", ")", ":", "\n", "    ", "distribution", "=", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", "\n", "\n", "assert", "distribution", ".", "parameters", "[", "'loc'", "]", "==", "0", "\n", "assert", "distribution", ".", "parameters", "[", "'scale'", "]", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stochastic_models.test_scipy_fittable_parametric_distribution": [[31, 40], ["flaky.flaky", "dowhy.gcm.ScipyDistribution", "numpy.random.normal", "dowhy.gcm.ScipyDistribution.fit", "pytest.approx", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_scipy_fittable_parametric_distribution", "(", ")", ":", "\n", "    ", "distribution", "=", "ScipyDistribution", "(", "stats", ".", "norm", ")", "\n", "\n", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "distribution", ".", "fit", "(", "X", ")", "\n", "\n", "assert", "distribution", ".", "parameters", "[", "'loc'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "distribution", ".", "parameters", "[", "'scale'", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stochastic_models.test_scipy_auto_select_continuous_parametric_distribution": [[42, 51], ["flaky.flaky", "dowhy.gcm.ScipyDistribution", "numpy.random.normal", "dowhy.gcm.ScipyDistribution.fit", "numpy.mean", "pytest.approx", "numpy.std", "pytest.approx", "dowhy.gcm.ScipyDistribution.draw_samples", "dowhy.gcm.ScipyDistribution.draw_samples"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_scipy_auto_select_continuous_parametric_distribution", "(", ")", ":", "\n", "    ", "distribution", "=", "ScipyDistribution", "(", ")", "\n", "\n", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "distribution", ".", "fit", "(", "X", ")", "\n", "\n", "assert", "np", ".", "mean", "(", "distribution", ".", "draw_samples", "(", "1000", ")", ")", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "np", ".", "std", "(", "distribution", ".", "draw_samples", "(", "1000", ")", ")", "==", "approx", "(", "1", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stochastic_models.test_empirical_distribution": [[53, 63], ["numpy.random.normal", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.EmpiricalDistribution.fit", "list", "dowhy.gcm.EmpiricalDistribution.draw_samples"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["", "def", "test_empirical_distribution", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "\n", "distribution", "=", "EmpiricalDistribution", "(", ")", "\n", "distribution", ".", "fit", "(", "X", ")", "\n", "\n", "X", "=", "list", "(", "X", ")", "\n", "\n", "for", "val", "in", "distribution", ".", "draw_samples", "(", "1000", ")", ":", "\n", "        ", "assert", "val", "in", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stochastic_models.test_fitted_parameters_assigned_correctly_using_normal_distribution": [[65, 72], ["flaky.flaky", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution.fit", "dowhy.gcm.ScipyDistribution().draw_samples", "pytest.approx", "pytest.approx", "dowhy.gcm.ScipyDistribution"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["", "", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_fitted_parameters_assigned_correctly_using_normal_distribution", "(", ")", ":", "\n", "    ", "distribution", "=", "ScipyDistribution", "(", "stats", ".", "norm", ")", "\n", "distribution", ".", "fit", "(", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "3", ",", "scale", "=", "2", ")", ".", "draw_samples", "(", "10000", ")", ")", "\n", "\n", "assert", "distribution", ".", "parameters", "[", "'loc'", "]", "==", "approx", "(", "3", ",", "abs", "=", "0.3", ")", "\n", "assert", "distribution", ".", "parameters", "[", "'scale'", "]", "==", "approx", "(", "2", ",", "abs", "=", "0.3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stochastic_models.test_fitted_parameters_assigned_correctly_using_beta_distribution": [[74, 83], ["flaky.flaky", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution.fit", "dowhy.gcm.ScipyDistribution().draw_samples", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "dowhy.gcm.ScipyDistribution"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_fitted_parameters_assigned_correctly_using_beta_distribution", "(", ")", ":", "\n", "    ", "distribution", "=", "ScipyDistribution", "(", "stats", ".", "beta", ")", "\n", "distribution", ".", "fit", "(", "ScipyDistribution", "(", "stats", ".", "beta", ",", "a", "=", "2", ",", "b", "=", "0.5", ")", ".", "draw_samples", "(", "10000", ")", ")", "\n", "\n", "assert", "distribution", ".", "parameters", "[", "'loc'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "distribution", ".", "parameters", "[", "'scale'", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.1", ")", "\n", "assert", "distribution", ".", "parameters", "[", "'a'", "]", "==", "approx", "(", "2", ",", "abs", "=", "0.5", ")", "\n", "assert", "distribution", ".", "parameters", "[", "'b'", "]", "==", "approx", "(", "0.5", ",", "abs", "=", "0.5", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_outlier_observation_when_estimate_anomaly_scores_using_median_cdf_quantile_scorer_then_returns_expected_result": [[19, 32], ["test_anomaly._create_pcm_and_outlier_observation", "max", "max", "dowhy.gcm.anomaly_scores().items", "dowhy.gcm.anomaly_scores().items", "operator.itemgetter", "operator.itemgetter", "dowhy.gcm.anomaly_scores", "dowhy.gcm.anomaly_scores", "dowhy.gcm.ITAnomalyScorer", "dowhy.gcm.MedianCDFQuantileScorer"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_pcm_and_outlier_observation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores"], ["def", "test_given_outlier_observation_when_estimate_anomaly_scores_using_median_cdf_quantile_scorer_then_returns_expected_result", "(", ")", ":", "\n", "    ", "pcm", ",", "outlier_observation", "=", "_create_pcm_and_outlier_observation", "(", ")", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "MedianCDFQuantileScorer", ")", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "\n", "lambda", ":", "ITAnomalyScorer", "(", "MedianCDFQuantileScorer", "(", ")", ")", ")", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_outlier_observation_when_estimate_anomaly_scores_using_rescaled_median_cdf_quantile_scorer_then_returns_expected_result": [[34, 47], ["test_anomaly._create_pcm_and_outlier_observation", "max", "max", "dowhy.gcm.anomaly_scores().items", "dowhy.gcm.anomaly_scores().items", "operator.itemgetter", "operator.itemgetter", "dowhy.gcm.anomaly_scores", "dowhy.gcm.anomaly_scores", "dowhy.gcm.ITAnomalyScorer", "dowhy.gcm.RescaledMedianCDFQuantileScorer"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_pcm_and_outlier_observation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores"], ["", "def", "test_given_outlier_observation_when_estimate_anomaly_scores_using_rescaled_median_cdf_quantile_scorer_then_returns_expected_result", "(", ")", ":", "\n", "    ", "pcm", ",", "outlier_observation", "=", "_create_pcm_and_outlier_observation", "(", ")", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "RescaledMedianCDFQuantileScorer", ")", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "\n", "lambda", ":", "ITAnomalyScorer", "(", "RescaledMedianCDFQuantileScorer", "(", ")", ")", ")", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_outlier_observation_when_estimate_anomaly_scores_using_mean_deviation_scorer_then_returns_expected_result": [[49, 62], ["test_anomaly._create_pcm_and_outlier_observation", "max", "max", "dowhy.gcm.anomaly_scores().items", "dowhy.gcm.anomaly_scores().items", "operator.itemgetter", "operator.itemgetter", "dowhy.gcm.anomaly_scores", "dowhy.gcm.anomaly_scores", "dowhy.gcm.MeanDeviationScorer", "dowhy.gcm.ITAnomalyScorer", "dowhy.gcm.MeanDeviationScorer"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_pcm_and_outlier_observation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores"], ["", "def", "test_given_outlier_observation_when_estimate_anomaly_scores_using_mean_deviation_scorer_then_returns_expected_result", "(", ")", ":", "\n", "    ", "pcm", ",", "outlier_observation", "=", "_create_pcm_and_outlier_observation", "(", ")", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "lambda", ":", "MeanDeviationScorer", "(", ")", ")", "\n", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "lambda", ":", "ITAnomalyScorer", "(", "MeanDeviationScorer", "(", ")", ")", ")", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_outlier_observation_when_estimate_anomaly_scores_using_median_deviation_scorer_then_returns_expected_result": [[64, 77], ["test_anomaly._create_pcm_and_outlier_observation", "max", "max", "dowhy.gcm.anomaly_scores().items", "dowhy.gcm.anomaly_scores().items", "operator.itemgetter", "operator.itemgetter", "dowhy.gcm.anomaly_scores", "dowhy.gcm.anomaly_scores", "dowhy.gcm.MedianDeviationScorer", "dowhy.gcm.ITAnomalyScorer", "dowhy.gcm.MedianDeviationScorer"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_pcm_and_outlier_observation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores"], ["", "def", "test_given_outlier_observation_when_estimate_anomaly_scores_using_median_deviation_scorer_then_returns_expected_result", "(", ")", ":", "\n", "    ", "pcm", ",", "outlier_observation", "=", "_create_pcm_and_outlier_observation", "(", ")", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "lambda", ":", "MedianDeviationScorer", "(", ")", ")", "\n", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "lambda", ":", "ITAnomalyScorer", "(", "MedianDeviationScorer", "(", ")", ")", ")", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_outlier_observation_when_estimate_anomaly_scores_using_inverse_density_scorer_then_returns_expected_result": [[79, 86], ["test_anomaly._create_pcm_and_outlier_observation", "max", "dowhy.gcm.anomaly_scores().items", "operator.itemgetter", "dowhy.gcm.anomaly_scores", "dowhy.gcm.InverseDensityScorer"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_pcm_and_outlier_observation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores"], ["", "def", "test_given_outlier_observation_when_estimate_anomaly_scores_using_inverse_density_scorer_then_returns_expected_result", "(", ")", ":", "\n", "    ", "pcm", ",", "outlier_observation", "=", "_create_pcm_and_outlier_observation", "(", ")", "\n", "\n", "assert", "max", "(", "anomaly_scores", "(", "pcm", ",", "\n", "outlier_observation", ",", "\n", "anomaly_scorer_factory", "=", "lambda", ":", "InverseDensityScorer", "(", ")", ")", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X1'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_data_with_change_in_mechanism_when_estimate_distribution_change_score_then_returns_expected_result": [[88, 104], ["test_anomaly._create_scm_for_distribution_change", "numpy.random.uniform", "pandas.DataFrame", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "max", "dowhy.gcm.distribution_change.estimate_distribution_change_scores().items", "operator.itemgetter", "dowhy.gcm.distribution_change.estimate_distribution_change_scores"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_scm_for_distribution_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.estimate_distribution_change_scores"], ["", "def", "test_given_data_with_change_in_mechanism_when_estimate_distribution_change_score_then_returns_expected_result", "(", ")", ":", "\n", "    ", "causal_model", ",", "original_observations", "=", "_create_scm_for_distribution_change", "(", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "# Here, changing the mechanism.", "\n", "X2", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X2", ",", "\n", "'X3'", ":", "X3", "}", ")", "\n", "\n", "assert", "max", "(", "estimate_distribution_change_scores", "(", "causal_model", ",", "original_observations", ",", "outlier_observations", ")", ".", "items", "(", ")", ",", "\n", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X2'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_data_with_change_in_mechanism_when_estimate_distribution_change_score_using_difference_in_means_then_returns_expected_result": [[106, 131], ["test_anomaly._create_scm_for_distribution_change", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.distribution_change.estimate_distribution_change_scores", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "max", "abs", "dowhy.gcm.distribution_change.estimate_distribution_change_scores.items", "operator.itemgetter", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_scm_for_distribution_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.estimate_distribution_change_scores"], ["", "def", "test_given_data_with_change_in_mechanism_when_estimate_distribution_change_score_using_difference_in_means_then_returns_expected_result", "(", ")", ":", "\n", "    ", "causal_model", ",", "original_observations", "=", "_create_scm_for_distribution_change", "(", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "# Here, changing the mechanism.", "\n", "X2", "=", "2", "+", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X2", ",", "\n", "'X3'", ":", "X3", "}", ")", "\n", "\n", "scores", "=", "estimate_distribution_change_scores", "(", "\n", "causal_model", ",", "\n", "original_observations", ",", "\n", "outlier_observations", ",", "\n", "difference_estimation_func", "=", "lambda", "x", ",", "y", ":", "abs", "(", "np", ".", "mean", "(", "x", ")", "-", "np", ".", "mean", "(", "y", ")", ")", ")", "\n", "\n", "assert", "scores", "[", "'X0'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "scores", "[", "'X1'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "scores", "[", "'X2'", "]", "==", "approx", "(", "2", ",", "abs", "=", "0.1", ")", "\n", "assert", "scores", "[", "'X3'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "\n", "assert", "max", "(", "scores", ".", "items", "(", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X2'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_data_with_change_in_root_node_when_estimate_distribution_change_score_using_difference_in_means_then_returns_expected_result": [[133, 158], ["test_anomaly._create_scm_for_distribution_change", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.distribution_change.estimate_distribution_change_scores", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "max", "abs", "dowhy.gcm.distribution_change.estimate_distribution_change_scores.items", "operator.itemgetter", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_scm_for_distribution_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.estimate_distribution_change_scores"], ["", "def", "test_given_data_with_change_in_root_node_when_estimate_distribution_change_score_using_difference_in_means_then_returns_expected_result", "(", ")", ":", "\n", "    ", "causal_model", ",", "original_observations", "=", "_create_scm_for_distribution_change", "(", ")", "\n", "\n", "# Here, changing the mechanism.", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1.5", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X2", ",", "\n", "'X3'", ":", "X3", "}", ")", "\n", "\n", "scores", "=", "estimate_distribution_change_scores", "(", "\n", "causal_model", ",", "\n", "original_observations", ",", "\n", "outlier_observations", ",", "\n", "difference_estimation_func", "=", "lambda", "x", ",", "y", ":", "abs", "(", "np", ".", "mean", "(", "x", ")", "-", "np", ".", "mean", "(", "y", ")", ")", ")", "\n", "\n", "assert", "scores", "[", "'X0'", "]", "==", "approx", "(", "0.25", ",", "abs", "=", "0.1", ")", "\n", "assert", "scores", "[", "'X1'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "scores", "[", "'X2'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "scores", "[", "'X3'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "\n", "assert", "max", "(", "scores", ".", "items", "(", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X0'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_graph_with_multiple_parents_when_estimate_distribution_change_scores_then_returns_expected_result": [[160, 187], ["flaky.flaky", "numpy.random.uniform", "numpy.random.uniform", "pandas.DataFrame", "numpy.random.uniform", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "dowhy.gcm.distribution_change.estimate_distribution_change_scores", "networkx.DiGraph", "pytest.approx", "abs", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.estimate_distribution_change_scores"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_graph_with_multiple_parents_when_estimate_distribution_change_scores_then_returns_expected_result", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X2", "=", "X0", "+", "X1", "\n", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", "}", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X2", "=", "X0", "+", "X1", "+", "1", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", "}", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X1'", ",", "'X2'", ")", "]", ")", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "original_observations", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "original_observations", ")", "\n", "\n", "scores", "=", "estimate_distribution_change_scores", "(", "\n", "causal_model", ",", "\n", "original_observations", ",", "\n", "outlier_observations", ",", "\n", "difference_estimation_func", "=", "lambda", "x", ",", "y", ":", "abs", "(", "np", ".", "mean", "(", "x", ")", "-", "np", ".", "mean", "(", "y", ")", ")", ")", "\n", "\n", "assert", "scores", "[", "'X0'", "]", "==", "0", "\n", "assert", "scores", "[", "'X1'", "]", "==", "0", "\n", "assert", "scores", "[", "'X2'", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.005", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_data_with_change_in_mechanism_when_estimate_distribution_change_score_using_difference_in_variance_then_returns_expected_result": [[189, 215], ["flaky.flaky", "test_anomaly._create_scm_for_distribution_change", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.distribution_change.estimate_distribution_change_scores", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "max", "abs", "dowhy.gcm.distribution_change.estimate_distribution_change_scores.items", "operator.itemgetter", "numpy.var", "numpy.var"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_scm_for_distribution_change", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.distribution_change.estimate_distribution_change_scores"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_data_with_change_in_mechanism_when_estimate_distribution_change_score_using_difference_in_variance_then_returns_expected_result", "(", ")", ":", "\n", "    ", "causal_model", ",", "original_observations", "=", "_create_scm_for_distribution_change", "(", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "# Here, changing the mechanism.", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "2", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "outlier_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X2", ",", "\n", "'X3'", ":", "X3", "}", ")", "\n", "\n", "scores", "=", "estimate_distribution_change_scores", "(", "\n", "causal_model", ",", "\n", "original_observations", ",", "\n", "outlier_observations", ",", "\n", "difference_estimation_func", "=", "lambda", "x", ",", "y", ":", "abs", "(", "np", ".", "var", "(", "x", ")", "-", "np", ".", "var", "(", "y", ")", ")", ")", "\n", "\n", "assert", "scores", "[", "'X0'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "scores", "[", "'X1'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "assert", "scores", "[", "'X2'", "]", "==", "approx", "(", "4", ",", "abs", "=", "0.5", ")", "\n", "assert", "scores", "[", "'X3'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "\n", "\n", "assert", "max", "(", "scores", ".", "items", "(", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "==", "'X2'", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_multivariate_inputs_when_estimate_anomaly_scores_then_does_not_raise_error": [[217, 242], ["flaky.flaky", "dowhy.gcm.ProbabilisticCausalModel", "numpy.random.normal", "pandas.DataFrame", "pandas.DataFrame", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "dowhy.gcm.anomaly_scores", "networkx.DiGraph", "pytest.approx", "data[].reshape", "data[].reshape", "data[].reshape", "data[].reshape", "numpy.log"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.anomaly_scores"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_multivariate_inputs_when_estimate_anomaly_scores_then_does_not_raise_error", "(", ")", ":", "\n", "    ", "\"\"\"This test verifies that estimate_anomaly_scores correctly handles multivariate input features, which\n     caused problems in an earlier version. \"\"\"", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X1'", ",", "'X0'", ")", ",", "(", "'X2'", ",", "'X0'", ")", ",", "(", "'X3'", ",", "'X0'", ")", ",", "(", "'X4'", ",", "'X0'", ")", "]", ")", ")", "\n", "\n", "data", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "10000", ",", "4", ")", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "(", "data", "[", ":", ",", "0", "]", "+", "data", "[", ":", ",", "1", "]", "+", "data", "[", ":", ",", "2", "]", "+", "data", "[", ":", ",", "3", "]", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "'X1'", ":", "data", "[", ":", ",", "0", "]", ".", "reshape", "(", "-", "1", ")", ",", "\n", "'X2'", ":", "data", "[", ":", ",", "1", "]", ".", "reshape", "(", "-", "1", ")", ",", "\n", "'X3'", ":", "data", "[", ":", ",", "2", "]", ".", "reshape", "(", "-", "1", ")", ",", "\n", "'X4'", ":", "data", "[", ":", ",", "3", "]", ".", "reshape", "(", "-", "1", ")", "}", ")", "\n", "data_anomaly", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "data", ".", "iloc", "[", "0", ":", "1", ",", "0", "]", "*", "10", "+", "data", ".", "iloc", "[", "0", ":", "1", ",", "1", "]", "+", "data", ".", "iloc", "[", "0", ":", "1", ",", "2", "]", "\n", "+", "data", ".", "iloc", "[", "0", ":", "1", ",", "3", "]", ",", "\n", "'X1'", ":", "data", ".", "iloc", "[", "0", ":", "1", ",", "0", "]", "*", "10", ",", "\n", "'X2'", ":", "data", ".", "iloc", "[", "0", ":", "1", ",", "1", "]", ",", "\n", "'X3'", ":", "data", ".", "iloc", "[", "0", ":", "1", ",", "2", "]", ",", "\n", "'X4'", ":", "data", ".", "iloc", "[", "0", ":", "1", ",", "3", "]", "}", ")", "\n", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "data", ")", "\n", "scores", "=", "anomaly_scores", "(", "causal_model", ",", "data_anomaly", ")", "\n", "assert", "scores", "[", "'X1'", "]", "[", "0", "]", "==", "approx", "(", "-", "np", ".", "log", "(", "EPS", ")", ",", "abs", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly.test_given_simple_linear_data_when_estimate_conditional_anomaly_scores_then_returns_expected_result": [[244, 259], ["flaky.flaky", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel.fit", "dowhy.gcm.MeanDeviationScorer", "dowhy.gcm.MeanDeviationScorer.fit", "dowhy.gcm.anomaly.conditional_anomaly_scores().reshape", "pytest.approx", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.MeanDeviationScorer.score", "dowhy.gcm.anomaly.conditional_anomaly_scores"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.conditional_anomaly_scores"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_simple_linear_data_when_estimate_conditional_anomaly_scores_then_returns_expected_result", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "N", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "\n", "Y", "=", "2", "*", "X", "+", "N", "\n", "\n", "causal_model", "=", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", "\n", "causal_model", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n", "anomaly_scorer", "=", "MeanDeviationScorer", "(", ")", "\n", "anomaly_scorer", ".", "fit", "(", "N", ")", "\n", "\n", "assert", "conditional_anomaly_scores", "(", "X", "[", ":", "5", "]", ",", "Y", "[", ":", "5", "]", ",", "causal_model", ",", "MeanDeviationScorer", ")", ".", "reshape", "(", "-", "1", ")", "==", "approx", "(", "anomaly_scorer", ".", "score", "(", "Y", "[", ":", "5", "]", "-", "2", "*", "X", "[", ":", "5", "]", ")", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_scm_for_distribution_change": [[261, 280], ["numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.fit", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["", "def", "_create_scm_for_distribution_change", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X2", ",", "\n", "'X3'", ":", "X3", "}", ")", "\n", "\n", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X3'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "fit", "(", "causal_model", ",", "original_observations", ")", "\n", "\n", "return", "causal_model", ",", "original_observations", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly._create_pcm_and_outlier_observation": [[282, 302], ["numpy.random.uniform", "pandas.DataFrame", "pandas.DataFrame", "dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "numpy.std"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "_create_pcm_and_outlier_observation", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X2", ",", "\n", "'X3'", ":", "X3", "}", ")", "\n", "outlier_observation", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", "[", ":", "1", "]", ",", "\n", "'X1'", ":", "X1", "[", ":", "1", "]", "+", "np", ".", "std", "(", "X1", ".", "data", ")", "*", "3", ",", "# Creating an anomaly here", "\n", "'X2'", ":", "X2", "[", ":", "1", "]", ",", "\n", "'X3'", ":", "X3", "[", ":", "1", "]", "}", ")", "\n", "\n", "pcm", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "pcm", ",", "original_observations", ")", "\n", "fit", "(", "pcm", ",", "original_observations", ")", "\n", "\n", "return", "pcm", ",", "outlier_observation", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_estimate_geometric_median": [[13, 24], ["flaky.flaky", "numpy.random.normal", "numpy.hstack", "numpy.random.normal", "numpy.hstack", "dowhy.gcm.util.general.geometric_median", "pytest.approx", "pytest.approx", "numpy.random.normal", "numpy.random.normal", "numpy.vstack"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.geometric_median"], ["@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_estimate_geometric_median", "(", ")", ":", "\n", "    ", "a", "=", "np", ".", "random", ".", "normal", "(", "10", ",", "1", ",", "100", ")", "\n", "a", "=", "np", ".", "hstack", "(", "[", "a", ",", "np", ".", "random", ".", "normal", "(", "10000", ",", "1", ",", "20", ")", "]", ")", "\n", "b", "=", "np", ".", "random", ".", "normal", "(", "-", "5", ",", "1", ",", "100", ")", "\n", "b", "=", "np", ".", "hstack", "(", "[", "b", ",", "np", ".", "random", ".", "normal", "(", "-", "10000", ",", "1", ",", "20", ")", "]", ")", "\n", "\n", "gm", "=", "geometric_median", "(", "np", ".", "vstack", "(", "[", "a", ",", "b", "]", ")", ".", "T", ")", "\n", "\n", "assert", "gm", "[", "0", "]", "==", "approx", "(", "10", ",", "abs", "=", "0.5", ")", "\n", "assert", "gm", "[", "1", "]", "==", "approx", "(", "-", "5", ",", "abs", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_quantile_based_fwer": [[26, 37], ["numpy.array", "dowhy.gcm.stats.quantile_based_fwer", "dowhy.gcm.stats.quantile_based_fwer", "dowhy.gcm.stats.quantile_based_fwer", "dowhy.gcm.stats.quantile_based_fwer", "dowhy.gcm.stats.quantile_based_fwer", "dowhy.gcm.stats.quantile_based_fwer", "dowhy.gcm.stats.quantile_based_fwer", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer"], ["", "def", "test_quantile_based_fwer", "(", ")", ":", "\n", "    ", "p_values", "=", "np", ".", "array", "(", "[", "0.01", ",", "0.02", ",", "0.03", ",", "0.04", ",", "0.05", ",", "0.06", ",", "0.07", ",", "0.08", ",", "0.09", ",", "0.1", "]", ")", "\n", "assert", "quantile_based_fwer", "(", "p_values", ",", "quantile", "=", "0.5", ")", "==", "0.055", "/", "0.5", "\n", "assert", "quantile_based_fwer", "(", "p_values", ",", "quantile", "=", "0.25", ")", "==", "0.0325", "/", "0.25", "\n", "assert", "quantile_based_fwer", "(", "p_values", ",", "quantile", "=", "0.75", ")", "==", "0.0775", "/", "0.75", "\n", "\n", "assert", "quantile_based_fwer", "(", "np", ".", "array", "(", "[", "0.01", ",", "0.02", ",", "0.03", ",", "0.04", ",", "0.05", ",", "0.06", ",", "0.07", ",", "0.08", ",", "0.09", ",", "0.1", ",", "1", "]", ")", ",", "\n", "quantile", "=", "0.5", ")", "==", "0.06", "/", "0.5", "\n", "assert", "quantile_based_fwer", "(", "np", ".", "array", "(", "[", "0.9", ",", "0.95", ",", "1", "]", ")", ",", "quantile", "=", "0.5", ")", "==", "1", "\n", "assert", "quantile_based_fwer", "(", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", ",", "quantile", "=", "0.5", ")", "==", "0", "\n", "assert", "quantile_based_fwer", "(", "np", ".", "array", "(", "[", "0.33", "]", ")", ",", "quantile", "=", "0.5", ")", "==", "0.33", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_given_p_values_with_nans_when_using_quantile_based_fwer_then_ignores_the_nan_values": [[39, 42], ["numpy.array", "dowhy.gcm.stats.quantile_based_fwer"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer"], ["", "def", "test_given_p_values_with_nans_when_using_quantile_based_fwer_then_ignores_the_nan_values", "(", ")", ":", "\n", "    ", "p_values", "=", "np", ".", "array", "(", "[", "0.01", ",", "np", ".", "nan", ",", "0.02", ",", "0.03", ",", "0.04", ",", "0.05", ",", "np", ".", "nan", ",", "0.06", ",", "0.07", ",", "0.08", ",", "0.09", ",", "0.1", "]", ")", "\n", "assert", "quantile_based_fwer", "(", "p_values", ",", "quantile", "=", "0.5", ")", "==", "0.055", "/", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_quantile_based_fwer_scaling": [[44, 51], ["numpy.array", "numpy.array", "dowhy.gcm.stats.quantile_based_fwer", "pytest.approx", "dowhy.gcm.stats.quantile_based_fwer", "pytest.approx", "dowhy.gcm.stats.quantile_based_fwer", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer"], ["", "def", "test_quantile_based_fwer_scaling", "(", ")", ":", "\n", "    ", "p_values", "=", "np", ".", "array", "(", "[", "0.01", ",", "0.02", ",", "0.03", ",", "0.04", ",", "0.05", ",", "0.06", ",", "0.07", ",", "0.08", ",", "0.09", ",", "0.1", "]", ")", "\n", "p_values_scaling", "=", "np", ".", "array", "(", "[", "2", ",", "2", ",", "1", ",", "2", ",", "1", ",", "3", ",", "1", ",", "2", ",", "4", ",", "1", "]", ")", "\n", "\n", "assert", "quantile_based_fwer", "(", "p_values", ",", "p_values_scaling", ",", "quantile", "=", "0.5", ")", "==", "approx", "(", "0.15", ")", "\n", "assert", "quantile_based_fwer", "(", "p_values", ",", "p_values_scaling", ",", "quantile", "=", "0.25", ")", "==", "approx", "(", "0.17", ")", "\n", "assert", "quantile_based_fwer", "(", "p_values", ",", "p_values_scaling", ",", "quantile", "=", "0.75", ")", "==", "approx", "(", "0.193", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_quantile_based_fwer_raises_error": [[53, 65], ["pytest.raises", "dowhy.gcm.stats.quantile_based_fwer", "pytest.raises", "dowhy.gcm.stats.quantile_based_fwer", "pytest.raises", "dowhy.gcm.stats.quantile_based_fwer", "pytest.raises", "dowhy.gcm.stats.quantile_based_fwer", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.quantile_based_fwer"], ["", "def", "test_quantile_based_fwer_raises_error", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "assert", "quantile_based_fwer", "(", "np", ".", "array", "(", "[", "0.1", ",", "0.5", ",", "1", "]", ")", ",", "quantile", "=", "0", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "assert", "quantile_based_fwer", "(", "np", ".", "array", "(", "[", "0.1", ",", "0.5", ",", "1", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", ",", "quantile", "=", "0.1", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "assert", "quantile_based_fwer", "(", "np", ".", "array", "(", "[", "0.1", ",", "0.5", ",", "1", "]", ")", ",", "quantile", "=", "1.1", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "assert", "quantile_based_fwer", "(", "np", ".", "array", "(", "[", "0.1", ",", "0.5", ",", "1", "]", ")", ",", "quantile", "=", "-", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_marginal_expectation_returns_all_results": [[67, 79], ["numpy.random.normal", "numpy.random.normal", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor.fit", "dowhy.gcm.stats.marginal_expectation"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation"], ["", "", "def", "test_marginal_expectation_returns_all_results", "(", ")", ":", "\n", "# Just checking formats, i.e. no need for correlation.", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "3", ")", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "1", ")", ")", "\n", "\n", "model_all_features", "=", "create_linear_regressor", "(", ")", "\n", "model_all_features", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n", "results", "=", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "X", ",", "X", ",", "[", "0", "]", ",", "return_averaged_results", "=", "False", ")", "\n", "assert", "results", ".", "shape", "[", "0", "]", "==", "1000", "\n", "assert", "results", ".", "shape", "[", "1", "]", "==", "1000", "\n", "assert", "results", ".", "shape", "[", "2", "]", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_marginal_expectation_returns_reduced_results": [[81, 92], ["numpy.random.normal", "numpy.random.normal", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor.fit", "dowhy.gcm.stats.marginal_expectation"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation"], ["", "def", "test_marginal_expectation_returns_reduced_results", "(", ")", ":", "\n", "# Just checking formats, i.e. no need for correlation.", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "3", ")", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "1", ")", ")", "\n", "\n", "model_all_features", "=", "create_linear_regressor", "(", ")", "\n", "model_all_features", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n", "results", "=", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "X", ",", "X", ",", "[", "0", "]", ",", "return_averaged_results", "=", "True", ")", "\n", "assert", "results", ".", "shape", "[", "0", "]", "==", "1000", "\n", "assert", "results", ".", "shape", "[", "1", "]", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_marginal_expectation_independent_continuous_linear": [[94, 173], ["flaky.flaky", "numpy.random.normal", "Y.reshape.reshape", "X[].reshape", "X[].reshape", "X[].reshape", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor.fit", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor.fit", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor.fit", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor.fit", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor.fit", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "dowhy.gcm.ml.create_linear_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_linear_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_linear_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_linear_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_linear_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_linear_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_linear_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_linear_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_linear_regressor.predict", "dowhy.gcm.ml.create_linear_regressor.predict", "dowhy.gcm.ml.create_linear_regressor.predict", "dowhy.gcm.ml.create_linear_regressor.predict", "dowhy.gcm.ml.create_linear_regressor.predict", "dowhy.gcm.ml.create_linear_regressor.predict", "dowhy.gcm.ml.create_linear_regressor.predict", "dowhy.gcm.ml.create_linear_regressor.predict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_marginal_expectation_independent_continuous_linear", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "3", ")", ")", "\n", "Y", "=", "3", "*", "X", "[", ":", ",", "0", "]", "+", "2", "*", "X", "[", ":", ",", "1", "]", "-", "X", "[", ":", ",", "2", "]", "\n", "Y", "=", "Y", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "X0", "=", "X", "[", ":", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X1", "=", "X", "[", ":", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X2", "=", "X", "[", ":", ",", "2", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X01", "=", "X", "[", ":", ",", ":", "2", "]", "\n", "\n", "model_all_features", "=", "create_linear_regressor", "(", ")", "\n", "model_all_features", ".", "fit", "(", "X", ",", "Y", ")", "\n", "model_feature_0", "=", "create_linear_regressor", "(", ")", "\n", "model_feature_0", ".", "fit", "(", "X0", ",", "Y", ")", "\n", "model_feature_1", "=", "create_linear_regressor", "(", ")", "\n", "model_feature_1", ".", "fit", "(", "X1", ",", "Y", ")", "\n", "model_feature_2", "=", "create_linear_regressor", "(", ")", "\n", "model_feature_2", ".", "fit", "(", "X2", ",", "Y", ")", "\n", "model_feature_01", "=", "create_linear_regressor", "(", ")", "\n", "model_feature_01", ".", "fit", "(", "X01", ",", "Y", ")", "\n", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_0", ".", "predict", "(", "X0", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "0", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_independently'", ")", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_1", ".", "predict", "(", "X1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "1", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_independently'", ")", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_2", ".", "predict", "(", "X2", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "2", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_independently'", ")", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_01", ".", "predict", "(", "X01", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_independently'", ")", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_0", ".", "predict", "(", "X0", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "0", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_jointly'", ")", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_1", ".", "predict", "(", "X1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "1", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_jointly'", ")", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_2", ".", "predict", "(", "X2", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "2", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_jointly'", ")", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_01", ".", "predict", "(", "X01", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_jointly'", ")", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_marginal_expectation_independent_categorical_linear": [[175, 229], ["flaky.flaky", "numpy.random.normal", "X[].reshape", "X[].reshape", "X[].reshape", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_logistic_regression_classifier.fit", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_logistic_regression_classifier.fit", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_logistic_regression_classifier.fit", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_logistic_regression_classifier.fit", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_logistic_regression_classifier.fit", "numpy.sum", "pytest.approx", "numpy.sum", "pytest.approx", "numpy.sum", "pytest.approx", "numpy.sum", "pytest.approx", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "dowhy.gcm.ml.create_logistic_regression_classifier.predict_probabilities", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_logistic_regression_classifier.predict_probabilities", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_logistic_regression_classifier.predict_probabilities", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_logistic_regression_classifier.predict_probabilities", "dowhy.gcm.stats.marginal_expectation"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_marginal_expectation_independent_categorical_linear", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "3", ")", ")", "\n", "Y", "=", "3", "*", "X", "[", ":", ",", "0", "]", "+", "2", "*", "X", "[", ":", ",", "1", "]", "-", "X", "[", ":", ",", "2", "]", "\n", "Y", "=", "(", "Y", "<=", "0", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "X0", "=", "X", "[", ":", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X1", "=", "X", "[", ":", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X2", "=", "X", "[", ":", ",", "2", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X01", "=", "X", "[", ":", ",", ":", "2", "]", "\n", "\n", "model_all_features", "=", "create_logistic_regression_classifier", "(", ")", "\n", "model_all_features", ".", "fit", "(", "X", ",", "Y", ")", "\n", "model_feature_0", "=", "create_logistic_regression_classifier", "(", ")", "\n", "model_feature_0", ".", "fit", "(", "X0", ",", "Y", ")", "\n", "model_feature_1", "=", "create_logistic_regression_classifier", "(", ")", "\n", "model_feature_1", ".", "fit", "(", "X1", ",", "Y", ")", "\n", "model_feature_2", "=", "create_logistic_regression_classifier", "(", ")", "\n", "model_feature_2", ".", "fit", "(", "X2", ",", "Y", ")", "\n", "model_feature_01", "=", "create_logistic_regression_classifier", "(", ")", "\n", "model_feature_01", ".", "fit", "(", "X01", ",", "Y", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_0", ".", "predict_probabilities", "(", "X0", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "0", "]", ",", "\n", "feature_perturbation", "=", "\n", "'randomize_columns_independently'", ")", ")", ",", "\n", "axis", "=", "0", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "sum", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_1", ".", "predict_probabilities", "(", "X1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "1", "]", ",", "\n", "feature_perturbation", "=", "\n", "'randomize_columns_independently'", ")", ")", ",", "\n", "axis", "=", "0", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "sum", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_2", ".", "predict_probabilities", "(", "X2", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "2", "]", ",", "\n", "feature_perturbation", "=", "\n", "'randomize_columns_independently'", ")", ")", ",", "\n", "axis", "=", "0", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "sum", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_01", ".", "predict_probabilities", "(", "X01", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "X", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "feature_perturbation", "=", "\n", "'randomize_columns_independently'", ")", ")", ",", "\n", "axis", "=", "0", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_marginal_expectation_independent_continuous_nonlinear": [[231, 281], ["flaky.flaky", "numpy.random.normal", "Y.reshape.reshape", "X[].reshape", "X[].reshape", "X[].reshape", "dowhy.gcm.ml.create_hist_gradient_boost_regressor", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.fit", "dowhy.gcm.ml.create_hist_gradient_boost_regressor", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.fit", "dowhy.gcm.ml.create_hist_gradient_boost_regressor", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.fit", "dowhy.gcm.ml.create_hist_gradient_boost_regressor", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.fit", "dowhy.gcm.ml.create_hist_gradient_boost_regressor", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.fit", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict().reshape", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict", "dowhy.gcm.ml.create_hist_gradient_boost_regressor.predict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_marginal_expectation_independent_continuous_nonlinear", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "2000", ",", "3", ")", ")", "\n", "Y", "=", "(", "2", "*", "X", "[", ":", ",", "0", "]", "+", "X", "[", ":", ",", "1", "]", ")", "**", "2", "+", "X", "[", ":", ",", "2", "]", "\n", "Y", "=", "Y", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "X0", "=", "X", "[", ":", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X1", "=", "X", "[", ":", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X2", "=", "X", "[", ":", ",", "2", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X01", "=", "X", "[", ":", ",", ":", "2", "]", "\n", "\n", "model_all_features", "=", "create_hist_gradient_boost_regressor", "(", ")", "\n", "model_all_features", ".", "fit", "(", "X", ",", "Y", ")", "\n", "model_feature_0", "=", "create_hist_gradient_boost_regressor", "(", ")", "\n", "model_feature_0", ".", "fit", "(", "X0", ",", "Y", ")", "\n", "model_feature_1", "=", "create_hist_gradient_boost_regressor", "(", ")", "\n", "model_feature_1", ".", "fit", "(", "X1", ",", "Y", ")", "\n", "model_feature_2", "=", "create_hist_gradient_boost_regressor", "(", ")", "\n", "model_feature_2", ".", "fit", "(", "X2", ",", "Y", ")", "\n", "model_feature_01", "=", "create_hist_gradient_boost_regressor", "(", ")", "\n", "model_feature_01", ".", "fit", "(", "X01", ",", "Y", ")", "\n", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_0", ".", "predict", "(", "X0", "[", ":", "100", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", "[", ":", "100", "]", ",", "\n", "[", "0", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_independently'", ")", ")", ")", "==", "approx", "(", "0", ",", "abs", "=", "100", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_1", ".", "predict", "(", "X1", "[", ":", "100", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", "[", ":", "100", "]", ",", "\n", "[", "1", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_independently'", ")", ")", ")", "==", "approx", "(", "0", ",", "abs", "=", "100", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_2", ".", "predict", "(", "X2", "[", ":", "100", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", "[", ":", "100", "]", ",", "\n", "[", "2", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_independently'", ")", ")", ")", "==", "approx", "(", "0", ",", "abs", "=", "100", ")", "\n", "assert", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_01", ".", "predict", "(", "X01", "[", ":", "100", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict", ",", "\n", "X", ",", "\n", "X", "[", ":", "100", "]", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "feature_perturbation", "=", "'randomize_columns_independently'", ")", ")", ")", "==", "approx", "(", "0", ",", "abs", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_marginal_expectation_independent_categorical_nonlinear": [[283, 337], ["flaky.flaky", "numpy.random.normal", "X[].reshape", "X[].reshape", "X[].reshape", "dowhy.gcm.ml.create_hist_gradient_boost_classifier", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.fit", "dowhy.gcm.ml.create_hist_gradient_boost_classifier", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.fit", "dowhy.gcm.ml.create_hist_gradient_boost_classifier", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.fit", "dowhy.gcm.ml.create_hist_gradient_boost_classifier", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.fit", "dowhy.gcm.ml.create_hist_gradient_boost_classifier", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.fit", "numpy.sum", "pytest.approx", "numpy.sum", "pytest.approx", "numpy.sum", "pytest.approx", "numpy.sum", "pytest.approx", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.predict_probabilities", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.predict_probabilities", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.predict_probabilities", "dowhy.gcm.stats.marginal_expectation", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.predict_probabilities", "dowhy.gcm.stats.marginal_expectation"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_marginal_expectation_independent_categorical_nonlinear", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "3", ")", ")", "\n", "Y", "=", "(", "2", "*", "X", "[", ":", ",", "0", "]", "+", "X", "[", ":", ",", "1", "]", ")", "**", "2", "+", "X", "[", ":", ",", "2", "]", "\n", "Y", "=", "(", "Y", "<=", "np", ".", "mean", "(", "Y", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "X0", "=", "X", "[", ":", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X1", "=", "X", "[", ":", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X2", "=", "X", "[", ":", ",", "2", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X01", "=", "X", "[", ":", ",", ":", "2", "]", "\n", "\n", "model_all_features", "=", "create_hist_gradient_boost_classifier", "(", ")", "\n", "model_all_features", ".", "fit", "(", "X", ",", "Y", ")", "\n", "model_feature_0", "=", "create_hist_gradient_boost_classifier", "(", ")", "\n", "model_feature_0", ".", "fit", "(", "X0", ",", "Y", ")", "\n", "model_feature_1", "=", "create_hist_gradient_boost_classifier", "(", ")", "\n", "model_feature_1", ".", "fit", "(", "X1", ",", "Y", ")", "\n", "model_feature_2", "=", "create_hist_gradient_boost_classifier", "(", ")", "\n", "model_feature_2", ".", "fit", "(", "X2", ",", "Y", ")", "\n", "model_feature_01", "=", "create_hist_gradient_boost_classifier", "(", ")", "\n", "model_feature_01", ".", "fit", "(", "X01", ",", "Y", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_0", ".", "predict_probabilities", "(", "X0", "[", ":", "100", "]", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "X", "[", ":", "100", "]", ",", "\n", "[", "0", "]", ",", "\n", "feature_perturbation", "=", "\n", "'randomize_columns_independently'", ")", ")", ",", "\n", "axis", "=", "0", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "sum", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_1", ".", "predict_probabilities", "(", "X1", "[", ":", "100", "]", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "X", "[", ":", "100", "]", ",", "\n", "[", "1", "]", ",", "\n", "feature_perturbation", "=", "\n", "'randomize_columns_independently'", ")", ")", ",", "\n", "axis", "=", "0", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "sum", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_2", ".", "predict_probabilities", "(", "X2", "[", ":", "100", "]", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "X", "[", ":", "100", "]", ",", "\n", "[", "2", "]", ",", "\n", "feature_perturbation", "=", "\n", "'randomize_columns_independently'", ")", ")", ",", "\n", "axis", "=", "0", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "assert", "np", ".", "sum", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "model_feature_01", ".", "predict_probabilities", "(", "X01", "[", ":", "100", "]", ")", "\n", "-", "marginal_expectation", "(", "model_all_features", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "X", "[", ":", "100", "]", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "feature_perturbation", "=", "\n", "'randomize_columns_independently'", ")", ")", ",", "\n", "axis", "=", "0", ")", ")", "==", "approx", "(", "0.2", ",", "abs", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_given_different_batch_sizes_when_estimating_marginal_expectation_then_returns_expected_result": [[339, 373], ["numpy.random.normal", "numpy.random.normal", "numpy.array", "np.random.normal.copy", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "dowhy.gcm.stats.marginal_expectation", "pytest.approx", "numpy.matlib.repmat", "range"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.marginal_expectation"], ["", "def", "test_given_different_batch_sizes_when_estimating_marginal_expectation_then_returns_expected_result", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "34", ",", "3", ")", ")", "\n", "feature_samples", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "123", ",", "3", ")", ")", "\n", "expected_non_aggregated", "=", "np", ".", "array", "(", "[", "repmat", "(", "X", "[", "i", ",", ":", "]", ",", "feature_samples", ".", "shape", "[", "0", "]", ",", "1", ")", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "\n", "def", "my_pred_func", "(", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "X", ".", "copy", "(", ")", "\n", "\n", "", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "1", ")", "==", "approx", "(", "X", ")", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "10", ")", "==", "approx", "(", "X", ")", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "100", ")", "==", "approx", "(", "X", ")", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "1000", ")", "==", "approx", "(", "X", ")", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "feature_samples", ".", "shape", "[", "0", "]", ")", "==", "approx", "(", "X", ")", "\n", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "1", ",", "\n", "return_averaged_results", "=", "False", ")", "==", "approx", "(", "expected_non_aggregated", ")", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "10", ",", "\n", "return_averaged_results", "=", "False", ")", "==", "approx", "(", "expected_non_aggregated", ")", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "100", ",", "\n", "return_averaged_results", "=", "False", ")", "==", "approx", "(", "expected_non_aggregated", ")", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "1000", ",", "\n", "return_averaged_results", "=", "False", ")", "==", "approx", "(", "expected_non_aggregated", ")", "\n", "assert", "marginal_expectation", "(", "my_pred_func", ",", "feature_samples", ",", "X", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "max_batch_size", "=", "feature_samples", ".", "shape", "[", "0", "]", ",", "\n", "return_averaged_results", "=", "False", ")", "==", "approx", "(", "expected_non_aggregated", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_given_linear_dependent_data_when_estimate_ftest_pvalue_then_returns_expected_result": [[375, 399], ["flaky.flaky", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.stats.estimate_ftest_pvalue", "dowhy.gcm.stats.estimate_ftest_pvalue", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.estimate_ftest_pvalue", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.estimate_ftest_pvalue"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_linear_dependent_data_when_estimate_ftest_pvalue_then_returns_expected_result", "(", ")", ":", "\n", "    ", "X_training", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "Y_training", "=", "X_training", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.05", ",", "1000", ")", "\n", "\n", "X_test", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "Y_test", "=", "X_test", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.05", ",", "1000", ")", "\n", "\n", "assert", "estimate_ftest_pvalue", "(", "X_training", ",", "\n", "np", ".", "array", "(", "[", "]", ")", ",", "\n", "Y_training", ",", "\n", "X_test", ",", "\n", "np", ".", "array", "(", "[", "]", ")", ",", "\n", "Y_test", ")", "<", "0.05", "\n", "\n", "Y_training", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "0.05", ",", "1000", ")", "\n", "Y_test", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "0.05", ",", "1000", ")", "\n", "\n", "assert", "estimate_ftest_pvalue", "(", "X_training", ",", "\n", "np", ".", "array", "(", "[", "]", ")", ",", "\n", "Y_training", ",", "\n", "X_test", ",", "\n", "np", ".", "array", "(", "[", "]", ")", ",", "\n", "Y_test", ")", ">=", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_stats.test_given_multivariate_dependent_data_when_estimate_ftest_pvalue_then_returns_expected_result": [[401, 427], ["flaky.flaky", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.stats.estimate_ftest_pvalue", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.stats.estimate_ftest_pvalue", "numpy.column_stack", "numpy.column_stack", "numpy.column_stack", "numpy.column_stack"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.estimate_ftest_pvalue", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.estimate_ftest_pvalue"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_multivariate_dependent_data_when_estimate_ftest_pvalue_then_returns_expected_result", "(", ")", ":", "\n", "    ", "X1_training", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X2_training", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "Y_training", "=", "X1_training", "+", "X2_training", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.05", ",", "1000", ")", "\n", "\n", "X1_test", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X2_test", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "Y_test", "=", "X1_test", "+", "X2_test", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.05", ",", "1000", ")", "\n", "\n", "assert", "estimate_ftest_pvalue", "(", "np", ".", "column_stack", "(", "[", "X1_training", ",", "X2_training", "]", ")", ",", "\n", "X1_training", ",", "\n", "Y_training", ",", "\n", "np", ".", "column_stack", "(", "[", "X1_test", ",", "X2_test", "]", ")", ",", "\n", "X1_test", ",", "\n", "Y_test", ")", "<", "0.05", "\n", "\n", "Y_training", "=", "X1_training", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.05", ",", "1000", ")", "\n", "Y_test", "=", "X1_test", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.05", ",", "1000", ")", "\n", "\n", "assert", "estimate_ftest_pvalue", "(", "np", ".", "column_stack", "(", "[", "X1_training", ",", "X2_training", "]", ")", ",", "\n", "X1_training", ",", "\n", "Y_training", ",", "\n", "np", ".", "column_stack", "(", "[", "X1_test", ",", "X2_test", "]", ")", ",", "\n", "X1_test", ",", "\n", "Y_test", ")", ">=", "0.05", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.preserve_random_generator_state": [[13, 20], ["numpy.random.get_state", "random.getstate", "numpy.random.set_state", "random.setstate"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "preserve_random_generator_state", "(", ")", ":", "\n", "    ", "numpy_state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "random_state", "=", "random", ".", "getstate", "(", ")", "\n", "yield", "\n", "np", ".", "random", ".", "set_state", "(", "numpy_state", ")", "\n", "random", ".", "setstate", "(", "random_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_given_few_features_when_estimate_shapley_values_with_auto_approx_then_returns_correct_result": [[22, 33], ["test_shapley._generate_data", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.ShapleyConfig", "pytest.approx", "test_shapley._set_function_for_aggregated_feature_attribution", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_given_few_features_when_estimate_shapley_values_with_auto_approx_then_returns_correct_result", "(", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "4", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_values", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "AUTO", ",", "n_jobs", "=", "1", ")", ")", "\n", "\n", "assert", "coefficients", "*", "(", "X", "[", "0", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_given_many_features_when_estimate_shapley_values_with_auto_approx_then_returns_correct_result": [[35, 46], ["test_shapley._generate_data", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.ShapleyConfig", "pytest.approx", "test_shapley._set_function_for_aggregated_feature_attribution", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_given_many_features_when_estimate_shapley_values_with_auto_approx_then_returns_correct_result", "(", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_values", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "AUTO", ",", "n_jobs", "=", "1", ")", ")", "\n", "\n", "assert", "coefficients", "*", "(", "X", "[", "0", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_estimate_shapley_values_symmetry_exact": [[48, 59], ["test_shapley._generate_data", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.ShapleyConfig", "pytest.approx", "test_shapley._set_function_for_aggregated_feature_attribution", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_estimate_shapley_values_symmetry_exact", "(", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_values", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EXACT", ",", "n_jobs", "=", "1", ")", ")", "\n", "\n", "assert", "coefficients", "*", "(", "X", "[", "0", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_estimate_shapley_values_symmetry_exact_fast": [[61, 72], ["test_shapley._generate_data", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.ShapleyConfig", "pytest.approx", "test_shapley._set_function_for_aggregated_feature_attribution", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_estimate_shapley_values_symmetry_exact_fast", "(", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_values", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EXACT_FAST", ",", "n_jobs", "=", "1", ")", ")", "\n", "\n", "assert", "coefficients", "*", "(", "X", "[", "0", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_estimate_shapley_values_symmetry_approximation_via_subset": [[74, 85], ["test_shapley._generate_data", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.ShapleyConfig", "pytest.approx", "test_shapley._set_function_for_aggregated_feature_attribution", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_estimate_shapley_values_symmetry_approximation_via_subset", "(", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_values", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "SUBSET_SAMPLING", ")", ")", "\n", "\n", "assert", "coefficients", "*", "(", "X", "[", "0", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_evaluate_set_function_via_shapley_symmetry_approximation_via_permutation": [[87, 98], ["test_shapley._generate_data", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.ShapleyConfig", "pytest.approx", "test_shapley._set_function_for_aggregated_feature_attribution", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_evaluate_set_function_via_shapley_symmetry_approximation_via_permutation", "(", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_values", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "PERMUTATION", ")", ")", "\n", "\n", "assert", "coefficients", "*", "(", "X", "[", "0", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_estimate_shapley_values_symmetry_approximation_via_early_stopping": [[100, 111], ["test_shapley._generate_data", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.ShapleyConfig", "pytest.approx", "test_shapley._set_function_for_aggregated_feature_attribution", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_estimate_shapley_values_symmetry_approximation_via_early_stopping", "(", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_values", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EARLY_STOPPING", ")", ")", "\n", "\n", "assert", "coefficients", "*", "(", "X", "[", "0", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_estimate_shapley_values_symmetry_approximation_via_subset_with_random_seed": [[113, 139], ["test_shapley._generate_data", "dowhy.gcm.shapley.ShapleyConfig", "numpy.random.seed", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.random.seed", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.estimate_shapley_values", "pytest.approx", "pytest.approx", "dowhy.gcm.shapley.estimate_shapley_values", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_estimate_shapley_values_symmetry_approximation_via_subset_with_random_seed", "(", "preserve_random_generator_state", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_config", "=", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "SUBSET_SAMPLING", ")", "\n", "assert", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "!=", "approx", "(", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", ",", "abs", "=", "0", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "shapley_values_1", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "shapley_values_2", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "\n", "\n", "assert", "shapley_values_1", "==", "approx", "(", "shapley_values_2", ",", "abs", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_estimate_shapley_values_symmetry_approximation_via_permutation_with_random_seed": [[141, 170], ["flaky.flaky", "test_shapley._generate_data", "dowhy.gcm.shapley.ShapleyConfig", "numpy.random.seed", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.random.seed", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.estimate_shapley_values", "pytest.approx", "pytest.approx", "dowhy.gcm.shapley.estimate_shapley_values", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_estimate_shapley_values_symmetry_approximation_via_permutation_with_random_seed", "(", "\n", "preserve_random_generator_state", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_config", "=", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "PERMUTATION", ")", "\n", "assert", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "!=", "approx", "(", "\n", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", ",", "abs", "=", "0", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "shapley_values_1", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "shapley_values_2", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "\n", "\n", "assert", "shapley_values_1", "==", "approx", "(", "shapley_values_2", ",", "abs", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley.test_estimate_shapley_values_symmetry_approximation_via_early_stopping_with_random_seed": [[172, 200], ["test_shapley._generate_data", "dowhy.gcm.shapley.ShapleyConfig", "numpy.random.seed", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.random.seed", "dowhy.gcm.shapley.estimate_shapley_values", "numpy.sum", "dowhy.gcm.shapley.estimate_shapley_values", "pytest.approx", "pytest.approx", "dowhy.gcm.shapley.estimate_shapley_values", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution", "test_shapley._set_function_for_aggregated_feature_attribution"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.shapley.estimate_shapley_values", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution"], ["", "def", "test_estimate_shapley_values_symmetry_approximation_via_early_stopping_with_random_seed", "(", "\n", "preserve_random_generator_state", ")", ":", "\n", "    ", "X", ",", "coefficients", "=", "_generate_data", "(", "15", ")", "\n", "\n", "def", "model", "(", "x", ")", ":", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "shapley_config", "=", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EARLY_STOPPING", ")", "\n", "assert", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "!=", "approx", "(", "\n", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", ",", "abs", "=", "0", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "shapley_values_1", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "shapley_values_2", "=", "estimate_shapley_values", "(", "\n", "lambda", "subset", ":", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "\n", "shapley_config", ")", "\n", "\n", "assert", "shapley_values_1", "==", "approx", "(", "shapley_values_2", ",", "abs", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._generate_data": [[202, 204], ["numpy.random.normal", "numpy.random.choice"], "function", ["None"], ["", "def", "_generate_data", "(", "num_vars", ")", ":", "\n", "    ", "return", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "num_vars", ")", ")", ",", "np", ".", "random", ".", "choice", "(", "20", ",", "num_vars", ")", "-", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_shapley._set_function_for_aggregated_feature_attribution": [[206, 211], ["dowhy.gcm.stats.permute_features", "dowhy.gcm.util.general.means_difference", "test_shapley.test_given_few_features_when_estimate_shapley_values_with_auto_approx_then_returns_correct_result.model", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.permute_features", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.means_difference"], ["", "def", "_set_function_for_aggregated_feature_attribution", "(", "subset", ",", "X", ",", "model", ")", ":", "\n", "    ", "tmp", "=", "permute_features", "(", "X", ",", "np", ".", "arange", "(", "0", ",", "X", ".", "shape", "[", "1", "]", ")", "[", "subset", "==", "0", "]", ",", "False", ")", "\n", "tmp", "[", ":", ",", "subset", "==", "1", "]", "=", "X", "[", "0", ",", "subset", "==", "1", "]", "\n", "\n", "return", "means_difference", "(", "model", "(", "tmp", ")", ",", "X", "[", "0", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_uncertainty.test_estimate_entropy_using_discretization": [[10, 16], ["numpy.random.normal", "numpy.random.normal", "dowhy.gcm.uncertainty.estimate_entropy_using_discretization", "pytest.approx", "dowhy.gcm.uncertainty.estimate_entropy_using_discretization", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_using_discretization", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_using_discretization"], ["def", "test_estimate_entropy_using_discretization", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "3", ",", "10000", ")", "\n", "\n", "assert", "estimate_entropy_using_discretization", "(", "X", ")", "==", "approx", "(", "1.25", ",", "abs", "=", "0.2", ")", "\n", "assert", "estimate_entropy_using_discretization", "(", "Y", ")", "==", "approx", "(", "2.45", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_uncertainty.test_estimate_entropy_kmeans": [[18, 24], ["numpy.random.normal", "numpy.random.normal", "dowhy.gcm.uncertainty.estimate_entropy_kmeans", "pytest.approx", "dowhy.gcm.uncertainty.estimate_entropy_kmeans", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_kmeans", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_kmeans"], ["", "def", "test_estimate_entropy_kmeans", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "3", ",", "10000", ")", "\n", "\n", "assert", "estimate_entropy_kmeans", "(", "X", ")", "==", "approx", "(", "1.4", ",", "abs", "=", "0.2", ")", "\n", "assert", "estimate_entropy_kmeans", "(", "Y", ")", "==", "approx", "(", "2.5", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_uncertainty.test_estimate_gaussian_entropy": [[26, 32], ["numpy.random.normal", "numpy.random.normal", "dowhy.gcm.uncertainty.estimate_gaussian_entropy", "pytest.approx", "dowhy.gcm.uncertainty.estimate_gaussian_entropy", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_gaussian_entropy", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_gaussian_entropy"], ["", "def", "test_estimate_gaussian_entropy", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "3", ",", "10000", ")", "\n", "\n", "assert", "estimate_gaussian_entropy", "(", "X", ")", "==", "approx", "(", "1.4", ",", "abs", "=", "0.2", ")", "\n", "assert", "estimate_gaussian_entropy", "(", "Y", ")", "==", "approx", "(", "2.5", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_uncertainty.test_estimate_variance": [[34, 47], ["flaky.flaky", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.uncertainty.estimate_variance", "pytest.approx", "dowhy.gcm.uncertainty.estimate_variance", "pytest.approx", "dowhy.gcm.uncertainty.estimate_variance", "pytest.approx", "dowhy.gcm.uncertainty.estimate_variance", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_estimate_variance", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "3", ",", "10000", ")", "\n", "\n", "assert", "estimate_variance", "(", "X", ")", "==", "approx", "(", "1", ",", "abs", "=", "0.2", ")", "\n", "assert", "estimate_variance", "(", "Y", ")", "==", "approx", "(", "9", ",", "abs", "=", "0.2", ")", "\n", "\n", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000000", ",", "3", ")", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "3", ",", "(", "1000000", ",", "3", ")", ")", "\n", "\n", "assert", "estimate_variance", "(", "X", ")", "==", "approx", "(", "1", ",", "abs", "=", "1", ")", "\n", "assert", "estimate_variance", "(", "Y", ")", "==", "approx", "(", "729", ",", "abs", "=", "15", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_uncertainty.test_estimate_entropy_of_probabilities": [[49, 56], ["dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities"], ["", "def", "test_estimate_entropy_of_probabilities", "(", ")", ":", "\n", "    ", "assert", "estimate_entropy_of_probabilities", "(", "np", ".", "array", "(", "[", "[", "0.25", ",", "0.25", ",", "0.25", ",", "0.25", "]", "]", ")", ")", "==", "approx", "(", "1.38", ",", "abs", "=", "0.05", ")", "\n", "assert", "estimate_entropy_of_probabilities", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "0", "]", "]", ")", ")", "==", "approx", "(", "0", ",", "abs", "=", "0.05", ")", "\n", "assert", "estimate_entropy_of_probabilities", "(", "np", ".", "array", "(", "[", "[", "0.5", ",", "0", ",", "0", ",", "0.5", "]", "]", ")", ")", "==", "approx", "(", "0.69", ",", "abs", "=", "0.05", ")", "\n", "assert", "estimate_entropy_of_probabilities", "(", "np", ".", "array", "(", "[", "[", "0", ",", "0.5", ",", "0.5", ",", "0", "]", ",", "[", "0.5", ",", "0", ",", "0", ",", "0.5", "]", "]", ")", ")", "==", "approx", "(", "0.69", ",", "abs", "=", "0.05", ")", "\n", "assert", "estimate_entropy_of_probabilities", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "[", "1", ",", "0", ",", "0", ",", "0", "]", "]", ")", ")", "==", "approx", "(", "0", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_uncertainty.test_estimate_entropy_discrete": [[58, 62], ["dowhy.gcm.uncertainty.estimate_entropy_discrete", "pytest.approx", "dowhy.gcm.uncertainty.estimate_entropy_discrete", "pytest.approx", "numpy.random.choice", "scipy.stats.entropy", "numpy.random.choice", "scipy.stats.entropy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_discrete", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_discrete", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.cit.entropy"], ["", "def", "test_estimate_entropy_discrete", "(", ")", ":", "\n", "    ", "assert", "estimate_entropy_discrete", "(", "np", ".", "random", ".", "choice", "(", "2", ",", "(", "1000", ",", "1", ")", ",", "replace", "=", "True", ")", ")", "==", "approx", "(", "entropy", "(", "[", "0.5", ",", "0.5", "]", ")", ",", "0.05", ")", "\n", "assert", "estimate_entropy_discrete", "(", "np", ".", "random", ".", "choice", "(", "2", ",", "(", "1000", ",", "2", ")", ",", "replace", "=", "True", ")", ")", "==", "approx", "(", "entropy", "(", "[", "0.25", ",", "0.25", ",", "0.25", ",", "0.25", "]", ")", ",", "0.05", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_ml.test_categorical_features": [[9, 36], ["flaky.flaky", "numpy.random.normal", "numpy.random.choice().astype", "range", "numpy.array", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor.fit", "np.array.append", "numpy.array", "dowhy.gcm.ml.create_linear_regressor.predict", "pytest.approx", "dowhy.gcm.ml.create_linear_regressor.predict", "pytest.approx", "numpy.random.choice", "numpy.array", "np.array.reshape"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict"], ["@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_categorical_features", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "choice", "(", "3", ",", "1000", ")", ".", "astype", "(", "str", ")", "\n", "X2", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "1000", ")", ":", "\n", "        ", "tmp_value", "=", "2", "*", "X0", "[", "i", "]", "\n", "\n", "if", "X1", "[", "i", "]", "==", "'0'", ":", "\n", "            ", "tmp_value", "-=", "5", "\n", "", "elif", "X1", "[", "i", "]", "==", "'1'", ":", "\n", "            ", "tmp_value", "+=", "10", "\n", "", "else", ":", "\n", "            ", "tmp_value", "+=", "5", "\n", "\n", "", "X2", ".", "append", "(", "tmp_value", ")", "\n", "\n", "", "X2", "=", "np", ".", "array", "(", "X2", ")", "\n", "\n", "inputs", "=", "np", ".", "array", "(", "[", "X0", ",", "X1", "]", ",", "dtype", "=", "object", ")", ".", "T", "\n", "\n", "mdl", "=", "create_linear_regressor", "(", ")", "\n", "mdl", ".", "fit", "(", "inputs", ",", "X2", ")", "\n", "\n", "assert", "mdl", ".", "predict", "(", "np", ".", "array", "(", "[", "[", "2", ",", "'1'", "]", "]", ",", "dtype", "=", "object", ")", ")", "==", "approx", "(", "14", ")", "\n", "assert", "mdl", ".", "predict", "(", "inputs", ")", "==", "approx", "(", "X2", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_ml.test_categorical_inputs": [[38, 71], ["numpy.random.normal", "numpy.random.choice().astype", "range", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_logistic_regression_classifier.fit", "numpy.unique", "X2.append", "numpy.array", "dowhy.gcm.ml.create_logistic_regression_classifier.predict_probabilities", "pytest.approx", "numpy.sum", "dowhy.gcm.ml.create_logistic_regression_classifier.predict", "pytest.approx", "numpy.random.choice", "numpy.array", "numpy.array", "numpy.array", "numpy.median", "numpy.argmax", "dowhy.gcm.ml.create_logistic_regression_classifier.predict_probabilities"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities"], ["", "def", "test_categorical_inputs", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "choice", "(", "3", ",", "1000", ")", ".", "astype", "(", "str", ")", "\n", "X2", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "1000", ")", ":", "\n", "        ", "tmp_value", "=", "2", "*", "X0", "[", "i", "]", "\n", "\n", "if", "X1", "[", "i", "]", "==", "'0'", ":", "\n", "            ", "tmp_value", "-=", "5", "\n", "", "elif", "X1", "[", "i", "]", "==", "'1'", ":", "\n", "            ", "tmp_value", "+=", "10", "\n", "", "else", ":", "\n", "            ", "tmp_value", "+=", "5", "\n", "\n", "", "X2", ".", "append", "(", "tmp_value", ")", "\n", "\n", "", "X2", "=", "(", "X2", ">", "np", ".", "median", "(", "X2", ")", ")", ".", "astype", "(", "str", ")", "\n", "\n", "inputs", "=", "np", ".", "array", "(", "[", "X0", ",", "X1", "]", ",", "dtype", "=", "object", ")", ".", "T", "\n", "\n", "mdl", "=", "create_logistic_regression_classifier", "(", ")", "\n", "mdl", ".", "fit", "(", "inputs", ",", "X2", ")", "\n", "\n", "X2", "[", "'True'", "==", "1", "]", "=", "1", "\n", "X2", "[", "'False'", "==", "0", "]", "=", "0", "\n", "\n", "assert", "mdl", ".", "predict_probabilities", "(", "np", ".", "array", "(", "[", "[", "2", ",", "'1'", "]", "]", ",", "dtype", "=", "object", ")", ")", "==", "approx", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", "]", ")", ",", "abs", "=", "0.01", ")", "\n", "assert", "np", ".", "sum", "(", "np", ".", "argmax", "(", "mdl", ".", "predict_probabilities", "(", "inputs", ")", ",", "axis", "=", "1", ")", "!=", "X2", ")", "<", "20", "\n", "\n", "_", ",", "counts", "=", "np", ".", "unique", "(", "mdl", ".", "predict", "(", "inputs", ")", ",", "return_counts", "=", "True", ")", "\n", "assert", "counts", "/", "1000", "==", "approx", "(", "np", ".", "array", "(", "[", "0.5", ",", "0.5", "]", ")", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_ml.test_when_cloning_sklearn_classification_model_then_returns_a_cloned_object": [[73, 82], ["sklearn.linear_model.LogisticRegression", "dowhy.gcm.ml.SklearnClassificationModel", "dowhy.gcm.ml.SklearnClassificationModel.clone", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone"], ["", "def", "test_when_cloning_sklearn_classification_model_then_returns_a_cloned_object", "(", ")", ":", "\n", "    ", "logistic_regression_model", "=", "LogisticRegression", "(", ")", "\n", "mdl", "=", "SklearnClassificationModel", "(", "logistic_regression_model", ")", "\n", "cloned_mdl", "=", "mdl", ".", "clone", "(", ")", "\n", "\n", "assert", "isinstance", "(", "cloned_mdl", ",", "SklearnClassificationModel", ")", "\n", "assert", "isinstance", "(", "cloned_mdl", ".", "sklearn_model", ",", "LogisticRegression", ")", "\n", "assert", "mdl", "!=", "cloned_mdl", "\n", "assert", "cloned_mdl", ".", "sklearn_model", "!=", "logistic_regression_model", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_graph.test_fit_and_draw_samples": [[13, 40], ["flaky.flaky", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.fit", "dowhy.gcm.draw_samples", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.AdditiveNoiseModel", "numpy.mean", "pytest.approx", "numpy.std", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.std", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.std", "pytest.approx", "numpy.mean", "pytest.approx", "numpy.std", "pytest.approx", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor", "dowhy.gcm.ml.create_linear_regressor"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_fit_and_draw_samples", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "1000", ")", "\n", "X1", "=", "2", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X2", "=", "0.5", "*", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "X3", "=", "0.5", "*", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.1", ",", "1000", ")", "\n", "\n", "original_observations", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "scm", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X0'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X1'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "scm", ".", "set_causal_mechanism", "(", "'X3'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "fit", "(", "scm", ",", "original_observations", ")", "\n", "\n", "generated_samples", "=", "draw_samples", "(", "scm", ",", "1000", ")", "\n", "\n", "assert", "np", ".", "mean", "(", "generated_samples", "[", "'X0'", "]", ")", "==", "approx", "(", "np", ".", "mean", "(", "X0", ")", ",", "abs", "=", "0.1", ")", "\n", "assert", "np", ".", "std", "(", "generated_samples", "[", "'X0'", "]", ")", "==", "approx", "(", "np", ".", "std", "(", "X0", ")", ",", "abs", "=", "0.2", ")", "\n", "assert", "np", ".", "mean", "(", "generated_samples", "[", "'X1'", "]", ")", "==", "approx", "(", "np", ".", "mean", "(", "X1", ")", ",", "abs", "=", "0.1", ")", "\n", "assert", "np", ".", "std", "(", "generated_samples", "[", "'X1'", "]", ")", "==", "approx", "(", "np", ".", "std", "(", "X1", ")", ",", "abs", "=", "0.2", ")", "\n", "assert", "np", ".", "mean", "(", "generated_samples", "[", "'X2'", "]", ")", "==", "approx", "(", "np", ".", "mean", "(", "X2", ")", ",", "abs", "=", "0.1", ")", "\n", "assert", "np", ".", "std", "(", "generated_samples", "[", "'X2'", "]", ")", "==", "approx", "(", "np", ".", "std", "(", "X2", ")", ",", "abs", "=", "0.2", ")", "\n", "assert", "np", ".", "mean", "(", "generated_samples", "[", "'X3'", "]", ")", "==", "approx", "(", "np", ".", "mean", "(", "X3", ")", ",", "abs", "=", "0.1", ")", "\n", "assert", "np", ".", "std", "(", "generated_samples", "[", "'X3'", "]", ")", "==", "approx", "(", "np", ".", "std", "(", "X3", ")", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_graph.test_set_causal_model_raises_error": [[42, 45], ["pytest.raises", "dowhy.gcm.ProbabilisticCausalModel().set_causal_mechanism", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.ProbabilisticCausalModel"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism"], ["", "def", "test_set_causal_model_raises_error", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ProbabilisticCausalModel", "(", ")", ".", "set_causal_mechanism", "(", "'X0'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_graph.test_is_root_node": [[47, 52], ["networkx.DiGraph", "dowhy.gcm.is_root_node", "dowhy.gcm.is_root_node", "dowhy.gcm.is_root_node"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.is_root_node"], ["", "", "def", "test_is_root_node", "(", ")", ":", "\n", "    ", "graph", "=", "nx", ".", "DiGraph", "(", "[", "(", "\"X\"", ",", "\"Z\"", ")", ",", "(", "\"Y\"", ",", "\"Z\"", ")", "]", ")", "\n", "assert", "is_root_node", "(", "graph", ",", "\"X\"", ")", "==", "True", "\n", "assert", "is_root_node", "(", "graph", ",", "\"Y\"", ")", "==", "True", "\n", "assert", "is_root_node", "(", "graph", ",", "\"Z\"", ")", "==", "False", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_arrow_strength.preserve_random_generator_state": [[18, 25], ["numpy.random.get_state", "random.getstate", "numpy.random.set_state", "random.setstate"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "preserve_random_generator_state", "(", ")", ":", "\n", "    ", "numpy_state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "random_state", "=", "random", ".", "getstate", "(", ")", "\n", "yield", "\n", "np", ".", "random", ".", "set_state", "(", "numpy_state", ")", "\n", "random", ".", "setstate", "(", "random_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_arrow_strength.test_given_kl_divergence_attribution_func_when_estimate_arrow_strength_then_returns_expected_results": [[27, 34], ["flaky.flaky", "dowhy.gcm.arrow_strength", "test_arrow_strength._create_causal_model", "pytest.approx", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.arrow_strength", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_arrow_strength._create_causal_model"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_kl_divergence_attribution_func_when_estimate_arrow_strength_then_returns_expected_results", "(", ")", ":", "\n", "    ", "causal_strengths", "=", "arrow_strength", "(", "_create_causal_model", "(", ")", ",", "\n", "'X2'", ",", "\n", "difference_estimation_func", "=", "estimate_kl_divergence_continuous", ")", "\n", "assert", "causal_strengths", "[", "(", "'X0'", ",", "'X2'", ")", "]", "==", "approx", "(", "2.76", ",", "abs", "=", "0.4", ")", "\n", "assert", "causal_strengths", "[", "(", "'X1'", ",", "'X2'", ")", "]", "==", "approx", "(", "1.6", ",", "abs", "=", "0.4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_arrow_strength.test_given_continuous_data_with_default_attribution_func_when_estimate_arrow_strength_then_returns_expected_results": [[36, 43], ["flaky.flaky", "dowhy.gcm.arrow_strength", "test_arrow_strength._create_causal_model", "pytest.approx", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.arrow_strength", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_arrow_strength._create_causal_model"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_data_with_default_attribution_func_when_estimate_arrow_strength_then_returns_expected_results", "(", ")", ":", "\n", "    ", "causal_strengths", "=", "arrow_strength", "(", "_create_causal_model", "(", ")", ",", "'X2'", ")", "\n", "\n", "# By default, the strength is measure with respect to the variance.", "\n", "assert", "causal_strengths", "[", "(", "'X0'", ",", "'X2'", ")", "]", "==", "approx", "(", "9", ",", "abs", "=", "0.5", ")", "\n", "assert", "causal_strengths", "[", "(", "'X1'", ",", "'X2'", ")", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_arrow_strength.test_given_gcm_with_misspecified_mechanism_when_evaluate_arrow_strength_with__observational_data_then_gives_expected_results": [[45, 69], ["flaky.flaky", "dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "numpy.random.normal", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.fit", "dowhy.gcm.arrow_strength", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.AdditiveNoiseModel", "pytest.approx", "pytest.approx", "dowhy.gcm.ml.create_linear_regressor", "numpy.random.normal", "numpy.var", "numpy.var"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.arrow_strength", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_gcm_with_misspecified_mechanism_when_evaluate_arrow_strength_with__observational_data_then_gives_expected_results", "(", ")", ":", "\n", "    ", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X0'", ",", "'X2'", ")", "]", ")", ")", "\n", "# Here, we misspecified the mechanism on purpose by setting scale to 1 instead of 2.", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "2", ",", "2000", ")", "# The standard deviation in the data is actually 2.", "\n", "X1", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "2000", ")", "\n", "\n", "test_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X0", "+", "X1", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.2", ",", "X0", ".", "shape", "[", "0", "]", ")", "}", ")", "\n", "fit", "(", "causal_model", ",", "test_data", ")", "\n", "\n", "# If we provide the observational data here, we can mitigate the misspecification of the causal mechanism.", "\n", "causal_strengths", "=", "arrow_strength", "(", "causal_model", ",", "\n", "'X2'", ",", "\n", "parent_samples", "=", "test_data", ",", "\n", "difference_estimation_func", "=", "lambda", "x", ",", "y", ":", "np", ".", "var", "(", "y", ")", "-", "np", ".", "var", "(", "x", ")", ")", "\n", "assert", "causal_strengths", "[", "(", "'X0'", ",", "'X2'", ")", "]", "==", "approx", "(", "4", ",", "abs", "=", "0.5", ")", "\n", "assert", "causal_strengths", "[", "(", "'X1'", ",", "'X2'", ")", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_arrow_strength.test_given_categorical_target_node_when_estimate_arrow_strength_of_model_classifier_then_returns_expected_result": [[71, 86], ["flaky.flaky", "numpy.random.random", "dowhy.gcm.ClassifierFCM", "dowhy.gcm.ClassifierFCM.fit", "dowhy.gcm.ml.create_logistic_regression_classifier", "numpy.array().astype", "dowhy.gcm.influence.arrow_strength_of_model", "pytest.approx", "Y.append", "Y.append", "numpy.array", "numpy.random.random", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.arrow_strength_of_model"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_target_node_when_estimate_arrow_strength_of_model_classifier_then_returns_expected_result", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "random", "(", "(", "1000", ",", "5", ")", ")", "\n", "Y", "=", "[", "]", "\n", "\n", "for", "n", "in", "X", ":", "\n", "        ", "if", "(", "n", "[", "0", "]", "+", "n", "[", "1", "]", "+", "np", ".", "random", ".", "random", "(", "1", ")", ")", ">", "1.5", ":", "\n", "            ", "Y", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "Y", ".", "append", "(", "1", ")", "\n", "\n", "", "", "classifier_sem", "=", "ClassifierFCM", "(", "create_logistic_regression_classifier", "(", ")", ")", "\n", "classifier_sem", ".", "fit", "(", "X", ",", "np", ".", "array", "(", "Y", ")", ".", "astype", "(", "str", ")", ")", "\n", "\n", "assert", "arrow_strength_of_model", "(", "classifier_sem", ",", "X", ")", "==", "approx", "(", "np", ".", "array", "(", "[", "0.3", ",", "0.3", ",", "0", ",", "0", ",", "0", "]", ")", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_arrow_strength._create_causal_model": [[88, 103], ["dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "numpy.random.normal", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.fit", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.ml.create_linear_regressor", "numpy.random.normal"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["", "def", "_create_causal_model", "(", ")", ":", "\n", "    ", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X0'", ",", "'X2'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "\n", "test_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "3", "*", "X0", "+", "X1", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.2", ",", "X0", ".", "shape", "[", "0", "]", ")", "}", ")", "\n", "fit", "(", "causal_model", ",", "test_data", ")", "\n", "\n", "return", "causal_model", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_feature.test_when_using_parent_relevance_with_continous_data_then_returns_correct_results": [[17, 37], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "numpy.random.normal", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.fit", "dowhy.gcm.feature.parent_relevance", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.AdditiveNoiseModel", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.var", "dowhy.gcm.ml.create_linear_regressor", "training_data[].to_numpy"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.parent_relevance", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_when_using_parent_relevance_with_continous_data_then_returns_correct_results", "(", ")", ":", "\n", "    ", "causal_model", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X0'", ",", "'X2'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "3", "*", "X0", "+", "X1", "}", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "relevance", ",", "noise", "=", "parent_relevance", "(", "causal_model", ",", "'X2'", ")", "\n", "\n", "# Contributions should add up to Var(X2)", "\n", "assert", "relevance", "[", "(", "'X0'", ",", "'X2'", ")", "]", "+", "relevance", "[", "(", "'X1'", ",", "'X2'", ")", "]", "+", "noise", "==", "approx", "(", "np", ".", "var", "(", "training_data", "[", "'X2'", "]", ".", "to_numpy", "(", ")", ")", ",", "abs", "=", "1.5", ")", "\n", "assert", "relevance", "[", "(", "'X0'", ",", "'X2'", ")", "]", "==", "approx", "(", "9", ",", "abs", "=", "1", ")", "\n", "assert", "relevance", "[", "(", "'X1'", ",", "'X2'", ")", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.3", ")", "\n", "assert", "noise", "==", "approx", "(", "0", ",", "abs", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_feature.test_when_using_parent_relevance_with_categorical_data_then_returns_correct_results": [[39, 76], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "numpy.random.uniform", "numpy.array().astype", "dowhy.gcm.fit", "dowhy.gcm.feature.parent_relevance", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ClassifierFCM", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "np.array().astype.append", "np.array().astype.append", "numpy.array", "pandas.DataFrame"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.parent_relevance"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_when_using_parent_relevance_with_categorical_data_then_returns_correct_results", "(", ")", ":", "\n", "    ", "causal_model", "=", "StructuralCausalModel", "(", "\n", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'Y'", ")", ",", "(", "'X1'", ",", "'Y'", ")", ",", "(", "'X2'", ",", "'Y'", ")", ",", "(", "'X3'", ",", "'Y'", ")", ",", "(", "'X4'", ",", "'Y'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "uniform", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "ScipyDistribution", "(", "stats", ".", "uniform", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "ScipyDistribution", "(", "stats", ".", "uniform", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X3'", ",", "ScipyDistribution", "(", "stats", ".", "uniform", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X4'", ",", "ScipyDistribution", "(", "stats", ".", "uniform", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'Y'", ",", "ClassifierFCM", "(", ")", ")", "\n", "\n", "X", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "(", "1000", ",", "5", ")", ")", "\n", "Y", "=", "[", "]", "\n", "\n", "for", "n", "in", "X", ":", "\n", "        ", "if", "n", "[", "0", "]", "+", "n", "[", "1", "]", ">", "1", ":", "\n", "            ", "Y", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "Y", ".", "append", "(", "1", ")", "\n", "\n", "", "", "X0", "=", "X", "[", ":", ",", "0", "]", "\n", "X1", "=", "X", "[", ":", ",", "1", "]", "\n", "X2", "=", "X", "[", ":", ",", "2", "]", "\n", "X3", "=", "X", "[", ":", ",", "3", "]", "\n", "X4", "=", "X", "[", ":", ",", "4", "]", "\n", "Y", "=", "np", ".", "array", "(", "Y", ")", ".", "astype", "(", "str", ")", "\n", "\n", "fit", "(", "causal_model", ",", "data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", ",", "'X4'", ":", "X4", ",", "'Y'", ":", "Y", "}", ")", ")", "\n", "\n", "relevance", ",", "noise", "=", "parent_relevance", "(", "causal_model", ",", "'Y'", ",", "num_samples_randomization", "=", "1000", ",", "num_samples_baseline", "=", "100", ")", "\n", "\n", "assert", "relevance", "[", "(", "'X0'", ",", "'Y'", ")", "]", "==", "approx", "(", "0.125", ",", "abs", "=", "0.05", ")", "\n", "assert", "relevance", "[", "(", "'X1'", ",", "'Y'", ")", "]", "==", "approx", "(", "0.125", ",", "abs", "=", "0.05", ")", "\n", "assert", "relevance", "[", "(", "'X2'", ",", "'Y'", ")", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.05", ")", "\n", "assert", "relevance", "[", "(", "'X3'", ",", "'Y'", ")", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.05", ")", "\n", "assert", "relevance", "[", "(", "'X4'", ",", "'Y'", ")", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.05", ")", "\n", "assert", "noise", "==", "approx", "(", "0", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_feature.test_when_using_parent_relevance_with_confidence_intervals_then_returns_reasonable_bounds": [[78, 108], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "dowhy.gcm.StructuralCausalModel.set_causal_mechanism", "numpy.random.normal", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.fit", "dowhy.gcm.confidence_intervals", "networkx.DiGraph", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.ScipyDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.feature.parent_relevance", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.array", "numpy.array", "numpy.array", "dowhy.gcm.ml.create_linear_regressor"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals.confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.parent_relevance", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_when_using_parent_relevance_with_confidence_intervals_then_returns_reasonable_bounds", "(", ")", ":", "\n", "    ", "causal_model", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X0'", ",", "'X2'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X0'", ",", "ScipyDistribution", "(", "stats", ".", "norm", ",", "loc", "=", "0", ",", "scale", "=", "1", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X2'", ",", "AdditiveNoiseModel", "(", "prediction_model", "=", "create_linear_regressor", "(", ")", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "3", "*", "X0", "+", "X1", "}", ")", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "def", "estimation_func", "(", ")", ":", "\n", "        ", "dict_result", ",", "noise", "=", "parent_relevance", "(", "causal_model", ",", "'X2'", ")", "\n", "dict_result", "[", "(", "'noise'", ",", "'X2'", ")", "]", "=", "noise", "\n", "return", "dict_result", "\n", "\n", "", "median_relevance", ",", "cis", "=", "confidence_intervals", "(", "estimation_func", ",", "num_bootstrap_resamples", "=", "10", ")", "\n", "\n", "# Contributions should add up to Var(X2)", "\n", "assert", "median_relevance", "[", "(", "'X0'", ",", "'X2'", ")", "]", "==", "approx", "(", "9", ",", "abs", "=", "1", ")", "\n", "assert", "median_relevance", "[", "(", "'X1'", ",", "'X2'", ")", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.3", ")", "\n", "assert", "median_relevance", "[", "(", "'noise'", ",", "'X2'", ")", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.5", ")", "\n", "\n", "assert", "cis", "[", "(", "'X0'", ",", "'X2'", ")", "]", "==", "approx", "(", "np", ".", "array", "(", "[", "8.5", ",", "9.5", "]", ")", ",", "abs", "=", "1", ")", "\n", "assert", "cis", "[", "(", "'X1'", ",", "'X2'", ")", "]", "==", "approx", "(", "np", ".", "array", "(", "[", "0.8", ",", "1.2", "]", ")", ",", "abs", "=", "0.4", ")", "\n", "assert", "cis", "[", "(", "'noise'", ",", "'X2'", ")", "]", "==", "approx", "(", "np", ".", "array", "(", "[", "-", "0.2", ",", "0.2", "]", ")", ",", "abs", "=", "0.4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_feature.test_feature_relevance_sample_mean_diff": [[110, 126], ["flaky.flaky", "numpy.random.normal", "dowhy.gcm.feature.feature_relevance_sample", "range", "numpy.random.choice", "numpy.sum", "pytest.approx", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_sample"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_feature_relevance_sample_mean_diff", "(", ")", ":", "\n", "    ", "num_vars", "=", "15", "\n", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "num_vars", ")", ")", "\n", "coefficients", "=", "np", ".", "random", ".", "choice", "(", "20", ",", "num_vars", ")", "-", "10", "\n", "\n", "def", "model", "(", "x", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "", "shapley_values", "=", "feature_relevance_sample", "(", "model", ",", "\n", "feature_samples", "=", "X", ",", "\n", "baseline_samples", "=", "X", "[", ":", "20", "]", ",", "\n", "subset_scoring_func", "=", "means_difference", ")", "\n", "\n", "for", "i", "in", "range", "(", "20", ")", ":", "\n", "        ", "assert", "coefficients", "*", "(", "X", "[", "i", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", "[", "i", "]", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_feature.test_given_baseline_values_when_estimating_feature_relevance_sample_with_mean_diff_then_returns_expected_result": [[128, 164], ["flaky.flaky", "numpy.random.normal", "dowhy.gcm.feature.feature_relevance_sample", "dowhy.gcm.feature.feature_relevance_sample", "dowhy.gcm.feature.feature_relevance_sample", "range", "numpy.random.choice", "numpy.sum", "numpy.zeros", "dowhy.gcm.shapley.ShapleyConfig", "dowhy.gcm.shapley.ShapleyConfig", "dowhy.gcm.shapley.ShapleyConfig", "pytest.approx", "pytest.approx", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.mean", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_sample", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_sample", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_sample"], ["", "", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_baseline_values_when_estimating_feature_relevance_sample_with_mean_diff_then_returns_expected_result", "(", ")", ":", "\n", "    ", "num_vars", "=", "5", "\n", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "num_vars", ")", ")", "\n", "coefficients", "=", "np", ".", "random", ".", "choice", "(", "20", ",", "num_vars", ")", "-", "10", "\n", "\n", "def", "model", "(", "x", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "", "shapley_values_1", "=", "feature_relevance_sample", "(", "model", ",", "\n", "feature_samples", "=", "X", ",", "\n", "baseline_samples", "=", "X", "[", ":", "20", "]", ",", "\n", "subset_scoring_func", "=", "lambda", "x", ",", "y", ":", "np", ".", "mean", "(", "x", ")", "*", "y", ",", "\n", "baseline_target_values", "=", "np", ".", "zeros", "(", "20", ")", ",", "\n", "shapley_config", "=", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EXACT", ")", ")", "\n", "\n", "shapley_values_2", "=", "feature_relevance_sample", "(", "model", ",", "\n", "feature_samples", "=", "X", ",", "\n", "baseline_samples", "=", "X", "[", ":", "20", "]", ",", "\n", "subset_scoring_func", "=", "lambda", "x", ",", "y", ":", "np", ".", "mean", "(", "x", ")", "*", "y", ",", "\n", "baseline_target_values", "=", "np", ".", "zeros", "(", "20", ")", "+", "1", ",", "\n", "shapley_config", "=", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EXACT", ")", ")", "\n", "\n", "shapley_values_3", "=", "feature_relevance_sample", "(", "model", ",", "\n", "feature_samples", "=", "X", ",", "\n", "baseline_samples", "=", "X", "[", ":", "20", "]", ",", "\n", "subset_scoring_func", "=", "lambda", "x", ",", "y", ":", "np", ".", "mean", "(", "x", ")", "*", "y", ",", "\n", "baseline_target_values", "=", "np", ".", "zeros", "(", "20", ")", "+", "2", ",", "\n", "shapley_config", "=", "ShapleyConfig", "(", "approximation_method", "=", "ShapleyApproximationMethods", ".", "EXACT", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "20", ")", ":", "\n", "        ", "assert", "shapley_values_1", "[", "i", "]", "==", "approx", "(", "np", ".", "zeros", "(", "5", ")", ")", "\n", "assert", "shapley_values_2", "[", "i", "]", "*", "2", "==", "approx", "(", "shapley_values_3", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_feature.test_feature_relevance_sample_mean_diff_with_certain_batch_size": [[166, 182], ["flaky.flaky", "numpy.random.normal", "dowhy.gcm.feature.feature_relevance_sample", "range", "numpy.random.choice", "numpy.sum", "pytest.approx", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_sample"], ["", "", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_feature_relevance_sample_mean_diff_with_certain_batch_size", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "3", ")", ")", "\n", "coefficients", "=", "np", ".", "random", ".", "choice", "(", "20", ",", "3", ")", "-", "10", "\n", "\n", "def", "model", "(", "x", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "sum", "(", "coefficients", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n", "", "shapley_values", "=", "feature_relevance_sample", "(", "model", ",", "\n", "feature_samples", "=", "X", ",", "\n", "baseline_samples", "=", "X", ",", "\n", "subset_scoring_func", "=", "means_difference", ",", "\n", "max_batch_size", "=", "123", ")", "\n", "\n", "for", "i", "in", "range", "(", "1000", ")", ":", "\n", "        ", "assert", "coefficients", "*", "(", "X", "[", "i", ",", ":", "]", "-", "np", ".", "mean", "(", "X", ",", "axis", "=", "0", ")", ")", "==", "approx", "(", "shapley_values", "[", "i", "]", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_feature.test_when_using_feature_relevance_distribution_with_entropy_set_function_then_returns_correct_results": [[184, 232], ["flaky.flaky", "numpy.random.uniform", "numpy.array().astype", "dowhy.gcm.ml.create_logistic_regression_classifier", "dowhy.gcm.ml.create_logistic_regression_classifier.fit", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "dowhy.gcm.feature.feature_relevance_distribution", "numpy.mean().reshape", "numpy.mean().reshape", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "np.array().astype.append", "np.array().astype.append", "numpy.array", "dowhy.gcm.ml.create_logistic_regression_classifier.predict_probabilities", "numpy.mean", "numpy.mean", "dowhy.gcm.ml.create_logistic_regression_classifier.predict_probabilities"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.feature_relevance_distribution", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities"], ["", "", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_when_using_feature_relevance_distribution_with_entropy_set_function_then_returns_correct_results", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "(", "3000", ",", "5", ")", ")", "\n", "Y", "=", "[", "]", "\n", "\n", "for", "n", "in", "X", ":", "\n", "        ", "if", "n", "[", "0", "]", "+", "n", "[", "1", "]", ">", "1", ":", "\n", "            ", "Y", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "Y", ".", "append", "(", "1", ")", "\n", "\n", "", "", "Y", "=", "np", ".", "array", "(", "Y", ")", ".", "astype", "(", "str", ")", "\n", "\n", "classifier_mdl", "=", "create_logistic_regression_classifier", "(", ")", "\n", "classifier_mdl", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n", "# H(P(Y)) -- Can be precomputed", "\n", "h_p_Y", "=", "estimate_entropy_of_probabilities", "(", "\n", "np", ".", "mean", "(", "classifier_mdl", ".", "predict_probabilities", "(", "X", ")", ",", "axis", "=", "0", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "# -(H(P(Y | do(x_S)) - H(P(Y))) = H(P(Y)) - H(P(Y | do(x_S))", "\n", "def", "my_entropy_feature_attribution_function", "(", "randomized_predictions", ":", "np", ".", "ndarray", ",", "\n", "baseline_predictions", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "# H(P(Y | do(x_S)) = H(E[P(Y | x_S, X'_\\S)])", "\n", "\n", "# E[P(Y | x_S, X'_\\S)]", "\n", "        ", "p_y_do_xs", "=", "np", ".", "mean", "(", "randomized_predictions", ",", "axis", "=", "0", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "\n", "# H(E[P(Y | x_S, X'_\\S)])", "\n", "h_p_Y_do_xs", "=", "estimate_entropy_of_probabilities", "(", "p_y_do_xs", ")", "\n", "\n", "# Using H(P(Y)) based on the origina data, i.e. ignoring baseline_predictions.", "\n", "return", "h_p_Y", "-", "h_p_Y_do_xs", "\n", "\n", "", "feature_contributions", "=", "feature_relevance_distribution", "(", "classifier_mdl", ".", "predict_probabilities", ",", "\n", "X", ",", "\n", "my_entropy_feature_attribution_function", ")", "\n", "\n", "# E[H(P(Y)) - H(P(Y | do(X_U))] = H(P(Y)) - E[H(P(Y | X))]", "\n", "expected_sum_shapley_values", "=", "h_p_Y", "-", "estimate_entropy_of_probabilities", "(", "classifier_mdl", ".", "predict_probabilities", "(", "X", ")", ")", "\n", "\n", "assert", "feature_contributions", "[", "0", "]", "==", "approx", "(", "expected_sum_shapley_values", "/", "2", ",", "abs", "=", "0.075", ")", "\n", "assert", "feature_contributions", "[", "1", "]", "==", "approx", "(", "expected_sum_shapley_values", "/", "2", ",", "abs", "=", "0.075", ")", "\n", "assert", "feature_contributions", "[", "2", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.01", ")", "\n", "assert", "feature_contributions", "[", "3", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.01", ")", "\n", "assert", "feature_contributions", "[", "4", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.01", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "feature_contributions", ")", "==", "approx", "(", "expected_sum_shapley_values", ",", "abs", "=", "0.04", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_feature.test_given_misspecified_graph_when_estimating_parent_relevance_with_observed_datas_then_returns_correct_result": [[234, 256], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "dowhy.gcm.StructuralCausalModel", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "dowhy.gcm.fit", "dowhy.gcm.feature.parent_relevance", "dowhy.gcm.feature.parent_relevance", "networkx.DiGraph", "networkx.DiGraph", "numpy.random.normal", "pytest.approx", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.parent_relevance", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.feature.parent_relevance"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_misspecified_graph_when_estimating_parent_relevance_with_observed_datas_then_returns_correct_result", "(", ")", ":", "\n", "    ", "causal_model_without", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X1'", ",", "'X2'", ")", "]", ")", ")", "\n", "causal_model_with", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X0'", ",", "'X2'", ")", ",", "(", "'X1'", ",", "'X2'", ")", "]", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "X1", "=", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "\n", "'X1'", ":", "X1", ",", "\n", "'X2'", ":", "X0", "+", "X1", "}", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model_without", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model_with", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model_without", ",", "training_data", ")", "\n", "fit", "(", "causal_model_with", ",", "training_data", ")", "\n", "\n", "feature_relevance_missing_edge", ",", "_", "=", "parent_relevance", "(", "causal_model_without", ",", "'X2'", ",", "training_data", ")", "\n", "feature_relevance_with_edge", ",", "_", "=", "parent_relevance", "(", "causal_model_with", ",", "'X2'", ")", "\n", "\n", "assert", "feature_relevance_missing_edge", "[", "(", "'X0'", ",", "'X2'", ")", "]", "==", "approx", "(", "feature_relevance_with_edge", "[", "(", "'X0'", ",", "'X2'", ")", "]", ",", "abs", "=", "0.1", ")", "\n", "assert", "feature_relevance_missing_edge", "[", "(", "'X1'", ",", "'X2'", ")", "]", "==", "approx", "(", "feature_relevance_with_edge", "[", "(", "'X1'", ",", "'X2'", ")", "]", ",", "abs", "=", "0.1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly_attribution.test_given_simple_gaussian_data_when_attribute_anomaly_scores_with_it_score_then_returns_qualitatively_correct_results": [[13, 72], ["flaky.flaky", "numpy.random.normal", "numpy.column_stack", "dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator", "dowhy.gcm.InverseDensityScorer", "dowhy.gcm.InverseDensityScorer.fit", "numpy.array", "dowhy.gcm.anomaly.attribute_anomaly_scores", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.argmax", "numpy.argmax", "numpy.argmax", "pytest.approx", "pytest.approx", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.attribute_anomaly_scores"], ["@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_simple_gaussian_data_when_attribute_anomaly_scores_with_it_score_then_returns_qualitatively_correct_results", "(", ")", ":", "\n", "    ", "Z", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "X0", "=", "Z", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "X1", "=", "Z", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "X2", "=", "Z", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "X3", "=", "Z", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "\n", "original_observations", "=", "np", ".", "column_stack", "(", "[", "X0", ",", "X1", ",", "X2", ",", "X3", "]", ")", "\n", "\n", "# Defining an anomaly scorer that handles multidimensional inputs.", "\n", "density_estimator", "=", "GaussianMixtureDensityEstimator", "(", ")", "\n", "anomaly_scorer", "=", "InverseDensityScorer", "(", "density_estimator", ")", "\n", "anomaly_scorer", ".", "fit", "(", "original_observations", ")", "\n", "\n", "# Seeing that the expectation of the noise in all nodes is 0, we introduce anomalies by setting some of them to 3.", "\n", "anomaly_samples", "=", "np", ".", "array", "(", "[", "[", "3", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "3", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "3", ",", "0", "]", ",", "\n", "[", "0", ",", "3", ",", "3", ",", "0", "]", ",", "\n", "[", "3", ",", "0", ",", "3", ",", "3", "]", "]", ")", "\n", "\n", "contributions", "=", "attribute_anomaly_scores", "(", "anomaly_samples", ",", "\n", "original_observations", ",", "\n", "anomaly_scorer", ".", "score", ",", "\n", "False", ")", "\n", "\n", "# In the first sample, only the first variable is anomalous. Therefore, it should have the highest contribution", "\n", "# and it should be \"significantly\" higher than the contribution of the other ones (here, we just arbitrarily say", "\n", "# it should be 3x higher. Due to the confounding factor Z, the reconstructed noise variables are pairwise dependent,", "\n", "# which is a violation of our causal sufficiency assumption. However, a confounder is included here to demonstrate", "\n", "# some robustness. Note that due to this and stochastic behaviour of the density estimator, it is", "\n", "# not possible to analytically compute expected results. Therefore, we rather look at the relations here.", "\n", "assert", "np", ".", "argmax", "(", "contributions", "[", "0", "]", ")", "==", "0", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "0", "]", "[", "0", "]", ">", "contributions", "[", "0", "]", "[", "1", ":", "]", "*", "3", ")", "\n", "\n", "# Same idea for the second sample, but here, it is the second variable that is anomalous.", "\n", "assert", "np", ".", "argmax", "(", "contributions", "[", "1", "]", ")", "==", "1", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "1", "]", "[", "1", "]", ">", "contributions", "[", "1", "]", "[", "0", "]", "*", "3", ")", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "1", "]", "[", "1", "]", ">", "contributions", "[", "1", "]", "[", "2", ":", "]", "*", "3", ")", "\n", "\n", "assert", "np", ".", "argmax", "(", "contributions", "[", "2", "]", ")", "==", "2", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "2", "]", "[", "2", "]", ">", "contributions", "[", "2", "]", "[", "0", ":", "2", "]", "*", "3", ")", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "2", "]", "[", "2", "]", ">", "contributions", "[", "2", "]", "[", "3", ":", "]", "*", "3", ")", "\n", "\n", "# In the fourth sample, there are 2 anomalous variables. Therefore, the contribution of these 2 variables should be", "\n", "# \"significantly\" higher than the contribution of the other variables. The contribution of both anomalous variables", "\n", "# should be equal (approximately).", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "3", "]", "[", "1", "]", ">", "contributions", "[", "3", "]", "[", "0", "]", "*", "3", ")", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "3", "]", "[", "2", "]", ">", "contributions", "[", "3", "]", "[", "0", "]", "*", "3", ")", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "3", "]", "[", "1", "]", ">", "contributions", "[", "3", "]", "[", "3", "]", "*", "3", ")", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "3", "]", "[", "2", "]", ">", "contributions", "[", "3", "]", "[", "3", "]", "*", "3", ")", "\n", "assert", "contributions", "[", "3", "]", "[", "1", "]", "==", "approx", "(", "contributions", "[", "3", "]", "[", "2", "]", ",", "abs", "=", "0.5", ")", "\n", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "4", "]", "[", "0", "]", ">", "contributions", "[", "4", "]", "[", "1", "]", "*", "3", ")", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "4", "]", "[", "2", "]", ">", "contributions", "[", "4", "]", "[", "1", "]", "*", "3", ")", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "4", "]", "[", "3", "]", ">", "contributions", "[", "4", "]", "[", "1", "]", "*", "3", ")", "\n", "assert", "contributions", "[", "4", "]", "[", "0", "]", "==", "approx", "(", "contributions", "[", "4", "]", "[", "2", "]", ",", "abs", "=", "0.5", ")", "\n", "assert", "contributions", "[", "4", "]", "[", "2", "]", "==", "approx", "(", "contributions", "[", "4", "]", "[", "3", "]", ",", "abs", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly_attribution.test_given_simple_gaussian_data_when_attribute_anomaly_scores_with_feature_relevance_then_returns_qualitatively_correct_results": [[74, 122], ["flaky.flaky", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.column_stack", "dowhy.gcm.density_estimators.GaussianMixtureDensityEstimator", "dowhy.gcm.InverseDensityScorer", "dowhy.gcm.InverseDensityScorer.fit", "numpy.mean", "numpy.array", "dowhy.gcm.anomaly.attribute_anomaly_scores", "numpy.all", "dowhy.gcm.InverseDensityScorer.score", "numpy.argmax", "numpy.sum", "pytest.approx", "numpy.sum", "pytest.approx", "numpy.sum", "pytest.approx", "dowhy.gcm.InverseDensityScorer.score", "dowhy.gcm.InverseDensityScorer.score", "dowhy.gcm.InverseDensityScorer.score", "anomaly_samples[].reshape", "anomaly_samples[].reshape", "anomaly_samples[].reshape"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.attribute_anomaly_scores", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_simple_gaussian_data_when_attribute_anomaly_scores_with_feature_relevance_then_returns_qualitatively_correct_results", "(", ")", ":", "\n", "    ", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "X1", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "X2", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "X3", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "5000", ")", "\n", "\n", "original_observations", "=", "np", ".", "column_stack", "(", "[", "X0", ",", "X1", ",", "X2", ",", "X3", "]", ")", "\n", "\n", "# Defining an anomaly scorer that handles multidimensional inputs.", "\n", "density_estimator", "=", "GaussianMixtureDensityEstimator", "(", "num_components", "=", "5", ")", "\n", "anomaly_scorer", "=", "InverseDensityScorer", "(", "density_estimator", ")", "\n", "anomaly_scorer", ".", "fit", "(", "original_observations", ")", "\n", "expectation_of_score", "=", "np", ".", "mean", "(", "anomaly_scorer", ".", "score", "(", "original_observations", ")", ")", "\n", "\n", "# Seeing that the expectation of the noise in all nodes is 0, we introduce anomalies by setting some of them to 3.", "\n", "anomaly_samples", "=", "np", ".", "array", "(", "[", "[", "3", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "3", ",", "3", ",", "0", "]", ",", "\n", "[", "3", ",", "0", ",", "3", ",", "3", "]", "]", ")", "\n", "\n", "contributions", "=", "attribute_anomaly_scores", "(", "anomaly_samples", ",", "\n", "original_observations", ",", "\n", "anomaly_scorer", ".", "score", ",", "\n", "True", ")", "\n", "\n", "assert", "np", ".", "argmax", "(", "contributions", "[", "0", "]", ")", "==", "0", "# The biggest contribution to the score should be for the first variable.", "\n", "assert", "contributions", "[", "0", "]", "[", "0", "]", ">", "0", "# The contribution should be positive (anomalous variable).", "\n", "assert", "np", ".", "all", "(", "contributions", "[", "0", "]", "[", "1", ":", "]", "<", "0", ")", "# Contributions should be negative (non-anomalous variables), since they", "\n", "# reduce the score.", "\n", "# The contributions should add up to g(x) - E[g(X)]", "\n", "assert", "np", ".", "sum", "(", "contributions", "[", "0", "]", ")", "==", "approx", "(", "anomaly_scorer", ".", "score", "(", "anomaly_samples", "[", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "-", "expectation_of_score", ")", "\n", "\n", "assert", "contributions", "[", "1", "]", "[", "1", "]", ">", "0", "# The contribution should be positive (anomalous variable).", "\n", "assert", "contributions", "[", "1", "]", "[", "2", "]", ">", "0", "# The contribution should be positive (anomalous variable).", "\n", "assert", "contributions", "[", "1", "]", "[", "0", "]", "<", "0", "# The contribution should be negative (non-anomalous variable).", "\n", "assert", "contributions", "[", "1", "]", "[", "3", "]", "<", "0", "# The contribution should be negative (non-anomalous variable).", "\n", "# The contributions should add up to g(x) - E[g(X)]", "\n", "assert", "np", ".", "sum", "(", "contributions", "[", "1", "]", ")", "==", "approx", "(", "anomaly_scorer", ".", "score", "(", "anomaly_samples", "[", "1", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "-", "expectation_of_score", ")", "\n", "\n", "assert", "contributions", "[", "2", "]", "[", "0", "]", ">", "0", "# The contribution should be positive (anomalous variable).", "\n", "assert", "contributions", "[", "2", "]", "[", "2", "]", ">", "0", "# The contribution should be positive (anomalous variable).", "\n", "assert", "contributions", "[", "2", "]", "[", "3", "]", ">", "0", "# The contribution should be positive (anomalous variable).", "\n", "assert", "contributions", "[", "2", "]", "[", "1", "]", "<", "0", "# The contribution should be negative (non-anomalous variable).", "\n", "# The contributions should add up to g(x) - E[g(X)]", "\n", "assert", "np", ".", "sum", "(", "contributions", "[", "2", "]", ")", "==", "approx", "(", "anomaly_scorer", ".", "score", "(", "anomaly_samples", "[", "2", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "-", "expectation_of_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly_attribution.test_given_simple_causal_chain_with_linear_relationships_when_attribute_anomaly_scores_with_it_score_then_returns_qualitatively_correct_results": [[124, 178], ["flaky.flaky", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.InvertibleStructuralCausalModel", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "pandas.DataFrame", "dowhy.gcm.attribute_anomalies", "numpy.all", "numpy.all", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "training_data[].to_numpy", "dowhy.gcm.MedianCDFQuantileScorer", "dowhy.gcm.MedianCDFQuantileScorer.fit", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "dowhy.gcm.MedianCDFQuantileScorer", "numpy.log", "test_anomaly_attribution.test_given_simple_causal_chain_with_linear_relationships_when_attribute_anomaly_scores_with_it_score_then_returns_qualitatively_correct_results.total_anomaly_score"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.attribute_anomalies", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_simple_causal_chain_with_linear_relationships_when_attribute_anomaly_scores_with_it_score_then_returns_qualitatively_correct_results", "(", ")", ":", "\n", "    ", "num_training_samples", "=", "5000", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "X1", "=", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "X2", "=", "X1", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "X3", "=", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "causal_model", "=", "InvertibleStructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "# Three examples:", "\n", "# 1. X1 is the root cause (+ 10 to the noise)", "\n", "# 2. X0 is the root cause (+ 10 to the noise)", "\n", "# 3. X0 and X3 are both root causes (+ 10 to both noises)", "\n", "anomaly_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "np", ".", "array", "(", "[", "0", ",", "10", ",", "10", "]", ")", ",", "\n", "'X1'", ":", "np", ".", "array", "(", "[", "10", ",", "10", ",", "10", "]", ")", ",", "\n", "'X2'", ":", "np", ".", "array", "(", "[", "10", ",", "10", ",", "10", "]", ")", ",", "\n", "'X3'", ":", "np", ".", "array", "(", "[", "10", ",", "10", ",", "20", "]", ")", "}", ")", "\n", "\n", "scores", "=", "attribute_anomalies", "(", "causal_model", ",", "\n", "'X3'", ",", "\n", "anomaly_data", ",", "\n", "anomaly_scorer", "=", "MedianCDFQuantileScorer", "(", ")", ",", "\n", "num_distribution_samples", "=", "num_training_samples", ",", "\n", "attribute_mean_deviation", "=", "False", ")", "\n", "\n", "def", "total_anomaly_score", "(", "training_data", ",", "anomaly_sample", ")", ":", "\n", "        ", "distribution_samples", "=", "training_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "\n", "anomaly_scorer", "=", "MedianCDFQuantileScorer", "(", ")", "\n", "anomaly_scorer", ".", "fit", "(", "distribution_samples", ")", "\n", "return", "-", "np", ".", "log", "(", "_relative_frequency", "(", "anomaly_scorer", ".", "score", "(", "distribution_samples", ")", "\n", ">=", "anomaly_scorer", ".", "score", "(", "anomaly_sample", ")", ")", ")", "\n", "\n", "", "assert", "scores", "[", "'X0'", "]", "[", "0", "]", "<", "0.5", "# Not anomalous.", "\n", "assert", "scores", "[", "'X0'", "]", "[", "1", "]", ">", "8", "# Anomalous, but the only root cause.", "\n", "assert", "scores", "[", "'X0'", "]", "[", "2", "]", ">", "4", "# Anomalous together with X1.", "\n", "assert", "scores", "[", "'X1'", "]", "[", "0", "]", ">", "8", "# Anomalous, but the only root cause.", "\n", "assert", "scores", "[", "'X1'", "]", "[", "1", "]", "<", "0.5", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X1'", "]", "[", "2", "]", "<", "0.5", "# Not anomalous given upstream nodes.", "\n", "assert", "np", ".", "all", "(", "scores", "[", "'X2'", "]", "<", "0.5", ")", "# Not anomalous given upstream nodes.", "\n", "assert", "np", ".", "all", "(", "scores", "[", "'X3'", "]", "[", ":", "2", "]", "<", "0.5", ")", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X3'", "]", "[", "2", "]", ">", "4", "# Anomalous together with X0.", "\n", "\n", "# The sum of the scores should add up to the anomaly score of the target (here, X3).", "\n", "assert", "scores", "[", "'X0'", "]", "[", "0", "]", "+", "scores", "[", "'X1'", "]", "[", "0", "]", "+", "scores", "[", "'X2'", "]", "[", "0", "]", "+", "scores", "[", "'X3'", "]", "[", "0", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "0", "]", ")", ",", "abs", "=", "0.001", ")", "\n", "assert", "scores", "[", "'X0'", "]", "[", "1", "]", "+", "scores", "[", "'X1'", "]", "[", "1", "]", "+", "scores", "[", "'X2'", "]", "[", "1", "]", "+", "scores", "[", "'X3'", "]", "[", "1", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "1", "]", ")", ",", "abs", "=", "0.001", ")", "\n", "assert", "scores", "[", "'X0'", "]", "[", "2", "]", "+", "scores", "[", "'X1'", "]", "[", "2", "]", "+", "scores", "[", "'X2'", "]", "[", "2", "]", "+", "scores", "[", "'X3'", "]", "[", "2", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "2", "]", ")", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly_attribution.test_given_simple_causal_chain_with_linear_relationships_when_attribute_anomaly_scores_with_feature_relevance_then_returns_qualitatively_correct_results": [[180, 233], ["flaky.flaky", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.InvertibleStructuralCausalModel", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "pandas.DataFrame", "dowhy.gcm.attribute_anomalies", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "networkx.DiGraph", "training_data[].to_numpy", "dowhy.gcm.MedianCDFQuantileScorer", "dowhy.gcm.MedianCDFQuantileScorer.fit", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "dowhy.gcm.MedianCDFQuantileScorer", "dowhy.gcm.MedianCDFQuantileScorer.score", "numpy.mean", "numpy.array", "numpy.array", "test_anomaly_attribution.test_given_simple_causal_chain_with_linear_relationships_when_attribute_anomaly_scores_with_it_score_then_returns_qualitatively_correct_results.total_anomaly_score"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly.attribute_anomalies", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly_scorer.AnomalyScorer.score"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_simple_causal_chain_with_linear_relationships_when_attribute_anomaly_scores_with_feature_relevance_then_returns_qualitatively_correct_results", "(", ")", ":", "\n", "    ", "num_training_samples", "=", "5000", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "X1", "=", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "X2", "=", "X1", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "X3", "=", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "\n", "causal_model", "=", "InvertibleStructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "# Three examples:", "\n", "# 1. X1 is the root cause (+ 10 to the noise)", "\n", "# 2. X0 is the root cause (+ 10 to the noise)", "\n", "# 3. X0 and X3 are both root causes (+ 10 to both noises)", "\n", "anomaly_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "np", ".", "array", "(", "[", "0", ",", "10", ",", "10", "]", ")", ",", "\n", "'X1'", ":", "np", ".", "array", "(", "[", "10", ",", "10", ",", "10", "]", ")", ",", "\n", "'X2'", ":", "np", ".", "array", "(", "[", "10", ",", "10", ",", "10", "]", ")", ",", "\n", "'X3'", ":", "np", ".", "array", "(", "[", "10", ",", "10", ",", "20", "]", ")", "}", ")", "\n", "\n", "scores", "=", "attribute_anomalies", "(", "causal_model", ",", "\n", "'X3'", ",", "\n", "anomaly_data", ",", "\n", "anomaly_scorer", "=", "MedianCDFQuantileScorer", "(", ")", ",", "\n", "num_distribution_samples", "=", "num_training_samples", ",", "\n", "attribute_mean_deviation", "=", "True", ")", "\n", "\n", "def", "total_anomaly_score", "(", "training_data", ",", "anomaly_sample", ")", ":", "\n", "        ", "distribution_samples", "=", "training_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "\n", "anomaly_scorer", "=", "MedianCDFQuantileScorer", "(", ")", "\n", "anomaly_scorer", ".", "fit", "(", "distribution_samples", ")", "\n", "return", "anomaly_scorer", ".", "score", "(", "anomaly_sample", ")", "-", "np", ".", "mean", "(", "anomaly_scorer", ".", "score", "(", "distribution_samples", ")", ")", "\n", "\n", "", "assert", "scores", "[", "'X0'", "]", "[", "0", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "# Not anomalous.", "\n", "assert", "scores", "[", "'X0'", "]", "[", "1", "]", ">", "0.4", "# Anomalous, but the only root cause.", "\n", "assert", "scores", "[", "'X0'", "]", "[", "2", "]", ">", "0.2", "# Anomalous together with X1.", "\n", "assert", "scores", "[", "'X1'", "]", "[", "0", "]", ">", "0.4", "# Anomalous, but the only root cause.", "\n", "assert", "scores", "[", "'X1'", "]", "[", "1", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X1'", "]", "[", "2", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.1", ")", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X2'", "]", "==", "approx", "(", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", ",", "abs", "=", "0.1", ")", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X3'", "]", "[", ":", "2", "]", "==", "approx", "(", "np", ".", "array", "(", "[", "0", ",", "0", "]", ")", ",", "abs", "=", "0.1", ")", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X3'", "]", "[", "2", "]", ">", "0.2", "# Anomalous together with X0.", "\n", "\n", "# The sum of the scores should add up to the anomaly score of the target (here, X3).", "\n", "assert", "scores", "[", "'X0'", "]", "[", "0", "]", "+", "scores", "[", "'X1'", "]", "[", "0", "]", "+", "scores", "[", "'X2'", "]", "[", "0", "]", "+", "scores", "[", "'X3'", "]", "[", "0", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "0", "]", ")", ",", "abs", "=", "0.001", ")", "\n", "assert", "scores", "[", "'X0'", "]", "[", "1", "]", "+", "scores", "[", "'X1'", "]", "[", "1", "]", "+", "scores", "[", "'X2'", "]", "[", "1", "]", "+", "scores", "[", "'X3'", "]", "[", "1", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "1", "]", ")", ",", "abs", "=", "0.001", ")", "\n", "assert", "scores", "[", "'X0'", "]", "[", "2", "]", "+", "scores", "[", "'X1'", "]", "[", "2", "]", "+", "scores", "[", "'X2'", "]", "[", "2", "]", "+", "scores", "[", "'X3'", "]", "[", "2", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "2", "]", ")", ",", "abs", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly_attribution.test_given_non_trivial_graph_with_nonlinear_relationships_when_attribute_anomaly_scores_with_it_score_then_returns_qualitatively_correct_results": [[235, 313], ["flaky.flaky", "numpy.random.normal", "numpy.random.uniform", "pandas.DataFrame", "dowhy.gcm.InvertibleStructuralCausalModel", "dowhy.gcm.InvertibleStructuralCausalModel.set_causal_mechanism", "dowhy.gcm.InvertibleStructuralCausalModel.set_causal_mechanism", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_non_trivial_graph_with_nonlinear_relationships_when_attribute_anomaly_scores_with_it_score_then_returns_qualitatively_correct_results", "(", ")", ":", "\n", "    ", "num_training_samples", "=", "10000", "\n", "\n", "# Defining ground truth model to avoid SCM learning issues and, hence, to focus on the anomaly attribution", "\n", "# algorithm.", "\n", "class", "MyNonLinearModel", "(", "PredictionModel", ")", ":", "\n", "        ", "def", "fit", "(", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "            ", "pass", "\n", "\n", "", "def", "predict", "(", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "            ", "return", "(", "np", ".", "sum", "(", "X", ",", "axis", "=", "1", ")", "**", "2", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "", "def", "clone", "(", "self", ")", ":", "\n", "            ", "pass", "\n", "\n", "", "", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "num_training_samples", ")", "\n", "X1", "=", "MyNonLinearModel", "(", ")", ".", "predict", "(", "X0", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "num_training_samples", ",", "1", ")", ")", "# X0**2 + N", "\n", "X2", "=", "np", ".", "random", ".", "uniform", "(", "-", "5", ",", "5", ",", "num_training_samples", ")", "\n", "X3", "=", "MyNonLinearModel", "(", ")", ".", "predict", "(", "np", ".", "column_stack", "(", "[", "X1", ",", "X2", "]", ")", ")", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "num_training_samples", ",", "1", ")", ")", "# (X1 + X2)**2 + N", "\n", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ".", "reshape", "(", "-", "1", ")", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", ".", "reshape", "(", "-", "1", ")", "}", ")", "\n", "causal_model", "=", "InvertibleStructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X1'", ",", "'X3'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X1'", ",", "AdditiveNoiseModel", "(", "MyNonLinearModel", "(", ")", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X3'", ",", "AdditiveNoiseModel", "(", "MyNonLinearModel", "(", ")", ")", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ",", "override_models", "=", "False", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "anomaly_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "np", ".", "array", "(", "[", "10", ",", "10", ",", "0", "]", ")", ",", "\n", "'X1'", ":", "np", ".", "array", "(", "[", "100", ",", "110", ",", "0", "]", ")", ",", "\n", "'X2'", ":", "np", ".", "array", "(", "[", "0", ",", "0", ",", "10", "]", ")", ",", "\n", "'X3'", ":", "np", ".", "array", "(", "[", "10000", ",", "12100", ",", "110", "]", ")", "}", ")", "\n", "\n", "scores", "=", "attribute_anomalies", "(", "causal_model", ",", "\n", "'X3'", ",", "\n", "anomaly_data", ",", "\n", "anomaly_scorer", "=", "MedianCDFQuantileScorer", "(", ")", ",", "\n", "num_distribution_samples", "=", "num_training_samples", ",", "\n", "attribute_mean_deviation", "=", "False", ")", "\n", "\n", "def", "total_anomaly_score", "(", "training_data", ",", "anomaly_sample", ")", ":", "\n", "        ", "distribution_samples", "=", "training_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "\n", "anomaly_scorer", "=", "MedianCDFQuantileScorer", "(", ")", "\n", "anomaly_scorer", ".", "fit", "(", "distribution_samples", ")", "\n", "return", "-", "np", ".", "log", "(", "_relative_frequency", "(", "anomaly_scorer", ".", "score", "(", "distribution_samples", ")", "\n", ">=", "anomaly_scorer", ".", "score", "(", "anomaly_sample", ")", ")", ")", "\n", "\n", "# 1. X0 is the root cause (+ 10 to the noise)", "\n", "# 2. X0 and X1 are the root causes (+ 10 to both noise)", "\n", "# 3. X2 and X3 are both root causes (+ 10 to both noises)", "\n", "", "assert", "scores", "[", "'X0'", "]", "[", "0", "]", ">", "8", "# Anomalous, but the only root cause.", "\n", "assert", "scores", "[", "'X0'", "]", "[", "1", "]", ">", "4", "# Anomalous, but together with X1.", "\n", "assert", "scores", "[", "'X0'", "]", "[", "2", "]", "<", "1", "# Not anomalous.", "\n", "\n", "assert", "scores", "[", "'X1'", "]", "[", "0", "]", "<", "1", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X1'", "]", "[", "1", "]", ">", "1", "# Anomalous, but together with X0.", "\n", "assert", "scores", "[", "'X1'", "]", "[", "2", "]", "<", "1", "# Not anomalous given upstream nodes.", "\n", "\n", "assert", "scores", "[", "'X2'", "]", "[", "0", "]", "<", "1", "# Not anomalous.", "\n", "assert", "scores", "[", "'X2'", "]", "[", "1", "]", "<", "1", "# Not anomalous.", "\n", "assert", "scores", "[", "'X2'", "]", "[", "2", "]", ">", "1", "# Anomalous, but together with X3.", "\n", "\n", "assert", "scores", "[", "'X3'", "]", "[", "0", "]", "<", "1", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X3'", "]", "[", "1", "]", "<", "1", "# Not anomalous given upstream nodes.", "\n", "assert", "scores", "[", "'X3'", "]", "[", "2", "]", ">", "1", "# Anomalous, but together with X1.", "\n", "\n", "# The sum of the scores should add up to the anomaly score of the target (here, X3).", "\n", "assert", "scores", "[", "'X0'", "]", "[", "0", "]", "+", "scores", "[", "'X1'", "]", "[", "0", "]", "+", "scores", "[", "'X2'", "]", "[", "0", "]", "+", "scores", "[", "'X3'", "]", "[", "0", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "0", "]", ")", ",", "abs", "=", "0.4", ")", "\n", "assert", "scores", "[", "'X0'", "]", "[", "1", "]", "+", "scores", "[", "'X1'", "]", "[", "1", "]", "+", "scores", "[", "'X2'", "]", "[", "1", "]", "+", "scores", "[", "'X3'", "]", "[", "1", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "1", "]", ")", ",", "abs", "=", "0.4", ")", "\n", "assert", "scores", "[", "'X0'", "]", "[", "2", "]", "+", "scores", "[", "'X1'", "]", "[", "2", "]", "+", "scores", "[", "'X2'", "]", "[", "2", "]", "+", "scores", "[", "'X3'", "]", "[", "2", "]", "==", "approx", "(", "total_anomaly_score", "(", "training_data", ",", "anomaly_data", "[", "'X3'", "]", ".", "to_numpy", "(", ")", "[", "2", "]", ")", ",", "abs", "=", "0.6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_anomaly_attribution.test_relative_frequency": [[315, 317], ["numpy.abs", "dowhy.gcm.anomaly._relative_frequency", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.anomaly._relative_frequency"], ["", "def", "test_relative_frequency", "(", ")", ":", "\n", "    ", "assert", "np", ".", "abs", "(", "_relative_frequency", "(", "np", ".", "array", "(", "[", "True", ",", "True", ",", "False", ",", "True", "]", ")", ")", "-", "4", "/", "5", ")", "<", "0.1", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_intrinsic_influence.test_intrinsic_causal_influence_variance_linear": [[16, 42], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "dowhy.gcm.intrinsic_causal_influence", "dowhy.gcm.intrinsic_causal_influence", "networkx.DiGraph", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "dowhy.gcm.uncertainty.estimate_variance", "dowhy.gcm.uncertainty.estimate_variance"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_variance"], ["@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_intrinsic_causal_influence_variance_linear", "(", ")", ":", "\n", "    ", "causal_model", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "X1", "=", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.001", ",", "10000", ")", "\n", "X2", "=", "X1", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "2", ",", "10000", ")", "\n", "X3", "=", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "iccs", "=", "intrinsic_causal_influence", "(", "causal_model", ",", "'X3'", ",", "prediction_model", "=", "'approx'", ")", "\n", "assert", "iccs", "[", "'X0'", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.25", ")", "\n", "assert", "iccs", "[", "'X1'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X2'", "]", "==", "approx", "(", "4", ",", "abs", "=", "0.5", ")", "\n", "assert", "iccs", "[", "'X3'", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.25", ")", "\n", "assert", "np", ".", "sum", "(", "[", "iccs", "[", "key", "]", "for", "key", "in", "iccs", "]", ")", "==", "approx", "(", "estimate_variance", "(", "X3", ")", ",", "abs", "=", "0.5", ")", "\n", "\n", "iccs", "=", "intrinsic_causal_influence", "(", "causal_model", ",", "'X3'", ",", "prediction_model", "=", "'exact'", ")", "\n", "assert", "iccs", "[", "'X0'", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.25", ")", "\n", "assert", "iccs", "[", "'X1'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X2'", "]", "==", "approx", "(", "4", ",", "abs", "=", "0.5", ")", "\n", "assert", "iccs", "[", "'X3'", "]", "==", "approx", "(", "1", ",", "abs", "=", "0.25", ")", "\n", "assert", "np", ".", "sum", "(", "[", "iccs", "[", "key", "]", "for", "key", "in", "iccs", "]", ")", "==", "approx", "(", "estimate_variance", "(", "X3", ")", ",", "abs", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_intrinsic_influence.test_intrinsic_causal_influence_categorical": [[44, 83], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "dowhy.gcm.intrinsic_causal_influence", "dowhy.gcm.intrinsic_causal_influence", "networkx.DiGraph", "numpy.column_stack", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "sklearn.linear_model.LogisticRegression.predict_proba", "numpy.array", "numpy.column_stack"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_intrinsic_causal_influence_categorical", "(", ")", ":", "\n", "    ", "causal_model", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "\n", "N1", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "0.001", ",", "10000", ")", "\n", "N2", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "2", ",", "10000", ")", "\n", "N3", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "X1", "=", "X0", "+", "N1", "\n", "X2", "=", "X1", "+", "N2", "\n", "X3", "=", "(", "(", "X2", "+", "N3", ")", ">=", "0", ")", ".", "astype", "(", "str", ")", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", "}", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "log_mdl", "=", "LogisticRegression", "(", "max_iter", "=", "1000", ")", "\n", "log_mdl", ".", "fit", "(", "np", ".", "column_stack", "(", "[", "X0", ",", "N1", ",", "N2", ",", "N3", "]", ")", ",", "X3", ")", "\n", "\n", "expected_output_full_subset", "=", "-", "estimate_entropy_of_probabilities", "(", "log_mdl", ".", "predict_proba", "(", "np", ".", "column_stack", "(", "[", "X0", ",", "N1", ",", "N2", ",", "N3", "]", ")", ")", ")", "\n", "expected_output_empty_subset", "=", "-", "estimate_entropy_of_probabilities", "(", "np", ".", "array", "(", "[", "[", "0.5", ",", "0.5", "]", "]", ")", ")", "\n", "\n", "iccs", "=", "intrinsic_causal_influence", "(", "causal_model", ",", "'X3'", ",", "prediction_model", "=", "'approx'", ",", "num_samples_baseline", "=", "100", ")", "\n", "assert", "iccs", "[", "'X0'", "]", "==", "approx", "(", "0.14", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X1'", "]", "==", "approx", "(", "0.01", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X2'", "]", "==", "approx", "(", "0.38", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X3'", "]", "==", "approx", "(", "0.12", ",", "abs", "=", "0.05", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "[", "iccs", "[", "key", "]", "for", "key", "in", "iccs", "]", ")", "==", "approx", "(", "expected_output_full_subset", "-", "expected_output_empty_subset", ",", "\n", "abs", "=", "0.05", ")", "\n", "\n", "iccs", "=", "intrinsic_causal_influence", "(", "causal_model", ",", "'X3'", ",", "prediction_model", "=", "'exact'", ",", "num_samples_baseline", "=", "100", ")", "\n", "assert", "iccs", "[", "'X0'", "]", "==", "approx", "(", "0.14", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X1'", "]", "==", "approx", "(", "0.01", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X2'", "]", "==", "approx", "(", "0.38", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X3'", "]", "==", "approx", "(", "0.12", ",", "abs", "=", "0.05", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "[", "iccs", "[", "key", "]", "for", "key", "in", "iccs", "]", ")", "==", "approx", "(", "-", "expected_output_empty_subset", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_intrinsic_influence.test_intrinsic_causal_influence_categorical_2": [[85, 138], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "range", "numpy.array", "pandas.DataFrame", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "dowhy.gcm._noise.noise_samples_of_ancestors", "dowhy.gcm.util.general.apply_one_hot_encoding", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "dowhy.gcm.intrinsic_causal_influence", "dowhy.gcm.intrinsic_causal_influence", "networkx.DiGraph", "numpy.random.choice().squeeze", "dowhy.gcm.StructuralCausalModel", "noise_samples.to_numpy", "dowhy.gcm.util.general.fit_one_hot_encoders", "data_samples[].to_numpy", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "np.array.append", "np.array.reshape", "dowhy.gcm.graph.node_connected_subgraph_view", "noise_samples.to_numpy", "sklearn.linear_model.LogisticRegression.predict_proba", "numpy.array", "numpy.random.choice", "np.array.append", "np.array.append", "numpy.median", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.noise_samples_of_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_intrinsic_causal_influence_categorical_2", "(", ")", ":", "\n", "    ", "causal_model", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "N1", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "0.001", ",", "10000", ")", "\n", "N2", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "2", ",", "10000", ")", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "X1", "=", "X0", "+", "N1", "\n", "X2", "=", "X1", "+", "N2", "\n", "\n", "X3", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "10000", ")", ":", "\n", "        ", "rand_val", "=", "np", ".", "random", ".", "choice", "(", "3", ",", "1", ")", ".", "squeeze", "(", ")", "\n", "if", "rand_val", "==", "0", ":", "\n", "            ", "X3", ".", "append", "(", "X2", "[", "i", "]", "+", "np", ".", "random", ".", "normal", "(", "-", "5", ",", "0.5", ",", "1", ")", ")", "\n", "", "elif", "rand_val", "==", "1", ":", "\n", "            ", "X3", ".", "append", "(", "X2", "[", "i", "]", "+", "np", ".", "random", ".", "normal", "(", "10", ",", "0.5", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "X3", ".", "append", "(", "X2", "[", "i", "]", "+", "np", ".", "random", ".", "normal", "(", "5", ",", "0.5", ",", "1", ")", ")", "\n", "\n", "", "", "X3", "=", "np", ".", "array", "(", "X3", ")", "\n", "X3", "=", "(", "X3", ">", "np", ".", "median", "(", "X3", ")", ")", ".", "astype", "(", "str", ")", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", ",", "'X2'", ":", "X2", ",", "'X3'", ":", "X3", ".", "reshape", "(", "-", "1", ")", "}", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "data_samples", ",", "noise_samples", "=", "noise_samples_of_ancestors", "(", "\n", "StructuralCausalModel", "(", "node_connected_subgraph_view", "(", "causal_model", ".", "graph", ",", "'X3'", ")", ")", ",", "\n", "'X3'", ",", "\n", "100000", ")", "\n", "X", "=", "apply_one_hot_encoding", "(", "noise_samples", ".", "to_numpy", "(", ")", ",", "fit_one_hot_encoders", "(", "noise_samples", ".", "to_numpy", "(", ")", ")", ")", "\n", "log_mdl", "=", "LogisticRegression", "(", ")", "\n", "log_mdl", ".", "fit", "(", "X", ",", "data_samples", "[", "'X3'", "]", ".", "to_numpy", "(", ")", ")", "\n", "\n", "expected_output_full_subset", "=", "-", "estimate_entropy_of_probabilities", "(", "log_mdl", ".", "predict_proba", "(", "X", ")", ")", "\n", "expected_output_empty_subset", "=", "-", "estimate_entropy_of_probabilities", "(", "np", ".", "array", "(", "[", "[", "0.5", ",", "0.5", "]", "]", ")", ")", "\n", "\n", "iccs", "=", "intrinsic_causal_influence", "(", "causal_model", ",", "'X3'", ",", "prediction_model", "=", "'approx'", ",", "num_samples_baseline", "=", "100", ")", "\n", "assert", "iccs", "[", "'X0'", "]", "==", "approx", "(", "0.05", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X1'", "]", "==", "approx", "(", "0.03", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X2'", "]", "==", "approx", "(", "0.1", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X3'", "]", "==", "approx", "(", "0.5", ",", "abs", "=", "0.05", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "[", "iccs", "[", "key", "]", "for", "key", "in", "iccs", "]", ")", "==", "approx", "(", "expected_output_full_subset", "-", "expected_output_empty_subset", ",", "\n", "abs", "=", "0.05", ")", "\n", "\n", "iccs", "=", "intrinsic_causal_influence", "(", "causal_model", ",", "'X3'", ",", "prediction_model", "=", "'exact'", ",", "num_samples_baseline", "=", "100", ")", "\n", "assert", "iccs", "[", "'X0'", "]", "==", "approx", "(", "0.05", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X1'", "]", "==", "approx", "(", "0.03", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X2'", "]", "==", "approx", "(", "0.1", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X3'", "]", "==", "approx", "(", "0.5", ",", "abs", "=", "0.05", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "[", "iccs", "[", "key", "]", "for", "key", "in", "iccs", "]", ")", "==", "approx", "(", "-", "expected_output_empty_subset", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_intrinsic_influence.test_given_only_categorical_data_when_estimate_icc_then_does_not_fail": [[140, 180], ["flaky.flaky", "dowhy.gcm.StructuralCausalModel", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "dowhy.gcm._noise.noise_samples_of_ancestors", "dowhy.gcm.util.general.apply_one_hot_encoding", "dowhy.gcm.ml.create_hist_gradient_boost_classifier", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.fit", "dowhy.gcm.intrinsic_causal_influence", "dowhy.gcm.intrinsic_causal_influence", "networkx.DiGraph", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.StructuralCausalModel", "noise_samples.to_numpy", "dowhy.gcm.util.general.fit_one_hot_encoders", "data_samples[].to_numpy", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "numpy.sum", "pytest.approx", "dowhy.gcm.graph.node_connected_subgraph_view", "noise_samples.to_numpy", "dowhy.gcm.ml.create_hist_gradient_boost_classifier.predict_probabilities", "numpy.array", "numpy.random.normal"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm._noise.noise_samples_of_ancestors", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.uncertainty.estimate_entropy_of_probabilities", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.node_connected_subgraph_view", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_only_categorical_data_when_estimate_icc_then_does_not_fail", "(", ")", ":", "\n", "    ", "causal_model", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", ",", "(", "'X1'", ",", "'X2'", ")", ",", "(", "'X2'", ",", "'X3'", ")", "]", ")", ")", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "X1", "=", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.001", ",", "10000", ")", "\n", "X2", "=", "X1", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "2", ",", "10000", ")", "\n", "X3", "=", "(", "(", "X2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", ")", ">=", "0", ")", ".", "astype", "(", "str", ")", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "(", "X0", ">=", "0", ")", ".", "astype", "(", "str", ")", ",", "\n", "'X1'", ":", "(", "X1", ">=", "0", ")", ".", "astype", "(", "str", ")", ",", "\n", "'X2'", ":", "(", "X2", ">=", "0", ")", ".", "astype", "(", "str", ")", ",", "\n", "'X3'", ":", "X3", "}", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "data_samples", ",", "noise_samples", "=", "noise_samples_of_ancestors", "(", "\n", "StructuralCausalModel", "(", "node_connected_subgraph_view", "(", "causal_model", ".", "graph", ",", "'X3'", ")", ")", ",", "'X3'", ",", "100000", ")", "\n", "X", "=", "apply_one_hot_encoding", "(", "noise_samples", ".", "to_numpy", "(", ")", ",", "fit_one_hot_encoders", "(", "noise_samples", ".", "to_numpy", "(", ")", ")", ")", "\n", "log_mdl", "=", "create_hist_gradient_boost_classifier", "(", ")", "# Due to the categorical features, this becomes non-linear.", "\n", "log_mdl", ".", "fit", "(", "X", ",", "data_samples", "[", "'X3'", "]", ".", "to_numpy", "(", ")", ")", "\n", "\n", "expected_output_full_subset", "=", "-", "estimate_entropy_of_probabilities", "(", "log_mdl", ".", "predict_probabilities", "(", "X", ")", ")", "\n", "expected_output_empty_subset", "=", "-", "estimate_entropy_of_probabilities", "(", "np", ".", "array", "(", "[", "[", "0.5", ",", "0.5", "]", "]", ")", ")", "\n", "\n", "iccs", "=", "intrinsic_causal_influence", "(", "causal_model", ",", "'X3'", ",", "prediction_model", "=", "'approx'", ",", "num_samples_baseline", "=", "100", ")", "\n", "assert", "iccs", "[", "'X0'", "]", "==", "approx", "(", "0.08", ",", "abs", "=", "0.03", ")", "\n", "assert", "iccs", "[", "'X1'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.005", ")", "\n", "assert", "iccs", "[", "'X2'", "]", "==", "approx", "(", "0.33", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X3'", "]", "==", "approx", "(", "0.27", ",", "abs", "=", "0.05", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "[", "iccs", "[", "key", "]", "for", "key", "in", "iccs", "]", ")", "==", "approx", "(", "expected_output_full_subset", "-", "expected_output_empty_subset", ",", "\n", "abs", "=", "0.05", ")", "\n", "\n", "iccs", "=", "intrinsic_causal_influence", "(", "causal_model", ",", "'X3'", ",", "prediction_model", "=", "'exact'", ",", "num_samples_baseline", "=", "100", ")", "\n", "assert", "iccs", "[", "'X0'", "]", "==", "approx", "(", "0.08", ",", "abs", "=", "0.03", ")", "\n", "assert", "iccs", "[", "'X1'", "]", "==", "approx", "(", "0", ",", "abs", "=", "0.005", ")", "\n", "assert", "iccs", "[", "'X2'", "]", "==", "approx", "(", "0.33", ",", "abs", "=", "0.05", ")", "\n", "assert", "iccs", "[", "'X3'", "]", "==", "approx", "(", "0.27", ",", "abs", "=", "0.05", ")", "\n", "\n", "assert", "np", ".", "sum", "(", "[", "iccs", "[", "key", "]", "for", "key", "in", "iccs", "]", ")", "==", "approx", "(", "-", "expected_output_empty_subset", ",", "abs", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_intrinsic_influence.test_when_calling_intrinsic_causal_influence_then_the_shape_of_inputs_in_the_attribution_function_should_be_equal": [[182, 196], ["dowhy.gcm.StructuralCausalModel", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "dowhy.gcm.intrinsic_causal_influence", "networkx.DiGraph", "numpy.random.normal", "numpy.all"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.influence.intrinsic_causal_influence"], ["", "def", "test_when_calling_intrinsic_causal_influence_then_the_shape_of_inputs_in_the_attribution_function_should_be_equal", "(", ")", ":", "\n", "    ", "causal_model", "=", "StructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X0'", ",", "'X1'", ")", "]", ")", ")", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "X1", "=", "X0", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "0.001", ",", "10000", ")", "\n", "training_data", "=", "pd", ".", "DataFrame", "(", "{", "'X0'", ":", "X0", ",", "'X1'", ":", "X1", "}", ")", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "training_data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "training_data", ")", "\n", "\n", "def", "my_attr_func", "(", "X", ",", "Y", ")", ":", "\n", "        ", "assert", "np", ".", "all", "(", "X", ".", "shape", "==", "Y", ".", "shape", ")", "\n", "return", "0", "\n", "\n", "", "intrinsic_causal_influence", "(", "causal_model", ",", "'X1'", ",", "attribution_func", "=", "my_attr_func", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation._generate_simple_non_linear_data": [[10, 16], ["numpy.random.normal", "pandas.DataFrame", "numpy.random.normal", "numpy.exp", "numpy.random.normal", "dict"], "function", ["None"], ["def", "_generate_simple_non_linear_data", "(", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0", ",", "scale", "=", "1", ",", "size", "=", "5000", ")", "\n", "Y", "=", "X", "**", "2", "+", "np", ".", "random", ".", "normal", "(", "loc", "=", "0", ",", "scale", "=", "1", ",", "size", "=", "5000", ")", "\n", "Z", "=", "np", ".", "exp", "(", "-", "Y", ")", "+", "np", ".", "random", ".", "normal", "(", "loc", "=", "0", ",", "scale", "=", "1", ",", "size", "=", "5000", ")", "\n", "\n", "return", "pd", ".", "DataFrame", "(", "data", "=", "dict", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "Z", "=", "Z", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_refute_causal_structure_collider": [[18, 36], ["flaky.flaky", "networkx.DiGraph", "numpy.random.normal", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.refute_causal_structure", "numpy.random.normal", "dict", "dict", "dict", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_causal_structure"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_refute_causal_structure_collider", "(", ")", ":", "\n", "# collider: X->Z<-Y", "\n", "    ", "collider_dag", "=", "nx", ".", "DiGraph", "(", "[", "(", "'X'", ",", "'Z'", ")", ",", "(", "'Y'", ",", "'Z'", ")", "]", ")", "\n", "X", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "Z", "=", "2", "*", "X", "+", "3", "*", "Y", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "data", "=", "dict", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "Z", "=", "Z", ")", ")", "\n", "rejection_result", ",", "rejection_summary", "=", "refute_causal_structure", "(", "collider_dag", ",", "data", ")", "\n", "\n", "assert", "rejection_result", "==", "RejectionResult", ".", "NOT_REJECTED", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'edge_dependence_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'edge_dependence_test'", "]", "[", "'X'", "]", "[", "'success'", "]", "==", "True", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'edge_dependence_test'", "]", "[", "'Y'", "]", "[", "'success'", "]", "==", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_refute_causal_structure_chain": [[38, 55], ["flaky.flaky", "networkx.DiGraph", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.refute_causal_structure", "numpy.random.normal", "numpy.random.normal", "dict", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_causal_structure"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_refute_causal_structure_chain", "(", ")", ":", "\n", "# chain: X->Z->Y", "\n", "    ", "chain_dag", "=", "nx", ".", "DiGraph", "(", "[", "(", "'X'", ",", "'Z'", ")", ",", "(", "'Z'", ",", "'Y'", ")", "]", ")", "\n", "X", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "Z", "=", "2", "*", "X", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "Y", "=", "3", "*", "Z", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "data", "=", "dict", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "Z", "=", "Z", ")", ")", "\n", "rejection_result", ",", "rejection_summary", "=", "refute_causal_structure", "(", "chain_dag", ",", "data", ")", "\n", "\n", "assert", "rejection_result", "==", "RejectionResult", ".", "NOT_REJECTED", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'edge_dependence_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'edge_dependence_test'", "]", "[", "'X'", "]", "[", "'success'", "]", "==", "True", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'local_markov_test'", "]", "[", "'success'", "]", "==", "True", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'success'", "]", "==", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_refute_causal_structure_fork": [[57, 74], ["flaky.flaky", "networkx.DiGraph", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.refute_causal_structure", "numpy.random.normal", "numpy.random.normal", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_causal_structure"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_refute_causal_structure_fork", "(", ")", ":", "\n", "# fork: X<-Z->Y", "\n", "    ", "fork_dag", "=", "nx", ".", "DiGraph", "(", "[", "(", "'Z'", ",", "'X'", ")", ",", "(", "'Z'", ",", "'Y'", ")", "]", ")", "\n", "Z", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "X", "=", "2", "*", "Z", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "Y", "=", "3", "*", "Z", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "data", "=", "dict", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "Z", "=", "Z", ")", ")", "\n", "rejection_result", ",", "rejection_summary", "=", "refute_causal_structure", "(", "fork_dag", ",", "data", ")", "\n", "\n", "assert", "rejection_result", "==", "RejectionResult", ".", "NOT_REJECTED", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'edge_dependence_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'local_markov_test'", "]", "[", "'success'", "]", "==", "True", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'success'", "]", "==", "True", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'local_markov_test'", "]", "[", "'success'", "]", "==", "True", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'success'", "]", "==", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_refute_causal_structure_general": [[76, 94], ["flaky.flaky", "networkx.DiGraph", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.refute_causal_structure", "numpy.random.normal", "numpy.random.normal", "dict", "dict", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_causal_structure"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_refute_causal_structure_general", "(", ")", ":", "\n", "# general DAG: X<-Z->Y, X->Y", "\n", "    ", "general_dag", "=", "nx", ".", "DiGraph", "(", "[", "(", "'Z'", ",", "'X'", ")", ",", "(", "'Z'", ",", "'Y'", ")", ",", "(", "'X'", ",", "'Y'", ")", "]", ")", "\n", "Z", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "X", "=", "2", "*", "Z", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "Y", "=", "2", "*", "Z", "+", "3", "*", "X", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "data", "=", "dict", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "Z", "=", "Z", ")", ")", "\n", "rejection_result", ",", "rejection_summary", "=", "refute_causal_structure", "(", "general_dag", ",", "data", ")", "\n", "\n", "assert", "rejection_result", "==", "RejectionResult", ".", "NOT_REJECTED", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Z'", "]", "[", "'edge_dependence_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'success'", "]", "==", "True", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'local_markov_test'", "]", "==", "dict", "(", ")", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'success'", "]", "==", "True", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "[", "'X'", "]", "[", "'success'", "]", "==", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_refute_causal_structure_adjusted_p_values": [[96, 114], ["flaky.flaky", "networkx.DiGraph", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.refute_causal_structure", "numpy.random.normal", "numpy.random.normal", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_causal_structure"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_refute_causal_structure_adjusted_p_values", "(", ")", ":", "\n", "# fork: X<-Z->Y", "\n", "    ", "fork_dag", "=", "nx", ".", "DiGraph", "(", "[", "(", "'Z'", ",", "'X'", ")", ",", "(", "'Z'", ",", "'Y'", ")", "]", ")", "\n", "Z", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "X", "=", "2", "*", "Z", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "Y", "=", "3", "*", "Z", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "data", "=", "dict", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "Z", "=", "Z", ")", ")", "\n", "rejection_result", ",", "rejection_summary", "=", "refute_causal_structure", "(", "fork_dag", ",", "data", ",", "fdr_control_method", "=", "'fdr_bh'", ")", "\n", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'local_markov_test'", "]", "[", "'fdr_adjusted_p_value'", "]", ">=", "rejection_summary", "[", "'X'", "]", "[", "'local_markov_test'", "]", "[", "'p_value'", "]", "\n", "assert", "rejection_summary", "[", "'X'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'fdr_adjusted_p_value'", "]", ">=", "rejection_summary", "[", "'X'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'p_value'", "]", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'local_markov_test'", "]", "[", "'fdr_adjusted_p_value'", "]", ">=", "rejection_summary", "[", "'Y'", "]", "[", "'local_markov_test'", "]", "[", "'p_value'", "]", "\n", "assert", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'fdr_adjusted_p_value'", "]", ">=", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'p_value'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_when_using_refute_causal_structure_without_fdrc_then_nans_for_adjusted_p_values_are_returned": [[116, 133], ["networkx.DiGraph", "numpy.random.normal", "pandas.DataFrame", "dowhy.gcm.refute_causal_structure", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.random.normal", "numpy.random.normal", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan", "dict"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_causal_structure"], ["", "def", "test_when_using_refute_causal_structure_without_fdrc_then_nans_for_adjusted_p_values_are_returned", "(", ")", ":", "\n", "    ", "fork_dag", "=", "nx", ".", "DiGraph", "(", "[", "(", "'Z'", ",", "'X'", ")", ",", "(", "'Z'", ",", "'Y'", ")", "]", ")", "\n", "Z", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "X", "=", "2", "*", "Z", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "Y", "=", "3", "*", "Z", "+", "np", ".", "random", ".", "normal", "(", "size", "=", "500", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "data", "=", "dict", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "Z", "=", "Z", ")", ")", "\n", "_", ",", "rejection_summary", "=", "refute_causal_structure", "(", "fork_dag", ",", "data", ",", "fdr_control_method", "=", "None", ")", "\n", "\n", "assert", "np", ".", "isnan", "(", "rejection_summary", "[", "'X'", "]", "[", "'local_markov_test'", "]", "[", "'fdr_adjusted_p_value'", "]", ")", "\n", "assert", "np", ".", "isnan", "(", "rejection_summary", "[", "'X'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'fdr_adjusted_p_value'", "]", ")", "\n", "assert", "np", ".", "isnan", "(", "rejection_summary", "[", "'Y'", "]", "[", "'local_markov_test'", "]", "[", "'fdr_adjusted_p_value'", "]", ")", "\n", "assert", "np", ".", "isnan", "(", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'fdr_adjusted_p_value'", "]", ")", "\n", "\n", "assert", "not", "np", ".", "isnan", "(", "rejection_summary", "[", "'X'", "]", "[", "'local_markov_test'", "]", "[", "'p_value'", "]", ")", "\n", "assert", "not", "np", ".", "isnan", "(", "rejection_summary", "[", "'X'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'p_value'", "]", ")", "\n", "assert", "not", "np", ".", "isnan", "(", "rejection_summary", "[", "'Y'", "]", "[", "'local_markov_test'", "]", "[", "'p_value'", "]", ")", "\n", "assert", "not", "np", ".", "isnan", "(", "rejection_summary", "[", "'Y'", "]", "[", "'edge_dependence_test'", "]", "[", "'Z'", "]", "[", "'p_value'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_given_non_linear_data_and_correct_dag_when_refute_invertible_model_then_not_reject_model": [[135, 153], ["flaky.flaky", "test_validation._generate_simple_non_linear_data", "dowhy.gcm.InvertibleStructuralCausalModel", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "networkx.DiGraph", "dowhy.gcm.refute_invertible_model", "dowhy.gcm.refute_invertible_model", "dowhy.gcm.kernel_based", "dowhy.gcm.kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation._generate_simple_non_linear_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_invertible_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_invertible_model", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_non_linear_data_and_correct_dag_when_refute_invertible_model_then_not_reject_model", "(", ")", ":", "\n", "    ", "data", "=", "_generate_simple_non_linear_data", "(", ")", "\n", "\n", "causal_model", "=", "InvertibleStructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X'", ",", "'Y'", ")", ",", "(", "'Y'", ",", "'Z'", ")", "]", ")", ")", "# X->Y->Z", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "data", ")", "\n", "\n", "assert", "refute_invertible_model", "(", "causal_model", ",", "\n", "data", ",", "\n", "independence_test", "=", "lambda", "x", ",", "y", ":", "kernel_based", "(", "x", ",", "y", ",", "bootstrap_num_runs", "=", "5", ")", ")", "==", "RejectionResult", ".", "NOT_REJECTED", "\n", "assert", "refute_invertible_model", "(", "causal_model", ",", "\n", "data", ",", "\n", "independence_test", "=", "lambda", "x", ",", "y", ":", "kernel_based", "(", "x", ",", "y", ",", "bootstrap_num_runs", "=", "5", ")", ",", "\n", "fdr_control_method", "=", "'fdr_bh'", ")", "==", "RejectionResult", ".", "NOT_REJECTED", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_given_non_linear_data_and_incorrect_dag_when_refute_invertible_model_then_reject_model": [[155, 173], ["flaky.flaky", "test_validation._generate_simple_non_linear_data", "dowhy.gcm.InvertibleStructuralCausalModel", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "networkx.DiGraph", "dowhy.gcm.refute_invertible_model", "dowhy.gcm.refute_invertible_model", "dowhy.gcm.kernel_based", "dowhy.gcm.kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation._generate_simple_non_linear_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_invertible_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_invertible_model", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_non_linear_data_and_incorrect_dag_when_refute_invertible_model_then_reject_model", "(", ")", ":", "\n", "    ", "data", "=", "_generate_simple_non_linear_data", "(", ")", "\n", "\n", "causal_model", "=", "InvertibleStructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'Z'", ",", "'Y'", ")", ",", "(", "'Y'", ",", "'X'", ")", "]", ")", ")", "# X<-Y<-Z", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "data", ")", "\n", "\n", "assert", "refute_invertible_model", "(", "causal_model", ",", "\n", "data", ",", "\n", "independence_test", "=", "lambda", "x", ",", "y", ":", "kernel_based", "(", "x", ",", "y", ",", "bootstrap_num_runs", "=", "5", ")", ")", "==", "RejectionResult", ".", "REJECTED", "\n", "assert", "refute_invertible_model", "(", "causal_model", ",", "\n", "data", ",", "\n", "independence_test", "=", "lambda", "x", ",", "y", ":", "kernel_based", "(", "x", ",", "y", ",", "bootstrap_num_runs", "=", "5", ")", ",", "\n", "fdr_control_method", "=", "'fdr_bh'", ")", "==", "RejectionResult", ".", "REJECTED", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation.test_given_non_linear_data_and_incorrect_dag_with_collider_when_refute_invertible_model_then_reject_model": [[175, 192], ["flaky.flaky", "test_validation._generate_simple_non_linear_data", "dowhy.gcm.InvertibleStructuralCausalModel", "dowhy.gcm.auto.assign_causal_mechanisms", "dowhy.gcm.fit", "networkx.DiGraph", "dowhy.gcm.refute_invertible_model", "dowhy.gcm.refute_invertible_model", "dowhy.gcm.kernel_based", "dowhy.gcm.kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_validation._generate_simple_non_linear_data", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.auto.assign_causal_mechanisms", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_invertible_model", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.validation.refute_invertible_model", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_non_linear_data_and_incorrect_dag_with_collider_when_refute_invertible_model_then_reject_model", "(", ")", ":", "\n", "    ", "data", "=", "_generate_simple_non_linear_data", "(", ")", "\n", "causal_model", "=", "InvertibleStructuralCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X'", ",", "'Y'", ")", ",", "(", "'Z'", ",", "'Y'", ")", "]", ")", ")", "# X->Y<-Z", "\n", "auto", ".", "assign_causal_mechanisms", "(", "causal_model", ",", "data", ",", "auto", ".", "AssignmentQuality", ".", "GOOD", ")", "\n", "\n", "fit", "(", "causal_model", ",", "data", ")", "\n", "\n", "assert", "refute_invertible_model", "(", "causal_model", ",", "\n", "data", ",", "\n", "independence_test", "=", "lambda", "x", ",", "y", ":", "kernel_based", "(", "x", ",", "y", ",", "bootstrap_num_runs", "=", "10", ")", ")", "==", "RejectionResult", ".", "REJECTED", "\n", "assert", "refute_invertible_model", "(", "causal_model", ",", "\n", "data", ",", "\n", "independence_test", "=", "lambda", "x", ",", "y", ":", "kernel_based", "(", "x", ",", "y", ",", "bootstrap_num_runs", "=", "10", ")", ",", "\n", "fdr_control_method", "=", "'fdr_bh'", ")", "==", "RejectionResult", ".", "REJECTED", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_divergence.test_estimate_kl_divergence_continuous": [[9, 16], ["flaky.flaky", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.divergence.estimate_kl_divergence_continuous", "pytest.approx", "dowhy.gcm.divergence.estimate_kl_divergence_continuous", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_continuous", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_continuous"], ["@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_estimate_kl_divergence_continuous", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "1", ",", "1", ",", "10000", ")", "\n", "\n", "assert", "estimate_kl_divergence_continuous", "(", "X", ",", "X", ")", "==", "approx", "(", "0", ",", "abs", "=", "0.001", ")", "\n", "assert", "estimate_kl_divergence_continuous", "(", "X", ",", "Y", ")", "==", "approx", "(", "0.5", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_divergence.test_estimate_kl_divergence_categorical": [[18, 26], ["flaky.flaky", "numpy.random.choice().astype", "numpy.random.choice().astype", "dowhy.gcm.divergence.estimate_kl_divergence_categorical", "pytest.approx", "dowhy.gcm.divergence.estimate_kl_divergence_categorical", "pytest.approx", "numpy.random.choice", "numpy.random.choice", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_categorical", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_categorical"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_estimate_kl_divergence_categorical", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "choice", "(", "4", ",", "1000", ",", "replace", "=", "True", ",", "p", "=", "[", "0.25", ",", "0.5", ",", "0.125", ",", "0.125", "]", ")", ".", "astype", "(", "str", ")", "\n", "Y", "=", "np", ".", "random", ".", "choice", "(", "4", ",", "1000", ",", "replace", "=", "True", ",", "p", "=", "[", "0.5", ",", "0.25", ",", "0.125", ",", "0.125", "]", ")", ".", "astype", "(", "str", ")", "\n", "\n", "assert", "estimate_kl_divergence_categorical", "(", "X", ",", "X", ")", "==", "approx", "(", "0", ")", "\n", "assert", "estimate_kl_divergence_categorical", "(", "X", ",", "Y", ")", "==", "approx", "(", "0.25", "*", "np", ".", "log", "(", "0.25", "/", "0.5", ")", "+", "0.5", "*", "np", ".", "log", "(", "0.5", "/", "0.25", ")", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_divergence.test_estimate_kl_divergence_of_probabilities": [[28, 33], ["dowhy.gcm.divergence.estimate_kl_divergence_of_probabilities", "pytest.approx", "numpy.array", "numpy.array", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.estimate_kl_divergence_of_probabilities"], ["", "def", "test_estimate_kl_divergence_of_probabilities", "(", ")", ":", "\n", "    ", "assert", "estimate_kl_divergence_of_probabilities", "(", "\n", "np", ".", "array", "(", "[", "[", "0.25", ",", "0.5", ",", "0.125", ",", "0.125", "]", ",", "[", "0.5", ",", "0.25", ",", "0.125", ",", "0.125", "]", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.5", ",", "0.25", ",", "0.125", ",", "0.125", "]", ",", "[", "0.25", ",", "0.5", ",", "0.125", ",", "0.125", "]", "]", ")", ")", "==", "approx", "(", "0.25", "*", "np", ".", "log", "(", "0.25", "/", "0.5", ")", "+", "0.5", "*", "np", ".", "log", "(", "0.5", "/", "0.25", ")", ",", "abs", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_divergence.test_auto_estimate_kl_divergence_continuous": [[35, 42], ["flaky.flaky", "numpy.random.normal", "numpy.random.normal", "dowhy.gcm.divergence.auto_estimate_kl_divergence", "pytest.approx", "dowhy.gcm.divergence.auto_estimate_kl_divergence", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.auto_estimate_kl_divergence", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.auto_estimate_kl_divergence"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_auto_estimate_kl_divergence_continuous", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "10000", ")", "\n", "Y", "=", "np", ".", "random", ".", "normal", "(", "1", ",", "1", ",", "10000", ")", "\n", "\n", "assert", "auto_estimate_kl_divergence", "(", "X", ",", "X", ")", "==", "approx", "(", "0", ",", "abs", "=", "0.001", ")", "\n", "assert", "auto_estimate_kl_divergence", "(", "X", ",", "Y", ")", "==", "approx", "(", "0.5", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_divergence.test_auto_estimate_kl_divergence_categorical": [[44, 52], ["flaky.flaky", "numpy.random.choice().astype", "numpy.random.choice().astype", "dowhy.gcm.divergence.auto_estimate_kl_divergence", "pytest.approx", "dowhy.gcm.divergence.auto_estimate_kl_divergence", "pytest.approx", "numpy.random.choice", "numpy.random.choice", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.auto_estimate_kl_divergence", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.auto_estimate_kl_divergence"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_auto_estimate_kl_divergence_categorical", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "choice", "(", "4", ",", "1000", ",", "replace", "=", "True", ",", "p", "=", "[", "0.25", ",", "0.5", ",", "0.125", ",", "0.125", "]", ")", ".", "astype", "(", "str", ")", "\n", "Y", "=", "np", ".", "random", ".", "choice", "(", "4", ",", "1000", ",", "replace", "=", "True", ",", "p", "=", "[", "0.5", ",", "0.25", ",", "0.125", ",", "0.125", "]", ")", ".", "astype", "(", "str", ")", "\n", "\n", "assert", "auto_estimate_kl_divergence", "(", "X", ",", "X", ")", "==", "approx", "(", "0", ")", "\n", "assert", "auto_estimate_kl_divergence", "(", "X", ",", "Y", ")", "==", "approx", "(", "0.25", "*", "np", ".", "log", "(", "0.25", "/", "0.5", ")", "+", "0.5", "*", "np", ".", "log", "(", "0.5", "/", "0.25", ")", ",", "abs", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_divergence.test_auto_estimate_kl_divergence_probabilities": [[54, 59], ["dowhy.gcm.divergence.auto_estimate_kl_divergence", "pytest.approx", "numpy.array", "numpy.array", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.divergence.auto_estimate_kl_divergence"], ["", "def", "test_auto_estimate_kl_divergence_probabilities", "(", ")", ":", "\n", "    ", "assert", "auto_estimate_kl_divergence", "(", "\n", "np", ".", "array", "(", "[", "[", "0.25", ",", "0.5", ",", "0.125", ",", "0.125", "]", ",", "[", "0.5", ",", "0.25", ",", "0.125", ",", "0.125", "]", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.5", ",", "0.25", ",", "0.125", ",", "0.125", "]", ",", "[", "0.25", ",", "0.5", ",", "0.125", ",", "0.125", "]", "]", ")", ")", "==", "approx", "(", "0.25", "*", "np", ".", "log", "(", "0.25", "/", "0.5", ")", "+", "0.5", "*", "np", ".", "log", "(", "0.5", "/", "0.25", ")", ",", "abs", "=", "0.01", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_confidence_intervals_cms.test_given_causal_graph_based_estimation_func_when_confidence_interval_then_can_use_bootstrap_training_and_sampling": [[13, 34], ["flaky.flaky", "dowhy.gcm.ProbabilisticCausalModel", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.ProbabilisticCausalModel.set_causal_mechanism", "dowhy.gcm.confidence_intervals.confidence_intervals", "numpy.allclose", "networkx.DiGraph", "dowhy.gcm.EmpiricalDistribution", "dowhy.gcm.AdditiveNoiseModel", "dowhy.gcm.bootstrap_training_and_sampling", "pytest.approx", "dowhy.gcm.ml.create_hist_gradient_boost_regressor", "dowhy.gcm.draw_samples", "pandas.DataFrame"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.cms.InvertibleStructuralCausalModel.set_causal_mechanism", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals.confidence_intervals", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals_cms.bootstrap_training_and_sampling", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stochastic_models.BayesianGaussianMixtureDistribution.draw_samples"], ["@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_causal_graph_based_estimation_func_when_confidence_interval_then_can_use_bootstrap_training_and_sampling", "(", ")", ":", "\n", "    ", "def", "draw_single_sample", "(", "causal_graph", ",", "variable", ")", ":", "\n", "        ", "return", "draw_samples", "(", "causal_graph", ",", "1", ")", "[", "variable", "]", "[", "0", "]", "\n", "\n", "", "causal_model", "=", "ProbabilisticCausalModel", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X'", ",", "'Y'", ")", "]", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'X'", ",", "EmpiricalDistribution", "(", ")", ")", "\n", "causal_model", ".", "set_causal_mechanism", "(", "'Y'", ",", "AdditiveNoiseModel", "(", "create_hist_gradient_boost_regressor", "(", ")", ")", ")", "\n", "\n", "median", ",", "interval", "=", "confidence_intervals", "(", "\n", "bootstrap_training_and_sampling", "(", "draw_single_sample", ",", "\n", "causal_model", ",", "\n", "bootstrap_training_data", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'X'", ":", "[", "1", ",", "3", ",", "4", ",", "4", ",", "1", ",", "3", ",", "6", ",", "3", ",", "3", ",", "6", ",", "3", ",", "4", "]", ",", "\n", "'Y'", ":", "[", "4", ",", "5", ",", "4", ",", "4", ",", "4", ",", "5", ",", "3", ",", "6", ",", "5", ",", "3", ",", "6", ",", "4", "]", "\n", "}", ")", ",", "\n", "bootstrap_data_subset_size_fraction", "=", "0.5", ",", "\n", "variable", "=", "'X'", ")", ")", "\n", "\n", "assert", "median", "==", "pytest", ".", "approx", "(", "4.", ",", "abs", "=", "1.1", ")", "\n", "assert", "np", ".", "allclose", "(", "interval", ",", "[", "1.", ",", "6.", "]", ",", "atol", "=", "2.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.test_confidence_intervals_cms.test_given_parameterized_estimation_func_when_confidence_interval_then_can_use_bootstrap_sampling_to_bind_parameters": [[36, 49], ["dowhy.gcm.confidence_intervals.confidence_intervals", "numpy.allclose", "dowhy.gcm.bootstrap_sampling", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.confidence_intervals.confidence_intervals"], ["", "def", "test_given_parameterized_estimation_func_when_confidence_interval_then_can_use_bootstrap_sampling_to_bind_parameters", "(", ")", ":", "\n", "    ", "i", "=", "0.0", "\n", "\n", "def", "parameterized_counter", "(", "some_parameter", ")", ":", "\n", "        ", "nonlocal", "i", "\n", "i", "+=", "1.0", "\n", "return", "{", "some_parameter", ":", "i", "}", "\n", "\n", "", "median", ",", "interval", "=", "confidence_intervals", "(", "bootstrap_sampling", "(", "parameterized_counter", ",", "'A'", ")", ",", "\n", "num_bootstrap_resamples", "=", "20", ")", "\n", "\n", "assert", "median", "[", "'A'", "]", "==", "pytest", ".", "approx", "(", "10.5", ")", "\n", "assert", "np", ".", "allclose", "(", "interval", "[", "'A'", "]", ",", "[", "1.95", ",", "19.05", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.pygraphviz._plot_causal_graph_graphviz": [[11, 55], ["causal_graph.edges", "pygraphviz.AGraph", "causal_graph.edges", "pygraphviz.AGraph.layout", "pygraphviz.AGraph.add_node", "os.path.splitext", "pygraphviz.AGraph.draw", "pygraphviz._plot_as_pyplot_figure", "max", "isinstance", "numpy.isinf", "pygraphviz.AGraph.add_edge", "pygraphviz.AGraph.add_edge", "abs", "str", "str", "str", "str", "str", "str", "str", "pygraphviz._calc_arrow_width", "int"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasEdges.edges", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasEdges.edges", "home.repos.pwc.inspect_result.microsoft_dowhy.util.pygraphviz._plot_as_pyplot_figure", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.add_edge", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width"], ["def", "_plot_causal_graph_graphviz", "(", "causal_graph", ":", "nx", ".", "Graph", ",", "\n", "display_causal_strengths", ":", "bool", "=", "True", ",", "\n", "causal_strengths", ":", "Optional", "[", "Dict", "[", "Tuple", "[", "Any", ",", "Any", "]", ",", "float", "]", "]", "=", "None", ",", "\n", "filename", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "display_plot", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "    ", "if", "causal_strengths", "is", "None", ":", "\n", "        ", "causal_strengths", "=", "{", "}", "\n", "\n", "", "max_strength", "=", "0.0", "\n", "for", "(", "source", ",", "target", ",", "strength", ")", "in", "causal_graph", ".", "edges", "(", "data", "=", "\"CAUSAL_STRENGTH\"", ",", "default", "=", "None", ")", ":", "\n", "        ", "if", "(", "source", ",", "target", ")", "not", "in", "causal_strengths", ":", "\n", "            ", "causal_strengths", "[", "(", "source", ",", "target", ")", "]", "=", "strength", "\n", "", "if", "causal_strengths", "[", "(", "source", ",", "target", ")", "]", "is", "not", "None", ":", "\n", "            ", "max_strength", "=", "max", "(", "max_strength", ",", "abs", "(", "causal_strengths", "[", "(", "source", ",", "target", ")", "]", ")", ")", "\n", "\n", "", "", "pygraphviz_graph", "=", "pygraphviz", ".", "AGraph", "(", "directed", "=", "isinstance", "(", "causal_graph", ",", "nx", ".", "DiGraph", ")", ")", "\n", "\n", "for", "node", "in", "causal_graph", ".", "nodes", ":", "\n", "        ", "pygraphviz_graph", ".", "add_node", "(", "node", ")", "\n", "\n", "", "for", "(", "source", ",", "target", ")", "in", "causal_graph", ".", "edges", "(", ")", ":", "\n", "        ", "causal_strength", "=", "causal_strengths", "[", "(", "source", ",", "target", ")", "]", "\n", "if", "causal_strength", "is", "not", "None", ":", "\n", "            ", "if", "np", ".", "isinf", "(", "causal_strength", ")", ":", "\n", "                ", "causal_strength", "=", "10000", "\n", "tmp_label", "=", "'Inf'", "\n", "", "else", ":", "\n", "                ", "tmp_label", "=", "str", "(", "' %s'", "%", "str", "(", "int", "(", "causal_strength", "*", "100", ")", "/", "100", ")", ")", "\n", "\n", "", "pygraphviz_graph", ".", "add_edge", "(", "str", "(", "source", ")", ",", "str", "(", "target", ")", ",", "\n", "label", "=", "tmp_label", "if", "display_causal_strengths", "else", "None", ",", "\n", "penwidth", "=", "str", "(", "_calc_arrow_width", "(", "causal_strength", ",", "max_strength", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "pygraphviz_graph", ".", "add_edge", "(", "str", "(", "source", ")", ",", "str", "(", "target", ")", ")", "\n", "\n", "", "", "pygraphviz_graph", ".", "layout", "(", "prog", "=", "\"dot\"", ")", "\n", "if", "filename", "is", "not", "None", ":", "\n", "        ", "filename", ",", "file_extension", "=", "os", ".", "path", ".", "splitext", "(", "filename", ")", "\n", "if", "file_extension", "==", "''", ":", "\n", "            ", "file_extension", "=", "'.pdf'", "\n", "", "pygraphviz_graph", ".", "draw", "(", "filename", "+", "file_extension", ")", "\n", "\n", "", "if", "display_plot", ":", "\n", "        ", "_plot_as_pyplot_figure", "(", "pygraphviz_graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.pygraphviz._calc_arrow_width": [[57, 59], ["float", "float", "abs"], "function", ["None"], ["", "", "def", "_calc_arrow_width", "(", "strength", ":", "float", ",", "max_strength", ":", "float", ")", ":", "\n", "    ", "return", "0.1", "+", "4.0", "*", "float", "(", "abs", "(", "strength", ")", ")", "/", "float", "(", "max_strength", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.pygraphviz._plot_as_pyplot_figure": [[61, 68], ["tempfile.TemporaryDirectory", "pygraphviz_graph.draw", "matplotlib.image.imread", "matplotlib.pyplot.imshow", "matplotlib.pyplot.axis", "matplotlib.pyplot.show"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show"], ["", "def", "_plot_as_pyplot_figure", "(", "pygraphviz_graph", ":", "pygraphviz", ".", "AGraph", ")", "->", "None", ":", "\n", "    ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmp_dir_name", ":", "\n", "        ", "pygraphviz_graph", ".", "draw", "(", "tmp_dir_name", "+", "os", ".", "sep", "+", "'Graph.png'", ")", "\n", "img", "=", "image", ".", "imread", "(", "tmp_dir_name", "+", "os", ".", "sep", "+", "'Graph.png'", ")", "\n", "pyplot", ".", "imshow", "(", "img", ")", "\n", "pyplot", ".", "axis", "(", "'off'", ")", "\n", "pyplot", ".", "show", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot": [[12, 62], ["_plot_causal_graph_graphviz", "_logger.info", "plotting._plot_causal_graph_networkx", "_logger.info", "plotting._plot_causal_graph_networkx", "str"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.pygraphviz._plot_causal_graph_graphviz", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._plot_causal_graph_networkx", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._plot_causal_graph_networkx"], ["def", "plot", "(", "causal_graph", ":", "nx", ".", "Graph", ",", "\n", "causal_strengths", ":", "Optional", "[", "Dict", "[", "Tuple", "[", "Any", ",", "Any", "]", ",", "float", "]", "]", "=", "None", ",", "\n", "filename", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "display_plot", ":", "bool", "=", "True", ",", "\n", "**", "kwargs", ")", "->", "None", ":", "\n", "    ", "\"\"\"Convenience function to plot causal graphs. This function uses different backends based on what's\n    available on the system. The best result is achieved when using Graphviz as the backend. This requires both\n    the Python pygraphviz package (``pip install pygraphviz``) and the shared system library (e.g. ``brew install\n    graphviz`` or ``apt-get install graphviz``). When graphviz is not available, it will fall back to the\n    networkx backend.\n\n    :param causal_graph: The graph to be plotted\n    :param causal_strengths: An optional dictionary with Edge -> float entries.\n    :param filename: An optional filename if the output should be plotted into a file.\n    :param display_plot: Optionally specify if the plot should be displayed or not (default to True).\n    :param kwargs: Remaining parameters will be passed through to the backend verbatim.\n\n    **Example usage**::\n\n    >>> plot(nx.DiGraph([('X', 'Y')])) # plots X -> Y\n    >>> plot(nx.DiGraph([('X', 'Y')]), causal_strengths={('X', 'Y'): 0.43}) # annotates arrow with 0.43\n    \"\"\"", "\n", "try", ":", "\n", "        ", "from", "dowhy", ".", "gcm", ".", "util", ".", "pygraphviz", "import", "_plot_causal_graph_graphviz", "\n", "try", ":", "\n", "            ", "_plot_causal_graph_graphviz", "(", "causal_graph", ",", "\n", "causal_strengths", "=", "causal_strengths", ",", "\n", "filename", "=", "filename", ",", "\n", "display_plot", "=", "display_plot", ",", "\n", "**", "kwargs", ")", "\n", "", "except", "Exception", "as", "error", ":", "\n", "            ", "_logger", ".", "info", "(", "\"There was an error when trying to plot the graph via graphviz, falling back to networkx \"", "\n", "\"plotting. If graphviz is not installed, consider installing it for better looking plots. The\"", "\n", "\" error is:\"", "+", "str", "(", "error", ")", ")", "\n", "_plot_causal_graph_networkx", "(", "causal_graph", ",", "\n", "causal_strengths", "=", "causal_strengths", ",", "\n", "filename", "=", "filename", ",", "\n", "display_plot", "=", "display_plot", ",", "\n", "**", "kwargs", ")", "\n", "\n", "", "", "except", "ImportError", ":", "\n", "        ", "_logger", ".", "info", "(", "\"Pygraphviz installation not found, falling back to networkx plotting. \"", "\n", "\"For better looking plots, consider installing pygraphviz. Note This requires both the Python \"", "\n", "\"pygraphviz package (``pip install pygraphviz``) and the shared system library (e.g. \"", "\n", "\"``brew install graphviz`` or ``apt-get install graphviz``)\"", ")", "\n", "_plot_causal_graph_networkx", "(", "causal_graph", ",", "\n", "causal_strengths", "=", "causal_strengths", ",", "\n", "filename", "=", "filename", ",", "\n", "display_plot", "=", "display_plot", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot_adjacency_matrix": [[64, 71], ["plotting.plot", "networkx.from_pandas_adjacency", "networkx.DiGraph", "networkx.Graph"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot"], ["", "", "def", "plot_adjacency_matrix", "(", "adjacency_matrix", ":", "pd", ".", "DataFrame", ",", "\n", "is_directed", ":", "bool", ",", "\n", "filename", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "display_plot", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "    ", "plot", "(", "nx", ".", "from_pandas_adjacency", "(", "adjacency_matrix", ",", "nx", ".", "DiGraph", "(", ")", "if", "is_directed", "else", "nx", ".", "Graph", "(", ")", ")", ",", "\n", "display_plot", "=", "display_plot", ",", "\n", "filename", "=", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._plot_causal_graph_networkx": [[73, 131], ["causal_graph.edges", "matplotlib.pyplot.figure", "networkx.draw", "networkx.drawing.nx_pydot.pydot_layout", "networkx.spring_layout", "max", "str().split", "range", "pyplot.figure.savefig", "matplotlib.pyplot.show", "abs", "ValueError", "len", "str", "len", "plotting._calc_arrow_width", "causal_graph.edges"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasEdges.edges", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.graph.HasEdges.edges"], ["", "def", "_plot_causal_graph_networkx", "(", "causal_graph", ":", "nx", ".", "Graph", ",", "\n", "pydot_layout_prog", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "causal_strengths", ":", "Optional", "[", "Dict", "[", "Tuple", "[", "Any", ",", "Any", "]", ",", "float", "]", "]", "=", "None", ",", "\n", "filename", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "display_plot", ":", "bool", "=", "True", ",", "\n", "label_wrap_length", ":", "int", "=", "3", ")", "->", "None", ":", "\n", "    ", "if", "'graph'", "not", "in", "causal_graph", ".", "graph", ":", "\n", "        ", "causal_graph", ".", "graph", "[", "'graph'", "]", "=", "{", "'rankdir'", ":", "'TD'", "}", "\n", "\n", "", "if", "pydot_layout_prog", "is", "not", "None", ":", "\n", "        ", "layout", "=", "nx_pydot", ".", "pydot_layout", "(", "causal_graph", ",", "prog", "=", "pydot_layout_prog", ")", "\n", "", "else", ":", "\n", "        ", "layout", "=", "nx", ".", "spring_layout", "(", "causal_graph", ")", "\n", "\n", "", "if", "causal_strengths", "is", "None", ":", "\n", "        ", "causal_strengths", "=", "{", "}", "\n", "\n", "", "max_strength", "=", "0.0", "\n", "for", "(", "source", ",", "target", ",", "strength", ")", "in", "causal_graph", ".", "edges", "(", "data", "=", "\"CAUSAL_STRENGTH\"", ",", "default", "=", "1", ")", ":", "\n", "        ", "if", "(", "source", ",", "target", ")", "not", "in", "causal_strengths", ":", "\n", "            ", "causal_strengths", "[", "(", "source", ",", "target", ")", "]", "=", "strength", "\n", "", "max_strength", "=", "max", "(", "max_strength", ",", "abs", "(", "causal_strengths", "[", "(", "source", ",", "target", ")", "]", ")", ")", "\n", "\n", "", "for", "edge", "in", "causal_graph", ".", "edges", ":", "\n", "        ", "if", "edge", "[", "0", "]", "==", "edge", "[", "1", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Node %s has a self-cycle, i.e. a node pointing to itself. Plotting self-cycles is \"", "\n", "\"currently only supported for plots using Graphviz! Consider installing the corresponding\"", "\n", "\"requirements.\"", "%", "edge", "[", "0", "]", ")", "\n", "\n", "# Wrapping labels if they are too long", "\n", "", "", "labels", "=", "{", "}", "\n", "for", "node", "in", "causal_graph", ".", "nodes", ":", "\n", "        ", "node_name_splits", "=", "str", "(", "node", ")", ".", "split", "(", "' '", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "node_name_splits", ")", ")", ":", "\n", "            ", "if", "len", "(", "node_name_splits", "[", "i", "-", "1", "]", ")", ">", "label_wrap_length", ":", "\n", "                ", "node_name_splits", "[", "i", "]", "=", "'\\n'", "+", "node_name_splits", "[", "i", "]", "\n", "", "else", ":", "\n", "                ", "node_name_splits", "[", "i", "]", "=", "' '", "+", "node_name_splits", "[", "i", "]", "\n", "\n", "", "", "labels", "[", "node", "]", "=", "''", ".", "join", "(", "node_name_splits", ")", "\n", "\n", "", "figure", "=", "pyplot", ".", "figure", "(", ")", "\n", "nx", ".", "draw", "(", "causal_graph", ",", "\n", "pos", "=", "layout", ",", "\n", "node_color", "=", "'lightblue'", ",", "\n", "linewidths", "=", "0.25", ",", "\n", "labels", "=", "labels", ",", "\n", "font_size", "=", "8", ",", "\n", "font_weight", "=", "'bold'", ",", "\n", "node_size", "=", "2000", ",", "\n", "width", "=", "[", "_calc_arrow_width", "(", "causal_strengths", "[", "(", "s", ",", "t", ")", "]", ",", "max_strength", ")", "\n", "for", "(", "s", ",", "t", ")", "in", "causal_graph", ".", "edges", "(", ")", "]", ")", "\n", "\n", "if", "filename", "is", "not", "None", ":", "\n", "        ", "figure", ".", "savefig", "(", "filename", ")", "\n", "\n", "", "if", "display_plot", ":", "\n", "        ", "pyplot", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width": [[133, 135], ["float", "float", "abs"], "function", ["None"], ["", "", "def", "_calc_arrow_width", "(", "strength", ":", "float", ",", "max_strength", ":", "float", ")", ":", "\n", "    ", "return", "0.2", "+", "4.0", "*", "float", "(", "abs", "(", "strength", ")", ")", "/", "float", "(", "max_strength", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d": [[13, 40], ["general.shape_into_2d.shaping"], "function", ["None"], ["def", "shape_into_2d", "(", "*", "args", ")", ":", "\n", "    ", "\"\"\"If necessary, shapes the numpy inputs into 2D matrices.\n\n    Example:\n        array([1, 2, 3]) -> array([[1], [2], [3]])\n        2 -> array([[2]])\n\n    :param args: The function expects numpy arrays as inputs and returns a reshaped (2D) version of them (if necessary).\n    :return: Reshaped versions of the input numpy arrays. For instance, given 1D inputs X, Y and Z, then\n             shape_into_2d(X, Y, Z) reshapes them into 2D and returns them. If an input is already 2D, it will not be\n             modified and returned as it is.\n    \"\"\"", "\n", "\n", "def", "shaping", "(", "X", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "if", "X", ".", "ndim", "<", "2", ":", "\n", "            ", "return", "np", ".", "column_stack", "(", "[", "X", "]", ")", "\n", "", "elif", "X", ".", "ndim", ">", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Cannot reshape a %dD array into a 2D array!\"", "%", "X", ".", "ndim", ")", "\n", "\n", "", "return", "X", "\n", "\n", "", "result", "=", "[", "shaping", "(", "x", ")", "for", "x", "in", "args", "]", "\n", "\n", "if", "len", "(", "result", ")", "==", "1", ":", "\n", "        ", "return", "result", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed": [[42, 50], ["numpy.random.seed", "random.seed"], "function", ["None"], ["", "", "def", "set_random_seed", "(", "random_seed", ":", "int", ")", "->", "None", ":", "\n", "    ", "\"\"\"Sets random seed in numpy and the random module.\n\n    :param random_seed: Random see for the numpy and random module.\n    :return: None\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "random_seed", ")", "\n", "random", ".", "seed", "(", "random_seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders": [[52, 68], ["general.shape_into_2d", "range", "isinstance", "sklearn.preprocessing.OneHotEncoder", "one_hot_encoders[].fit", "X[].reshape"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "fit_one_hot_encoders", "(", "X", ":", "np", ".", "ndarray", ")", "->", "Dict", "[", "int", ",", "OneHotEncoder", "]", ":", "\n", "    ", "\"\"\"Fits one-hot encoders to each categorical column in X. A categorical input needs to be a string, i.e. a\n    categorical column consists only of strings.\n\n    :param X: Input data matrix.\n    :return: Dictionary that maps a column index to a scikit OneHotEncoder.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "one_hot_encoders", "=", "{", "}", "\n", "for", "column", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "if", "isinstance", "(", "X", "[", "0", ",", "column", "]", ",", "str", ")", ":", "\n", "            ", "one_hot_encoders", "[", "column", "]", "=", "OneHotEncoder", "(", "handle_unknown", "=", "'ignore'", ")", "\n", "one_hot_encoders", "[", "column", "]", ".", "fit", "(", "X", "[", ":", ",", "column", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "", "", "return", "one_hot_encoders", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding": [[70, 85], ["general.shape_into_2d", "range", "numpy.hstack().astype", "one_hot_features.append", "one_hot_features.append", "numpy.hstack", "one_hot_encoder_map[].transform().toarray", "X[].reshape", "one_hot_encoder_map[].transform", "X[].reshape"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "apply_one_hot_encoding", "(", "X", ":", "np", ".", "ndarray", ",", "one_hot_encoder_map", ":", "Dict", "[", "int", ",", "OneHotEncoder", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "if", "not", "one_hot_encoder_map", ":", "\n", "        ", "return", "X", "\n", "\n", "", "one_hot_features", "=", "[", "]", "\n", "\n", "for", "column", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "if", "column", "in", "one_hot_encoder_map", ":", "\n", "            ", "one_hot_features", ".", "append", "(", "one_hot_encoder_map", "[", "column", "]", ".", "transform", "(", "X", "[", ":", ",", "column", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "toarray", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "one_hot_features", ".", "append", "(", "X", "[", ":", ",", "column", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "", "", "return", "np", ".", "hstack", "(", "one_hot_features", ")", ".", "astype", "(", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical": [[87, 113], ["general.shape_into_2d", "range", "numpy.isnan", "ValueError", "isinstance", "isinstance", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "is_categorical", "(", "X", ":", "np", ".", "ndarray", ")", "->", "bool", ":", "\n", "    ", "\"\"\" Checks if all of the given columns are categorical, i.e. either a string or a boolean. Only if all of the\n    columns are categorical, this method will return True. Alternatively, consider has_categorical for checking if any\n    of the columns is categorical.\n\n    Note: A np matrix with mixed data types might internally convert numeric columns to strings and vice versa. To\n    ensure that the given given data keeps the original data type, consider converting/initializing it with the dtype\n    'object'. For instance: np.array([[1, 'True', '0', 0.2], [3, 'False', '1', 2.3]], dtype=object)\n\n    :param X: Input array to check if all columns are categorical.\n    :return: True if all columns of the input are categorical, False otherwise.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "status", "=", "True", "\n", "for", "column", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "if", "(", "isinstance", "(", "X", "[", "0", ",", "column", "]", ",", "int", ")", "or", "isinstance", "(", "X", "[", "0", ",", "column", "]", ",", "float", ")", ")", "and", "np", ".", "isnan", "(", "X", "[", "0", ",", "column", "]", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Input contains NaN values! This is currently not supported. \"", "\n", "\"Consider imputing missing values.\"", ")", "\n", "\n", "", "status", "&=", "(", "isinstance", "(", "X", "[", "0", ",", "column", "]", ",", "str", ")", "or", "isinstance", "(", "X", "[", "0", ",", "column", "]", ",", "bool", ")", ")", "\n", "\n", "if", "not", "status", ":", "\n", "            ", "break", "\n", "\n", "", "", "return", "status", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.has_categorical": [[115, 137], ["general.shape_into_2d", "range", "general.is_categorical"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical"], ["", "def", "has_categorical", "(", "X", ":", "np", ".", "ndarray", ")", "->", "bool", ":", "\n", "    ", "\"\"\" Checks if any of the given columns are categorical, i.e. either a string or a boolean. If any of the columns\n    is categorical, this method will return True. Alternatively, consider is_categorical for checking if all columns are\n    categorical.\n\n    Note: A np matrix with mixed data types might internally convert numeric columns to strings and vice versa. To\n    ensure that the given given data keeps the original data type, consider converting/initializing it with the dtype\n    'object'. For instance: np.array([[1, 'True', '0', 0.2], [3, 'False', '1', 2.3]], dtype=object)\n\n    :param X: Input array to check if all columns are categorical.\n    :return: True if all columns of the input are categorical, False otherwise.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "status", "=", "False", "\n", "for", "column", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "status", "|=", "is_categorical", "(", "X", "[", ":", ",", "column", "]", ")", "\n", "\n", "if", "status", ":", "\n", "            ", "break", "\n", "\n", "", "", "return", "status", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.means_difference": [[139, 141], ["numpy.mean().squeeze", "numpy.mean().squeeze", "numpy.mean", "numpy.mean"], "function", ["None"], ["", "def", "means_difference", "(", "randomized_predictions", ":", "np", ".", "ndarray", ",", "baseline_values", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "return", "np", ".", "mean", "(", "randomized_predictions", ")", ".", "squeeze", "(", ")", "-", "np", ".", "mean", "(", "baseline_values", ")", ".", "squeeze", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.variance_of_deviations": [[143, 148], ["numpy.var"], "function", ["None"], ["", "def", "variance_of_deviations", "(", "randomized_predictions", ":", "np", ".", "ndarray", ",", "baseline_values", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "# Using the negative value here seeing that the Shapley estimation evaluates v(S u {i}) - v(S) for a subset S. In", "\n", "# case of variance, we have v(S u {i}) <= v(S), which would result in a negative contribution of players to the", "\n", "# target quantity (here, variance).", "\n", "    ", "return", "-", "np", ".", "var", "(", "(", "randomized_predictions", "-", "baseline_values", ")", ".", "squeeze", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.variance_of_matching_values": [[150, 155], ["numpy.var"], "function", ["None"], ["", "def", "variance_of_matching_values", "(", "randomized_predictions", ":", "np", ".", "ndarray", ",", "baseline_values", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "# Using the negative value here seeing that the Shapley estimation evaluates v(S u {i}) - v(S) for a subset S. In", "\n", "# case of variance, we have v(S u {i}) <= v(S), which would result in a negative contribution of players to the", "\n", "# target quantity (here, variance).", "\n", "    ", "return", "-", "np", ".", "var", "(", "(", "randomized_predictions", "==", "baseline_values", ")", ".", "squeeze", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.geometric_median": [[157, 162], ["numpy.sum", "scipy.optimize.minimize", "numpy.sqrt", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "def", "geometric_median", "(", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "def", "distance_function", "(", "x_input", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "sum", "(", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "(", "x_input", "-", "x", ")", "**", "2", ",", "axis", "=", "1", ")", ")", ")", "\n", "\n", "", "return", "minimize", "(", "distance_function", ",", "np", ".", "sum", "(", "x", ",", "axis", "=", "0", ")", "/", "x", ".", "shape", "[", "0", "]", ")", ".", "x", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.test_plotting.test_when_plot_does_not_raise_exception": [[8, 10], ["dowhy.gcm.util.plot", "networkx.DiGraph"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot"], ["def", "test_when_plot_does_not_raise_exception", "(", ")", ":", "\n", "    ", "plot", "(", "nx", ".", "DiGraph", "(", "[", "(", "'X'", ",", "'Y'", ")", ",", "(", "'Y'", ",", "'Z'", ")", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.test_plotting.test_plot_adjacency_matrix": [[12, 19], ["pandas.DataFrame", "dowhy.gcm.util.plot_adjacency_matrix", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot_adjacency_matrix"], ["", "def", "test_plot_adjacency_matrix", "(", ")", ":", "\n", "    ", "causal_graph", "=", "pd", ".", "DataFrame", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", ")", ",", "\n", "columns", "=", "[", "'X'", ",", "'Y'", ",", "'Z'", "]", ",", "\n", "index", "=", "[", "'X'", ",", "'Y'", ",", "'Z'", "]", ")", "\n", "\n", "# Check if calling the method causes some import or runtime errors", "\n", "plot_adjacency_matrix", "(", "causal_graph", ",", "is_directed", "=", "True", ")", "\n", "# TODO: Plotting undirected graphs with networkx causes an error when an older networkx version is used with a newer", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.util.test_pygraphviz.test_calc_arrow_width": [[6, 13], ["dowhy.gcm.util.pygraphviz._calc_arrow_width", "pytest.approx", "dowhy.gcm.util.pygraphviz._calc_arrow_width", "pytest.approx", "dowhy.gcm.util.pygraphviz._calc_arrow_width", "pytest.approx", "dowhy.gcm.util.pygraphviz._calc_arrow_width", "pytest.approx", "dowhy.gcm.util.pygraphviz._calc_arrow_width", "pytest.approx", "dowhy.gcm.util.pygraphviz._calc_arrow_width", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width", "home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting._calc_arrow_width"], ["def", "test_calc_arrow_width", "(", ")", ":", "\n", "    ", "assert", "_calc_arrow_width", "(", ".4", ",", "max_strength", "=", ".5", ")", "==", "approx", "(", "3.3", ",", "abs", "=", "0.01", ")", "\n", "assert", "_calc_arrow_width", "(", ".2", ",", "max_strength", "=", ".5", ")", "==", "approx", "(", "1.7", ",", "abs", "=", "0.01", ")", "\n", "assert", "_calc_arrow_width", "(", "-", ".2", ",", "max_strength", "=", ".5", ")", "==", "approx", "(", "1.7", ",", "abs", "=", "0.01", ")", "\n", "assert", "_calc_arrow_width", "(", ".5", ",", "max_strength", "=", ".5", ")", "==", "approx", "(", "4.1", ",", "abs", "=", "0.01", ")", "\n", "assert", "_calc_arrow_width", "(", ".35", ",", "max_strength", "=", ".5", ")", "==", "approx", "(", "2.9", ",", "abs", "=", "0.01", ")", "\n", "assert", "_calc_arrow_width", "(", "100", ",", "max_strength", "=", "101", ")", "==", "approx", "(", "4.06", ",", "abs", "=", "0.01", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.__init__": [[30, 33], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sklearn_mdl", ":", "Any", ")", "->", "None", ":", "\n", "        ", "self", ".", "_sklearn_mdl", "=", "sklearn_mdl", "\n", "self", ".", "_one_hot_encoders", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit": [[34, 39], ["dowhy.gcm.util.general.fit_one_hot_encoders", "dowhy.gcm.util.general.apply_one_hot_encoding", "regression.SklearnRegressionModel._sklearn_mdl.fit", "Y.squeeze"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "self", ".", "_one_hot_encoders", "=", "fit_one_hot_encoders", "(", "X", ")", "\n", "X", "=", "apply_one_hot_encoding", "(", "X", ",", "self", ".", "_one_hot_encoders", ")", "\n", "\n", "self", ".", "_sklearn_mdl", ".", "fit", "(", "X", "=", "X", ",", "y", "=", "Y", ".", "squeeze", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict": [[40, 43], ["dowhy.gcm.util.general.shape_into_2d", "regression.SklearnRegressionModel._sklearn_mdl.predict", "dowhy.gcm.util.general.apply_one_hot_encoding"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "array", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "shape_into_2d", "(", "\n", "self", ".", "_sklearn_mdl", ".", "predict", "(", "apply_one_hot_encoding", "(", "X", ",", "self", ".", "_one_hot_encoders", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.sklearn_model": [[44, 47], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sklearn_model", "(", "self", ")", "->", "Any", ":", "\n", "        ", "return", "self", ".", "_sklearn_mdl", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.clone": [[48, 55], ["regression.SklearnRegressionModel", "sklearn.clone"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Clones the prediction model using the same hyper parameters but not fitted.\n\n        :return: An unfitted clone of the prediction model.\n        \"\"\"", "\n", "return", "SklearnRegressionModel", "(", "sklearn_mdl", "=", "sklearn", ".", "clone", "(", "self", ".", "_sklearn_mdl", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleIdentityFunction.evaluate": [[116, 118], ["None"], "methods", ["None"], ["    ", "def", "evaluate", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleIdentityFunction.evaluate_inverse": [[119, 121], ["None"], "methods", ["None"], ["", "def", "evaluate_inverse", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleExponentialFunction.evaluate": [[125, 127], ["numpy.exp"], "methods", ["None"], ["    ", "def", "evaluate", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "exp", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleExponentialFunction.evaluate_inverse": [[128, 130], ["numpy.log"], "methods", ["None"], ["", "def", "evaluate_inverse", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "log", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate": [[133, 135], ["numpy.log"], "methods", ["None"], ["    ", "def", "evaluate", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "log", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.InvertibleLogarithmicFunction.evaluate_inverse": [[136, 138], ["numpy.exp"], "methods", ["None"], ["", "def", "evaluate_inverse", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "exp", "(", "X", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor_with_given_parameters": [[57, 65], ["sklearn.linear_model.LinearRegression", "regression.SklearnRegressionModel"], "function", ["None"], ["", "", "def", "create_linear_regressor_with_given_parameters", "(", "coefficients", ":", "np", ".", "ndarray", ",", "\n", "intercept", ":", "float", "=", "0", ",", "\n", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "linear_model", "=", "LinearRegression", "(", "**", "kwargs", ")", "\n", "linear_model", ".", "coef_", "=", "coefficients", "\n", "linear_model", ".", "intercept_", "=", "intercept", "\n", "\n", "return", "SklearnRegressionModel", "(", "linear_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_linear_regressor": [[67, 69], ["regression.SklearnRegressionModel", "sklearn.linear_model.LinearRegression"], "function", ["None"], ["", "def", "create_linear_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "LinearRegression", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_ridge_regressor": [[71, 73], ["regression.SklearnRegressionModel", "sklearn.linear_model.RidgeCV"], "function", ["None"], ["", "def", "create_ridge_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "RidgeCV", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_lasso_regressor": [[75, 77], ["regression.SklearnRegressionModel", "sklearn.linear_model.LassoCV"], "function", ["None"], ["", "def", "create_lasso_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "LassoCV", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_lasso_lars_ic_regressor": [[79, 81], ["regression.SklearnRegressionModel", "sklearn.linear_model.LassoLarsIC"], "function", ["None"], ["", "def", "create_lasso_lars_ic_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "LassoLarsIC", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_elastic_net_regressor": [[83, 85], ["regression.SklearnRegressionModel", "sklearn.linear_model.ElasticNetCV"], "function", ["None"], ["", "def", "create_elastic_net_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "ElasticNetCV", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_gaussian_process_regressor": [[87, 89], ["regression.SklearnRegressionModel", "sklearn.gaussian_process.GaussianProcessRegressor"], "function", ["None"], ["", "def", "create_gaussian_process_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "GaussianProcessRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_support_vector_regressor": [[91, 93], ["regression.SklearnRegressionModel", "sklearn.svm.SVR"], "function", ["None"], ["", "def", "create_support_vector_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "SVR", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_random_forest_regressor": [[95, 97], ["regression.SklearnRegressionModel", "sklearn.ensemble.RandomForestRegressor"], "function", ["None"], ["", "def", "create_random_forest_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "RandomForestRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_hist_gradient_boost_regressor": [[99, 101], ["regression.SklearnRegressionModel", "sklearn.ensemble.HistGradientBoostingRegressor"], "function", ["None"], ["", "def", "create_hist_gradient_boost_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "HistGradientBoostingRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_extra_trees_regressor": [[103, 105], ["regression.SklearnRegressionModel", "sklearn.ensemble.ExtraTreesRegressor"], "function", ["None"], ["", "def", "create_extra_trees_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "ExtraTreesRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_knn_regressor": [[107, 109], ["regression.SklearnRegressionModel", "sklearn.neighbors.KNeighborsRegressor"], "function", ["None"], ["", "def", "create_knn_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "KNeighborsRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.create_ada_boost_regressor": [[111, 113], ["regression.SklearnRegressionModel", "sklearn.ensemble.AdaBoostRegressor"], "function", ["None"], ["", "def", "create_ada_boost_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "AdaBoostRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.predict_probabilities": [[29, 32], ["dowhy.gcm.util.general.shape_into_2d", "classification.SklearnClassificationModel._sklearn_mdl.predict_proba", "dowhy.gcm.util.general.apply_one_hot_encoding"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding"], ["    ", "def", "predict_probabilities", "(", "self", ",", "X", ":", "np", ".", "array", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "shape_into_2d", "(", "\n", "self", ".", "_sklearn_mdl", ".", "predict_proba", "(", "apply_one_hot_encoding", "(", "X", ",", "self", ".", "_one_hot_encoders", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.classes": [[33, 36], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "classes", "(", "self", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "return", "self", ".", "_sklearn_mdl", ".", "classes_", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone": [[37, 39], ["classification.SklearnClassificationModel", "sklearn.clone"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.SklearnClassificationModel.clone"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "return", "SklearnClassificationModel", "(", "sklearn_mdl", "=", "sklearn", ".", "clone", "(", "self", ".", "_sklearn_mdl", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_random_forest_classifier": [[41, 43], ["classification.SklearnClassificationModel", "sklearn.ensemble.RandomForestClassifier"], "function", ["None"], ["", "", "def", "create_random_forest_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "RandomForestClassifier", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_gaussian_process_classifier": [[45, 47], ["classification.SklearnClassificationModel", "sklearn.gaussian_process.GaussianProcessClassifier"], "function", ["None"], ["", "def", "create_gaussian_process_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "GaussianProcessClassifier", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_hist_gradient_boost_classifier": [[49, 51], ["classification.SklearnClassificationModel", "sklearn.ensemble.HistGradientBoostingClassifier"], "function", ["None"], ["", "def", "create_hist_gradient_boost_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "HistGradientBoostingClassifier", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_logistic_regression_classifier": [[53, 55], ["classification.SklearnClassificationModel", "sklearn.linear_model.LogisticRegression"], "function", ["None"], ["", "def", "create_logistic_regression_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "LogisticRegression", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_extra_trees_classifier": [[57, 59], ["classification.SklearnClassificationModel", "sklearn.ensemble.ExtraTreesClassifier"], "function", ["None"], ["", "def", "create_extra_trees_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "ExtraTreesClassifier", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_ada_boost_classifier": [[61, 63], ["classification.SklearnClassificationModel", "sklearn.ensemble.AdaBoostClassifier"], "function", ["None"], ["", "def", "create_ada_boost_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "AdaBoostClassifier", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_support_vector_classifier": [[65, 67], ["classification.SklearnClassificationModel", "sklearn.svm.SVC"], "function", ["None"], ["", "def", "create_support_vector_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "SVC", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_knn_classifier": [[69, 71], ["classification.SklearnClassificationModel", "sklearn.neighbors.KNeighborsClassifier"], "function", ["None"], ["", "def", "create_knn_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "KNeighborsClassifier", "(", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.ml.classification.create_gaussian_nb_classifier": [[73, 75], ["classification.SklearnClassificationModel", "sklearn.naive_bayes.GaussianNB"], "function", ["None"], ["", "def", "create_gaussian_nb_classifier", "(", "**", "kwargs", ")", "->", "SklearnClassificationModel", ":", "\n", "    ", "return", "SklearnClassificationModel", "(", "GaussianNB", "(", "**", "kwargs", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based": [[21, 104], ["dowhy.gcm.util.general.set_random_seed", "numpy.random.randint", "p_value_adjust_func", "kernel.kernel_based.evaluate_kernel_test_on_samples"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed"], ["def", "kernel_based", "(", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "Z", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "kernel", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", "=", "apply_rbf_kernel", ",", "\n", "scale_data", ":", "bool", "=", "True", ",", "\n", "use_bootstrap", ":", "bool", "=", "True", ",", "\n", "bootstrap_num_runs", ":", "int", "=", "20", ",", "\n", "bootstrap_num_samples_per_run", ":", "int", "=", "2000", ",", "\n", "bootstrap_n_jobs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "p_value_adjust_func", ":", "Callable", "[", "[", "Union", "[", "np", ".", "ndarray", ",", "List", "[", "float", "]", "]", "]", ",", "float", "]", "=", "quantile_based_fwer", ")", "->", "float", ":", "\n", "    ", "\"\"\"Prepares the data and uses kernel (conditional) independence test. The independence test estimates a p-value\n    for the null hypothesis that X and Y are independent (given Z). Depending whether Z is given, a conditional or\n    pairwise independence test is performed.\n\n    If Z is given: Using KCI as conditional independence test.\n    If Z is not given: Using HSIC as pairwise independence test.\n\n    Note:\n    - The data can be multivariate, i.e. the given input matrices can have multiple columns.\n    - Categorical data need to be represented as strings.\n    - It is possible to apply a different kernel to each column in the matrices. For instance, a RBF kernel for the\n      first dimension in X and a delta kernel for the second.\n\n    Based on the work:\n    - Conditional: K. Zhang, J. Peters, D. Janzing, B. Sch\u00f6lkopf. *Kernel-based Conditional Independence Test and Application in Causal Discovery*. UAI'11, Pages 804\u2013813, 2011.\n    - Pairwise: A. Gretton, K. Fukumizu, C.-H. Teo, L. Song, B. Sch\u00f6lkopf, A. Smola. *A Kernel Statistical Test of Independence*. NIPS 21, 2007.\n\n    :param X: Data matrix for observations from X.\n    :param Y: Data matrix for observations from Y.\n    :param Z: Optional data matrix for observations from Z. This is the conditional variable.\n    :param kernel: A kernel for estimating the pairwise similarities between samples. The expected input is a n x d\n                   numpy array and the output is expected to be a n x n numpy array. By default, the RBF kernel is used.\n    :param scale_data: If set to True, the data will be standardized. If set to False, the data is taken as it is.\n                       Standardizing the data helps in identifying weak dependencies. If one is only interested in\n                       stronger ones, consider setting this to False.\n    :param use_bootstrap: If True, the independence tests are performed on multiple subsets of the data and the final\n                          p-value is constructed based on the provided p_value_adjust_func function.\n    :param bootstrap_num_runs: Number of bootstrap runs (only relevant if use_bootstrap is True).\n    :param bootstrap_num_samples_per_run: Number of samples used in a bootstrap run (only relevant if use_bootstrap is\n                                          True).\n    :param bootstrap_n_jobs: Number of parallel jobs for the boostrap runs.\n    :param p_value_adjust_func: A callable that expects a numpy array of multiple p-values and returns one p-value. This\n                                is typically used a family wise error rate control method.\n    :return: The p-value for the null hypothesis that X and Y are independent (given Z).\n    \"\"\"", "\n", "bootstrap_n_jobs", "=", "config", ".", "default_n_jobs", "if", "bootstrap_n_jobs", "is", "None", "else", "bootstrap_n_jobs", "\n", "\n", "def", "evaluate_kernel_test_on_samples", "(", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "Z", ":", "np", ".", "ndarray", ",", "\n", "parallel_random_seed", ":", "int", ")", "->", "float", ":", "\n", "        ", "set_random_seed", "(", "parallel_random_seed", ")", "\n", "\n", "try", ":", "\n", "            ", "if", "Z", "is", "None", ":", "\n", "                ", "return", "_hsic", "(", "X", ",", "Y", ",", "kernel", "=", "kernel", ",", "scale_data", "=", "scale_data", ")", "\n", "", "else", ":", "\n", "                ", "return", "_kci", "(", "X", ",", "Y", ",", "Z", ",", "kernel", "=", "kernel", ",", "scale_data", "=", "scale_data", ")", "\n", "", "", "except", "LinAlgError", ":", "\n", "# TODO: This is a temporary workaround.", "\n", "#       Under some circumstances, the KCI test throws a \"numpy.linalg.LinAlgError: SVD did not converge\"", "\n", "#       error, depending on the data samples. This is related to the utilized algorithms by numpy for SVD.", "\n", "#       There is actually a robust version for SVD, but it is not included in numpy.", "\n", "#       This can either be addressed by some augmenting the data, using a different SVD implementation or", "\n", "#       wait until numpy updates the used algorithm.", "\n", "            ", "return", "np", ".", "nan", "\n", "\n", "", "", "if", "use_bootstrap", "and", "X", ".", "shape", "[", "0", "]", ">", "bootstrap_num_samples_per_run", ":", "\n", "        ", "random_indices", "=", "[", "np", ".", "random", ".", "choice", "(", "X", ".", "shape", "[", "0", "]", ",", "min", "(", "X", ".", "shape", "[", "0", "]", ",", "bootstrap_num_samples_per_run", ")", ",", "replace", "=", "False", ")", "\n", "for", "run", "in", "range", "(", "bootstrap_num_runs", ")", "]", "\n", "\n", "random_seeds", "=", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "len", "(", "random_indices", ")", ")", "\n", "p_values", "=", "Parallel", "(", "n_jobs", "=", "bootstrap_n_jobs", ")", "(", "\n", "delayed", "(", "evaluate_kernel_test_on_samples", ")", "(", "X", "[", "indices", "]", ",", "\n", "Y", "[", "indices", "]", ",", "\n", "Z", "[", "indices", "]", "if", "Z", "is", "not", "None", "else", "None", ",", "\n", "random_seed", ")", "\n", "for", "indices", ",", "random_seed", "in", "zip", "(", "random_indices", ",", "random_seeds", ")", ")", "\n", "\n", "return", "p_value_adjust_func", "(", "p_values", ")", "\n", "", "else", ":", "\n", "        ", "return", "evaluate_kernel_test_on_samples", "(", "X", ",", "Y", ",", "Z", ",", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "1", ")", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based": [[106, 194], ["float", "kernel._rit", "kernel._rcit"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._rit", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._rcit"], ["", "", "def", "approx_kernel_based", "(", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "Z", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "num_random_features_X", ":", "int", "=", "50", ",", "\n", "num_random_features_Y", ":", "int", "=", "50", ",", "\n", "num_random_features_Z", ":", "int", "=", "50", ",", "\n", "num_permutations", ":", "int", "=", "100", ",", "\n", "approx_kernel", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", "=", "approximate_rbf_kernel_features", ",", "\n", "scale_data", ":", "bool", "=", "False", ",", "\n", "use_bootstrap", ":", "bool", "=", "True", ",", "\n", "bootstrap_num_runs", ":", "int", "=", "10", ",", "\n", "bootstrap_num_samples", ":", "int", "=", "1000", ",", "\n", "bootstrap_n_jobs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "p_value_adjust_func", ":", "\n", "Callable", "[", "[", "Union", "[", "np", ".", "ndarray", ",", "List", "[", "float", "]", "]", "]", ",", "float", "]", "=", "quantile_based_fwer", ")", "->", "float", ":", "\n", "    ", "\"\"\"Implementation of the Randomized Conditional Independence Test. The independence test estimates a p-value\n    for the null hypothesis that X and Y are independent (given Z). Depending whether Z is given, a conditional or\n    pairwise independence test is performed.\n    \n    If Z is given: Using RCIT as conditional independence test.\n    If Z is not given: Using RIT as pairwise independence test.\n\n    Note:\n    - The data can be multivariate, i.e. the given input matrices can have multiple columns.\n    - Categorical data need to be represented as strings.\n    - It is possible to apply a different kernel to each column in the matrices. For instance, a RBF kernel for the\n      first dimension in X and a delta kernel for the second.\n      \n    Based on the work:\n        Strobl, Eric V., Kun Zhang, and Shyam Visweswaran.\n        Approximate kernel-based conditional independence tests for fast non-parametric causal discovery.\n        Journal of Causal Inference 7.1 (2019).\n    \n    :param X: Data matrix for observations from X.\n    :param Y: Data matrix for observations from Y.\n    :param Z: Optional data matrix for observations from Z. This is the conditional variable.\n    :param num_random_features_X: Number of features sampled from the approximated kernel map for X. \n    :param num_random_features_Y: Number of features sampled from the approximated kernel map for Y. \n    :param num_random_features_Z: Number of features sampled from the approximated kernel map for Z. \n    :param num_permutations: Number of permutations for estimating the test test statistic.\n    :param approx_kernel: The approximated kernel map. The expected input is a n x d numpy array and the output is \n                          expected to be a n x k numpy array with k << d. By default, the Nystroem method with a RBF\n                          kernel is used.\n    :param scale_data: If set to True, the data will be standardized. If set to False, the data is taken as it is.\n                       Standardizing the data helps in identifying weak dependencies. If one is only interested in\n                       stronger ones, consider setting this to False.\n    :param use_bootstrap: If True, the independence tests are performed on multiple subsets of the data and the final\n                          p-value is constructed based on the provided p_value_adjust_func function.\n    :param bootstrap_num_runs: Number of bootstrap runs (only relevant if use_bootstrap is True).\n    :param bootstrap_num_samples: Maximum number of used samples per bootstrap run. \n    :param bootstrap_n_jobs: Number of parallel jobs for the boostrap runs.\n    :param p_value_adjust_func: A callable that expects a numpy array of multiple p-values and returns one p-value. This\n                                is typically used a family wise error rate control method.\n    :return: The p-value for the null hypothesis that X and Y are independent (given Z).\n    \"\"\"", "\n", "bootstrap_n_jobs", "=", "config", ".", "default_n_jobs", "if", "bootstrap_n_jobs", "is", "None", "else", "bootstrap_n_jobs", "\n", "\n", "if", "not", "use_bootstrap", ":", "\n", "        ", "bootstrap_num_runs", "=", "1", "\n", "bootstrap_num_samples", "=", "float", "(", "'inf'", ")", "\n", "bootstrap_n_jobs", "=", "1", "\n", "\n", "", "if", "Z", "is", "None", ":", "\n", "        ", "return", "_rit", "(", "X", ",", "\n", "Y", ",", "\n", "num_permutations", "=", "num_permutations", ",", "\n", "num_random_features_X", "=", "num_random_features_X", ",", "\n", "num_random_features_Y", "=", "num_random_features_Y", ",", "\n", "num_runs", "=", "bootstrap_num_runs", ",", "\n", "num_max_samples_per_run", "=", "bootstrap_num_samples", ",", "\n", "approx_kernel", "=", "approx_kernel", ",", "\n", "scale_data", "=", "scale_data", ",", "\n", "n_jobs", "=", "bootstrap_n_jobs", ",", "\n", "p_value_adjust_func", "=", "p_value_adjust_func", ")", "\n", "", "else", ":", "\n", "        ", "return", "_rcit", "(", "X", ",", "\n", "Y", ",", "\n", "Z", ",", "\n", "num_permutations", "=", "num_permutations", ",", "\n", "num_random_features_X", "=", "num_random_features_X", ",", "\n", "num_random_features_Y", "=", "num_random_features_Y", ",", "\n", "num_random_features_Z", "=", "num_random_features_Z", ",", "\n", "num_runs", "=", "bootstrap_num_runs", ",", "\n", "num_max_samples_per_run", "=", "bootstrap_num_samples", ",", "\n", "approx_kernel", "=", "approx_kernel", ",", "\n", "scale_data", "=", "scale_data", ",", "\n", "n_jobs", "=", "bootstrap_n_jobs", ",", "\n", "p_value_adjust_func", "=", "p_value_adjust_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._kci": [[196, 279], ["kernel._convert_to_numeric", "kernel", "kernel", "kernel", "kernel._fast_centering", "kernel._fast_centering", "kernel._fast_centering", "numpy.sum", "numpy.linalg.svd", "numpy.linalg.svd", "kernel._filter_out_small_eigen_values_and_vectors", "kernel._filter_out_small_eigen_values_and_vectors", "empirical_kernel_map_xz_z.reshape.squeeze", "empirical_kernel_map_xz_z.reshape.reshape", "empirical_kernel_map_y_z.reshape.squeeze", "empirical_kernel_map_y_z.reshape.reshape", "kernel._estimate_p_value", "RuntimeError", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "numpy.eye", "len", "len", "dowhy.gcm.util.general.shape_into_2d", "numpy.linalg.pinv", "numpy.sqrt", "numpy.sqrt", "numpy.eye", "numpy.sqrt", "numpy.eye", "numpy.sqrt", "numpy.eye", "len", "len"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._convert_to_numeric", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._fast_centering", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._fast_centering", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._fast_centering", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._filter_out_small_eigen_values_and_vectors", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._filter_out_small_eigen_values_and_vectors", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_p_value", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "", "def", "_kci", "(", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "Z", ":", "np", ".", "ndarray", ",", "\n", "kernel", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "scale_data", ":", "bool", ",", "\n", "regularization_param", ":", "float", "=", "10", "**", "-", "3", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Tests the null hypothesis that X and Y are independent given Z using the kernel conditional independence test.\n\n    This is a corrected reimplementation of the KCI method in the CondIndTests R-package. Authors of the original R\n    package: Christina Heinze-Deml, Jonas Peters, Asbjoern Marco Sinius Munk\n\n    :return: The p-value for the null hypothesis that X and Y are independent given Z.\n    \"\"\"", "\n", "X", ",", "Y", ",", "Z", "=", "_convert_to_numeric", "(", "*", "shape_into_2d", "(", "X", ",", "Y", ",", "Z", ")", ")", "\n", "\n", "if", "X", ".", "shape", "[", "0", "]", "!=", "Y", ".", "shape", "[", "0", "]", "!=", "Z", ".", "shape", "[", "0", "]", ":", "\n", "        ", "raise", "RuntimeError", "(", "'All variables need to have the same number of samples!'", ")", "\n", "\n", "", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "if", "scale_data", ":", "\n", "        ", "X", "=", "scale", "(", "X", ")", "\n", "Y", "=", "scale", "(", "Y", ")", "\n", "Z", "=", "scale", "(", "Z", ")", "\n", "\n", "", "k_x", "=", "kernel", "(", "X", ")", "\n", "k_y", "=", "kernel", "(", "Y", ")", "\n", "k_z", "=", "kernel", "(", "Z", ")", "\n", "\n", "k_xz", "=", "k_x", "*", "k_z", "\n", "\n", "k_xz", "=", "_fast_centering", "(", "k_xz", ")", "\n", "k_y", "=", "_fast_centering", "(", "k_y", ")", "\n", "k_z", "=", "_fast_centering", "(", "k_z", ")", "\n", "\n", "r_z", "=", "np", ".", "eye", "(", "n", ")", "-", "k_z", "@", "pinv", "(", "k_z", "+", "regularization_param", "*", "np", ".", "eye", "(", "n", ")", ")", "\n", "\n", "k_xz_z", "=", "r_z", "@", "k_xz", "@", "r_z", ".", "T", "\n", "k_y_z", "=", "r_z", "@", "k_y", "@", "r_z", ".", "T", "\n", "\n", "# Not dividing by n, seeing that the expectation and variance are also not divided by n and n**2, respectively.", "\n", "statistic", "=", "np", ".", "sum", "(", "k_xz_z", "*", "k_y_z", ".", "T", ")", "\n", "\n", "# Taking the sum, because due to numerical issues, the matrices might not be symmetric.", "\n", "eigen_vec_k_xz_z", ",", "eigen_val_k_xz_z", ",", "_", "=", "svd", "(", "(", "k_xz_z", "+", "k_xz_z", ".", "T", ")", "/", "2", ")", "\n", "eigen_vec_k_y_z", ",", "eigen_val_k_y_z", ",", "_", "=", "svd", "(", "(", "k_y_z", "+", "k_y_z", ".", "T", ")", "/", "2", ")", "\n", "\n", "# Filter out eigenvalues that are too small.", "\n", "eigen_val_k_xz_z", ",", "eigen_vec_k_xz_z", "=", "_filter_out_small_eigen_values_and_vectors", "(", "eigen_val_k_xz_z", ",", "eigen_vec_k_xz_z", ")", "\n", "eigen_val_k_y_z", ",", "eigen_vec_k_y_z", "=", "_filter_out_small_eigen_values_and_vectors", "(", "eigen_val_k_y_z", ",", "eigen_vec_k_y_z", ")", "\n", "\n", "if", "len", "(", "eigen_val_k_xz_z", ")", "==", "1", ":", "\n", "        ", "empirical_kernel_map_xz_z", "=", "eigen_vec_k_xz_z", "*", "np", ".", "sqrt", "(", "eigen_val_k_xz_z", ")", "\n", "", "else", ":", "\n", "        ", "empirical_kernel_map_xz_z", "=", "eigen_vec_k_xz_z", "@", "(", "np", ".", "eye", "(", "len", "(", "eigen_val_k_xz_z", ")", ")", "\n", "*", "np", ".", "sqrt", "(", "eigen_val_k_xz_z", ")", ")", ".", "T", "\n", "\n", "", "empirical_kernel_map_xz_z", "=", "empirical_kernel_map_xz_z", ".", "squeeze", "(", ")", "\n", "empirical_kernel_map_xz_z", "=", "empirical_kernel_map_xz_z", ".", "reshape", "(", "empirical_kernel_map_xz_z", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "if", "len", "(", "eigen_val_k_y_z", ")", "==", "1", ":", "\n", "        ", "empirical_kernel_map_y_z", "=", "eigen_vec_k_y_z", "*", "np", ".", "sqrt", "(", "eigen_val_k_y_z", ")", "\n", "", "else", ":", "\n", "        ", "empirical_kernel_map_y_z", "=", "eigen_vec_k_y_z", "@", "(", "np", ".", "eye", "(", "len", "(", "eigen_val_k_y_z", ")", ")", "*", "np", ".", "sqrt", "(", "eigen_val_k_y_z", ")", ")", ".", "T", "\n", "\n", "", "empirical_kernel_map_y_z", "=", "empirical_kernel_map_y_z", ".", "squeeze", "(", ")", "\n", "empirical_kernel_map_y_z", "=", "empirical_kernel_map_y_z", ".", "reshape", "(", "empirical_kernel_map_y_z", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "num_eigen_vec_xz_z", "=", "empirical_kernel_map_xz_z", ".", "shape", "[", "1", "]", "\n", "num_eigen_vec_y_z", "=", "empirical_kernel_map_y_z", ".", "shape", "[", "1", "]", "\n", "\n", "size_w", "=", "num_eigen_vec_xz_z", "*", "num_eigen_vec_y_z", "\n", "\n", "w", "=", "(", "empirical_kernel_map_y_z", "[", ":", ",", "None", "]", "\n", "*", "empirical_kernel_map_xz_z", "[", "...", ",", "None", "]", ")", ".", "reshape", "(", "empirical_kernel_map_y_z", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "if", "size_w", ">", "n", ":", "\n", "        ", "ww_prod", "=", "w", "@", "w", ".", "T", "\n", "", "else", ":", "\n", "        ", "ww_prod", "=", "w", ".", "T", "@", "w", "\n", "\n", "", "return", "_estimate_p_value", "(", "ww_prod", ",", "statistic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._fast_centering": [[281, 295], ["len", "numpy.ones", "numpy.outer", "numpy.sum", "numpy.outer", "numpy.sum", "numpy.ones", "numpy.ones", "numpy.sum"], "function", ["None"], ["", "def", "_fast_centering", "(", "k", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Compute centered kernel matrix in time O(n^2).\n\n    The centered kernel matrix is defined as K_c = H @ K @ H, with\n    H = identity - 1/ n * ones(n,n). Computing H @ K @ H via matrix multiplication scales with n^3. The\n    implementation circumvents this and runs in time n^2.\n    :param k: original kernel matrix of size nxn\n    :return: centered kernel matrix of size nxn\n    \"\"\"", "\n", "n", "=", "len", "(", "k", ")", "\n", "k_c", "=", "(", "k", "-", "1", "/", "n", "*", "np", ".", "outer", "(", "np", ".", "ones", "(", "n", ")", ",", "np", ".", "sum", "(", "k", ",", "axis", "=", "0", ")", ")", "\n", "-", "1", "/", "n", "*", "np", ".", "outer", "(", "np", ".", "sum", "(", "k", ",", "axis", "=", "1", ")", ",", "np", ".", "ones", "(", "n", ")", ")", "\n", "+", "1", "/", "n", "**", "2", "*", "np", ".", "sum", "(", "k", ")", "*", "np", ".", "ones", "(", "(", "n", ",", "n", ")", ")", ")", "\n", "return", "k_c", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._hsic": [[297, 359], ["kernel._convert_to_numeric", "kernel", "kernel", "kernel._fast_centering", "kernel._fast_centering", "numpy.ones", "max", "max", "RuntimeError", "RuntimeError", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "numpy.diag", "numpy.diag", "max.squeeze", "max.squeeze", "scipy.stats.gamma.cdf", "dowhy.gcm.util.general.shape_into_2d", "numpy.diag", "numpy.diag", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.trace", "numpy.sum", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._convert_to_numeric", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._fast_centering", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._fast_centering", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "_hsic", "(", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "kernel", ":", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "scale_data", ":", "bool", ",", "\n", "cut_off_value", ":", "float", "=", "EPS", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Estimates the Hilbert-Schmidt Independence Criterion score for a pairwise independence test between variables X\n    and Y.\n\n    This is a reimplementation from the original Matlab code provided by the authors.\n\n    :return: The p-value for the null hypothesis that X and Y are independent.\n    \"\"\"", "\n", "X", ",", "Y", "=", "_convert_to_numeric", "(", "*", "shape_into_2d", "(", "X", ",", "Y", ")", ")", "\n", "\n", "if", "X", ".", "shape", "[", "0", "]", "!=", "Y", ".", "shape", "[", "0", "]", ":", "\n", "        ", "raise", "RuntimeError", "(", "'All variables need to have the same number of samples!'", ")", "\n", "\n", "", "if", "X", ".", "shape", "[", "0", "]", "<", "6", ":", "\n", "        ", "raise", "RuntimeError", "(", "'At least 6 samples are required for the HSIC independence test. Only %d were given.'", "\n", "%", "X", ".", "shape", "[", "0", "]", ")", "\n", "\n", "", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "if", "scale_data", ":", "\n", "        ", "X", "=", "scale", "(", "X", ")", "\n", "Y", "=", "scale", "(", "Y", ")", "\n", "\n", "", "k_mat", "=", "kernel", "(", "X", ")", "\n", "l_mat", "=", "kernel", "(", "Y", ")", "\n", "\n", "k_c", "=", "_fast_centering", "(", "k_mat", ")", "\n", "l_c", "=", "_fast_centering", "(", "l_mat", ")", "\n", "\n", "#  Test statistic is given as np.trace(K @ H @ L @ H) / n. Below computes without matrix products.", "\n", "test_statistic", "=", "1", "/", "n", "*", "(", "np", ".", "sum", "(", "k_mat", "*", "l_mat", ")", "-", "2", "/", "n", "*", "np", ".", "sum", "(", "k_mat", ",", "axis", "=", "0", ")", "@", "np", ".", "sum", "(", "l_mat", ",", "axis", "=", "1", ")", "+", "\n", "1", "/", "n", "**", "2", "*", "np", ".", "sum", "(", "k_mat", ")", "*", "np", ".", "sum", "(", "l_mat", ")", ")", "\n", "\n", "var_hsic", "=", "(", "k_c", "*", "l_c", ")", "**", "2", "\n", "var_hsic", "=", "(", "np", ".", "sum", "(", "var_hsic", ")", "-", "np", ".", "trace", "(", "var_hsic", ")", ")", "/", "n", "/", "(", "n", "-", "1", ")", "\n", "var_hsic", "=", "var_hsic", "*", "2", "*", "(", "n", "-", "4", ")", "*", "(", "n", "-", "5", ")", "/", "n", "/", "(", "n", "-", "1", ")", "/", "(", "n", "-", "2", ")", "/", "(", "n", "-", "3", ")", "\n", "\n", "k_mat", "=", "k_mat", "-", "np", ".", "diag", "(", "np", ".", "diag", "(", "k_mat", ")", ")", "\n", "l_mat", "=", "l_mat", "-", "np", ".", "diag", "(", "np", ".", "diag", "(", "l_mat", ")", ")", "\n", "\n", "bone", "=", "np", ".", "ones", "(", "(", "n", ",", "1", ")", ",", "dtype", "=", "float", ")", "\n", "mu_x", "=", "(", "bone", ".", "T", "@", "k_mat", "@", "bone", ")", "/", "n", "/", "(", "n", "-", "1", ")", "\n", "mu_y", "=", "(", "bone", ".", "T", "@", "l_mat", "@", "bone", ")", "/", "n", "/", "(", "n", "-", "1", ")", "\n", "\n", "m_hsic", "=", "(", "1", "+", "mu_x", "*", "mu_y", "-", "mu_x", "-", "mu_y", ")", "/", "n", "\n", "\n", "var_hsic", "=", "max", "(", "var_hsic", ".", "squeeze", "(", ")", ",", "cut_off_value", ")", "\n", "m_hsic", "=", "max", "(", "m_hsic", ".", "squeeze", "(", ")", ",", "cut_off_value", ")", "\n", "if", "test_statistic", "<=", "cut_off_value", ":", "\n", "        ", "test_statistic", "=", "0", "\n", "\n", "", "al", "=", "m_hsic", "**", "2", "/", "var_hsic", "\n", "bet", "=", "var_hsic", "*", "n", "/", "m_hsic", "\n", "\n", "p_value", "=", "1", "-", "gamma", ".", "cdf", "(", "test_statistic", ",", "al", ",", "scale", "=", "bet", ")", "\n", "\n", "return", "p_value", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._filter_out_small_eigen_values_and_vectors": [[361, 368], ["numpy.where", "max"], "function", ["None"], ["", "def", "_filter_out_small_eigen_values_and_vectors", "(", "eigen_values", ":", "np", ".", "ndarray", ",", "\n", "eigen_vectors", ":", "np", ".", "ndarray", ",", "\n", "relative_tolerance", ":", "float", "=", "(", "10", "**", "-", "5", ")", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "filtered_indices_xz_z", "=", "np", ".", "where", "(", "eigen_values", "[", "eigen_values", ">", "max", "(", "eigen_values", ")", "*", "relative_tolerance", "]", ")", "\n", "\n", "return", "eigen_values", "[", "filtered_indices_xz_z", "]", ",", "eigen_vectors", "[", ":", ",", "filtered_indices_xz_z", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_p_value": [[370, 379], ["numpy.trace", "numpy.trace", "scipy.stats.gamma.cdf"], "function", ["None"], ["", "def", "_estimate_p_value", "(", "ww_prod", ":", "np", ".", "ndarray", ",", "statistic", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "# Dividing by n not required since we do not divide the test statistical_tools by n.", "\n", "    ", "mean_approx", "=", "np", ".", "trace", "(", "ww_prod", ")", "\n", "variance_approx", "=", "2", "*", "np", ".", "trace", "(", "ww_prod", "@", "ww_prod", ")", "\n", "\n", "alpha_approx", "=", "mean_approx", "**", "2", "/", "variance_approx", "\n", "beta_approx", "=", "variance_approx", "/", "mean_approx", "\n", "\n", "return", "1", "-", "gamma", ".", "cdf", "(", "statistic", ",", "alpha_approx", ",", "scale", "=", "beta_approx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._rit": [[381, 431], ["kernel._convert_to_numeric", "numpy.random.randint", "p_value_adjust_func", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "dowhy.gcm.util.general.set_random_seed", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "range", "joblib.Parallel", "dowhy.gcm.util.general.shape_into_2d", "numpy.random.choice", "approx_kernel", "approx_kernel", "permutation_results_of_statistic.append", "numpy.iinfo", "kernel._estimate_rit_statistic", "numpy.sum", "len", "joblib.delayed", "range", "kernel._estimate_rit_statistic", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._convert_to_numeric", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_rit_statistic", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_rit_statistic"], ["", "def", "_rit", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ",", "\n", "num_random_features_X", ":", "int", ",", "\n", "num_random_features_Y", ":", "int", ",", "\n", "num_permutations", ":", "int", ",", "\n", "num_runs", ":", "int", ",", "\n", "num_max_samples_per_run", ":", "int", ",", "\n", "approx_kernel", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "int", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "scale_data", ":", "bool", ",", "\n", "n_jobs", ":", "Optional", "[", "int", "]", ",", "\n", "p_value_adjust_func", ":", "Callable", "[", "[", "Union", "[", "np", ".", "ndarray", ",", "List", "[", "float", "]", "]", "]", ",", "float", "]", ")", "->", "float", ":", "\n", "    ", "\"\"\"Implementation of the Randomized Independence Test based on the work:\n        Strobl, Eric V., Kun Zhang, and Shyam Visweswaran.\n        Approximate kernel-based conditional independence tests for fast non-parametric causal discovery.\n        Journal of Causal Inference 7.1 (2019).\n    \"\"\"", "\n", "n_jobs", "=", "config", ".", "default_n_jobs", "if", "n_jobs", "is", "None", "else", "n_jobs", "\n", "\n", "X", ",", "Y", "=", "_convert_to_numeric", "(", "*", "shape_into_2d", "(", "X", ",", "Y", ")", ")", "\n", "\n", "if", "scale_data", ":", "\n", "        ", "X", "=", "scale", "(", "X", ")", "\n", "Y", "=", "scale", "(", "Y", ")", "\n", "\n", "", "def", "evaluate_rit_on_samples", "(", "parallel_random_seed", ":", "int", ")", ":", "\n", "        ", "set_random_seed", "(", "parallel_random_seed", ")", "\n", "\n", "if", "X", ".", "shape", "[", "0", "]", ">", "num_max_samples_per_run", ":", "\n", "            ", "random_indices", "=", "np", ".", "random", ".", "choice", "(", "X", ".", "shape", "[", "0", "]", ",", "num_max_samples_per_run", ",", "replace", "=", "False", ")", "\n", "X_samples", "=", "X", "[", "random_indices", "]", "\n", "Y_samples", "=", "Y", "[", "random_indices", "]", "\n", "", "else", ":", "\n", "            ", "X_samples", "=", "X", "\n", "Y_samples", "=", "Y", "\n", "\n", "", "random_features_x", "=", "scale", "(", "approx_kernel", "(", "X_samples", ",", "num_random_features_X", ")", ")", "\n", "random_features_y", "=", "scale", "(", "approx_kernel", "(", "Y_samples", ",", "num_random_features_Y", ")", ")", "\n", "\n", "permutation_results_of_statistic", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_permutations", ")", ":", "\n", "            ", "permutation_results_of_statistic", ".", "append", "(", "_estimate_rit_statistic", "(", "\n", "random_features_x", "[", "np", ".", "random", ".", "choice", "(", "random_features_x", ".", "shape", "[", "0", "]", ",", "\n", "random_features_x", ".", "shape", "[", "0", "]", ",", "replace", "=", "False", ")", "]", ",", "random_features_y", ")", ")", "\n", "\n", "", "return", "1", "-", "(", "np", ".", "sum", "(", "_estimate_rit_statistic", "(", "random_features_x", ",", "random_features_y", ")", "\n", ">", "permutation_results_of_statistic", ")", "/", "len", "(", "permutation_results_of_statistic", ")", ")", "\n", "\n", "", "random_seeds", "=", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "num_runs", ")", "\n", "p_values", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "delayed", "(", "evaluate_rit_on_samples", ")", "(", "random_seeds", "[", "i", "]", ")", "for", "i", "in", "range", "(", "num_runs", ")", ")", "\n", "\n", "return", "p_value_adjust_func", "(", "p_values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._rcit": [[433, 505], ["kernel._convert_to_numeric", "numpy.random.randint", "p_value_adjust_func", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "dowhy.gcm.util.general.set_random_seed", "numpy.column_stack", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "kernel._estimate_column_wise_covariances", "scipy.linalg.cho_solve", "kernel._estimate_column_wise_covariances", "kernel._estimate_column_wise_covariances", "range", "joblib.Parallel", "dowhy.gcm.util.general.shape_into_2d", "numpy.random.choice", "approx_kernel", "approx_kernel", "approx_kernel", "scipy.linalg.cho_factor", "numpy.eye", "permutation_results_of_statistic.append", "numpy.iinfo", "kernel._estimate_rit_statistic", "numpy.sum", "len", "joblib.delayed", "range", "numpy.eye", "kernel._estimate_rit_statistic", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._convert_to_numeric", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_column_wise_covariances", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_column_wise_covariances", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_column_wise_covariances", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_rit_statistic", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_rit_statistic"], ["", "def", "_rcit", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ",", "Z", ":", "np", ".", "ndarray", ",", "\n", "num_random_features_X", ":", "int", ",", "\n", "num_random_features_Y", ":", "int", ",", "\n", "num_random_features_Z", ":", "int", ",", "\n", "num_permutations", ":", "int", ",", "\n", "num_runs", ":", "int", ",", "\n", "num_max_samples_per_run", ":", "int", ",", "\n", "approx_kernel", ":", "Callable", "[", "[", "np", ".", "ndarray", ",", "int", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "scale_data", ":", "bool", ",", "\n", "n_jobs", ":", "Optional", "[", "int", "]", ",", "\n", "p_value_adjust_func", ":", "Callable", "[", "[", "Union", "[", "np", ".", "ndarray", ",", "List", "[", "float", "]", "]", "]", ",", "float", "]", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Implementation of the Randomized Conditional Independence Test based on the work:\n        Strobl, Eric V., Kun Zhang, and Shyam Visweswaran.\n        Approximate kernel-based conditional independence tests for fast non-parametric causal discovery.\n        Journal of Causal Inference 7.1 (2019).\n    \"\"\"", "\n", "n_jobs", "=", "config", ".", "default_n_jobs", "if", "n_jobs", "is", "None", "else", "n_jobs", "\n", "\n", "X", ",", "Y", ",", "Z", "=", "_convert_to_numeric", "(", "*", "shape_into_2d", "(", "X", ",", "Y", ",", "Z", ")", ")", "\n", "\n", "if", "scale_data", ":", "\n", "        ", "X", "=", "scale", "(", "X", ")", "\n", "Y", "=", "scale", "(", "Y", ")", "\n", "Z", "=", "scale", "(", "Z", ")", "\n", "\n", "", "def", "parallel_job", "(", "parallel_random_seed", ":", "int", ")", ":", "\n", "        ", "set_random_seed", "(", "parallel_random_seed", ")", "\n", "\n", "if", "X", ".", "shape", "[", "0", "]", ">", "num_max_samples_per_run", ":", "\n", "            ", "random_indices", "=", "np", ".", "random", ".", "choice", "(", "X", ".", "shape", "[", "0", "]", ",", "num_max_samples_per_run", ",", "replace", "=", "False", ")", "\n", "X_samples", "=", "X", "[", "random_indices", "]", "\n", "Y_samples", "=", "Y", "[", "random_indices", "]", "\n", "Z_samples", "=", "Z", "[", "random_indices", "]", "\n", "", "else", ":", "\n", "            ", "X_samples", "=", "X", "\n", "Y_samples", "=", "Y", "\n", "Z_samples", "=", "Z", "\n", "\n", "", "Y_samples", "=", "np", ".", "column_stack", "(", "[", "Y_samples", ",", "Z_samples", "]", ")", "\n", "random_features_x", "=", "scale", "(", "approx_kernel", "(", "X_samples", ",", "num_random_features_X", ")", ")", "\n", "random_features_y", "=", "scale", "(", "approx_kernel", "(", "Y_samples", ",", "num_random_features_Y", ")", ")", "\n", "random_features_z", "=", "scale", "(", "approx_kernel", "(", "Z_samples", ",", "num_random_features_Z", ")", ")", "\n", "\n", "cov_zz", "=", "_estimate_column_wise_covariances", "(", "random_features_z", ",", "random_features_z", ")", "\n", "inverse_cov_zz", "=", "scipy", ".", "linalg", ".", "cho_solve", "(", "\n", "scipy", ".", "linalg", ".", "cho_factor", "(", "cov_zz", "+", "np", ".", "eye", "(", "cov_zz", ".", "shape", "[", "0", "]", ")", "*", "10", "**", "-", "10", ",", "lower", "=", "True", ")", ",", "\n", "np", ".", "eye", "(", "cov_zz", ".", "shape", "[", "0", "]", ")", ")", "\n", "cov_xz", "=", "_estimate_column_wise_covariances", "(", "random_features_x", ",", "random_features_z", ")", "\n", "cov_zy", "=", "_estimate_column_wise_covariances", "(", "random_features_z", ",", "random_features_y", ")", "\n", "\n", "z_inverse_cov_zz", "=", "random_features_z", "@", "inverse_cov_zz", "\n", "\n", "residual_x", "=", "random_features_x", "-", "z_inverse_cov_zz", "@", "cov_xz", ".", "T", "\n", "residual_y", "=", "random_features_y", "-", "z_inverse_cov_zz", "@", "cov_zy", "\n", "\n", "# Estimate test statistic multiple times on different permutations of the data. The p-value is then the", "\n", "# probability (i.e. fraction) of obtaining a test statistic that is greater than statistic on the non-permuted", "\n", "# data.", "\n", "permutation_results_of_statistic", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_permutations", ")", ":", "\n", "            ", "permutation_results_of_statistic", ".", "append", "(", "_estimate_rit_statistic", "(", "\n", "residual_x", "[", "np", ".", "random", ".", "choice", "(", "residual_x", ".", "shape", "[", "0", "]", ",", "\n", "residual_x", ".", "shape", "[", "0", "]", ",", "replace", "=", "False", ")", "]", ",", "residual_y", ")", ")", "\n", "\n", "", "return", "1", "-", "(", "np", ".", "sum", "(", "_estimate_rit_statistic", "(", "residual_x", ",", "residual_y", ")", ">", "permutation_results_of_statistic", ")", "\n", "/", "len", "(", "permutation_results_of_statistic", ")", ")", "\n", "\n", "", "random_seeds", "=", "np", ".", "random", ".", "randint", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ",", "size", "=", "num_runs", ")", "\n", "p_values", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "delayed", "(", "parallel_job", ")", "(", "random_seeds", "[", "i", "]", ")", "for", "i", "in", "range", "(", "num_runs", ")", ")", "\n", "\n", "return", "p_value_adjust_func", "(", "p_values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_rit_statistic": [[507, 509], ["numpy.sum", "kernel._estimate_column_wise_covariances"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_column_wise_covariances"], ["", "def", "_estimate_rit_statistic", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "return", "X", ".", "shape", "[", "0", "]", "*", "np", ".", "sum", "(", "_estimate_column_wise_covariances", "(", "X", ",", "Y", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._estimate_column_wise_covariances": [[511, 513], ["numpy.cov"], "function", ["None"], ["", "def", "_estimate_column_wise_covariances", "(", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "return", "np", ".", "cov", "(", "X", ",", "Y", ",", "rowvar", "=", "False", ")", "[", ":", "X", ".", "shape", "[", "1", "]", ",", "-", "Y", ".", "shape", "[", "1", "]", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._convert_to_numeric": [[515, 517], ["dowhy.gcm.util.general.apply_one_hot_encoding", "dowhy.gcm.util.general.fit_one_hot_encoders"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders"], ["", "def", "_convert_to_numeric", "(", "*", "args", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "    ", "return", "[", "apply_one_hot_encoding", "(", "X", ",", "fit_one_hot_encoders", "(", "X", ")", ")", "for", "X", "in", "args", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based": [[14, 110], ["dowhy.gcm.util.general.shape_into_2d", "sklearn.preprocessing.scale", "sklearn.preprocessing.scale", "range", "p_value_adjust_func", "ValueError", "dowhy.gcm.util.general.apply_one_hot_encoding", "dowhy.gcm.util.general.apply_one_hot_encoding", "dowhy.gcm.util.general.shape_into_2d", "sklearn.preprocessing.scale", "all_p_values.append", "dowhy.gcm.util.general.fit_one_hot_encoders", "dowhy.gcm.util.general.fit_one_hot_encoders", "dowhy.gcm.util.general.apply_one_hot_encoding", "numpy.random.choice", "sklearn.kernel_approximation.Nystroem().fit_transform", "sklearn.kernel_approximation.Nystroem().fit_transform", "sklearn.kernel_approximation.Nystroem().fit_transform", "numpy.array().reshape", "int", "numpy.random.choice", "numpy.arange", "dowhy.gcm.stats.estimate_ftest_pvalue", "dowhy.gcm.util.general.fit_one_hot_encoders", "numpy.column_stack", "sklearn.kernel_approximation.Nystroem", "sklearn.kernel_approximation.Nystroem", "sklearn.kernel_approximation.Nystroem", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.apply_one_hot_encoding", "home.repos.pwc.inspect_result.microsoft_dowhy.gcm.stats.estimate_ftest_pvalue", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.fit_one_hot_encoders"], ["", "from", "sklearn", ".", "ensemble", "import", "RandomForestRegressor", ",", "HistGradientBoostingRegressor", ",", "ExtraTreesRegressor", ",", "AdaBoostRegressor", "\n", "from", "sklearn", ".", "gaussian_process", "import", "GaussianProcessRegressor", "\n", "from", "sklearn", ".", "linear_model", "import", "LinearRegression", ",", "RidgeCV", ",", "LassoCV", ",", "LassoLarsIC", ",", "ElasticNetCV", "\n", "from", "sklearn", ".", "neighbors", "import", "KNeighborsRegressor", "\n", "from", "sklearn", ".", "svm", "import", "SVR", "\n", "\n", "from", "dowhy", ".", "gcm", ".", "fcms", "import", "InvertibleFunction", ",", "PredictionModel", "\n", "from", "dowhy", ".", "gcm", ".", "util", ".", "general", "import", "shape_into_2d", ",", "fit_one_hot_encoders", ",", "apply_one_hot_encoding", "\n", "\n", "\n", "class", "SklearnRegressionModel", "(", "PredictionModel", ")", ":", "\n", "    ", "\"\"\"\n        General wrapper class for sklearn models.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "sklearn_mdl", ":", "Any", ")", "->", "None", ":", "\n", "        ", "self", ".", "_sklearn_mdl", "=", "sklearn_mdl", "\n", "self", ".", "_one_hot_encoders", "=", "{", "}", "\n", "\n", "", "def", "fit", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "self", ".", "_one_hot_encoders", "=", "fit_one_hot_encoders", "(", "X", ")", "\n", "X", "=", "apply_one_hot_encoding", "(", "X", ",", "self", ".", "_one_hot_encoders", ")", "\n", "\n", "self", ".", "_sklearn_mdl", ".", "fit", "(", "X", "=", "X", ",", "y", "=", "Y", ".", "squeeze", "(", ")", ")", "\n", "\n", "", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "array", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "shape_into_2d", "(", "\n", "self", ".", "_sklearn_mdl", ".", "predict", "(", "apply_one_hot_encoding", "(", "X", ",", "self", ".", "_one_hot_encoders", ")", ")", ")", "\n", "\n", "", "@", "property", "\n", "def", "sklearn_model", "(", "self", ")", "->", "Any", ":", "\n", "        ", "return", "self", ".", "_sklearn_mdl", "\n", "\n", "", "def", "clone", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Clones the prediction model using the same hyper parameters but not fitted.\n\n        :return: An unfitted clone of the prediction model.\n        \"\"\"", "\n", "return", "SklearnRegressionModel", "(", "sklearn_mdl", "=", "sklearn", ".", "clone", "(", "self", ".", "_sklearn_mdl", ")", ")", "\n", "\n", "\n", "", "", "def", "create_linear_regressor_with_given_parameters", "(", "coefficients", ":", "np", ".", "ndarray", ",", "\n", "intercept", ":", "float", "=", "0", ",", "\n", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "linear_model", "=", "LinearRegression", "(", "**", "kwargs", ")", "\n", "linear_model", ".", "coef_", "=", "coefficients", "\n", "linear_model", ".", "intercept_", "=", "intercept", "\n", "\n", "return", "SklearnRegressionModel", "(", "linear_model", ")", "\n", "\n", "\n", "", "def", "create_linear_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "LinearRegression", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_ridge_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "RidgeCV", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_lasso_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "LassoCV", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_lasso_lars_ic_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "LassoLarsIC", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_elastic_net_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "ElasticNetCV", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_gaussian_process_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "GaussianProcessRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_support_vector_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "SVR", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_random_forest_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "RandomForestRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_hist_gradient_boost_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "HistGradientBoostingRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_extra_trees_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "ExtraTreesRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n", "", "def", "create_knn_regressor", "(", "**", "kwargs", ")", "->", "SklearnRegressionModel", ":", "\n", "    ", "return", "SklearnRegressionModel", "(", "KNeighborsRegressor", "(", "**", "kwargs", ")", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation.apply_rbf_kernel": [[14, 31], ["dowhy.gcm.util.general.shape_into_2d", "sklearn.metrics.euclidean_distances", "numpy.exp", "kernel_operation._median_based_precision"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation._median_based_precision"], ["def", "apply_rbf_kernel", "(", "X", ":", "np", ".", "ndarray", ",", "\n", "precision", ":", "Optional", "[", "float", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Estimates the RBF (Gaussian) kernel for the given input data.\n\n    :param X: Input data.\n    :param precision: Specific precision matrix for the RBF kernel. If None is given, this is inferred from the data.\n    :return: The outcome of applying a RBF (Gaussian) kernel on the data.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "distance_matrix", "=", "euclidean_distances", "(", "X", ",", "squared", "=", "True", ")", "\n", "\n", "if", "precision", "is", "None", ":", "\n", "        ", "precision", "=", "_median_based_precision", "(", "X", ")", "\n", "\n", "", "return", "np", ".", "exp", "(", "-", "precision", "*", "distance_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation.apply_delta_kernel": [[33, 41], ["dowhy.gcm.util.general.shape_into_2d", "numpy.array().reshape().astype", "numpy.array().reshape", "numpy.array", "list", "map"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "apply_delta_kernel", "(", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Applies the delta kernel, i.e. the distance is 1 if two entries are equal and 0 otherwise.\n\n    :param X: Input data.\n    :return: The outcome of the delta-kernel, a binary distance matrix.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "return", "np", ".", "array", "(", "list", "(", "map", "(", "lambda", "value", ":", "value", "==", "X", ",", "X", ")", ")", ")", ".", "reshape", "(", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation.approximate_rbf_kernel_features": [[43, 60], ["dowhy.gcm.util.general.shape_into_2d", "sklearn.kernel_approximation.Nystroem().fit_transform", "kernel_operation._median_based_precision", "sklearn.kernel_approximation.Nystroem"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation._median_based_precision"], ["", "def", "approximate_rbf_kernel_features", "(", "X", ":", "np", ".", "ndarray", ",", "\n", "num_random_components", ":", "int", ",", "\n", "precision", ":", "Optional", "[", "float", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Applies the Nystroem method to create a NxD (D << N) approximated RBF kernel map using a subset of the data,\n    where N is the number of samples in X and D the number of components.\n\n    :param X: Input data.\n    :param num_random_components: Number of components D for the approximated kernel map.\n    :param precision: Specific precision matrix for the RBF kernel. If None is given, this is inferred from the data.\n    :return: A NxD approximated RBF kernel map, where N is the number of samples in X and D the number of components.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "if", "precision", "is", "None", ":", "\n", "        ", "precision", "=", "_median_based_precision", "(", "X", ")", "\n", "\n", "", "return", "Nystroem", "(", "kernel", "=", "'rbf'", ",", "gamma", "=", "precision", ",", "n_components", "=", "num_random_components", ")", ".", "fit_transform", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation.approximate_delta_kernel_features": [[62, 83], ["dowhy.gcm.util.general.shape_into_2d", "enumerate", "sklearn.kernel_approximation.Nystroem().fit_transform", "float", "numpy.unique", "dowhy.gcm.util.general.shape_into_2d.astype", "sklearn.kernel_approximation.Nystroem"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d"], ["", "def", "approximate_delta_kernel_features", "(", "X", ":", "np", ".", "ndarray", ",", "num_random_components", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Applies the Nystroem method to create a NxD (D << N) approximated delta kernel map using a subset of the data,\n    where N is the number of samples in X and D the number of components. The delta kernel gives 1 if two entries are\n    equal and 0 otherwise.\n\n    :param X: Input data.\n    :param num_random_components: Number of components D for the approximated kernel map.\n    :return: A NxD approximated RBF kernel map, where N is the number of samples in X and D the number of components.\n    \"\"\"", "\n", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "def", "delta_function", "(", "x", ",", "y", ")", "->", "float", ":", "\n", "        ", "return", "float", "(", "x", "==", "y", ")", "\n", "\n", "", "for", "i", ",", "unique_element", "in", "enumerate", "(", "np", ".", "unique", "(", "X", ")", ")", ":", "\n", "        ", "X", "[", "X", "==", "unique_element", "]", "=", "i", "\n", "\n", "", "result", "=", "Nystroem", "(", "kernel", "=", "delta_function", ",", "n_components", "=", "num_random_components", ")", ".", "fit_transform", "(", "X", ".", "astype", "(", "int", ")", ")", "\n", "result", "[", "result", "!=", "0", "]", "=", "1", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation.auto_create_list_of_kernels": [[85, 96], ["dowhy.gcm.util.general.shape_into_2d", "range", "dowhy.gcm.util.general.is_categorical", "tmp_list.append", "tmp_list.append"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical"], ["", "def", "auto_create_list_of_kernels", "(", "X", ":", "np", ".", "ndarray", ")", "->", "List", "[", "Callable", "[", "[", "np", ".", "ndarray", "]", ",", "np", ".", "ndarray", "]", "]", ":", "\n", "    ", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "tmp_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "if", "not", "is_categorical", "(", "X", "[", ":", ",", "i", "]", ")", ":", "\n", "            ", "tmp_list", ".", "append", "(", "apply_rbf_kernel", ")", "\n", "", "else", ":", "\n", "            ", "tmp_list", ".", "append", "(", "apply_delta_kernel", ")", "\n", "\n", "", "", "return", "tmp_list", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation.auto_create_list_of_kernel_approximations": [[98, 109], ["dowhy.gcm.util.general.shape_into_2d", "range", "dowhy.gcm.util.general.is_categorical", "tmp_list.append", "tmp_list.append"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.shape_into_2d", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.is_categorical"], ["", "def", "auto_create_list_of_kernel_approximations", "(", "X", ":", "np", ".", "ndarray", ")", "->", "List", "[", "Callable", "[", "[", "np", ".", "ndarray", ",", "int", "]", ",", "np", ".", "ndarray", "]", "]", ":", "\n", "    ", "X", "=", "shape_into_2d", "(", "X", ")", "\n", "\n", "tmp_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "if", "not", "is_categorical", "(", "X", "[", ":", ",", "i", "]", ")", ":", "\n", "            ", "tmp_list", ".", "append", "(", "approximate_rbf_kernel_features", ")", "\n", "", "else", ":", "\n", "            ", "tmp_list", ".", "append", "(", "approximate_delta_kernel_features", ")", "\n", "\n", "", "", "return", "tmp_list", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel_operation._median_based_precision": [[111, 117], ["numpy.sqrt", "tmp.reshape.reshape", "sklearn.metrics.euclidean_distances", "numpy.tril", "numpy.median"], "function", ["None"], ["", "def", "_median_based_precision", "(", "X", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "tmp", "=", "np", ".", "sqrt", "(", "euclidean_distances", "(", "X", ",", "squared", "=", "True", ")", ")", "\n", "tmp", "=", "tmp", "-", "np", ".", "tril", "(", "tmp", ",", "-", "1", ")", "\n", "tmp", "=", "tmp", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "return", "1", "/", "np", ".", "median", "(", "tmp", "[", "tmp", ">", "0", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.__init__.independence_test": [[5, 38], ["kernel.kernel_based", "kernel.approx_kernel_based", "regression.regression_based", "ValueError"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["logging", ".", "getLogger", "(", "__name__", ")", ".", "addHandler", "(", "logging", ".", "NullHandler", "(", ")", ")", "\n", "\n", "here", "=", "path", ".", "abspath", "(", "path", ".", "dirname", "(", "__file__", ")", ")", "\n", "# Loading version number", "\n", "with", "open", "(", "path", ".", "join", "(", "here", ",", "'VERSION'", ")", ")", "as", "version_file", ":", "\n", "    ", "__version__", "=", "version_file", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.preserve_random_generator_state": [[12, 19], ["numpy.random.get_state", "random.getstate", "numpy.random.set_state", "random.setstate"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "preserve_random_generator_state", "(", ")", ":", "\n", "    ", "numpy_state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "random_state", "=", "random", ".", "getstate", "(", ")", "\n", "yield", "\n", "np", ".", "random", ".", "set_state", "(", "numpy_state", ")", "\n", "random", ".", "setstate", "(", "random_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_conditional_independence_test_independent": [[21, 28], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.regression_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_regression_based_conditional_independence_test_independent", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "regression_based", "(", "x", ",", "y", ",", "z", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_conditional_independence_test_dependent": [[30, 38], ["flaky.flaky", "numpy.random.randn", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.regression_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_regression_based_conditional_independence_test_dependent", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "w", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "0.05", ">", "regression_based", "(", "x", ",", "y", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_conditional_independence_test_categorical_independent": [[40, 45], ["flaky.flaky", "tests.gcm.independence_test.test_kernel._generate_categorical_data", "dowhy.gcm.independence_test.regression_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel._generate_categorical_data", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_regression_based_conditional_independence_test_categorical_independent", "(", ")", ":", "\n", "    ", "x", ",", "y", ",", "z", "=", "_generate_categorical_data", "(", ")", "\n", "\n", "assert", "regression_based", "(", "x", ",", "y", ",", "z", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_conditional_independence_test_categorical_dependent": [[108, 113], ["flaky.flaky", "tests.gcm.independence_test.test_kernel._generate_categorical_data", "dowhy.gcm.independence_test.regression_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel._generate_categorical_data", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_regression_based_conditional_independence_test_categorical_dependent", "(", ")", ":", "\n", "    ", "x", ",", "y", ",", "z", "=", "_generate_categorical_data", "(", ")", "\n", "\n", "assert", "regression_based", "(", "x", ",", "z", ",", "y", ")", "<", "0.05", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_pairwise_independence_test_independent": [[54, 61], ["flaky.flaky", "numpy.random.randn", "numpy.random.randn", "numpy.exp", "dowhy.gcm.independence_test.regression_based", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_regression_based_pairwise_independence_test_independent", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "w", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "regression_based", "(", "x", ",", "w", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_pairwise_independence_test_dependent": [[63, 70], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.regression_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_regression_based_pairwise_independence_test_dependent", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "regression_based", "(", "x", ",", "y", ")", "<", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_pairwise_independence_test_categorical_independent": [[72, 78], ["flaky.flaky", "numpy.random.normal", "numpy.random.choice().astype", "dowhy.gcm.independence_test.regression_based", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_regression_based_pairwise_independence_test_categorical_independent", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "y", "=", "np", ".", "random", ".", "choice", "(", "2", ",", "1000", ")", ".", "astype", "(", "str", ")", "\n", "\n", "assert", "regression_based", "(", "x", ",", "y", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_pairwise_independence_test_categorical_dependent": [[80, 93], ["flaky.flaky", "numpy.random.normal", "numpy.array().astype", "dowhy.gcm.independence_test.regression_based", "np.array().astype.append", "np.array().astype.append", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_regression_based_pairwise_independence_test_categorical_dependent", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "y", "=", "[", "]", "\n", "\n", "for", "v", "in", "x", ":", "\n", "        ", "if", "v", ">", "0", ":", "\n", "            ", "y", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "y", ".", "append", "(", "1", ")", "\n", "", "", "y", "=", "np", ".", "array", "(", "y", ")", ".", "astype", "(", "str", ")", "\n", "\n", "assert", "regression_based", "(", "x", ",", "y", ")", "<", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_regression.test_regression_based_conditional_independence_parallelization": [[95, 106], ["numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.util.general.set_random_seed", "dowhy.gcm.independence_test.regression_based", "dowhy.gcm.util.general.set_random_seed", "dowhy.gcm.independence_test.regression_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based", "home.repos.pwc.inspect_result.microsoft_dowhy.util.general.set_random_seed", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.regression.regression_based"], ["", "def", "test_regression_based_conditional_independence_parallelization", "(", "preserve_random_generator_state", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "set_random_seed", "(", "0", ")", "\n", "p_value_1", "=", "regression_based", "(", "x", ",", "y", ",", "z", ")", "\n", "set_random_seed", "(", "0", ")", "\n", "p_value_2", "=", "regression_based", "(", "x", ",", "y", ",", "z", ")", "\n", "\n", "assert", "p_value_1", "==", "p_value_2", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_continuous_conditionally_independent_data_when_perform_kernel_based_test_then_not_reject": [[12, 19], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.kernel_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_conditionally_independent_data_when_perform_kernel_based_test_then_not_reject", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "y", ",", "z", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_continuous_conditionally_dependent_data_when_perform_kernel_based_test_then_reject": [[21, 29], ["flaky.flaky", "numpy.random.randn", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.kernel_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_conditionally_dependent_data_when_perform_kernel_based_test_then_reject", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "w", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "0.05", ">", "kernel_based", "(", "x", ",", "y", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_categorical_conditionally_independent_data_when_perform_kernel_based_test_then_not_reject": [[31, 36], ["flaky.flaky", "test_kernel._generate_categorical_data", "dowhy.gcm.independence_test.kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel._generate_categorical_data", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_conditionally_independent_data_when_perform_kernel_based_test_then_not_reject", "(", ")", ":", "\n", "    ", "x", ",", "y", ",", "z", "=", "_generate_categorical_data", "(", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "y", ",", "z", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_categorical_conditionally_dependent_data_when_perform_kernel_based_test_then_reject": [[38, 43], ["flaky.flaky", "test_kernel._generate_categorical_data", "dowhy.gcm.independence_test.kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel._generate_categorical_data", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_conditionally_dependent_data_when_perform_kernel_based_test_then_reject", "(", ")", ":", "\n", "    ", "x", ",", "y", ",", "z", "=", "_generate_categorical_data", "(", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "z", ",", "y", ")", "<", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_random_seed_when_perform_conditional_kernel_based_test_then_return_deterministic_result": [[45, 72], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.exp", "numpy.random.seed", "dowhy.gcm.independence_test.kernel_based", "numpy.random.seed", "dowhy.gcm.independence_test.kernel_based", "dowhy.gcm.independence_test.kernel_based", "dowhy.gcm.independence_test.kernel_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_random_seed_when_perform_conditional_kernel_based_test_then_return_deterministic_result", "(", "_preserve_random_generator_state", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "z", ",", "y", ",", "\n", "bootstrap_num_samples_per_run", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "2", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "!=", "kernel_based", "(", "x", ",", "z", ",", "y", ",", "\n", "bootstrap_num_samples_per_run", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "2", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result_1", "=", "kernel_based", "(", "x", ",", "z", ",", "y", ",", "\n", "bootstrap_num_samples_per_run", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "2", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result_2", "=", "kernel_based", "(", "x", ",", "z", ",", "y", ",", "\n", "bootstrap_num_samples_per_run", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "2", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "\n", "assert", "result_1", "==", "result_2", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_too_few_samples_when_perform_kernel_based_test_then_raise_error": [[74, 78], ["pytest.raises", "dowhy.gcm.independence_test.kernel_based", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "def", "test_given_too_few_samples_when_perform_kernel_based_test_then_raise_error", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "kernel_based", "(", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "1", ",", "3", ",", "2", ",", "4", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_continuous_independent_data_when_perform_kernel_based_test_then_not_reject": [[80, 86], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.random.rand", "dowhy.gcm.independence_test.kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_independent_data_when_perform_kernel_based_test_then_not_reject", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "y", "=", "np", ".", "exp", "(", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "y", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_continuous_dependent_data_when_perform_kernel_based_test_then_reject": [[88, 95], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.kernel_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_dependent_data_when_perform_kernel_based_test_then_reject", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "y", ")", "<", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_categorical_independent_data_when_perform_kernel_based_test_then_not_reject": [[97, 103], ["flaky.flaky", "numpy.random.normal", "dowhy.gcm.independence_test.kernel_based", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_independent_data_when_perform_kernel_based_test_then_not_reject", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "y", "=", "(", "np", ".", "random", ".", "choice", "(", "2", ",", "1000", ")", "==", "1", ")", ".", "astype", "(", "str", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "y", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_categorical_dependent_data_when_perform_kernel_based_test_then_reject": [[105, 118], ["flaky.flaky", "numpy.random.normal", "numpy.array().astype", "dowhy.gcm.independence_test.kernel_based", "np.array().astype.append", "np.array().astype.append", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_dependent_data_when_perform_kernel_based_test_then_reject", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "y", "=", "[", "]", "\n", "\n", "for", "v", "in", "x", ":", "\n", "        ", "if", "v", ">", "0", ":", "\n", "            ", "y", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "y", ".", "append", "(", "1", ")", "\n", "", "", "y", "=", "np", ".", "array", "(", "y", ")", ".", "astype", "(", "str", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "y", ")", "<", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_random_seed_when_perform_pairwise_kernel_based_test_then_return_deterministic_result": [[120, 144], ["flaky.flaky", "numpy.random.randn", "numpy.random.seed", "dowhy.gcm.independence_test.kernel_based", "numpy.random.seed", "dowhy.gcm.independence_test.kernel_based", "numpy.random.randn", "dowhy.gcm.independence_test.kernel_based", "dowhy.gcm.independence_test.kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_random_seed_when_perform_pairwise_kernel_based_test_then_return_deterministic_result", "(", "_preserve_random_generator_state", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "y", "=", "x", "+", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "\n", "assert", "kernel_based", "(", "x", ",", "y", ",", "\n", "bootstrap_num_samples_per_run", "=", "10", ",", "\n", "bootstrap_num_runs", "=", "2", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "!=", "kernel_based", "(", "x", ",", "y", ",", "\n", "bootstrap_num_samples_per_run", "=", "10", ",", "\n", "bootstrap_num_runs", "=", "2", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result_1", "=", "kernel_based", "(", "x", ",", "y", ",", "bootstrap_num_samples_per_run", "=", "10", ",", "\n", "bootstrap_num_runs", "=", "2", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result_2", "=", "kernel_based", "(", "x", ",", "y", ",", "bootstrap_num_samples_per_run", "=", "10", ",", "\n", "bootstrap_num_runs", "=", "2", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "\n", "assert", "result_1", "==", "result_2", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_constant_inputs_when_perform_kernel_based_test_then_returns_non_nan_value": [[146, 148], ["dowhy.gcm.independence_test.kernel_based", "numpy.random.normal", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "def", "test_given_constant_inputs_when_perform_kernel_based_test_then_returns_non_nan_value", "(", ")", ":", "\n", "    ", "assert", "kernel_based", "(", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "1000", ",", "2", ")", ")", ",", "np", ".", "array", "(", "[", "5", "]", "*", "1000", ")", ")", "!=", "np", ".", "nan", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_continuous_conditionally_independent_data_when_perform_approx_kernel_based_test_then_not_reject": [[150, 157], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.approx_kernel_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_conditionally_independent_data_when_perform_approx_kernel_based_test_then_not_reject", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "approx_kernel_based", "(", "x", ",", "y", ",", "z", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_continuous_conditionally_dependent_data_when_perform_approx_kernel_based_test_then_reject": [[159, 167], ["flaky.flaky", "numpy.random.randn", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.approx_kernel_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_conditionally_dependent_data_when_perform_approx_kernel_based_test_then_reject", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "w", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "0.05", ">", "approx_kernel_based", "(", "x", ",", "y", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_categorical_conditionally_independent_data_when_perform_approx_kernel_based_test_then_not_reject": [[169, 174], ["flaky.flaky", "test_kernel._generate_categorical_data", "dowhy.gcm.independence_test.approx_kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel._generate_categorical_data", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_conditionally_independent_data_when_perform_approx_kernel_based_test_then_not_reject", "(", ")", ":", "\n", "    ", "x", ",", "y", ",", "z", "=", "_generate_categorical_data", "(", ")", "\n", "\n", "assert", "approx_kernel_based", "(", "x", ",", "y", ",", "z", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_categorical_conditionally_dependent_data_when_perform_approx_kernel_based_test_then_reject": [[176, 181], ["flaky.flaky", "test_kernel._generate_categorical_data", "dowhy.gcm.independence_test.approx_kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel._generate_categorical_data", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_conditionally_dependent_data_when_perform_approx_kernel_based_test_then_reject", "(", ")", ":", "\n", "    ", "x", ",", "y", ",", "z", "=", "_generate_categorical_data", "(", ")", "\n", "\n", "assert", "approx_kernel_based", "(", "x", ",", "z", ",", "y", ")", "<", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_random_seed_when_perform_conditional_approx_kernel_based_test_then_return_deterministic_result": [[183, 230], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.exp", "numpy.random.seed", "dowhy.gcm.independence_test.approx_kernel_based", "numpy.random.seed", "dowhy.gcm.independence_test.approx_kernel_based", "dowhy.gcm.independence_test.approx_kernel_based", "dowhy.gcm.independence_test.approx_kernel_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_random_seed_when_perform_conditional_approx_kernel_based_test_then_return_deterministic_result", "(", "_preserve_random_generator_state", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "approx_kernel_based", "(", "x", ",", "\n", "z", ",", "\n", "y", ",", "\n", "num_random_features_X", "=", "1", ",", "\n", "num_random_features_Y", "=", "1", ",", "\n", "num_random_features_Z", "=", "1", ",", "\n", "bootstrap_num_samples", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "10", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "!=", "approx_kernel_based", "(", "x", ",", "\n", "z", ",", "\n", "y", ",", "\n", "num_random_features_X", "=", "1", ",", "\n", "num_random_features_Y", "=", "1", ",", "\n", "num_random_features_Z", "=", "1", ",", "\n", "bootstrap_num_samples", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "10", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result_1", "=", "approx_kernel_based", "(", "x", ",", "\n", "z", ",", "\n", "y", ",", "\n", "num_random_features_X", "=", "1", ",", "\n", "num_random_features_Y", "=", "1", ",", "\n", "num_random_features_Z", "=", "1", ",", "\n", "bootstrap_num_samples", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "10", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result_2", "=", "approx_kernel_based", "(", "x", ",", "\n", "z", ",", "\n", "y", ",", "\n", "num_random_features_X", "=", "1", ",", "\n", "num_random_features_Y", "=", "1", ",", "\n", "num_random_features_Z", "=", "1", ",", "\n", "bootstrap_num_samples", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "10", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "\n", "assert", "result_1", "==", "result_2", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_continuous_independent_data_when_perform_approx_kernel_based_test_then_not_reject": [[232, 237], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.random.rand", "dowhy.gcm.independence_test.approx_kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_independent_data_when_perform_approx_kernel_based_test_then_not_reject", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "y", "=", "np", ".", "exp", "(", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "assert", "approx_kernel_based", "(", "x", ",", "y", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_continuous_dependent_data_when_perform_approx_kernel_based_test_then_reject": [[239, 246], ["flaky.flaky", "numpy.random.randn", "numpy.exp", "numpy.exp", "dowhy.gcm.independence_test.approx_kernel_based", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_continuous_dependent_data_when_perform_approx_kernel_based_test_then_reject", "(", ")", ":", "\n", "    ", "z", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "exp", "(", "z", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", ")", "\n", "\n", "assert", "approx_kernel_based", "(", "x", ",", "y", ")", "<", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_categorical_independent_data_when_perform_approx_kernel_based_test_then_not_reject": [[248, 256], ["flaky.flaky", "numpy.random.normal", "numpy.random.choice().astype", "dowhy.gcm.independence_test.approx_kernel_based", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_independent_data_when_perform_approx_kernel_based_test_then_not_reject", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "y", "=", "np", ".", "random", ".", "choice", "(", "2", ",", "1000", ")", ".", "astype", "(", "str", ")", "\n", "y", "[", "y", "==", "'0'", "]", "=", "'Class 1'", "\n", "y", "[", "y", "==", "'1'", "]", "=", "'Class 2'", "\n", "\n", "assert", "approx_kernel_based", "(", "x", ",", "y", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_categorical_dependent_data_when_perform_approx_kernel_based_test_then_reject": [[258, 271], ["flaky.flaky", "numpy.random.normal", "numpy.array().astype", "dowhy.gcm.independence_test.approx_kernel_based", "np.array().astype.append", "np.array().astype.append", "numpy.array"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "5", ")", "\n", "def", "test_given_categorical_dependent_data_when_perform_approx_kernel_based_test_then_reject", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "y", "=", "[", "]", "\n", "\n", "for", "v", "in", "x", ":", "\n", "        ", "if", "v", ">", "0", ":", "\n", "            ", "y", ".", "append", "(", "'Class 1'", ")", "\n", "", "else", ":", "\n", "            ", "y", ".", "append", "(", "'Class 2'", ")", "\n", "", "", "y", "=", "np", ".", "array", "(", "y", ")", ".", "astype", "(", "str", ")", "\n", "\n", "assert", "approx_kernel_based", "(", "x", ",", "y", ")", "<", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_random_seed_when_perform_pairwise_approx_kernel_based_test_then_return_deterministic_result": [[273, 311], ["flaky.flaky", "numpy.random.randn", "numpy.random.seed", "dowhy.gcm.independence_test.approx_kernel_based", "numpy.random.seed", "dowhy.gcm.independence_test.approx_kernel_based", "numpy.random.rand", "dowhy.gcm.independence_test.approx_kernel_based", "dowhy.gcm.independence_test.approx_kernel_based"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.approx_kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "2", ")", "\n", "def", "test_given_random_seed_when_perform_pairwise_approx_kernel_based_test_then_return_deterministic_result", "(", "_preserve_random_generator_state", ")", ":", "\n", "    ", "w", "=", "np", ".", "random", ".", "randn", "(", "1000", ",", "1", ")", "\n", "x", "=", "w", "+", "np", ".", "random", ".", "rand", "(", "1000", ",", "1", ")", "\n", "\n", "assert", "approx_kernel_based", "(", "x", ",", "\n", "w", ",", "\n", "num_random_features_X", "=", "1", ",", "\n", "num_random_features_Y", "=", "1", ",", "\n", "bootstrap_num_samples", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "10", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "!=", "approx_kernel_based", "(", "x", ",", "\n", "w", ",", "\n", "num_random_features_X", "=", "1", ",", "\n", "num_random_features_Y", "=", "1", ",", "\n", "bootstrap_num_samples", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "10", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result_1", "=", "approx_kernel_based", "(", "x", ",", "\n", "w", ",", "\n", "num_random_features_X", "=", "1", ",", "\n", "num_random_features_Y", "=", "1", ",", "\n", "bootstrap_num_samples", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "10", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result_2", "=", "approx_kernel_based", "(", "x", ",", "\n", "w", ",", "\n", "num_random_features_X", "=", "1", ",", "\n", "num_random_features_Y", "=", "1", ",", "\n", "bootstrap_num_samples", "=", "5", ",", "\n", "bootstrap_num_runs", "=", "10", ",", "\n", "p_value_adjust_func", "=", "np", ".", "mean", ")", "\n", "\n", "assert", "result_1", "==", "result_2", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_when_using_fast_centering_then_gives_expected_results": [[313, 319], ["numpy.random.normal", "numpy.identity", "dowhy.gcm.independence_test.kernel._fast_centering", "_pytest.python_api.approx", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel._fast_centering"], ["", "def", "test_when_using_fast_centering_then_gives_expected_results", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "(", "100", ",", "100", ")", ")", "\n", "\n", "h", "=", "np", ".", "identity", "(", "X", ".", "shape", "[", "0", "]", ")", "-", "np", ".", "ones", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "0", "]", ")", ",", "dtype", "=", "float", ")", "/", "X", ".", "shape", "[", "0", "]", "\n", "\n", "assert", "_fast_centering", "(", "X", ")", "==", "approx", "(", "h", "@", "X", "@", "h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel.test_given_weak_dependency_when_perform_kernel_based_test_then_returns_expected_result": [[321, 328], ["flaky.flaky", "numpy.random.choice", "numpy.sum", "dowhy.gcm.independence_test.kernel_based", "dowhy.gcm.independence_test.kernel_based", "numpy.random.uniform", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based", "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.kernel.kernel_based"], ["", "@", "flaky", "(", "max_runs", "=", "3", ")", "\n", "def", "test_given_weak_dependency_when_perform_kernel_based_test_then_returns_expected_result", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "random", ".", "choice", "(", "2", ",", "(", "10000", ",", "100", ")", ")", "# Require a lot of data here for the bootstraps.", "\n", "Y", "=", "np", ".", "sum", "(", "X", "*", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "5", ")", ",", "axis", "=", "1", ")", "\n", "\n", "assert", "kernel_based", "(", "X", "[", ":", ",", "0", "]", ",", "Y", ")", "<=", "0.05", "\n", "assert", "kernel_based", "(", "np", ".", "random", ".", "choice", "(", "2", ",", "(", "10000", ",", "1", ")", ")", ",", "Y", ")", ">", "0.05", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel._generate_categorical_data": [[330, 344], ["numpy.random.normal", "numpy.array().astype", "numpy.random.randn", "np.array().astype.append", "np.array().astype.append", "len", "numpy.array"], "function", ["None"], ["", "def", "_generate_categorical_data", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "1", ",", "1000", ")", "\n", "z", "=", "[", "]", "\n", "for", "v", "in", "x", ":", "\n", "        ", "if", "v", ">", "0", ":", "\n", "            ", "z", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "z", ".", "append", "(", "1", ")", "\n", "", "", "y", "=", "z", "+", "np", ".", "random", ".", "randn", "(", "len", "(", "z", ")", ")", "\n", "z", "=", "np", ".", "array", "(", "z", ")", ".", "astype", "(", "str", ")", "\n", "z", "[", "z", "==", "'0'", "]", "=", "'Class 1'", "\n", "z", "[", "z", "==", "'1'", "]", "=", "'Class 2'", "\n", "\n", "return", "x", ",", "y", ",", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.independence_test.test_kernel._preserve_random_generator_state": [[346, 353], ["numpy.random.get_state", "random.getstate", "numpy.random.set_state", "random.setstate"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "_preserve_random_generator_state", "(", ")", ":", "\n", "    ", "numpy_state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "random_state", "=", "random", ".", "getstate", "(", ")", "\n", "yield", "\n", "np", ".", "random", ".", "set_state", "(", "numpy_state", ")", "\n", "random", ".", "setstate", "(", "random_state", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.__init__": [[9, 20], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pandas_obj", ")", ":", "\n", "        ", "\"\"\"\n        An accessor for the pandas.DataFrame under the `causal` namespace.\n\n        :param pandas_obj:\n        \"\"\"", "\n", "self", ".", "_obj", "=", "pandas_obj", "\n", "self", ".", "_causal_model", "=", "None", "\n", "self", ".", "_sampler", "=", "None", "\n", "self", ".", "_identified_estimand", "=", "None", "\n", "self", ".", "_method", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.reset": [[21, 31], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        If a `causal` namespace method (especially `do`) was run statefully, this resets the namespace.\n\n        :return:\n        \"\"\"", "\n", "self", ".", "_causal_model", "=", "None", "\n", "self", ".", "_identified_estimand", "=", "None", "\n", "self", ".", "_sampler", "=", "None", "\n", "self", ".", "_method", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do": [[32, 123], ["causal_data_frame.CausalAccessor.parse_x", "dowhy.utils.api.parse_state", "causal_data_frame.CausalAccessor._sampler.do_sample", "causal_data_frame.CausalAccessor.reset", "dowhy.causal_model.CausalModel", "bool", "dict", "dict.keys", "dowhy.get_class_object", "dowhy.get_class_object.", "causal_data_frame.CausalAccessor.reset", "causal_data_frame.CausalAccessor.convert_to_custom_type", "len", "len", "dict", "dict.keys", "len", "len", "Exception", "x.keys", "causal_data_frame.CausalAccessor.convert_to_custom_type"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.parse_x", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.api.parse_state", "home.repos.pwc.inspect_result.microsoft_dowhy.do_samplers.mcmc_sampler.McmcSampler.do_sample", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.reset", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.reset", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.convert_to_custom_type", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.convert_to_custom_type"], ["", "def", "do", "(", "self", ",", "x", ",", "method", "=", "'weighting'", ",", "num_cores", "=", "1", ",", "variable_types", "=", "{", "}", ",", "outcome", "=", "None", ",", "params", "=", "None", ",", "dot_graph", "=", "None", ",", "\n", "common_causes", "=", "None", ",", "estimand_type", "=", "'nonparametric-ate'", ",", "proceed_when_unidentifiable", "=", "False", ",", "stateful", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        The do-operation implemented with sampling. This will return a pandas.DataFrame with the outcome\n        variable(s) replaced with samples from P(Y|do(X=x)).\n\n        If the value of `x` is left unspecified (e.g. as a string or list), then the original values of `x` are left in\n        the DataFrame, and Y is sampled from its respective P(Y|do(x)). If the value of `x` is specified (passed with a\n        `dict`, where variable names are keys, and values are specified) then the new `DataFrame` will contain the\n        specified values of `x`.\n\n        For some methods, the `variable_types` field must be specified. It should be a `dict`, where the keys are\n        variable names, and values are 'o' for ordered discrete, 'u' for un-ordered discrete, 'd' for discrete, or 'c'\n        for continuous.\n\n        Inference requires a set of control variables. These can be provided explicitly using `common_causes`, which\n        contains a list of variable names to control for. These can be provided implicitly by specifying a causal graph\n        with `dot_graph`, from which they will be chosen using the default identification method.\n\n        When the set of control variables can't be identified with the provided assumptions, a prompt will raise to the\n        user asking whether to proceed. To automatically over-ride the prompt, you can set the flag\n        `proceed_when_unidentifiable` to `True`.\n\n        Some methods build components during inference which are expensive. To retain those components for later\n        inference (e.g. successive calls to `do` with different values of `x`), you can set the `stateful` flag to `True`.\n        Be cautious about using the `do` operation statefully. State is set on the namespace, rather than the method, so\n        can behave unpredictably. To reset the namespace and run statelessly again, you can call the `reset` method.\n\n        :param x: str, list, dict: The causal state on which to intervene, and (optional) its interventional value(s).\n        :param method: The inference method to use with the sampler. Currently, `'mcmc'`, `'weighting'`, and\n            `'kernel_density'` are supported. The `mcmc` sampler requires `pymc3>=3.7`.\n        :param num_cores: int: if the inference method only supports sampling a point at a time, this will parallelize\n            sampling.\n        :param variable_types: dict: The dictionary containing the variable types. Must contain the union of the causal\n            state, control variables, and the outcome.\n        :param outcome: str: The outcome variable.\n        :param params: dict: extra parameters to set as attributes on the sampler object\n        :param dot_graph: str: A string specifying the causal graph.\n        :param common_causes: list: A list of strings containing the variable names to control for.\n        :param estimand_type: str: 'nonparametric-ate' is the only one currently supported. Others may be added later, to allow for specific, parametric estimands.\n        :param proceed_when_unidentifiable: bool: A flag to over-ride user prompts to proceed when effects aren't\n            identifiable with the assumptions provided.\n        :param stateful: bool: Whether to retain state. By default, the do operation is stateless.\n\n        :return: pandas.DataFrame: A DataFrame containing the sampled outcome\n        \"\"\"", "\n", "x", ",", "keep_original_treatment", "=", "self", ".", "parse_x", "(", "x", ")", "\n", "outcome", "=", "parse_state", "(", "outcome", ")", "\n", "if", "not", "stateful", "or", "method", "!=", "self", ".", "_method", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "", "if", "not", "self", ".", "_causal_model", ":", "\n", "            ", "self", ".", "_causal_model", "=", "CausalModel", "(", "self", ".", "_obj", ",", "\n", "[", "xi", "for", "xi", "in", "x", ".", "keys", "(", ")", "]", ",", "\n", "outcome", ",", "\n", "graph", "=", "dot_graph", ",", "\n", "common_causes", "=", "common_causes", ",", "\n", "instruments", "=", "None", ",", "\n", "estimand_type", "=", "estimand_type", ",", "\n", "proceed_when_unidentifiable", "=", "proceed_when_unidentifiable", ")", "\n", "#self._identified_estimand = self._causal_model.identify_effect()", "\n", "\n", "", "if", "not", "bool", "(", "variable_types", ")", ":", "#check if the variables dictionary is empty", "\n", "            ", "variable_types", "=", "dict", "(", "self", ".", "_obj", ".", "dtypes", ")", "#Convert the series containing data types to a dictionary", "\n", "for", "key", "in", "variable_types", ".", "keys", "(", ")", ":", "\n", "                ", "variable_types", "[", "key", "]", "=", "self", ".", "convert_to_custom_type", "(", "variable_types", "[", "key", "]", ".", "name", ")", "#Obtain the custom type corrosponding to each data type", "\n", "\n", "", "", "elif", "len", "(", "self", ".", "_obj", ".", "columns", ")", ">", "len", "(", "variable_types", ")", ":", "\n", "            ", "all_variables", "=", "dict", "(", "self", ".", "_obj", ".", "dtypes", ")", "\n", "for", "key", "in", "all_variables", ".", "keys", "(", ")", ":", "\n", "                ", "if", "key", "not", "in", "variable_types", ":", "\n", "                    ", "variable_types", "[", "key", "]", "=", "self", ".", "convert_to_custom_type", "(", "all_variables", "[", "key", "]", ".", "name", ")", "\n", "\n", "", "", "", "elif", "len", "(", "self", ".", "_obj", ".", "columns", ")", "<", "len", "(", "variable_types", ")", ":", "\n", "            ", "raise", "Exception", "(", "'Number of variables in the DataFrame is lesser than the variable_types dict'", ")", "\n", "\n", "", "if", "not", "self", ".", "_sampler", ":", "\n", "            ", "self", ".", "_method", "=", "method", "\n", "do_sampler_class", "=", "do_samplers", ".", "get_class_object", "(", "method", "+", "\"_sampler\"", ")", "\n", "self", ".", "_sampler", "=", "do_sampler_class", "(", "self", ".", "_obj", ",", "\n", "#self._identified_estimand,", "\n", "#self._causal_model._treatment,", "\n", "#self._causal_model._outcome,", "\n", "params", "=", "params", ",", "\n", "variable_types", "=", "variable_types", ",", "\n", "num_cores", "=", "num_cores", ",", "\n", "causal_model", "=", "self", ".", "_causal_model", ",", "\n", "keep_original_treatment", "=", "keep_original_treatment", ")", "\n", "", "result", "=", "self", ".", "_sampler", ".", "do_sample", "(", "x", ")", "\n", "if", "not", "stateful", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.convert_to_custom_type": [[124, 145], ["Exception"], "methods", ["None"], ["", "def", "convert_to_custom_type", "(", "self", ",", "input_type", ")", ":", "\n", "        ", "\"\"\"\n        This function converts a DataFrame type to a custom type used within dowhy.\n        We make use of the following mapping\n        int -> 'c'\n        float -> 'c'\n        binary -> 'b'\n        category -> 'd'\n        Currently we have not added support for time.\n        :param input_type: str: The datatype of a column within a DataFrame\n        \"\"\"", "\n", "if", "'int'", "in", "input_type", ":", "\n", "            ", "return", "'c'", "\n", "", "elif", "'float'", "in", "input_type", ":", "\n", "            ", "return", "'c'", "\n", "", "elif", "'bool'", "in", "input_type", ":", "\n", "            ", "return", "'b'", "\n", "", "elif", "'category'", "in", "input_type", ":", "\n", "            ", "return", "'d'", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'{} format is not supported'", ".", "format", "(", "input_type", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.parse_x": [[146, 154], ["Exception", "type", "type", "type", "type"], "methods", ["None"], ["", "", "def", "parse_x", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "type", "(", "x", ")", "==", "str", ":", "\n", "            ", "return", "{", "x", ":", "None", "}", ",", "True", "\n", "", "if", "type", "(", "x", ")", "==", "list", ":", "\n", "            ", "return", "{", "xi", ":", "None", "for", "xi", "in", "x", "}", ",", "True", "\n", "", "if", "type", "(", "x", ")", "==", "dict", ":", "\n", "            ", "return", "x", ",", "False", "\n", "", "raise", "Exception", "(", "'x format not recognized: {}'", ".", "format", "(", "type", "(", "x", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.data_transformers.pca_reducer.PCAReducer.__init__": [[9, 14], ["dowhy.data_transformer.DimensionalityReducer.__init__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_do_standardize", "=", "True", "\n", "if", "\"standardize\"", "in", "kwargs", ":", "\n", "            ", "self", ".", "_do_standardize", "=", "kwargs", "[", "\"standardize\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.data_transformers.pca_reducer.PCAReducer.reduce": [[15, 22], ["sklearn.decomposition.PCA", "sklearn.decomposition.PCA.fit_transform", "sklearn.preprocessing.scale"], "methods", ["None"], ["", "", "def", "reduce", "(", "self", ")", ":", "\n", "        ", "data", "=", "self", ".", "_data", "\n", "if", "self", ".", "_do_standardize", ":", "\n", "            ", "data", "=", "scale", "(", "self", ".", "_data", ",", "axis", "=", "0", ")", "\n", "", "pca_model", "=", "PCA", "(", "n_components", "=", "self", ".", "_ndims", ")", "\n", "reduced_data", "=", "pca_model", ".", "fit_transform", "(", "data", ")", "\n", "return", "reduced_data", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.data_transformers.test_pca_reducer.TestPCAReducer.test_reduce": [[22, 44], ["dowhy.data_transformers.pca_reducer.PCAReducer", "dowhy.data_transformers.pca_reducer.PCAReducer.reduce", "print", "print", "print", "matplotlib.pyplot.scatter", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.scatter", "matplotlib.pyplot.show", "numpy.square", "numpy.square", "numpy.square", "numpy.square", "all", "abs", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.data_transformers.pca_reducer.PCAReducer.reduce", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show"], ["    ", "def", "test_reduce", "(", "self", ",", "feature_matrix", ",", "show_plot", "=", "False", ")", ":", "\n", "        ", "reducer", "=", "PCAReducer", "(", "feature_matrix", ",", "ndims", "=", "2", ",", "standardize", "=", "False", ")", "\n", "X_pca", "=", "reducer", ".", "reduce", "(", ")", "\n", "print", "(", "feature_matrix", ")", "\n", "print", "(", "X_pca", ")", "\n", "if", "show_plot", ":", "\n", "            ", "plt", ".", "scatter", "(", "feature_matrix", "[", ":", ",", "0", "]", ",", "feature_matrix", "[", ":", ",", "1", "]", ",", "c", "=", "\"g\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Dim 0\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Dim 1\"", ")", "\n", "plt", ".", "scatter", "(", "X_pca", "[", ":", ",", "0", "]", ",", "X_pca", "[", ":", ",", "1", "]", ",", "alpha", "=", "0.5", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "dist_origin", "=", "(", "\n", "np", ".", "square", "(", "feature_matrix", "[", ":", ",", "0", "]", "-", "np", ".", "mean", "(", "feature_matrix", "[", ":", ",", "0", "]", ")", ")", "+", "\n", "np", ".", "square", "(", "feature_matrix", "[", ":", ",", "1", "]", "-", "np", ".", "mean", "(", "feature_matrix", "[", ":", ",", "1", "]", ")", ")", "\n", ")", "\n", "dist_origin_pca", "=", "(", "\n", "np", ".", "square", "(", "X_pca", "[", ":", ",", "0", "]", "-", "np", ".", "mean", "(", "X_pca", "[", ":", ",", "0", "]", ")", ")", "+", "\n", "np", ".", "square", "(", "X_pca", "[", ":", ",", "1", "]", "-", "np", ".", "mean", "(", "X_pca", "[", ":", ",", "1", "]", ")", ")", "\n", ")", "\n", "print", "(", "(", "dist_origin_pca", "-", "dist_origin", ")", "/", "dist_origin", ")", "\n", "assert", "all", "(", "abs", "(", "dist_origin_pca", "-", "dist_origin", ")", ")", "<", "0.001", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.data_transformers.test_pca_reducer.feature_matrix": [[8, 19], ["pytest.fixture", "numpy.random.uniform", "numpy.ones", "numpy.random.multivariate_normal"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", ")", "\n", "def", "feature_matrix", "(", ")", ":", "\n", "    ", "num_features", "=", "2", "\n", "num_samples", "=", "10000", "\n", "means", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ",", "num_features", ")", "\n", "# cov_mat = np.diag(np.ones(num_features))", "\n", "cov_mat", "=", "np", ".", "ones", "(", "(", "num_features", ",", "num_features", ")", ")", "\n", "cov_mat", "[", "0", ",", "1", "]", "=", "0.5", "\n", "cov_mat", "[", "1", ",", "0", "]", "=", "0.5", "\n", "X", "=", "np", ".", "random", ".", "multivariate_normal", "(", "means", ",", "cov_mat", ",", "num_samples", ")", "\n", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.cdt.CDT.__init__": [[13, 18], ["dowhy.graph_learners.GraphLearner.__init__", "get_library_class_object", "get_library_class_object."], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.__init__.get_library_class_object"], ["def", "__init__", "(", "self", ",", "data", ",", "full_method_name", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", "data", ",", "full_method_name", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "library_class", "=", "get_library_class_object", "(", "full_method_name", ")", "\n", "self", ".", "_method", "=", "library_class", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.cdt.CDT.learn_graph": [[19, 39], ["cdt.CDT._method.predict", "networkx.to_numpy_matrix", "numpy.asarray", "adjacency_matrix_to_graph", "str_to_dot"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.predict", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.adjacency_matrix_to_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.str_to_dot"], ["", "def", "learn_graph", "(", "self", ",", "labels", "=", "None", ")", ":", "\n", "\t\t", "'''\n\t\tDiscover causal graph and return the graph in DOT format.\n\n\t\t'''", "\n", "graph", "=", "self", ".", "_method", ".", "predict", "(", "self", ".", "_data", ")", "\n", "\n", "# Get adjacency matrix", "\n", "self", ".", "_adjacency_matrix", "=", "nx", ".", "to_numpy_matrix", "(", "graph", ")", "\n", "self", ".", "_adjacency_matrix", "=", "np", ".", "asarray", "(", "self", ".", "_adjacency_matrix", ")", "\n", "\n", "# If labels not provided", "\n", "if", "labels", "is", "not", "None", ":", "\n", "\t\t\t", "self", ".", "_labels", "=", "labels", "\n", "\n", "", "self", ".", "_graph_dot", "=", "adjacency_matrix_to_graph", "(", "self", ".", "_adjacency_matrix", ",", "self", ".", "_labels", ")", "\n", "\n", "# Obtain valid DOT format", "\n", "self", ".", "_graph_dot", "=", "str_to_dot", "(", "self", ".", "_graph_dot", ".", "source", ")", "\n", "return", "self", ".", "_graph_dot", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.ges.GES.__init__": [[13, 18], ["dowhy.graph_learners.GraphLearner.__init__", "importlib.import_module"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "data", ",", "full_method_name", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", "data", ",", "full_method_name", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "library_class", "=", "import_module", "(", "full_method_name", ")", "\n", "self", ".", "_method", "=", "library_class", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.ges.GES.learn_graph": [[19, 36], ["ges.GES._method.fit_bic", "numpy.asarray", "adjacency_matrix_to_graph", "str_to_dot", "ges.GES._data.to_numpy"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.adjacency_matrix_to_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.str_to_dot"], ["", "def", "learn_graph", "(", "self", ",", "labels", "=", "None", ")", ":", "\n", "\t\t", "'''\n\t\tDiscover causal graph and return the graph in DOT format.\n\n\t\t'''", "\n", "self", ".", "_adjacency_matrix", ",", "self", ".", "score", "=", "self", ".", "_method", ".", "fit_bic", "(", "self", ".", "_data", ".", "to_numpy", "(", ")", ")", "\n", "self", ".", "_adjacency_matrix", "=", "np", ".", "asarray", "(", "self", ".", "_adjacency_matrix", ")", "\n", "\n", "# If labels provided", "\n", "if", "labels", "is", "not", "None", ":", "\n", "\t\t\t", "self", ".", "_labels", "=", "labels", "\n", "\n", "", "self", ".", "_graph_dot", "=", "adjacency_matrix_to_graph", "(", "self", ".", "_adjacency_matrix", ",", "self", ".", "_labels", ")", "\n", "\n", "# Return in valid DOT format", "\n", "self", ".", "_graph_dot", "=", "str_to_dot", "(", "self", ".", "_graph_dot", ".", "source", ")", "\n", "return", "self", ".", "_graph_dot", "", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.__init__.get_discovery_class_object": [[6, 23], ["module_name.upper", "importlib.import_module", "getattr", "issubclass", "ImportError"], "function", ["None"], ["\n", "here", "=", "path", ".", "abspath", "(", "path", ".", "dirname", "(", "__file__", ")", ")", "\n", "# Loading version number", "\n", "with", "open", "(", "path", ".", "join", "(", "here", ",", "'VERSION'", ")", ")", "as", "version_file", ":", "\n", "    ", "__version__", "=", "version_file", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.__init__.get_library_class_object": [[24, 38], ["module_method_name.rpartition", "importlib.import_module", "getattr", "ImportError"], "function", ["None"], []], "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.lingam.LINGAM.__init__": [[13, 18], ["dowhy.graph_learners.GraphLearner.__init__", "get_library_class_object", "get_library_class_object."], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__", "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.__init__.get_library_class_object"], ["def", "__init__", "(", "self", ",", "data", ",", "full_method_name", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", "data", ",", "full_method_name", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "library_class", "=", "get_library_class_object", "(", "full_method_name", ")", "\n", "self", ".", "_method", "=", "library_class", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.graph_learners.lingam.LINGAM.learn_graph": [[19, 36], ["lingam.LINGAM._method.fit", "adjacency_matrix_to_graph", "str_to_dot"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.adjacency_matrix_to_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.utils.graph_operations.str_to_dot"], ["", "def", "learn_graph", "(", "self", ",", "labels", "=", "None", ")", ":", "\n", "\t\t", "'''\n\t\tDiscover causal graph and return the graph in DOT format.\n\n\t\t'''", "\n", "self", ".", "_method", ".", "fit", "(", "self", ".", "_data", ")", "\n", "self", ".", "_adjacency_matrix", "=", "self", ".", "_method", ".", "adjacency_matrix_", "\n", "\n", "# If labels provided", "\n", "if", "labels", "is", "not", "None", ":", "\n", "\t\t\t", "self", ".", "_labels", "=", "labels", "\n", "\n", "", "self", ".", "_graph_dot", "=", "adjacency_matrix_to_graph", "(", "self", ".", "_adjacency_matrix", ",", "self", ".", "_labels", ")", "\n", "\n", "# Return in valid DOT format", "\n", "self", ".", "_graph_dot", "=", "str_to_dot", "(", "self", ".", "_graph_dot", ".", "source", ")", "\n", "return", "self", ".", "_graph_dot", "", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.visual_interpreter.VisualInterpreter.__init__": [[7, 9], ["dowhy.interpreter.Interpreter.__init__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "instance", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "instance", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.visual_interpreter.VisualInterpreter.show": [[10, 20], ["None"], "methods", ["None"], ["", "def", "show", "(", "self", ",", "interpret_plot", ")", ":", "\n", "        ", "\"\"\"Display the intepretation.\n        \n        :param interpret_plot: Plot object containing the interpretation\n\n        :returns: None\n\n        \"\"\"", "\n", "# TODO: A common way to show all plots", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.__init__": [[7, 9], ["dowhy.interpreter.Interpreter.__init__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "instance", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "instance", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show": [[10, 19], ["print"], "methods", ["None"], ["", "def", "show", "(", "self", ",", "interpret_text", ")", ":", "\n", "        ", "\"\"\"Display the intepretation.\n        \n        :param interpret_text: String containing the interpretation\n\n        :returns: None\n\n        \"\"\"", "\n", "print", "(", "interpret_text", ")", "# can be extended later to provide a prettier output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_effect_interpreter.TextualEffectInterpreter.__init__": [[8, 12], ["dowhy.interpreters.textual_interpreter.TextualInterpreter.__init__"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "instance", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "instance", ",", "**", "kwargs", ")", "\n", "# Setting estimator attribute for convenience", "\n", "self", ".", "estimator", "=", "self", ".", "estimate", ".", "estimator", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_effect_interpreter.TextualEffectInterpreter.interpret": [[13, 37], ["pandas.api.types.is_numeric_dtype", "textual_effect_interpreter.TextualEffectInterpreter.show", "all", "all", "NotImplementedError", "NotImplementedError", "pandas.api.types.is_numeric_dtype", "pandas.api.types.is_bool_dtype", "pandas.api.types.is_numeric_dtype", "pandas.api.types.is_bool_dtype"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show"], ["", "def", "interpret", "(", "self", ")", ":", "\n", "        ", "\"\"\"Interpret causal effect by showing how much a unit change in treatment will cause change in the outcome.\n\n        \"\"\"", "\n", "interpret_text", "=", "\"\"", "\n", "treatments_str", "=", "\",\"", ".", "join", "(", "self", ".", "estimator", ".", "_treatment_name", ")", "\n", "if", "pd", ".", "api", ".", "types", ".", "is_numeric_dtype", "(", "self", ".", "estimator", ".", "_outcome", ".", "dtypes", ")", ":", "\n", "# Outcome is numeric", "\n", "            ", "if", "all", "(", "pd", ".", "api", ".", "types", ".", "is_numeric_dtype", "(", "tr_dtype", ")", "or", "pd", ".", "api", ".", "types", ".", "is_bool_dtype", "(", "tr_dtype", ")", "for", "tr_dtype", "in", "self", ".", "estimator", ".", "_treatment", ".", "dtypes", ")", ":", "\n", "# Treatments are also numeric or binary", "\n", "                ", "interpret_text", "+=", "\"Increasing the treatment variable(s) [{0}] from {1} to {2} causes an increase of {3} in the expected value of the outcome [{4}]\"", ".", "format", "(", "treatments_str", ",", "self", ".", "estimator", ".", "_control_value", ",", "self", ".", "estimator", ".", "_treatment_value", ",", "self", ".", "estimate", ".", "value", ",", "self", ".", "estimator", ".", "_outcome_name", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\"Interpretation not supported yet for categorical treatments\"", ")", "\n", "", "", "else", ":", "\n", "# Outcome is categorical", "\n", "            ", "if", "all", "(", "pd", ".", "api", ".", "types", ".", "is_numeric_dtype", "(", "tr_dtype", ")", "or", "pd", ".", "api", ".", "types", ".", "is_bool_dtype", "(", "tr_dtype", ")", "for", "tr_dtype", "in", "self", ".", "estimator", ".", "_treatment", ".", "dtypes", ")", ":", "\n", "# Treatments are numeric or binary", "\n", "                ", "interpret_text", "+=", "\"Increasing the treatment variable(s) [{0}] from {1} to {2} causes an increase of {3} in the expected value of the outcome [{4}]\"", ".", "format", "(", "treatments_str", ",", "self", ".", "estimator", ".", "_control_value", ",", "self", ".", "estimator", ".", "_treatment_value", ",", "self", ".", "estimate", ".", "value", ",", "self", ".", "estimator", ".", "_outcome_name", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\"Interpretation not supported yet for categorical treatments\"", ")", "\n", "\n", "", "", "interpret_text", "+=", "\", over the data distribution/population represented by the dataset.\"", "\n", "self", ".", "show", "(", "interpret_text", ")", "\n", "return", "interpret_text", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.confounder_distribution_interpreter.ConfounderDistributionInterpreter.__init__": [[11, 44], ["dowhy.interpreters.visual_interpreter.VisualInterpreter.__init__", "isinstance", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.logger.error", "ValueError", "any", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.logger.error", "ValueError", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.logger.error", "ValueError", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.logger.error", "ValueError", "isinstance"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "estimate", ",", "fig_size", ",", "font_size", ",", "var_name", ",", "var_type", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param estimate: Causal estimate\n        :param fig_size: Size of the figure\n        :param font_size: Size of the font of the plot title\n        :param var_name: The confounding variable for which distribution changes should be compared\n        :param var_type: Type of the confounding variable; must be one of 'continuous' or 'discrete'\n        \"\"\"", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "estimate", ",", "**", "kwargs", ")", "\n", "if", "not", "isinstance", "(", "estimate", ",", "CausalEstimate", ")", ":", "\n", "            ", "error_msg", "=", "\"The interpreter method expects a CausalEstimate object.\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "", "self", ".", "estimator", "=", "self", ".", "estimate", ".", "estimator", "\n", "if", "not", "any", "(", "isinstance", "(", "self", ".", "estimator", ",", "est_class", ")", "for", "est_class", "in", "ConfounderDistributionInterpreter", ".", "SUPPORTED_ESTIMATORS", ")", ":", "\n", "            ", "error_msg", "=", "\"The interpreter method only supports propensity score weighting estimator.\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "if", "var_type", "not", "in", "{", "\"continuous\"", ",", "\"discrete\"", "}", ":", "\n", "            ", "error_msg", "=", "\"var_type must be one of 'continuous' or 'discrete'.\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "if", "var_type", "==", "\"continuous\"", ":", "\n", "            ", "error_msg", "=", "\"Distributional changes plot for continuous variables is not yet implemented.\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "self", ".", "fig_size", "=", "fig_size", "\n", "self", ".", "font_size", "=", "font_size", "\n", "self", ".", "var_name", "=", "var_name", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.confounder_distribution_interpreter.ConfounderDistributionInterpreter.discrete_dist_plot": [[45, 59], ["ax.bar", "ax.bar", "ax.set_xlabel", "ax.set_ylabel", "ax.set_title", "ax.set_xticks", "ax.set_xticklabels", "ax.legend"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "discrete_dist_plot", "(", "labels", ",", "not_treated_counts", ",", "treated_counts", ",", "ax", ",", "title", ",", "var_name", ",", "font_size", ",", "width", "=", "0.35", ")", ":", "\n", "        ", "\"\"\"\n        Plot of the treated vs untreated.\n        \"\"\"", "\n", "\n", "ax", ".", "bar", "(", "labels", "-", "width", "/", "2", ",", "not_treated_counts", ",", "width", ",", "label", "=", "'Untreated'", ")", "\n", "ax", ".", "bar", "(", "labels", "+", "width", "/", "2", ",", "treated_counts", ",", "width", ",", "label", "=", "'Treated'", ")", "\n", "ax", ".", "set_xlabel", "(", "var_name", ")", "\n", "ax", ".", "set_ylabel", "(", "'Count'", ")", "\n", "ax", ".", "set_title", "(", "title", ",", "fontsize", "=", "font_size", ")", "\n", "ax", ".", "set_xticks", "(", "labels", ")", "\n", "ax", ".", "set_xticklabels", "(", "labels", ")", "\n", "ax", ".", "legend", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.confounder_distribution_interpreter.ConfounderDistributionInterpreter.interpret": [[60, 101], ["confounder_distribution_interpreter.ConfounderDistributionInterpreter.estimator._data[].copy", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.groupby().size().reset_index", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.groupby().agg().reset_index", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.groupby().agg().reset_index.rename", "plt.subplots", "zip", "fig.tight_layout", "plt.show", "plot_df[].reset_index", "plot_df[].reset_index", "aggregated_not_treated[].astype", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.discrete_dist_plot", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.groupby().size", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.groupby().agg", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.groupby", "confounder_distribution_interpreter.ConfounderDistributionInterpreter.groupby"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.textual_interpreter.TextualInterpreter.show", "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.confounder_distribution_interpreter.ConfounderDistributionInterpreter.discrete_dist_plot"], ["", "def", "interpret", "(", "self", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Shows distribution changes for confounding variables before and after applying inverse propensity weights.\n        \"\"\"", "\n", "\n", "cols", "=", "self", ".", "estimator", ".", "_observed_common_causes_names", "+", "self", ".", "estimator", ".", "_treatment_name", "\n", "df", "=", "self", ".", "estimator", ".", "_data", "[", "cols", "]", ".", "copy", "(", ")", "\n", "treated", "=", "self", ".", "estimator", ".", "_treatment_name", "[", "0", "]", "\n", "propensity", "=", "self", ".", "estimate", ".", "propensity_scores", "\n", "\n", "# add weight column", "\n", "df", ".", "loc", "[", ":", ",", "\"weight\"", "]", "=", "df", ".", "loc", "[", ":", ",", "treated", "]", "*", "(", "propensity", ")", "**", "(", "-", "1", ")", "+", "(", "1", "-", "df", ".", "loc", "[", ":", ",", "treated", "]", ")", "*", "(", "1", "-", "propensity", ")", "**", "(", "-", "1", ")", "\n", "\n", "# before weights are applied we count number rows in each category", "\n", "# which is equivalent to summing over weight=1", "\n", "barplot_df_before", "=", "df", ".", "groupby", "(", "[", "self", ".", "var_name", ",", "treated", "]", ")", ".", "size", "(", ")", ".", "reset_index", "(", "name", "=", "\"count\"", ")", "\n", "\n", "# after weights are applied we need to sum over the given weights", "\n", "barplot_df_after", "=", "df", ".", "groupby", "(", "[", "self", ".", "var_name", ",", "treated", "]", ")", ".", "agg", "(", "{", "'weight'", ":", "np", ".", "sum", "}", ")", ".", "reset_index", "(", ")", "\n", "barplot_df_after", ".", "rename", "(", "columns", "=", "{", "'weight'", ":", "'count'", "}", ",", "inplace", "=", "True", ")", "\n", "\n", "title1", "=", "\"Distribution of \"", "+", "self", ".", "var_name", "+", "\" before applying the weights\"", "\n", "title2", "=", "\"Distribution of \"", "+", "self", ".", "var_name", "+", "\" after applying the weights\"", "\n", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "fig", ",", "(", "ax1", ",", "ax2", ")", "=", "plt", ".", "subplots", "(", "1", ",", "2", ",", "figsize", "=", "self", ".", "fig_size", ")", "\n", "iterable", "=", "zip", "(", "[", "barplot_df_before", ",", "barplot_df_after", "]", ",", "[", "ax1", ",", "ax2", "]", ",", "[", "title1", ",", "title2", "]", ")", "\n", "for", "plot_df", ",", "ax", ",", "title", "in", "iterable", ":", "\n", "            ", "aggregated_not_treated", "=", "plot_df", "[", "plot_df", "[", "treated", "]", "==", "False", "]", ".", "reset_index", "(", ")", "\n", "aggregated_treated", "=", "plot_df", "[", "plot_df", "[", "treated", "]", "==", "True", "]", ".", "reset_index", "(", ")", "\n", "\n", "labels", "=", "aggregated_not_treated", "[", "self", ".", "var_name", "]", ".", "astype", "(", "'float'", ")", "\n", "not_treated_counts", "=", "aggregated_not_treated", "[", "'count'", "]", "\n", "\n", "treated_counts", "=", "aggregated_treated", "[", "'count'", "]", "\n", "self", ".", "discrete_dist_plot", "(", "labels", ",", "not_treated_counts", ",", "treated_counts", ",", "ax", ",", "title", ",", "\n", "self", ".", "var_name", ",", "self", ".", "font_size", ")", "\n", "\n", "", "fig", ".", "tight_layout", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.__init__.get_class_object": [[6, 19], ["string.capwords().replace", "importlib.import_module", "getattr", "issubclass", "ImportError", "string.capwords"], "function", ["None"], ["\n", "here", "=", "path", ".", "abspath", "(", "path", ".", "dirname", "(", "__file__", ")", ")", "\n", "# Loading version number", "\n", "with", "open", "(", "path", ".", "join", "(", "here", ",", "'VERSION'", ")", ")", "as", "version_file", ":", "\n", "    ", "__version__", "=", "version_file", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__": [[12, 23], ["dowhy.interpreters.visual_interpreter.VisualInterpreter.__init__", "isinstance", "propensity_balance_interpreter.PropensityBalanceInterpreter.logger.error", "ValueError", "any", "propensity_balance_interpreter.PropensityBalanceInterpreter.logger.error", "ValueError", "isinstance"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.__init__"], ["def", "__init__", "(", "self", ",", "estimate", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "estimate", ",", "**", "kwargs", ")", "\n", "if", "not", "isinstance", "(", "estimate", ",", "CausalEstimate", ")", ":", "\n", "            ", "error_msg", "=", "\"The interpreter method expects a CausalEstimate object.\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "", "self", ".", "estimator", "=", "self", ".", "estimate", ".", "estimator", "\n", "if", "not", "any", "(", "isinstance", "(", "self", ".", "estimator", ",", "est_class", ")", "for", "est_class", "in", "PropensityBalanceInterpreter", ".", "SUPPORTED_ESTIMATORS", ")", ":", "\n", "            ", "error_msg", "=", "\"The interpreter method only supports propensity score stratification estimator.\"", "\n", "self", ".", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.interpreters.propensity_balance_interpreter.PropensityBalanceInterpreter.interpret": [[24, 74], ["pandas.wide_to_long().reset_index().astype", "pandas.wide_to_long().reset_index().astype.groupby().agg", "mean_diff.query.query.groupby().transform().reset_index", "mean_diff.query.query.query", "pandas.wide_to_long().reset_index().astype.groupby().agg().reset_index", "pandas.wide_to_long().reset_index().astype.groupby().agg().reset_index", "pandas.merge", "pandas.merge", "pandas.wide_to_long().reset_index().astype.groupby().agg().reset_index", "pandas.merge", "mean_diff_strata.groupby().agg().reset_index.groupby().agg().reset_index.groupby().agg().reset_index", "pandas.wide_to_long().reset_index().astype.groupby().agg", "pandas.merge.groupby().transform().reset_index", "pandas.wide_to_long().reset_index().astype.groupby().agg().reset_index", "pandas.merge", "pandas.concat", "plt.style.use", "plt.subplots", "pandas.concat.groupby", "plt.legend", "plt.ylabel", "plt.xlabel", "plt.xticks", "subdf.plot", "pandas.wide_to_long().reset_index", "pandas.wide_to_long().reset_index().astype.groupby", "mean_diff.query.query.groupby().transform", "pandas.wide_to_long().reset_index().astype.groupby().agg", "pandas.wide_to_long().reset_index().astype.groupby().agg", "pandas.wide_to_long().reset_index().astype.groupby().agg", "mean_diff_strata.groupby().agg().reset_index.groupby().agg().reset_index.groupby().agg", "pandas.wide_to_long().reset_index().astype.groupby", "pandas.merge.groupby().transform", "pandas.wide_to_long().reset_index().astype.groupby().agg", "pandas.wide_to_long", "mean_diff.query.query.groupby", "pandas.wide_to_long().reset_index().astype.groupby", "pandas.wide_to_long().reset_index().astype.groupby", "pandas.wide_to_long().reset_index().astype.groupby", "mean_diff_strata.groupby().agg().reset_index.groupby().agg().reset_index.groupby", "pandas.merge.groupby", "pandas.wide_to_long().reset_index().astype.groupby", "df.reset_index", "x.max", "x.min", "x.max", "x.min"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.util.plotting.plot"], ["", "", "def", "interpret", "(", "self", ")", ":", "\n", "        ", "\"\"\"Balance plot that shows the change in standardized mean differences for each covariate after propensity score stratification.\n\n        \"\"\"", "\n", "cols", "=", "self", ".", "estimator", ".", "_observed_common_causes_names", "+", "self", ".", "estimator", ".", "_treatment_name", "+", "[", "\"strata\"", ",", "\"propensity_score\"", "]", "\n", "df", "=", "self", ".", "estimator", ".", "_data", "[", "cols", "]", "\n", "df_long", "=", "pd", ".", "wide_to_long", "(", "df", ".", "reset_index", "(", ")", ",", "stubnames", "=", "[", "\"W\"", "]", ",", "i", "=", "'index'", ",", "j", "=", "\"common_cause_id\"", ")", ".", "reset_index", "(", ")", ".", "astype", "(", "{", "'W'", ":", "'float64'", "}", ")", "\n", "\n", "# First, calculating mean differences by strata", "\n", "mean_diff", "=", "df_long", ".", "groupby", "(", "self", ".", "estimator", ".", "_treatment_name", "+", "[", "\"common_cause_id\"", ",", "\"strata\"", "]", ")", ".", "agg", "(", "mean_w", "=", "(", "\"W\"", ",", "np", ".", "mean", ")", ")", "\n", "mean_diff", "=", "mean_diff", ".", "groupby", "(", "[", "\"common_cause_id\"", ",", "\"strata\"", "]", ")", ".", "transform", "(", "lambda", "x", ":", "x", ".", "max", "(", ")", "-", "x", ".", "min", "(", ")", ")", ".", "reset_index", "(", ")", "\n", "mean_diff", "=", "mean_diff", ".", "query", "(", "\"v0==True\"", ")", "\n", "size_by_w_strata", "=", "df_long", ".", "groupby", "(", "[", "\"common_cause_id\"", ",", "\"strata\"", "]", ")", ".", "agg", "(", "\n", "size", "=", "(", "\"propensity_score\"", ",", "np", ".", "size", ")", ")", ".", "reset_index", "(", ")", "\n", "size_by_strata", "=", "df_long", ".", "groupby", "(", "[", "\"common_cause_id\"", "]", ")", ".", "agg", "(", "\n", "size", "=", "(", "\"propensity_score\"", ",", "np", ".", "size", ")", ")", ".", "reset_index", "(", ")", "\n", "size_by_strata", "=", "pd", ".", "merge", "(", "size_by_w_strata", ",", "size_by_strata", ",", "on", "=", "\"common_cause_id\"", ")", "\n", "mean_diff_strata", "=", "pd", ".", "merge", "(", "mean_diff", ",", "size_by_strata", ",", "on", "=", "(", "\"common_cause_id\"", ",", "\"strata\"", ")", ")", "\n", "\n", "stddev_by_w_strata", "=", "df_long", ".", "groupby", "(", "[", "\"common_cause_id\"", ",", "\"strata\"", "]", ")", ".", "agg", "(", "\n", "stddev", "=", "(", "\"W\"", ",", "np", ".", "std", ")", ")", ".", "reset_index", "(", ")", "\n", "mean_diff_strata", "=", "pd", ".", "merge", "(", "mean_diff_strata", ",", "stddev_by_w_strata", ",", "on", "=", "[", "\"common_cause_id\"", ",", "\"strata\"", "]", ")", "\n", "mean_diff_strata", "[", "\"scaled_mean\"", "]", "=", "(", "mean_diff_strata", "[", "\"mean_w\"", "]", "/", "mean_diff_strata", "[", "\"stddev\"", "]", ")", "*", "(", "mean_diff_strata", "[", "\"size_x\"", "]", "/", "mean_diff_strata", "[", "\"size_y\"", "]", ")", "\n", "mean_diff_strata", "=", "mean_diff_strata", ".", "groupby", "(", "\"common_cause_id\"", ")", ".", "agg", "(", "std_mean_diff", "=", "(", "\"scaled_mean\"", ",", "np", ".", "sum", ")", ")", ".", "reset_index", "(", ")", "\n", "\n", "# Second, without strata", "\n", "mean_diff_overall", "=", "df_long", ".", "groupby", "(", "self", ".", "estimator", ".", "_treatment_name", "+", "[", "\"common_cause_id\"", "]", ")", ".", "agg", "(", "mean_w", "=", "(", "\"W\"", ",", "np", ".", "mean", ")", ")", "\n", "mean_diff_overall", "=", "mean_diff_overall", ".", "groupby", "(", "\"common_cause_id\"", ")", ".", "transform", "(", "lambda", "x", ":", "x", ".", "max", "(", ")", "-", "x", ".", "min", "(", ")", ")", ".", "reset_index", "(", ")", "\n", "mean_diff_overall", "=", "mean_diff_overall", "[", "mean_diff_overall", "[", "self", ".", "estimator", ".", "_treatment_name", "[", "0", "]", "]", "==", "True", "]", "#TODO", "\n", "stddev_overall", "=", "df_long", ".", "groupby", "(", "[", "\"common_cause_id\"", "]", ")", ".", "agg", "(", "\n", "stddev", "=", "(", "\"W\"", ",", "np", ".", "std", ")", ")", ".", "reset_index", "(", ")", "\n", "mean_diff_overall", "=", "pd", ".", "merge", "(", "mean_diff_overall", ",", "stddev_overall", ",", "on", "=", "[", "\"common_cause_id\"", "]", ")", "\n", "mean_diff_overall", "[", "\"std_mean_diff\"", "]", "=", "mean_diff_overall", "[", "\"mean_w\"", "]", "/", "mean_diff_overall", "[", "\"stddev\"", "]", "\n", "\n", "# Third, concatenating them and plotting", "\n", "mean_diff_overall", "=", "mean_diff_overall", "[", "[", "\"common_cause_id\"", ",", "\"std_mean_diff\"", "]", "]", "\n", "mean_diff_strata", "[", "\"sample\"", "]", "=", "\"PropensityAdjusted\"", "\n", "mean_diff_overall", "[", "\"sample\"", "]", "=", "\"Unadjusted\"", "\n", "plot_df", "=", "pd", ".", "concat", "(", "[", "mean_diff_overall", ",", "mean_diff_strata", "]", ")", "\n", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "plt", ".", "style", ".", "use", "(", "\"seaborn-white\"", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ")", "\n", "for", "label", ",", "subdf", "in", "plot_df", ".", "groupby", "(", "'common_cause_id'", ")", ":", "\n", "            ", "subdf", ".", "plot", "(", "kind", "=", "\"line\"", ",", "x", "=", "\"sample\"", ",", "y", "=", "\"std_mean_diff\"", ",", "ax", "=", "ax", ",", "label", "=", "label", ")", "\n", "", "plt", ".", "legend", "(", "title", "=", "\"Common causes\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Standardized mean difference between treatment and control\"", ")", "\n", "plt", ".", "xlabel", "(", "\"\"", ")", "\n", "plt", ".", "xticks", "(", "rotation", "=", "45", ")", "\n", "return", "plot_df", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_refuter.test_causal_refuter_placeholder_method": [[11, 15], ["test_causal_refuter.MockRefuter", "dowhy.causal_identifier.IdentifiedEstimand", "pytest.raises", "MockRefuter.refute_estimate"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_refuters.add_unobserved_common_cause.AddUnobservedCommonCause.refute_estimate"], ["", "def", "test_causal_refuter_placeholder_method", "(", ")", ":", "\n", "\t", "refuter", "=", "MockRefuter", "(", "None", ",", "IdentifiedEstimand", "(", "None", ",", "None", ",", "None", ")", ",", "None", ")", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "\t\t", "refuter", ".", "refute_estimate", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_model.TestCausalModel.test_external_estimator": [[11, 47], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.identify_effect", "dowhy.CausalModel.estimate_effect", "dowhy.CausalModel.estimate_effect", "sklearn.linear_model.LogisticRegression"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_identifiers.id_identifier.IDIdentifier.identify_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_estimator.CausalEstimator.estimate_effect"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"beta\"", ",", "\"num_samples\"", ",", "\"num_treatments\"", "]", ",", "\n", "[", "(", "10", ",", "100", ",", "1", ")", ",", "]", ")", "\n", "def", "test_external_estimator", "(", "self", ",", "beta", ",", "num_samples", ",", "num_treatments", ")", ":", "\n", "        ", "num_common_causes", "=", "5", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "\n", "beta", "=", "beta", ",", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "True", ",", "\n", ")", "\n", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "\"df\"", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", ",", "\n", ")", "\n", "\n", "identified_estimand", "=", "model", ".", "identify_effect", "(", "proceed_when_unidentifiable", "=", "True", ")", "\n", "\n", "estimate", "=", "model", ".", "estimate_effect", "(", "\n", "identified_estimand", ",", "\n", "method_name", "=", "\"backdoor.tests.causal_estimators.mock_external_estimator.PropensityScoreWeightingEstimator\"", ",", "\n", "control_value", "=", "0", ",", "\n", "treatment_value", "=", "1", ",", "\n", "target_units", "=", "\"ate\"", ",", "# condition used for CATE", "\n", "confidence_intervals", "=", "True", ",", "\n", "method_params", "=", "{", "\n", "\"propensity_score_model\"", ":", "linear_model", ".", "LogisticRegression", "(", "max_iter", "=", "1000", ")", "\n", "}", ",", "\n", ")", "\n", "\n", "assert", "estimate", ".", "estimator", ".", "propensity_score_model", ".", "max_iter", "==", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_model.TestCausalModel.test_graph_input": [[48, 81], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel", "print", "dowhy.CausalModel", "dowhy.CausalModel", "dowhy.CausalModel.get_common_causes", "dowhy.CausalModel.get_common_causes", "all"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"beta\"", ",", "\"num_instruments\"", ",", "\"num_samples\"", ",", "\"num_treatments\"", "]", ",", "\n", "[", "(", "10", ",", "1", ",", "100", ",", "1", ")", ",", "]", ")", "\n", "def", "test_graph_input", "(", "self", ",", "beta", ",", "num_instruments", ",", "num_samples", ",", "num_treatments", ")", ":", "\n", "        ", "num_common_causes", "=", "5", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "beta", ",", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "True", ")", "\n", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", "\n", ")", "\n", "# removing two common causes", "\n", "gml_str", "=", "'graph[directed 1 node[ id \"{0}\" label \"{0}\"]node[ id \"{1}\" label \"{1}\"]node[ id \"Unobserved Confounders\" label \"Unobserved Confounders\"]edge[source \"{0}\" target \"{1}\"]edge[source \"Unobserved Confounders\" target \"{0}\"]edge[source \"Unobserved Confounders\" target \"{1}\"]node[ id \"X0\" label \"X0\"] edge[ source \"X0\" target \"{0}\"] node[ id \"X1\" label \"X1\"] edge[ source \"X1\" target \"{0}\"] node[ id \"X2\" label \"X2\"] edge[ source \"X2\" target \"{0}\"] edge[ source \"X0\" target \"{1}\"] edge[ source \"X1\" target \"{1}\"] edge[ source \"X2\" target \"{1}\"] node[ id \"Z0\" label \"Z0\"] edge[ source \"Z0\" target \"{0}\"]]'", ".", "format", "(", "data", "[", "\"treatment_name\"", "]", "[", "0", "]", ",", "data", "[", "\"outcome_name\"", "]", ")", "\n", "print", "(", "gml_str", ")", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "gml_str", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", ",", "\n", "missing_nodes_as_confounders", "=", "True", "\n", ")", "\n", "common_causes", "=", "model", ".", "get_common_causes", "(", ")", "\n", "assert", "all", "(", "node_name", "in", "common_causes", "for", "node_name", "in", "[", "\"X1\"", ",", "\"X2\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_model.TestCausalModel.test_graph_input2": [[82, 183], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel", "print", "dowhy.CausalModel", "dowhy.CausalModel", "dowhy.CausalModel.get_common_causes", "dowhy.CausalModel.get_common_causes", "all"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"beta\"", ",", "\"num_instruments\"", ",", "\"num_samples\"", ",", "\"num_treatments\"", "]", ",", "\n", "[", "(", "10", ",", "1", ",", "100", ",", "1", ")", ",", "]", ")", "\n", "def", "test_graph_input2", "(", "self", ",", "beta", ",", "num_instruments", ",", "num_samples", ",", "num_treatments", ")", ":", "\n", "        ", "num_common_causes", "=", "5", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "beta", ",", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "True", ")", "\n", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", "\n", ")", "\n", "# removing two common causes", "\n", "gml_str", "=", "\"\"\"graph[\n        directed 1 \n        node[ id \"{0}\" \n        label \"{0}\"\n        ]\n        node [ \n        id \"{1}\" \n        label \"{1}\"\n        ]\n        node [ \n        id \"Unobserved Confounders\" \n        label \"Unobserved Confounders\"\n        ]\n        edge[\n        source \"{0}\" \n        target \"{1}\"\n        ]\n        edge[\n        source \"Unobserved Confounders\" \n        target \"{0}\"\n        ]\n        edge[\n        source \"Unobserved Confounders\" \n        target \"{1}\"\n        ]\n        node[ \n        id \"X0\" \n        label \"X0\"\n        ] \n        edge[ \n        source \"X0\" \n        target \"{0}\"\n        ] \n        node[ \n        id \"X1\" \n        label \"X1\"\n        ] \n        edge[ \n        source \"X1\" \n        target \"{0}\"\n        ] \n        node[ \n        id \"X2\" \n        label \"X2\"\n        ] \n        edge[ \n        source \"X2\" \n        target \"{0}\"\n        ] \n        edge[ \n        source \"X0\" \n        target \"{1}\"\n        ] \n        edge[ \n        source \"X1\" \n        target \"{1}\"\n        ] \n        edge[ \n        source \"X2\" \n        target \"{1}\"\n        ] \n        node[ \n        id \"Z0\" \n        label \"Z0\"\n        ] \n        edge[\n        source \"Z0\" \n        target \"{0}\"\n        ]]\"\"\"", ".", "format", "(", "data", "[", "\"treatment_name\"", "]", "[", "0", "]", ",", "data", "[", "\"outcome_name\"", "]", ")", "\n", "print", "(", "gml_str", ")", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "gml_str", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", ",", "\n", "missing_nodes_as_confounders", "=", "True", "\n", ")", "\n", "common_causes", "=", "model", ".", "get_common_causes", "(", ")", "\n", "assert", "all", "(", "node_name", "in", "common_causes", "for", "node_name", "in", "[", "\"X1\"", ",", "\"X2\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_model.TestCausalModel.test_graph_input3": [[184, 239], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel", "print", "dowhy.CausalModel", "dowhy.CausalModel", "dowhy.CausalModel.get_common_causes", "dowhy.CausalModel.get_common_causes", "all", "dowhy.CausalModel._graph.get_all_nodes", "dowhy.CausalModel._graph.get_all_nodes", "all", "dowhy.CausalModel._graph.get_all_nodes", "dowhy.CausalModel._graph.get_all_nodes"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"beta\"", ",", "\"num_instruments\"", ",", "\"num_samples\"", ",", "\"num_treatments\"", "]", ",", "\n", "[", "(", "10", ",", "1", ",", "100", ",", "1", ")", ",", "]", ")", "\n", "def", "test_graph_input3", "(", "self", ",", "beta", ",", "num_instruments", ",", "num_samples", ",", "num_treatments", ")", ":", "\n", "        ", "num_common_causes", "=", "5", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "beta", ",", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "True", ")", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", "\n", ")", "\n", "# removing two common causes ", "\n", "gml_str", "=", "\"\"\"dag {\n        \"Unobserved Confounders\" [pos=\"0.491,-1.056\"]\n        X0 [pos=\"-2.109,0.057\"]\n        X1 [adjusted, pos=\"-0.453,-1.562\"]\n        X2 [pos=\"-2.268,-1.210\"]\n        Z0 [pos=\"-1.918,-1.735\"]\n        v0 [latent, pos=\"-1.525,-1.293\"]\n        y [outcome, pos=\"-1.164,-0.116\"]\n        \"Unobserved Confounders\" -> v0\n        \"Unobserved Confounders\" -> y\n        X0 -> v0\n        X0 -> y\n        X1 -> v0\n        X1 -> y\n        X2 -> v0\n        X2 -> y\n        Z0 -> v0\n        v0 -> y\n        }\n        \"\"\"", "\n", "print", "(", "gml_str", ")", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "gml_str", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", ",", "\n", "missing_nodes_as_confounders", "=", "True", "\n", ")", "\n", "common_causes", "=", "model", ".", "get_common_causes", "(", ")", "\n", "assert", "all", "(", "node_name", "in", "common_causes", "for", "node_name", "in", "[", "\"X1\"", ",", "\"X2\"", "]", ")", "\n", "all_nodes", "=", "model", ".", "_graph", ".", "get_all_nodes", "(", "include_unobserved", "=", "True", ")", "\n", "assert", "all", "(", "node_name", "in", "all_nodes", "for", "node_name", "in", "[", "\"Unobserved Confounders\"", ",", "\"X0\"", ",", "\"X1\"", ",", "\"X2\"", ",", "\"Z0\"", ",", "\"v0\"", ",", "\"y\"", "]", ")", "\n", "all_nodes", "=", "model", ".", "_graph", ".", "get_all_nodes", "(", "include_unobserved", "=", "False", ")", "\n", "assert", "\"Unobserved Confounders\"", "not", "in", "all_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_model.TestCausalModel.test_graph_input4": [[240, 277], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.CausalModel", "dowhy.CausalModel", "print", "dowhy.CausalModel", "dowhy.CausalModel", "dowhy.CausalModel.get_common_causes", "dowhy.CausalModel.get_common_causes", "all", "dowhy.CausalModel._graph.get_all_nodes", "dowhy.CausalModel._graph.get_all_nodes", "all", "dowhy.CausalModel._graph.get_all_nodes", "dowhy.CausalModel._graph.get_all_nodes"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_common_causes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_graph.CausalGraph.get_all_nodes"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"beta\"", ",", "\"num_instruments\"", ",", "\"num_samples\"", ",", "\"num_treatments\"", "]", ",", "\n", "[", "(", "10", ",", "1", ",", "100", ",", "1", ")", ",", "]", ")", "\n", "def", "test_graph_input4", "(", "self", ",", "beta", ",", "num_instruments", ",", "num_samples", ",", "num_treatments", ")", ":", "\n", "        ", "num_common_causes", "=", "5", "\n", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "beta", ",", "\n", "num_common_causes", "=", "num_common_causes", ",", "\n", "num_instruments", "=", "num_instruments", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "num_treatments", "=", "num_treatments", ",", "\n", "treatment_is_binary", "=", "True", ")", "\n", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", "\n", ")", "\n", "# removing two common causes ", "\n", "gml_str", "=", "\"tests/sample_dag.txt\"", "\n", "print", "(", "gml_str", ")", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "data", "[", "'df'", "]", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "gml_str", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "test_significance", "=", "None", ",", "\n", "missing_nodes_as_confounders", "=", "True", "\n", ")", "\n", "common_causes", "=", "model", ".", "get_common_causes", "(", ")", "\n", "assert", "all", "(", "node_name", "in", "common_causes", "for", "node_name", "in", "[", "\"X1\"", ",", "\"X2\"", "]", ")", "\n", "all_nodes", "=", "model", ".", "_graph", ".", "get_all_nodes", "(", "include_unobserved", "=", "True", ")", "\n", "assert", "all", "(", "node_name", "in", "all_nodes", "for", "node_name", "in", "[", "\"Unobserved Confounders\"", ",", "\"X0\"", ",", "\"X1\"", ",", "\"X2\"", ",", "\"Z0\"", ",", "\"v0\"", ",", "\"y\"", "]", ")", "\n", "all_nodes", "=", "model", ".", "_graph", ".", "get_all_nodes", "(", "include_unobserved", "=", "False", ")", "\n", "assert", "\"Unobserved Confounders\"", "not", "in", "all_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_model.TestCausalModel.test_graph_refutation": [[278, 293], ["pytest.mark.parametrize", "dowhy.datasets.dataset_from_random_graph", "dowhy.datasets.dataset_from_random_graph", "dowhy.datasets.dataset_from_random_graph", "dowhy.datasets.dataset_from_random_graph", "dowhy.CausalModel", "dowhy.CausalModel", "dowhy.CausalModel.refute_graph", "dowhy.CausalModel.refute_graph"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.refute_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.refute_graph"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"num_variables\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "10", ",", "5000", ")", ",", "]", ")", "\n", "def", "test_graph_refutation", "(", "self", ",", "num_variables", ",", "num_samples", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "dataset_from_random_graph", "(", "num_vars", "=", "num_variables", ",", "num_samples", "=", "num_samples", ")", "\n", "df", "=", "data", "[", "\"df\"", "]", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "df", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "data", "[", "\"gml_graph\"", "]", ",", "\n", ")", "\n", "graph_refutation_object", "=", "model", ".", "refute_graph", "(", "k", "=", "1", ",", "independence_test", "=", "\n", "{", "'test_for_continuous'", ":", "'partial_correlation'", ",", "\n", "'test_for_discrete'", ":", "'conditional_mutual_information'", "}", ")", "\n", "assert", "graph_refutation_object", ".", "refutation_result", "==", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_model.TestCausalModel.test_graph_refutation2": [[294, 386], ["pytest.mark.parametrize", "dowhy.datasets.dataset_from_random_graph", "dowhy.datasets.dataset_from_random_graph", "dowhy.datasets.dataset_from_random_graph", "dowhy.datasets.dataset_from_random_graph", "dowhy.CausalModel", "dowhy.CausalModel", "dowhy.CausalModel.refute_graph", "dowhy.CausalModel.refute_graph"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.dataset_from_random_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.refute_graph", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.causal_model.CausalModel.refute_graph"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"num_variables\"", ",", "\"num_samples\"", "]", ",", "\n", "[", "(", "10", ",", "5000", ")", ",", "]", ")", "\n", "def", "test_graph_refutation2", "(", "self", ",", "num_variables", ",", "num_samples", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "dataset_from_random_graph", "(", "num_vars", "=", "num_variables", ",", "num_samples", "=", "num_samples", ")", "\n", "df", "=", "data", "[", "\"df\"", "]", "\n", "gml_str", "=", "\"\"\"\n        graph [\n        directed 1\n        node [\n            id 0\n            label \"a\"\n        ]\n        node [\n            id 1\n            label \"b\"\n        ]\n        node [\n            id 2\n            label \"c\"\n        ]\n        node [\n            id 3\n            label \"d\"\n        ]\n        node [\n            id 4\n            label \"e\"\n        ]\n        node [\n            id 5\n            label \"f\"\n        ]\n        node [\n            id 6\n            label \"g\"\n        ]\n        node [\n            id 7\n            label \"h\"\n        ]\n        node [\n            id 8\n            label \"i\"\n        ]\n        node [\n            id 9\n            label \"j\"\n        ]\n        edge [\n            source 0\n            target 1\n        ]\n        edge [\n            source 0\n            target 3\n        ]\n        edge [\n            source 3\n            target 2\n        ]\n        edge [\n            source 7\n            target 4\n        ]\n        edge [\n            source 6\n            target 5\n        ]\n        edge [\n            source 7\n            target 8\n        ]\n        edge [\n            source 9\n            target 2\n        ]\n        edge [\n            source 9\n            target 8\n        ]\n        ]\n        \"\"\"", "\n", "model", "=", "CausalModel", "(", "\n", "data", "=", "df", ",", "\n", "treatment", "=", "data", "[", "\"treatment_name\"", "]", ",", "\n", "outcome", "=", "data", "[", "\"outcome_name\"", "]", ",", "\n", "graph", "=", "gml_str", ",", "\n", ")", "\n", "graph_refutation_object", "=", "model", ".", "refute_graph", "(", "k", "=", "2", ",", "independence_test", "=", "\n", "{", "'test_for_continuous'", ":", "'partial_correlation'", ",", "\n", "'test_for_discrete'", ":", "'conditional_mutual_information'", "}", ")", "\n", "assert", "graph_refutation_object", ".", "refutation_result", "==", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_notebooks._notebook_run": [[36, 57], ["tempfile.NamedTemporaryFile", "subprocess.check_call", "fout.seek", "nbformat.read"], "function", ["None"], ["", "def", "_notebook_run", "(", "filepath", ")", ":", "\n", "    ", "\"\"\"Execute a notebook via nbconvert and collect output.\n       :returns (parsed nb object, execution errors)\n\n       Source of this function: http://www.christianmoscardi.com/blog/2016/01/20/jupyter-testing.html\n    \"\"\"", "\n", "with", "tempfile", ".", "NamedTemporaryFile", "(", "suffix", "=", "\".ipynb\"", ")", "as", "fout", ":", "\n", "        ", "args", "=", "[", "\"jupyter\"", ",", "\"nbconvert\"", ",", "\"--to\"", ",", "\"notebook\"", ",", "\"--execute\"", ",", "\n", "#          \"--ExecutePreprocessor.timeout=600\",", "\n", "\"-y\"", ",", "\"--no-prompt\"", ",", "\n", "\"--output\"", ",", "fout", ".", "name", ",", "filepath", "]", "\n", "subprocess", ".", "check_call", "(", "args", ")", "\n", "\n", "fout", ".", "seek", "(", "0", ")", "\n", "nb", "=", "nbformat", ".", "read", "(", "fout", ",", "nbformat", ".", "current_nbformat", ")", "\n", "\n", "", "errors", "=", "[", "output", "for", "cell", "in", "nb", ".", "cells", "if", "\"outputs\"", "in", "cell", "\n", "for", "output", "in", "cell", "[", "\"outputs\"", "]", "if", "output", ".", "output_type", "==", "\"error\"", "]", "\n", "\n", "return", "nb", ",", "errors", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_notebooks.test_notebook": [[79, 83], ["pytest.mark.parametrize", "test_notebooks._notebook_run"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_notebooks._notebook_run"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"notebook_filename\"", ",", "parameter_list", ")", "\n", "def", "test_notebook", "(", "notebook_filename", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "_notebook_run", "(", "NOTEBOOKS_PATH", "+", "notebook_filename", ")", "\n", "assert", "errors", "==", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_data_transformer.test_dimensionality_reducer_placeholder_methods": [[10, 14], ["test_data_transformer.MockReducer", "pytest.raises", "MockReducer.reduce"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.data_transformers.pca_reducer.PCAReducer.reduce"], ["", "def", "test_dimensionality_reducer_placeholder_methods", "(", ")", ":", "\n", "\t", "reducer", "=", "MockReducer", "(", "None", ",", "None", ")", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "\t\t", "reducer", ".", "reduce", "(", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_estimator.TestCausalEstimator.setUp": [[22, 29], ["None"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "# self.df = pd.read_csv(os.path.join(DATA_PATH,'dgp_1/acic_1_1_data.csv'))", "\n", "# self.ate = np.mean(self.df['y1'] - self.df['y0'])", "\n", "# treated = self.df[self.df['z']==1]", "\n", "# self.att = np.mean(treated['y1'] - treated['y0'])", "\n", "        ", "self", ".", "df", "=", "None", "\n", "self", ".", "ate", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.test_causal_estimator.test_causal_estimator_placeholder_methods": [[11, 19], ["test_causal_estimator.MockEstimator", "pytest.raises", "MockEstimator._estimate_effect", "pytest.raises", "MockEstimator._do", "pytest.raises", "MockEstimator.construct_symbolic_estimator"], "function", ["home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator._estimate_effect", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.econml.Econml._do", "home.repos.pwc.inspect_result.microsoft_dowhy.causal_estimators.propensity_score_stratification_estimator.PropensityScoreStratificationEstimator.construct_symbolic_estimator"], ["", "def", "test_causal_estimator_placeholder_methods", "(", ")", ":", "\n", "    ", "estimator", "=", "MockEstimator", "(", "None", ",", "None", ",", "[", "None", "]", ",", "[", "None", "]", ",", "None", ")", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "estimator", ".", "_estimate_effect", "(", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "estimator", ".", "_do", "(", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "estimator", ".", "construct_symbolic_estimator", "(", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.tests.conftest.fixed_seed": [[5, 9], ["random.seed", "numpy.random.seed"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "fixed_seed", "(", ")", ":", "\n", "    ", "rand", ".", "seed", "(", "0", ")", "\n", "numpy", ".", "random", ".", "seed", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_sampler.test_pandas_do_api.TestPandasDoAPI.test_pandas_api_discrete_cause_continuous_confounder": [[12, 48], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "numpy.random.normal", "data[].copy", "data[].copy.causal.do", "numpy.abs", "print", "numpy.random.normal", "causal_df[].mean", "causal_df[].mean", "numpy.random.normal"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"N\"", ",", "\"error_tolerance\"", "]", ",", "\n", "[", "(", "10000", ",", "0.1", ")", ",", "]", ")", "\n", "def", "test_pandas_api_discrete_cause_continuous_confounder", "(", "self", ",", "N", ",", "error_tolerance", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "num_instruments", "=", "1", ",", "\n", "num_samples", "=", "N", ",", "\n", "treatment_is_binary", "=", "False", ")", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "N", ")", "\n", "v", "=", "(", "np", ".", "random", ".", "normal", "(", "size", "=", "N", ")", "+", "X0", ")", ".", "astype", "(", "int", ")", "\n", "y", "=", "data", "[", "'ate'", "]", "*", "v", "+", "X0", "+", "np", ".", "random", ".", "normal", "(", ")", "\n", "data", "[", "'df'", "]", "[", "'v'", "]", "=", "v", "\n", "data", "[", "'df'", "]", "[", "'X0'", "]", "=", "X0", "\n", "data", "[", "'df'", "]", "[", "'y'", "]", "=", "y", "\n", "df", "=", "data", "[", "'df'", "]", ".", "copy", "(", ")", "\n", "\n", "variable_types", "=", "{", "'v'", ":", "'d'", ",", "'X0'", ":", "'c'", ",", "'y'", ":", "'c'", "}", "\n", "outcome", "=", "'y'", "\n", "cause", "=", "'v'", "\n", "common_causes", "=", "'X0'", "\n", "method", "=", "'weighting'", "\n", "causal_df", "=", "df", ".", "causal", ".", "do", "(", "x", "=", "cause", ",", "\n", "variable_types", "=", "variable_types", ",", "\n", "outcome", "=", "outcome", ",", "\n", "method", "=", "method", ",", "\n", "common_causes", "=", "common_causes", ",", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "\n", "ate", "=", "(", "causal_df", "[", "causal_df", ".", "v", "==", "1", "]", ".", "mean", "(", ")", "-", "causal_df", "[", "causal_df", ".", "v", "==", "0", "]", ".", "mean", "(", ")", ")", "[", "'y'", "]", "\n", "error", "=", "np", ".", "abs", "(", "ate", "-", "data", "[", "'ate'", "]", ")", "\n", "res", "=", "True", "if", "(", "error", "<", "data", "[", "'ate'", "]", "*", "error_tolerance", ")", "else", "False", "\n", "print", "(", "\"Error in ATE estimate = {0} with tolerance {1}%. Estimated={2},True={3}\"", ".", "format", "(", "\n", "error", ",", "error_tolerance", "*", "100", ",", "ate", ",", "data", "[", "'ate'", "]", ")", "\n", ")", "\n", "assert", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_sampler.test_pandas_do_api.TestPandasDoAPI.test_pandas_api_discrete_cause_discrete_confounder": [[49, 86], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "numpy.random.normal().astype", "data[].copy", "data[].copy.causal.do", "print", "numpy.abs", "print", "numpy.random.normal", "numpy.random.normal", "causal_df[].mean", "causal_df[].mean", "numpy.random.normal"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"N\"", ",", "\"error_tolerance\"", "]", ",", "\n", "[", "(", "10000", ",", "0.1", ")", ",", "]", ")", "\n", "def", "test_pandas_api_discrete_cause_discrete_confounder", "(", "self", ",", "N", ",", "error_tolerance", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "num_instruments", "=", "1", ",", "\n", "num_samples", "=", "N", ",", "\n", "treatment_is_binary", "=", "False", ")", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "N", ")", ".", "astype", "(", "int", ")", "\n", "v", "=", "(", "np", ".", "random", ".", "normal", "(", "size", "=", "N", ")", "+", "X0", ")", ".", "astype", "(", "int", ")", "\n", "y", "=", "data", "[", "'ate'", "]", "*", "v", "+", "X0", "+", "np", ".", "random", ".", "normal", "(", ")", "\n", "data", "[", "'df'", "]", "[", "'v'", "]", "=", "v", "\n", "data", "[", "'df'", "]", "[", "'X0'", "]", "=", "X0", "\n", "data", "[", "'df'", "]", "[", "'y'", "]", "=", "y", "\n", "df", "=", "data", "[", "'df'", "]", ".", "copy", "(", ")", "\n", "\n", "variable_types", "=", "{", "'v'", ":", "'d'", ",", "'X0'", ":", "'d'", ",", "'y'", ":", "'c'", "}", "\n", "outcome", "=", "'y'", "\n", "cause", "=", "'v'", "\n", "common_causes", "=", "'X0'", "\n", "method", "=", "'weighting'", "\n", "causal_df", "=", "df", ".", "causal", ".", "do", "(", "x", "=", "cause", ",", "\n", "variable_types", "=", "variable_types", ",", "\n", "outcome", "=", "outcome", ",", "\n", "method", "=", "method", ",", "\n", "common_causes", "=", "common_causes", ",", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "\n", "ate", "=", "(", "causal_df", "[", "causal_df", ".", "v", "==", "1", "]", ".", "mean", "(", ")", "-", "causal_df", "[", "causal_df", ".", "v", "==", "0", "]", ".", "mean", "(", ")", ")", "[", "'y'", "]", "\n", "print", "(", "'ate'", ",", "ate", ")", "\n", "error", "=", "np", ".", "abs", "(", "ate", "-", "data", "[", "'ate'", "]", ")", "\n", "res", "=", "True", "if", "(", "error", "<", "data", "[", "'ate'", "]", "*", "error_tolerance", ")", "else", "False", "\n", "print", "(", "\"Error in ATE estimate = {0} with tolerance {1}%. Estimated={2},True={3}\"", ".", "format", "(", "\n", "error", ",", "error_tolerance", "*", "100", ",", "ate", ",", "data", "[", "'ate'", "]", ")", "\n", ")", "\n", "assert", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_sampler.test_pandas_do_api.TestPandasDoAPI.test_pandas_api_continuous_cause_discrete_confounder": [[87, 123], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "numpy.random.normal().astype", "data[].copy", "data[].copy.causal.do", "print", "numpy.abs", "print", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "sklearn.linear_model.LinearRegression().fit", "sklearn.linear_model.LinearRegression"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"N\"", ",", "\"error_tolerance\"", "]", ",", "\n", "[", "(", "10000", ",", "0.1", ")", ",", "]", ")", "\n", "def", "test_pandas_api_continuous_cause_discrete_confounder", "(", "self", ",", "N", ",", "error_tolerance", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "num_instruments", "=", "1", ",", "\n", "num_samples", "=", "N", ",", "\n", "treatment_is_binary", "=", "False", ")", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "N", ")", ".", "astype", "(", "int", ")", "\n", "v", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "N", ")", "+", "X0", "\n", "y", "=", "data", "[", "'ate'", "]", "*", "v", "+", "X0", "+", "np", ".", "random", ".", "normal", "(", ")", "\n", "data", "[", "'df'", "]", "[", "'v'", "]", "=", "v", "\n", "data", "[", "'df'", "]", "[", "'X0'", "]", "=", "X0", "\n", "data", "[", "'df'", "]", "[", "'y'", "]", "=", "y", "\n", "df", "=", "data", "[", "'df'", "]", ".", "copy", "(", ")", "\n", "\n", "variable_types", "=", "{", "'v'", ":", "'c'", ",", "'X0'", ":", "'d'", ",", "'y'", ":", "'c'", "}", "\n", "outcome", "=", "'y'", "\n", "cause", "=", "'v'", "\n", "common_causes", "=", "'X0'", "\n", "method", "=", "'weighting'", "\n", "causal_df", "=", "df", ".", "causal", ".", "do", "(", "x", "=", "cause", ",", "\n", "variable_types", "=", "variable_types", ",", "\n", "outcome", "=", "outcome", ",", "\n", "method", "=", "method", ",", "\n", "common_causes", "=", "common_causes", ",", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "\n", "ate", "=", "LinearRegression", "(", ")", ".", "fit", "(", "causal_df", "[", "[", "'v'", "]", "]", ",", "causal_df", "[", "'y'", "]", ")", ".", "coef_", "[", "0", "]", "\n", "print", "(", "'ate'", ",", "ate", ")", "\n", "error", "=", "np", ".", "abs", "(", "ate", "-", "data", "[", "'ate'", "]", ")", "\n", "res", "=", "True", "if", "(", "error", "<", "data", "[", "'ate'", "]", "*", "error_tolerance", ")", "else", "False", "\n", "print", "(", "\"Error in ATE estimate = {0} with tolerance {1}%. Estimated={2},True={3}\"", ".", "format", "(", "\n", "error", ",", "error_tolerance", "*", "100", ",", "ate", ",", "data", "[", "'ate'", "]", ")", "\n", ")", "\n", "assert", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_sampler.test_pandas_do_api.TestPandasDoAPI.test_pandas_api_continuous_cause_continuous_confounder": [[124, 160], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "numpy.random.normal", "data[].copy", "data[].copy.causal.do", "print", "numpy.abs", "print", "numpy.random.normal", "numpy.random.normal", "sklearn.linear_model.LinearRegression().fit", "sklearn.linear_model.LinearRegression"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do", "home.repos.pwc.inspect_result.microsoft_dowhy.ml.regression.SklearnRegressionModel.fit"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"N\"", ",", "\"error_tolerance\"", "]", ",", "\n", "[", "(", "10000", ",", "0.1", ")", ",", "]", ")", "\n", "def", "test_pandas_api_continuous_cause_continuous_confounder", "(", "self", ",", "N", ",", "error_tolerance", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "10", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "num_instruments", "=", "1", ",", "\n", "num_samples", "=", "N", ",", "\n", "treatment_is_binary", "=", "False", ")", "\n", "X0", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "N", ")", "\n", "v", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "N", ")", "+", "X0", "\n", "y", "=", "data", "[", "'ate'", "]", "*", "v", "+", "X0", "+", "np", ".", "random", ".", "normal", "(", ")", "\n", "data", "[", "'df'", "]", "[", "'v'", "]", "=", "v", "\n", "data", "[", "'df'", "]", "[", "'X0'", "]", "=", "X0", "\n", "data", "[", "'df'", "]", "[", "'y'", "]", "=", "y", "\n", "df", "=", "data", "[", "'df'", "]", ".", "copy", "(", ")", "\n", "\n", "variable_types", "=", "{", "'v'", ":", "'c'", ",", "'X0'", ":", "'c'", ",", "'y'", ":", "'c'", "}", "\n", "outcome", "=", "'y'", "\n", "cause", "=", "'v'", "\n", "common_causes", "=", "'X0'", "\n", "method", "=", "'weighting'", "\n", "causal_df", "=", "df", ".", "causal", ".", "do", "(", "x", "=", "cause", ",", "\n", "variable_types", "=", "variable_types", ",", "\n", "outcome", "=", "outcome", ",", "\n", "method", "=", "method", ",", "\n", "common_causes", "=", "common_causes", ",", "\n", "proceed_when_unidentifiable", "=", "True", ")", "\n", "\n", "ate", "=", "LinearRegression", "(", ")", ".", "fit", "(", "causal_df", "[", "[", "'v'", "]", "]", ",", "causal_df", "[", "'y'", "]", ")", ".", "coef_", "[", "0", "]", "\n", "print", "(", "'ate'", ",", "ate", ")", "\n", "error", "=", "np", ".", "abs", "(", "ate", "-", "data", "[", "'ate'", "]", ")", "\n", "res", "=", "True", "if", "(", "error", "<", "data", "[", "'ate'", "]", "*", "error_tolerance", ")", "else", "False", "\n", "print", "(", "\"Error in ATE estimate = {0} with tolerance {1}%. Estimated={2},True={3}\"", ".", "format", "(", "\n", "error", ",", "error_tolerance", "*", "100", ",", "ate", ",", "data", "[", "'ate'", "]", ")", "\n", ")", "\n", "assert", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_sampler.test_pandas_do_api.TestPandasDoAPI.test_pandas_api_with_full_specification_of_type": [[166, 181], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "data[].causal.do().groupby().mean", "data[].causal.do().groupby", "data[].causal.do"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"N\"", ",", "\"variable_types\"", "]", ",", "\n", "[", "(", "10000", ",", "{", "'v0'", ":", "'b'", ",", "'y'", ":", "'c'", ",", "'W0'", ":", "'c'", "}", ")", ",", "]", ")", "\n", "def", "test_pandas_api_with_full_specification_of_type", "(", "self", ",", "N", ",", "variable_types", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "5", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "num_instruments", "=", "0", ",", "\n", "num_samples", "=", "1000", ",", "\n", "treatment_is_binary", "=", "True", ")", "\n", "\n", "data", "[", "'df'", "]", ".", "causal", ".", "do", "(", "x", "=", "'v0'", ",", "\n", "variable_types", "=", "variable_types", ",", "\n", "outcome", "=", "'y'", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "common_causes", "=", "[", "'W0'", "]", ")", ".", "groupby", "(", "'v0'", ")", ".", "mean", "(", ")", "\n", "assert", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_sampler.test_pandas_do_api.TestPandasDoAPI.test_pandas_api_with_partial_specification_of_type": [[182, 197], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "data[].causal.do().groupby().mean", "data[].causal.do().groupby", "data[].causal.do"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"N\"", ",", "\"variable_types\"", "]", ",", "\n", "[", "(", "10000", ",", "{", "'v0'", ":", "'b'", ",", "'W0'", ":", "'c'", "}", ")", ",", "]", ")", "\n", "def", "test_pandas_api_with_partial_specification_of_type", "(", "self", ",", "N", ",", "variable_types", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "5", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "num_instruments", "=", "0", ",", "\n", "num_samples", "=", "1000", ",", "\n", "treatment_is_binary", "=", "True", ")", "\n", "\n", "data", "[", "'df'", "]", ".", "causal", ".", "do", "(", "x", "=", "'v0'", ",", "\n", "variable_types", "=", "variable_types", ",", "\n", "outcome", "=", "'y'", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "common_causes", "=", "[", "'W0'", "]", ")", ".", "groupby", "(", "'v0'", ")", ".", "mean", "(", ")", "\n", "assert", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_sampler.test_pandas_do_api.TestPandasDoAPI.test_pandas_api_with_no_specification_of_type": [[198, 213], ["pytest.mark.parametrize", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "dowhy.datasets.linear_dataset", "data[].causal.do().groupby().mean", "data[].causal.do().groupby", "data[].causal.do"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.dowhy.datasets.linear_dataset", "home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"N\"", ",", "\"variable_types\"", "]", ",", "\n", "[", "(", "10000", ",", "{", "}", ")", ",", "]", ")", "\n", "def", "test_pandas_api_with_no_specification_of_type", "(", "self", ",", "N", ",", "variable_types", ")", ":", "\n", "        ", "data", "=", "dowhy", ".", "datasets", ".", "linear_dataset", "(", "beta", "=", "5", ",", "\n", "num_common_causes", "=", "1", ",", "\n", "num_instruments", "=", "0", ",", "\n", "num_samples", "=", "1000", ",", "\n", "treatment_is_binary", "=", "True", ")", "\n", "\n", "data", "[", "'df'", "]", ".", "causal", ".", "do", "(", "x", "=", "'v0'", ",", "\n", "variable_types", "=", "variable_types", ",", "\n", "outcome", "=", "'y'", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "common_causes", "=", "[", "'W0'", "]", ")", ".", "groupby", "(", "'v0'", ")", ".", "mean", "(", ")", "\n", "assert", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.microsoft_dowhy.do_sampler.test_pandas_do_api.TestPandasDoAPI.test_pandas_api_with_dummy_data": [[214, 223], ["pytest.mark.parametrize", "pandas.DataFrame", "pandas.DataFrame.causal.do", "print", "dict"], "methods", ["home.repos.pwc.inspect_result.microsoft_dowhy.api.causal_data_frame.CausalAccessor.do"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "[", "\"N\"", ",", "\"variable_types\"", "]", ",", "\n", "[", "(", "1", ",", "{", "'v0'", ":", "'b'", ",", "'W0'", ":", "'c'", "}", ")", ",", "]", ")", "\n", "\n", "def", "test_pandas_api_with_dummy_data", "(", "self", ",", "N", ",", "variable_types", ")", ":", "\n", "        ", "df", "=", "pd", ".", "DataFrame", "(", "{", "'x'", ":", "[", "0", ",", "0.5", ",", "1", "]", ",", "'y'", ":", "[", "1", ",", "0.5", ",", "0", "]", ",", "'a'", ":", "[", "0", ",", "0.5", ",", "0", "]", ",", "'b'", ":", "[", "0.25", ",", "0", ",", "0", "]", "}", ")", "\n", "dd", "=", "df", ".", "causal", ".", "do", "(", "x", "=", "[", "'x'", "]", ",", "outcome", "=", "'y'", ",", "common_causes", "=", "[", "'a'", ",", "'b'", "]", ",", "\n", "proceed_when_unidentifiable", "=", "True", ",", "\n", "variable_types", "=", "dict", "(", "x", "=", "'c'", ",", "y", "=", "'c'", ",", "a", "=", "'c'", ",", "b", "=", "'c'", ")", ")", "\n", "print", "(", "dd", ")", "\n", "\n"]]}