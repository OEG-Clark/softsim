{"home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.config.Config.__init__": [[200, 225], ["numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "stage", ")", ":", "\n", "        ", "\"\"\"Set values of computed attributes.\"\"\"", "\n", "# Effective batch size", "\n", "self", ".", "BATCH_SIZE", "=", "self", ".", "IMAGES_PER_GPU", "*", "self", ".", "GPU_COUNT", "\n", "\n", "# Input image size: [height, width, depth, channels]", "\n", "if", "self", ".", "IMAGE_RESIZE_MODE", "==", "\"crop\"", ":", "\n", "            ", "self", ".", "IMAGE_SHAPE", "=", "np", ".", "array", "(", "[", "self", ".", "IMAGE_MIN_DIM", ",", "self", ".", "IMAGE_MIN_DIM", ",", "self", ".", "IMAGE_MIN_DIM", ",", "1", "]", ")", "\n", "", "elif", "self", ".", "IMAGE_RESIZE_MODE", "==", "\"self\"", ":", "\n", "            ", "self", ".", "IMAGE_SHAPE", "=", "np", ".", "array", "(", "[", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MIN_DIM", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "IMAGE_SHAPE", "=", "np", ".", "array", "(", "[", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MAX_DIM", ",", "1", "]", ")", "\n", "\n", "# Image meta data length", "\n", "# See compose_image_meta() for details", "\n", "", "self", ".", "IMAGE_META_SIZE", "=", "1", "+", "4", "+", "4", "+", "6", "+", "1", "+", "self", ".", "NUM_CLASSES", "\n", "self", ".", "STAGE", "=", "stage", "\n", "if", "stage", "==", "'finetune'", ":", "\n", "            ", "self", ".", "MINI_MASK_SHAPE", "=", "(", "192", ",", "192", ",", "192", ")", "\n", "self", ".", "MASK_SHAPE", "=", "(", "192", ",", "192", ",", "192", ")", "\n", "self", ".", "DETECTION_TARGET_IOU_THRESHOLD", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "self", ".", "MINI_MASK_SHAPE", "=", "(", "96", ",", "96", ",", "96", ")", "\n", "self", ".", "MASK_SHAPE", "=", "(", "96", ",", "96", ",", "96", ")", "\n", "self", ".", "DETECTION_TARGET_IOU_THRESHOLD", "=", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.config.Config.display": [[226, 233], ["print", "dir", "print", "print", "a.startswith", "callable", "getattr", "getattr"], "methods", ["None"], ["", "", "def", "display", "(", "self", ")", ":", "\n", "        ", "\"\"\"Display Configuration values.\"\"\"", "\n", "print", "(", "\"\\nConfigurations:\"", ")", "\n", "for", "a", "in", "dir", "(", "self", ")", ":", "\n", "            ", "if", "not", "a", ".", "startswith", "(", "\"__\"", ")", "and", "not", "callable", "(", "getattr", "(", "self", ",", "a", ")", ")", ":", "\n", "                ", "print", "(", "\"{:30} {}\"", ".", "format", "(", "a", ",", "getattr", "(", "self", ",", "a", ")", ")", ")", "\n", "", "", "print", "(", "\"\\n\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.HeartDataset.load_heart": [[183, 219], ["heart_main.HeartDataset.add_class", "heart_main.HeartDataset.add_class", "heart_main.HeartDataset.add_class", "heart_main.HeartDataset.add_class", "heart_main.HeartDataset.add_class", "heart_main.HeartDataset.add_class", "heart_main.HeartDataset.add_class", "json.load", "list", "open", "nibabel.load().get_data().copy", "heart_main.HeartDataset.add_image", "nibabel.load().get_data", "nibabel.load"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_image"], ["    ", "def", "load_heart", "(", "self", ",", "subset", ")", ":", "\n", "        ", "\"\"\"Load a subset of the heart dataset.\n        dataset_dir: Root directory of the dataset.\n        subset: Subset to load: train or val\n        \"\"\"", "\n", "# Add classes. We have seven classes to add.", "\n", "self", ".", "add_class", "(", "\"heart\"", ",", "1", ",", "\"a\"", ")", "\n", "self", ".", "add_class", "(", "\"heart\"", ",", "2", ",", "\"b\"", ")", "\n", "self", ".", "add_class", "(", "\"heart\"", ",", "3", ",", "\"c\"", ")", "\n", "self", ".", "add_class", "(", "\"heart\"", ",", "4", ",", "\"d\"", ")", "\n", "self", ".", "add_class", "(", "\"heart\"", ",", "5", ",", "\"e\"", ")", "\n", "self", ".", "add_class", "(", "\"heart\"", ",", "6", ",", "\"f\"", ")", "\n", "self", ".", "add_class", "(", "\"heart\"", ",", "7", ",", "\"g\"", ")", "\n", "\n", "# Train or validation dataset?", "\n", "assert", "subset", "in", "[", "\"train\"", ",", "\"val\"", "]", "\n", "\n", "# Load dataset info", "\n", "info", "=", "json", ".", "load", "(", "open", "(", "args", ".", "data", "+", "\"dataset.json\"", ")", ")", "\n", "info", "=", "list", "(", "info", "[", "'train_and_test'", "]", ")", "\n", "\n", "if", "subset", "==", "\"train\"", ":", "\n", "            ", "info", "=", "info", "[", "13", ":", "]", "\n", "", "else", ":", "\n", "            ", "info", "=", "info", "[", ":", "13", "]", "\n", "\n", "# Add images and masks", "\n", "", "for", "a", "in", "info", ":", "\n", "            ", "image", "=", "nib", ".", "load", "(", "a", "[", "'image'", "]", ")", ".", "get_data", "(", ")", ".", "copy", "(", ")", "\n", "height", ",", "width", ",", "depth", "=", "image", ".", "shape", "\n", "self", ".", "add_image", "(", "\n", "\"heart\"", ",", "\n", "image_id", "=", "a", "[", "'image'", "]", ",", "# use file name as a unique image id", "\n", "path", "=", "a", "[", "'image'", "]", ",", "\n", "width", "=", "width", ",", "height", "=", "height", ",", "depth", "=", "depth", ",", "\n", "mask", "=", "a", "[", "'label'", "]", ")", "# save the path of the corresponding mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.HeartDataset.load_image": [[220, 225], ["nibabel.load().get_data().copy", "numpy.expand_dims", "nibabel.load().get_data", "nibabel.load"], "methods", ["None"], ["", "", "def", "load_image", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified image and return a [H,W,D,C] Numpy array.\"\"\"", "\n", "# Load image", "\n", "image", "=", "nib", ".", "load", "(", "self", ".", "image_info", "[", "image_id", "]", "[", "'path'", "]", ")", ".", "get_data", "(", ")", ".", "copy", "(", ")", "\n", "return", "np", ".", "expand_dims", "(", "image", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.HeartDataset.process_mask": [[226, 239], ["numpy.zeros", "range", "numpy.zeros.astype", "numpy.arange"], "methods", ["None"], ["", "def", "process_mask", "(", "self", ",", "mask", ")", ":", "\n", "        ", "\"\"\"Given the [depth, height, width] mask that may contains many classes of annotations.\n        Generate instance masks and a mask that only contains one class (heart) from it.\n        Returns:\n        masks: A np.int32 array of shape [depth, height, width, instance_count] with\n            one mask per instance.\n        class_ids: a 1D array of class IDs of the instance masks.\n        \"\"\"", "\n", "masks", "=", "np", ".", "zeros", "(", "(", "self", ".", "num_classes", ",", "mask", ".", "shape", "[", "0", "]", ",", "mask", ".", "shape", "[", "1", "]", ",", "mask", ".", "shape", "[", "2", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_classes", ")", ":", "\n", "            ", "masks", "[", "i", "]", "[", "mask", "==", "i", "]", "=", "1", "\n", "# Return masks and array of class IDs of each instance.", "\n", "", "return", "masks", ".", "astype", "(", "np", ".", "int32", ")", ",", "np", ".", "arange", "(", "1", ",", "self", ".", "num_classes", ",", "1", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.HeartDataset.load_mask": [[240, 254], ["nibabel.load().get_data().copy", "super().load_mask", "nibabel.load().get_data", "nibabel.load"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.load_mask"], ["", "def", "load_mask", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified mask and return a [H,W,D] Numpy array.\n       Returns:\n        masks: A np.int32 array of shape [height, width, depth].\n        \"\"\"", "\n", "# If not a heart dataset image, delegate to parent class.", "\n", "image_info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "if", "image_info", "[", "\"source\"", "]", "!=", "\"heart\"", ":", "\n", "            ", "return", "super", "(", "self", ".", "__class__", ",", "self", ")", ".", "load_mask", "(", "image_id", ")", "\n", "\n", "# Convert masks to a bitmap mask of shape [height, width, depth, instance_count]", "\n", "# Load the mask.", "\n", "", "mask", "=", "nib", ".", "load", "(", "self", ".", "image_info", "[", "image_id", "]", "[", "'mask'", "]", ")", ".", "get_data", "(", ")", ".", "copy", "(", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.HeartDataset.image_reference": [[255, 262], ["super().image_reference"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.image_reference"], ["", "def", "image_reference", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Return the path of the image.\"\"\"", "\n", "info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "if", "info", "[", "\"source\"", "]", "==", "\"heart\"", ":", "\n", "            ", "return", "info", "[", "\"path\"", "]", "\n", "", "else", ":", "\n", "            ", "super", "(", "self", ".", "__class__", ",", "self", ")", ".", "image_reference", "(", "image_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.train": [[264, 280], ["heart_main.HeartDataset", "heart_main.HeartDataset.load_heart", "HeartDataset.prepare", "heart_main.HeartDataset", "heart_main.HeartDataset.load_heart", "HeartDataset.prepare", "print", "model.train_model"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.HeartDataset.load_heart", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.prepare", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.HeartDataset.load_heart", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.prepare", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.train_model"], ["", "", "", "def", "train", "(", "model", ")", ":", "\n", "    ", "\"\"\"Train the model\"\"\"", "\n", "# Training dataset", "\n", "dataset_train", "=", "HeartDataset", "(", ")", "\n", "dataset_train", ".", "load_heart", "(", "\"train\"", ")", "\n", "dataset_train", ".", "prepare", "(", ")", "\n", "\n", "# Validation dataset", "\n", "dataset_val", "=", "HeartDataset", "(", ")", "\n", "dataset_val", ".", "load_heart", "(", "\"val\"", ")", "\n", "dataset_val", ".", "prepare", "(", ")", "\n", "\n", "print", "(", "\"Train all layers\"", ")", "\n", "model", ".", "train_model", "(", "dataset_train", ",", "dataset_val", ",", "\n", "learning_rate", "=", "config", ".", "LEARNING_RATE", ",", "\n", "epochs", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.heart_main.test": [[286, 361], ["json.load", "list", "print", "numpy.array", "print", "print", "print", "print", "open", "nibabel.load().get_data().copy", "nibabel.load", "label.get_data().copy.get_data().copy", "numpy.expand_dims", "time.time", "print", "numpy.zeros", "numpy.zeros", "range", "range", "utils.compute_per_class_mask_iou", "np.array.append", "print", "numpy.mean", "numpy.std", "np.array.mean", "model.detect", "time.time", "nibabel.Nifti1Image", "nibabel.save", "nibabel.load().get_data", "label.get_data().copy.get_data", "time.time", "mask.astype", "os.path.exists", "os.makedirs", "str", "nibabel.load", "str", "utils.compute_per_class_mask_iou.mean"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_per_class_mask_iou", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.detect"], ["", "def", "test", "(", "model", ",", "limit", ",", "save", ",", "bbox", ")", ":", "\n", "    ", "\"\"\"Test the model.\n    model: the model to test.\n    limit: the images to be used.\n    save: whether to save the masks.\n    limit: whether to draw the bboxes.\n    \"\"\"", "\n", "per_class_ious", "=", "[", "]", "\n", "info", "=", "json", ".", "load", "(", "open", "(", "args", ".", "data", "+", "\"dataset.json\"", ")", ")", "\n", "info", "=", "list", "(", "info", "[", "'train_and_test'", "]", ")", "\n", "detect_time", "=", "0", "\n", "for", "path", "in", "info", "[", ":", "limit", "]", ":", "\n", "        ", "path_image", "=", "path", "[", "'image'", "]", "\n", "path_label", "=", "path", "[", "'label'", "]", "\n", "image", "=", "nib", ".", "load", "(", "path_image", ")", ".", "get_data", "(", ")", ".", "copy", "(", ")", "\n", "label", "=", "nib", ".", "load", "(", "path_label", ")", "# load the gt-masks", "\n", "affine", "=", "label", ".", "affine", "# prepared to save the predicted mask later", "\n", "label", "=", "label", ".", "get_data", "(", ")", ".", "copy", "(", ")", "\n", "image", "=", "np", ".", "expand_dims", "(", "image", ",", "-", "1", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "model", ".", "detect", "(", "[", "image", "]", ")", "[", "0", "]", "\n", "detect_time", "+=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"detect_time:\"", ",", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "\"\"\"The shape of result: a dict containing\n        {\n            \"rois\": final_rois,           [N, (y1, x1, z1, y2, x2, z2)] in real coordinates\n            \"class_ids\": final_class_ids, [N]\n            \"scores\": final_scores,       [N]\n            \"mask\": final_mask,           [mask_shape[0], mask_shape[1], mask_shape[2]]\n        }\"\"\"", "\n", "rois", "=", "result", "[", "\"rois\"", "]", "\n", "class_ids", "=", "result", "[", "\"class_ids\"", "]", "\n", "scores", "=", "result", "[", "\"scores\"", "]", "\n", "mask", "=", "result", "[", "\"mask\"", "]", "\n", "# Prepare the gt-masks and pred-masks to calculate the ious.", "\n", "gt_masks", "=", "np", ".", "zeros", "(", "(", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "1", "]", ",", "image", ".", "shape", "[", "2", "]", ",", "model", ".", "config", ".", "NUM_CLASSES", "-", "1", ")", ")", "\n", "pred_masks", "=", "np", ".", "zeros", "(", "(", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "1", "]", ",", "image", ".", "shape", "[", "2", "]", ",", "model", ".", "config", ".", "NUM_CLASSES", "-", "1", ")", ")", "\n", "# Generate the per instance gt masks.", "\n", "for", "j", "in", "range", "(", "model", ".", "config", ".", "NUM_CLASSES", "-", "1", ")", ":", "\n", "            ", "gt_masks", "[", ":", ",", ":", ",", ":", ",", "j", "]", "[", "label", "==", "j", "+", "1", "]", "=", "1", "\n", "# Generate the per instance predicted masks.", "\n", "", "for", "j", "in", "range", "(", "model", ".", "config", ".", "NUM_CLASSES", "-", "1", ")", ":", "\n", "            ", "pred_masks", "[", ":", ",", ":", ",", ":", ",", "j", "]", "[", "mask", "==", "j", "+", "1", "]", "=", "1", "\n", "# calculate different kind of ious", "\n", "", "per_class_iou", "=", "utils", ".", "compute_per_class_mask_iou", "(", "gt_masks", ",", "pred_masks", ")", "\n", "per_class_ious", ".", "append", "(", "per_class_iou", ")", "\n", "# Save the results", "\n", "if", "save", "==", "\"true\"", ":", "\n", "# Draw bboxes", "\n", "            ", "if", "bbox", "==", "\"true\"", ":", "\n", "                ", "y1", ",", "x1", ",", "z1", ",", "y2", ",", "x2", ",", "z2", "=", "rois", "[", "0", ",", ":", "]", "\n", "mask", "[", "y1", ",", "x1", ":", "x2", ",", "z1", "]", "=", "10", "\n", "mask", "[", "y1", ",", "x1", ":", "x2", ",", "z2", "]", "=", "10", "\n", "mask", "[", "y2", ",", "x1", ":", "x2", ",", "z1", "]", "=", "10", "\n", "mask", "[", "y2", ",", "x1", ":", "x2", ",", "z2", "]", "=", "10", "\n", "mask", "[", "y1", ":", "y2", ",", "x1", ",", "z1", "]", "=", "10", "\n", "mask", "[", "y1", ":", "y2", ",", "x2", ",", "z1", "]", "=", "10", "\n", "mask", "[", "y1", ":", "y2", ",", "x1", ",", "z2", "]", "=", "10", "\n", "mask", "[", "y1", ":", "y2", ",", "x2", ",", "z2", "]", "=", "10", "\n", "mask", "[", "y1", ",", "x1", ",", "z1", ":", "z2", "]", "=", "10", "\n", "mask", "[", "y1", ",", "x2", ",", "z1", ":", "z2", "]", "=", "10", "\n", "mask", "[", "y2", ",", "x1", ",", "z1", ":", "z2", "]", "=", "10", "\n", "mask", "[", "y2", ",", "x2", ",", "z1", ":", "z2", "]", "=", "10", "\n", "", "vol", "=", "nib", ".", "Nifti1Image", "(", "mask", ".", "astype", "(", "np", ".", "int32", ")", ",", "affine", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "\"./results\"", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "\"./results\"", ")", "\n", "", "nib", ".", "save", "(", "vol", ",", "\"./results/\"", "+", "str", "(", "per_class_iou", ".", "mean", "(", ")", ")", "+", "\"_\"", "+", "path_image", "[", "-", "17", ":", "]", ")", "\n", "", "print", "(", "path_image", "[", "-", "17", ":", "]", "+", "\" detected done. iou = \"", "+", "str", "(", "per_class_iou", ")", ")", "\n", "", "print", "(", "\"Test completed.\"", ")", "\n", "# Print the iou results.", "\n", "per_class_ious", "=", "np", ".", "array", "(", "per_class_ious", ")", "\n", "print", "(", "\"per class iou mean:\"", ",", "np", ".", "mean", "(", "per_class_ious", ",", "axis", "=", "0", ")", ")", "\n", "print", "(", "\"std:\"", ",", "np", ".", "std", "(", "per_class_ious", ",", "axis", "=", "0", ")", ")", "\n", "print", "(", "\"Total ious mean:\"", ",", "per_class_ious", ".", "mean", "(", ")", ")", "\n", "print", "(", "\"Total detect time:\"", ",", "detect_time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.mask_branch.Modified3DUNet.__init__": [[12, 90], ["torch.Module.__init__", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Dropout3d", "torch.Dropout3d", "torch.Upsample", "torch.Upsample", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_conv", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "mask_branch.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "mask_branch.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "mask_branch.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "mask_branch.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.upscale_conv"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.upscale_conv"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "n_classes", ",", "stage", ",", "base_n_filter", "=", "32", ")", ":", "\n", "        ", "super", "(", "Modified3DUNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "base_n_filter", "=", "base_n_filter", "\n", "self", ".", "stage", "=", "stage", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", ")", "\n", "self", ".", "dropout3d", "=", "nn", ".", "Dropout3d", "(", "p", "=", "0.6", ")", "\n", "self", ".", "upsacle", "=", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", "\n", "\n", "# Level 1 context pathway", "\n", "self", ".", "conv3d_c1_1", "=", "nn", ".", "Conv3d", "(", "self", ".", "in_channels", ",", "self", ".", "base_n_filter", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "conv3d_c1_2", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "lrelu_conv_c1", "=", "self", ".", "lrelu_conv", "(", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", ")", "\n", "self", ".", "inorm3d_c1", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", ")", "\n", "\n", "# Level 2 context pathway", "\n", "self", ".", "conv3d_c2", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", "*", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_conv_c2", "=", "self", ".", "norm_lrelu_conv", "(", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "2", ")", "\n", "self", ".", "inorm3d_c2", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "2", ")", "\n", "\n", "# Level 3 context pathway", "\n", "self", ".", "conv3d_c3", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "4", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_conv_c3", "=", "self", ".", "norm_lrelu_conv", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "4", ")", "\n", "self", ".", "inorm3d_c3", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "4", ")", "\n", "\n", "# Level 4 context pathway", "\n", "self", ".", "conv3d_c4", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "8", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_conv_c4", "=", "self", ".", "norm_lrelu_conv", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ")", "\n", "self", ".", "inorm3d_c4", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "8", ")", "\n", "\n", "# Level 5 context pathway, level 0 localization pathway", "\n", "self", ".", "conv3d_c5", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "16", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_conv_c5", "=", "self", ".", "norm_lrelu_conv", "(", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "16", ")", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l0", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "16", ",", "\n", "self", ".", "base_n_filter", "*", "8", ")", "\n", "\n", "self", ".", "conv3d_l0", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "inorm3d_l0", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "8", ")", "\n", "\n", "# Level 1 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l1", "=", "self", ".", "conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "16", ")", "\n", "self", ".", "conv3d_l1", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "8", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l1", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "8", ",", "\n", "self", ".", "base_n_filter", "*", "4", ")", "\n", "\n", "# Level 2 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l2", "=", "self", ".", "conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ")", "\n", "self", ".", "conv3d_l2", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "4", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l2", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "4", ",", "\n", "self", ".", "base_n_filter", "*", "2", ")", "\n", "\n", "# Level 3 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l3", "=", "self", ".", "conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "4", ")", "\n", "self", ".", "conv3d_l3", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "2", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l3", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "2", ",", "\n", "self", ".", "base_n_filter", ")", "\n", "\n", "# Level 4 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l4", "=", "self", ".", "conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "2", ")", "\n", "self", ".", "conv3d_l4", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "n_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "self", ".", "ds2_1x1_conv3d", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "n_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "ds3_1x1_conv3d", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "n_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "out_upscale_conv", "=", "self", ".", "upscale_conv", "(", "self", ".", "n_classes", ",", "self", ".", "n_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.mask_branch.Modified3DUNet.conv_norm_lrelu": [[91, 96], ["torch.Sequential", "torch.Sequential", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["None"], ["", "def", "conv_norm_lrelu", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_out", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.mask_branch.Modified3DUNet.norm_lrelu_conv": [[97, 102], ["torch.Sequential", "torch.Sequential", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv3d", "torch.Conv3d"], "methods", ["None"], ["", "def", "norm_lrelu_conv", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_in", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.mask_branch.Modified3DUNet.lrelu_conv": [[103, 107], ["torch.Sequential", "torch.Sequential", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv3d", "torch.Conv3d"], "methods", ["None"], ["", "def", "lrelu_conv", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu": [[108, 117], ["torch.Sequential", "torch.Sequential", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Upsample", "torch.Upsample", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["None"], ["", "def", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_in", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ",", "\n", "# should be feat_in*2 or feat_in", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_out", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.mask_branch.Modified3DUNet.upscale_conv": [[118, 123], ["torch.Sequential", "torch.Sequential", "torch.Upsample", "torch.Upsample", "torch.Conv3d", "torch.Conv3d"], "methods", ["None"], ["", "def", "upscale_conv", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ",", "\n", "# should be feat_in*2 or feat_in", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.mask_branch.Modified3DUNet.forward": [[124, 221], ["mask_branch.Modified3DUNet.conv3d_c1_1", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c1_2", "mask_branch.Modified3DUNet.dropout3d", "mask_branch.Modified3DUNet.lrelu_conv_c1", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.inorm3d_c1", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c2", "mask_branch.Modified3DUNet.norm_lrelu_conv_c2", "mask_branch.Modified3DUNet.dropout3d", "mask_branch.Modified3DUNet.norm_lrelu_conv_c2", "mask_branch.Modified3DUNet.inorm3d_c2", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c3", "mask_branch.Modified3DUNet.norm_lrelu_conv_c3", "mask_branch.Modified3DUNet.dropout3d", "mask_branch.Modified3DUNet.norm_lrelu_conv_c3", "mask_branch.Modified3DUNet.inorm3d_c3", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c4", "mask_branch.Modified3DUNet.norm_lrelu_conv_c4", "mask_branch.Modified3DUNet.dropout3d", "mask_branch.Modified3DUNet.norm_lrelu_conv_c4", "mask_branch.Modified3DUNet.inorm3d_c4", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c5", "mask_branch.Modified3DUNet.norm_lrelu_conv_c5", "mask_branch.Modified3DUNet.dropout3d", "mask_branch.Modified3DUNet.norm_lrelu_conv_c5", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l0", "mask_branch.Modified3DUNet.conv3d_l0", "mask_branch.Modified3DUNet.inorm3d_l0", "mask_branch.Modified3DUNet.lrelu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_branch.Modified3DUNet.conv_norm_lrelu_l1", "mask_branch.Modified3DUNet.conv3d_l1", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_branch.Modified3DUNet.conv_norm_lrelu_l2", "mask_branch.Modified3DUNet.conv3d_l2", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_branch.Modified3DUNet.conv_norm_lrelu_l3", "mask_branch.Modified3DUNet.conv3d_l3", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l3", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_branch.Modified3DUNet.conv_norm_lrelu_l4", "mask_branch.Modified3DUNet.conv3d_l4", "mask_branch.Modified3DUNet.ds2_1x1_conv3d", "mask_branch.Modified3DUNet.upsacle", "mask_branch.Modified3DUNet.ds3_1x1_conv3d", "mask_branch.Modified3DUNet.upsacle", "mask_branch.Modified3DUNet.out_upscale_conv", "mask_branch.Modified3DUNet.upsacle"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "#  Level 1 context pathway", "\n", "        ", "out", "=", "self", ".", "conv3d_c1_1", "(", "x", ")", "\n", "residual_1", "=", "out", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "out", "=", "self", ".", "conv3d_c1_2", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu_conv_c1", "(", "out", ")", "\n", "# Element Wise Summation", "\n", "out", "+=", "residual_1", "\n", "context_1", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "out", "=", "self", ".", "inorm3d_c1", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "\n", "# Level 2 context pathway", "\n", "out", "=", "self", ".", "conv3d_c2", "(", "out", ")", "\n", "residual_2", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c2", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c2", "(", "out", ")", "\n", "out", "+=", "residual_2", "\n", "out", "=", "self", ".", "inorm3d_c2", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "context_2", "=", "out", "\n", "\n", "# Level 3 context pathway", "\n", "out", "=", "self", ".", "conv3d_c3", "(", "out", ")", "\n", "residual_3", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c3", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c3", "(", "out", ")", "\n", "out", "+=", "residual_3", "\n", "out", "=", "self", ".", "inorm3d_c3", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "context_3", "=", "out", "\n", "\n", "# Level 4 context pathway", "\n", "out", "=", "self", ".", "conv3d_c4", "(", "out", ")", "\n", "residual_4", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c4", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c4", "(", "out", ")", "\n", "out", "+=", "residual_4", "\n", "out", "=", "self", ".", "inorm3d_c4", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "context_4", "=", "out", "\n", "\n", "# Level 5", "\n", "out", "=", "self", ".", "conv3d_c5", "(", "out", ")", "\n", "residual_5", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c5", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c5", "(", "out", ")", "\n", "out", "+=", "residual_5", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l0", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3d_l0", "(", "out", ")", "\n", "out", "=", "self", ".", "inorm3d_l0", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "\n", "# Level 1 localization pathway", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_4", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv3d_l1", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l1", "(", "out", ")", "\n", "\n", "# Level 2 localization pathway", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_3", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l2", "(", "out", ")", "\n", "ds2", "=", "out", "\n", "out", "=", "self", ".", "conv3d_l2", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l2", "(", "out", ")", "\n", "\n", "# Level 3 localization pathway", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_2", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l3", "(", "out", ")", "\n", "ds3", "=", "out", "\n", "out", "=", "self", ".", "conv3d_l3", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l3", "(", "out", ")", "\n", "\n", "# Level 4 localization pathway", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_1", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l4", "(", "out", ")", "\n", "out_pred", "=", "self", ".", "conv3d_l4", "(", "out", ")", "\n", "\n", "ds2_1x1_conv", "=", "self", ".", "ds2_1x1_conv3d", "(", "ds2", ")", "\n", "ds1_ds2_sum_upscale", "=", "self", ".", "upsacle", "(", "ds2_1x1_conv", ")", "\n", "ds3_1x1_conv", "=", "self", ".", "ds3_1x1_conv3d", "(", "ds3", ")", "\n", "ds1_ds2_sum_upscale_ds3_sum", "=", "ds1_ds2_sum_upscale", "+", "ds3_1x1_conv", "\n", "ds1_ds2_sum_upscale_ds3_sum_upscale", "=", "self", ".", "upsacle", "(", "ds1_ds2_sum_upscale_ds3_sum", ")", "\n", "\n", "out", "=", "out_pred", "+", "ds1_ds2_sum_upscale_ds3_sum_upscale", "\n", "if", "self", ".", "stage", "==", "'finetune'", ":", "\n", "            ", "out_upscale", "=", "self", ".", "out_upscale_conv", "(", "out", ")", "\n", "out", "=", "self", ".", "upsacle", "(", "out", ")", "+", "out_upscale", "\n", "", "seg_layer", "=", "out", "\n", "return", "seg_layer", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.TopDownLayer.__init__": [[113, 117], ["torch.Module.__init__", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", "TopDownLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv3d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv3d", "(", "out_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.TopDownLayer.forward": [[118, 122], ["torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "model.TopDownLayer.conv1", "model.TopDownLayer.conv2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "y", "=", "F", ".", "interpolate", "(", "y", ",", "scale_factor", "=", "2", ")", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "return", "self", ".", "conv2", "(", "x", "+", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.FPN.__init__": [[125, 135], ["torch.Module.__init__", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["    ", "def", "__init__", "(", "self", ",", "C1", ",", "C2", ",", "C3", ",", "out_channels", ",", "config", ")", ":", "\n", "        ", "super", "(", "FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "C1", "=", "C1", "\n", "self", ".", "C2", "=", "C2", "\n", "self", ".", "C3", "=", "C3", "\n", "self", ".", "P3_conv1", "=", "nn", ".", "Conv3d", "(", "config", ".", "BACKBONE_CHANNELS", "[", "1", "]", "*", "4", ",", "self", ".", "out_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "P3_conv2", "=", "nn", ".", "Conv3d", "(", "self", ".", "out_channels", ",", "self", ".", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "P2_conv1", "=", "nn", ".", "Conv3d", "(", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", "*", "4", ",", "self", ".", "out_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "P2_conv2", "=", "nn", ".", "Conv3d", "(", "self", ".", "out_channels", ",", "self", ".", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.FPN.forward": [[136, 149], ["model.FPN.C1", "model.FPN.C2", "model.FPN.C3", "model.FPN.P3_conv1", "model.FPN.P3_conv2", "model.FPN.P2_conv2", "model.FPN.P2_conv1", "torch.upsample", "torch.upsample", "torch.upsample", "torch.upsample", "torch.upsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "C1", "(", "x", ")", "\n", "x", "=", "self", ".", "C2", "(", "x", ")", "\n", "c2_out", "=", "x", "\n", "x", "=", "self", ".", "C3", "(", "x", ")", "\n", "c3_out", "=", "x", "\n", "\n", "p3_out", "=", "self", ".", "P3_conv1", "(", "c3_out", ")", "\n", "p2_out", "=", "self", ".", "P2_conv1", "(", "c2_out", ")", "+", "F", ".", "upsample", "(", "p3_out", ",", "scale_factor", "=", "2", ")", "\n", "p3_out", "=", "self", ".", "P3_conv2", "(", "p3_out", ")", "\n", "p2_out", "=", "self", ".", "P2_conv2", "(", "p2_out", ")", "\n", "\n", "return", "[", "p2_out", ",", "p3_out", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.RPN.__init__": [[711, 718], ["torch.Module.__init__", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["def", "__init__", "(", "self", ",", "anchors_per_location", ",", "anchor_stride", ",", "channel", ",", "conv_channel", ")", ":", "\n", "        ", "super", "(", "RPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv_shared", "=", "nn", ".", "Conv3d", "(", "channel", ",", "conv_channel", ",", "kernel_size", "=", "3", ",", "stride", "=", "anchor_stride", ",", "padding", "=", "1", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv_class", "=", "nn", ".", "Conv3d", "(", "conv_channel", ",", "2", "*", "anchors_per_location", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "2", ")", "\n", "self", ".", "conv_bbox", "=", "nn", ".", "Conv3d", "(", "conv_channel", ",", "6", "*", "anchors_per_location", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.RPN.forward": [[719, 744], ["model.RPN.relu", "model.RPN.conv_class", "rpn_class_logits.view.view.permute", "rpn_class_logits.view.view.contiguous", "rpn_class_logits.view.view.view", "model.RPN.softmax", "model.RPN.conv_bbox", "rpn_bbox.view.view.permute", "rpn_bbox.view.view.contiguous", "rpn_bbox.view.view.view", "model.RPN.conv_shared", "model.RPN.size", "model.RPN.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# Shared convolutional base of the RPN", "\n", "        ", "x", "=", "self", ".", "relu", "(", "self", ".", "conv_shared", "(", "x", ")", ")", "\n", "\n", "# Anchor Score. [batch, anchors per location * 2, depth, height, width].", "\n", "rpn_class_logits", "=", "self", ".", "conv_class", "(", "x", ")", "\n", "\n", "# Reshape to [batch, anchors, 2]", "\n", "rpn_class_logits", "=", "rpn_class_logits", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", "\n", "rpn_class_logits", "=", "rpn_class_logits", ".", "contiguous", "(", ")", "\n", "rpn_class_logits", "=", "rpn_class_logits", ".", "view", "(", "x", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ",", "2", ")", "\n", "\n", "# Softmax on last dimension of BG/FG.", "\n", "rpn_probs", "=", "self", ".", "softmax", "(", "rpn_class_logits", ")", "\n", "\n", "# Bounding box refinement. [batch, anchors per location * 6, D, H, W]", "\n", "# where 6 == delta [z, y, x, log(d), log(h), log(w)]", "\n", "rpn_bbox", "=", "self", ".", "conv_bbox", "(", "x", ")", "\n", "\n", "# Reshape to [batch, anchors, 6]", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "contiguous", "(", ")", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "view", "(", "x", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ",", "6", ")", "\n", "\n", "return", "[", "rpn_class_logits", ",", "rpn_probs", ",", "rpn_bbox", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.Classifier.__init__": [[751, 767], ["torch.Module.__init__", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channel", ",", "pool_size", ",", "image_shape", ",", "num_classes", ",", "fc_size", ",", "test_flag", "=", "False", ")", ":", "\n", "        ", "super", "(", "Classifier", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pool_size", "=", "pool_size", "\n", "self", ".", "image_shape", "=", "image_shape", "\n", "self", ".", "fc_size", "=", "fc_size", "\n", "self", ".", "test_flag", "=", "test_flag", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv3d", "(", "channel", ",", "fc_size", ",", "kernel_size", "=", "self", ".", "pool_size", ",", "stride", "=", "1", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm3d", "(", "fc_size", ",", "eps", "=", "0.001", ",", "momentum", "=", "0.01", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv3d", "(", "fc_size", ",", "fc_size", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm3d", "(", "fc_size", ",", "eps", "=", "0.001", ",", "momentum", "=", "0.01", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "self", ".", "linear_class", "=", "nn", ".", "Linear", "(", "fc_size", ",", "num_classes", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "self", ".", "linear_bbox", "=", "nn", ".", "Linear", "(", "fc_size", ",", "num_classes", "*", "6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.Classifier.forward": [[768, 785], ["model.pyramid_roi_align", "model.Classifier.conv1", "model.Classifier.bn1", "model.Classifier.relu", "model.Classifier.conv2", "model.Classifier.bn2", "model.Classifier.relu", "x.view.view.view", "model.Classifier.linear_class", "model.Classifier.softmax", "model.Classifier.linear_bbox", "mrcnn_bbox.view.view.view", "mrcnn_bbox.view.view.size"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.pyramid_roi_align"], ["", "def", "forward", "(", "self", ",", "x", ",", "rois", ")", ":", "\n", "        ", "x", "=", "pyramid_roi_align", "(", "[", "rois", "]", "+", "x", ",", "self", ".", "pool_size", ",", "self", ".", "test_flag", ")", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "self", ".", "fc_size", ")", "\n", "mrcnn_class_logits", "=", "self", ".", "linear_class", "(", "x", ")", "\n", "mrcnn_probs", "=", "self", ".", "softmax", "(", "mrcnn_class_logits", ")", "\n", "\n", "mrcnn_bbox", "=", "self", ".", "linear_bbox", "(", "x", ")", "\n", "mrcnn_bbox", "=", "mrcnn_bbox", ".", "view", "(", "mrcnn_bbox", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ",", "6", ")", "\n", "\n", "return", "[", "mrcnn_class_logits", ",", "mrcnn_probs", ",", "mrcnn_bbox", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.Mask.__init__": [[788, 795], ["torch.Module.__init__", "mask_branch.Modified3DUNet", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channel", ",", "pool_size", ",", "num_classes", ",", "conv_channel", ",", "stage", ",", "test_flag", "=", "False", ")", ":", "\n", "        ", "super", "(", "Mask", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pool_size", "=", "pool_size", "\n", "self", ".", "test_flag", "=", "test_flag", "\n", "\n", "self", ".", "modified_u_net", "=", "mask_branch", ".", "Modified3DUNet", "(", "channel", ",", "num_classes", ",", "stage", ",", "conv_channel", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.Mask.forward": [[796, 802], ["model.pyramid_roi_align", "model.Mask.modified_u_net", "model.Mask.softmax"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.pyramid_roi_align"], ["", "def", "forward", "(", "self", ",", "x", ",", "rois", ")", ":", "\n", "        ", "x", "=", "pyramid_roi_align", "(", "[", "rois", "]", "+", "x", ",", "self", ".", "pool_size", ",", "self", ".", "test_flag", ")", "\n", "x", "=", "self", ".", "modified_u_net", "(", "x", ")", "\n", "output", "=", "self", ".", "softmax", "(", "x", ")", "\n", "\n", "return", "x", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.Dataset.__init__": [[1185, 1210], ["numpy.copy"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "config", ")", ":", "\n", "        ", "\"\"\"A generator that returns images and corresponding target class ids,\n            bounding box deltas, and masks.\n            dataset: The Dataset object to pick data from\n            config: The model config object\n            shuffle: If True, shuffles the samples before every epoch\n            augment: If not None, applies the given image augmentation to images\n            Returns a Python generator. Upon calling next() on it, the\n            generator returns two lists, inputs and outputs. The contents\n            of the lists differs depending on the received arguments:\n            inputs list:\n            - images: [batch, H, W, D, C]\n            - image_metas: [batch, size of image meta]\n            - mask: [batch, H, W, D]\n            outputs list: Usually empty in regular training. But if detection_targets\n                is True then the outputs list contains target class_ids, bbox deltas,\n                and masks.\n            \"\"\"", "\n", "self", ".", "b", "=", "0", "# batch item index", "\n", "self", ".", "image_index", "=", "-", "1", "\n", "self", ".", "image_ids", "=", "np", ".", "copy", "(", "dataset", ".", "image_ids", ")", "\n", "self", ".", "error_count", "=", "0", "\n", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "config", "=", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.Dataset.__getitem__": [[1211, 1236], ["model.Dataset.dataset.load_image", "model.Dataset.dataset.load_mask", "utils.resize_image", "utils.resize_mask", "numpy.zeros", "model.compose_image_meta"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.load_image", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.load_mask", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize_image", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize_mask", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compose_image_meta"], ["", "def", "__getitem__", "(", "self", ",", "image_index", ")", ":", "\n", "        ", "image_id", "=", "self", ".", "image_ids", "[", "image_index", "]", "\n", "# Load image, which is [H, W, D, C] first.", "\n", "image", "=", "self", ".", "dataset", ".", "load_image", "(", "image_id", ")", "\n", "# Load mask, which is [H, W, D] first.", "\n", "mask", "=", "self", ".", "dataset", ".", "load_mask", "(", "image_id", ")", "\n", "# Note that window has already been (z1, y1, x1, z2, y2, x2) here.", "\n", "image", ",", "window", ",", "scale", ",", "padding", ",", "crop", "=", "utils", ".", "resize_image", "(", "\n", "image", ",", "\n", "min_dim", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", ",", "\n", "max_dim", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", ",", "\n", "min_scale", "=", "self", ".", "config", ".", "IMAGE_MIN_SCALE", ",", "\n", "mode", "=", "self", ".", "config", ".", "IMAGE_RESIZE_MODE", ")", "\n", "mask", "=", "utils", ".", "resize_mask", "(", "mask", ",", "scale", ",", "padding", ",", "max_dim", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", ",", "\n", "min_dim", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", ",", "crop", "=", "crop", ",", "mode", "=", "self", ".", "config", ".", "IMAGE_RESIZE_MODE", ")", "\n", "\n", "# Active classes", "\n", "# Different datasets have different classes, so track the classes supported in the dataset of this image.", "\n", "active_class_ids", "=", "np", ".", "zeros", "(", "[", "self", ".", "dataset", ".", "num_classes", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "source_class_ids", "=", "self", ".", "dataset", ".", "source_class_ids", "[", "self", ".", "dataset", ".", "image_info", "[", "image_id", "]", "[", "\"source\"", "]", "]", "\n", "active_class_ids", "[", "source_class_ids", "]", "=", "1", "\n", "# Image meta data", "\n", "image_meta", "=", "compose_image_meta", "(", "image_id", ",", "image", ".", "shape", ",", "window", ",", "active_class_ids", ")", "\n", "\n", "return", "image", ",", "image_meta", ",", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.Dataset.__len__": [[1237, 1239], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "image_ids", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.__init__": [[1248, 1258], ["torch.Module.__init__", "model.MaskRCNN.build", "model.MaskRCNN.initialize_weights"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.build", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.initialize_weights"], ["def", "__init__", "(", "self", ",", "config", ",", "model_dir", ",", "test_flag", "=", "False", ")", ":", "\n", "        ", "\"\"\"config: A Sub-class of the Config class\n        model_dir: Directory to save training logs and trained weights\n        \"\"\"", "\n", "super", "(", "MaskRCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "config", "=", "config", "\n", "self", ".", "model_dir", "=", "model_dir", "\n", "self", ".", "build", "(", "config", "=", "config", ",", "test_flag", "=", "test_flag", ")", "\n", "self", ".", "initialize_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.build": [[1259, 1305], ["backbone.P3D19", "backbone.P3D19.stages", "model.FPN", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "model.RPN", "model.Classifier", "model.Mask", "Exception", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.MaskRCNN.anchors.cuda", "len", "model.MaskRCNN.apply", "int", "int", "int", "classname.find", "m.parameters", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "utils.generate_pyramid_anchors", "model.compute_backbone_shapes"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D19", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.stages", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.generate_pyramid_anchors", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_backbone_shapes"], ["", "def", "build", "(", "self", ",", "config", ",", "test_flag", "=", "False", ")", ":", "\n", "        ", "\"\"\"Build 3D-Mask-RCNN architecture.\"\"\"", "\n", "\n", "# Image size must be dividable by 2 multiple times", "\n", "h", ",", "w", ",", "d", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "if", "h", "/", "16", "!=", "int", "(", "h", "/", "16", ")", "or", "w", "/", "16", "!=", "int", "(", "w", "/", "16", ")", "or", "d", "/", "16", "!=", "int", "(", "d", "/", "16", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Image size must be dividable by 16. Use 256, 320, 512, ... etc.\"", ")", "\n", "\n", "# Build the shared convolutional layers.", "\n", "# Returns a list of the last layers of each stage, 5 in total.", "\n", "", "P3D_Resnet", "=", "backbone", ".", "P3D19", "(", "config", "=", "config", ")", "\n", "C1", ",", "C2", ",", "C3", "=", "P3D_Resnet", ".", "stages", "(", ")", "\n", "\n", "# Top-down Layers", "\n", "self", ".", "fpn", "=", "FPN", "(", "C1", ",", "C2", ",", "C3", ",", "out_channels", "=", "config", ".", "TOP_DOWN_PYRAMID_SIZE", ",", "config", "=", "config", ")", "\n", "\n", "# Generate Anchors", "\n", "self", ".", "anchors", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "utils", ".", "generate_pyramid_anchors", "(", "config", ".", "RPN_ANCHOR_SCALES", ",", "\n", "config", ".", "RPN_ANCHOR_RATIOS", ",", "\n", "compute_backbone_shapes", "(", "\n", "config", ",", "config", ".", "IMAGE_SHAPE", ")", ",", "\n", "config", ".", "BACKBONE_STRIDES", ",", "\n", "config", ".", "RPN_ANCHOR_STRIDE", ")", ")", ".", "float", "(", ")", ",", "\n", "requires_grad", "=", "False", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "            ", "self", ".", "anchors", "=", "self", ".", "anchors", ".", "cuda", "(", ")", "\n", "\n", "# RPN", "\n", "", "self", ".", "rpn", "=", "RPN", "(", "len", "(", "config", ".", "RPN_ANCHOR_RATIOS", ")", ",", "config", ".", "RPN_ANCHOR_STRIDE", ",", "config", ".", "TOP_DOWN_PYRAMID_SIZE", ",", "config", ".", "RPN_CONV_CHANNELS", ")", "\n", "\n", "# FPN Classifier", "\n", "self", ".", "classifier", "=", "Classifier", "(", "config", ".", "TOP_DOWN_PYRAMID_SIZE", ",", "config", ".", "POOL_SIZE", ",", "config", ".", "IMAGE_SHAPE", ",", "\n", "2", ",", "config", ".", "FPN_CLASSIFY_FC_LAYERS_SIZE", ",", "test_flag", ")", "\n", "\n", "# FPN Mask", "\n", "self", ".", "mask", "=", "Mask", "(", "1", ",", "config", ".", "MASK_POOL_SIZE", ",", "config", ".", "NUM_CLASSES", ",", "config", ".", "UNET_MASK_BRANCH_CHANNEL", ",", "self", ".", "config", ".", "STAGE", ",", "test_flag", ")", "\n", "\n", "# Fix batch norm layers", "\n", "def", "set_bn_fix", "(", "m", ")", ":", "\n", "            ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "classname", ".", "find", "(", "'BatchNorm'", ")", "!=", "-", "1", ":", "\n", "                ", "for", "p", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                    ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "", "if", "not", "config", ".", "TRAIN_BN", ":", "\n", "            ", "self", ".", "apply", "(", "set_bn_fix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.initialize_weights": [[1306, 1320], ["model.MaskRCNN.modules", "isinstance", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "isinstance", "m.bias.data.zero_", "m.weight.data.fill_", "m.bias.data.zero_", "isinstance", "m.weight.data.normal_", "m.bias.data.zero_"], "methods", ["None"], ["", "", "def", "initialize_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize model weights.\"\"\"", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv3d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm3d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "0.01", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.set_trainable": [[1321, 1328], ["model.MaskRCNN.named_parameters", "bool", "re.fullmatch"], "methods", ["None"], ["", "", "", "def", "set_trainable", "(", "self", ",", "layer_regex", ")", ":", "\n", "        ", "\"\"\"Sets model layers as trainable if their names match the given regular expression.\"\"\"", "\n", "for", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "layer_name", "=", "param", "[", "0", "]", "\n", "trainable", "=", "bool", "(", "re", ".", "fullmatch", "(", "layer_regex", ",", "layer_name", ")", ")", "\n", "if", "not", "trainable", ":", "\n", "                ", "param", "[", "1", "]", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.load_weights": [[1329, 1340], ["os.path.exists", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "model.MaskRCNN.load_state_dict", "print", "print"], "methods", ["None"], ["", "", "", "def", "load_weights", "(", "self", ",", "file_path", ")", ":", "\n", "        ", "\"\"\"Modified version of the corresponding Keras function with the addition of multi-GPU support\n        and the ability to exclude some layers from loading.\n        exclude: list of layer names to exclude\n        \"\"\"", "\n", "if", "os", ".", "path", ".", "exists", "(", "file_path", ")", ":", "\n", "            ", "pretrained_dict", "=", "torch", ".", "load", "(", "file_path", ")", "\n", "self", ".", "load_state_dict", "(", "pretrained_dict", ",", "strict", "=", "True", ")", "\n", "print", "(", "\"Weight file loading success!\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Weight file not found ...\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.detect": [[1341, 1390], ["time.time", "model.MaskRCNN.mold_inputs", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.MaskRCNN.predict", "detections.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "mrcnn_mask.permute().detach().cpu().numpy.permute().detach().cpu().numpy.permute().detach().cpu().numpy", "print", "enumerate", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "model.MaskRCNN.unmold_detections", "results.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "detections.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "mrcnn_mask.permute().detach().cpu().numpy.permute().detach().cpu().numpy.permute().detach().cpu", "time.time", "detections.detach().cpu().numpy.detach().cpu().numpy.detach", "mrcnn_mask.permute().detach().cpu().numpy.permute().detach().cpu().numpy.permute().detach", "mrcnn_mask.permute().detach().cpu().numpy.permute().detach().cpu().numpy.permute"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.mold_inputs", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.predict", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.unmold_detections"], ["", "", "def", "detect", "(", "self", ",", "images", ")", ":", "\n", "        ", "\"\"\"Runs the detection pipeline.\n        images: List of images, potentially of different sizes. [1, height, width, depth, channels]\n        Returns a list of dicts, one dict per image. The dict contains:\n        rois: [N, (y1, x1, z1, y2, x2, z2)] detection bounding boxes\n        class_ids: [N] int class IDs\n        scores: [N] float probability scores for the class IDs\n        masks: [H, W, D, N] instance binary masks\n        Transform all outputs from pytorch shape to normal shape here.\n        \"\"\"", "\n", "\n", "# Mold inputs to format expected by the neural network", "\n", "# Has been transformed to pytorch shapes.", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "molded_images", ",", "image_metas", ",", "windows", "=", "self", ".", "mold_inputs", "(", "images", ")", "\n", "\n", "# Convert images to torch tensor", "\n", "molded_images", "=", "torch", ".", "from_numpy", "(", "molded_images", ")", ".", "float", "(", ")", "\n", "\n", "# To GPU", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "            ", "molded_images", "=", "molded_images", ".", "cuda", "(", ")", "\n", "\n", "# Wrap in variable", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "molded_images", "=", "Variable", "(", "molded_images", ")", "\n", "\n", "# Run object detection", "\n", "", "detections", ",", "mrcnn_mask", "=", "self", ".", "predict", "(", "[", "molded_images", ",", "image_metas", "]", ",", "mode", "=", "'inference'", ")", "\n", "# Convert to numpy", "\n", "detections", "=", "detections", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mrcnn_mask", "=", "mrcnn_mask", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "4", ",", "5", ",", "2", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "print", "(", "\"detect done, using time\"", ",", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "\n", "# Process detections", "\n", "results", "=", "[", "]", "\n", "for", "i", ",", "image", "in", "enumerate", "(", "images", ")", ":", "\n", "            ", "final_rois", ",", "final_class_ids", ",", "final_scores", ",", "final_mask", "=", "self", ".", "unmold_detections", "(", "detections", "[", "i", "]", ",", "mrcnn_mask", "[", "i", "]", ",", "\n", "[", "image", ".", "shape", "[", "3", "]", ",", "image", ".", "shape", "[", "2", "]", ",", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "1", "]", "]", ",", "\n", "windows", "[", "i", "]", ")", "\n", "results", ".", "append", "(", "{", "\n", "\"rois\"", ":", "final_rois", ",", "\n", "\"class_ids\"", ":", "final_class_ids", ",", "\n", "\"scores\"", ":", "final_scores", ",", "\n", "\"mask\"", ":", "final_mask", ",", "\n", "}", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.predict": [[1391, 1515], ["model.MaskRCNN.fpn", "list", "model.proposal_layer", "model.MaskRCNN.eval", "layer_outputs.append", "zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.MaskRCNN.classifier", "model.detection_layer", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "detection_boxes.unsqueeze.unsqueeze.unsqueeze", "model.MaskRCNN.mask", "detections.unsqueeze.unsqueeze.unsqueeze", "mrcnn_mask.cuda.cuda.unsqueeze", "model.MaskRCNN.train", "model.MaskRCNN.apply", "model.MaskRCNN.rpn", "list", "scale.cuda.cuda.cuda", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.detection_target_layer", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "scale.cuda.cuda.cuda", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "classname.find", "m.eval", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "rois.size", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "mrcnn_class_logits.cuda.cuda.cuda", "mrcnn_class.cuda.cuda.cuda", "mrcnn_bbox.cuda.cuda.cuda", "mrcnn_mask.cuda.cuda.cuda", "mrcnn_mask_logits.cuda.cuda.cuda", "model.MaskRCNN.classifier", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "model.MaskRCNN.classifier", "model.MaskRCNN.mask", "numpy.array", "p_rois.size", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "mrcnn_mask.cuda.cuda.cuda", "mrcnn_mask_logits.cuda.cuda.cuda"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.proposal_layer", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.detection_layer", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.train", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.detection_target_layer"], ["", "def", "predict", "(", "self", ",", "inputs", ",", "mode", ")", ":", "\n", "        ", "molded_images", "=", "inputs", "[", "0", "]", "\n", "image_metas", "=", "inputs", "[", "1", "]", "\n", "\n", "if", "mode", "==", "'inference'", ":", "\n", "            ", "self", ".", "eval", "(", ")", "\n", "", "elif", "mode", "==", "'training'", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "\n", "# Set batchnorm always in eval mode during training", "\n", "def", "set_bn_eval", "(", "m", ")", ":", "\n", "                ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "classname", ".", "find", "(", "'BatchNorm'", ")", "!=", "-", "1", ":", "\n", "                    ", "m", ".", "eval", "(", ")", "\n", "\n", "", "", "self", ".", "apply", "(", "set_bn_eval", ")", "\n", "\n", "# Feature extraction", "\n", "", "p2_out", ",", "p3_out", "=", "self", ".", "fpn", "(", "molded_images", ")", "\n", "\n", "rpn_feature_maps", "=", "[", "p2_out", ",", "p3_out", "]", "\n", "mrcnn_classifier_feature_maps", "=", "[", "p2_out", ",", "p3_out", "]", "\n", "mrcnn_mask_feature_maps", "=", "[", "molded_images", ",", "molded_images", "]", "\n", "\n", "# Loop through pyramid layers", "\n", "layer_outputs", "=", "[", "]", "# list of lists", "\n", "for", "p", "in", "rpn_feature_maps", ":", "\n", "            ", "layer_outputs", ".", "append", "(", "self", ".", "rpn", "(", "p", ")", ")", "\n", "\n", "# Concatenate layer outputs", "\n", "# Convert from list of lists of level outputs to list of lists", "\n", "# of outputs across levels.", "\n", "# e.g. [[a1, b1, c1], [a2, b2, c2]] => [[a1, a2], [b1, b2], [c1, c2]]", "\n", "", "outputs", "=", "list", "(", "zip", "(", "*", "layer_outputs", ")", ")", "\n", "outputs", "=", "[", "torch", ".", "cat", "(", "list", "(", "o", ")", ",", "dim", "=", "1", ")", "for", "o", "in", "outputs", "]", "\n", "rpn_class_logits", ",", "rpn_class", ",", "rpn_bbox", "=", "outputs", "\n", "\n", "# Generate proposals", "\n", "# Proposals are [batch, N, (z1, y1, x1, z2, y2, x2)] in normalized coordinates", "\n", "# and zero padded.", "\n", "proposal_count", "=", "self", ".", "config", ".", "POST_NMS_ROIS_TRAINING", "if", "mode", "==", "\"training\"", "else", "self", ".", "config", ".", "POST_NMS_ROIS_INFERENCE", "\n", "rpn_rois", "=", "proposal_layer", "(", "[", "rpn_class", ",", "rpn_bbox", "]", ",", "\n", "proposal_count", "=", "proposal_count", ",", "\n", "nms_threshold", "=", "self", ".", "config", ".", "RPN_NMS_THRESHOLD", ",", "\n", "anchors", "=", "self", ".", "anchors", ",", "\n", "config", "=", "self", ".", "config", ")", "\n", "if", "mode", "==", "'inference'", ":", "\n", "# Network Heads", "\n", "# Proposal classifier and BBox regressor heads", "\n", "            ", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", "=", "self", ".", "classifier", "(", "mrcnn_classifier_feature_maps", ",", "rpn_rois", ")", "\n", "\n", "# Detections", "\n", "# output is [batch, num_detections, (z1, y1, x1, z2, y2, x2, class_id, score)] in image coordinates", "\n", "detections", "=", "detection_layer", "(", "self", ".", "config", ",", "rpn_rois", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "image_metas", ")", "\n", "\n", "# Convert boxes to normalized coordinates", "\n", "h", ",", "w", ",", "d", "=", "self", ".", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "scale", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "d", ",", "h", ",", "w", ",", "d", ",", "h", ",", "w", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                ", "scale", "=", "scale", ".", "cuda", "(", ")", "\n", "", "detection_boxes", "=", "detections", "[", ":", ",", ":", "6", "]", "/", "scale", "\n", "\n", "# Add back batch dimension", "\n", "detection_boxes", "=", "detection_boxes", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# Create masks for detections", "\n", "_", ",", "mrcnn_mask", "=", "self", ".", "mask", "(", "mrcnn_mask_feature_maps", ",", "detection_boxes", ")", "\n", "\n", "# Add back batch dimension", "\n", "detections", "=", "detections", ".", "unsqueeze", "(", "0", ")", "\n", "mrcnn_mask", "=", "mrcnn_mask", ".", "unsqueeze", "(", "0", ")", "\n", "return", "[", "detections", ",", "mrcnn_mask", "]", "\n", "\n", "", "elif", "mode", "==", "'training'", ":", "\n", "            ", "gt_class_ids", "=", "inputs", "[", "2", "]", "# [1, 2, ..., num_classes - 1]", "\n", "gt_boxes", "=", "inputs", "[", "3", "]", "# [(num_classes - 1) * one_class_bbox]", "\n", "gt_masks", "=", "inputs", "[", "4", "]", "# multi_classes masks [D, H, W, num_classes - 1]", "\n", "\n", "# Normalize coordinates", "\n", "h", ",", "w", ",", "d", "=", "self", ".", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "scale", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "d", ",", "h", ",", "w", ",", "d", ",", "h", ",", "w", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                ", "scale", "=", "scale", ".", "cuda", "(", ")", "\n", "", "gt_boxes", "=", "gt_boxes", "/", "scale", "\n", "\n", "# Generate detection targets", "\n", "# Subsamples proposals and generates target outputs for training", "\n", "p_rois", ",", "rois", ",", "target_class_ids", ",", "target_deltas", ",", "target_mask", "=", "detection_target_layer", "(", "rpn_rois", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", ",", "self", ".", "config", ")", "\n", "\n", "if", "rois", ".", "size", "(", ")", "[", "0", "]", "==", "0", ":", "\n", "                ", "mrcnn_class_logits", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "mrcnn_class", "=", "Variable", "(", "torch", ".", "IntTensor", "(", ")", ")", "\n", "mrcnn_bbox", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "mrcnn_mask", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "mrcnn_mask_logits", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                    ", "mrcnn_class_logits", "=", "mrcnn_class_logits", ".", "cuda", "(", ")", "\n", "mrcnn_class", "=", "mrcnn_class", ".", "cuda", "(", ")", "\n", "mrcnn_bbox", "=", "mrcnn_bbox", ".", "cuda", "(", ")", "\n", "mrcnn_mask", "=", "mrcnn_mask", ".", "cuda", "(", ")", "\n", "mrcnn_mask_logits", "=", "mrcnn_mask_logits", ".", "cuda", "(", ")", "\n", "", "", "elif", "p_rois", ".", "size", "(", ")", "[", "0", "]", "==", "0", ":", "\n", "# Network Heads", "\n", "# Proposal classifier and BBox regressor heads", "\n", "                ", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", "=", "self", ".", "classifier", "(", "mrcnn_classifier_feature_maps", ",", "rois", ")", "\n", "mrcnn_mask", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "mrcnn_mask_logits", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                    ", "mrcnn_mask", "=", "mrcnn_mask", ".", "cuda", "(", ")", "\n", "mrcnn_mask_logits", "=", "mrcnn_mask_logits", ".", "cuda", "(", ")", "\n", "\n", "", "", "else", ":", "\n", "# Network Heads", "\n", "# Proposal classifier and BBox regressor heads", "\n", "                ", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", "=", "self", ".", "classifier", "(", "mrcnn_classifier_feature_maps", ",", "rois", ")", "\n", "\n", "# Create masks for detections", "\n", "mrcnn_mask_logits", ",", "mrcnn_mask", "=", "self", ".", "mask", "(", "mrcnn_mask_feature_maps", ",", "p_rois", ")", "\n", "\n", "", "return", "[", "rpn_class_logits", ",", "rpn_bbox", ",", "\n", "target_class_ids", ",", "mrcnn_class_logits", ",", "\n", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.train_model": [[1516, 1573], ["model.Dataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "model.Dataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "model.MaskRCNN.set_trainable", "torch.SGD", "torch.SGD", "torch.SGD", "torch.SGD", "torch.SGD", "time.time", "time.strftime", "range", "time.localtime", "os.path.exists", "os.makedirs", "model.log", "time.time", "numpy.random.randint", "model.MaskRCNN.train_epoch", "print", "model.MaskRCNN.named_parameters", "model.MaskRCNN.named_parameters", "int", "int", "model.MaskRCNN.valid_epoch", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "str", "str", "model.MaskRCNN.state_dict", "time.time", "time.time", "str", "round", "str", "round", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.set_trainable", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.train_epoch", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.valid_epoch"], ["", "", "def", "train_model", "(", "self", ",", "train_dataset", ",", "val_dataset", ",", "learning_rate", ",", "epochs", ")", ":", "\n", "        ", "\"\"\"Train the model.\n        train_dataset, val_dataset: Training and validation Dataset objects.\n        learning_rate: The learning rate to train with\n        epochs: Number of training epochs. Note that previous training epochs\n                are considered to be done already, so this actually determines\n                the epochs to train in total rather than in this particular call.\n        \"\"\"", "\n", "layers", "=", "\".*\"", "# set all the layers trainable", "\n", "\n", "# Data generators", "\n", "train_set", "=", "Dataset", "(", "train_dataset", ",", "self", ".", "config", ")", "\n", "train_generator", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "train_set", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "23", ")", "\n", "val_set", "=", "Dataset", "(", "val_dataset", ",", "self", ".", "config", ")", "\n", "val_generator", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "val_set", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "10", ")", "\n", "\n", "# Train", "\n", "self", ".", "set_trainable", "(", "layers", ")", "\n", "\n", "# Optimizer object", "\n", "# Add L2 Regularization", "\n", "# Skip gamma and beta weights of batch normalization layers.", "\n", "trainables_wo_bn", "=", "[", "param", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", "\n", "if", "param", ".", "requires_grad", "and", "'bn'", "not", "in", "name", "]", "\n", "trainables_only_bn", "=", "[", "param", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", "\n", "if", "param", ".", "requires_grad", "and", "'bn'", "in", "name", "]", "\n", "optimizer", "=", "optim", ".", "SGD", "(", "[", "\n", "{", "'params'", ":", "trainables_wo_bn", ",", "'weight_decay'", ":", "self", ".", "config", ".", "WEIGHT_DECAY", "}", ",", "\n", "{", "'params'", ":", "trainables_only_bn", "}", "\n", "]", ",", "lr", "=", "learning_rate", ",", "momentum", "=", "self", ".", "config", ".", "LEARNING_MOMENTUM", ")", "\n", "\n", "total_start_time", "=", "time", ".", "time", "(", ")", "\n", "start_datetime", "=", "time", ".", "strftime", "(", "\"%Y-%m-%d %H:%M:%S\"", ",", "time", ".", "localtime", "(", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "\"./logs/heart/\"", "+", "str", "(", "start_datetime", ")", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "\"./logs/heart/\"", "+", "str", "(", "start_datetime", ")", ")", "\n", "", "for", "epoch", "in", "range", "(", "self", ".", "epoch", "+", "1", ",", "epochs", "+", "1", ")", ":", "\n", "            ", "log", "(", "\"Epoch {}/{}.\"", ".", "format", "(", "epoch", ",", "epochs", ")", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "# Training", "\n", "angle", "=", "np", ".", "random", ".", "randint", "(", "-", "20", ",", "21", ")", "\n", "loss", ",", "loss_rpn_class", ",", "loss_rpn_bbox", ",", "loss_mrcnn_class", ",", "loss_mrcnn_bbox", ",", "loss_mrcnn_mask", ",", "loss_mrcnn_mask_edge", "=", "self", ".", "train_epoch", "(", "train_generator", ",", "optimizer", ",", "self", ".", "config", ".", "STEPS_PER_EPOCH", ",", "angle", ",", "train_dataset", ")", "\n", "\n", "print", "(", "\"One Training Epoch time:\"", ",", "int", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ",", "\n", "\"Total time:\"", ",", "int", "(", "time", ".", "time", "(", ")", "-", "total_start_time", ")", ")", "\n", "\n", "if", "epoch", "%", "5", "==", "0", ":", "\n", "# Validation", "\n", "                ", "val_loss", ",", "val_loss_rpn_class", ",", "val_loss_rpn_bbox", ",", "val_loss_mrcnn_class", ",", "val_loss_mrcnn_bbox", ",", "val_loss_mrcnn_mask", ",", "val_loss_mrcnn_mask_edge", "=", "self", ".", "valid_epoch", "(", "val_generator", ",", "self", ".", "config", ".", "VALIDATION_STEPS", ",", "angle", ",", "val_dataset", ")", "\n", "\n", "torch", ".", "save", "(", "self", ".", "state_dict", "(", ")", ",", "\"./logs/heart/\"", "+", "str", "(", "start_datetime", ")", "+", "\"/model\"", "+", "str", "(", "epoch", ")", "+", "\n", "\"_loss: \"", "+", "str", "(", "round", "(", "loss", ",", "4", ")", ")", "+", "\"_val: \"", "+", "str", "(", "round", "(", "val_loss", ",", "4", ")", ")", ")", "\n", "\n", "", "", "self", ".", "epoch", "=", "epochs", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.train_epoch": [[1574, 1677], ["optimizer.zero_grad", "image.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze().cpu().numpy", "mask.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze().cpu().numpy", "model.load_image_gt", "image_metas.numpy.numpy.numpy", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "model.MaskRCNN.predict", "model.compute_losses", "loss.backward", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "model.print_progress_bar", "model.MaskRCNN.anchors.cpu().numpy", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "images.cuda.cuda.cuda", "rpn_match.cuda.cuda.cuda", "rpn_bbox.cuda.cuda.cuda", "gt_class_ids.cuda.cuda.cuda", "gt_boxes.cuda.cuda.cuda", "gt_masks.cuda.cuda.cuda", "model.MaskRCNN.parameters", "optimizer.step", "optimizer.zero_grad", "loss.detach().cpu().item", "rpn_class_loss.detach().cpu().item", "rpn_bbox_loss.detach().cpu().item", "mrcnn_class_loss.detach().cpu().item", "mrcnn_bbox_loss.detach().cpu().item", "mrcnn_mask_loss.detach().cpu().item", "mrcnn_mask_edge_loss.detach().cpu().item", "image.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze().cpu", "mask.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze().cpu", "model.MaskRCNN.anchors.cpu", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "loss.detach().cpu().item", "loss.detach().cpu", "rpn_class_loss.detach().cpu", "rpn_bbox_loss.detach().cpu", "mrcnn_class_loss.detach().cpu", "mrcnn_bbox_loss.detach().cpu", "mrcnn_mask_loss.detach().cpu", "mrcnn_mask_edge_loss.detach().cpu", "image.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze", "mask.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze", "rpn_class_loss.detach().cpu().item", "rpn_bbox_loss.detach().cpu().item", "mrcnn_class_loss.detach().cpu().item", "mrcnn_bbox_loss.detach().cpu().item", "mrcnn_mask_loss.detach().cpu().item", "mrcnn_mask_edge_loss.detach().cpu().item", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "loss.detach().cpu", "loss.detach", "rpn_class_loss.detach", "rpn_bbox_loss.detach", "mrcnn_class_loss.detach", "mrcnn_bbox_loss.detach", "mrcnn_mask_loss.detach", "mrcnn_mask_edge_loss.detach", "rpn_class_loss.detach().cpu", "rpn_bbox_loss.detach().cpu", "mrcnn_class_loss.detach().cpu", "mrcnn_bbox_loss.detach().cpu", "mrcnn_mask_loss.detach().cpu", "mrcnn_mask_edge_loss.detach().cpu", "loss.detach", "rpn_class_loss.detach", "rpn_bbox_loss.detach", "mrcnn_class_loss.detach", "mrcnn_bbox_loss.detach", "mrcnn_mask_loss.detach", "mrcnn_mask_edge_loss.detach"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.load_image_gt", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.predict", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_losses", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.print_progress_bar"], ["", "def", "train_epoch", "(", "self", ",", "datagenerator", ",", "optimizer", ",", "steps", ",", "angle", ",", "dataset", ")", ":", "\n", "        ", "batch_count", "=", "0", "\n", "loss_sum", "=", "0", "\n", "loss_rpn_class_sum", "=", "0", "\n", "loss_rpn_bbox_sum", "=", "0", "\n", "loss_mrcnn_class_sum", "=", "0", "\n", "loss_mrcnn_bbox_sum", "=", "0", "\n", "loss_mrcnn_mask_sum", "=", "0", "\n", "loss_mrcnn_mask_edge_sum", "=", "0", "\n", "step", "=", "0", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "for", "inputs", "in", "datagenerator", ":", "\n", "            ", "batch_count", "+=", "1", "\n", "\n", "image", "=", "inputs", "[", "0", "]", "\n", "image_metas", "=", "inputs", "[", "1", "]", "\n", "mask", "=", "inputs", "[", "2", "]", "\n", "\n", "image", "=", "image", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mask", "=", "mask", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "images", ",", "rpn_match", ",", "rpn_bbox", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", "=", "load_image_gt", "(", "image", ",", "mask", ",", "angle", ",", "dataset", ",", "\n", "self", ".", "config", ",", "\n", "self", ".", "anchors", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "# image_metas as numpy array", "\n", "image_metas", "=", "image_metas", ".", "numpy", "(", ")", "\n", "\n", "# Wrap in variables", "\n", "images", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "images", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "rpn_match", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "rpn_match", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "rpn_bbox", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "rpn_bbox", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_class_ids", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_class_ids", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_boxes", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_boxes", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_masks", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_masks", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "# To GPU", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                ", "images", "=", "images", ".", "cuda", "(", ")", "\n", "rpn_match", "=", "rpn_match", ".", "cuda", "(", ")", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "cuda", "(", ")", "\n", "gt_class_ids", "=", "gt_class_ids", ".", "cuda", "(", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "cuda", "(", ")", "\n", "gt_masks", "=", "gt_masks", ".", "cuda", "(", ")", "\n", "\n", "# Run object detection", "\n", "", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "mrcnn_class_logits", ",", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", "=", "self", ".", "predict", "(", "[", "images", ",", "image_metas", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", "]", ",", "mode", "=", "'training'", ")", "\n", "\n", "# Compute losses", "\n", "rpn_class_loss", ",", "rpn_bbox_loss", ",", "mrcnn_class_loss", ",", "mrcnn_bbox_loss", ",", "mrcnn_mask_loss", ",", "mrcnn_mask_edge_loss", "=", "compute_losses", "(", "rpn_match", ",", "rpn_bbox", ",", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "\n", "mrcnn_class_logits", ",", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", ",", "self", ".", "config", ".", "STAGE", ")", "\n", "\n", "loss", "=", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_class_loss\"", "]", "*", "rpn_class_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_bbox_loss\"", "]", "*", "rpn_bbox_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_class_loss\"", "]", "*", "mrcnn_class_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_bbox_loss\"", "]", "*", "mrcnn_bbox_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_loss\"", "]", "*", "mrcnn_mask_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_edge_loss\"", "]", "*", "mrcnn_mask_edge_loss", "\n", "\n", "# Back propagation", "\n", "loss", ".", "backward", "(", ")", "\n", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "parameters", "(", ")", ",", "5.0", ")", "\n", "if", "(", "batch_count", "%", "self", ".", "config", ".", "BATCH_SIZE", ")", "==", "0", ":", "\n", "                ", "optimizer", ".", "step", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "batch_count", "=", "0", "\n", "\n", "# Progress", "\n", "", "print_progress_bar", "(", "step", "+", "1", ",", "steps", ",", "prefix", "=", "\"\\t{}/{}\"", ".", "format", "(", "step", "+", "1", ",", "steps", ")", ",", "\n", "suffix", "=", "\"Complete - loss: {:.5f} - rpn_class_loss: {:.5f} - rpn_bbox_loss: {:.5f}\"", "\n", "\" - mrcnn_class_loss: {:.5f} - mrcnn_bbox_loss: {:.5f} - mrcnn_mask_loss: {:.5f}\"", "\n", "\" - mrcnn_mask_edge_loss: {:.5f}\"", "\n", ".", "format", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_class_loss\"", "]", "*", "rpn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_bbox_loss\"", "]", "*", "rpn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_class_loss\"", "]", "*", "mrcnn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_bbox_loss\"", "]", "*", "mrcnn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_loss\"", "]", "*", "mrcnn_mask_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_edge_loss\"", "]", "*", "mrcnn_mask_edge_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", ",", "\n", "length", "=", "45", ")", "\n", "\n", "# Statistics", "\n", "loss_sum", "+=", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_rpn_class_sum", "+=", "rpn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_rpn_bbox_sum", "+=", "rpn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_class_sum", "+=", "mrcnn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_bbox_sum", "+=", "mrcnn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_mask_sum", "+=", "mrcnn_mask_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_mask_edge_sum", "+=", "mrcnn_mask_edge_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "\n", "# Break after 'steps' steps", "\n", "if", "step", "==", "steps", "-", "1", ":", "\n", "                ", "break", "\n", "", "step", "+=", "1", "\n", "\n", "", "return", "loss_sum", ",", "loss_rpn_class_sum", ",", "loss_rpn_bbox_sum", ",", "loss_mrcnn_class_sum", ",", "loss_mrcnn_bbox_sum", ",", "loss_mrcnn_mask_sum", ",", "loss_mrcnn_mask_edge_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.valid_epoch": [[1678, 1773], ["image.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze().cpu().numpy", "mask.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze().cpu().numpy", "model.load_image_gt", "image_metas.numpy.numpy.numpy", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "model.MaskRCNN.predict", "model.compute_losses", "model.print_progress_bar", "model.MaskRCNN.anchors.cpu().numpy", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "torch.from_numpy().float().unsqueeze", "images.cuda.cuda.cuda", "rpn_match.cuda.cuda.cuda", "rpn_bbox.cuda.cuda.cuda", "gt_class_ids.cuda.cuda.cuda", "gt_boxes.cuda.cuda.cuda", "gt_masks.cuda.cuda.cuda", "loss.detach().cpu().item", "rpn_class_loss.detach().cpu().item", "rpn_bbox_loss.detach().cpu().item", "mrcnn_class_loss.detach().cpu().item", "mrcnn_bbox_loss.detach().cpu().item", "mrcnn_mask_loss.detach().cpu().item", "mrcnn_mask_edge_loss.detach().cpu().item", "image.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze().cpu", "mask.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze().cpu", "target_class_ids.size", "model.MaskRCNN.anchors.cpu", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "loss.detach().cpu().item", "loss.detach().cpu", "rpn_class_loss.detach().cpu", "rpn_bbox_loss.detach().cpu", "mrcnn_class_loss.detach().cpu", "mrcnn_bbox_loss.detach().cpu", "mrcnn_mask_loss.detach().cpu", "mrcnn_mask_edge_loss.detach().cpu", "image.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze", "mask.squeeze().cpu().numpy.squeeze().cpu().numpy.squeeze", "rpn_class_loss.detach().cpu().item", "rpn_bbox_loss.detach().cpu().item", "mrcnn_class_loss.detach().cpu().item", "mrcnn_bbox_loss.detach().cpu().item", "mrcnn_mask_loss.detach().cpu().item", "mrcnn_mask_edge_loss.detach().cpu().item", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "loss.detach().cpu", "loss.detach", "rpn_class_loss.detach", "rpn_bbox_loss.detach", "mrcnn_class_loss.detach", "mrcnn_bbox_loss.detach", "mrcnn_mask_loss.detach", "mrcnn_mask_edge_loss.detach", "rpn_class_loss.detach().cpu", "rpn_bbox_loss.detach().cpu", "mrcnn_class_loss.detach().cpu", "mrcnn_bbox_loss.detach().cpu", "mrcnn_mask_loss.detach().cpu", "mrcnn_mask_edge_loss.detach().cpu", "loss.detach", "rpn_class_loss.detach", "rpn_bbox_loss.detach", "mrcnn_class_loss.detach", "mrcnn_bbox_loss.detach", "mrcnn_mask_loss.detach", "mrcnn_mask_edge_loss.detach"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.load_image_gt", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.predict", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_losses", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.print_progress_bar"], ["", "def", "valid_epoch", "(", "self", ",", "datagenerator", ",", "steps", ",", "angle", ",", "dataset", ")", ":", "\n", "\n", "        ", "step", "=", "0", "\n", "loss_sum", "=", "0", "\n", "loss_rpn_class_sum", "=", "0", "\n", "loss_rpn_bbox_sum", "=", "0", "\n", "loss_mrcnn_class_sum", "=", "0", "\n", "loss_mrcnn_bbox_sum", "=", "0", "\n", "loss_mrcnn_mask_sum", "=", "0", "\n", "loss_mrcnn_mask_edge_sum", "=", "0", "\n", "\n", "for", "inputs", "in", "datagenerator", ":", "\n", "\n", "            ", "image", "=", "inputs", "[", "0", "]", "\n", "image_metas", "=", "inputs", "[", "1", "]", "\n", "mask", "=", "inputs", "[", "2", "]", "\n", "\n", "image", "=", "image", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mask", "=", "mask", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "images", ",", "rpn_match", ",", "rpn_bbox", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", "=", "load_image_gt", "(", "image", ",", "mask", ",", "angle", ",", "dataset", ",", "\n", "self", ".", "config", ",", "\n", "self", ".", "anchors", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "# image_metas as numpy array", "\n", "image_metas", "=", "image_metas", ".", "numpy", "(", ")", "\n", "\n", "# Wrap in variables", "\n", "images", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "images", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "rpn_match", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "rpn_match", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "rpn_bbox", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "rpn_bbox", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_class_ids", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_class_ids", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_boxes", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_boxes", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_masks", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_masks", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "# To GPU", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                ", "images", "=", "images", ".", "cuda", "(", ")", "\n", "rpn_match", "=", "rpn_match", ".", "cuda", "(", ")", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "cuda", "(", ")", "\n", "gt_class_ids", "=", "gt_class_ids", ".", "cuda", "(", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "cuda", "(", ")", "\n", "gt_masks", "=", "gt_masks", ".", "cuda", "(", ")", "\n", "\n", "# Run object detection", "\n", "", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "mrcnn_class_logits", ",", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", "=", "self", ".", "predict", "(", "[", "images", ",", "image_metas", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", "]", ",", "mode", "=", "'training'", ")", "\n", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "# Compute losses", "\n", "", "rpn_class_loss", ",", "rpn_bbox_loss", ",", "mrcnn_class_loss", ",", "mrcnn_bbox_loss", ",", "mrcnn_mask_loss", ",", "mrcnn_mask_edge_loss", "=", "compute_losses", "(", "rpn_match", ",", "rpn_bbox", ",", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "\n", "mrcnn_class_logits", ",", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", ",", "self", ".", "config", ".", "STAGE", ")", "\n", "\n", "loss", "=", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_class_loss\"", "]", "*", "rpn_class_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_bbox_loss\"", "]", "*", "rpn_bbox_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_class_loss\"", "]", "*", "mrcnn_class_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_bbox_loss\"", "]", "*", "mrcnn_bbox_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_loss\"", "]", "*", "mrcnn_mask_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_edge_loss\"", "]", "*", "mrcnn_mask_edge_loss", "\n", "\n", "# Progress", "\n", "print_progress_bar", "(", "step", "+", "1", ",", "steps", ",", "prefix", "=", "\"\\t{}/{}\"", ".", "format", "(", "step", "+", "1", ",", "steps", ")", ",", "\n", "suffix", "=", "\"Complete - loss: {:.5f} - rpn_class_loss: {:.5f} - rpn_bbox_loss: {:.5f}\"", "\n", "\" - mrcnn_class_loss: {:.5f} - mrcnn_bbox_loss: {:.5f} - mrcnn_mask_loss: {:.5f}\"", "\n", "\" - mrcnn_mask_edge_loss: {:.5f}\"", "\n", ".", "format", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_class_loss\"", "]", "*", "rpn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_bbox_loss\"", "]", "*", "rpn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_class_loss\"", "]", "*", "mrcnn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_bbox_loss\"", "]", "*", "mrcnn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_loss\"", "]", "*", "mrcnn_mask_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_edge_loss\"", "]", "*", "mrcnn_mask_edge_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", ",", "\n", "length", "=", "10", ")", "\n", "\n", "# Statistics", "\n", "loss_sum", "+=", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_rpn_class_sum", "+=", "rpn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_rpn_bbox_sum", "+=", "rpn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_class_sum", "+=", "mrcnn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_bbox_sum", "+=", "mrcnn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_mask_sum", "+=", "mrcnn_mask_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_mask_edge_sum", "+=", "mrcnn_mask_edge_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "\n", "# Break after 'steps' steps", "\n", "if", "step", "==", "steps", "-", "1", ":", "\n", "                ", "break", "\n", "", "step", "+=", "1", "\n", "\n", "", "return", "loss_sum", ",", "loss_rpn_class_sum", ",", "loss_rpn_bbox_sum", ",", "loss_mrcnn_class_sum", ",", "loss_mrcnn_bbox_sum", ",", "loss_mrcnn_mask_sum", ",", "loss_mrcnn_mask_edge_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.mold_inputs": [[1774, 1811], ["numpy.stack", "numpy.stack", "numpy.stack", "utils.resize_image", "model.mold_image", "molded_image.transpose.transpose.transpose", "model.compose_image_meta", "numpy.stack.append", "numpy.stack.append", "numpy.stack.append", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize_image", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.mold_image", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compose_image_meta"], ["", "def", "mold_inputs", "(", "self", ",", "images", ")", ":", "\n", "        ", "\"\"\"Takes a list of images and modifies them to the format expected\n        as an input to the neural network.\n        images: List of image matrices [height, width, depth, channels]. Images can have\n            different sizes.\n        Returns 3 Numpy matrices:\n        molded_images: [N, 1, d, h, w]. Images resized and normalized.\n        image_metas: [N, length of meta data]. Details about each image.\n        windows: [N, (z1, y1, x1, z2, y2, x2)]. The portion of the image that has the\n            original image (padding excluded).\n        \"\"\"", "\n", "molded_images", "=", "[", "]", "\n", "image_metas", "=", "[", "]", "\n", "windows", "=", "[", "]", "\n", "for", "image", "in", "images", ":", "\n", "# Resize image to fit the model expected size", "\n", "            ", "molded_image", ",", "window", ",", "scale", ",", "padding", ",", "crop", "=", "utils", ".", "resize_image", "(", "\n", "image", ",", "\n", "min_dim", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", ",", "\n", "max_dim", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", ",", "\n", "min_scale", "=", "self", ".", "config", ".", "IMAGE_MIN_SCALE", ",", "\n", "mode", "=", "self", ".", "config", ".", "IMAGE_RESIZE_MODE", ")", "\n", "molded_image", "=", "mold_image", "(", "molded_image", ")", "\n", "molded_image", "=", "molded_image", ".", "transpose", "(", "(", "3", ",", "2", ",", "0", ",", "1", ")", ")", "# [C, D, H, W]", "\n", "# Build image_meta", "\n", "image_meta", "=", "compose_image_meta", "(", "\n", "0", ",", "image", ".", "shape", ",", "window", ",", "\n", "np", ".", "zeros", "(", "[", "self", ".", "config", ".", "NUM_CLASSES", "]", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "# Append", "\n", "molded_images", ".", "append", "(", "molded_image", ")", "\n", "windows", ".", "append", "(", "window", ")", "\n", "image_metas", ".", "append", "(", "image_meta", ")", "\n", "# Pack into arrays", "\n", "", "molded_images", "=", "np", ".", "stack", "(", "molded_images", ")", "\n", "image_metas", "=", "np", ".", "stack", "(", "image_metas", ")", "\n", "windows", "=", "np", ".", "stack", "(", "windows", ")", "\n", "return", "molded_images", ",", "image_metas", ",", "windows", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.MaskRCNN.unmold_detections": [[1812, 1865], ["time.time", "detections[].astype", "detections[].astype", "numpy.array", "numpy.array", "numpy.multiply().astype", "utils.unmold_mask", "numpy.argmax", "print", "numpy.where", "numpy.where", "numpy.delete", "numpy.delete", "numpy.delete", "numpy.delete", "numpy.arange", "numpy.argmax.transpose", "numpy.multiply", "time.time", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.unmold_mask"], ["", "def", "unmold_detections", "(", "self", ",", "detections", ",", "mrcnn_mask", ",", "image_shape", ",", "window", ")", ":", "\n", "        ", "\"\"\"Reformat the detections of one image from the format of the neural\n        network output to a format suitable for use in the rest of the application.\n        detections: [N, (z1, y1, x1, z2, y2, x2, class_id, score)]\n        mrcnn_mask: [N, depth, height, width, num_classes]\n        image_shape: [channels, depth, height, width] Original size of the image before resizing\n        window: [z1, y1, x1, z2, y2, x2] Box in the image where the real image is excluding the padding.\n        Returns:\n        boxes: [N, (y1, x1, z1, y2, x2, z2)] Bounding boxes in pixels\n        class_ids: [N] Integer class IDs for each bounding box\n        scores: [N] Float probability scores of the class_id\n        masks: [height, width, depth] normal shape full mask\n        \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "# How many detections do we have?", "\n", "# Detections array is padded with zeros. Find the first class_id == 0.", "\n", "zero_ix", "=", "np", ".", "where", "(", "detections", "[", ":", ",", "6", "]", "==", "0", ")", "[", "0", "]", "\n", "N", "=", "zero_ix", "[", "0", "]", "if", "zero_ix", ".", "shape", "[", "0", "]", ">", "0", "else", "detections", ".", "shape", "[", "0", "]", "\n", "\n", "# Extract boxes, class_ids, scores, and class-specific masks", "\n", "boxes", "=", "detections", "[", ":", "N", ",", ":", "6", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "class_ids", "=", "detections", "[", ":", "N", ",", "6", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "scores", "=", "detections", "[", ":", "N", ",", "7", "]", "\n", "masks", "=", "mrcnn_mask", "[", "np", ".", "arange", "(", "N", ")", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "\n", "# Compute scale and shift to translate the bounding boxes to image domain.", "\n", "d_scale", "=", "image_shape", "[", "1", "]", "/", "(", "window", "[", "3", "]", "-", "window", "[", "0", "]", ")", "\n", "h_scale", "=", "image_shape", "[", "2", "]", "/", "(", "window", "[", "4", "]", "-", "window", "[", "1", "]", ")", "\n", "w_scale", "=", "image_shape", "[", "3", "]", "/", "(", "window", "[", "5", "]", "-", "window", "[", "2", "]", ")", "\n", "shift", "=", "window", "[", ":", "3", "]", "# z, y, x", "\n", "scales", "=", "np", ".", "array", "(", "[", "d_scale", ",", "h_scale", ",", "w_scale", ",", "d_scale", ",", "h_scale", ",", "w_scale", "]", ")", "\n", "shifts", "=", "np", ".", "array", "(", "[", "shift", "[", "0", "]", ",", "shift", "[", "1", "]", ",", "shift", "[", "2", "]", ",", "shift", "[", "0", "]", ",", "shift", "[", "1", "]", ",", "shift", "[", "2", "]", "]", ")", "\n", "boxes", "=", "np", ".", "multiply", "(", "boxes", "-", "shifts", ",", "scales", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "# Filter out detections with zero area. Often only happens in early", "\n", "# stages of training when the network weights are still a bit random.", "\n", "exclude_ix", "=", "np", ".", "where", "(", "\n", "(", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "*", "(", "boxes", "[", ":", ",", "4", "]", "-", "boxes", "[", ":", ",", "1", "]", ")", "*", "(", "boxes", "[", ":", ",", "5", "]", "-", "boxes", "[", ":", ",", "2", "]", ")", "<=", "0", ")", "[", "0", "]", "\n", "if", "exclude_ix", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "boxes", "=", "np", ".", "delete", "(", "boxes", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "class_ids", "=", "np", ".", "delete", "(", "class_ids", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "scores", "=", "np", ".", "delete", "(", "scores", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "masks", "=", "np", ".", "delete", "(", "masks", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "\n", "# Resize masks to original image size.", "\n", "", "full_masks", "=", "utils", ".", "unmold_mask", "(", "masks", "[", "0", "]", ",", "boxes", "[", "0", "]", ",", "image_shape", ")", "\n", "full_mask", "=", "np", ".", "argmax", "(", "full_masks", ",", "axis", "=", "3", ")", "\n", "\n", "# Transform the shapes of boxes to normal shape.", "\n", "boxes", "[", ":", ",", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", "]", "=", "boxes", "[", ":", ",", "[", "1", ",", "2", ",", "0", ",", "4", ",", "5", ",", "3", "]", "]", "\n", "print", "(", "\"unmold done, using time\"", ",", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "\n", "return", "boxes", ",", "np", ".", "arange", "(", "1", ",", "8", ")", ",", "scores", ",", "full_mask", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.log": [[28, 39], ["print", "text.ljust.ljust", "str", "array.min", "array.max"], "function", ["None"], ["def", "log", "(", "text", ",", "array", "=", "None", ")", ":", "\n", "    ", "\"\"\"Prints a text message. And, optionally, if a Numpy array is provided it\n    prints it's shape, min, and max values.\n    \"\"\"", "\n", "if", "array", "is", "not", "None", ":", "\n", "        ", "text", "=", "text", ".", "ljust", "(", "25", ")", "\n", "text", "+=", "(", "\"shape: {:20}  min: {:10.5f}  max: {:10.5f}\"", ".", "format", "(", "\n", "str", "(", "array", ".", "shape", ")", ",", "\n", "array", ".", "min", "(", ")", "if", "array", ".", "size", "else", "\"\"", ",", "\n", "array", ".", "max", "(", ")", "if", "array", ".", "size", "else", "\"\"", ")", ")", "\n", "", "print", "(", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.print_progress_bar": [[41, 59], ["int", "print", "print", "float", "str"], "function", ["None"], ["", "def", "print_progress_bar", "(", "iteration", ",", "total", ",", "prefix", "=", "''", ",", "suffix", "=", "''", ",", "decimals", "=", "1", ",", "length", "=", "100", ",", "fill", "=", "''", ")", ":", "\n", "    ", "\"\"\"Call in a loop to create terminal progress bar\n    @params:\n        iteration   - Required  : current iteration (Int)\n        total       - Required  : total iterations (Int)\n        prefix      - Optional  : prefix string (Str)\n        suffix      - Optional  : suffix string (Str)\n        decimals    - Optional  : positive number of decimals in percent complete (Int)\n        length      - Optional  : character length of bar (Int)\n        fill        - Optional  : bar fill character (Str)\n    \"\"\"", "\n", "percent", "=", "(", "\"{0:.\"", "+", "str", "(", "decimals", ")", "+", "\"f}\"", ")", ".", "format", "(", "100", "*", "(", "iteration", "/", "float", "(", "total", ")", ")", ")", "\n", "filled_length", "=", "int", "(", "length", "*", "iteration", "//", "total", ")", "\n", "bar", "=", "fill", "*", "filled_length", "+", "'-'", "*", "(", "length", "-", "filled_length", ")", "\n", "print", "(", "'\\r%s |%s| %s%% %s'", "%", "(", "prefix", ",", "bar", ",", "percent", ",", "suffix", ")", ",", "end", "=", "'\\n'", ")", "\n", "# Print New Line on Complete", "\n", "if", "iteration", "==", "total", ":", "\n", "        ", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.unique1d": [[65, 75], ["torch.autograd.Variable", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tensor.sort", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor", "first_element.cuda.cuda", "torch.cat.detach", "tensor.size", "tensor.size"], "function", ["None"], ["", "", "def", "unique1d", "(", "tensor", ")", ":", "\n", "    ", "if", "tensor", ".", "size", "(", ")", "[", "0", "]", "==", "0", "or", "tensor", ".", "size", "(", ")", "[", "0", "]", "==", "1", ":", "\n", "        ", "return", "tensor", "\n", "", "tensor", "=", "tensor", ".", "sort", "(", ")", "[", "0", "]", "\n", "unique_bool", "=", "tensor", "[", "1", ":", "]", "!=", "tensor", "[", ":", "-", "1", "]", "\n", "first_element", "=", "Variable", "(", "torch", ".", "ByteTensor", "(", "[", "True", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "tensor", ".", "is_cuda", ":", "\n", "        ", "first_element", "=", "first_element", ".", "cuda", "(", ")", "\n", "", "unique_bool", "=", "torch", ".", "cat", "(", "(", "first_element", ",", "unique_bool", ")", ",", "dim", "=", "0", ")", "\n", "return", "tensor", "[", "unique_bool", ".", "detach", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.intersect1d": [[77, 81], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.sort"], "function", ["None"], ["", "def", "intersect1d", "(", "tensor1", ",", "tensor2", ")", ":", "\n", "    ", "aux", "=", "torch", ".", "cat", "(", "(", "tensor1", ",", "tensor2", ")", ",", "dim", "=", "0", ")", "\n", "aux", "=", "aux", ".", "sort", "(", ")", "[", "0", "]", "\n", "return", "aux", "[", ":", "-", "1", "]", "[", "(", "aux", "[", "1", ":", "]", "==", "aux", "[", ":", "-", "1", "]", ")", ".", "detach", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.log2": [[83, 89], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "ln2.cuda.cuda", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log"], ["", "def", "log2", "(", "x", ")", ":", "\n", "    ", "\"\"\"Implementation of log2. Pytorch doesn't have a native implementation.\"\"\"", "\n", "ln2", "=", "torch", ".", "log", "(", "torch", ".", "FloatTensor", "(", "[", "2.0", "]", ")", ")", "\n", "if", "x", ".", "is_cuda", ":", "\n", "        ", "ln2", "=", "ln2", ".", "cuda", "(", ")", "\n", "", "return", "torch", ".", "log", "(", "x", ")", "/", "ln2", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compute_backbone_shapes": [[91, 102], ["numpy.array", "int", "int", "int", "math.ceil", "math.ceil", "math.ceil"], "function", ["None"], ["", "def", "compute_backbone_shapes", "(", "config", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Computes the depth, width and height of each stage of the backbone network.\n    Returns:\n        [N, (depth, height, width)]. Where N is the number of stages\n    \"\"\"", "\n", "H", ",", "W", ",", "D", "=", "image_shape", "[", ":", "3", "]", "\n", "return", "np", ".", "array", "(", "\n", "[", "[", "int", "(", "math", ".", "ceil", "(", "D", "/", "stride", ")", ")", ",", "\n", "int", "(", "math", ".", "ceil", "(", "H", "/", "stride", ")", ")", ",", "\n", "int", "(", "math", ".", "ceil", "(", "W", "/", "stride", ")", ")", "]", "\n", "for", "stride", "in", "config", ".", "BACKBONE_STRIDES", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.apply_box_deltas": [[155, 183], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "function", ["None"], ["", "", "def", "apply_box_deltas", "(", "boxes", ",", "deltas", ")", ":", "\n", "    ", "\"\"\"Applies the given deltas to the given boxes.\n    boxes: [N, 6] where each row is z1, y1, x1, z2, y2, x2\n    deltas: [N, 6] where each row is [dz, dy, dx, log(dd), log(dh), log(dw)]\n    \"\"\"", "\n", "# Convert to z, y, x, d, h, w", "\n", "depth", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "height", "=", "boxes", "[", ":", ",", "4", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "width", "=", "boxes", "[", ":", ",", "5", "]", "-", "boxes", "[", ":", ",", "2", "]", "\n", "center_z", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "depth", "\n", "center_y", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "height", "\n", "center_x", "=", "boxes", "[", ":", ",", "2", "]", "+", "0.5", "*", "width", "\n", "# Apply deltas", "\n", "center_z", "+=", "deltas", "[", ":", ",", "0", "]", "*", "depth", "\n", "center_y", "+=", "deltas", "[", ":", ",", "1", "]", "*", "height", "\n", "center_x", "+=", "deltas", "[", ":", ",", "2", "]", "*", "width", "\n", "depth", "*=", "torch", ".", "exp", "(", "deltas", "[", ":", ",", "3", "]", ")", "\n", "height", "*=", "torch", ".", "exp", "(", "deltas", "[", ":", ",", "4", "]", ")", "\n", "width", "*=", "torch", ".", "exp", "(", "deltas", "[", ":", ",", "5", "]", ")", "\n", "# Convert back to z1, y1, x1, z2, y2, x2", "\n", "z1", "=", "center_z", "-", "0.5", "*", "depth", "\n", "y1", "=", "center_y", "-", "0.5", "*", "height", "\n", "x1", "=", "center_x", "-", "0.5", "*", "width", "\n", "z2", "=", "z1", "+", "depth", "\n", "y2", "=", "y1", "+", "height", "\n", "x2", "=", "x1", "+", "width", "\n", "result", "=", "torch", ".", "stack", "(", "[", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "]", ",", "dim", "=", "1", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.clip_boxes": [[185, 197], ["torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float"], "function", ["None"], ["", "def", "clip_boxes", "(", "boxes", ",", "window", ")", ":", "\n", "    ", "\"\"\"boxes: [N, 6] each col is z1, y1, x1, z2, y2, x2\n    window: [6] in the form z1, y1, x1, z2, y2, x2\n    \"\"\"", "\n", "boxes", "=", "torch", ".", "stack", "(", "\n", "[", "boxes", "[", ":", ",", "0", "]", ".", "clamp", "(", "float", "(", "window", "[", "0", "]", ")", ",", "float", "(", "window", "[", "3", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "1", "]", ".", "clamp", "(", "float", "(", "window", "[", "1", "]", ")", ",", "float", "(", "window", "[", "4", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "2", "]", ".", "clamp", "(", "float", "(", "window", "[", "2", "]", ")", ",", "float", "(", "window", "[", "5", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "3", "]", ".", "clamp", "(", "float", "(", "window", "[", "0", "]", ")", ",", "float", "(", "window", "[", "3", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "4", "]", ".", "clamp", "(", "float", "(", "window", "[", "1", "]", ")", ",", "float", "(", "window", "[", "4", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "5", "]", ".", "clamp", "(", "float", "(", "window", "[", "2", "]", ")", ",", "float", "(", "window", "[", "5", "]", ")", ")", "]", ",", "1", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.proposal_layer": [[199, 259], ["inputs[].squeeze", "inputs[].squeeze", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "min", "scores.sort", "model.apply_box_deltas", "numpy.array().astype", "model.clip_boxes", "utils.non_max_suppression", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "normalized_boxes.unsqueeze.unsqueeze", "std_dev.cuda.cuda", "clip_boxes.cpu().detach().numpy", "scores.cpu().detach().numpy", "norm.cuda.cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "anchors.size", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.reshape", "order.detach", "order.detach", "clip_boxes.cpu().detach", "scores.cpu().detach", "numpy.array", "clip_boxes.cpu", "scores.cpu"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.apply_box_deltas", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.clip_boxes", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.non_max_suppression"], ["", "def", "proposal_layer", "(", "inputs", ",", "proposal_count", ",", "nms_threshold", ",", "anchors", ",", "config", "=", "None", ")", ":", "\n", "    ", "\"\"\"Receives anchor scores and selects a subset to pass as proposals\n    to the second stage. Filtering is done based on anchor scores and\n    non-max suppression to remove overlaps. It also applies bounding\n    box refinement deltas to anchors.\n    Inputs:\n        rpn_probs: [batch, anchors, (bg prob, fg prob)]\n        rpn_bbox: [batch, anchors, (dz, dy, dx, log(dd), log(dh), log(dw))]\n    Returns:\n        Proposals in normalized coordinates [batch, rois, (z1, y1, x1, z2, y2, x2)]\n    \"\"\"", "\n", "\n", "# Currently only supports batchsize 1", "\n", "inputs", "[", "0", "]", "=", "inputs", "[", "0", "]", ".", "squeeze", "(", "0", ")", "\n", "inputs", "[", "1", "]", "=", "inputs", "[", "1", "]", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Box Scores. Use the foreground class confidence. [Batch, num_rois, 1]", "\n", "scores", "=", "inputs", "[", "0", "]", "[", ":", ",", "1", "]", "\n", "\n", "# Box deltas [batch, num_rois, 6]", "\n", "deltas", "=", "inputs", "[", "1", "]", "\n", "std_dev", "=", "torch", ".", "from_numpy", "(", "np", ".", "reshape", "(", "config", ".", "RPN_BBOX_STD_DEV", ",", "[", "1", ",", "6", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "std_dev", "=", "std_dev", ".", "cuda", "(", ")", "\n", "", "deltas", "=", "deltas", "*", "std_dev", "\n", "\n", "# Improve performance by trimming to top anchors by score", "\n", "# and doing the rest on the smaller subset.", "\n", "pre_nms_limit", "=", "min", "(", "config", ".", "PRE_NMS_LIMIT", ",", "anchors", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "scores", ",", "order", "=", "scores", ".", "sort", "(", "descending", "=", "True", ")", "\n", "order", "=", "order", "[", ":", "pre_nms_limit", "]", "\n", "scores", "=", "scores", "[", ":", "pre_nms_limit", "]", "\n", "deltas", "=", "deltas", "[", "order", ".", "detach", "(", ")", ",", ":", "]", "\n", "anchors", "=", "anchors", "[", "order", ".", "detach", "(", ")", ",", ":", "]", "\n", "\n", "# Apply deltas to anchors to get refined anchors.", "\n", "# [batch, N, (z1, y1, x1, z2, y2, x2)]", "\n", "boxes", "=", "apply_box_deltas", "(", "anchors", ",", "deltas", ")", "\n", "\n", "# Clip to image boundaries. [batch, N, (z1, y1, x1, z2, y2, x2)]", "\n", "height", ",", "width", ",", "depth", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "window", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "depth", ",", "height", ",", "width", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "boxes", "=", "clip_boxes", "(", "boxes", ",", "window", ")", "\n", "\n", "# Non-max suppression", "\n", "keep", "=", "utils", ".", "non_max_suppression", "(", "boxes", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "scores", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "nms_threshold", ",", "proposal_count", ")", "\n", "keep", "=", "torch", ".", "from_numpy", "(", "keep", ")", ".", "long", "(", ")", "\n", "boxes", "=", "boxes", "[", "keep", ",", ":", "]", "\n", "\n", "# Normalize dimensions to range of 0 to 1.", "\n", "norm", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "depth", ",", "height", ",", "width", ",", "depth", ",", "height", ",", "width", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "norm", "=", "norm", ".", "cuda", "(", ")", "\n", "", "normalized_boxes", "=", "boxes", "/", "norm", "\n", "\n", "# Add back batch dimension", "\n", "normalized_boxes", "=", "normalized_boxes", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "return", "normalized_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.RoI_Align": [[265, 290], ["utils.denorm_boxes_graph", "boxes[].floor", "boxes[].floor", "boxes[].floor", "boxes[].ceil", "boxes[].ceil", "boxes[].ceil", "boxes.long.long", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "range", "torch.zeros().cuda.cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "boxes.long.size", "torch.interpolate().cuda", "feature_map.size", "feature_map.size", "feature_map.size", "print", "print", "torch.interpolate", "feature_map.size", "boxes.long.size", "feature_map.size", "feature_map[].unsqueeze"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.denorm_boxes_graph"], ["", "def", "RoI_Align", "(", "feature_map", ",", "pool_size", ",", "boxes", ")", ":", "\n", "    ", "\"\"\"Implementation of 3D RoI Align (actually it's just pooling rather than align).\n    feature_map: [channels, depth, height, width]. Generated from FPN.\n    pool_size: [D, H, W]. The shape of the output.\n    boxes: [num_boxes, (z1, y1, x1, z2, y2, x2)].\n    \"\"\"", "\n", "boxes", "=", "utils", ".", "denorm_boxes_graph", "(", "boxes", ",", "(", "feature_map", ".", "size", "(", ")", "[", "1", "]", ",", "feature_map", ".", "size", "(", ")", "[", "2", "]", ",", "feature_map", ".", "size", "(", ")", "[", "3", "]", ")", ")", "\n", "boxes", "[", ":", ",", "0", "]", "=", "boxes", "[", ":", ",", "0", "]", ".", "floor", "(", ")", "\n", "boxes", "[", ":", ",", "1", "]", "=", "boxes", "[", ":", ",", "1", "]", ".", "floor", "(", ")", "\n", "boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", ".", "floor", "(", ")", "\n", "boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", ".", "ceil", "(", ")", "\n", "boxes", "[", ":", ",", "4", "]", "=", "boxes", "[", ":", ",", "4", "]", ".", "ceil", "(", ")", "\n", "boxes", "[", ":", ",", "5", "]", "=", "boxes", "[", ":", ",", "5", "]", ".", "ceil", "(", ")", "\n", "boxes", "=", "boxes", ".", "long", "(", ")", "\n", "output", "=", "torch", ".", "zeros", "(", "(", "boxes", ".", "size", "(", ")", "[", "0", "]", ",", "feature_map", ".", "size", "(", ")", "[", "0", "]", ",", "pool_size", "[", "0", "]", ",", "pool_size", "[", "1", "]", ",", "pool_size", "[", "2", "]", ")", ")", ".", "cuda", "(", ")", "\n", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", ")", "[", "0", "]", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "output", "[", "i", "]", "=", "F", ".", "interpolate", "(", "(", "feature_map", "[", ":", ",", "boxes", "[", "i", "]", "[", "0", "]", ":", "boxes", "[", "i", "]", "[", "3", "]", ",", "boxes", "[", "i", "]", "[", "1", "]", ":", "boxes", "[", "i", "]", "[", "4", "]", ",", "boxes", "[", "i", "]", "[", "2", "]", ":", "boxes", "[", "i", "]", "[", "5", "]", "]", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "size", "=", "pool_size", ",", "mode", "=", "'trilinear'", ",", "align_corners", "=", "True", ")", ".", "cuda", "(", ")", "\n", "", "except", ":", "\n", "            ", "print", "(", "\"RoI_Align error!\"", ")", "\n", "print", "(", "\"box:\"", ",", "boxes", "[", "i", "]", ",", "\"feature_map size:\"", ",", "feature_map", ".", "size", "(", ")", ")", "\n", "pass", "\n", "\n", "", "", "return", "output", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.pyramid_roi_align": [[292, 371], ["boxes.chunk", "roi_level.clamp.round().int", "roi_level.clamp.clamp", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "range", "range", "range", "torch.cat.append", "level_boxes.detach.detach", "model.RoI_Align", "torch.cat.append", "len", "inputs[].squeeze", "len", "inputs[].squeeze", "model.log2", "roi_level.clamp.round", "ix.any", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "ix.detach", "ix.detach"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.RoI_Align", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log2"], ["", "def", "pyramid_roi_align", "(", "inputs", ",", "pool_size", ",", "test_flag", "=", "False", ")", ":", "\n", "    ", "\"\"\"Implements ROI Pooling on multiple levels of the feature pyramid.\n    Params:\n    - pool_size: [depth, height, width] of the output pooled regions. Usually [7, 7, 7]\n    - image_shape: [height, width, depth, channels]. Shape of input image in pixels\n    Inputs:\n    - boxes: [batch, num_boxes, (z1, y1, x1, z2, y2, x2)] in normalized coordinates.\n    - Feature maps: List of feature maps from different levels of the pyramid.\n                    Each is [batch, channels, depth, height, width]\n    Output:\n    Pooled regions in the shape: [num_boxes, channels, depth, height, width].\n    The width, height and depth are those specific in the pool_shape in the layer\n    constructor.\n    \"\"\"", "\n", "\n", "# Currently only supports batchsize 1", "\n", "if", "test_flag", ":", "\n", "        ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "inputs", ")", ")", ":", "\n", "            ", "inputs", "[", "i", "]", "=", "inputs", "[", "i", "]", ".", "squeeze", "(", "0", ")", "\n", "", "", "else", ":", "\n", "        ", "for", "i", "in", "range", "(", "1", ",", "len", "(", "inputs", ")", ")", ":", "\n", "            ", "inputs", "[", "i", "]", "=", "inputs", "[", "i", "]", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Crop boxes [batch, num_boxes, (y1, x1, z1, y2, x2, z2)] in normalized coordinates", "\n", "", "", "boxes", "=", "inputs", "[", "0", "]", "\n", "# Feature Maps. List of feature maps from different level of the", "\n", "# feature pyramid. Each is [batch, channels, depth, height, width]", "\n", "feature_maps", "=", "inputs", "[", "1", ":", "]", "\n", "\n", "# Assign each ROI to a level in the pyramid based on the ROI volume.", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "boxes", ".", "chunk", "(", "6", ",", "dim", "=", "1", ")", "\n", "d", "=", "z2", "-", "z1", "\n", "h", "=", "y2", "-", "y1", "\n", "w", "=", "x2", "-", "x1", "\n", "\n", "# Equation 1 in the Feature Pyramid Networks paper.", "\n", "# Account for the fact that our coordinates are normalized here.", "\n", "# TODO: change the equation here", "\n", "roi_level", "=", "4", "+", "(", "1.", "/", "3.", ")", "*", "log2", "(", "h", "*", "w", "*", "d", ")", "\n", "roi_level", "=", "roi_level", ".", "round", "(", ")", ".", "int", "(", ")", "\n", "roi_level", "=", "roi_level", ".", "clamp", "(", "2", ",", "3", ")", "\n", "\n", "# Loop through levels and apply ROI pooling to P2 or P3.", "\n", "pooled", "=", "[", "]", "\n", "box_to_level", "=", "[", "]", "\n", "for", "i", ",", "level", "in", "enumerate", "(", "range", "(", "2", ",", "4", ")", ")", ":", "\n", "        ", "ix", "=", "(", "roi_level", "==", "level", ")", "\n", "if", "not", "ix", ".", "any", "(", ")", ":", "\n", "            ", "continue", "\n", "", "ix", "=", "torch", ".", "nonzero", "(", "ix", ")", "[", ":", ",", "0", "]", "\n", "level_boxes", "=", "boxes", "[", "ix", ".", "detach", "(", ")", ",", ":", "]", "\n", "\n", "# Keep track of which box is mapped to which level", "\n", "box_to_level", ".", "append", "(", "ix", ".", "detach", "(", ")", ")", "\n", "\n", "# Stop gradient propagation to ROI proposals", "\n", "level_boxes", "=", "level_boxes", ".", "detach", "(", ")", "\n", "\n", "# Crop and Resize", "\n", "# From Mask R-CNN paper: \"We sample four regular locations, so that we can evaluate", "\n", "# either max or average pooling. In fact, interpolating only a single value at each bin center", "\n", "# (without pooling) is nearly as effective.\"", "\n", "# Here we use the simplified approach of a single value per bin.", "\n", "# Result: [batch * num_boxes, channels, pool_depth, pool_height, pool_width]", "\n", "pooled_features", "=", "RoI_Align", "(", "feature_maps", "[", "i", "]", ",", "pool_size", ",", "level_boxes", ")", "\n", "pooled", ".", "append", "(", "pooled_features", ")", "\n", "\n", "# Pack pooled features into one tensor", "\n", "", "pooled", "=", "torch", ".", "cat", "(", "pooled", ",", "dim", "=", "0", ")", "\n", "\n", "# Pack box_to_level mapping into one array and add another", "\n", "# column representing the order of pooled boxes", "\n", "box_to_level", "=", "torch", ".", "cat", "(", "box_to_level", ",", "dim", "=", "0", ")", "\n", "\n", "# Rearrange pooled features to match the order of the original boxes", "\n", "_", ",", "box_to_level", "=", "torch", ".", "sort", "(", "box_to_level", ")", "\n", "pooled", "=", "pooled", "[", "box_to_level", ",", ":", ",", ":", ",", ":", "]", "\n", "\n", "return", "pooled", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.bbox_overlaps": [[377, 412], ["boxes1.repeat().view.repeat().view", "boxes2.repeat.repeat", "boxes1.repeat().view.chunk", "boxes2.repeat.chunk", "torch.autograd.Variable", "iou.view", "boxes2.repeat.size", "boxes1.repeat().view.size", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "boxes1.repeat().view.repeat", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "z1.size"], "function", ["None"], ["", "def", "bbox_overlaps", "(", "boxes1", ",", "boxes2", ")", ":", "\n", "    ", "\"\"\"Computes IoU overlaps between two sets of boxes.\n    boxes1, boxes2: [N, (z1, y1, x1, z2, y2, x2)].\n    \"\"\"", "\n", "# 1. Tile boxes2 and repeat boxes1. This allows us to compare", "\n", "# every boxes1 against every boxes2 without loops.", "\n", "boxes1_repeat", "=", "boxes2", ".", "size", "(", ")", "[", "0", "]", "\n", "boxes2_repeat", "=", "boxes1", ".", "size", "(", ")", "[", "0", "]", "\n", "boxes1", "=", "boxes1", ".", "repeat", "(", "1", ",", "boxes1_repeat", ")", ".", "view", "(", "-", "1", ",", "6", ")", "\n", "boxes2", "=", "boxes2", ".", "repeat", "(", "boxes2_repeat", ",", "1", ")", "\n", "\n", "# 2. Compute intersections", "\n", "b1_z1", ",", "b1_y1", ",", "b1_x1", ",", "b1_z2", ",", "b1_y2", ",", "b1_x2", "=", "boxes1", ".", "chunk", "(", "6", ",", "dim", "=", "1", ")", "\n", "b2_z1", ",", "b2_y1", ",", "b2_x1", ",", "b2_z2", ",", "b2_y2", ",", "b2_x2", "=", "boxes2", ".", "chunk", "(", "6", ",", "dim", "=", "1", ")", "\n", "z1", "=", "torch", ".", "max", "(", "b1_z1", ",", "b2_z1", ")", "[", ":", ",", "0", "]", "\n", "y1", "=", "torch", ".", "max", "(", "b1_y1", ",", "b2_y1", ")", "[", ":", ",", "0", "]", "\n", "x1", "=", "torch", ".", "max", "(", "b1_x1", ",", "b2_x1", ")", "[", ":", ",", "0", "]", "\n", "z2", "=", "torch", ".", "min", "(", "b1_z2", ",", "b2_z2", ")", "[", ":", ",", "0", "]", "\n", "y2", "=", "torch", ".", "min", "(", "b1_y2", ",", "b2_y2", ")", "[", ":", ",", "0", "]", "\n", "x2", "=", "torch", ".", "min", "(", "b1_x2", ",", "b2_x2", ")", "[", ":", ",", "0", "]", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "z1", ".", "size", "(", ")", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "z1", ".", "is_cuda", ":", "\n", "        ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "intersection", "=", "torch", ".", "max", "(", "x2", "-", "x1", ",", "zeros", ")", "*", "torch", ".", "max", "(", "y2", "-", "y1", ",", "zeros", ")", "*", "torch", ".", "max", "(", "z2", "-", "z1", ",", "zeros", ")", "\n", "\n", "# 3. Compute unions", "\n", "b1_volume", "=", "(", "b1_z2", "-", "b1_z1", ")", "*", "(", "b1_y2", "-", "b1_y1", ")", "*", "(", "b1_x2", "-", "b1_x1", ")", "\n", "b2_volume", "=", "(", "b2_z2", "-", "b2_z1", ")", "*", "(", "b2_y2", "-", "b2_y1", ")", "*", "(", "b2_x2", "-", "b2_x1", ")", "\n", "union", "=", "b1_volume", "[", ":", ",", "0", "]", "+", "b2_volume", "[", ":", ",", "0", "]", "-", "intersection", "\n", "\n", "# 4. Compute IoU and reshape to [boxes1, boxes2]", "\n", "iou", "=", "intersection", "/", "union", "\n", "overlaps", "=", "iou", ".", "view", "(", "boxes2_repeat", ",", "boxes1_repeat", ")", "\n", "\n", "return", "overlaps", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.detection_target_layer": [[414, 564], ["proposals.squeeze.squeeze", "gt_class_ids.squeeze.squeeze", "gt_boxes.squeeze.squeeze", "gt_masks.squeeze.squeeze", "model.bbox_overlaps", "print", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "roi_iou_max.max", "int", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.autograd.Variable", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "numpy.zeros", "range", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "roi_gt_masks.type.type", "int", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.autograd.Variable().long", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.autograd.Variable", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.autograd.Variable", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "rand_idx.cuda.cuda", "positive_indices.size", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "utils.box_refinement", "std_dev.cuda.cuda", "int", "int", "int", "int", "int", "int", "gt_masks[].cpu().numpy", "utils.resize", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "rand_idx.cuda.cuda", "negative_indices.size", "zeros.cuda.cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "positive_indices.size", "roi_gt_box_assignment.detach", "positive_rois.cuda.detach", "roi_gt_boxes.detach", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "negative_indices.size", "torch.autograd.Variable", "roi_gt_class_ids.cuda.long", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable().int", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "positive_indices.detach", "positive_indices.detach", "roi_gt_box_assignment.detach", "gt_masks[].cpu", "negative_indices.detach", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "positive_rois.cuda.cuda", "zeros.cuda.cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "positive_rois.cuda.cuda", "rois.cuda.cuda", "roi_gt_class_ids.cuda.cuda", "deltas.cuda.cuda", "masks.cuda.cuda", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.autograd.Variable", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.bbox_overlaps", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.box_refinement", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["", "def", "detection_target_layer", "(", "proposals", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", ",", "config", ")", ":", "\n", "    ", "\"\"\"Subsamples proposals and generates target box refinement, class_ids,\n    and masks for each.\n    Inputs:\n    proposals: [batch, N, (z1, y1, x1, z2, y2, x2)] in normalized coordinates. Might\n               be zero padded if there are not enough proposals.\n    gt_class_ids: [batch, MAX_GT_INSTANCES] Integer class IDs.\n    gt_boxes: [batch, MAX_GT_INSTANCES, (z1, y1, x1, z2, y2, x2)] in normalized\n              coordinates.\n    gt_masks: [batch, MAX_GT_INSTANCES, depth, height, width] of np.int32 type\n    Returns: Target ROIs and corresponding class IDs, bounding box shifts,\n    and masks.\n    rois: [batch, TRAIN_ROIS_PER_IMAGE, (z1, y1, x1, z2, y2, x2)] in normalized coordinates\n    target_class_ids: [batch, TRAIN_ROIS_PER_IMAGE]. Integer class IDs.\n    target_deltas: [batch, TRAIN_ROIS_PER_IMAGE, NUM_CLASSES,\n                    (dz, dy, dx, log(dd), log(dh), log(dw), class_id)]\n                   Class-specific bbox refinements.\n    target_mask: [batch, TRAIN_ROIS_PER_IMAGE, depth, height, width)\n                 Masks cropped to bbox boundaries and resized to neural\n                 network output size.\n    \"\"\"", "\n", "\n", "# Currently only supports batchsize 1", "\n", "proposals", "=", "proposals", ".", "squeeze", "(", "0", ")", "\n", "gt_class_ids", "=", "gt_class_ids", ".", "squeeze", "(", "0", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "squeeze", "(", "0", ")", "\n", "gt_masks", "=", "gt_masks", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Compute overlaps matrix [proposals, gt_boxes]", "\n", "overlaps", "=", "bbox_overlaps", "(", "proposals", ",", "gt_boxes", ")", "\n", "\n", "# Determine positive and negative ROIs", "\n", "roi_iou_max", "=", "torch", ".", "max", "(", "overlaps", ",", "dim", "=", "1", ")", "[", "0", "]", "\n", "print", "(", "\"rpn_roi_iou_max:\"", ",", "roi_iou_max", ".", "max", "(", ")", ")", "\n", "\n", "# 1. Positive ROIs are those with >= 0.5 IoU with a GT box", "\n", "positive_roi_bool", "=", "roi_iou_max", ">=", "config", ".", "DETECTION_TARGET_IOU_THRESHOLD", "\n", "\n", "# Subsample ROIs. Aim for 33% positive", "\n", "# Positive ROIs", "\n", "if", "torch", ".", "nonzero", "(", "positive_roi_bool", ")", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "        ", "positive_indices", "=", "torch", ".", "nonzero", "(", "positive_roi_bool", ")", "[", ":", ",", "0", "]", "\n", "\n", "positive_count", "=", "int", "(", "config", ".", "TRAIN_ROIS_PER_IMAGE", "*", "\n", "config", ".", "ROI_POSITIVE_RATIO", ")", "\n", "rand_idx", "=", "torch", ".", "randperm", "(", "positive_indices", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "rand_idx", "=", "rand_idx", "[", ":", "positive_count", "]", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "rand_idx", "=", "rand_idx", ".", "cuda", "(", ")", "\n", "", "positive_indices", "=", "positive_indices", "[", "rand_idx", "]", "\n", "positive_count", "=", "positive_indices", ".", "size", "(", ")", "[", "0", "]", "\n", "positive_rois", "=", "proposals", "[", "positive_indices", ".", "detach", "(", ")", ",", ":", "]", "\n", "# Assign positive ROIs to GT boxes.", "\n", "positive_overlaps", "=", "overlaps", "[", "positive_indices", ".", "detach", "(", ")", ",", ":", "]", "\n", "roi_gt_box_assignment", "=", "torch", ".", "max", "(", "positive_overlaps", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "roi_gt_boxes", "=", "gt_boxes", "[", "roi_gt_box_assignment", ".", "detach", "(", ")", ",", ":", "]", "\n", "roi_gt_class_ids", "=", "gt_class_ids", "[", "roi_gt_box_assignment", ".", "detach", "(", ")", "]", "\n", "\n", "# Compute bbox refinement for positive ROIs", "\n", "deltas", "=", "Variable", "(", "utils", ".", "box_refinement", "(", "positive_rois", ".", "detach", "(", ")", ",", "roi_gt_boxes", ".", "detach", "(", ")", ")", ",", "requires_grad", "=", "False", ")", "\n", "std_dev", "=", "torch", ".", "from_numpy", "(", "config", ".", "BBOX_STD_DEV", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "std_dev", "=", "std_dev", ".", "cuda", "(", ")", "\n", "", "deltas", "/=", "std_dev", "\n", "# Assign positive ROIs to GT masks", "\n", "# Permute masks to [N, depth, height, width]", "\n", "# Pick the right mask for each ROI", "\n", "roi_gt_masks", "=", "np", ".", "zeros", "(", "(", "positive_rois", ".", "shape", "[", "0", "]", ",", "8", ",", ")", "+", "config", ".", "MASK_SHAPE", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "positive_rois", ".", "shape", "[", "0", "]", ")", ":", "\n", "             ", "z1", "=", "int", "(", "gt_masks", ".", "shape", "[", "1", "]", "*", "positive_rois", "[", "i", ",", "0", "]", ")", "\n", "z2", "=", "int", "(", "gt_masks", ".", "shape", "[", "1", "]", "*", "positive_rois", "[", "i", ",", "3", "]", ")", "\n", "y1", "=", "int", "(", "gt_masks", ".", "shape", "[", "2", "]", "*", "positive_rois", "[", "i", ",", "1", "]", ")", "\n", "y2", "=", "int", "(", "gt_masks", ".", "shape", "[", "2", "]", "*", "positive_rois", "[", "i", ",", "4", "]", ")", "\n", "x1", "=", "int", "(", "gt_masks", ".", "shape", "[", "3", "]", "*", "positive_rois", "[", "i", ",", "2", "]", ")", "\n", "x2", "=", "int", "(", "gt_masks", ".", "shape", "[", "3", "]", "*", "positive_rois", "[", "i", ",", "5", "]", ")", "\n", "crop_mask", "=", "gt_masks", "[", ":", ",", "z1", ":", "z2", ",", "y1", ":", "y2", ",", "x1", ":", "x2", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "crop_mask", "=", "utils", ".", "resize", "(", "crop_mask", ",", "(", "8", ",", ")", "+", "config", ".", "MASK_SHAPE", ",", "order", "=", "0", ",", "preserve_range", "=", "True", ")", "\n", "roi_gt_masks", "[", "i", ",", ":", ",", ":", ",", ":", ",", ":", "]", "=", "crop_mask", "\n", "", "roi_gt_masks", "=", "torch", ".", "from_numpy", "(", "roi_gt_masks", ")", ".", "cuda", "(", ")", "\n", "roi_gt_masks", "=", "roi_gt_masks", ".", "type", "(", "torch", ".", "DoubleTensor", ")", "\n", "", "else", ":", "\n", "        ", "positive_count", "=", "0", "\n", "\n", "# 2. Negative ROIs are those with < 0.5 with every GT box.", "\n", "", "negative_roi_bool", "=", "roi_iou_max", "<", "config", ".", "DETECTION_TARGET_IOU_THRESHOLD", "\n", "negative_roi_bool", "=", "negative_roi_bool", "\n", "# Negative ROIs. Add enough to maintain positive:negative ratio.", "\n", "if", "torch", ".", "nonzero", "(", "negative_roi_bool", ")", ".", "size", "(", ")", "[", "0", "]", "!=", "0", "and", "positive_count", ">", "0", ":", "\n", "        ", "negative_indices", "=", "torch", ".", "nonzero", "(", "negative_roi_bool", ")", "[", ":", ",", "0", "]", "\n", "r", "=", "1.0", "/", "config", ".", "ROI_POSITIVE_RATIO", "\n", "negative_count", "=", "int", "(", "r", "*", "positive_count", "-", "positive_count", ")", "\n", "rand_idx", "=", "torch", ".", "randperm", "(", "negative_indices", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "rand_idx", "=", "rand_idx", "[", ":", "negative_count", "]", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "rand_idx", "=", "rand_idx", ".", "cuda", "(", ")", "\n", "", "negative_indices", "=", "negative_indices", "[", "rand_idx", "]", "\n", "negative_count", "=", "negative_indices", ".", "size", "(", ")", "[", "0", "]", "\n", "negative_rois", "=", "proposals", "[", "negative_indices", ".", "detach", "(", ")", ",", ":", "]", "\n", "", "else", ":", "\n", "        ", "negative_count", "=", "0", "\n", "\n", "# Append negative ROIs and pad bbox deltas and masks that", "\n", "# are not used for negative ROIs with zeros.", "\n", "", "if", "positive_count", ">", "0", "and", "negative_count", ">", "0", ":", "\n", "        ", "rois", "=", "torch", ".", "cat", "(", "(", "positive_rois", ",", "negative_rois", ")", ",", "dim", "=", "0", ")", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ")", ",", "requires_grad", "=", "False", ")", ".", "long", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "roi_gt_class_ids", "=", "torch", ".", "cat", "(", "[", "roi_gt_class_ids", ".", "long", "(", ")", ",", "zeros", "]", ",", "dim", "=", "0", ")", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ",", "6", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "deltas", "=", "torch", ".", "cat", "(", "[", "deltas", ",", "zeros", "]", ",", "dim", "=", "0", ")", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ",", "config", ".", "MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MASK_SHAPE", "[", "1", "]", ",", "config", ".", "MASK_SHAPE", "[", "2", "]", ")", ",", "\n", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "masks", "=", "roi_gt_masks", "\n", "", "elif", "positive_count", ">", "0", ":", "\n", "        ", "rois", "=", "positive_rois", "\n", "", "elif", "negative_count", ">", "0", ":", "\n", "        ", "positive_rois", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "rois", "=", "negative_rois", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "positive_rois", "=", "positive_rois", ".", "cuda", "(", ")", "\n", "", "roi_gt_class_ids", "=", "zeros", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ",", "6", ")", ",", "requires_grad", "=", "False", ")", ".", "int", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "deltas", "=", "zeros", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ",", "config", ".", "MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MASK_SHAPE", "[", "1", "]", ",", "config", ".", "MASK_SHAPE", "[", "2", "]", ")", ",", "\n", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "masks", "=", "zeros", "\n", "", "else", ":", "\n", "        ", "positive_rois", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "rois", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "roi_gt_class_ids", "=", "Variable", "(", "torch", ".", "IntTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "deltas", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "masks", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "positive_rois", "=", "positive_rois", ".", "cuda", "(", ")", "\n", "rois", "=", "rois", ".", "cuda", "(", ")", "\n", "roi_gt_class_ids", "=", "roi_gt_class_ids", ".", "cuda", "(", ")", "\n", "deltas", "=", "deltas", ".", "cuda", "(", ")", "\n", "masks", "=", "masks", ".", "cuda", "(", ")", "\n", "", "", "return", "positive_rois", ",", "rois", ",", "roi_gt_class_ids", ",", "deltas", ",", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.clip_to_window": [[570, 582], ["boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float"], "function", ["None"], ["", "def", "clip_to_window", "(", "window", ",", "boxes", ")", ":", "\n", "    ", "\"\"\"window: (z1, y1, x1, z2, y2, x2). The window in the image we want to clip to.\n        boxes: [N, (z1, y1, x1, z2, y2, x2)]\n    \"\"\"", "\n", "boxes", "[", ":", ",", "0", "]", "=", "boxes", "[", ":", ",", "0", "]", ".", "clamp", "(", "float", "(", "window", "[", "0", "]", ")", ",", "float", "(", "window", "[", "3", "]", ")", ")", "\n", "boxes", "[", ":", ",", "1", "]", "=", "boxes", "[", ":", ",", "1", "]", ".", "clamp", "(", "float", "(", "window", "[", "1", "]", ")", ",", "float", "(", "window", "[", "4", "]", ")", ")", "\n", "boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", ".", "clamp", "(", "float", "(", "window", "[", "2", "]", ")", ",", "float", "(", "window", "[", "5", "]", ")", ")", "\n", "boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", ".", "clamp", "(", "float", "(", "window", "[", "0", "]", ")", ",", "float", "(", "window", "[", "3", "]", ")", ")", "\n", "boxes", "[", ":", ",", "4", "]", "=", "boxes", "[", ":", ",", "4", "]", ".", "clamp", "(", "float", "(", "window", "[", "1", "]", ")", ",", "float", "(", "window", "[", "4", "]", ")", ")", "\n", "boxes", "[", ":", ",", "5", "]", "=", "boxes", "[", ":", ",", "5", "]", ".", "clamp", "(", "float", "(", "window", "[", "2", "]", ")", ",", "float", "(", "window", "[", "5", "]", ")", ")", "\n", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.refine_detections": [[584, 677], ["torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.apply_box_deltas", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.clip_to_window", "torch.round", "torch.round", "torch.round", "torch.round", "torch.round", "enumerate", "model.intersect1d", "min", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "idx.cuda.cuda", "std_dev.cuda.cuda", "scale.cuda.cuda", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "model.unique1d", "ix_scores.sort", "utils.non_max_suppression", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "intersect1d.detach", "intersect1d.detach", "intersect1d.detach", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "ix_rois.cpu().detach().numpy", "ix_scores.cpu().detach().numpy", "model.unique1d", "intersect1d.size", "class_scores[].sort", "top_ids.detach", "class_ids[].unsqueeze().float", "class_scores[].unsqueeze", "class_ids.detach", "class_ids.detach", "numpy.reshape", "numpy.array", "ixs.detach", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "ixs[].detach", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "class_ids.size", "order.detach", "ix_rois.cpu().detach", "ix_scores.cpu().detach", "intersect1d.detach", "class_ids[].unsqueeze", "ix_rois.cpu", "ix_scores.cpu", "intersect1d.detach", "intersect1d.detach", "order[].detach", "intersect1d.detach"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.apply_box_deltas", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.clip_to_window", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.intersect1d", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.unique1d", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.non_max_suppression", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.unique1d"], ["", "def", "refine_detections", "(", "rois", ",", "probs", ",", "deltas", ",", "window", ",", "config", ")", ":", "\n", "    ", "\"\"\"Refine classified proposals and filter overlaps and return final\n    detections.\n    Inputs:\n        rois: [N, (z1, y1, x1, z2, y2, x2)] in normalized coordinates\n        probs: [N, num_classes]. Class probabilities.\n        deltas: [N, num_classes, (dz, dy, dx, log(dd), log(dh), log(dw))]. Class-specific\n                bounding box deltas.\n        window: (z1, y1, x1, z2, y2, x2) in image coordinates. The part of the image\n            that contains the image excluding the padding.\n    Returns detections shaped: [N, (z1, y1, x1, z2, y2, x2, class_id, score)]\n    \"\"\"", "\n", "\n", "# Class IDs per ROI", "\n", "_", ",", "class_ids", "=", "torch", ".", "max", "(", "probs", ",", "dim", "=", "1", ")", "\n", "\n", "# Class probability of the top class of each ROI", "\n", "# Class-specific bounding box deltas", "\n", "idx", "=", "torch", ".", "arange", "(", "class_ids", ".", "size", "(", ")", "[", "0", "]", ")", ".", "long", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "idx", "=", "idx", ".", "cuda", "(", ")", "\n", "", "class_scores", "=", "probs", "[", "idx", ",", "class_ids", ".", "detach", "(", ")", "]", "\n", "deltas_specific", "=", "deltas", "[", "idx", ",", "class_ids", ".", "detach", "(", ")", "]", "\n", "\n", "# Apply bounding box deltas", "\n", "# Shape: [boxes, (z1, y1, x1, z2, y2, x2)] in normalized coordinates", "\n", "std_dev", "=", "torch", ".", "from_numpy", "(", "np", ".", "reshape", "(", "config", ".", "RPN_BBOX_STD_DEV", ",", "[", "1", ",", "6", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "std_dev", "=", "std_dev", ".", "cuda", "(", ")", "\n", "", "refined_rois", "=", "apply_box_deltas", "(", "rois", ",", "deltas_specific", "*", "std_dev", ")", "\n", "\n", "# Convert coordinates to image domain", "\n", "height", ",", "width", ",", "depth", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "scale", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "depth", ",", "height", ",", "width", ",", "depth", ",", "height", ",", "width", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "scale", "=", "scale", ".", "cuda", "(", ")", "\n", "", "refined_rois", "*=", "scale", "\n", "\n", "# Clip boxes to image window", "\n", "refined_rois", "=", "clip_to_window", "(", "window", ",", "refined_rois", ")", "\n", "\n", "# Round and cast to int since we're dealing with pixels now", "\n", "refined_rois", "=", "torch", ".", "round", "(", "refined_rois", ")", "\n", "\n", "# Filter out background boxes", "\n", "keep_bool", "=", "class_ids", ">", "0", "\n", "\n", "# Filter out low confidence boxes", "\n", "if", "config", ".", "DETECTION_MIN_CONFIDENCE", ":", "\n", "        ", "keep_bool", "=", "keep_bool", "&", "(", "class_scores", ">=", "config", ".", "DETECTION_MIN_CONFIDENCE", ")", "\n", "", "keep", "=", "torch", ".", "nonzero", "(", "keep_bool", ")", "[", ":", ",", "0", "]", "\n", "\n", "# Apply per-class NMS", "\n", "pre_nms_class_ids", "=", "class_ids", "[", "keep", ".", "detach", "(", ")", "]", "\n", "pre_nms_scores", "=", "class_scores", "[", "keep", ".", "detach", "(", ")", "]", "\n", "pre_nms_rois", "=", "refined_rois", "[", "keep", ".", "detach", "(", ")", "]", "\n", "\n", "for", "i", ",", "class_id", "in", "enumerate", "(", "unique1d", "(", "pre_nms_class_ids", ")", ")", ":", "\n", "# Pick detections of this class", "\n", "        ", "ixs", "=", "torch", ".", "nonzero", "(", "pre_nms_class_ids", "==", "class_id", ")", "[", ":", ",", "0", "]", "\n", "\n", "# Sort", "\n", "ix_rois", "=", "pre_nms_rois", "[", "ixs", ".", "detach", "(", ")", "]", "\n", "ix_scores", "=", "pre_nms_scores", "[", "ixs", "]", "\n", "ix_scores", ",", "order", "=", "ix_scores", ".", "sort", "(", "descending", "=", "True", ")", "\n", "ix_rois", "=", "ix_rois", "[", "order", ".", "detach", "(", ")", ",", ":", "]", "\n", "\n", "class_keep", "=", "utils", ".", "non_max_suppression", "(", "ix_rois", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "ix_scores", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "config", ".", "DETECTION_NMS_THRESHOLD", ",", "config", ".", "DETECTION_MAX_INSTANCES", ")", "\n", "class_keep", "=", "torch", ".", "from_numpy", "(", "class_keep", ")", ".", "long", "(", ")", "\n", "\n", "# Map indices", "\n", "class_keep", "=", "keep", "[", "ixs", "[", "order", "[", "class_keep", "]", ".", "detach", "(", ")", "]", ".", "detach", "(", ")", "]", "\n", "\n", "if", "i", "==", "0", ":", "\n", "            ", "nms_keep", "=", "class_keep", "\n", "", "else", ":", "\n", "            ", "nms_keep", "=", "unique1d", "(", "torch", ".", "cat", "(", "(", "nms_keep", ",", "class_keep", ")", ")", ")", "\n", "", "", "keep", "=", "intersect1d", "(", "keep", ",", "nms_keep", ")", "\n", "\n", "# Keep top detections", "\n", "roi_count", "=", "config", ".", "DETECTION_MAX_INSTANCES", "\n", "roi_count", "=", "min", "(", "roi_count", ",", "keep", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "top_ids", "=", "class_scores", "[", "keep", ".", "detach", "(", ")", "]", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "[", ":", "roi_count", "]", "\n", "keep", "=", "keep", "[", "top_ids", ".", "detach", "(", ")", "]", "\n", "\n", "# Arrange output as [N, (z1, y1, x1, z2, y2, x2, class_id, score)]", "\n", "# Coordinates are in image domain.", "\n", "result", "=", "torch", ".", "cat", "(", "(", "refined_rois", "[", "keep", ".", "detach", "(", ")", "]", ",", "\n", "class_ids", "[", "keep", ".", "detach", "(", ")", "]", ".", "unsqueeze", "(", "1", ")", ".", "float", "(", ")", ",", "\n", "class_scores", "[", "keep", ".", "detach", "(", ")", "]", ".", "unsqueeze", "(", "1", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.detection_layer": [[679, 694], ["rois.squeeze.squeeze", "model.parse_image_meta", "model.refine_detections"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.parse_image_meta", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.refine_detections"], ["", "def", "detection_layer", "(", "config", ",", "rois", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "image_meta", ")", ":", "\n", "    ", "\"\"\"Takes classified proposal boxes and their bounding box deltas and\n    returns the final detection boxes.\n    Returns:\n    [batch, num_detections, (z1, y1, x1, z2, y2, x2, class_score)] in pixels\n    \"\"\"", "\n", "\n", "# Currently only supports batchsize 1", "\n", "rois", "=", "rois", ".", "squeeze", "(", "0", ")", "\n", "\n", "_", ",", "_", ",", "window", ",", "_", "=", "parse_image_meta", "(", "image_meta", ")", "\n", "window", "=", "window", "[", "0", "]", "\n", "detections", "=", "refine_detections", "(", "rois", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "window", ",", "config", ")", "\n", "\n", "return", "detections", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compute_rpn_class_loss": [[808, 833], ["rpn_match.squeeze.squeeze", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.cross_entropy", "torch.nonzero.detach", "torch.nonzero.detach", "torch.nonzero.detach", "torch.nonzero.detach"], "function", ["None"], ["", "", "def", "compute_rpn_class_loss", "(", "rpn_match", ",", "rpn_class_logits", ")", ":", "\n", "    ", "\"\"\"RPN anchor classifier loss.\n    rpn_match: [batch, anchors, 1]. Anchor match type. 1=positive,\n               -1=negative, 0=neutral anchor.\n    rpn_class_logits: [batch, anchors, 2]. RPN classifier logits for FG/BG.\n    \"\"\"", "\n", "\n", "# Squeeze last dim to simplify", "\n", "rpn_match", "=", "rpn_match", ".", "squeeze", "(", "2", ")", "\n", "\n", "# Get anchor classes. Convert the -1/+1 match to 0/1 values.", "\n", "anchor_class", "=", "(", "rpn_match", "==", "1", ")", ".", "long", "(", ")", "\n", "\n", "# Positive and Negative anchors contribute to the loss,", "\n", "# but neutral anchors (match value = 0) don't.", "\n", "indices", "=", "torch", ".", "nonzero", "(", "rpn_match", "!=", "0", ")", "\n", "\n", "# Pick rows that contribute to the loss and filter out the rest.", "\n", "rpn_class_logits", "=", "rpn_class_logits", "[", "indices", ".", "detach", "(", ")", "[", ":", ",", "0", "]", ",", "indices", ".", "detach", "(", ")", "[", ":", ",", "1", "]", ",", ":", "]", "\n", "anchor_class", "=", "anchor_class", "[", "indices", ".", "detach", "(", ")", "[", ":", ",", "0", "]", ",", "indices", ".", "detach", "(", ")", "[", ":", ",", "1", "]", "]", "\n", "\n", "# Cross-entropy loss", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "rpn_class_logits", ",", "anchor_class", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compute_rpn_bbox_loss": [[835, 861], ["rpn_match.squeeze.squeeze", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.smooth_l1_loss", "torch.nonzero.detach", "torch.nonzero.detach", "rpn_bbox.size"], "function", ["None"], ["", "def", "compute_rpn_bbox_loss", "(", "target_bbox", ",", "rpn_match", ",", "rpn_bbox", ")", ":", "\n", "    ", "\"\"\"Return the RPN bounding box loss graph.\n    target_bbox: [batch, max positive anchors, (dz, dy, dx, log(dd), log(dh), log(dw))].\n        Uses 0 padding to fill in unused bbox deltas.\n    rpn_match: [batch, anchors, 1]. Anchor match type. 1=positive,\n               -1=negative, 0=neutral anchor.\n    rpn_bbox: [batch, anchors, (dz, dy, dx, log(dd), log(dh), log(dw))]\n    \"\"\"", "\n", "\n", "# Squeeze last dim to simplify", "\n", "rpn_match", "=", "rpn_match", ".", "squeeze", "(", "2", ")", "\n", "\n", "# Positive anchors contribute to the loss, but negative and", "\n", "# neutral anchors (match value of 0 or -1) don't.", "\n", "indices", "=", "torch", ".", "nonzero", "(", "rpn_match", "==", "1", ")", "\n", "\n", "# Pick bbox deltas that contribute to the loss", "\n", "rpn_bbox", "=", "rpn_bbox", "[", "indices", ".", "detach", "(", ")", "[", ":", ",", "0", "]", ",", "indices", ".", "detach", "(", ")", "[", ":", ",", "1", "]", "]", "\n", "\n", "# Trim target bounding box deltas to the same length as rpn_bbox.", "\n", "target_bbox", "=", "target_bbox", "[", "0", ",", ":", "rpn_bbox", ".", "size", "(", ")", "[", "0", "]", ",", ":", "]", "\n", "\n", "# Smooth L1 loss", "\n", "loss", "=", "F", ".", "smooth_l1_loss", "(", "rpn_bbox", ",", "target_bbox", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compute_mrcnn_class_loss": [[863, 879], ["torch.cross_entropy", "torch.autograd.Variable", "target_class_ids.size", "target_class_ids.long", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "loss.cuda.cuda"], "function", ["None"], ["", "def", "compute_mrcnn_class_loss", "(", "target_class_ids", ",", "pred_class_logits", ")", ":", "\n", "    ", "\"\"\"Loss for the classifier head of Mask RCNN.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Uses zero\n        padding to fill in the array.\n    pred_class_logits: [batch, num_rois, num_classes]\n    \"\"\"", "\n", "\n", "# Loss", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "        ", "loss", "=", "F", ".", "cross_entropy", "(", "pred_class_logits", ",", "target_class_ids", ".", "long", "(", ")", ")", "\n", "", "else", ":", "\n", "        ", "loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "target_class_ids", ".", "is_cuda", ":", "\n", "            ", "loss", "=", "loss", ".", "cuda", "(", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compute_mrcnn_bbox_loss": [[881, 907], ["target_class_ids[].long", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.smooth_l1_loss", "torch.autograd.Variable", "target_class_ids.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "loss.cuda.cuda", "indices[].detach", "indices[].detach", "indices[].detach", "positive_roi_ix.detach"], "function", ["None"], ["", "def", "compute_mrcnn_bbox_loss", "(", "target_bbox", ",", "target_class_ids", ",", "pred_bbox", ")", ":", "\n", "    ", "\"\"\"Loss for Mask R-CNN bounding box refinement.\n    target_bbox: [batch, num_rois, (dz, dy, dx, log(dd), log(dh), log(dw))]\n    target_class_ids: [batch, num_rois]. Integer class IDs.\n    pred_bbox: [batch, num_rois, num_classes, (dz, dy, dx, log(dd), log(dh), log(dw))]\n    \"\"\"", "\n", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the right class_id of each ROI. Get their indices.", "\n", "        ", "positive_roi_ix", "=", "torch", ".", "nonzero", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_roi_class_ids", "=", "target_class_ids", "[", "positive_roi_ix", ".", "detach", "(", ")", "]", ".", "long", "(", ")", "\n", "indices", "=", "torch", ".", "stack", "(", "(", "positive_roi_ix", ",", "positive_roi_class_ids", ")", ",", "dim", "=", "1", ")", "\n", "\n", "# Gather the deltas (predicted and true) that contribute to loss", "\n", "target_bbox", "=", "target_bbox", "[", "indices", "[", ":", ",", "0", "]", ".", "detach", "(", ")", ",", ":", "]", "\n", "pred_bbox", "=", "pred_bbox", "[", "indices", "[", ":", ",", "0", "]", ".", "detach", "(", ")", ",", "indices", "[", ":", ",", "1", "]", ".", "detach", "(", ")", ",", ":", "]", "\n", "\n", "# Smooth L1 loss", "\n", "loss", "=", "F", ".", "smooth_l1_loss", "(", "pred_bbox", ",", "target_bbox", ")", "\n", "", "else", ":", "\n", "        ", "loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "target_class_ids", ".", "is_cuda", ":", "\n", "            ", "loss", "=", "loss", ".", "cuda", "(", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compute_mrcnn_mask_loss": [[909, 936], ["target_class_ids[].long", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "y_true_.long().cuda", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.CrossEntropyLoss().cuda", "nn.CrossEntropyLoss().cuda.", "torch.autograd.Variable", "target_class_ids.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "loss.cuda.cuda", "y_true_.long", "torch.CrossEntropyLoss", "indices[].detach", "positive_ix.detach"], "function", ["None"], ["", "def", "compute_mrcnn_mask_loss", "(", "target_masks", ",", "target_class_ids", ",", "pred_masks", ")", ":", "\n", "    ", "\"\"\"Mask binary cross-entropy loss for the masks head.\n    target_masks: [batch, num_rois, depth, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_masks: [batch, proposals, num_classes, depth, height, width] float32 tensor\n                with values from 0 to 1.\n    \"\"\"", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "# Only positive ROIs contribute to the loss. And only the class specific mask of each ROI.", "\n", "        ", "positive_ix", "=", "torch", ".", "nonzero", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "target_class_ids", "[", "positive_ix", ".", "detach", "(", ")", "]", ".", "long", "(", ")", "\n", "indices", "=", "torch", ".", "stack", "(", "(", "positive_ix", ",", "positive_class_ids", ")", ",", "dim", "=", "1", ")", "\n", "# Gather the masks (predicted and true) that contribute to loss", "\n", "y_true_", "=", "target_masks", "[", "indices", "[", ":", ",", "0", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "y_true", "=", "y_true_", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "y_true", "=", "torch", ".", "argmax", "(", "y_true", ",", "dim", "=", "1", ")", "\n", "y_pred", "=", "pred_masks", "[", "indices", "[", ":", ",", "0", "]", ".", "detach", "(", ")", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "# Binary cross entropy", "\n", "los", "=", "nn", ".", "CrossEntropyLoss", "(", ")", ".", "cuda", "(", ")", "\n", "loss", "=", "los", "(", "y_pred", ",", "y_true", ")", "\n", "", "else", ":", "\n", "        ", "loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "target_class_ids", ".", "is_cuda", ":", "\n", "            ", "loss", "=", "loss", ".", "cuda", "(", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compute_mrcnn_mask_edge_loss": [[938, 982], ["numpy.array", "np.array.transpose", "np.array.transpose", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "target_class_ids[].long", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.MSELoss", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "range", "torch.autograd.Variable", "target_class_ids.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "y_pred[].unsqueeze", "range", "torch.stack.size", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "loss.cuda.cuda", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.stack.size", "torch.conv3d", "torch.conv3d", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "nn.MSELoss.", "indices[].detach", "y_true_[].unsqueeze().unsqueeze().cuda().float", "y_pred_[].unsqueeze", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "positive_ix.detach", "torch.stack.size", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "numpy.array().reshape", "y_true_[].unsqueeze().unsqueeze().cuda", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "numpy.array", "y_true_[].unsqueeze().unsqueeze", "y_true_[].unsqueeze"], "function", ["None"], ["", "def", "compute_mrcnn_mask_edge_loss", "(", "target_masks", ",", "target_class_ids", ",", "pred_masks", ")", ":", "\n", "    ", "\"\"\"Mask edge mean square error loss for the Edge Agreement Head.\n    Here I use the Sobel kernel without smoothing the ground_truth masks.\n        target_masks: [batch, num_rois, depth, height, width].\n        target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n        pred_masks: [batch, proposals, num_classes, depth, height, width] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "# Generate the xyz dimension Sobel kernels", "\n", "        ", "kernel_x", "=", "np", ".", "array", "(", "[", "[", "[", "1", ",", "2", ",", "1", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "-", "1", ",", "-", "2", ",", "-", "1", "]", "]", ",", "\n", "[", "[", "2", ",", "4", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "-", "2", ",", "-", "4", ",", "-", "2", "]", "]", ",", "\n", "[", "[", "1", ",", "2", ",", "1", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "-", "1", ",", "-", "2", ",", "-", "1", "]", "]", "]", ")", "\n", "kernel_y", "=", "kernel_x", ".", "transpose", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "kernel_z", "=", "kernel_x", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "kernel", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "kernel_x", ",", "kernel_y", ",", "kernel_z", "]", ")", ".", "reshape", "(", "(", "3", ",", "1", ",", "3", ",", "3", ",", "3", ")", ")", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "\n", "# Only positive ROIs contribute to the loss. And only the class specific mask of each ROI.", "\n", "positive_ix", "=", "torch", ".", "nonzero", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "target_class_ids", "[", "positive_ix", ".", "detach", "(", ")", "]", ".", "long", "(", ")", "\n", "indices", "=", "torch", ".", "stack", "(", "(", "positive_ix", ",", "positive_class_ids", ")", ",", "dim", "=", "1", ")", "\n", "# Gather the masks (predicted and true) that contribute to loss", "\n", "y_true", "=", "target_masks", "[", ":", "indices", ".", "size", "(", ")", "[", "0", "]", ",", "1", ":", ",", ":", ",", ":", "]", "\n", "y_pred", "=", "pred_masks", "[", "indices", "[", ":", ",", "0", "]", ".", "detach", "(", ")", ",", "1", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "# Implement the edge detection convolution", "\n", "loss_fn", "=", "nn", ".", "MSELoss", "(", ")", "\n", "loss", "=", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "cuda", "(", ")", "\n", "for", "i", "in", "range", "(", "indices", ".", "size", "(", ")", "[", "0", "]", ")", ":", "\n", "            ", "y_true_", "=", "y_true", "[", "i", "]", "\n", "y_pred_", "=", "y_pred", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "# [N, 7, 64, 64, 64]", "\n", "for", "j", "in", "range", "(", "7", ")", ":", "\n", "                ", "y_true_final", "=", "F", ".", "conv3d", "(", "y_true_", "[", "j", ",", ":", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ".", "float", "(", ")", ",", "kernel", ")", "\n", "y_pred_final", "=", "F", ".", "conv3d", "(", "y_pred_", "[", ":", ",", "j", ",", ":", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", ",", "kernel", ")", "\n", "y_true_final", "=", "torch", ".", "sqrt", "(", "torch", ".", "pow", "(", "y_true_final", "[", ":", ",", "0", "]", ",", "2", ")", "+", "torch", ".", "pow", "(", "y_true_final", "[", ":", ",", "1", "]", ",", "2", ")", "+", "\n", "torch", ".", "pow", "(", "y_true_final", "[", ":", ",", "0", "]", ",", "2", ")", ")", "\n", "y_pred_final", "=", "torch", ".", "sqrt", "(", "torch", ".", "pow", "(", "y_pred_final", "[", ":", ",", "0", "]", ",", "2", ")", "+", "torch", ".", "pow", "(", "y_pred_final", "[", ":", ",", "1", "]", ",", "2", ")", "+", "\n", "torch", ".", "pow", "(", "y_pred_final", "[", ":", ",", "0", "]", ",", "2", ")", ")", "\n", "# Mean Square Error", "\n", "loss", "+=", "loss_fn", "(", "y_pred_final", ",", "y_true_final", ")", "\n", "", "", "loss", "/=", "indices", ".", "size", "(", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "target_class_ids", ".", "is_cuda", ":", "\n", "            ", "loss", "=", "loss", ".", "cuda", "(", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compute_losses": [[984, 1001], ["model.compute_rpn_class_loss", "model.compute_rpn_bbox_loss", "model.compute_mrcnn_class_loss", "model.compute_mrcnn_bbox_loss", "model.compute_mrcnn_mask_loss", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "model.compute_mrcnn_mask_edge_loss", "torch.autograd.Variable().cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.autograd.Variable", "numpy.where", "numpy.where", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_rpn_class_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_rpn_bbox_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_class_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_bbox_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_mask_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_mask_edge_loss"], ["", "def", "compute_losses", "(", "rpn_match", ",", "rpn_bbox", ",", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "mrcnn_class_logits", ",", "\n", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", ",", "stage", ")", ":", "\n", "\n", "    ", "rpn_class_loss", "=", "compute_rpn_class_loss", "(", "rpn_match", ",", "rpn_class_logits", ")", "\n", "rpn_bbox_loss", "=", "compute_rpn_bbox_loss", "(", "rpn_bbox", ",", "rpn_match", ",", "rpn_pred_bbox", ")", "\n", "mrcnn_class_loss", "=", "compute_mrcnn_class_loss", "(", "torch", ".", "from_numpy", "(", "np", ".", "where", "(", "target_class_ids", ">", "0", ",", "1", ",", "0", ")", ")", ".", "cuda", "(", ")", ",", "\n", "mrcnn_class_logits", ")", "\n", "mrcnn_bbox_loss", "=", "compute_mrcnn_bbox_loss", "(", "target_deltas", ",", "\n", "torch", ".", "from_numpy", "(", "np", ".", "where", "(", "target_class_ids", ">", "0", ",", "1", ",", "0", ")", ")", ".", "cuda", "(", ")", ",", "mrcnn_bbox", ")", "\n", "\n", "mrcnn_mask_loss", "=", "compute_mrcnn_mask_loss", "(", "target_mask", ",", "target_class_ids", ",", "mrcnn_mask_logits", ")", "\n", "if", "stage", "==", "'finetune'", ":", "\n", "        ", "mrcnn_mask_edge_loss", "=", "compute_mrcnn_mask_edge_loss", "(", "target_mask", ",", "target_class_ids", ",", "mrcnn_mask", ")", "\n", "", "else", ":", "\n", "        ", "mrcnn_mask_edge_loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", ".", "cuda", "(", ")", "\n", "\n", "", "return", "[", "rpn_class_loss", ",", "rpn_bbox_loss", ",", "mrcnn_class_loss", ",", "mrcnn_bbox_loss", ",", "mrcnn_mask_loss", ",", "mrcnn_mask_edge_loss", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.load_image_gt": [[1007, 1088], ["iaa.Affine", "np.expand_dims.transpose", "mask.astype.transpose", "utils.extract_bboxes", "numpy.floor", "numpy.ceil", "numpy.floor", "numpy.ceil", "numpy.floor", "numpy.ceil", "numpy.tile", "dataset.process_mask", "model.build_rpn_targets", "model.mold_image", "numpy.squeeze", "iaa.Affine.to_deterministic", "augment.to_deterministic.augment_image", "augment.to_deterministic.augment_image", "numpy.expand_dims", "mask.astype.astype", "numpy.expand_dims", "max", "min", "max", "min", "max", "min", "np.tile.astype", "numpy.array", "np.expand_dims.astype", "mask.astype.astype", "imgaug.HooksImages"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.extract_bboxes", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.process_mask", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.build_rpn_targets", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.mold_image"], ["", "def", "load_image_gt", "(", "image", ",", "mask", ",", "angle", ",", "dataset", ",", "config", ",", "anchors", ")", ":", "\n", "    ", "\"\"\"Load and return ground truth data for an image.\n    angle: rotate the image and mask for augmentation\n    anchors: used for generate rpn_match and rpn_bbox\n    Returns:\n    image: [1, depth, height, width]\n    class_ids: [instance_count] Integer class IDs\n    bbox: [instance_count, (z1, y1, x1, z2, y2, x2)]\n    mask: [depth, height, width, instance_count]\n    rpn_match: [batch, N] Integer (1=positive anchor, -1=negative, 0=neutral)\n    rpn_bbox: [batch, N, (dz, dy, dx, log(dd), log(dh), log(dw))] Anchor bbox deltas\n    \"\"\"", "\n", "# Augmentation", "\n", "import", "imgaug", "\n", "from", "imgaug", "import", "augmenters", "as", "iaa", "\n", "augment", "=", "iaa", ".", "Affine", "(", "rotate", "=", "angle", ",", "order", "=", "0", ")", "# randomly rotate the image between -20 degree and 20 degree", "\n", "if", "augment", "is", "not", "None", ":", "\n", "# Augmenters that are safe to apply to masks", "\n", "# Some, such as Affine, have settings that make them unsafe, so always", "\n", "# test your augmentation on masks", "\n", "        ", "MASK_AUGMENTERS", "=", "[", "\"Sequential\"", ",", "\"SomeOf\"", ",", "\"OneOf\"", ",", "\"Sometimes\"", ",", "\n", "\"Fliplr\"", ",", "\"Flipud\"", ",", "\"CropAndPad\"", ",", "\n", "\"Affine\"", ",", "\"PiecewiseAffine\"", "]", "\n", "\n", "def", "hook", "(", "images", ",", "augmenter", ",", "parents", ",", "default", ")", ":", "\n", "            ", "\"\"\"Determines which augmenters to apply to masks.\"\"\"", "\n", "return", "augmenter", ".", "__class__", ".", "__name__", "in", "MASK_AUGMENTERS", "\n", "\n", "# Store shapes before augmentation to compare", "\n", "", "image_shape", "=", "image", ".", "shape", "\n", "mask_shape", "=", "mask", ".", "shape", "\n", "# Reshape the image to [height, width, depth] so that we can implement imgaug on it.", "\n", "# Regard every [height, width, 1] of the image as an image and do imgaug on it.", "\n", "image", "=", "np", ".", "squeeze", "(", "image", ",", "3", ")", "\n", "# Make augmenters deterministic to apply similarly to images and masks", "\n", "det", "=", "augment", ".", "to_deterministic", "(", ")", "\n", "image", "=", "det", ".", "augment_image", "(", "image", ")", "\n", "mask", "=", "det", ".", "augment_image", "(", "mask", ".", "astype", "(", "np", ".", "uint8", ")", ",", "\n", "hooks", "=", "imgaug", ".", "HooksImages", "(", "activator", "=", "hook", ")", ")", "\n", "# Reshape the image back to [height, width, length, 1]", "\n", "image", "=", "np", ".", "expand_dims", "(", "image", ",", "-", "1", ")", "\n", "# Verify that shapes didn't change", "\n", "assert", "image", ".", "shape", "==", "image_shape", ",", "\"Augmentation shouldn't change image size\"", "\n", "assert", "mask", ".", "shape", "==", "mask_shape", ",", "\"Augmentation shouldn't change mask size\"", "\n", "# Change mask back to np.int32", "\n", "mask", "=", "mask", ".", "astype", "(", "np", ".", "int32", ")", "\n", "# Transpose the image and mask to the correct shape.", "\n", "# After transpose, image: [C, D, H, W], mask: [D, H, W, C]", "\n", "", "image", "=", "image", ".", "transpose", "(", "(", "3", ",", "2", ",", "0", ",", "1", ")", ")", "\n", "mask", "=", "mask", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "# Bounding boxes: [num_instances, (z1, y1, x1, z2, y2, x2)]", "\n", "bbox", "=", "utils", ".", "extract_bboxes", "(", "np", ".", "expand_dims", "(", "mask", ",", "-", "1", ")", ")", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "bbox", "[", "0", ",", ":", "]", "\n", "depth", "=", "z2", "-", "z1", "\n", "height", "=", "y2", "-", "y1", "\n", "width", "=", "x2", "-", "x1", "\n", "z1", "-=", "depth", "*", "0.05", "\n", "z2", "+=", "depth", "*", "0.05", "\n", "y1", "-=", "height", "*", "0.05", "\n", "y2", "+=", "height", "*", "0.05", "\n", "x1", "-=", "width", "*", "0.05", "\n", "x2", "+=", "width", "*", "0.05", "\n", "z1", "=", "np", ".", "floor", "(", "max", "(", "0", ",", "z1", ")", ")", "\n", "z2", "=", "np", ".", "ceil", "(", "min", "(", "mask", ".", "shape", "[", "0", "]", ",", "z2", ")", ")", "\n", "y1", "=", "np", ".", "floor", "(", "max", "(", "0", ",", "y1", ")", ")", "\n", "y2", "=", "np", ".", "ceil", "(", "min", "(", "mask", ".", "shape", "[", "1", "]", ",", "y2", ")", ")", "\n", "x1", "=", "np", ".", "floor", "(", "max", "(", "0", ",", "x1", ")", ")", "\n", "x2", "=", "np", ".", "ceil", "(", "min", "(", "mask", ".", "shape", "[", "2", "]", ",", "x2", ")", ")", "\n", "bbox", "[", "0", ",", ":", "]", "=", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "\n", "bbox", "=", "np", ".", "tile", "(", "bbox", ".", "astype", "(", "np", ".", "int32", ")", ",", "(", "config", ".", "NUM_CLASSES", "-", "1", ",", "1", ")", ")", "\n", "# Get the whole-heart mask, instance-specific masks and class_ids.", "\n", "masks", ",", "class_ids", "=", "dataset", ".", "process_mask", "(", "mask", ")", "\n", "\n", "# RPN Targets", "\n", "rpn_match", ",", "rpn_bbox", "=", "build_rpn_targets", "(", "anchors", ",", "np", ".", "array", "(", "[", "bbox", "[", "0", "]", "]", ")", ",", "config", ")", "\n", "\n", "# Add to batch", "\n", "rpn_match", "=", "rpn_match", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "image", "=", "mold_image", "(", "image", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "return", "image", ",", "rpn_match", ",", "rpn_bbox", ",", "class_ids", ",", "bbox", ",", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.build_rpn_targets": [[1090, 1182], ["numpy.zeros", "numpy.zeros", "utils.compute_overlaps", "numpy.argmax", "numpy.argmax", "zip", "numpy.where", "len", "numpy.random.choice", "numpy.where", "len", "numpy.random.choice", "numpy.where", "numpy.sum", "numpy.log", "numpy.log", "numpy.log", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_overlaps", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log"], ["", "def", "build_rpn_targets", "(", "anchors", ",", "gt_boxes", ",", "config", ")", ":", "\n", "    ", "\"\"\"Given the anchors and GT boxes, compute overlaps and identify positive\n    anchors and deltas to refine them to match their corresponding GT boxes.\n    anchors: [num_anchors, (z1, y1, x1, z2, y2, x2)]\n    gt_class_ids: [num_gt_boxes] Integer class IDs.\n    gt_boxes: [num_gt_boxes, (z1, y1, x1, z2, y2, x2)]\n    Returns:\n    rpn_match: [N] (int32) matches between anchors and GT boxes.\n               1 = positive anchor, -1 = negative anchor, 0 = neutral\n    rpn_bbox: [N, (dz, dy, dx, log(dd), log(dh), log(dw))] Anchor bbox deltas.\n    \"\"\"", "\n", "# RPN Match: 1 = positive anchor, -1 = negative anchor, 0 = neutral", "\n", "rpn_match", "=", "np", ".", "zeros", "(", "[", "anchors", ".", "shape", "[", "0", "]", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "# RPN bounding boxes: [max anchors per image, (dz, dy, dx, log(dd), log(dh), log(dw))]", "\n", "rpn_bbox", "=", "np", ".", "zeros", "(", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", ",", "6", ")", ")", "\n", "# Compute overlaps [num_anchors, num_gt_boxes]", "\n", "overlaps", "=", "utils", ".", "compute_overlaps", "(", "anchors", ",", "gt_boxes", ")", "\n", "\n", "# Match anchors to GT Boxes", "\n", "# If an anchor overlaps a GT box with IoU >= 0.7 then it's positive.", "\n", "# If an anchor overlaps a GT box with IoU < 0.3 then it's negative.", "\n", "# Neutral anchors are those that don't match the conditions above, and they don't influence the loss function.", "\n", "# However, don't keep any GT box unmatched (rare, but happens).", "\n", "# Instead, match it to the closest anchor (even if its max IoU is < 0.3).", "\n", "\n", "# 1. Set negative anchors first. They get overwritten below if a GT box is", "\n", "# matched to them. Skip boxes in crowd areas.", "\n", "anchor_iou_argmax", "=", "np", ".", "argmax", "(", "overlaps", ",", "axis", "=", "1", ")", "\n", "anchor_iou_max", "=", "overlaps", "[", "np", ".", "arange", "(", "overlaps", ".", "shape", "[", "0", "]", ")", ",", "anchor_iou_argmax", "]", "\n", "rpn_match", "[", "anchor_iou_max", "<", "0.3", "]", "=", "-", "1", "\n", "\n", "# 2. Set an anchor for each GT box (regardless of IoU value).", "\n", "gt_iou_argmax", "=", "np", ".", "argmax", "(", "overlaps", ",", "axis", "=", "0", ")", "\n", "rpn_match", "[", "gt_iou_argmax", "]", "=", "1", "\n", "\n", "# 3. Set anchors with high overlap as positive.", "\n", "rpn_match", "[", "anchor_iou_max", ">=", "0.7", "]", "=", "1", "\n", "\n", "# Subsample to balance positive and negative anchors", "\n", "# Don't let positives be more than half the anchors", "\n", "ids", "=", "np", ".", "where", "(", "rpn_match", "==", "1", ")", "[", "0", "]", "\n", "extra", "=", "len", "(", "ids", ")", "-", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", "//", "2", ")", "\n", "if", "extra", ">", "0", ":", "\n", "# Reset the extra ones to neutral", "\n", "        ", "ids", "=", "np", ".", "random", ".", "choice", "(", "ids", ",", "extra", ",", "replace", "=", "False", ")", "\n", "rpn_match", "[", "ids", "]", "=", "0", "\n", "# Same for negative proposals", "\n", "", "ids", "=", "np", ".", "where", "(", "rpn_match", "==", "-", "1", ")", "[", "0", "]", "\n", "extra", "=", "len", "(", "ids", ")", "-", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", "-", "\n", "np", ".", "sum", "(", "rpn_match", "==", "1", ")", ")", "\n", "if", "extra", ">", "0", ":", "\n", "# Rest the extra ones to neutral", "\n", "        ", "ids", "=", "np", ".", "random", ".", "choice", "(", "ids", ",", "extra", ",", "replace", "=", "False", ")", "\n", "rpn_match", "[", "ids", "]", "=", "0", "\n", "\n", "# For positive anchors, compute shift and scale needed to transform them to match the corresponding GT boxes.", "\n", "", "ids", "=", "np", ".", "where", "(", "rpn_match", "==", "1", ")", "[", "0", "]", "\n", "ix", "=", "0", "# index into rpn_bbox", "\n", "for", "i", ",", "a", "in", "zip", "(", "ids", ",", "anchors", "[", "ids", "]", ")", ":", "\n", "# Closest gt box (it might have IoU < 0.7)", "\n", "        ", "gt", "=", "gt_boxes", "[", "anchor_iou_argmax", "[", "i", "]", "]", "\n", "\n", "# Convert coordinates to center plus width/height.", "\n", "# GT Box", "\n", "gt_d", "=", "gt", "[", "3", "]", "-", "gt", "[", "0", "]", "\n", "gt_h", "=", "gt", "[", "4", "]", "-", "gt", "[", "1", "]", "\n", "gt_w", "=", "gt", "[", "5", "]", "-", "gt", "[", "2", "]", "\n", "gt_center_z", "=", "gt", "[", "0", "]", "+", "0.5", "*", "gt_d", "\n", "gt_center_y", "=", "gt", "[", "1", "]", "+", "0.5", "*", "gt_h", "\n", "gt_center_x", "=", "gt", "[", "2", "]", "+", "0.5", "*", "gt_w", "\n", "# Anchor", "\n", "a_d", "=", "a", "[", "3", "]", "-", "a", "[", "0", "]", "\n", "a_h", "=", "a", "[", "4", "]", "-", "a", "[", "1", "]", "\n", "a_w", "=", "a", "[", "5", "]", "-", "a", "[", "2", "]", "\n", "a_center_z", "=", "a", "[", "0", "]", "+", "0.5", "*", "a_d", "\n", "a_center_y", "=", "a", "[", "1", "]", "+", "0.5", "*", "a_h", "\n", "a_center_x", "=", "a", "[", "2", "]", "+", "0.5", "*", "a_w", "\n", "\n", "# Compute the bbox refinement that the RPN should predict.", "\n", "rpn_bbox", "[", "ix", "]", "=", "[", "\n", "(", "gt_center_z", "-", "a_center_z", ")", "/", "a_d", ",", "\n", "(", "gt_center_y", "-", "a_center_y", ")", "/", "a_h", ",", "\n", "(", "gt_center_x", "-", "a_center_x", ")", "/", "a_w", ",", "\n", "np", ".", "log", "(", "gt_d", "/", "a_d", ")", ",", "\n", "np", ".", "log", "(", "gt_h", "/", "a_h", ")", ",", "\n", "np", ".", "log", "(", "gt_w", "/", "a_w", ")", ",", "\n", "]", "\n", "# Normalize", "\n", "rpn_bbox", "[", "ix", "]", "/=", "config", ".", "RPN_BBOX_STD_DEV", "\n", "ix", "+=", "1", "\n", "\n", "", "return", "rpn_match", ",", "rpn_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.compose_image_meta": [[1871, 1889], ["numpy.array", "list", "list", "list"], "function", ["None"], ["", "", "def", "compose_image_meta", "(", "image_id", ",", "image_shape", ",", "window", ",", "active_class_ids", ")", ":", "\n", "    ", "\"\"\"Takes attributes of an image and puts them in one 1D array. Use\n    parse_image_meta() to parse the values back.\n    image_id: An int ID of the image. Useful for debugging.\n    image_shape: [channels, depth, height, width]\n    window: (z1, y1, x1, z2, y2, x2) in pixels. The volume of the image where the real\n            image is (excluding the padding)\n    active_class_ids: List of class_ids available in the dataset from which\n        the image came. Useful if training on images from multiple datasets\n        where not all classes are present in all datasets.\n    \"\"\"", "\n", "meta", "=", "np", ".", "array", "(", "\n", "[", "image_id", "]", "+", "# size = 1", "\n", "list", "(", "image_shape", ")", "+", "# size = 4", "\n", "list", "(", "window", ")", "+", "# size = 6: (z1, y1, x1, z2, y2, x2) in image coordinates", "\n", "list", "(", "active_class_ids", ")", "# size = num_classes", "\n", ")", "\n", "return", "meta", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.parse_image_meta": [[1891, 1900], ["None"], "function", ["None"], ["", "def", "parse_image_meta", "(", "meta", ")", ":", "\n", "    ", "\"\"\"Parses an image info Numpy array to its components.\n    See compose_image_meta() for more details.\n    \"\"\"", "\n", "image_id", "=", "meta", "[", ":", ",", "0", "]", "\n", "image_shape", "=", "meta", "[", ":", ",", "1", ":", "5", "]", "\n", "window", "=", "meta", "[", ":", ",", "5", ":", "11", "]", "# (z1, y1, x1, z2, y2, x2) window of image in in pixels", "\n", "active_class_ids", "=", "meta", "[", ":", ",", "11", ":", "]", "\n", "return", "image_id", ",", "image_shape", ",", "window", ",", "active_class_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.model.mold_image": [[1902, 1905], ["images.std", "images.mean"], "function", ["None"], ["", "def", "mold_image", "(", "images", ")", ":", "\n", "    ", "\"\"\"Normalize the input image to set its mean = 0 and std = 1.\"\"\"", "\n", "return", "(", "images", "-", "images", ".", "mean", "(", ")", ")", "/", "images", ".", "std", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.__init__": [[197, 203], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "class_map", "=", "None", ")", ":", "\n", "        ", "self", ".", "_image_ids", "=", "[", "]", "\n", "self", ".", "image_info", "=", "[", "]", "\n", "# Background is always the first class", "\n", "self", ".", "class_info", "=", "[", "{", "\"source\"", ":", "\"\"", ",", "\"id\"", ":", "0", ",", "\"name\"", ":", "\"BG\"", "}", "]", "\n", "self", ".", "source_class_ids", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.add_class": [[204, 216], ["utils.Dataset.class_info.append"], "methods", ["None"], ["", "def", "add_class", "(", "self", ",", "source", ",", "class_id", ",", "class_name", ")", ":", "\n", "        ", "assert", "\".\"", "not", "in", "source", ",", "\"Source name cannot contain a dot\"", "\n", "# Does the class exist already?", "\n", "for", "info", "in", "self", ".", "class_info", ":", "\n", "            ", "if", "info", "[", "'source'", "]", "==", "source", "and", "info", "[", "\"id\"", "]", "==", "class_id", ":", "\n", "# source.class_id combination already available, skip", "\n", "                ", "return", "\n", "# Add the class", "\n", "", "", "self", ".", "class_info", ".", "append", "(", "{", "\n", "\"source\"", ":", "source", ",", "\n", "\"id\"", ":", "class_id", ",", "\n", "\"name\"", ":", "class_name", ",", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.add_image": [[218, 226], ["image_info.update", "utils.Dataset.image_info.append"], "methods", ["None"], ["", "def", "add_image", "(", "self", ",", "source", ",", "image_id", ",", "path", ",", "**", "kwargs", ")", ":", "\n", "        ", "image_info", "=", "{", "\n", "\"id\"", ":", "image_id", ",", "\n", "\"source\"", ":", "source", ",", "\n", "\"path\"", ":", "path", ",", "\n", "}", "\n", "image_info", ".", "update", "(", "kwargs", ")", "\n", "self", ".", "image_info", ".", "append", "(", "image_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.image_reference": [[227, 235], ["None"], "methods", ["None"], ["", "def", "image_reference", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Return a link to the image in its source Website or details about\n        the image that help looking it up or debugging it.\n\n        Override for your dataset, but pass to this function\n        if you encounter images not in your dataset.\n        \"\"\"", "\n", "return", "\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.prepare": [[236, 267], ["len", "numpy.arange", "len", "numpy.arange", "list", "utils.Dataset.prepare.clean_name"], "methods", ["None"], ["", "def", "prepare", "(", "self", ",", "class_map", "=", "None", ")", ":", "\n", "        ", "\"\"\"Prepares the Dataset class for use.\n\n        TODO: class map is not supported yet. When done, it should handle mapping\n              classes from different datasets to the same class ID.\n        \"\"\"", "\n", "def", "clean_name", "(", "name", ")", ":", "\n", "            ", "\"\"\"Returns a shorter version of object names for cleaner display.\"\"\"", "\n", "return", "\",\"", ".", "join", "(", "name", ".", "split", "(", "\",\"", ")", "[", ":", "1", "]", ")", "\n", "\n", "# Build (or rebuild) everything else from the info dicts.", "\n", "", "self", ".", "num_classes", "=", "len", "(", "self", ".", "class_info", ")", "\n", "self", ".", "class_ids", "=", "np", ".", "arange", "(", "self", ".", "num_classes", ")", "\n", "self", ".", "class_names", "=", "[", "clean_name", "(", "c", "[", "\"name\"", "]", ")", "for", "c", "in", "self", ".", "class_info", "]", "\n", "self", ".", "num_images", "=", "len", "(", "self", ".", "image_info", ")", "\n", "self", ".", "_image_ids", "=", "np", ".", "arange", "(", "self", ".", "num_images", ")", "\n", "\n", "self", ".", "class_from_source_map", "=", "{", "\"{}.{}\"", ".", "format", "(", "info", "[", "'source'", "]", ",", "info", "[", "'id'", "]", ")", ":", "id", "\n", "for", "info", ",", "id", "in", "zip", "(", "self", ".", "class_info", ",", "self", ".", "class_ids", ")", "}", "\n", "\n", "# Map sources to class_ids they support", "\n", "self", ".", "sources", "=", "list", "(", "set", "(", "[", "i", "[", "'source'", "]", "for", "i", "in", "self", ".", "class_info", "]", ")", ")", "\n", "self", ".", "source_class_ids", "=", "{", "}", "\n", "# Loop over datasets", "\n", "for", "source", "in", "self", ".", "sources", ":", "\n", "            ", "self", ".", "source_class_ids", "[", "source", "]", "=", "[", "]", "\n", "# Find classes that belong to this dataset", "\n", "for", "i", ",", "info", "in", "enumerate", "(", "self", ".", "class_info", ")", ":", "\n", "# Include BG class in all datasets", "\n", "                ", "if", "i", "==", "0", "or", "source", "==", "info", "[", "'source'", "]", ":", "\n", "                    ", "self", ".", "source_class_ids", "[", "source", "]", ".", "append", "(", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.map_source_class_id": [[268, 275], ["None"], "methods", ["None"], ["", "", "", "", "def", "map_source_class_id", "(", "self", ",", "source_class_id", ")", ":", "\n", "        ", "\"\"\"Takes a source class ID and returns the int class ID assigned to it.\n\n        For example:\n        dataset.map_source_class_id(\"coco.12\") -> 23\n        \"\"\"", "\n", "return", "self", ".", "class_from_source_map", "[", "source_class_id", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.get_source_class_id": [[276, 281], ["None"], "methods", ["None"], ["", "def", "get_source_class_id", "(", "self", ",", "class_id", ",", "source", ")", ":", "\n", "        ", "\"\"\"Map an internal class ID to the corresponding class ID in the source dataset.\"\"\"", "\n", "info", "=", "self", ".", "class_info", "[", "class_id", "]", "\n", "assert", "info", "[", "'source'", "]", "==", "source", "\n", "return", "info", "[", "'id'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.append_data": [[282, 292], ["enumerate", "enumerate", "str", "str"], "methods", ["None"], ["", "def", "append_data", "(", "self", ",", "class_info", ",", "image_info", ")", ":", "\n", "        ", "self", ".", "external_to_class_id", "=", "{", "}", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "self", ".", "class_info", ")", ":", "\n", "            ", "for", "ds", ",", "id", "in", "c", "[", "\"map\"", "]", ":", "\n", "                ", "self", ".", "external_to_class_id", "[", "ds", "+", "str", "(", "id", ")", "]", "=", "i", "\n", "\n", "# Map external image IDs to internal ones.", "\n", "", "", "self", ".", "external_to_image_id", "=", "{", "}", "\n", "for", "i", ",", "info", "in", "enumerate", "(", "self", ".", "image_info", ")", ":", "\n", "            ", "self", ".", "external_to_image_id", "[", "info", "[", "\"ds\"", "]", "+", "str", "(", "info", "[", "\"id\"", "]", ")", "]", "=", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.image_ids": [[293, 296], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "image_ids", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_image_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.source_image_link": [[297, 303], ["None"], "methods", ["None"], ["", "def", "source_image_link", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Returns the path or URL to the image.\n        Override this to return a URL to the image if it's available online for easy\n        debugging.\n        \"\"\"", "\n", "return", "self", ".", "image_info", "[", "image_id", "]", "[", "\"path\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.load_image": [[304, 309], ["nibabel.load().get_data().copy", "numpy.expand_dims", "nibabel.load().get_data", "nibabel.load"], "methods", ["None"], ["", "def", "load_image", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified image and return a [H, W, D, 1] Numpy array.\"\"\"", "\n", "# Load image", "\n", "image", "=", "nib", ".", "load", "(", "self", ".", "image_info", "[", "image_id", "]", "[", "'path'", "]", ")", ".", "get_data", "(", ")", ".", "copy", "(", ")", "\n", "return", "np", ".", "expand_dims", "(", "image", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.Dataset.load_mask": [[310, 316], ["numpy.empty"], "methods", ["None"], ["", "def", "load_mask", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified mask and return a [H, W, D] Numpy array.\"\"\"", "\n", "# Override this function to load a mask from your dataset.", "\n", "# Otherwise, it returns an empty mask.", "\n", "mask", "=", "np", ".", "empty", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.extract_bboxes": [[20, 48], ["numpy.zeros", "range", "np.zeros.astype", "numpy.where", "ix[].min", "ix[].max", "ix[].min", "ix[].max", "numpy.where", "ix[].min", "ix[].max", "numpy.array", "numpy.sum", "numpy.sum"], "function", ["None"], ["def", "extract_bboxes", "(", "mask", ")", ":", "\n", "    ", "\"\"\"Compute bounding boxes from masks.\n    mask: [depth, height, width, num_instances]. Mask pixels are either 1 or 0.\n\n    Returns: bbox array [num_instances, (z1, y1, x1, z2, y2, x2)].\n    \"\"\"", "\n", "boxes", "=", "np", ".", "zeros", "(", "[", "mask", ".", "shape", "[", "-", "1", "]", ",", "6", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "# Bounding box.", "\n", "        ", "ix", "=", "np", ".", "where", "(", "np", ".", "sum", "(", "mask", ",", "axis", "=", "2", ")", ">", "0", ")", "\n", "z1", "=", "ix", "[", "0", "]", ".", "min", "(", ")", "\n", "z2", "=", "ix", "[", "0", "]", ".", "max", "(", ")", "\n", "y1", "=", "ix", "[", "1", "]", ".", "min", "(", ")", "\n", "y2", "=", "ix", "[", "1", "]", ".", "max", "(", ")", "\n", "ix", "=", "np", ".", "where", "(", "np", ".", "sum", "(", "mask", ",", "axis", "=", "0", ")", ">", "0", ")", "\n", "x1", "=", "ix", "[", "1", "]", ".", "min", "(", ")", "\n", "x2", "=", "ix", "[", "1", "]", ".", "max", "(", ")", "\n", "# x2, y2 and z2 should not be part of the box. Increment by 1.", "\n", "if", "z1", "!=", "z2", ":", "\n", "            ", "z2", "+=", "1", "\n", "x2", "+=", "1", "\n", "y2", "+=", "1", "\n", "", "else", ":", "\n", "# No mask for this instance. Might happen due to", "\n", "# resizing or cropping. Set bbox to zeros", "\n", "            ", "x1", ",", "x2", ",", "y1", ",", "y2", ",", "z1", ",", "z2", "=", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "\n", "", "boxes", "[", "i", "]", "=", "np", ".", "array", "(", "[", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "]", ")", "\n", "", "return", "boxes", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.compute_iou": [[50, 71], ["numpy.maximum", "numpy.minimum", "numpy.maximum", "numpy.minimum", "numpy.maximum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["", "def", "compute_iou", "(", "box", ",", "boxes", ",", "box_volume", ",", "boxes_volume", ")", ":", "\n", "    ", "\"\"\"Calculates IoU of the given box with the array of the given boxes.\n    box: 1D vector [z1, y1, x1, z2, y2, x2]\n    boxes: [boxes_count, (z1, y1, x1, z2, y2, x2)]\n    box_volume: float. the volume of 'box'\n    boxes_volume: array of depth boxes_count.\n\n    Note: the volumes are passed in rather than calculated here for\n          efficiency. Calculate once in the caller to avoid duplicate work.\n    \"\"\"", "\n", "# Calculate intersection volumes", "\n", "z1", "=", "np", ".", "maximum", "(", "box", "[", "0", "]", ",", "boxes", "[", ":", ",", "0", "]", ")", "\n", "z2", "=", "np", ".", "minimum", "(", "box", "[", "3", "]", ",", "boxes", "[", ":", ",", "3", "]", ")", "\n", "y1", "=", "np", ".", "maximum", "(", "box", "[", "1", "]", ",", "boxes", "[", ":", ",", "1", "]", ")", "\n", "y2", "=", "np", ".", "minimum", "(", "box", "[", "4", "]", ",", "boxes", "[", ":", ",", "4", "]", ")", "\n", "x1", "=", "np", ".", "maximum", "(", "box", "[", "2", "]", ",", "boxes", "[", ":", ",", "2", "]", ")", "\n", "x2", "=", "np", ".", "minimum", "(", "box", "[", "5", "]", ",", "boxes", "[", ":", ",", "5", "]", ")", "\n", "intersection", "=", "np", ".", "maximum", "(", "x2", "-", "x1", ",", "0", ")", "*", "np", ".", "maximum", "(", "y2", "-", "y1", ",", "0", ")", "*", "np", ".", "maximum", "(", "z2", "-", "z1", ",", "0", ")", "\n", "union", "=", "box_volume", "+", "boxes_volume", "[", ":", "]", "-", "intersection", "[", ":", "]", "\n", "iou", "=", "intersection", "/", "(", "union", "+", "1e-6", ")", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.compute_overlaps": [[73, 90], ["numpy.zeros", "range", "utils.compute_iou"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_iou"], ["", "def", "compute_overlaps", "(", "boxes1", ",", "boxes2", ")", ":", "\n", "    ", "\"\"\"Computes IoU overlaps between two sets of boxes.\n    boxes1, boxes2: [N, (z1, y1, x1, z2, y2, x2)].\n\n    For better performance, pass the largest set first and the smaller second.\n    \"\"\"", "\n", "# volumes of anchors and GT boxes", "\n", "volume1", "=", "(", "boxes1", "[", ":", ",", "3", "]", "-", "boxes1", "[", ":", ",", "0", "]", ")", "*", "(", "boxes1", "[", ":", ",", "4", "]", "-", "boxes1", "[", ":", ",", "1", "]", ")", "*", "(", "boxes1", "[", ":", ",", "5", "]", "-", "boxes1", "[", ":", ",", "2", "]", ")", "\n", "volume2", "=", "(", "boxes2", "[", ":", ",", "3", "]", "-", "boxes2", "[", ":", ",", "0", "]", ")", "*", "(", "boxes2", "[", ":", ",", "4", "]", "-", "boxes2", "[", ":", ",", "1", "]", ")", "*", "(", "boxes2", "[", ":", ",", "5", "]", "-", "boxes2", "[", ":", ",", "2", "]", ")", "\n", "\n", "# Compute overlaps to generate matrix [boxes1 count, boxes2 count]", "\n", "# Each cell contains the IoU value.", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "boxes1", ".", "shape", "[", "0", "]", ",", "boxes2", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "overlaps", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "box2", "=", "boxes2", "[", "i", "]", "\n", "overlaps", "[", ":", ",", "i", "]", "=", "compute_iou", "(", "box2", ",", "boxes1", ",", "volume2", "[", "i", "]", ",", "volume1", ")", "\n", "", "return", "overlaps", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.box_refinement": [[92, 120], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.stack", "torch.stack"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log"], ["", "def", "box_refinement", "(", "box", ",", "gt_box", ")", ":", "\n", "    ", "\"\"\"Compute refinement needed to transform box to gt_box.\n    box and gt_box are [N, (z1, y1, x1, z2, y2, x2)]\n    \"\"\"", "\n", "\n", "depth", "=", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "0", "]", "\n", "height", "=", "box", "[", ":", ",", "4", "]", "-", "box", "[", ":", ",", "1", "]", "\n", "width", "=", "box", "[", ":", ",", "5", "]", "-", "box", "[", ":", ",", "2", "]", "\n", "center_z", "=", "box", "[", ":", ",", "0", "]", "+", "0.5", "*", "depth", "\n", "center_y", "=", "box", "[", ":", ",", "1", "]", "+", "0.5", "*", "height", "\n", "center_x", "=", "box", "[", ":", ",", "2", "]", "+", "0.5", "*", "width", "\n", "\n", "gt_depth", "=", "gt_box", "[", ":", ",", "3", "]", "-", "gt_box", "[", ":", ",", "0", "]", "\n", "gt_height", "=", "gt_box", "[", ":", ",", "4", "]", "-", "gt_box", "[", ":", ",", "1", "]", "\n", "gt_width", "=", "gt_box", "[", ":", ",", "5", "]", "-", "gt_box", "[", ":", ",", "2", "]", "\n", "gt_center_z", "=", "gt_box", "[", ":", ",", "0", "]", "+", "0.5", "*", "gt_depth", "\n", "gt_center_y", "=", "gt_box", "[", ":", ",", "1", "]", "+", "0.5", "*", "gt_height", "\n", "gt_center_x", "=", "gt_box", "[", ":", ",", "2", "]", "+", "0.5", "*", "gt_width", "\n", "\n", "dz", "=", "(", "gt_center_z", "-", "center_z", ")", "/", "depth", "\n", "dy", "=", "(", "gt_center_y", "-", "center_y", ")", "/", "height", "\n", "dx", "=", "(", "gt_center_x", "-", "center_x", ")", "/", "width", "\n", "dd", "=", "torch", ".", "log", "(", "gt_depth", "/", "depth", ")", "\n", "dh", "=", "torch", ".", "log", "(", "gt_height", "/", "height", ")", "\n", "dw", "=", "torch", ".", "log", "(", "gt_width", "/", "width", ")", "\n", "\n", "result", "=", "torch", ".", "stack", "(", "[", "dz", ",", "dy", ",", "dx", ",", "dd", ",", "dh", ",", "dw", "]", ",", "dim", "=", "1", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.non_max_suppression": [[122, 158], ["numpy.array", "scores.argsort", "len", "pick.append", "utils.compute_iou", "numpy.delete", "numpy.delete", "len", "numpy.where"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_iou"], ["", "def", "non_max_suppression", "(", "boxes", ",", "scores", ",", "threshold", ",", "max_num", ")", ":", "\n", "    ", "\"\"\"Performs non-maximum suppression and returns indices of kept boxes.\n    boxes: [N, (z1, y1, x1, z2, y2, x2)]. Notice that (z2, y2, x2) lays outside the box.\n    scores: 1-D array of box scores.\n    threshold: Float. IoU threshold to use for filtering.\n    max_num: Int. The max number of boxes to keep.\n    Return the index of boxes to keep.\n    \"\"\"", "\n", "# Compute box volumes", "\n", "z1", "=", "boxes", "[", ":", ",", "0", "]", "\n", "y1", "=", "boxes", "[", ":", ",", "1", "]", "\n", "x1", "=", "boxes", "[", ":", ",", "2", "]", "\n", "z2", "=", "boxes", "[", ":", ",", "3", "]", "\n", "y2", "=", "boxes", "[", ":", ",", "4", "]", "\n", "x2", "=", "boxes", "[", ":", ",", "5", "]", "\n", "volume", "=", "(", "z2", "-", "z1", ")", "*", "(", "y2", "-", "y1", ")", "*", "(", "x2", "-", "x1", ")", "\n", "\n", "# Get indices of boxes sorted by scores (highest first)", "\n", "ixs", "=", "scores", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "pick", "=", "[", "]", "\n", "while", "len", "(", "ixs", ")", ">", "0", ":", "\n", "# Pick top box and add its index to the list", "\n", "        ", "i", "=", "ixs", "[", "0", "]", "\n", "pick", ".", "append", "(", "i", ")", "\n", "if", "len", "(", "pick", ")", ">=", "max_num", ":", "\n", "            ", "break", "\n", "# Compute IoU of the picked box with the rest", "\n", "", "iou", "=", "compute_iou", "(", "boxes", "[", "i", "]", ",", "boxes", "[", "ixs", "[", "1", ":", "]", "]", ",", "volume", "[", "i", "]", ",", "volume", "[", "ixs", "[", "1", ":", "]", "]", ")", "\n", "# Identify boxes with IoU over the threshold. This returns indices into ixs[1:],", "\n", "# so add 1 to get indices into ixs.", "\n", "remove_ixs", "=", "np", ".", "where", "(", "iou", ">", "threshold", ")", "[", "0", "]", "+", "1", "\n", "# Remove indices of the picked and overlapped boxes.", "\n", "ixs", "=", "np", ".", "delete", "(", "ixs", ",", "remove_ixs", ")", "\n", "ixs", "=", "np", ".", "delete", "(", "ixs", ",", "0", ")", "\n", "", "return", "np", ".", "array", "(", "pick", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.denorm_boxes_graph": [[160, 175], ["torch.Tensor().cuda", "torch.Tensor().cuda", "torch.mul", "torch.mul", "torch.Tensor", "torch.Tensor"], "function", ["None"], ["", "def", "denorm_boxes_graph", "(", "boxes", ",", "size", ")", ":", "\n", "    ", "\"\"\"Converts boxes from normalized coordinates to pixel coordinates.\n    boxes: [..., (z1, y1, x1, z2, y2, x2)] in normalized coordinates\n    size: [depth, height, width], the size to denorm to.\n\n    Note: In pixel coordinates (z2, y2, x2) is outside the box.\n          But in normalized coordinates it's inside the box.\n\n    Returns:\n        [..., (z1, y1, x1, z2, y2, x2)] in pixel coordinates\n    \"\"\"", "\n", "d", ",", "h", ",", "w", "=", "size", "\n", "scale", "=", "torch", ".", "Tensor", "(", "[", "d", ",", "h", ",", "w", ",", "d", ",", "h", ",", "w", "]", ")", ".", "cuda", "(", ")", "\n", "denorm_boxes", "=", "torch", ".", "mul", "(", "boxes", ",", "scale", ")", "\n", "return", "denorm_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize": [[318, 340], ["distutils.version.LooseVersion", "distutils.version.LooseVersion", "skimage.transform.resize", "skimage.transform.resize"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["", "", "def", "resize", "(", "image", ",", "output_shape", ",", "order", "=", "1", ",", "mode", "=", "'constant'", ",", "cval", "=", "0", ",", "clip", "=", "True", ",", "\n", "preserve_range", "=", "True", ",", "anti_aliasing", "=", "False", ",", "anti_aliasing_sigma", "=", "None", ")", ":", "\n", "    ", "\"\"\"A wrapper for Scikit-Image resize().\n\n    Scikit-Image generates warnings on every call to resize() if it doesn't\n    receive the right parameters. The right parameters depend on the version\n    of skimage. This solves the problem by using different parameters per\n    version. And it provides a central place to control resizing defaults.\n    \"\"\"", "\n", "if", "LooseVersion", "(", "skimage", ".", "__version__", ")", ">=", "LooseVersion", "(", "\"0.14\"", ")", ":", "\n", "# New in 0.14: anti_aliasing. Default it to False for backward", "\n", "# compatibility with skimage 0.13.", "\n", "        ", "return", "skimage", ".", "transform", ".", "resize", "(", "\n", "image", ",", "output_shape", ",", "\n", "order", "=", "order", ",", "mode", "=", "mode", ",", "cval", "=", "cval", ",", "clip", "=", "clip", ",", "\n", "preserve_range", "=", "preserve_range", ",", "anti_aliasing", "=", "anti_aliasing", ",", "\n", "anti_aliasing_sigma", "=", "anti_aliasing_sigma", ")", "\n", "", "else", ":", "\n", "        ", "return", "skimage", ".", "transform", ".", "resize", "(", "\n", "image", ",", "output_shape", ",", "\n", "order", "=", "order", ",", "mode", "=", "mode", ",", "cval", "=", "cval", ",", "clip", "=", "clip", ",", "\n", "preserve_range", "=", "preserve_range", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize_image": [[342, 394], ["utils.resize", "resize.astype"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["", "", "def", "resize_image", "(", "image", ",", "min_dim", "=", "None", ",", "max_dim", "=", "None", ",", "min_scale", "=", "None", ",", "mode", "=", "\"square\"", ")", ":", "\n", "    ", "\"\"\"Resizes an image keeping the aspect ratio.\n\n    min_dim: if provided, resizes the image such that it's smaller\n             dimension == min_dim\n    max_dim: if provided, ensures that the image longest side doesn't\n             exceed this value.\n    min_scale: if provided, ensure that the image is scaled up by at least\n               this percent even if min_dim doesn't require it.\n    mode: Resizing mode.\n        none: No resizing. Return the image unchanged.\n        square: Resize and pad with zeros to get a square image\n                of size [max_dim, max_dim, max_dim].\n        pad64: Pads width and height with zeros to make them multiples of 64.\n               If min_dim or min_scale are provided, it scales the image up\n               before padding. max_dim is ignored in this mode.\n               The multiple of 64 is needed to ensure smooth scaling of feature\n               maps up and down the 6 levels of the FPN pyramid (2**6=64).\n        crop: Picks random crops from the image. First, scales the image based\n              on min_dim and min_scale, then picks a random crop of\n              size min_dim x min_dim. Can be used in training only.\n              max_dim is not used in this mode.\n        self: Self-designed resize strategy.\n              Resize the image to [IMAGE_MAX_DIM, IMAGE_MAX_DIM, IMAGE_MIN_DIM]\n\n    Returns:\n    image: the resized image of [height, width, depth, channels]\n    window: (z1, y1, x1, z2, y2, x2). If max_dim is provided, padding might\n            be inserted in the returned image. If so, this window is the\n            coordinates of the image part of the full image (excluding\n            the padding). The x2, y2, z2 pixels are not included.\n    scale: The scale factor used to resize the image\n    padding: Padding added to the image [(top, bottom), (left, right), (front, back), (0, 0)]\n    \"\"\"", "\n", "# Keep track of image dtype and return results in the same dtype", "\n", "image_dtype", "=", "image", ".", "dtype", "\n", "# Default window (z1, y1, x1, z2, y2, x2) and default scale == 1.", "\n", "h", ",", "w", ",", "d", "=", "image", ".", "shape", "[", ":", "3", "]", "\n", "window", "=", "(", "0", ",", "0", ",", "0", ",", "d", ",", "h", ",", "w", ")", "\n", "scale", "=", "1", "\n", "padding", "=", "[", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", "]", "\n", "crop", "=", "None", "\n", "\n", "if", "mode", "==", "\"none\"", ":", "\n", "        ", "return", "image", ",", "window", ",", "scale", ",", "padding", ",", "crop", "\n", "\n", "# Self-designed resize strategy.", "\n", "", "if", "mode", "==", "\"self\"", ":", "\n", "        ", "image", "=", "resize", "(", "image", ",", "(", "max_dim", ",", "max_dim", ",", "min_dim", ",", "1", ")", ",", "\n", "order", "=", "1", ",", "mode", "=", "\"constant\"", ",", "preserve_range", "=", "True", ")", "\n", "return", "image", ".", "astype", "(", "image_dtype", ")", ",", "(", "0", ",", "0", ",", "0", ",", "min_dim", ",", "max_dim", ",", "max_dim", ")", ",", "-", "1", ",", "[", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", "]", ",", "crop", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize_mask": [[396, 409], ["utils.resize", "numpy.round().astype", "numpy.round"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["", "", "def", "resize_mask", "(", "mask", ",", "scale", ",", "padding", ",", "max_dim", "=", "0", ",", "min_dim", "=", "0", ",", "crop", "=", "None", ",", "mode", "=", "\"square\"", ")", ":", "\n", "    ", "\"\"\"Resizes a mask using the given scale and padding.\n    Typically, you get the scale and padding from resize_image() to\n    ensure both, the image and the mask, are resized consistently.\n\n    scale: mask scaling factor\n    padding: Padding to add to the mask in the form\n            [(top, bottom), (left, right), (front, back), (0, 0)]\n    \"\"\"", "\n", "# Self-designed resize strategy.", "\n", "if", "mode", "==", "\"self\"", ":", "\n", "        ", "mask", "=", "resize", "(", "mask", ",", "(", "max_dim", ",", "max_dim", ",", "min_dim", ")", ",", "order", "=", "0", ",", "mode", "=", "'constant'", ",", "preserve_range", "=", "True", ")", "\n", "return", "np", ".", "round", "(", "mask", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.minimize_mask": [[411, 425], ["numpy.zeros", "range", "skimage.transform.resize", "numpy.around().astype", "Exception", "numpy.around"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["", "", "def", "minimize_mask", "(", "bbox", ",", "mask", ",", "mini_shape", ")", ":", "\n", "    ", "\"\"\"Resize masks to a smaller version to cut memory load.\n    Mini-masks can then resized back to image scale using expand_masks()\n    \"\"\"", "\n", "mini_mask", "=", "np", ".", "zeros", "(", "mini_shape", "+", "(", "mask", ".", "shape", "[", "-", "1", "]", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "m", "=", "mask", "[", ":", ",", ":", ",", ":", ",", "i", "]", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "bbox", "[", "i", "]", "[", ":", "6", "]", "\n", "m", "=", "m", "[", "z1", ":", "z2", ",", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "\n", "if", "m", ".", "size", "==", "0", ":", "\n", "            ", "raise", "Exception", "(", "\"Invalid bounding box with volume of zero\"", ")", "\n", "", "m", "=", "skimage", ".", "transform", ".", "resize", "(", "m", ",", "mini_shape", ",", "order", "=", "0", ",", "mode", "=", "\"constant\"", ",", "preserve_range", "=", "True", ")", "\n", "mini_mask", "[", ":", ",", ":", ",", ":", ",", "i", "]", "=", "np", ".", "around", "(", "m", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "return", "mini_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.expand_mask": [[427, 441], ["numpy.zeros", "range", "skimage.transform.resize", "numpy.around().astype", "numpy.around"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["", "def", "expand_mask", "(", "bbox", ",", "mini_mask", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Resizes mini masks back to image size. Reverses the change\n    of minimize_mask().\n    \"\"\"", "\n", "mask", "=", "np", ".", "zeros", "(", "image_shape", "[", ":", "3", "]", "+", "(", "mini_mask", ".", "shape", "[", "-", "1", "]", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "m", "=", "mini_mask", "[", ":", ",", ":", ",", ":", ",", "i", "]", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "bbox", "[", "i", "]", "[", ":", "6", "]", "\n", "d", "=", "z2", "-", "z1", "\n", "h", "=", "y2", "-", "y1", "\n", "w", "=", "x2", "-", "x1", "\n", "m", "=", "skimage", ".", "transform", ".", "resize", "(", "m", ",", "(", "d", ",", "h", ",", "w", ")", ",", "order", "=", "1", ",", "mode", "=", "\"constant\"", ",", "preserve_range", "=", "True", ")", "\n", "mask", "[", "z1", ":", "z2", ",", "y1", ":", "y2", ",", "x1", ":", "x2", ",", "i", "]", "=", "np", ".", "around", "(", "m", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.unmold_mask": [[443, 461], ["torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "mask.squeeze().detach().cpu().numpy().transpose.permute().unsqueeze", "torch.interpolate", "mask.squeeze().detach().cpu().numpy().transpose.squeeze().detach().cpu().numpy().transpose", "numpy.zeros", "torch.from_numpy().float", "torch.from_numpy().float", "mask.squeeze().detach().cpu().numpy().transpose.permute", "mask.squeeze().detach().cpu().numpy().transpose.squeeze().detach().cpu().numpy", "torch.from_numpy", "torch.from_numpy", "mask.squeeze().detach().cpu().numpy().transpose.squeeze().detach().cpu", "mask.squeeze().detach().cpu().numpy().transpose.squeeze().detach", "mask.squeeze().detach().cpu().numpy().transpose.squeeze"], "function", ["None"], ["", "def", "unmold_mask", "(", "mask", ",", "bbox", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Converts a mask generated by the neural network into a format similar\n    to it's original shape.\n    mask: [depth, height, width, num_instances] of type float. A small, typically 28x28 mask.\n    bbox: [z1, y1, x1, z2, y2, x2]. The box to fit the mask in.\n    image_shape: [channels, depth, height, width]\n\n    Returns a tf.int32 mask with the same size as the original image.\n    \"\"\"", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "bbox", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "\n", "mask", "=", "mask", ".", "permute", "(", "3", ",", "0", ",", "1", ",", "2", ")", ".", "unsqueeze", "(", "0", ")", "\n", "mask", "=", "F", ".", "interpolate", "(", "mask", ",", "size", "=", "(", "z2", "-", "z1", ",", "y2", "-", "y1", ",", "x2", "-", "x1", ")", ",", "mode", "=", "'trilinear'", ",", "align_corners", "=", "False", ")", "\n", "mask", "=", "mask", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "3", ",", "0", ")", "\n", "# Put the mask in the right location.", "\n", "full_mask", "=", "np", ".", "zeros", "(", "(", "image_shape", "[", "1", "]", ",", "image_shape", "[", "2", "]", ",", "image_shape", "[", "3", "]", ",", "mask", ".", "shape", "[", "-", "1", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "full_mask", "[", "z1", ":", "z2", ",", "y1", ":", "y2", ",", "x1", ":", "x2", ",", ":", "]", "=", "mask", "\n", "return", "full_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.generate_anchors": [[467, 509], ["numpy.meshgrid", "scales.flatten.flatten", "ratios.flatten.flatten", "numpy.meshgrid", "numpy.meshgrid", "numpy.meshgrid", "numpy.meshgrid", "numpy.stack().reshape", "numpy.stack().reshape", "numpy.concatenate", "numpy.array", "numpy.array", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.stack", "numpy.stack"], "function", ["None"], ["", "def", "generate_anchors", "(", "scales", ",", "ratios", ",", "shape", ",", "feature_stride", ",", "anchor_stride", ")", ":", "\n", "    ", "\"\"\"\n    scales: 1D array of anchor sizes in pixels. Example: [32, 64, 128]\n    ratios: 1D array of anchor ratios of width/height. Example: [1]\n    shape: [depth, height, width] spatial shape of the feature map over which\n            to generate anchors.\n    feature_stride: Stride of the feature map relative to the image in pixels.\n    anchor_stride: Stride of anchors on the feature map. For example, if the\n        value is 2 then generate anchors for every other feature map pixel.\n    \"\"\"", "\n", "# Get all combinations of scales and ratios", "\n", "scales", ",", "ratios", "=", "np", ".", "meshgrid", "(", "np", ".", "array", "(", "scales", ")", ",", "np", ".", "array", "(", "ratios", ")", ")", "\n", "scales", "=", "scales", ".", "flatten", "(", ")", "\n", "ratios", "=", "ratios", ".", "flatten", "(", ")", "\n", "\n", "# Enumerate heights and widths from scales and ratios", "\n", "# TODO: conditions when we have different ratios?", "\n", "# Here I apply a trick.", "\n", "depths", "=", "scales", "\n", "heights", "=", "scales", "\n", "widths", "=", "scales", "\n", "\n", "# Enumerate shifts in feature space", "\n", "shifts_z", "=", "np", ".", "arange", "(", "0", ",", "shape", "[", "0", "]", ",", "anchor_stride", ")", "*", "feature_stride", "\n", "shifts_y", "=", "np", ".", "arange", "(", "0", ",", "shape", "[", "1", "]", ",", "anchor_stride", ")", "*", "feature_stride", "\n", "shifts_x", "=", "np", ".", "arange", "(", "0", ",", "shape", "[", "2", "]", ",", "anchor_stride", ")", "*", "feature_stride", "\n", "shifts_z", ",", "shifts_y", ",", "shifts_x", "=", "np", ".", "meshgrid", "(", "shifts_z", ",", "shifts_y", ",", "shifts_x", ")", "\n", "\n", "# Enumerate combinations of shifts, widths, and heights", "\n", "box_depths", ",", "box_centers_z", "=", "np", ".", "meshgrid", "(", "depths", ",", "shifts_z", ")", "\n", "box_widths", ",", "box_centers_x", "=", "np", ".", "meshgrid", "(", "widths", ",", "shifts_x", ")", "\n", "box_heights", ",", "box_centers_y", "=", "np", ".", "meshgrid", "(", "heights", ",", "shifts_y", ")", "\n", "\n", "# Reshape to get a list of (z, y, x) and a list of (d, h, w)", "\n", "box_centers", "=", "np", ".", "stack", "(", "\n", "[", "box_centers_z", ",", "box_centers_y", ",", "box_centers_x", "]", ",", "axis", "=", "2", ")", ".", "reshape", "(", "[", "-", "1", ",", "3", "]", ")", "\n", "box_sizes", "=", "np", ".", "stack", "(", "[", "box_depths", ",", "box_heights", ",", "box_widths", "]", ",", "axis", "=", "2", ")", ".", "reshape", "(", "[", "-", "1", ",", "3", "]", ")", "\n", "\n", "# Convert to corner coordinates (z1, y1, x1, z2, y2, x2)", "\n", "boxes", "=", "np", ".", "concatenate", "(", "[", "box_centers", "-", "0.5", "*", "box_sizes", ",", "\n", "box_centers", "+", "0.5", "*", "box_sizes", "]", ",", "axis", "=", "1", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.generate_pyramid_anchors": [[511, 529], ["range", "numpy.concatenate", "len", "anchors.append", "utils.generate_anchors"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.generate_anchors"], ["", "def", "generate_pyramid_anchors", "(", "scales", ",", "ratios", ",", "feature_shapes", ",", "feature_strides", ",", "\n", "anchor_stride", ")", ":", "\n", "    ", "\"\"\"Generate anchors at different levels of a feature pyramid. Each scale\n    is associated with a level of the pyramid, but each ratio is used in\n    all levels of the pyramid.\n\n    Returns:\n    anchors: [N, (z1, y1, x1, z2, y2, x2)]. All generated anchors in one array. Sorted\n        with the same order of the given scales. So, anchors of scale[0] come\n        first, then anchors of scale[1], and so on.\n    \"\"\"", "\n", "# Anchors", "\n", "# [anchor_count, (z1, y1, x1, z2, y2, x2)]", "\n", "anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "scales", ")", ")", ":", "\n", "        ", "anchors", ".", "append", "(", "generate_anchors", "(", "scales", "[", "i", "]", ",", "ratios", ",", "feature_shapes", "[", "i", "]", ",", "\n", "feature_strides", "[", "i", "]", ",", "anchor_stride", ")", ")", "\n", "", "return", "np", ".", "concatenate", "(", "anchors", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.batch_slice": [[542, 578], ["range", "list", "isinstance", "graph_fn", "list.append", "zip", "torch.stack", "torch.stack", "len", "isinstance", "len", "zip"], "function", ["None"], ["", "def", "batch_slice", "(", "inputs", ",", "graph_fn", ",", "batch_size", ",", "names", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Splits inputs into slices and feeds each slice to a copy of the given\n    computation graph and then combines the results. It allows you to run a\n    graph on a batch of inputs even if the graph is written to support one\n    instance only.\n\n    inputs: list of tensors. All must have the same first dimension size\n    graph_fn: A function that returns a TF tensor that's part of a graph.\n    batch_size: number of slices to divide the data into.\n    names: If provided, assigns names to the resulting tensors.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "inputs", ",", "list", ")", ":", "\n", "        ", "inputs", "=", "[", "inputs", "]", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "inputs_slice", "=", "[", "x", "[", "i", "]", "for", "x", "in", "inputs", "]", "\n", "output_slice", "=", "graph_fn", "(", "*", "inputs_slice", ")", "\n", "if", "not", "isinstance", "(", "output_slice", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "output_slice", "=", "[", "output_slice", "]", "\n", "", "outputs", ".", "append", "(", "output_slice", ")", "\n", "# Change outputs from a list of slices where each is", "\n", "# a list of outputs to a list of outputs and each has", "\n", "# a list of slices", "\n", "", "outputs", "=", "list", "(", "zip", "(", "*", "outputs", ")", ")", "\n", "\n", "if", "names", "is", "None", ":", "\n", "        ", "names", "=", "[", "None", "]", "*", "len", "(", "outputs", ")", "\n", "\n", "", "result", "=", "[", "torch", ".", "stack", "(", "o", ",", "axis", "=", "0", ",", "name", "=", "n", ")", "\n", "for", "o", ",", "n", "in", "zip", "(", "outputs", ",", "names", ")", "]", "\n", "if", "len", "(", "result", ")", "==", "1", ":", "\n", "        ", "result", "=", "result", "[", "0", "]", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.compute_per_class_mask_iou": [[580, 597], ["numpy.reshape().astype", "numpy.reshape().astype", "numpy.sum", "numpy.sum", "numpy.array", "numpy.reshape", "numpy.reshape", "numpy.dot", "range"], "function", ["None"], ["", "def", "compute_per_class_mask_iou", "(", "gt_masks", ",", "pred_masks", ")", ":", "\n", "    ", "\"\"\"Computes per_class_IoU overlaps between two sets of masks.\n    gt_masks, pred_masks: [Height, Width, Depth, instances], zero-padding if there's no such instance.\n    Returns ious per instance.\n    \"\"\"", "\n", "# flatten masks and compute their areas", "\n", "gt_masks", "=", "np", ".", "reshape", "(", "gt_masks", ">", ".5", ",", "(", "-", "1", ",", "gt_masks", ".", "shape", "[", "-", "1", "]", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "pred_masks", "=", "np", ".", "reshape", "(", "pred_masks", ">", ".5", ",", "(", "-", "1", ",", "pred_masks", ".", "shape", "[", "-", "1", "]", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "area1", "=", "np", ".", "sum", "(", "gt_masks", ",", "axis", "=", "0", ")", "\n", "area2", "=", "np", ".", "sum", "(", "pred_masks", ",", "axis", "=", "0", ")", "\n", "\n", "# intersections and union", "\n", "intersections", "=", "np", ".", "array", "(", "[", "np", ".", "dot", "(", "gt_masks", ".", "T", ",", "pred_masks", ")", "[", "i", ",", "i", "]", "for", "i", "in", "range", "(", "gt_masks", ".", "shape", "[", "-", "1", "]", ")", "]", ")", "\n", "union", "=", "area1", "+", "area2", "-", "intersections", "\n", "ious", "=", "intersections", "/", "(", "union", "+", "1e-6", ")", "# avoid intersections to be divided by 0", "\n", "\n", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.compute_mask_iou": [[599, 618], ["numpy.reshape().astype", "numpy.reshape().astype", "numpy.sum", "numpy.sum", "numpy.dot", "numpy.reshape", "numpy.reshape"], "function", ["None"], ["", "def", "compute_mask_iou", "(", "gt_masks", ",", "pred_masks", ")", ":", "\n", "    ", "\"\"\"Computes IoU overlaps between two sets of masks. Regard different classes as the same.\n    gt_masks, pred_masks: [Height, Width, Depth].\n    Returns ious of the two masks.\n    \"\"\"", "\n", "# flatten masks and compute their areas", "\n", "gt_masks", "[", "gt_masks", ">", "0", "]", "=", "1", "\n", "pred_masks", "[", "pred_masks", ">", "0", "]", "=", "1", "\n", "gt_masks", "=", "np", ".", "reshape", "(", "gt_masks", ",", "(", "-", "1", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "pred_masks", "=", "np", ".", "reshape", "(", "pred_masks", ",", "(", "-", "1", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "area1", "=", "np", ".", "sum", "(", "gt_masks", ")", "\n", "area2", "=", "np", ".", "sum", "(", "pred_masks", ")", "\n", "\n", "# intersections and union", "\n", "intersections", "=", "np", ".", "dot", "(", "gt_masks", ".", "T", ",", "pred_masks", ")", "\n", "union", "=", "area1", "+", "area2", "-", "intersections", "\n", "ious", "=", "intersections", "/", "(", "union", "+", "1e-6", ")", "# avoid intersections to be divided by 0", "\n", "\n", "return", "ious", "\n", "", ""]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.Bottleneck.__init__": [[29, 57], ["torch.Module.__init__", "torch.Conv3d", "torch.BatchNorm3d", "backbone.conv_S", "torch.BatchNorm3d", "backbone.conv_T", "torch.BatchNorm3d", "torch.ReLU", "list", "torch.Conv3d", "torch.BatchNorm3d", "torch.Sequential", "torch.Conv3d", "torch.BatchNorm3d", "torch.Conv3d", "torch.BatchNorm3d", "len"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.conv_S", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.conv_T"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "block", ",", "expand", "=", "False", ",", "stride", "=", "1", ",", "ST_structure", "=", "(", "'A'", ",", "'B'", ",", "'C'", ")", ")", ":", "\n", "        ", "\"\"\"A wrapper for different Bottlenecks.\n        block: identify Block_A/B/C.\n        expand: whether to expand the final output channel by multiplying expansion.\n        \"\"\"", "\n", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "expand", "=", "expand", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv3d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm3d", "(", "planes", ")", "\n", "\n", "self", ".", "ST", "=", "list", "(", "ST_structure", ")", "[", "(", "block", "-", "1", ")", "%", "len", "(", "ST_structure", ")", "]", "\n", "self", ".", "conv2", "=", "conv_S", "(", "planes", ",", "planes", ",", "stride", "=", "1", ",", "padding", "=", "(", "0", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm3d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "conv_T", "(", "planes", ",", "planes", ",", "stride", "=", "1", ",", "padding", "=", "(", "1", ",", "0", ",", "0", ")", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm3d", "(", "planes", ")", "\n", "if", "expand", ":", "\n", "            ", "self", ".", "conv4", "=", "nn", ".", "Conv3d", "(", "planes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "bn4", "=", "nn", ".", "BatchNorm3d", "(", "planes", "*", "4", ")", "\n", "self", ".", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv3d", "(", "inplanes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "stride", "=", "2", ")", ",", "\n", "nn", ".", "BatchNorm3d", "(", "planes", "*", "4", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv4", "=", "nn", ".", "Conv3d", "(", "planes", ",", "inplanes", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "bn4", "=", "nn", ".", "BatchNorm3d", "(", "inplanes", ")", "\n", "", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.Bottleneck.ST_A": [[58, 68], ["backbone.Bottleneck.conv2", "backbone.Bottleneck.bn2", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv3", "backbone.Bottleneck.bn3", "backbone.Bottleneck.relu"], "methods", ["None"], ["", "def", "ST_A", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.Bottleneck.ST_B": [[69, 79], ["backbone.Bottleneck.conv2", "backbone.Bottleneck.bn2", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv3", "backbone.Bottleneck.bn3", "backbone.Bottleneck.relu"], "methods", ["None"], ["", "def", "ST_B", "(", "self", ",", "x", ")", ":", "\n", "        ", "tmp_x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "tmp_x", "=", "self", ".", "bn2", "(", "tmp_x", ")", "\n", "tmp_x", "=", "self", ".", "relu", "(", "tmp_x", ")", "\n", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "return", "x", "+", "tmp_x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.Bottleneck.ST_C": [[80, 90], ["backbone.Bottleneck.conv2", "backbone.Bottleneck.bn2", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv3", "backbone.Bottleneck.bn3", "backbone.Bottleneck.relu"], "methods", ["None"], ["", "def", "ST_C", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "tmp_x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "tmp_x", "=", "self", ".", "bn3", "(", "tmp_x", ")", "\n", "tmp_x", "=", "self", ".", "relu", "(", "tmp_x", ")", "\n", "\n", "return", "x", "+", "tmp_x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.Bottleneck.forward": [[91, 115], ["backbone.Bottleneck.conv1", "backbone.Bottleneck.bn1", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv4", "backbone.Bottleneck.bn4", "backbone.Bottleneck.relu", "backbone.Bottleneck.ST_A", "backbone.Bottleneck.downsample", "backbone.Bottleneck.ST_B", "backbone.Bottleneck.ST_C"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_A", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_B", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_C"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "ST", "==", "'A'", ":", "\n", "            ", "out", "=", "self", ".", "ST_A", "(", "out", ")", "\n", "", "elif", "self", ".", "ST", "==", "'B'", ":", "\n", "            ", "out", "=", "self", ".", "ST_B", "(", "out", ")", "\n", "", "elif", "self", ".", "ST", "==", "'C'", ":", "\n", "            ", "out", "=", "self", ".", "ST_C", "(", "out", ")", "\n", "\n", "", "out", "=", "self", ".", "conv4", "(", "out", ")", "\n", "out", "=", "self", ".", "bn4", "(", "out", ")", "\n", "\n", "if", "self", ".", "expand", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "residual", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.P3D.__init__": [[119, 140], ["torch.Module.__init__", "torch.Sequential", "backbone.P3D._make_layer", "backbone.P3D._make_layer", "backbone.P3D.modules", "torch.Conv3d", "torch.BatchNorm3d", "torch.ReLU", "torch.MaxPool3d", "isinstance", "m.weight.data.normal_", "isinstance", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D._make_layer", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "layers", ",", "input_channel", "=", "1", ",", "config", "=", "None", ")", ":", "\n", "        ", "super", "(", "P3D", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inplanes", "=", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", "\n", "\n", "self", ".", "C1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv3d", "(", "input_channel", ",", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", ",", "kernel_size", "=", "(", "3", ",", "7", ",", "7", ")", ",", "stride", "=", "2", ",", "padding", "=", "(", "1", ",", "3", ",", "3", ")", ")", ",", "\n", "nn", ".", "BatchNorm3d", "(", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "MaxPool3d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", ")", "# size = 1 / 4, channel = config.BACKBONE_CHANNELS[0]", "\n", "\n", "self", ".", "C2", "=", "self", ".", "_make_layer", "(", "block", ",", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", ",", "layers", "[", "0", "]", ",", "stride", "=", "2", ")", "# 1 / 8, [0] * 4", "\n", "self", ".", "C3", "=", "self", ".", "_make_layer", "(", "block", ",", "config", ".", "BACKBONE_CHANNELS", "[", "1", "]", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "# 1 / 16, [1] * 4", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv3d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm3d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.P3D._make_layer": [[141, 149], ["layers.append", "range", "torch.Sequential", "block", "layers.append", "block"], "methods", ["None"], ["", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "1", ",", "True", ",", "stride", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "2", ",", "blocks", "+", "1", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "i", ",", "False", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.P3D.forward": [[150, 156], ["backbone.P3D.C1", "backbone.P3D.C2", "backbone.P3D.C3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "C1", "(", "x", ")", "\n", "x", "=", "self", ".", "C2", "(", "x", ")", "\n", "x", "=", "self", ".", "C3", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.P3D.stages": [[157, 159], ["None"], "methods", ["None"], ["", "def", "stages", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "C1", ",", "self", ".", "C2", ",", "self", ".", "C3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.conv_S": [[14, 18], ["torch.Conv3d"], "function", ["None"], ["def", "conv_S", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ":", "\n", "    ", "\"\"\"conv_S is the spatial conv layer\"\"\"", "\n", "return", "nn", ".", "Conv3d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "(", "1", ",", "3", ",", "3", ")", ",", "\n", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.conv_T": [[20, 24], ["torch.Conv3d"], "function", ["None"], ["", "def", "conv_T", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ":", "\n", "    ", "\"\"\"conv_T is the temporal conv layer\"\"\"", "\n", "return", "nn", ".", "Conv3d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "(", "3", ",", "1", ",", "1", ")", ",", "\n", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.backbone.P3D19": [[161, 165], ["backbone.P3D"], "function", ["None"], ["", "", "def", "P3D19", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Construct a P3D19 model.\"\"\"", "\n", "model", "=", "P3D", "(", "Bottleneck", ",", "[", "2", ",", "3", "]", ",", "**", "kwargs", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.config.Config.__init__": [[197, 227], ["numpy.array"], "methods", ["None"], ["# Gradient norm clipping", "\n", "GRADIENT_CLIP_NORM", "=", "5.0", "\n", "\n", "def", "__init__", "(", "self", ",", "stage", ")", ":", "\n", "        ", "\"\"\"Set values of computed attributes.\"\"\"", "\n", "# Effective batch size", "\n", "self", ".", "BATCH_SIZE", "=", "self", ".", "IMAGES_PER_GPU", "*", "self", ".", "GPU_COUNT", "\n", "\n", "# Input image size: [height, width, depth, channels]", "\n", "if", "self", ".", "IMAGE_RESIZE_MODE", "==", "\"crop\"", ":", "\n", "            ", "self", ".", "IMAGE_SHAPE", "=", "np", ".", "array", "(", "[", "self", ".", "IMAGE_MIN_DIM", ",", "self", ".", "IMAGE_MIN_DIM", ",", "self", ".", "IMAGE_MIN_DIM", ",", "1", "]", ")", "\n", "", "elif", "self", ".", "IMAGE_RESIZE_MODE", "==", "\"self\"", ":", "\n", "            ", "self", ".", "IMAGE_SHAPE", "=", "np", ".", "array", "(", "[", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MIN_DIM", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "IMAGE_SHAPE", "=", "np", ".", "array", "(", "[", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MAX_DIM", ",", "1", "]", ")", "\n", "\n", "# Image meta data length", "\n", "# See compose_image_meta() for details", "\n", "", "self", ".", "IMAGE_META_SIZE", "=", "1", "+", "4", "+", "4", "+", "6", "+", "1", "+", "self", ".", "NUM_CLASSES", "\n", "self", ".", "STAGE", "=", "stage", "\n", "if", "stage", "==", "'finetune'", ":", "\n", "            ", "self", ".", "MINI_MASK_SHAPE", "=", "(", "192", ",", "192", ",", "192", ")", "\n", "self", ".", "MASK_SHAPE", "=", "(", "192", ",", "192", ",", "192", ")", "\n", "self", ".", "DETECTION_TARGET_IOU_THRESHOLD", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "self", ".", "MINI_MASK_SHAPE", "=", "(", "96", ",", "96", ",", "96", ")", "\n", "self", ".", "MASK_SHAPE", "=", "(", "96", ",", "96", ",", "96", ")", "\n", "self", ".", "DETECTION_TARGET_IOU_THRESHOLD", "=", "0.5", "\n", "\n", "", "", "def", "display", "(", "self", ")", ":", "\n", "        ", "\"\"\"Display Configuration values.\"\"\"", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.config.Config.display": [[228, 235], ["print", "dir", "print", "print", "a.startswith", "callable", "getattr", "getattr"], "methods", ["None"], ["print", "(", "\"\\nConfigurations:\"", ")", "\n", "for", "a", "in", "dir", "(", "self", ")", ":", "\n", "            ", "if", "not", "a", ".", "startswith", "(", "\"__\"", ")", "and", "not", "callable", "(", "getattr", "(", "self", ",", "a", ")", ")", ":", "\n", "                ", "print", "(", "\"{:30} {}\"", ".", "format", "(", "a", ",", "getattr", "(", "self", ",", "a", ")", ")", ")", "\n", "", "", "print", "(", "\"\\n\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.load_LiTS": [[185, 217], ["LiTS_main.LiTSDataset.add_class", "LiTS_main.LiTSDataset.add_class", "zip", "range", "range", "LiTS_main.LiTSDataset.add_image", "all_image_path.append", "all_label_path.append", "all_image_path.append", "all_label_path.append", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_image"], ["    ", "def", "load_LiTS", "(", "self", ",", "subset", ")", ":", "\n", "        ", "\"\"\"Load a subset of the heart dataset.\n        dataset_dir: Root directory of the dataset.\n        subset: Subset to load: train or val\n        \"\"\"", "\n", "# Add classes. We have seven classes to add.", "\n", "self", ".", "add_class", "(", "\"LiTS\"", ",", "1", ",", "\"liver\"", ")", "\n", "self", ".", "add_class", "(", "\"LiTS\"", ",", "2", ",", "\"tumor\"", ")", "\n", "\n", "# Train or validation dataset?", "\n", "assert", "subset", "in", "[", "\"train\"", ",", "\"val\"", "]", "\n", "all_image_path", "=", "[", "]", "\n", "all_label_path", "=", "[", "]", "\n", "if", "subset", "==", "\"train\"", ":", "\n", "            ", "for", "i", "in", "range", "(", "111", ")", ":", "\n", "                ", "all_image_path", ".", "append", "(", "args", ".", "data", "+", "\"image_np/liver_\"", "+", "str", "(", "i", ")", "+", "\".npy\"", ")", "\n", "all_label_path", ".", "append", "(", "args", ".", "data", "+", "\"label_np/liver_label_\"", "+", "str", "(", "i", ")", "+", "\".npy\"", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "111", ",", "131", ")", ":", "\n", "                ", "all_image_path", ".", "append", "(", "args", ".", "data", "+", "\"image_np/liver_\"", "+", "str", "(", "i", ")", "+", "\".npy\"", ")", "\n", "all_label_path", ".", "append", "(", "args", ".", "data", "+", "\"label_np/liver_label_\"", "+", "str", "(", "i", ")", "+", "\".npy\"", ")", "\n", "\n", "# Add images and masks", "\n", "", "", "for", "image_path", ",", "label_path", "in", "zip", "(", "all_image_path", ",", "all_label_path", ")", ":", "\n", "# image = np.load(image_path).astype(np.float32)", "\n", "# height, width, depth = image.shape", "\n", "            ", "self", ".", "add_image", "(", "\n", "\"LiTS\"", ",", "\n", "image_id", "=", "image_path", ",", "# use its path as a unique image id", "\n", "path", "=", "image_path", ",", "\n", "# width=width, height=height, depth=depth,", "\n", "mask", "=", "label_path", ")", "# save the path of the corresponding mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.load_image": [[218, 224], ["numpy.load().astype", "numpy.load"], "methods", ["None"], ["", "", "def", "load_image", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified image and return a [H, W, D] Numpy array.\"\"\"", "\n", "# Load image", "\n", "image", "=", "np", ".", "load", "(", "self", ".", "image_info", "[", "image_id", "]", "[", "'path'", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.process_mask": [[225, 238], ["numpy.zeros", "range", "numpy.zeros.astype", "numpy.arange"], "methods", ["None"], ["", "def", "process_mask", "(", "self", ",", "mask", ")", ":", "\n", "        ", "\"\"\"Given the [depth, height, width] mask that may contains many classes of annotations.\n        Generate instance masks and class_ids.\n        Returns:\n        masks: A np.int32 array of shape [num_classes, depth, height, width] with one mask per instance.\n        class_ids: a 1D array of class IDs of the instance masks.\n        \"\"\"", "\n", "masks", "=", "np", ".", "zeros", "(", "(", "self", ".", "num_classes", ",", "mask", ".", "shape", "[", "0", "]", ",", "mask", ".", "shape", "[", "1", "]", ",", "mask", ".", "shape", "[", "2", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_classes", ")", ":", "\n", "            ", "masks", "[", "i", "]", "[", "mask", "==", "i", "]", "=", "1", "\n", "\n", "# Return masks and array of class IDs of each instance.", "\n", "", "return", "masks", ".", "astype", "(", "np", ".", "float32", ")", ",", "np", ".", "arange", "(", "1", ",", "self", ".", "num_classes", ",", "1", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.load_mask": [[239, 253], ["numpy.load().astype", "super().load_mask", "numpy.load"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.load_mask"], ["", "def", "load_mask", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified mask and return a [H, W, D] Numpy array.\n       Returns:\n        masks: A np.int32 array of shape [height, width, depth].\n        \"\"\"", "\n", "# If not a LiTS dataset image, delegate to parent class.", "\n", "image_info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "if", "image_info", "[", "\"source\"", "]", "!=", "\"LiTS\"", ":", "\n", "            ", "return", "super", "(", "self", ".", "__class__", ",", "self", ")", ".", "load_mask", "(", "image_id", ")", "\n", "\n", "# Load mask", "\n", "", "mask", "=", "np", ".", "load", "(", "self", ".", "image_info", "[", "image_id", "]", "[", "'mask'", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.image_reference": [[254, 261], ["super().image_reference"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.image_reference"], ["", "def", "image_reference", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Return the path of the image.\"\"\"", "\n", "info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "if", "info", "[", "\"source\"", "]", "==", "\"LiTS\"", ":", "\n", "            ", "return", "info", "[", "\"path\"", "]", "\n", "", "else", ":", "\n", "            ", "super", "(", "self", ".", "__class__", ",", "self", ")", ".", "image_reference", "(", "image_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.train": [[263, 279], ["LiTS_main.LiTSDataset", "LiTS_main.LiTSDataset.load_LiTS", "LiTSDataset.prepare", "LiTS_main.LiTSDataset", "LiTS_main.LiTSDataset.load_LiTS", "LiTSDataset.prepare", "print", "model.train_model"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.load_LiTS", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.prepare", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.load_LiTS", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.prepare", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.train_model"], ["", "", "", "def", "train", "(", "model", ")", ":", "\n", "    ", "\"\"\"Train the model\"\"\"", "\n", "# Training dataset", "\n", "dataset_train", "=", "LiTSDataset", "(", ")", "\n", "dataset_train", ".", "load_LiTS", "(", "\"train\"", ")", "\n", "dataset_train", ".", "prepare", "(", ")", "\n", "\n", "# Validation dataset", "\n", "dataset_val", "=", "LiTSDataset", "(", ")", "\n", "dataset_val", ".", "load_LiTS", "(", "\"val\"", ")", "\n", "dataset_val", ".", "prepare", "(", ")", "\n", "\n", "print", "(", "\"Train all layers\"", ")", "\n", "model", ".", "train_model", "(", "dataset_train", ",", "dataset_val", ",", "\n", "learning_rate", "=", "config", ".", "LEARNING_RATE", ",", "\n", "epochs", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.test": [[285, 368], ["range", "print", "numpy.array", "print", "print", "os.path.exists", "os.makedirs", "numpy.load().astype", "numpy.load().astype", "utils.extract_bboxes", "utils.extend_bbox", "nibabel.load", "np.array.mean", "numpy.array", "print", "print", "print", "print", "time.time", "print", "rois.astype.clip", "rois[].clip", "rois[].clip", "rois[].clip", "rois.astype.astype", "print", "np.array.append", "numpy.mean", "numpy.std", "np.array.mean", "numpy.load", "numpy.load", "model.detect", "time.time", "numpy.zeros().astype", "numpy.zeros", "numpy.zeros", "range", "utils.compute_per_class_mask_iou", "np.array.append", "skimage.transform.resize", "nibabel.Nifti1Image", "print", "str", "time.time", "utils.compute_overlaps", "range", "skimage.transform.resize.astype", "nibabel.save", "print", "nibabel.save", "print", "numpy.zeros", "numpy.array", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "utils.compute_per_class_mask_iou.mean"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.extract_bboxes", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.extend_bbox", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.detect", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_per_class_mask_iou", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_overlaps"], ["", "def", "test", "(", "model", ")", ":", "\n", "    ", "\"\"\"Test the model.\"\"\"", "\n", "save_path", "=", "\"./results/\"", "+", "args", ".", "weights", "[", "27", ":", "]", "+", "\"/\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_path", ")", "\n", "", "per_class_ious", "=", "[", "]", "\n", "box_iou", "=", "[", "]", "\n", "detect_time", "=", "0", "\n", "for", "i", "in", "range", "(", "args", ".", "limit", ",", "131", ")", ":", "\n", "        ", "image", "=", "np", ".", "load", "(", "args", ".", "data", "+", "\"image_np/liver_\"", "+", "str", "(", "i", ")", "+", "\".npy\"", ")", ".", "astype", "(", "np", ".", "float32", ")", "# [H, W, D]", "\n", "label", "=", "np", ".", "load", "(", "args", ".", "data", "+", "\"label_np/liver_label_\"", "+", "str", "(", "i", ")", "+", "\".npy\"", ")", ".", "astype", "(", "np", ".", "int32", ")", "# [H, W, D, num_class]", "\n", "gt_bbox", "=", "utils", ".", "extract_bboxes", "(", "label", ")", "\n", "gt_bbox", "=", "utils", ".", "extend_bbox", "(", "gt_bbox", ",", "label", ".", "shape", ")", "\n", "nib_label", "=", "nib", ".", "load", "(", "\"/media/disk1/LiTS/labelTr/segmentation-\"", "+", "str", "(", "i", ")", "+", "\".nii.gz\"", ")", "\n", "affine", "=", "nib_label", ".", "affine", "# prepared to save the predicted mask later", "\n", "ori_shape", "=", "nib_label", ".", "shape", "\n", "try", ":", "\n", "            ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "model", ".", "detect", "(", "[", "image", "]", ")", "[", "0", "]", "\n", "detect_time", "+=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"detect_time:\"", ",", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "\"\"\"The shape of result: a dict containing\n            {\n                \"rois\": final_rois,           [N, (y1, x1, z1, y2, x2, z2)] in real coordinates\n                \"class_ids\": final_class_ids, [N]\n                \"scores\": final_scores,       [N]\n                \"mask\": final_mask,           [mask_shape[0], mask_shape[1], mask_shape[2]]\n            }\"\"\"", "\n", "rois", "=", "result", "[", "\"rois\"", "]", "\n", "class_ids", "=", "result", "[", "\"class_ids\"", "]", "\n", "scores", "=", "result", "[", "\"scores\"", "]", "\n", "mask", "=", "result", "[", "\"mask\"", "]", "\n", "if", "args", ".", "stage", "==", "'beginning'", ":", "\n", "                ", "mask", "=", "np", ".", "zeros", "(", "mask", ".", "shape", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "rois", "=", "rois", ".", "clip", "(", "min", "=", "0", ")", "\n", "rois", "[", ":", ",", "3", "]", "=", "rois", "[", ":", ",", "3", "]", ".", "clip", "(", "max", "=", "mask", ".", "shape", "[", "0", "]", "-", "1", ")", "\n", "rois", "[", ":", ",", "4", "]", "=", "rois", "[", ":", ",", "4", "]", ".", "clip", "(", "max", "=", "mask", ".", "shape", "[", "1", "]", "-", "1", ")", "\n", "rois", "[", ":", ",", "5", "]", "=", "rois", "[", ":", ",", "5", "]", ".", "clip", "(", "max", "=", "mask", ".", "shape", "[", "2", "]", "-", "1", ")", "\n", "rois", "=", "rois", ".", "astype", "(", "np", ".", "int32", ")", "\n", "# import pdb", "\n", "# pdb.set_trace()", "\n", "# compute bbox iou", "\n", "print", "(", "\"gt_bbox:\"", ",", "gt_bbox", ",", "\"pred_bbox:\"", ",", "rois", ")", "\n", "box_iou", ".", "append", "(", "utils", ".", "compute_overlaps", "(", "np", ".", "array", "(", "[", "gt_bbox", "]", ")", ",", "rois", ")", "[", "0", ",", "0", "]", ")", "\n", "if", "args", ".", "stage", "!=", "'beginning'", ":", "\n", "# Prepare the gt-masks and pred-masks to calculate the ious. [H, W, D, num_classes - 1]", "\n", "                ", "gt_masks", "=", "np", ".", "zeros", "(", "label", ".", "shape", "[", ":", "3", "]", "+", "(", "model", ".", "config", ".", "NUM_CLASSES", "-", "1", ",", ")", ")", "\n", "pred_masks", "=", "np", ".", "zeros", "(", "image", ".", "shape", "+", "(", "model", ".", "config", ".", "NUM_CLASSES", "-", "1", ",", ")", ")", "\n", "for", "j", "in", "range", "(", "model", ".", "config", ".", "NUM_CLASSES", "-", "1", ")", ":", "\n", "                    ", "gt_masks", "[", ":", ",", ":", ",", ":", ",", "j", "]", "[", "label", "==", "j", "+", "1", "]", "=", "1", "\n", "pred_masks", "[", ":", ",", ":", ",", ":", ",", "j", "]", "[", "mask", "==", "j", "+", "1", "]", "=", "1", "\n", "# calculate different kind of ious", "\n", "", "per_class_iou", "=", "utils", ".", "compute_per_class_mask_iou", "(", "gt_masks", ",", "pred_masks", ")", "\n", "per_class_ious", ".", "append", "(", "per_class_iou", ")", "\n", "# Save the results", "\n", "", "if", "args", ".", "save", ":", "\n", "# Draw bboxes", "\n", "                ", "if", "args", ".", "bbox", ":", "\n", "                    ", "for", "j", "in", "range", "(", "rois", ".", "shape", "[", "0", "]", ")", ":", "\n", "                        ", "y1", ",", "x1", ",", "z1", ",", "y2", ",", "x2", ",", "z2", "=", "rois", "[", "j", ",", ":", "]", "\n", "mask", "[", "y1", ":", "y2", ",", "x1", ":", "x2", ",", "z1", ":", "z2", "]", "=", "100", "\n", "", "", "mask", "=", "resize", "(", "mask", ",", "ori_shape", ",", "order", "=", "0", ",", "mode", "=", "'constant'", ",", "preserve_range", "=", "True", ",", "anti_aliasing", "=", "False", ")", "\n", "vol", "=", "nib", ".", "Nifti1Image", "(", "mask", ".", "astype", "(", "np", ".", "uint8", ")", ",", "affine", ")", "\n", "if", "args", ".", "stage", "!=", "'beginning'", ":", "\n", "                    ", "nib", ".", "save", "(", "vol", ",", "save_path", "+", "str", "(", "per_class_iou", ".", "mean", "(", ")", ")", "+", "\"_liver_\"", "+", "str", "(", "i", ")", "+", "\".nii.gz\"", ")", "\n", "print", "(", "\"liver_\"", "+", "str", "(", "i", ")", "+", "\" detected done. iou = \"", "+", "str", "(", "per_class_iou", ")", ")", "\n", "", "else", ":", "\n", "                    ", "nib", ".", "save", "(", "vol", ",", "save_path", "+", "str", "(", "box_iou", "[", "-", "1", "]", ")", "+", "\"_liver_\"", "+", "str", "(", "i", ")", "+", "\".nii.gz\"", ")", "\n", "print", "(", "\"liver_\"", "+", "str", "(", "i", ")", "+", "\" detected done. box_iou = \"", "+", "str", "(", "box_iou", "[", "-", "1", "]", ")", ")", "\n", "", "", "", "except", ":", "\n", "            ", "print", "(", "\"detect error!\"", ")", "\n", "pass", "\n", "", "", "print", "(", "\"Test completed.\"", ")", "\n", "# Print the iou results.", "\n", "box_iou", "=", "np", ".", "array", "(", "box_iou", ")", "\n", "print", "(", "\"box iou:\"", ",", "box_iou", ")", "\n", "print", "(", "\"mean:\"", ",", "box_iou", ".", "mean", "(", ")", ")", "\n", "if", "args", ".", "stage", "!=", "'beginning'", ":", "\n", "        ", "per_class_ious", "=", "np", ".", "array", "(", "per_class_ious", ")", "\n", "print", "(", "\"per class iou mean:\"", ",", "np", ".", "mean", "(", "per_class_ious", ",", "axis", "=", "0", ")", ")", "\n", "print", "(", "\"std:\"", ",", "np", ".", "std", "(", "per_class_ious", ",", "axis", "=", "0", ")", ")", "\n", "print", "(", "\"Total ious mean:\"", ",", "per_class_ious", ".", "mean", "(", ")", ")", "\n", "print", "(", "\"Total detect time:\"", ",", "detect_time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.predict_for_submit": [[370, 395], ["range", "print", "numpy.load().astype", "nibabel.load", "time.time", "print", "skimage.transform.resize", "nibabel.Nifti1Image", "nibabel.save", "numpy.load", "model.detect", "skimage.transform.resize.astype", "os.path.exists", "os.makedirs", "str", "time.time", "str", "str"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.detect"], ["", "", "def", "predict_for_submit", "(", "model", ")", ":", "\n", "    ", "\"\"\"Predict on the test set for final submission.\n    model: the model to test.\n    limit: the images to be used.\n    save: whether to save the masks.\n    \"\"\"", "\n", "for", "i", "in", "range", "(", "args", ".", "limit", ",", "70", ")", ":", "\n", "        ", "image", "=", "np", ".", "load", "(", "args", ".", "data", "+", "\"image_test_np/liver_\"", "+", "str", "(", "i", ")", "+", "\".npy\"", ")", ".", "astype", "(", "np", ".", "float32", ")", "# [512, 512, D]", "\n", "nib_image", "=", "nib", ".", "load", "(", "args", ".", "data", "+", "\"imagesTs/test-volume-\"", "+", "str", "(", "i", ")", "+", "\".nii.gz\"", ")", "\n", "affine", "=", "nib_image", ".", "affine", "\n", "ori_shape", "=", "nib_image", ".", "shape", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "try", ":", "\n", "            ", "result", "=", "model", ".", "detect", "(", "[", "image", "]", ")", "[", "0", "]", "\n", "print", "(", "\"processing\"", ",", "i", ",", "\"detect_time:\"", ",", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "mask", "=", "result", "[", "\"mask\"", "]", "\n", "mask", "=", "resize", "(", "mask", ",", "ori_shape", ",", "order", "=", "0", ",", "preserve_range", "=", "True", ",", "anti_aliasing", "=", "False", ")", "\n", "vol", "=", "nib", ".", "Nifti1Image", "(", "mask", ".", "astype", "(", "np", ".", "uint8", ")", ",", "affine", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "\"./results/submissions/\"", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "\"./results/submissions/\"", ")", "\n", "", "nib", ".", "save", "(", "vol", ",", "\"./results/submissions/test-segmentation-\"", "+", "str", "(", "i", ")", "+", "\".nii\"", ")", "\n", "", "except", ":", "\n", "            ", "pass", "\n", "\n", "", "", "print", "(", "\"prediction completed\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.preprocessing.get_spacing": [[10, 14], ["numpy.abs", "numpy.array"], "function", ["None"], ["def", "get_spacing", "(", "image", ")", ":", "\n", "    ", "affine", "=", "image", ".", "affine", "\n", "\n", "return", "np", ".", "abs", "(", "np", ".", "array", "(", "[", "affine", "[", "0", ",", "0", "]", ",", "affine", "[", "1", ",", "1", "]", ",", "affine", "[", "2", ",", "2", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.__init__": [[12, 90], ["torch.Module.__init__", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Upsample", "torch.Upsample", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_conv", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "mask_branch.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "mask_branch.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "mask_branch.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "mask_branch.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "mask_branch.Modified3DUNet.upscale_conv"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.upscale_conv"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "n_classes", ",", "stage", ",", "base_n_filter", "=", "32", ")", ":", "\n", "        ", "super", "(", "Modified3DUNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "base_n_filter", "=", "base_n_filter", "\n", "self", ".", "stage", "=", "stage", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", ")", "\n", "self", ".", "dropout3d", "=", "nn", ".", "Dropout3d", "(", "p", "=", "0.6", ")", "\n", "self", ".", "upsacle", "=", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", "\n", "\n", "# Level 1 context pathway", "\n", "self", ".", "conv3d_c1_1", "=", "nn", ".", "Conv3d", "(", "self", ".", "in_channels", ",", "self", ".", "base_n_filter", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "conv3d_c1_2", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "lrelu_conv_c1", "=", "self", ".", "lrelu_conv", "(", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", ")", "\n", "self", ".", "inorm3d_c1", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", ")", "\n", "\n", "# Level 2 context pathway", "\n", "self", ".", "conv3d_c2", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", "*", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_conv_c2", "=", "self", ".", "norm_lrelu_conv", "(", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "2", ")", "\n", "self", ".", "inorm3d_c2", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "2", ")", "\n", "\n", "# Level 3 context pathway", "\n", "self", ".", "conv3d_c3", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "4", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_conv_c3", "=", "self", ".", "norm_lrelu_conv", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "4", ")", "\n", "self", ".", "inorm3d_c3", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "4", ")", "\n", "\n", "# Level 4 context pathway", "\n", "self", ".", "conv3d_c4", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "8", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_conv_c4", "=", "self", ".", "norm_lrelu_conv", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ")", "\n", "self", ".", "inorm3d_c4", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "8", ")", "\n", "\n", "# Level 5 context pathway, level 0 localization pathway", "\n", "self", ".", "conv3d_c5", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "16", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_conv_c5", "=", "self", ".", "norm_lrelu_conv", "(", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "16", ")", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l0", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "16", ",", "\n", "self", ".", "base_n_filter", "*", "8", ")", "\n", "\n", "self", ".", "conv3d_l0", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "inorm3d_l0", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "8", ")", "\n", "\n", "# Level 1 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l1", "=", "self", ".", "conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "16", ")", "\n", "self", ".", "conv3d_l1", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "8", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l1", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "8", ",", "\n", "self", ".", "base_n_filter", "*", "4", ")", "\n", "\n", "# Level 2 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l2", "=", "self", ".", "conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ")", "\n", "self", ".", "conv3d_l2", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "4", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l2", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "4", ",", "\n", "self", ".", "base_n_filter", "*", "2", ")", "\n", "\n", "# Level 3 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l3", "=", "self", ".", "conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "4", ")", "\n", "self", ".", "conv3d_l3", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "2", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l3", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "2", ",", "\n", "self", ".", "base_n_filter", ")", "\n", "\n", "# Level 4 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l4", "=", "self", ".", "conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "2", ")", "\n", "self", ".", "conv3d_l4", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "n_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "self", ".", "ds2_1x1_conv3d", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "n_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "ds3_1x1_conv3d", "=", "nn", ".", "Conv3d", "(", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "n_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "out_upscale_conv", "=", "self", ".", "upscale_conv", "(", "self", ".", "n_classes", ",", "self", ".", "n_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.conv_norm_lrelu": [[91, 96], ["torch.Sequential", "torch.Sequential", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["None"], ["", "def", "conv_norm_lrelu", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_out", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_conv": [[97, 102], ["torch.Sequential", "torch.Sequential", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv3d", "torch.Conv3d"], "methods", ["None"], ["", "def", "norm_lrelu_conv", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_in", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.lrelu_conv": [[103, 107], ["torch.Sequential", "torch.Sequential", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv3d", "torch.Conv3d"], "methods", ["None"], ["", "def", "lrelu_conv", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu": [[108, 117], ["torch.Sequential", "torch.Sequential", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Upsample", "torch.Upsample", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["None"], ["", "def", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_in", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ",", "\n", "# should be feat_in*2 or feat_in", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_out", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.upscale_conv": [[118, 123], ["torch.Sequential", "torch.Sequential", "torch.Upsample", "torch.Upsample", "torch.Conv3d", "torch.Conv3d"], "methods", ["None"], ["", "def", "upscale_conv", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ",", "\n", "# should be feat_in*2 or feat_in", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.mask_branch.Modified3DUNet.forward": [[124, 222], ["mask_branch.Modified3DUNet.conv3d_c1_1", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c1_2", "mask_branch.Modified3DUNet.lrelu_conv_c1", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.inorm3d_c1", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c2", "mask_branch.Modified3DUNet.norm_lrelu_conv_c2", "mask_branch.Modified3DUNet.norm_lrelu_conv_c2", "mask_branch.Modified3DUNet.inorm3d_c2", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c3", "mask_branch.Modified3DUNet.norm_lrelu_conv_c3", "mask_branch.Modified3DUNet.norm_lrelu_conv_c3", "mask_branch.Modified3DUNet.inorm3d_c3", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c4", "mask_branch.Modified3DUNet.norm_lrelu_conv_c4", "mask_branch.Modified3DUNet.norm_lrelu_conv_c4", "mask_branch.Modified3DUNet.inorm3d_c4", "mask_branch.Modified3DUNet.lrelu", "mask_branch.Modified3DUNet.conv3d_c5", "mask_branch.Modified3DUNet.norm_lrelu_conv_c5", "mask_branch.Modified3DUNet.norm_lrelu_conv_c5", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l0", "mask_branch.Modified3DUNet.conv3d_l0", "mask_branch.Modified3DUNet.inorm3d_l0", "mask_branch.Modified3DUNet.lrelu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_branch.Modified3DUNet.conv_norm_lrelu_l1", "mask_branch.Modified3DUNet.conv3d_l1", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_branch.Modified3DUNet.conv_norm_lrelu_l2", "mask_branch.Modified3DUNet.conv3d_l2", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_branch.Modified3DUNet.conv_norm_lrelu_l3", "mask_branch.Modified3DUNet.conv3d_l3", "mask_branch.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l3", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_branch.Modified3DUNet.conv_norm_lrelu_l4", "mask_branch.Modified3DUNet.conv3d_l4", "mask_branch.Modified3DUNet.ds2_1x1_conv3d", "mask_branch.Modified3DUNet.upsacle", "mask_branch.Modified3DUNet.ds3_1x1_conv3d", "mask_branch.Modified3DUNet.upsacle", "mask_branch.Modified3DUNet.out_upscale_conv", "mask_branch.Modified3DUNet.upsacle"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "#  Level 1 context pathway", "\n", "        ", "out", "=", "self", ".", "conv3d_c1_1", "(", "x", ")", "\n", "residual_1", "=", "out", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "out", "=", "self", ".", "conv3d_c1_2", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu_conv_c1", "(", "out", ")", "\n", "# Element Wise Summation", "\n", "out", "+=", "residual_1", "\n", "context_1", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "out", "=", "self", ".", "inorm3d_c1", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "\n", "# Level 2 context pathway", "\n", "out", "=", "self", ".", "conv3d_c2", "(", "out", ")", "\n", "residual_2", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c2", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c2", "(", "out", ")", "\n", "out", "+=", "residual_2", "\n", "out", "=", "self", ".", "inorm3d_c2", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "context_2", "=", "out", "\n", "\n", "# Level 3 context pathway", "\n", "out", "=", "self", ".", "conv3d_c3", "(", "out", ")", "\n", "residual_3", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c3", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c3", "(", "out", ")", "\n", "out", "+=", "residual_3", "\n", "out", "=", "self", ".", "inorm3d_c3", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "context_3", "=", "out", "\n", "\n", "# Level 4 context pathway", "\n", "out", "=", "self", ".", "conv3d_c4", "(", "out", ")", "\n", "residual_4", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c4", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c4", "(", "out", ")", "\n", "out", "+=", "residual_4", "\n", "out", "=", "self", ".", "inorm3d_c4", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "context_4", "=", "out", "\n", "\n", "# Level 5", "\n", "out", "=", "self", ".", "conv3d_c5", "(", "out", ")", "\n", "residual_5", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c5", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c5", "(", "out", ")", "\n", "out", "+=", "residual_5", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l0", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3d_l0", "(", "out", ")", "\n", "out", "=", "self", ".", "inorm3d_l0", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "\n", "# Level 1 localization pathway", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_4", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv3d_l1", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l1", "(", "out", ")", "\n", "\n", "# Level 2 localization pathway", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_3", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l2", "(", "out", ")", "\n", "ds2", "=", "out", "\n", "out", "=", "self", ".", "conv3d_l2", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l2", "(", "out", ")", "\n", "\n", "# Level 3 localization pathway", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_2", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l3", "(", "out", ")", "\n", "ds3", "=", "out", "\n", "out", "=", "self", ".", "conv3d_l3", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l3", "(", "out", ")", "\n", "\n", "# Level 4 localization pathway", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_1", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l4", "(", "out", ")", "\n", "out_pred", "=", "self", ".", "conv3d_l4", "(", "out", ")", "\n", "\n", "ds2_1x1_conv", "=", "self", ".", "ds2_1x1_conv3d", "(", "ds2", ")", "\n", "ds1_ds2_sum_upscale", "=", "self", ".", "upsacle", "(", "ds2_1x1_conv", ")", "\n", "ds3_1x1_conv", "=", "self", ".", "ds3_1x1_conv3d", "(", "ds3", ")", "\n", "ds1_ds2_sum_upscale_ds3_sum", "=", "ds1_ds2_sum_upscale", "+", "ds3_1x1_conv", "\n", "ds1_ds2_sum_upscale_ds3_sum_upscale", "=", "self", ".", "upsacle", "(", "ds1_ds2_sum_upscale_ds3_sum", ")", "\n", "\n", "out", "=", "out_pred", "+", "ds1_ds2_sum_upscale_ds3_sum_upscale", "\n", "if", "self", ".", "stage", "==", "'finetune'", ":", "\n", "            ", "out_upscale", "=", "self", ".", "out_upscale_conv", "(", "out", ")", "\n", "out", "=", "self", ".", "upsacle", "(", "out", ")", "+", "out_upscale", "\n", "", "seg_layer", "=", "out", "\n", "return", "seg_layer", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.FPN.__init__": [[115, 125], ["torch.Module.__init__", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["self", ".", "conv1", "=", "nn", ".", "Conv3d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv3d", "(", "out_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "y", "=", "F", ".", "interpolate", "(", "y", ",", "scale_factor", "=", "2", ")", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "return", "self", ".", "conv2", "(", "x", "+", "y", ")", "\n", "\n", "\n", "", "", "class", "FPN", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "C1", ",", "C2", ",", "C3", ",", "out_channels", ",", "config", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.FPN.forward": [[126, 139], ["model.FPN.C1", "model.FPN.C2", "model.FPN.C3", "model.FPN.P3_conv1", "model.FPN.P3_conv2", "model.FPN.P2_conv2", "model.FPN.P2_conv1", "torch.upsample", "torch.upsample", "torch.upsample", "torch.upsample", "torch.upsample"], "methods", ["None"], ["        ", "super", "(", "FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "C1", "=", "C1", "\n", "self", ".", "C2", "=", "C2", "\n", "self", ".", "C3", "=", "C3", "\n", "self", ".", "P3_conv1", "=", "nn", ".", "Conv3d", "(", "config", ".", "BACKBONE_CHANNELS", "[", "1", "]", "*", "4", ",", "self", ".", "out_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "P3_conv2", "=", "nn", ".", "Conv3d", "(", "self", ".", "out_channels", ",", "self", ".", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "P2_conv1", "=", "nn", ".", "Conv3d", "(", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", "*", "4", ",", "self", ".", "out_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "P2_conv2", "=", "nn", ".", "Conv3d", "(", "self", ".", "out_channels", ",", "self", ".", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "C1", "(", "x", ")", "\n", "x", "=", "self", ".", "C2", "(", "x", ")", "\n", "c2_out", "=", "x", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.RPN.__init__": [[710, 717], ["torch.Module.__init__", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["\n", "def", "__init__", "(", "self", ",", "anchors_per_location", ",", "anchor_stride", ",", "channel", ",", "conv_channel", ")", ":", "\n", "        ", "super", "(", "RPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv_shared", "=", "nn", ".", "Conv3d", "(", "channel", ",", "conv_channel", ",", "kernel_size", "=", "3", ",", "stride", "=", "anchor_stride", ",", "padding", "=", "1", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv_class", "=", "nn", ".", "Conv3d", "(", "conv_channel", ",", "2", "*", "anchors_per_location", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "2", ")", "\n", "self", ".", "conv_bbox", "=", "nn", ".", "Conv3d", "(", "conv_channel", ",", "6", "*", "anchors_per_location", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.RPN.forward": [[718, 743], ["model.RPN.relu", "model.RPN.conv_class", "rpn_class_logits.view.view.permute", "rpn_class_logits.view.view.contiguous", "rpn_class_logits.view.view.view", "model.RPN.softmax", "model.RPN.conv_bbox", "rpn_bbox.view.view.permute", "rpn_bbox.view.view.contiguous", "rpn_bbox.view.view.view", "model.RPN.conv_shared", "model.RPN.size", "model.RPN.size"], "methods", ["None"], ["\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# Shared convolutional base of the RPN", "\n", "        ", "x", "=", "self", ".", "relu", "(", "self", ".", "conv_shared", "(", "x", ")", ")", "\n", "\n", "# Anchor Score. [batch, anchors per location * 2, depth, height, width].", "\n", "rpn_class_logits", "=", "self", ".", "conv_class", "(", "x", ")", "\n", "\n", "# Reshape to [batch, anchors, 2]", "\n", "rpn_class_logits", "=", "rpn_class_logits", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", "\n", "rpn_class_logits", "=", "rpn_class_logits", ".", "contiguous", "(", ")", "\n", "rpn_class_logits", "=", "rpn_class_logits", ".", "view", "(", "x", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ",", "2", ")", "\n", "\n", "# Softmax on last dimension of BG/FG.", "\n", "rpn_probs", "=", "self", ".", "softmax", "(", "rpn_class_logits", ")", "\n", "\n", "# Bounding box refinement. [batch, anchors per location * 6, D, H, W]", "\n", "# where 6 == delta [z, y, x, log(d), log(h), log(w)]", "\n", "rpn_bbox", "=", "self", ".", "conv_bbox", "(", "x", ")", "\n", "\n", "# Reshape to [batch, anchors, 6]", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "contiguous", "(", ")", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "view", "(", "x", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ",", "6", ")", "\n", "\n", "return", "[", "rpn_class_logits", ",", "rpn_probs", ",", "rpn_bbox", "]", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.Classifier.__init__": [[751, 767], ["torch.Module.__init__", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channel", ",", "pool_size", ",", "image_shape", ",", "num_classes", ",", "fc_size", ",", "test_flag", "=", "False", ")", ":", "\n", "        ", "super", "(", "Classifier", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pool_size", "=", "pool_size", "\n", "self", ".", "image_shape", "=", "image_shape", "\n", "self", ".", "fc_size", "=", "fc_size", "\n", "self", ".", "test_flag", "=", "test_flag", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv3d", "(", "channel", ",", "fc_size", ",", "kernel_size", "=", "self", ".", "pool_size", ",", "stride", "=", "1", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm3d", "(", "fc_size", ",", "eps", "=", "0.001", ",", "momentum", "=", "0.01", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv3d", "(", "fc_size", ",", "fc_size", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm3d", "(", "fc_size", ",", "eps", "=", "0.001", ",", "momentum", "=", "0.01", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "self", ".", "linear_class", "=", "nn", ".", "Linear", "(", "fc_size", ",", "num_classes", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "self", ".", "linear_bbox", "=", "nn", ".", "Linear", "(", "fc_size", ",", "num_classes", "*", "6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.Classifier.forward": [[768, 785], ["model.pyramid_roi_align", "model.Classifier.conv1", "model.Classifier.bn1", "model.Classifier.relu", "model.Classifier.conv2", "model.Classifier.bn2", "model.Classifier.relu", "x.view.view.view", "model.Classifier.linear_class", "model.Classifier.softmax", "model.Classifier.linear_bbox", "mrcnn_bbox.view.view.view", "mrcnn_bbox.view.view.size"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.pyramid_roi_align"], ["", "def", "forward", "(", "self", ",", "x", ",", "rois", ")", ":", "\n", "        ", "x", "=", "pyramid_roi_align", "(", "[", "rois", "]", "+", "x", ",", "self", ".", "pool_size", ",", "self", ".", "test_flag", ")", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "self", ".", "fc_size", ")", "\n", "mrcnn_class_logits", "=", "self", ".", "linear_class", "(", "x", ")", "\n", "mrcnn_probs", "=", "self", ".", "softmax", "(", "mrcnn_class_logits", ")", "\n", "\n", "mrcnn_bbox", "=", "self", ".", "linear_bbox", "(", "x", ")", "\n", "mrcnn_bbox", "=", "mrcnn_bbox", ".", "view", "(", "mrcnn_bbox", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ",", "6", ")", "\n", "\n", "return", "[", "mrcnn_class_logits", ",", "mrcnn_probs", ",", "mrcnn_bbox", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.Mask.__init__": [[789, 796], ["torch.Module.__init__", "mask_branch.Modified3DUNet", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__"], ["        ", "super", "(", "Mask", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pool_size", "=", "pool_size", "\n", "self", ".", "test_flag", "=", "test_flag", "\n", "\n", "self", ".", "modified_u_net", "=", "mask_branch", ".", "Modified3DUNet", "(", "channel", ",", "num_classes", ",", "stage", ",", "conv_channel", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "rois", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.Mask.forward": [[797, 803], ["model.pyramid_roi_align", "model.Mask.modified_u_net", "model.Mask.softmax"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.pyramid_roi_align"], ["        ", "x", "=", "pyramid_roi_align", "(", "[", "rois", "]", "+", "x", ",", "self", ".", "pool_size", ",", "self", ".", "test_flag", ")", "\n", "x", "=", "self", ".", "modified_u_net", "(", "x", ")", "\n", "output", "=", "self", ".", "softmax", "(", "x", ")", "\n", "\n", "return", "x", ",", "output", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.Dataset.__init__": [[1131, 1144], ["numpy.copy", "utils.generate_pyramid_anchors", "model.compute_backbone_shapes"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.generate_pyramid_anchors", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_backbone_shapes"], ["extra", "=", "len", "(", "ids", ")", "-", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", "//", "2", ")", "\n", "if", "extra", ">", "0", ":", "\n", "# Reset the extra ones to neutral", "\n", "        ", "ids", "=", "np", ".", "random", ".", "choice", "(", "ids", ",", "extra", ",", "replace", "=", "False", ")", "\n", "rpn_match", "[", "ids", "]", "=", "0", "\n", "# Same for negative proposals", "\n", "", "ids", "=", "np", ".", "where", "(", "rpn_match", "==", "-", "1", ")", "[", "0", "]", "\n", "extra", "=", "len", "(", "ids", ")", "-", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", "-", "\n", "np", ".", "sum", "(", "rpn_match", "==", "1", ")", ")", "\n", "if", "extra", ">", "0", ":", "\n", "# Rest the extra ones to neutral", "\n", "        ", "ids", "=", "np", ".", "random", ".", "choice", "(", "ids", ",", "extra", ",", "replace", "=", "False", ")", "\n", "rpn_match", "[", "ids", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.Dataset.__getitem__": [[1145, 1249], ["model.Dataset.dataset.load_image", "model.preprocess_image", "model.Dataset.dataset.load_mask", "numpy.zeros", "numpy.zeros", "int", "int", "int", "numpy.zeros", "model.compose_image_meta", "numpy.expand_dims", "skimage.transform.resize.transpose", "model.load_image_gt", "model.Dataset.dataset.process_mask", "int", "skimage.transform.rotate", "skimage.transform.rotate", "skimage.transform.resize", "skimage.transform.resize", "skimage.transform.resize", "skimage.transform.resize", "skimage.transform.resize.transpose", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.load_image", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.preprocess_image", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.load_mask", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compose_image_meta", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.load_image_gt", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.LiTSDataset.process_mask", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["# For positive anchors, compute shift and scale needed to transform them to match the corresponding GT boxes.", "\n", "", "ids", "=", "np", ".", "where", "(", "rpn_match", "==", "1", ")", "[", "0", "]", "\n", "ix", "=", "0", "# index into rpn_bbox", "\n", "for", "i", ",", "a", "in", "zip", "(", "ids", ",", "anchors", "[", "ids", "]", ")", ":", "\n", "# Closest gt box (it might have IoU < 0.7)", "\n", "        ", "gt", "=", "gt_boxes", "[", "anchor_iou_argmax", "[", "i", "]", "]", "\n", "\n", "# Convert coordinates to center plus width/height.", "\n", "# GT Box", "\n", "gt_d", "=", "gt", "[", "3", "]", "-", "gt", "[", "0", "]", "\n", "gt_h", "=", "gt", "[", "4", "]", "-", "gt", "[", "1", "]", "\n", "gt_w", "=", "gt", "[", "5", "]", "-", "gt", "[", "2", "]", "\n", "gt_center_z", "=", "gt", "[", "0", "]", "+", "0.5", "*", "gt_d", "\n", "gt_center_y", "=", "gt", "[", "1", "]", "+", "0.5", "*", "gt_h", "\n", "gt_center_x", "=", "gt", "[", "2", "]", "+", "0.5", "*", "gt_w", "\n", "# Anchor", "\n", "a_d", "=", "a", "[", "3", "]", "-", "a", "[", "0", "]", "\n", "a_h", "=", "a", "[", "4", "]", "-", "a", "[", "1", "]", "\n", "a_w", "=", "a", "[", "5", "]", "-", "a", "[", "2", "]", "\n", "a_center_z", "=", "a", "[", "0", "]", "+", "0.5", "*", "a_d", "\n", "a_center_y", "=", "a", "[", "1", "]", "+", "0.5", "*", "a_h", "\n", "a_center_x", "=", "a", "[", "2", "]", "+", "0.5", "*", "a_w", "\n", "\n", "# Compute the bbox refinement that the RPN should predict.", "\n", "rpn_bbox", "[", "ix", "]", "=", "[", "\n", "(", "gt_center_z", "-", "a_center_z", ")", "/", "a_d", ",", "\n", "(", "gt_center_y", "-", "a_center_y", ")", "/", "a_h", ",", "\n", "(", "gt_center_x", "-", "a_center_x", ")", "/", "a_w", ",", "\n", "np", ".", "log", "(", "gt_d", "/", "a_d", ")", ",", "\n", "np", ".", "log", "(", "gt_h", "/", "a_h", ")", ",", "\n", "np", ".", "log", "(", "gt_w", "/", "a_w", ")", ",", "\n", "]", "\n", "# Normalize", "\n", "rpn_bbox", "[", "ix", "]", "/=", "config", ".", "RPN_BBOX_STD_DEV", "\n", "ix", "+=", "1", "\n", "\n", "", "return", "rpn_match", ",", "rpn_bbox", "\n", "\n", "\n", "", "class", "Dataset", "(", "torch", ".", "utils", ".", "data", ".", "Dataset", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "dataset", ",", "config", ")", ":", "\n", "        ", "\"\"\"A generator that returns images and corresponding target class ids,\n            bounding box deltas, and masks.\n            dataset: The Dataset object to pick data from\n            config: The model config object\n            shuffle: If True, shuffles the samples before every epoch\n            augment: If not None, applies the given image augmentation to images\n            Returns a Python generator. Upon calling next() on it, the\n            generator returns two lists, inputs and outputs. The contents\n            of the lists differs depending on the received arguments:\n            inputs list:\n            - images: [batch, H, W, D, C]\n            - image_metas: [batch, size of image meta]\n            - mask: [batch, H, W, D]\n            outputs list: Usually empty in regular training. But if detection_targets\n                is True then the outputs list contains target class_ids, bbox deltas,\n                and masks.\n            \"\"\"", "\n", "self", ".", "b", "=", "0", "# batch item index", "\n", "self", ".", "image_index", "=", "-", "1", "\n", "self", ".", "image_ids", "=", "np", ".", "copy", "(", "dataset", ".", "image_ids", ")", "\n", "self", ".", "error_count", "=", "0", "\n", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "config", "=", "config", "\n", "\n", "", "def", "__getitem__", "(", "self", ",", "image_index", ")", ":", "\n", "        ", "image_id", "=", "self", ".", "image_ids", "[", "image_index", "]", "\n", "# Load image, which is [H, W, D, C] first.", "\n", "image", "=", "self", ".", "dataset", ".", "load_image", "(", "image_id", ")", "\n", "# Load mask, which is [H, W, D] first.", "\n", "mask", "=", "self", ".", "dataset", ".", "load_mask", "(", "image_id", ")", "\n", "# Note that window has already been (z1, y1, x1, z2, y2, x2) here.", "\n", "image", ",", "window", ",", "scale", ",", "padding", ",", "crop", "=", "utils", ".", "resize_image", "(", "\n", "image", ",", "\n", "min_dim", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", ",", "\n", "max_dim", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", ",", "\n", "min_scale", "=", "self", ".", "config", ".", "IMAGE_MIN_SCALE", ",", "\n", "mode", "=", "self", ".", "config", ".", "IMAGE_RESIZE_MODE", ")", "\n", "mask", "=", "utils", ".", "resize_mask", "(", "mask", ",", "scale", ",", "padding", ",", "max_dim", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", ",", "\n", "min_dim", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", ",", "crop", "=", "crop", ",", "mode", "=", "self", ".", "config", ".", "IMAGE_RESIZE_MODE", ")", "\n", "\n", "# Active classes", "\n", "# Different datasets have different classes, so track the classes supported in the dataset of this image.", "\n", "active_class_ids", "=", "np", ".", "zeros", "(", "[", "self", ".", "dataset", ".", "num_classes", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "source_class_ids", "=", "self", ".", "dataset", ".", "source_class_ids", "[", "self", ".", "dataset", ".", "image_info", "[", "image_id", "]", "[", "\"source\"", "]", "]", "\n", "active_class_ids", "[", "source_class_ids", "]", "=", "1", "\n", "# Image meta data", "\n", "image_meta", "=", "compose_image_meta", "(", "image_id", ",", "image", ".", "shape", ",", "window", ",", "active_class_ids", ")", "\n", "\n", "return", "image", ",", "image_meta", ",", "mask", "\n", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "image_ids", ".", "shape", "[", "0", "]", "\n", "\n", "\n", "############################################################", "\n", "#  MaskRCNN Class", "\n", "############################################################", "\n", "\n", "", "", "class", "MaskRCNN", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"Encapsulates the 3D-Mask-RCNN model functionality.\"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "config", ",", "model_dir", ",", "test_flag", "=", "False", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.Dataset.__len__": [[1250, 1253], ["None"], "methods", ["None"], ["\n", "super", "(", "MaskRCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "epoch", "=", "0", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.__init__": [[1262, 1272], ["torch.Module.__init__", "model.MaskRCNN.build", "model.MaskRCNN.initialize_weights"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.build", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.initialize_weights"], ["# Image size must be dividable by 2 multiple times", "\n", "h", ",", "w", ",", "d", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "if", "h", "/", "16", "!=", "int", "(", "h", "/", "16", ")", "or", "w", "/", "16", "!=", "int", "(", "w", "/", "16", ")", "or", "d", "/", "16", "!=", "int", "(", "d", "/", "16", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Image size must be dividable by 16. Use 256, 320, 512, ... etc.\"", ")", "\n", "\n", "# Build the shared convolutional layers.", "\n", "# Returns a list of the last layers of each stage, 5 in total.", "\n", "", "P3D_Resnet", "=", "backbone", ".", "P3D19", "(", "config", "=", "config", ")", "\n", "C1", ",", "C2", ",", "C3", "=", "P3D_Resnet", ".", "stages", "(", ")", "\n", "\n", "# Top-down Layers", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.build": [[1273, 1334], ["backbone.P3D35.stages", "model.FPN", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "model.RPN", "model.Classifier", "model.Mask", "Exception", "print", "backbone.P3D19", "print", "backbone.P3D35", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.MaskRCNN.anchors.cuda", "len", "model.MaskRCNN.parameters", "model.MaskRCNN.parameters", "model.MaskRCNN.apply", "int", "int", "int", "classname.find", "m.parameters", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "utils.generate_pyramid_anchors", "model.compute_backbone_shapes"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.stages", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D19", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D35", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.generate_pyramid_anchors", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_backbone_shapes"], ["self", ".", "fpn", "=", "FPN", "(", "C1", ",", "C2", ",", "C3", ",", "out_channels", "=", "config", ".", "TOP_DOWN_PYRAMID_SIZE", ",", "config", "=", "config", ")", "\n", "\n", "# Generate Anchors", "\n", "self", ".", "anchors", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "utils", ".", "generate_pyramid_anchors", "(", "config", ".", "RPN_ANCHOR_SCALES", ",", "\n", "config", ".", "RPN_ANCHOR_RATIOS", ",", "\n", "compute_backbone_shapes", "(", "\n", "config", ",", "config", ".", "IMAGE_SHAPE", ")", ",", "\n", "config", ".", "BACKBONE_STRIDES", ",", "\n", "config", ".", "RPN_ANCHOR_STRIDE", ")", ")", ".", "float", "(", ")", ",", "\n", "requires_grad", "=", "False", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "            ", "self", ".", "anchors", "=", "self", ".", "anchors", ".", "cuda", "(", ")", "\n", "\n", "# RPN", "\n", "", "self", ".", "rpn", "=", "RPN", "(", "len", "(", "config", ".", "RPN_ANCHOR_RATIOS", ")", ",", "config", ".", "RPN_ANCHOR_STRIDE", ",", "config", ".", "TOP_DOWN_PYRAMID_SIZE", ",", "config", ".", "RPN_CONV_CHANNELS", ")", "\n", "\n", "# FPN Classifier", "\n", "self", ".", "classifier", "=", "Classifier", "(", "config", ".", "TOP_DOWN_PYRAMID_SIZE", ",", "config", ".", "POOL_SIZE", ",", "config", ".", "IMAGE_SHAPE", ",", "\n", "2", ",", "config", ".", "FPN_CLASSIFY_FC_LAYERS_SIZE", ",", "test_flag", ")", "\n", "\n", "# FPN Mask", "\n", "self", ".", "mask", "=", "Mask", "(", "1", ",", "config", ".", "MASK_POOL_SIZE", ",", "config", ".", "NUM_CLASSES", ",", "config", ".", "UNET_MASK_BRANCH_CHANNEL", ",", "self", ".", "config", ".", "STAGE", ",", "test_flag", ")", "\n", "\n", "# Fix batch norm layers", "\n", "def", "set_bn_fix", "(", "m", ")", ":", "\n", "            ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "classname", ".", "find", "(", "'BatchNorm'", ")", "!=", "-", "1", ":", "\n", "                ", "for", "p", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                    ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "", "if", "not", "config", ".", "TRAIN_BN", ":", "\n", "            ", "self", ".", "apply", "(", "set_bn_fix", ")", "\n", "\n", "", "", "def", "initialize_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize model weights.\"\"\"", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv3d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm3d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "0.01", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "", "", "", "def", "set_trainable", "(", "self", ",", "layer_regex", ")", ":", "\n", "        ", "\"\"\"Sets model layers as trainable if their names match the given regular expression.\"\"\"", "\n", "for", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "layer_name", "=", "param", "[", "0", "]", "\n", "trainable", "=", "bool", "(", "re", ".", "fullmatch", "(", "layer_regex", ",", "layer_name", ")", ")", "\n", "if", "not", "trainable", ":", "\n", "                ", "param", "[", "1", "]", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "", "def", "load_weights", "(", "self", ",", "file_path", ")", ":", "\n", "        ", "\"\"\"Modified version of the corresponding Keras function with the addition of multi-GPU support\n        and the ability to exclude some layers from loading.\n        exclude: list of layer names to exclude\n        \"\"\"", "\n", "if", "os", ".", "path", ".", "exists", "(", "file_path", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.initialize_weights": [[1335, 1349], ["model.MaskRCNN.modules", "isinstance", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "isinstance", "m.bias.data.zero_", "m.weight.data.fill_", "m.bias.data.zero_", "isinstance", "m.weight.data.normal_", "m.bias.data.zero_"], "methods", ["None"], ["            ", "pretrained_dict", "=", "torch", ".", "load", "(", "file_path", ")", "\n", "self", ".", "load_state_dict", "(", "pretrained_dict", ",", "strict", "=", "True", ")", "\n", "print", "(", "\"Weight file loading success!\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Weight file not found ...\"", ")", "\n", "\n", "", "", "def", "detect", "(", "self", ",", "images", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.set_trainable": [[1350, 1357], ["model.MaskRCNN.named_parameters", "bool", "re.fullmatch"], "methods", ["None"], ["\n", "\n", "# Mold inputs to format expected by the neural network", "\n", "# Has been transformed to pytorch shapes.", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "molded_images", ",", "image_metas", ",", "windows", "=", "self", ".", "mold_inputs", "(", "images", ")", "\n", "\n", "# Convert images to torch tensor", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.load_weights": [[1358, 1372], ["os.path.exists", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "model.MaskRCNN.state_dict", "model.MaskRCNN.update", "model.MaskRCNN.load_state_dict", "print", "print", "torch.load.items", "torch.load.items", "torch.load.items", "torch.load.items", "torch.load.items"], "methods", ["None"], ["molded_images", "=", "torch", ".", "from_numpy", "(", "molded_images", ")", ".", "float", "(", ")", "\n", "\n", "# To GPU", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "            ", "molded_images", "=", "molded_images", ".", "cuda", "(", ")", "\n", "\n", "# Wrap in variable", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "molded_images", "=", "Variable", "(", "molded_images", ")", "\n", "\n", "# Run object detection", "\n", "", "detections", ",", "mrcnn_mask", "=", "self", ".", "predict", "(", "[", "molded_images", ",", "image_metas", "]", ",", "mode", "=", "'inference'", ")", "\n", "# Convert to numpy", "\n", "detections", "=", "detections", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mrcnn_mask", "=", "mrcnn_mask", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "4", ",", "5", ",", "2", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.detect": [[1373, 1418], ["time.time", "model.MaskRCNN.mold_inputs", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.MaskRCNN.predict", "detections.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "mrcnn_mask.permute().detach().cpu().numpy.permute().detach().cpu().numpy.permute().detach().cpu().numpy", "print", "enumerate", "molded_images.cuda.cuda.cuda", "model.MaskRCNN.unmold_detections", "results.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "detections.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "mrcnn_mask.permute().detach().cpu().numpy.permute().detach().cpu().numpy.permute().detach().cpu", "time.time", "detections.detach().cpu().numpy.detach().cpu().numpy.detach", "mrcnn_mask.permute().detach().cpu().numpy.permute().detach().cpu().numpy.permute().detach", "mrcnn_mask.permute().detach().cpu().numpy.permute().detach().cpu().numpy.permute"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.mold_inputs", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.predict", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.unmold_detections"], ["print", "(", "\"detect done, using time\"", ",", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "\n", "# Process detections", "\n", "results", "=", "[", "]", "\n", "for", "i", ",", "image", "in", "enumerate", "(", "images", ")", ":", "\n", "            ", "final_rois", ",", "final_class_ids", ",", "final_scores", ",", "final_mask", "=", "self", ".", "unmold_detections", "(", "detections", "[", "i", "]", ",", "mrcnn_mask", "[", "i", "]", ",", "\n", "[", "image", ".", "shape", "[", "3", "]", ",", "image", ".", "shape", "[", "2", "]", ",", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "1", "]", "]", ",", "\n", "windows", "[", "i", "]", ")", "\n", "results", ".", "append", "(", "{", "\n", "\"rois\"", ":", "final_rois", ",", "\n", "\"class_ids\"", ":", "final_class_ids", ",", "\n", "\"scores\"", ":", "final_scores", ",", "\n", "\"mask\"", ":", "final_mask", ",", "\n", "}", ")", "\n", "\n", "", "return", "results", "\n", "\n", "", "def", "predict", "(", "self", ",", "inputs", ",", "mode", ")", ":", "\n", "        ", "molded_images", "=", "inputs", "[", "0", "]", "\n", "image_metas", "=", "inputs", "[", "1", "]", "\n", "\n", "if", "mode", "==", "'inference'", ":", "\n", "            ", "self", ".", "eval", "(", ")", "\n", "", "elif", "mode", "==", "'training'", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "\n", "# Set batchnorm always in eval mode during training", "\n", "def", "set_bn_eval", "(", "m", ")", ":", "\n", "                ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "classname", ".", "find", "(", "'BatchNorm'", ")", "!=", "-", "1", ":", "\n", "                    ", "m", ".", "eval", "(", ")", "\n", "\n", "", "", "self", ".", "apply", "(", "set_bn_eval", ")", "\n", "\n", "# Feature extraction", "\n", "", "p2_out", ",", "p3_out", "=", "self", ".", "fpn", "(", "molded_images", ")", "\n", "\n", "rpn_feature_maps", "=", "[", "p2_out", ",", "p3_out", "]", "\n", "mrcnn_classifier_feature_maps", "=", "[", "p2_out", ",", "p3_out", "]", "\n", "mrcnn_mask_feature_maps", "=", "[", "molded_images", ",", "molded_images", "]", "\n", "\n", "# Loop through pyramid layers", "\n", "layer_outputs", "=", "[", "]", "# list of lists", "\n", "for", "p", "in", "rpn_feature_maps", ":", "\n", "            ", "layer_outputs", ".", "append", "(", "self", ".", "rpn", "(", "p", ")", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.predict": [[1419, 1556], ["model.MaskRCNN.fpn", "list", "model.proposal_layer", "model.MaskRCNN.eval", "layer_outputs.append", "zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.MaskRCNN.classifier", "model.detection_layer", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "detection_boxes.unsqueeze.unsqueeze.unsqueeze", "detections.unsqueeze.unsqueeze.unsqueeze", "model.MaskRCNN.train", "model.MaskRCNN.apply", "model.MaskRCNN.rpn", "list", "scale.cuda.cuda.cuda", "model.MaskRCNN.mask", "mrcnn_mask.cuda.cuda.unsqueeze", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.detection_target_layer", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "scale.cuda.cuda.cuda", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "classname.find", "m.eval", "numpy.array", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "rois.size", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "mrcnn_class_logits.cuda.cuda.cuda", "mrcnn_class.cuda.cuda.cuda", "mrcnn_bbox.cuda.cuda.cuda", "mrcnn_mask.cuda.cuda.cuda", "mrcnn_mask_logits.cuda.cuda.cuda", "model.MaskRCNN.classifier", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "model.MaskRCNN.mask", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "mrcnn_mask.cuda.cuda.cuda", "mrcnn_mask_logits.cuda.cuda.cuda", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "mrcnn_class_logits.cuda.cuda.cuda", "mrcnn_class.cuda.cuda.cuda", "mrcnn_bbox.cuda.cuda.cuda", "p_rois.size"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.proposal_layer", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.detection_layer", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.LiTS_main.train", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.detection_target_layer"], ["\n", "# Concatenate layer outputs", "\n", "# Convert from list of lists of level outputs to list of lists", "\n", "# of outputs across levels.", "\n", "# e.g. [[a1, b1, c1], [a2, b2, c2]] => [[a1, a2], [b1, b2], [c1, c2]]", "\n", "", "outputs", "=", "list", "(", "zip", "(", "*", "layer_outputs", ")", ")", "\n", "outputs", "=", "[", "torch", ".", "cat", "(", "list", "(", "o", ")", ",", "dim", "=", "1", ")", "for", "o", "in", "outputs", "]", "\n", "rpn_class_logits", ",", "rpn_class", ",", "rpn_bbox", "=", "outputs", "\n", "\n", "# Generate proposals", "\n", "# Proposals are [batch, N, (z1, y1, x1, z2, y2, x2)] in normalized coordinates", "\n", "# and zero padded.", "\n", "proposal_count", "=", "self", ".", "config", ".", "POST_NMS_ROIS_TRAINING", "if", "mode", "==", "\"training\"", "else", "self", ".", "config", ".", "POST_NMS_ROIS_INFERENCE", "\n", "rpn_rois", "=", "proposal_layer", "(", "[", "rpn_class", ",", "rpn_bbox", "]", ",", "\n", "proposal_count", "=", "proposal_count", ",", "\n", "nms_threshold", "=", "self", ".", "config", ".", "RPN_NMS_THRESHOLD", ",", "\n", "anchors", "=", "self", ".", "anchors", ",", "\n", "config", "=", "self", ".", "config", ")", "\n", "if", "mode", "==", "'inference'", ":", "\n", "# Network Heads", "\n", "# Proposal classifier and BBox regressor heads", "\n", "            ", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", "=", "self", ".", "classifier", "(", "mrcnn_classifier_feature_maps", ",", "rpn_rois", ")", "\n", "\n", "# Detections", "\n", "# output is [batch, num_detections, (z1, y1, x1, z2, y2, x2, class_id, score)] in image coordinates", "\n", "detections", "=", "detection_layer", "(", "self", ".", "config", ",", "rpn_rois", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "image_metas", ")", "\n", "\n", "# Convert boxes to normalized coordinates", "\n", "h", ",", "w", ",", "d", "=", "self", ".", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "scale", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "d", ",", "h", ",", "w", ",", "d", ",", "h", ",", "w", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                ", "scale", "=", "scale", ".", "cuda", "(", ")", "\n", "", "detection_boxes", "=", "detections", "[", ":", ",", ":", "6", "]", "/", "scale", "\n", "\n", "# Add back batch dimension", "\n", "detection_boxes", "=", "detection_boxes", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# Create masks for detections", "\n", "_", ",", "mrcnn_mask", "=", "self", ".", "mask", "(", "mrcnn_mask_feature_maps", ",", "detection_boxes", ")", "\n", "\n", "# Add back batch dimension", "\n", "detections", "=", "detections", ".", "unsqueeze", "(", "0", ")", "\n", "mrcnn_mask", "=", "mrcnn_mask", ".", "unsqueeze", "(", "0", ")", "\n", "return", "[", "detections", ",", "mrcnn_mask", "]", "\n", "\n", "", "elif", "mode", "==", "'training'", ":", "\n", "            ", "gt_class_ids", "=", "inputs", "[", "2", "]", "# [1, 2, ..., num_classes - 1]", "\n", "gt_boxes", "=", "inputs", "[", "3", "]", "# [(num_classes - 1) * one_class_bbox]", "\n", "gt_masks", "=", "inputs", "[", "4", "]", "# multi_classes masks [D, H, W, num_classes - 1]", "\n", "\n", "# Normalize coordinates", "\n", "h", ",", "w", ",", "d", "=", "self", ".", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "scale", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "d", ",", "h", ",", "w", ",", "d", ",", "h", ",", "w", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                ", "scale", "=", "scale", ".", "cuda", "(", ")", "\n", "", "gt_boxes", "=", "gt_boxes", "/", "scale", "\n", "\n", "# Generate detection targets", "\n", "# Subsamples proposals and generates target outputs for training", "\n", "p_rois", ",", "rois", ",", "target_class_ids", ",", "target_deltas", ",", "target_mask", "=", "detection_target_layer", "(", "rpn_rois", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", ",", "self", ".", "config", ")", "\n", "\n", "if", "rois", ".", "size", "(", ")", "[", "0", "]", "==", "0", ":", "\n", "                ", "mrcnn_class_logits", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "mrcnn_class", "=", "Variable", "(", "torch", ".", "IntTensor", "(", ")", ")", "\n", "mrcnn_bbox", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "mrcnn_mask", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "mrcnn_mask_logits", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                    ", "mrcnn_class_logits", "=", "mrcnn_class_logits", ".", "cuda", "(", ")", "\n", "mrcnn_class", "=", "mrcnn_class", ".", "cuda", "(", ")", "\n", "mrcnn_bbox", "=", "mrcnn_bbox", ".", "cuda", "(", ")", "\n", "mrcnn_mask", "=", "mrcnn_mask", ".", "cuda", "(", ")", "\n", "mrcnn_mask_logits", "=", "mrcnn_mask_logits", ".", "cuda", "(", ")", "\n", "", "", "elif", "p_rois", ".", "size", "(", ")", "[", "0", "]", "==", "0", ":", "\n", "# Network Heads", "\n", "# Proposal classifier and BBox regressor heads", "\n", "                ", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", "=", "self", ".", "classifier", "(", "mrcnn_classifier_feature_maps", ",", "rois", ")", "\n", "mrcnn_mask", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "mrcnn_mask_logits", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ")", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                    ", "mrcnn_mask", "=", "mrcnn_mask", ".", "cuda", "(", ")", "\n", "mrcnn_mask_logits", "=", "mrcnn_mask_logits", ".", "cuda", "(", ")", "\n", "\n", "", "", "else", ":", "\n", "# Network Heads", "\n", "# Proposal classifier and BBox regressor heads", "\n", "                ", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", "=", "self", ".", "classifier", "(", "mrcnn_classifier_feature_maps", ",", "rois", ")", "\n", "\n", "# Create masks for detections", "\n", "mrcnn_mask_logits", ",", "mrcnn_mask", "=", "self", ".", "mask", "(", "mrcnn_mask_feature_maps", ",", "p_rois", ")", "\n", "\n", "", "return", "[", "rpn_class_logits", ",", "rpn_bbox", ",", "\n", "target_class_ids", ",", "mrcnn_class_logits", ",", "\n", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", "]", "\n", "\n", "", "", "def", "train_model", "(", "self", ",", "train_dataset", ",", "val_dataset", ",", "learning_rate", ",", "epochs", ")", ":", "\n", "        ", "\"\"\"Train the model.\n        train_dataset, val_dataset: Training and validation Dataset objects.\n        learning_rate: The learning rate to train with\n        epochs: Number of training epochs. Note that previous training epochs\n                are considered to be done already, so this actually determines\n                the epochs to train in total rather than in this particular call.\n        \"\"\"", "\n", "layers", "=", "\".*\"", "# set all the layers trainable", "\n", "\n", "# Data generators", "\n", "train_set", "=", "Dataset", "(", "train_dataset", ",", "self", ".", "config", ")", "\n", "train_generator", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "train_set", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "23", ")", "\n", "val_set", "=", "Dataset", "(", "val_dataset", ",", "self", ".", "config", ")", "\n", "val_generator", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "val_set", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "10", ")", "\n", "\n", "# Train", "\n", "self", ".", "set_trainable", "(", "layers", ")", "\n", "\n", "# Optimizer object", "\n", "# Add L2 Regularization", "\n", "# Skip gamma and beta weights of batch normalization layers.", "\n", "trainables_wo_bn", "=", "[", "param", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", "\n", "if", "param", ".", "requires_grad", "and", "'bn'", "not", "in", "name", "]", "\n", "trainables_only_bn", "=", "[", "param", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", "\n", "if", "param", ".", "requires_grad", "and", "'bn'", "in", "name", "]", "\n", "optimizer", "=", "optim", ".", "SGD", "(", "[", "\n", "{", "'params'", ":", "trainables_wo_bn", ",", "'weight_decay'", ":", "self", ".", "config", ".", "WEIGHT_DECAY", "}", ",", "\n", "{", "'params'", ":", "trainables_only_bn", "}", "\n", "]", ",", "lr", "=", "learning_rate", ",", "momentum", "=", "self", ".", "config", ".", "LEARNING_MOMENTUM", ")", "\n", "\n", "total_start_time", "=", "time", ".", "time", "(", ")", "\n", "start_datetime", "=", "time", ".", "strftime", "(", "\"%Y-%m-%d %H:%M:%S\"", ",", "time", ".", "localtime", "(", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "\"./logs/heart/\"", "+", "str", "(", "start_datetime", ")", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "\"./logs/heart/\"", "+", "str", "(", "start_datetime", ")", ")", "\n", "", "for", "epoch", "in", "range", "(", "self", ".", "epoch", "+", "1", ",", "epochs", "+", "1", ")", ":", "\n", "            ", "log", "(", "\"Epoch {}/{}.\"", ".", "format", "(", "epoch", ",", "epochs", ")", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "# Training", "\n", "angle", "=", "np", ".", "random", ".", "randint", "(", "-", "20", ",", "21", ")", "\n", "loss", ",", "loss_rpn_class", ",", "loss_rpn_bbox", ","]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.train_model": [[1557, 1621], ["model.Dataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "model.Dataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "model.MaskRCNN.set_trainable", "torch.SGD", "torch.SGD", "torch.SGD", "torch.SGD", "torch.SGD", "time.time", "time.strftime", "range", "time.localtime", "os.path.exists", "os.makedirs", "model.log", "time.time", "model.MaskRCNN.one_epoch", "print", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "model.MaskRCNN.named_parameters", "model.MaskRCNN.named_parameters", "int", "int", "model.MaskRCNN.one_epoch", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "str", "str", "model.MaskRCNN.state_dict", "time.time", "time.time", "str", "round", "str", "round", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.set_trainable", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.one_epoch", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.one_epoch"], ["loss_mrcnn_class", ",", "loss_mrcnn_bbox", ",", "loss_mrcnn_mask", ",", "loss_mrcnn_mask_edge", "=", "self", ".", "train_epoch", "(", "train_generator", ",", "optimizer", ",", "self", ".", "config", ".", "STEPS_PER_EPOCH", ",", "angle", ",", "train_dataset", ")", "\n", "\n", "print", "(", "\"One Training Epoch time:\"", ",", "int", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ",", "\n", "\"Total time:\"", ",", "int", "(", "time", ".", "time", "(", ")", "-", "total_start_time", ")", ")", "\n", "\n", "if", "epoch", "%", "5", "==", "0", ":", "\n", "# Validation", "\n", "                ", "val_loss", ",", "val_loss_rpn_class", ",", "val_loss_rpn_bbox", ",", "val_loss_mrcnn_class", ",", "val_loss_mrcnn_bbox", ",", "val_loss_mrcnn_mask", ",", "val_loss_mrcnn_mask_edge", "=", "self", ".", "valid_epoch", "(", "val_generator", ",", "self", ".", "config", ".", "VALIDATION_STEPS", ",", "angle", ",", "val_dataset", ")", "\n", "\n", "torch", ".", "save", "(", "self", ".", "state_dict", "(", ")", ",", "\"./logs/heart/\"", "+", "str", "(", "start_datetime", ")", "+", "\"/model\"", "+", "str", "(", "epoch", ")", "+", "\n", "\"_loss: \"", "+", "str", "(", "round", "(", "loss", ",", "4", ")", ")", "+", "\"_val: \"", "+", "str", "(", "round", "(", "val_loss", ",", "4", ")", ")", ")", "\n", "\n", "", "", "self", ".", "epoch", "=", "epochs", "\n", "\n", "", "def", "train_epoch", "(", "self", ",", "datagenerator", ",", "optimizer", ",", "steps", ",", "angle", ",", "dataset", ")", ":", "\n", "        ", "batch_count", "=", "0", "\n", "loss_sum", "=", "0", "\n", "loss_rpn_class_sum", "=", "0", "\n", "loss_rpn_bbox_sum", "=", "0", "\n", "loss_mrcnn_class_sum", "=", "0", "\n", "loss_mrcnn_bbox_sum", "=", "0", "\n", "loss_mrcnn_mask_sum", "=", "0", "\n", "loss_mrcnn_mask_edge_sum", "=", "0", "\n", "step", "=", "0", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "for", "inputs", "in", "datagenerator", ":", "\n", "            ", "batch_count", "+=", "1", "\n", "\n", "image", "=", "inputs", "[", "0", "]", "\n", "image_metas", "=", "inputs", "[", "1", "]", "\n", "mask", "=", "inputs", "[", "2", "]", "\n", "\n", "image", "=", "image", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mask", "=", "mask", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "images", ",", "rpn_match", ",", "rpn_bbox", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", "=", "load_image_gt", "(", "image", ",", "mask", ",", "angle", ",", "dataset", ",", "\n", "self", ".", "config", ",", "\n", "self", ".", "anchors", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "# image_metas as numpy array", "\n", "image_metas", "=", "image_metas", ".", "numpy", "(", ")", "\n", "\n", "# Wrap in variables", "\n", "images", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "images", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "rpn_match", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "rpn_match", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "rpn_bbox", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "rpn_bbox", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_class_ids", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_class_ids", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_boxes", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_boxes", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_masks", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_masks", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "# To GPU", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                ", "images", "=", "images", ".", "cuda", "(", ")", "\n", "rpn_match", "=", "rpn_match", ".", "cuda", "(", ")", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "cuda", "(", ")", "\n", "gt_class_ids", "=", "gt_class_ids", ".", "cuda", "(", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "cuda", "(", ")", "\n", "gt_masks", "=", "gt_masks", ".", "cuda", "(", ")", "\n", "\n", "# Run object detection", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.one_epoch": [[1622, 1726], ["optimizer.zero_grad", "image_metas.numpy.numpy.numpy", "model.MaskRCNN.predict", "model.compute_losses", "model.print_progress_bar", "images.cuda().float.cuda().float.cuda().float", "rpn_match.cuda.cuda.cuda", "rpn_bbox.cuda().float.cuda().float.cuda().float", "gt_class_ids.cuda.cuda.cuda", "gt_boxes.cuda().float.cuda().float.cuda().float", "gt_masks.cuda().float.cuda().float.cuda().float", "loss.detach().cpu().item", "rpn_class_loss.detach().cpu().item", "rpn_bbox_loss.detach().cpu().item", "mrcnn_class_loss.detach().cpu().item", "mrcnn_bbox_loss.detach().cpu().item", "mrcnn_mask_loss.detach().cpu().item", "mrcnn_mask_edge_loss.detach().cpu().item", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "loss.backward", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "images.cuda().float.cuda().float.cuda", "rpn_bbox.cuda().float.cuda().float.cuda", "gt_boxes.cuda().float.cuda().float.cuda", "gt_masks.cuda().float.cuda().float.cuda", "model.MaskRCNN.parameters", "optimizer.step", "optimizer.zero_grad", "optimizer.zero_grad", "loss.detach().cpu().item", "loss.detach().cpu", "rpn_class_loss.detach().cpu", "rpn_bbox_loss.detach().cpu", "mrcnn_class_loss.detach().cpu", "mrcnn_bbox_loss.detach().cpu", "mrcnn_mask_loss.detach().cpu", "mrcnn_mask_edge_loss.detach().cpu", "rpn_class_loss.detach().cpu().item", "rpn_bbox_loss.detach().cpu().item", "mrcnn_class_loss.detach().cpu().item", "mrcnn_bbox_loss.detach().cpu().item", "mrcnn_mask_loss.detach().cpu().item", "mrcnn_mask_edge_loss.detach().cpu().item", "loss.detach().cpu", "loss.detach", "rpn_class_loss.detach", "rpn_bbox_loss.detach", "mrcnn_class_loss.detach", "mrcnn_bbox_loss.detach", "mrcnn_mask_loss.detach", "mrcnn_mask_edge_loss.detach", "rpn_class_loss.detach().cpu", "rpn_bbox_loss.detach().cpu", "mrcnn_class_loss.detach().cpu", "mrcnn_bbox_loss.detach().cpu", "mrcnn_mask_loss.detach().cpu", "mrcnn_mask_edge_loss.detach().cpu", "loss.detach", "rpn_class_loss.detach", "rpn_bbox_loss.detach", "mrcnn_class_loss.detach", "mrcnn_bbox_loss.detach", "mrcnn_mask_loss.detach", "mrcnn_mask_edge_loss.detach"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.predict", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_losses", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.print_progress_bar"], ["", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "mrcnn_class_logits", ",", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", "=", "self", ".", "predict", "(", "[", "images", ",", "image_metas", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", "]", ",", "mode", "=", "'training'", ")", "\n", "\n", "# Compute losses", "\n", "rpn_class_loss", ",", "rpn_bbox_loss", ",", "mrcnn_class_loss", ",", "mrcnn_bbox_loss", ",", "mrcnn_mask_loss", ",", "mrcnn_mask_edge_loss", "=", "compute_losses", "(", "rpn_match", ",", "rpn_bbox", ",", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "\n", "mrcnn_class_logits", ",", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", ",", "self", ".", "config", ".", "STAGE", ")", "\n", "\n", "loss", "=", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_class_loss\"", "]", "*", "rpn_class_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_bbox_loss\"", "]", "*", "rpn_bbox_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_class_loss\"", "]", "*", "mrcnn_class_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_bbox_loss\"", "]", "*", "mrcnn_bbox_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_loss\"", "]", "*", "mrcnn_mask_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_edge_loss\"", "]", "*", "mrcnn_mask_edge_loss", "\n", "\n", "# Back propagation", "\n", "loss", ".", "backward", "(", ")", "\n", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "parameters", "(", ")", ",", "5.0", ")", "\n", "if", "(", "batch_count", "%", "self", ".", "config", ".", "BATCH_SIZE", ")", "==", "0", ":", "\n", "                ", "optimizer", ".", "step", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "batch_count", "=", "0", "\n", "\n", "# Progress", "\n", "", "print_progress_bar", "(", "step", "+", "1", ",", "steps", ",", "prefix", "=", "\"\\t{}/{}\"", ".", "format", "(", "step", "+", "1", ",", "steps", ")", ",", "\n", "suffix", "=", "\"Complete - loss: {:.5f} - rpn_class_loss: {:.5f} - rpn_bbox_loss: {:.5f}\"", "\n", "\" - mrcnn_class_loss: {:.5f} - mrcnn_bbox_loss: {:.5f} - mrcnn_mask_loss: {:.5f}\"", "\n", "\" - mrcnn_mask_edge_loss: {:.5f}\"", "\n", ".", "format", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_class_loss\"", "]", "*", "rpn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_bbox_loss\"", "]", "*", "rpn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_class_loss\"", "]", "*", "mrcnn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_bbox_loss\"", "]", "*", "mrcnn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_loss\"", "]", "*", "mrcnn_mask_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_edge_loss\"", "]", "*", "mrcnn_mask_edge_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", ",", "\n", "length", "=", "45", ")", "\n", "\n", "# Statistics", "\n", "loss_sum", "+=", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_rpn_class_sum", "+=", "rpn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_rpn_bbox_sum", "+=", "rpn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_class_sum", "+=", "mrcnn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_bbox_sum", "+=", "mrcnn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_mask_sum", "+=", "mrcnn_mask_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_mask_edge_sum", "+=", "mrcnn_mask_edge_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "\n", "# Break after 'steps' steps", "\n", "if", "step", "==", "steps", "-", "1", ":", "\n", "                ", "break", "\n", "", "step", "+=", "1", "\n", "\n", "", "return", "loss_sum", ",", "loss_rpn_class_sum", ",", "loss_rpn_bbox_sum", ",", "loss_mrcnn_class_sum", ",", "loss_mrcnn_bbox_sum", ",", "loss_mrcnn_mask_sum", ",", "loss_mrcnn_mask_edge_sum", "\n", "\n", "", "def", "valid_epoch", "(", "self", ",", "datagenerator", ",", "steps", ",", "angle", ",", "dataset", ")", ":", "\n", "\n", "        ", "step", "=", "0", "\n", "loss_sum", "=", "0", "\n", "loss_rpn_class_sum", "=", "0", "\n", "loss_rpn_bbox_sum", "=", "0", "\n", "loss_mrcnn_class_sum", "=", "0", "\n", "loss_mrcnn_bbox_sum", "=", "0", "\n", "loss_mrcnn_mask_sum", "=", "0", "\n", "loss_mrcnn_mask_edge_sum", "=", "0", "\n", "\n", "for", "inputs", "in", "datagenerator", ":", "\n", "\n", "            ", "image", "=", "inputs", "[", "0", "]", "\n", "image_metas", "=", "inputs", "[", "1", "]", "\n", "mask", "=", "inputs", "[", "2", "]", "\n", "\n", "image", "=", "image", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mask", "=", "mask", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "images", ",", "rpn_match", ",", "rpn_bbox", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", "=", "load_image_gt", "(", "image", ",", "mask", ",", "angle", ",", "dataset", ",", "\n", "self", ".", "config", ",", "\n", "self", ".", "anchors", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "# image_metas as numpy array", "\n", "image_metas", "=", "image_metas", ".", "numpy", "(", ")", "\n", "\n", "# Wrap in variables", "\n", "images", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "images", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "rpn_match", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "rpn_match", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "rpn_bbox", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "rpn_bbox", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_class_ids", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_class_ids", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_boxes", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_boxes", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "gt_masks", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "gt_masks", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "# To GPU", "\n", "if", "self", ".", "config", ".", "GPU_COUNT", ":", "\n", "                ", "images", "=", "images", ".", "cuda", "(", ")", "\n", "rpn_match", "=", "rpn_match", ".", "cuda", "(", ")", "\n", "rpn_bbox", "=", "rpn_bbox", ".", "cuda", "(", ")", "\n", "gt_class_ids", "=", "gt_class_ids", ".", "cuda", "(", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "cuda", "(", ")", "\n", "gt_masks", "=", "gt_masks", ".", "cuda", "(", ")", "\n", "\n", "# Run object detection", "\n", "", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "mrcnn_class_logits", ",", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", "=", "self", ".", "predict", "(", "[", "images", ",", "image_metas", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", "]", ",", "mode", "=", "'training'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.mold_inputs": [[1727, 1776], ["numpy.stack", "numpy.stack", "numpy.stack", "model.preprocess_image", "numpy.zeros", "int", "int", "int", "skimage.transform.resize", "numpy.expand_dims", "model.compose_image_meta", "numpy.stack.append", "numpy.stack.append", "numpy.stack.append", "skimage.transform.resize.transpose", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.preprocess_image", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compose_image_meta"], ["if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "# Compute losses", "\n", "", "rpn_class_loss", ",", "rpn_bbox_loss", ",", "mrcnn_class_loss", ",", "mrcnn_bbox_loss", ",", "mrcnn_mask_loss", ",", "mrcnn_mask_edge_loss", "=", "compute_losses", "(", "rpn_match", ",", "rpn_bbox", ",", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "\n", "mrcnn_class_logits", ",", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", ",", "self", ".", "config", ".", "STAGE", ")", "\n", "\n", "loss", "=", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_class_loss\"", "]", "*", "rpn_class_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_bbox_loss\"", "]", "*", "rpn_bbox_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_class_loss\"", "]", "*", "mrcnn_class_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_bbox_loss\"", "]", "*", "mrcnn_bbox_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_loss\"", "]", "*", "mrcnn_mask_loss", "+", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_edge_loss\"", "]", "*", "mrcnn_mask_edge_loss", "\n", "\n", "# Progress", "\n", "print_progress_bar", "(", "step", "+", "1", ",", "steps", ",", "prefix", "=", "\"\\t{}/{}\"", ".", "format", "(", "step", "+", "1", ",", "steps", ")", ",", "\n", "suffix", "=", "\"Complete - loss: {:.5f} - rpn_class_loss: {:.5f} - rpn_bbox_loss: {:.5f}\"", "\n", "\" - mrcnn_class_loss: {:.5f} - mrcnn_bbox_loss: {:.5f} - mrcnn_mask_loss: {:.5f}\"", "\n", "\" - mrcnn_mask_edge_loss: {:.5f}\"", "\n", ".", "format", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_class_loss\"", "]", "*", "rpn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"rpn_bbox_loss\"", "]", "*", "rpn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_class_loss\"", "]", "*", "mrcnn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_bbox_loss\"", "]", "*", "mrcnn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_loss\"", "]", "*", "mrcnn_mask_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "self", ".", "config", ".", "LOSS_WEIGHTS", "[", "\"mrcnn_mask_edge_loss\"", "]", "*", "mrcnn_mask_edge_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", ",", "\n", "length", "=", "10", ")", "\n", "\n", "# Statistics", "\n", "loss_sum", "+=", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_rpn_class_sum", "+=", "rpn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_rpn_bbox_sum", "+=", "rpn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_class_sum", "+=", "mrcnn_class_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_bbox_sum", "+=", "mrcnn_bbox_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_mask_sum", "+=", "mrcnn_mask_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "loss_mrcnn_mask_edge_sum", "+=", "mrcnn_mask_edge_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "/", "steps", "\n", "\n", "# Break after 'steps' steps", "\n", "if", "step", "==", "steps", "-", "1", ":", "\n", "                ", "break", "\n", "", "step", "+=", "1", "\n", "\n", "", "return", "loss_sum", ",", "loss_rpn_class_sum", ",", "loss_rpn_bbox_sum", ",", "loss_mrcnn_class_sum", ",", "loss_mrcnn_bbox_sum", ",", "loss_mrcnn_mask_sum", ",", "loss_mrcnn_mask_edge_sum", "\n", "\n", "", "def", "mold_inputs", "(", "self", ",", "images", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.MaskRCNN.unmold_detections": [[1777, 1836], ["time.time", "detections[].astype", "detections[].astype", "numpy.array", "numpy.array", "numpy.multiply().astype", "utils.unmold_mask", "numpy.argmax", "print", "numpy.where", "numpy.where", "numpy.delete", "numpy.delete", "numpy.delete", "numpy.delete", "numpy.arange", "numpy.argmax.transpose", "numpy.multiply", "time.time", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.unmold_mask"], ["\n", "molded_images", "=", "[", "]", "\n", "image_metas", "=", "[", "]", "\n", "windows", "=", "[", "]", "\n", "for", "image", "in", "images", ":", "\n", "# Resize image to fit the model expected size", "\n", "            ", "molded_image", ",", "window", ",", "scale", ",", "padding", ",", "crop", "=", "utils", ".", "resize_image", "(", "\n", "image", ",", "\n", "min_dim", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", ",", "\n", "max_dim", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", ",", "\n", "min_scale", "=", "self", ".", "config", ".", "IMAGE_MIN_SCALE", ",", "\n", "mode", "=", "self", ".", "config", ".", "IMAGE_RESIZE_MODE", ")", "\n", "molded_image", "=", "mold_image", "(", "molded_image", ")", "\n", "molded_image", "=", "molded_image", ".", "transpose", "(", "(", "3", ",", "2", ",", "0", ",", "1", ")", ")", "# [C, D, H, W]", "\n", "# Build image_meta", "\n", "image_meta", "=", "compose_image_meta", "(", "\n", "0", ",", "image", ".", "shape", ",", "window", ",", "\n", "np", ".", "zeros", "(", "[", "self", ".", "config", ".", "NUM_CLASSES", "]", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "# Append", "\n", "molded_images", ".", "append", "(", "molded_image", ")", "\n", "windows", ".", "append", "(", "window", ")", "\n", "image_metas", ".", "append", "(", "image_meta", ")", "\n", "# Pack into arrays", "\n", "", "molded_images", "=", "np", ".", "stack", "(", "molded_images", ")", "\n", "image_metas", "=", "np", ".", "stack", "(", "image_metas", ")", "\n", "windows", "=", "np", ".", "stack", "(", "windows", ")", "\n", "return", "molded_images", ",", "image_metas", ",", "windows", "\n", "\n", "", "def", "unmold_detections", "(", "self", ",", "detections", ",", "mrcnn_mask", ",", "image_shape", ",", "window", ")", ":", "\n", "        ", "\"\"\"Reformat the detections of one image from the format of the neural\n        network output to a format suitable for use in the rest of the application.\n        detections: [N, (z1, y1, x1, z2, y2, x2, class_id, score)]\n        mrcnn_mask: [N, depth, height, width, num_classes]\n        image_shape: [channels, depth, height, width] Original size of the image before resizing\n        window: [z1, y1, x1, z2, y2, x2] Box in the image where the real image is excluding the padding.\n        Returns:\n        boxes: [N, (y1, x1, z1, y2, x2, z2)] Bounding boxes in pixels\n        class_ids: [N] Integer class IDs for each bounding box\n        scores: [N] Float probability scores of the class_id\n        masks: [height, width, depth] normal shape full mask\n        \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "# How many detections do we have?", "\n", "# Detections array is padded with zeros. Find the first class_id == 0.", "\n", "zero_ix", "=", "np", ".", "where", "(", "detections", "[", ":", ",", "6", "]", "==", "0", ")", "[", "0", "]", "\n", "N", "=", "zero_ix", "[", "0", "]", "if", "zero_ix", ".", "shape", "[", "0", "]", ">", "0", "else", "detections", ".", "shape", "[", "0", "]", "\n", "\n", "# Extract boxes, class_ids, scores, and class-specific masks", "\n", "boxes", "=", "detections", "[", ":", "N", ",", ":", "6", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "class_ids", "=", "detections", "[", ":", "N", ",", "6", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "scores", "=", "detections", "[", ":", "N", ",", "7", "]", "\n", "masks", "=", "mrcnn_mask", "[", "np", ".", "arange", "(", "N", ")", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log": [[30, 41], ["print", "text.ljust.ljust", "str", "array.min", "array.max"], "function", ["None"], ["\n", "if", "array", "is", "not", "None", ":", "\n", "        ", "text", "=", "text", ".", "ljust", "(", "25", ")", "\n", "text", "+=", "(", "\"shape: {:20}  min: {:10.5f}  max: {:10.5f}\"", ".", "format", "(", "\n", "str", "(", "array", ".", "shape", ")", ",", "\n", "array", ".", "min", "(", ")", "if", "array", ".", "size", "else", "\"\"", ",", "\n", "array", ".", "max", "(", ")", "if", "array", ".", "size", "else", "\"\"", ")", ")", "\n", "", "print", "(", "text", ")", "\n", "\n", "\n", "", "def", "print_progress_bar", "(", "iteration", ",", "total", ",", "prefix", "=", "''", ",", "suffix", "=", "''", ",", "decimals", "=", "1", ",", "length", "=", "100", ",", "fill", "=", "''", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.print_progress_bar": [[43, 61], ["int", "print", "print", "float", "str"], "function", ["None"], ["\n", "percent", "=", "(", "\"{0:.\"", "+", "str", "(", "decimals", ")", "+", "\"f}\"", ")", ".", "format", "(", "100", "*", "(", "iteration", "/", "float", "(", "total", ")", ")", ")", "\n", "filled_length", "=", "int", "(", "length", "*", "iteration", "//", "total", ")", "\n", "bar", "=", "fill", "*", "filled_length", "+", "'-'", "*", "(", "length", "-", "filled_length", ")", "\n", "print", "(", "'\\r%s |%s| %s%% %s'", "%", "(", "prefix", ",", "bar", ",", "percent", ",", "suffix", ")", ",", "end", "=", "'\\n'", ")", "\n", "# Print New Line on Complete", "\n", "if", "iteration", "==", "total", ":", "\n", "        ", "print", "(", ")", "\n", "\n", "\n", "############################################################", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.unique1d": [[67, 78], ["torch.autograd.Variable", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tensor.sort", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor", "first_element.cuda.cuda", "torch.cat.detach", "tensor.size", "tensor.size"], "function", ["None"], ["        ", "return", "tensor", "\n", "", "tensor", "=", "tensor", ".", "sort", "(", ")", "[", "0", "]", "\n", "unique_bool", "=", "tensor", "[", "1", ":", "]", "!=", "tensor", "[", ":", "-", "1", "]", "\n", "first_element", "=", "Variable", "(", "torch", ".", "ByteTensor", "(", "[", "True", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "tensor", ".", "is_cuda", ":", "\n", "        ", "first_element", "=", "first_element", ".", "cuda", "(", ")", "\n", "", "unique_bool", "=", "torch", ".", "cat", "(", "(", "first_element", ",", "unique_bool", ")", ",", "dim", "=", "0", ")", "\n", "return", "tensor", "[", "unique_bool", ".", "detach", "(", ")", "]", "\n", "\n", "\n", "", "def", "intersect1d", "(", "tensor1", ",", "tensor2", ")", ":", "\n", "    ", "aux", "=", "torch", ".", "cat", "(", "(", "tensor1", ",", "tensor2", ")", ",", "dim", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.intersect1d": [[80, 85], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.sort"], "function", ["None"], ["return", "aux", "[", ":", "-", "1", "]", "[", "(", "aux", "[", "1", ":", "]", "==", "aux", "[", ":", "-", "1", "]", ")", ".", "detach", "(", ")", "]", "\n", "\n", "\n", "", "def", "log2", "(", "x", ")", ":", "\n", "    ", "\"\"\"Implementation of log2. Pytorch doesn't have a native implementation.\"\"\"", "\n", "ln2", "=", "torch", ".", "log", "(", "torch", ".", "FloatTensor", "(", "[", "2.0", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log2": [[87, 94], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "ln2.cuda.cuda", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log"], ["        ", "ln2", "=", "ln2", ".", "cuda", "(", ")", "\n", "", "return", "torch", ".", "log", "(", "x", ")", "/", "ln2", "\n", "\n", "\n", "", "def", "compute_backbone_shapes", "(", "config", ",", "image_shape", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_backbone_shapes": [[96, 108], ["numpy.array", "int", "int", "int", "math.ceil", "math.ceil", "math.ceil"], "function", ["None"], ["H", ",", "W", ",", "D", "=", "image_shape", "[", ":", "3", "]", "\n", "return", "np", ".", "array", "(", "\n", "[", "[", "int", "(", "math", ".", "ceil", "(", "D", "/", "stride", ")", ")", ",", "\n", "int", "(", "math", ".", "ceil", "(", "H", "/", "stride", ")", ")", ",", "\n", "int", "(", "math", ".", "ceil", "(", "W", "/", "stride", ")", ")", "]", "\n", "for", "stride", "in", "config", ".", "BACKBONE_STRIDES", "]", ")", "\n", "\n", "\n", "############################################################", "\n", "#  FPN Graph", "\n", "############################################################", "\n", "\n", "", "class", "TopDownLayer", "(", "nn", ".", "Module", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.apply_box_deltas": [[145, 174], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "function", ["None"], ["p3_out", "=", "self", ".", "P3_conv2", "(", "p3_out", ")", "\n", "p2_out", "=", "self", ".", "P2_conv2", "(", "p2_out", ")", "\n", "\n", "return", "[", "p2_out", ",", "p3_out", "]", "\n", "\n", "\n", "############################################################", "\n", "#  Proposal Layer", "\n", "############################################################", "\n", "\n", "", "", "def", "apply_box_deltas", "(", "boxes", ",", "deltas", ")", ":", "\n", "    ", "\"\"\"Applies the given deltas to the given boxes.\n    boxes: [N, 6] where each row is z1, y1, x1, z2, y2, x2\n    deltas: [N, 6] where each row is [dz, dy, dx, log(dd), log(dh), log(dw)]\n    \"\"\"", "\n", "# Convert to z, y, x, d, h, w", "\n", "depth", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "height", "=", "boxes", "[", ":", ",", "4", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "width", "=", "boxes", "[", ":", ",", "5", "]", "-", "boxes", "[", ":", ",", "2", "]", "\n", "center_z", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "depth", "\n", "center_y", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "height", "\n", "center_x", "=", "boxes", "[", ":", ",", "2", "]", "+", "0.5", "*", "width", "\n", "# Apply deltas", "\n", "center_z", "+=", "deltas", "[", ":", ",", "0", "]", "*", "depth", "\n", "center_y", "+=", "deltas", "[", ":", ",", "1", "]", "*", "height", "\n", "center_x", "+=", "deltas", "[", ":", ",", "2", "]", "*", "width", "\n", "depth", "*=", "torch", ".", "exp", "(", "deltas", "[", ":", ",", "3", "]", ")", "\n", "height", "*=", "torch", ".", "exp", "(", "deltas", "[", ":", ",", "4", "]", ")", "\n", "width", "*=", "torch", ".", "exp", "(", "deltas", "[", ":", ",", "5", "]", ")", "\n", "# Convert back to z1, y1, x1, z2, y2, x2", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.clip_boxes": [[176, 189], ["torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float"], "function", ["None"], ["y1", "=", "center_y", "-", "0.5", "*", "height", "\n", "x1", "=", "center_x", "-", "0.5", "*", "width", "\n", "z2", "=", "z1", "+", "depth", "\n", "y2", "=", "y1", "+", "height", "\n", "x2", "=", "x1", "+", "width", "\n", "result", "=", "torch", ".", "stack", "(", "[", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "]", ",", "dim", "=", "1", ")", "\n", "return", "result", "\n", "\n", "\n", "", "def", "clip_boxes", "(", "boxes", ",", "window", ")", ":", "\n", "    ", "\"\"\"boxes: [N, 6] each col is z1, y1, x1, z2, y2, x2\n    window: [6] in the form z1, y1, x1, z2, y2, x2\n    \"\"\"", "\n", "boxes", "=", "torch", ".", "stack", "(", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.proposal_layer": [[191, 251], ["inputs[].squeeze", "inputs[].squeeze", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "min", "scores.sort", "model.apply_box_deltas", "numpy.array().astype", "model.clip_boxes", "utils.non_max_suppression", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "normalized_boxes.unsqueeze.unsqueeze", "std_dev.cuda.cuda", "clip_boxes.cpu().detach().numpy", "scores.cpu().detach().numpy", "norm.cuda.cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "anchors.size", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.reshape", "order.detach", "order.detach", "clip_boxes.cpu().detach", "scores.cpu().detach", "numpy.array", "clip_boxes.cpu", "scores.cpu"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.apply_box_deltas", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.clip_boxes", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.non_max_suppression"], ["boxes", "[", ":", ",", "1", "]", ".", "clamp", "(", "float", "(", "window", "[", "1", "]", ")", ",", "float", "(", "window", "[", "4", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "2", "]", ".", "clamp", "(", "float", "(", "window", "[", "2", "]", ")", ",", "float", "(", "window", "[", "5", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "3", "]", ".", "clamp", "(", "float", "(", "window", "[", "0", "]", ")", ",", "float", "(", "window", "[", "3", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "4", "]", ".", "clamp", "(", "float", "(", "window", "[", "1", "]", ")", ",", "float", "(", "window", "[", "4", "]", ")", ")", ",", "\n", "boxes", "[", ":", ",", "5", "]", ".", "clamp", "(", "float", "(", "window", "[", "2", "]", ")", ",", "float", "(", "window", "[", "5", "]", ")", ")", "]", ",", "1", ")", "\n", "return", "boxes", "\n", "\n", "\n", "", "def", "proposal_layer", "(", "inputs", ",", "proposal_count", ",", "nms_threshold", ",", "anchors", ",", "config", "=", "None", ")", ":", "\n", "    ", "\"\"\"Receives anchor scores and selects a subset to pass as proposals\n    to the second stage. Filtering is done based on anchor scores and\n    non-max suppression to remove overlaps. It also applies bounding\n    box refinement deltas to anchors.\n    Inputs:\n        rpn_probs: [batch, anchors, (bg prob, fg prob)]\n        rpn_bbox: [batch, anchors, (dz, dy, dx, log(dd), log(dh), log(dw))]\n    Returns:\n        Proposals in normalized coordinates [batch, rois, (z1, y1, x1, z2, y2, x2)]\n    \"\"\"", "\n", "\n", "# Currently only supports batchsize 1", "\n", "inputs", "[", "0", "]", "=", "inputs", "[", "0", "]", ".", "squeeze", "(", "0", ")", "\n", "inputs", "[", "1", "]", "=", "inputs", "[", "1", "]", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Box Scores. Use the foreground class confidence. [Batch, num_rois, 1]", "\n", "scores", "=", "inputs", "[", "0", "]", "[", ":", ",", "1", "]", "\n", "\n", "# Box deltas [batch, num_rois, 6]", "\n", "deltas", "=", "inputs", "[", "1", "]", "\n", "std_dev", "=", "torch", ".", "from_numpy", "(", "np", ".", "reshape", "(", "config", ".", "RPN_BBOX_STD_DEV", ",", "[", "1", ",", "6", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "std_dev", "=", "std_dev", ".", "cuda", "(", ")", "\n", "", "deltas", "=", "deltas", "*", "std_dev", "\n", "\n", "# Improve performance by trimming to top anchors by score", "\n", "# and doing the rest on the smaller subset.", "\n", "pre_nms_limit", "=", "min", "(", "config", ".", "PRE_NMS_LIMIT", ",", "anchors", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "scores", ",", "order", "=", "scores", ".", "sort", "(", "descending", "=", "True", ")", "\n", "order", "=", "order", "[", ":", "pre_nms_limit", "]", "\n", "scores", "=", "scores", "[", ":", "pre_nms_limit", "]", "\n", "deltas", "=", "deltas", "[", "order", ".", "detach", "(", ")", ",", ":", "]", "\n", "anchors", "=", "anchors", "[", "order", ".", "detach", "(", ")", ",", ":", "]", "\n", "\n", "# Apply deltas to anchors to get refined anchors.", "\n", "# [batch, N, (z1, y1, x1, z2, y2, x2)]", "\n", "boxes", "=", "apply_box_deltas", "(", "anchors", ",", "deltas", ")", "\n", "\n", "# Clip to image boundaries. [batch, N, (z1, y1, x1, z2, y2, x2)]", "\n", "height", ",", "width", ",", "depth", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "window", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "depth", ",", "height", ",", "width", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "boxes", "=", "clip_boxes", "(", "boxes", ",", "window", ")", "\n", "\n", "# Non-max suppression", "\n", "keep", "=", "utils", ".", "non_max_suppression", "(", "boxes", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "scores", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "nms_threshold", ",", "proposal_count", ")", "\n", "keep", "=", "torch", ".", "from_numpy", "(", "keep", ")", ".", "long", "(", ")", "\n", "boxes", "=", "boxes", "[", "keep", ",", ":", "]", "\n", "\n", "# Normalize dimensions to range of 0 to 1.", "\n", "norm", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "depth", ",", "height", ",", "width", ",", "depth", ",", "height", ",", "width", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.RoI_Align": [[257, 282], ["utils.denorm_boxes_graph", "boxes[].floor", "boxes[].floor", "boxes[].floor", "boxes[].ceil", "boxes[].ceil", "boxes[].ceil", "boxes.long.long", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "range", "torch.zeros().cuda.cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "boxes.long.size", "torch.interpolate().cuda", "feature_map.size", "feature_map.size", "feature_map.size", "torch.interpolate", "boxes.long.size", "feature_map.size", "feature_map[].unsqueeze"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.denorm_boxes_graph"], ["\n", "return", "normalized_boxes", "\n", "\n", "\n", "############################################################", "\n", "#  ROIAlign Layer", "\n", "############################################################", "\n", "\n", "", "def", "RoI_Align", "(", "feature_map", ",", "pool_size", ",", "boxes", ")", ":", "\n", "    ", "\"\"\"Implementation of 3D RoI Align (actually it's just pooling rather than align).\n    feature_map: [channels, depth, height, width]. Generated from FPN.\n    pool_size: [D, H, W]. The shape of the output.\n    boxes: [num_boxes, (z1, y1, x1, z2, y2, x2)].\n    \"\"\"", "\n", "boxes", "=", "utils", ".", "denorm_boxes_graph", "(", "boxes", ",", "(", "feature_map", ".", "size", "(", ")", "[", "1", "]", ",", "feature_map", ".", "size", "(", ")", "[", "2", "]", ",", "feature_map", ".", "size", "(", ")", "[", "3", "]", ")", ")", "\n", "boxes", "[", ":", ",", "0", "]", "=", "boxes", "[", ":", ",", "0", "]", ".", "floor", "(", ")", "\n", "boxes", "[", ":", ",", "1", "]", "=", "boxes", "[", ":", ",", "1", "]", ".", "floor", "(", ")", "\n", "boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", ".", "floor", "(", ")", "\n", "boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", ".", "ceil", "(", ")", "\n", "boxes", "[", ":", ",", "4", "]", "=", "boxes", "[", ":", ",", "4", "]", ".", "ceil", "(", ")", "\n", "boxes", "[", ":", ",", "5", "]", "=", "boxes", "[", ":", ",", "5", "]", ".", "ceil", "(", ")", "\n", "boxes", "=", "boxes", ".", "long", "(", ")", "\n", "output", "=", "torch", ".", "zeros", "(", "(", "boxes", ".", "size", "(", ")", "[", "0", "]", ",", "feature_map", ".", "size", "(", ")", "[", "0", "]", ",", "pool_size", "[", "0", "]", ",", "pool_size", "[", "1", "]", ",", "pool_size", "[", "2", "]", ")", ")", ".", "cuda", "(", ")", "\n", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", ")", "[", "0", "]", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "output", "[", "i", "]", "=", "F", ".", "interpolate", "(", "(", "feature_map", "[", ":", ",", "boxes", "[", "i", "]", "[", "0", "]", ":", "boxes", "[", "i", "]", "[", "3", "]", ",", "boxes", "[", "i", "]", "[", "1", "]", ":", "boxes", "[", "i", "]", "[", "4", "]", ",", "boxes", "[", "i", "]", "[", "2", "]", ":", "boxes", "[", "i", "]", "[", "5", "]", "]", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.pyramid_roi_align": [[284, 362], ["boxes.chunk", "roi_level.clamp.round().int", "roi_level.clamp.clamp", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "range", "range", "range", "torch.cat.append", "level_boxes.detach.detach", "model.RoI_Align", "torch.cat.append", "len", "inputs[].squeeze", "len", "inputs[].squeeze", "model.log2", "roi_level.clamp.round", "ix.any", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "ix.detach", "ix.detach"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.RoI_Align", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log2"], ["", "except", ":", "\n", "            ", "print", "(", "\"RoI_Align error!\"", ")", "\n", "print", "(", "\"box:\"", ",", "boxes", "[", "i", "]", ",", "\"feature_map size:\"", ",", "feature_map", ".", "size", "(", ")", ")", "\n", "pass", "\n", "\n", "", "", "return", "output", ".", "cuda", "(", ")", "\n", "\n", "\n", "", "def", "pyramid_roi_align", "(", "inputs", ",", "pool_size", ",", "test_flag", "=", "False", ")", ":", "\n", "    ", "\"\"\"Implements ROI Pooling on multiple levels of the feature pyramid.\n    Params:\n    - pool_size: [depth, height, width] of the output pooled regions. Usually [7, 7, 7]\n    - image_shape: [height, width, depth, channels]. Shape of input image in pixels\n    Inputs:\n    - boxes: [batch, num_boxes, (z1, y1, x1, z2, y2, x2)] in normalized coordinates.\n    - Feature maps: List of feature maps from different levels of the pyramid.\n                    Each is [batch, channels, depth, height, width]\n    Output:\n    Pooled regions in the shape: [num_boxes, channels, depth, height, width].\n    The width, height and depth are those specific in the pool_shape in the layer\n    constructor.\n    \"\"\"", "\n", "\n", "# Currently only supports batchsize 1", "\n", "if", "test_flag", ":", "\n", "        ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "inputs", ")", ")", ":", "\n", "            ", "inputs", "[", "i", "]", "=", "inputs", "[", "i", "]", ".", "squeeze", "(", "0", ")", "\n", "", "", "else", ":", "\n", "        ", "for", "i", "in", "range", "(", "1", ",", "len", "(", "inputs", ")", ")", ":", "\n", "            ", "inputs", "[", "i", "]", "=", "inputs", "[", "i", "]", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Crop boxes [batch, num_boxes, (y1, x1, z1, y2, x2, z2)] in normalized coordinates", "\n", "", "", "boxes", "=", "inputs", "[", "0", "]", "\n", "# Feature Maps. List of feature maps from different level of the", "\n", "# feature pyramid. Each is [batch, channels, depth, height, width]", "\n", "feature_maps", "=", "inputs", "[", "1", ":", "]", "\n", "\n", "# Assign each ROI to a level in the pyramid based on the ROI volume.", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "boxes", ".", "chunk", "(", "6", ",", "dim", "=", "1", ")", "\n", "d", "=", "z2", "-", "z1", "\n", "h", "=", "y2", "-", "y1", "\n", "w", "=", "x2", "-", "x1", "\n", "\n", "# Equation 1 in the Feature Pyramid Networks paper.", "\n", "# Account for the fact that our coordinates are normalized here.", "\n", "# TODO: change the equation here", "\n", "roi_level", "=", "4", "+", "(", "1.", "/", "3.", ")", "*", "log2", "(", "h", "*", "w", "*", "d", ")", "\n", "roi_level", "=", "roi_level", ".", "round", "(", ")", ".", "int", "(", ")", "\n", "roi_level", "=", "roi_level", ".", "clamp", "(", "2", ",", "3", ")", "\n", "\n", "# Loop through levels and apply ROI pooling to P2 or P3.", "\n", "pooled", "=", "[", "]", "\n", "box_to_level", "=", "[", "]", "\n", "for", "i", ",", "level", "in", "enumerate", "(", "range", "(", "2", ",", "4", ")", ")", ":", "\n", "        ", "ix", "=", "(", "roi_level", "==", "level", ")", "\n", "if", "not", "ix", ".", "any", "(", ")", ":", "\n", "            ", "continue", "\n", "", "ix", "=", "torch", ".", "nonzero", "(", "ix", ")", "[", ":", ",", "0", "]", "\n", "level_boxes", "=", "boxes", "[", "ix", ".", "detach", "(", ")", ",", ":", "]", "\n", "\n", "# Keep track of which box is mapped to which level", "\n", "box_to_level", ".", "append", "(", "ix", ".", "detach", "(", ")", ")", "\n", "\n", "# Stop gradient propagation to ROI proposals", "\n", "level_boxes", "=", "level_boxes", ".", "detach", "(", ")", "\n", "\n", "# Crop and Resize", "\n", "# From Mask R-CNN paper: \"We sample four regular locations, so that we can evaluate", "\n", "# either max or average pooling. In fact, interpolating only a single value at each bin center", "\n", "# (without pooling) is nearly as effective.\"", "\n", "# Here we use the simplified approach of a single value per bin.", "\n", "# Result: [batch * num_boxes, channels, pool_depth, pool_height, pool_width]", "\n", "pooled_features", "=", "RoI_Align", "(", "feature_maps", "[", "i", "]", ",", "pool_size", ",", "level_boxes", ")", "\n", "pooled", ".", "append", "(", "pooled_features", ")", "\n", "\n", "# Pack pooled features into one tensor", "\n", "", "pooled", "=", "torch", ".", "cat", "(", "pooled", ",", "dim", "=", "0", ")", "\n", "\n", "# Pack box_to_level mapping into one array and add another", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.bbox_overlaps": [[368, 403], ["boxes1.repeat().view.repeat().view", "boxes2.repeat.repeat", "boxes1.repeat().view.chunk", "boxes2.repeat.chunk", "torch.autograd.Variable", "iou.view", "boxes2.repeat.size", "boxes1.repeat().view.size", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "boxes1.repeat().view.repeat", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "z1.size"], "function", ["None"], ["pooled", "=", "pooled", "[", "box_to_level", ",", ":", ",", ":", ",", ":", "]", "\n", "\n", "return", "pooled", "\n", "\n", "\n", "############################################################", "\n", "#  Detection Target Layer", "\n", "############################################################", "\n", "\n", "", "def", "bbox_overlaps", "(", "boxes1", ",", "boxes2", ")", ":", "\n", "    ", "\"\"\"Computes IoU overlaps between two sets of boxes.\n    boxes1, boxes2: [N, (z1, y1, x1, z2, y2, x2)].\n    \"\"\"", "\n", "# 1. Tile boxes2 and repeat boxes1. This allows us to compare", "\n", "# every boxes1 against every boxes2 without loops.", "\n", "boxes1_repeat", "=", "boxes2", ".", "size", "(", ")", "[", "0", "]", "\n", "boxes2_repeat", "=", "boxes1", ".", "size", "(", ")", "[", "0", "]", "\n", "boxes1", "=", "boxes1", ".", "repeat", "(", "1", ",", "boxes1_repeat", ")", ".", "view", "(", "-", "1", ",", "6", ")", "\n", "boxes2", "=", "boxes2", ".", "repeat", "(", "boxes2_repeat", ",", "1", ")", "\n", "\n", "# 2. Compute intersections", "\n", "b1_z1", ",", "b1_y1", ",", "b1_x1", ",", "b1_z2", ",", "b1_y2", ",", "b1_x2", "=", "boxes1", ".", "chunk", "(", "6", ",", "dim", "=", "1", ")", "\n", "b2_z1", ",", "b2_y1", ",", "b2_x1", ",", "b2_z2", ",", "b2_y2", ",", "b2_x2", "=", "boxes2", ".", "chunk", "(", "6", ",", "dim", "=", "1", ")", "\n", "z1", "=", "torch", ".", "max", "(", "b1_z1", ",", "b2_z1", ")", "[", ":", ",", "0", "]", "\n", "y1", "=", "torch", ".", "max", "(", "b1_y1", ",", "b2_y1", ")", "[", ":", ",", "0", "]", "\n", "x1", "=", "torch", ".", "max", "(", "b1_x1", ",", "b2_x1", ")", "[", ":", ",", "0", "]", "\n", "z2", "=", "torch", ".", "min", "(", "b1_z2", ",", "b2_z2", ")", "[", ":", ",", "0", "]", "\n", "y2", "=", "torch", ".", "min", "(", "b1_y2", ",", "b2_y2", ")", "[", ":", ",", "0", "]", "\n", "x2", "=", "torch", ".", "min", "(", "b1_x2", ",", "b2_x2", ")", "[", ":", ",", "0", "]", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "z1", ".", "size", "(", ")", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "z1", ".", "is_cuda", ":", "\n", "        ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "intersection", "=", "torch", ".", "max", "(", "x2", "-", "x1", ",", "zeros", ")", "*", "torch", ".", "max", "(", "y2", "-", "y1", ",", "zeros", ")", "*", "torch", ".", "max", "(", "z2", "-", "z1", ",", "zeros", ")", "\n", "\n", "# 3. Compute unions", "\n", "b1_volume", "=", "(", "b1_z2", "-", "b1_z1", ")", "*", "(", "b1_y2", "-", "b1_y1", ")", "*", "(", "b1_x2", "-", "b1_x1", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.detection_target_layer": [[405, 555], ["proposals.squeeze.squeeze", "gt_class_ids.squeeze.squeeze", "gt_boxes.squeeze.squeeze", "gt_masks.squeeze.squeeze", "model.bbox_overlaps", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "int", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.autograd.Variable", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "numpy.zeros", "range", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "roi_gt_masks.type.type", "int", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.autograd.Variable().long", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.autograd.Variable", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.autograd.Variable", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "round", "rand_idx.cuda.cuda", "positive_indices.size", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "utils.box_refinement", "std_dev.cuda.cuda", "int", "int", "int", "int", "int", "int", "gt_masks[].cpu().numpy", "skimage.transform.resize", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "round", "rand_idx.cuda.cuda", "negative_indices.size", "zeros.cuda.cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "positive_indices.size", "roi_gt_box_assignment.detach", "positive_rois.cuda.detach", "roi_gt_boxes.detach", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "negative_indices.size", "torch.autograd.Variable", "roi_gt_class_ids.cuda.long", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable().int", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "positive_indices.detach", "positive_indices.detach", "roi_gt_box_assignment.detach", "gt_masks[].cpu", "negative_indices.detach", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "positive_rois.cuda.cuda", "zeros.cuda.cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "positive_rois.cuda.cuda", "rois.cuda.cuda", "roi_gt_class_ids.cuda.cuda", "deltas.cuda.cuda", "masks.cuda.cuda", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.autograd.Variable", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.bbox_overlaps", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.box_refinement", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["union", "=", "b1_volume", "[", ":", ",", "0", "]", "+", "b2_volume", "[", ":", ",", "0", "]", "-", "intersection", "\n", "\n", "# 4. Compute IoU and reshape to [boxes1, boxes2]", "\n", "iou", "=", "intersection", "/", "union", "\n", "overlaps", "=", "iou", ".", "view", "(", "boxes2_repeat", ",", "boxes1_repeat", ")", "\n", "\n", "return", "overlaps", "\n", "\n", "\n", "", "def", "detection_target_layer", "(", "proposals", ",", "gt_class_ids", ",", "gt_boxes", ",", "gt_masks", ",", "config", ")", ":", "\n", "    ", "\"\"\"Subsamples proposals and generates target box refinement, class_ids,\n    and masks for each.\n    Inputs:\n    proposals: [batch, N, (z1, y1, x1, z2, y2, x2)] in normalized coordinates. Might\n               be zero padded if there are not enough proposals.\n    gt_class_ids: [batch, MAX_GT_INSTANCES] Integer class IDs.\n    gt_boxes: [batch, MAX_GT_INSTANCES, (z1, y1, x1, z2, y2, x2)] in normalized\n              coordinates.\n    gt_masks: [batch, MAX_GT_INSTANCES, depth, height, width] of np.int32 type\n    Returns: Target ROIs and corresponding class IDs, bounding box shifts,\n    and masks.\n    rois: [batch, TRAIN_ROIS_PER_IMAGE, (z1, y1, x1, z2, y2, x2)] in normalized coordinates\n    target_class_ids: [batch, TRAIN_ROIS_PER_IMAGE]. Integer class IDs.\n    target_deltas: [batch, TRAIN_ROIS_PER_IMAGE, NUM_CLASSES,\n                    (dz, dy, dx, log(dd), log(dh), log(dw), class_id)]\n                   Class-specific bbox refinements.\n    target_mask: [batch, TRAIN_ROIS_PER_IMAGE, depth, height, width)\n                 Masks cropped to bbox boundaries and resized to neural\n                 network output size.\n    \"\"\"", "\n", "\n", "# Currently only supports batchsize 1", "\n", "proposals", "=", "proposals", ".", "squeeze", "(", "0", ")", "\n", "gt_class_ids", "=", "gt_class_ids", ".", "squeeze", "(", "0", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "squeeze", "(", "0", ")", "\n", "gt_masks", "=", "gt_masks", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Compute overlaps matrix [proposals, gt_boxes]", "\n", "overlaps", "=", "bbox_overlaps", "(", "proposals", ",", "gt_boxes", ")", "\n", "\n", "# Determine positive and negative ROIs", "\n", "roi_iou_max", "=", "torch", ".", "max", "(", "overlaps", ",", "dim", "=", "1", ")", "[", "0", "]", "\n", "print", "(", "\"rpn_roi_iou_max:\"", ",", "roi_iou_max", ".", "max", "(", ")", ")", "\n", "\n", "# 1. Positive ROIs are those with >= 0.5 IoU with a GT box", "\n", "positive_roi_bool", "=", "roi_iou_max", ">=", "config", ".", "DETECTION_TARGET_IOU_THRESHOLD", "\n", "\n", "# Subsample ROIs. Aim for 33% positive", "\n", "# Positive ROIs", "\n", "if", "torch", ".", "nonzero", "(", "positive_roi_bool", ")", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "        ", "positive_indices", "=", "torch", ".", "nonzero", "(", "positive_roi_bool", ")", "[", ":", ",", "0", "]", "\n", "\n", "positive_count", "=", "int", "(", "config", ".", "TRAIN_ROIS_PER_IMAGE", "*", "\n", "config", ".", "ROI_POSITIVE_RATIO", ")", "\n", "rand_idx", "=", "torch", ".", "randperm", "(", "positive_indices", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "rand_idx", "=", "rand_idx", "[", ":", "positive_count", "]", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "rand_idx", "=", "rand_idx", ".", "cuda", "(", ")", "\n", "", "positive_indices", "=", "positive_indices", "[", "rand_idx", "]", "\n", "positive_count", "=", "positive_indices", ".", "size", "(", ")", "[", "0", "]", "\n", "positive_rois", "=", "proposals", "[", "positive_indices", ".", "detach", "(", ")", ",", ":", "]", "\n", "# Assign positive ROIs to GT boxes.", "\n", "positive_overlaps", "=", "overlaps", "[", "positive_indices", ".", "detach", "(", ")", ",", ":", "]", "\n", "roi_gt_box_assignment", "=", "torch", ".", "max", "(", "positive_overlaps", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "roi_gt_boxes", "=", "gt_boxes", "[", "roi_gt_box_assignment", ".", "detach", "(", ")", ",", ":", "]", "\n", "roi_gt_class_ids", "=", "gt_class_ids", "[", "roi_gt_box_assignment", ".", "detach", "(", ")", "]", "\n", "\n", "# Compute bbox refinement for positive ROIs", "\n", "deltas", "=", "Variable", "(", "utils", ".", "box_refinement", "(", "positive_rois", ".", "detach", "(", ")", ",", "roi_gt_boxes", ".", "detach", "(", ")", ")", ",", "requires_grad", "=", "False", ")", "\n", "std_dev", "=", "torch", ".", "from_numpy", "(", "config", ".", "BBOX_STD_DEV", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "std_dev", "=", "std_dev", ".", "cuda", "(", ")", "\n", "", "deltas", "/=", "std_dev", "\n", "# Assign positive ROIs to GT masks", "\n", "# Permute masks to [N, depth, height, width]", "\n", "# Pick the right mask for each ROI", "\n", "roi_gt_masks", "=", "np", ".", "zeros", "(", "(", "positive_rois", ".", "shape", "[", "0", "]", ",", "8", ",", ")", "+", "config", ".", "MASK_SHAPE", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "positive_rois", ".", "shape", "[", "0", "]", ")", ":", "\n", "             ", "z1", "=", "int", "(", "gt_masks", ".", "shape", "[", "1", "]", "*", "positive_rois", "[", "i", ",", "0", "]", ")", "\n", "z2", "=", "int", "(", "gt_masks", ".", "shape", "[", "1", "]", "*", "positive_rois", "[", "i", ",", "3", "]", ")", "\n", "y1", "=", "int", "(", "gt_masks", ".", "shape", "[", "2", "]", "*", "positive_rois", "[", "i", ",", "1", "]", ")", "\n", "y2", "=", "int", "(", "gt_masks", ".", "shape", "[", "2", "]", "*", "positive_rois", "[", "i", ",", "4", "]", ")", "\n", "x1", "=", "int", "(", "gt_masks", ".", "shape", "[", "3", "]", "*", "positive_rois", "[", "i", ",", "2", "]", ")", "\n", "x2", "=", "int", "(", "gt_masks", ".", "shape", "[", "3", "]", "*", "positive_rois", "[", "i", ",", "5", "]", ")", "\n", "crop_mask", "=", "gt_masks", "[", ":", ",", "z1", ":", "z2", ",", "y1", ":", "y2", ",", "x1", ":", "x2", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "crop_mask", "=", "utils", ".", "resize", "(", "crop_mask", ",", "(", "8", ",", ")", "+", "config", ".", "MASK_SHAPE", ",", "order", "=", "0", ",", "preserve_range", "=", "True", ")", "\n", "roi_gt_masks", "[", "i", ",", ":", ",", ":", ",", ":", ",", ":", "]", "=", "crop_mask", "\n", "", "roi_gt_masks", "=", "torch", ".", "from_numpy", "(", "roi_gt_masks", ")", ".", "cuda", "(", ")", "\n", "roi_gt_masks", "=", "roi_gt_masks", ".", "type", "(", "torch", ".", "DoubleTensor", ")", "\n", "", "else", ":", "\n", "        ", "positive_count", "=", "0", "\n", "\n", "# 2. Negative ROIs are those with < 0.5 with every GT box.", "\n", "", "negative_roi_bool", "=", "roi_iou_max", "<", "config", ".", "DETECTION_TARGET_IOU_THRESHOLD", "\n", "negative_roi_bool", "=", "negative_roi_bool", "\n", "# Negative ROIs. Add enough to maintain positive:negative ratio.", "\n", "if", "torch", ".", "nonzero", "(", "negative_roi_bool", ")", ".", "size", "(", ")", "[", "0", "]", "!=", "0", "and", "positive_count", ">", "0", ":", "\n", "        ", "negative_indices", "=", "torch", ".", "nonzero", "(", "negative_roi_bool", ")", "[", ":", ",", "0", "]", "\n", "r", "=", "1.0", "/", "config", ".", "ROI_POSITIVE_RATIO", "\n", "negative_count", "=", "int", "(", "r", "*", "positive_count", "-", "positive_count", ")", "\n", "rand_idx", "=", "torch", ".", "randperm", "(", "negative_indices", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "rand_idx", "=", "rand_idx", "[", ":", "negative_count", "]", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "rand_idx", "=", "rand_idx", ".", "cuda", "(", ")", "\n", "", "negative_indices", "=", "negative_indices", "[", "rand_idx", "]", "\n", "negative_count", "=", "negative_indices", ".", "size", "(", ")", "[", "0", "]", "\n", "negative_rois", "=", "proposals", "[", "negative_indices", ".", "detach", "(", ")", ",", ":", "]", "\n", "", "else", ":", "\n", "        ", "negative_count", "=", "0", "\n", "\n", "# Append negative ROIs and pad bbox deltas and masks that", "\n", "# are not used for negative ROIs with zeros.", "\n", "", "if", "positive_count", ">", "0", "and", "negative_count", ">", "0", ":", "\n", "        ", "rois", "=", "torch", ".", "cat", "(", "(", "positive_rois", ",", "negative_rois", ")", ",", "dim", "=", "0", ")", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ")", ",", "requires_grad", "=", "False", ")", ".", "long", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "roi_gt_class_ids", "=", "torch", ".", "cat", "(", "[", "roi_gt_class_ids", ".", "long", "(", ")", ",", "zeros", "]", ",", "dim", "=", "0", ")", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ",", "6", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "deltas", "=", "torch", ".", "cat", "(", "[", "deltas", ",", "zeros", "]", ",", "dim", "=", "0", ")", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ",", "config", ".", "MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MASK_SHAPE", "[", "1", "]", ",", "config", ".", "MASK_SHAPE", "[", "2", "]", ")", ",", "\n", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "masks", "=", "roi_gt_masks", "\n", "", "elif", "positive_count", ">", "0", ":", "\n", "        ", "rois", "=", "positive_rois", "\n", "", "elif", "negative_count", ">", "0", ":", "\n", "        ", "positive_rois", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "rois", "=", "negative_rois", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "positive_rois", "=", "positive_rois", ".", "cuda", "(", ")", "\n", "", "roi_gt_class_ids", "=", "zeros", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ",", "6", ")", ",", "requires_grad", "=", "False", ")", ".", "int", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "deltas", "=", "zeros", "\n", "zeros", "=", "Variable", "(", "torch", ".", "zeros", "(", "negative_count", ",", "config", ".", "MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MASK_SHAPE", "[", "1", "]", ",", "config", ".", "MASK_SHAPE", "[", "2", "]", ")", ",", "\n", "requires_grad", "=", "False", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "", "masks", "=", "zeros", "\n", "", "else", ":", "\n", "        ", "positive_rois", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "rois", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "roi_gt_class_ids", "=", "Variable", "(", "torch", ".", "IntTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "deltas", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", ")", ",", "requires_grad", "=", "False", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.clip_to_window": [[561, 573], ["boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "boxes[].clamp", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float"], "function", ["None"], ["deltas", "=", "deltas", ".", "cuda", "(", ")", "\n", "masks", "=", "masks", ".", "cuda", "(", ")", "\n", "", "", "return", "positive_rois", ",", "rois", ",", "roi_gt_class_ids", ",", "deltas", ",", "masks", "\n", "\n", "\n", "############################################################", "\n", "#  Detection Layer", "\n", "############################################################", "\n", "\n", "", "def", "clip_to_window", "(", "window", ",", "boxes", ")", ":", "\n", "    ", "\"\"\"window: (z1, y1, x1, z2, y2, x2). The window in the image we want to clip to.\n        boxes: [N, (z1, y1, x1, z2, y2, x2)]\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.refine_detections": [[575, 677], ["torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.apply_box_deltas", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "model.clip_to_window", "torch.round", "torch.round", "torch.round", "torch.round", "torch.round", "enumerate", "model.intersect1d", "min", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "idx.cuda.cuda", "std_dev.cuda.cuda", "scale.cuda.cuda", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "model.unique1d", "ix_scores.sort", "utils.non_max_suppression", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "intersect1d.detach", "intersect1d.detach", "intersect1d.detach", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "ix_rois.cpu().detach().numpy", "ix_scores.cpu().detach().numpy", "model.unique1d", "intersect1d.size", "class_scores[].sort", "top_ids.detach", "class_ids[].unsqueeze().float", "class_scores[].unsqueeze", "class_ids.detach", "class_ids.detach", "numpy.reshape", "numpy.array", "ixs.detach", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "ixs[].detach", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "class_ids.size", "order.detach", "ix_rois.cpu().detach", "ix_scores.cpu().detach", "intersect1d.detach", "class_ids[].unsqueeze", "ix_rois.cpu", "ix_scores.cpu", "intersect1d.detach", "intersect1d.detach", "order[].detach", "intersect1d.detach"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.apply_box_deltas", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.clip_to_window", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.intersect1d", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.unique1d", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.non_max_suppression", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.unique1d"], ["boxes", "[", ":", ",", "1", "]", "=", "boxes", "[", ":", ",", "1", "]", ".", "clamp", "(", "float", "(", "window", "[", "1", "]", ")", ",", "float", "(", "window", "[", "4", "]", ")", ")", "\n", "boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", ".", "clamp", "(", "float", "(", "window", "[", "2", "]", ")", ",", "float", "(", "window", "[", "5", "]", ")", ")", "\n", "boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", ".", "clamp", "(", "float", "(", "window", "[", "0", "]", ")", ",", "float", "(", "window", "[", "3", "]", ")", ")", "\n", "boxes", "[", ":", ",", "4", "]", "=", "boxes", "[", ":", ",", "4", "]", ".", "clamp", "(", "float", "(", "window", "[", "1", "]", ")", ",", "float", "(", "window", "[", "4", "]", ")", ")", "\n", "boxes", "[", ":", ",", "5", "]", "=", "boxes", "[", ":", ",", "5", "]", ".", "clamp", "(", "float", "(", "window", "[", "2", "]", ")", ",", "float", "(", "window", "[", "5", "]", ")", ")", "\n", "\n", "return", "boxes", "\n", "\n", "\n", "", "def", "refine_detections", "(", "rois", ",", "probs", ",", "deltas", ",", "window", ",", "config", ")", ":", "\n", "    ", "\"\"\"Refine classified proposals and filter overlaps and return final\n    detections.\n    Inputs:\n        rois: [N, (z1, y1, x1, z2, y2, x2)] in normalized coordinates\n        probs: [N, num_classes]. Class probabilities.\n        deltas: [N, num_classes, (dz, dy, dx, log(dd), log(dh), log(dw))]. Class-specific\n                bounding box deltas.\n        window: (z1, y1, x1, z2, y2, x2) in image coordinates. The part of the image\n            that contains the image excluding the padding.\n    Returns detections shaped: [N, (z1, y1, x1, z2, y2, x2, class_id, score)]\n    \"\"\"", "\n", "\n", "# Class IDs per ROI", "\n", "_", ",", "class_ids", "=", "torch", ".", "max", "(", "probs", ",", "dim", "=", "1", ")", "\n", "\n", "# Class probability of the top class of each ROI", "\n", "# Class-specific bounding box deltas", "\n", "idx", "=", "torch", ".", "arange", "(", "class_ids", ".", "size", "(", ")", "[", "0", "]", ")", ".", "long", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "idx", "=", "idx", ".", "cuda", "(", ")", "\n", "", "class_scores", "=", "probs", "[", "idx", ",", "class_ids", ".", "detach", "(", ")", "]", "\n", "deltas_specific", "=", "deltas", "[", "idx", ",", "class_ids", ".", "detach", "(", ")", "]", "\n", "\n", "# Apply bounding box deltas", "\n", "# Shape: [boxes, (z1, y1, x1, z2, y2, x2)] in normalized coordinates", "\n", "std_dev", "=", "torch", ".", "from_numpy", "(", "np", ".", "reshape", "(", "config", ".", "RPN_BBOX_STD_DEV", ",", "[", "1", ",", "6", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "std_dev", "=", "std_dev", ".", "cuda", "(", ")", "\n", "", "refined_rois", "=", "apply_box_deltas", "(", "rois", ",", "deltas_specific", "*", "std_dev", ")", "\n", "\n", "# Convert coordinates to image domain", "\n", "height", ",", "width", ",", "depth", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "3", "]", "\n", "scale", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "depth", ",", "height", ",", "width", ",", "depth", ",", "height", ",", "width", "]", ")", ")", ".", "float", "(", ")", "\n", "if", "config", ".", "GPU_COUNT", ":", "\n", "        ", "scale", "=", "scale", ".", "cuda", "(", ")", "\n", "", "refined_rois", "*=", "scale", "\n", "\n", "# Clip boxes to image window", "\n", "refined_rois", "=", "clip_to_window", "(", "window", ",", "refined_rois", ")", "\n", "\n", "# Round and cast to int since we're dealing with pixels now", "\n", "refined_rois", "=", "torch", ".", "round", "(", "refined_rois", ")", "\n", "\n", "# Filter out background boxes", "\n", "keep_bool", "=", "class_ids", ">", "0", "\n", "\n", "# Filter out low confidence boxes", "\n", "if", "config", ".", "DETECTION_MIN_CONFIDENCE", ":", "\n", "        ", "keep_bool", "=", "keep_bool", "&", "(", "class_scores", ">=", "config", ".", "DETECTION_MIN_CONFIDENCE", ")", "\n", "", "keep", "=", "torch", ".", "nonzero", "(", "keep_bool", ")", "[", ":", ",", "0", "]", "\n", "\n", "# Apply per-class NMS", "\n", "pre_nms_class_ids", "=", "class_ids", "[", "keep", ".", "detach", "(", ")", "]", "\n", "pre_nms_scores", "=", "class_scores", "[", "keep", ".", "detach", "(", ")", "]", "\n", "pre_nms_rois", "=", "refined_rois", "[", "keep", ".", "detach", "(", ")", "]", "\n", "\n", "for", "i", ",", "class_id", "in", "enumerate", "(", "unique1d", "(", "pre_nms_class_ids", ")", ")", ":", "\n", "# Pick detections of this class", "\n", "        ", "ixs", "=", "torch", ".", "nonzero", "(", "pre_nms_class_ids", "==", "class_id", ")", "[", ":", ",", "0", "]", "\n", "\n", "# Sort", "\n", "ix_rois", "=", "pre_nms_rois", "[", "ixs", ".", "detach", "(", ")", "]", "\n", "ix_scores", "=", "pre_nms_scores", "[", "ixs", "]", "\n", "ix_scores", ",", "order", "=", "ix_scores", ".", "sort", "(", "descending", "=", "True", ")", "\n", "ix_rois", "=", "ix_rois", "[", "order", ".", "detach", "(", ")", ",", ":", "]", "\n", "\n", "class_keep", "=", "utils", ".", "non_max_suppression", "(", "ix_rois", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "ix_scores", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "config", ".", "DETECTION_NMS_THRESHOLD", ",", "config", ".", "DETECTION_MAX_INSTANCES", ")", "\n", "class_keep", "=", "torch", ".", "from_numpy", "(", "class_keep", ")", ".", "long", "(", ")", "\n", "\n", "# Map indices", "\n", "class_keep", "=", "keep", "[", "ixs", "[", "order", "[", "class_keep", "]", ".", "detach", "(", ")", "]", ".", "detach", "(", ")", "]", "\n", "\n", "if", "i", "==", "0", ":", "\n", "            ", "nms_keep", "=", "class_keep", "\n", "", "else", ":", "\n", "            ", "nms_keep", "=", "unique1d", "(", "torch", ".", "cat", "(", "(", "nms_keep", ",", "class_keep", ")", ")", ")", "\n", "", "", "keep", "=", "intersect1d", "(", "keep", ",", "nms_keep", ")", "\n", "\n", "# Keep top detections", "\n", "roi_count", "=", "config", ".", "DETECTION_MAX_INSTANCES", "\n", "roi_count", "=", "min", "(", "roi_count", ",", "keep", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "top_ids", "=", "class_scores", "[", "keep", ".", "detach", "(", ")", "]", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "[", ":", "roi_count", "]", "\n", "keep", "=", "keep", "[", "top_ids", ".", "detach", "(", ")", "]", "\n", "\n", "# Arrange output as [N, (z1, y1, x1, z2, y2, x2, class_id, score)]", "\n", "# Coordinates are in image domain.", "\n", "result", "=", "torch", ".", "cat", "(", "(", "refined_rois", "[", "keep", ".", "detach", "(", ")", "]", ",", "\n", "class_ids", "[", "keep", ".", "detach", "(", ")", "]", ".", "unsqueeze", "(", "1", ")", ".", "float", "(", ")", ",", "\n", "class_scores", "[", "keep", ".", "detach", "(", ")", "]", ".", "unsqueeze", "(", "1", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.detection_layer": [[679, 693], ["rois.squeeze.squeeze", "model.parse_image_meta", "model.refine_detections"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.parse_image_meta", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.refine_detections"], ["", "def", "detection_layer", "(", "config", ",", "rois", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "image_meta", ")", ":", "\n", "    ", "\"\"\"Takes classified proposal boxes and their bounding box deltas and\n    returns the final detection boxes.\n    Returns:\n    [batch, num_detections, (z1, y1, x1, z2, y2, x2, class_score)] in pixels\n    \"\"\"", "\n", "\n", "# Currently only supports batchsize 1", "\n", "rois", "=", "rois", ".", "squeeze", "(", "0", ")", "\n", "\n", "_", ",", "_", ",", "window", ",", "_", "=", "parse_image_meta", "(", "image_meta", ")", "\n", "window", "=", "window", "[", "0", "]", "\n", "detections", "=", "refine_detections", "(", "rois", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "window", ",", "config", ")", "\n", "\n", "return", "detections", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_rpn_class_loss": [[809, 834], ["rpn_match.squeeze.squeeze", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.cross_entropy", "torch.nonzero.detach", "torch.nonzero.detach", "torch.nonzero.detach", "torch.nonzero.detach"], "function", ["None"], ["    ", "\"\"\"RPN anchor classifier loss.\n    rpn_match: [batch, anchors, 1]. Anchor match type. 1=positive,\n               -1=negative, 0=neutral anchor.\n    rpn_class_logits: [batch, anchors, 2]. RPN classifier logits for FG/BG.\n    \"\"\"", "\n", "\n", "# Squeeze last dim to simplify", "\n", "rpn_match", "=", "rpn_match", ".", "squeeze", "(", "2", ")", "\n", "\n", "# Get anchor classes. Convert the -1/+1 match to 0/1 values.", "\n", "anchor_class", "=", "(", "rpn_match", "==", "1", ")", ".", "long", "(", ")", "\n", "\n", "# Positive and Negative anchors contribute to the loss,", "\n", "# but neutral anchors (match value = 0) don't.", "\n", "indices", "=", "torch", ".", "nonzero", "(", "rpn_match", "!=", "0", ")", "\n", "\n", "# Pick rows that contribute to the loss and filter out the rest.", "\n", "rpn_class_logits", "=", "rpn_class_logits", "[", "indices", ".", "detach", "(", ")", "[", ":", ",", "0", "]", ",", "indices", ".", "detach", "(", ")", "[", ":", ",", "1", "]", ",", ":", "]", "\n", "anchor_class", "=", "anchor_class", "[", "indices", ".", "detach", "(", ")", "[", ":", ",", "0", "]", ",", "indices", ".", "detach", "(", ")", "[", ":", ",", "1", "]", "]", "\n", "\n", "# Cross-entropy loss", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "rpn_class_logits", ",", "anchor_class", ")", "\n", "\n", "return", "loss", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_rpn_bbox_loss": [[836, 861], ["rpn_match.squeeze.squeeze", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.smooth_l1_loss", "torch.nonzero.detach", "torch.nonzero.detach", "rpn_bbox.size"], "function", ["None"], ["    ", "\"\"\"Return the RPN bounding box loss graph.\n    target_bbox: [batch, max positive anchors, (dz, dy, dx, log(dd), log(dh), log(dw))].\n        Uses 0 padding to fill in unused bbox deltas.\n    rpn_match: [batch, anchors, 1]. Anchor match type. 1=positive,\n               -1=negative, 0=neutral anchor.\n    rpn_bbox: [batch, anchors, (dz, dy, dx, log(dd), log(dh), log(dw))]\n    \"\"\"", "\n", "\n", "# Squeeze last dim to simplify", "\n", "rpn_match", "=", "rpn_match", ".", "squeeze", "(", "2", ")", "\n", "\n", "# Positive anchors contribute to the loss, but negative and", "\n", "# neutral anchors (match value of 0 or -1) don't.", "\n", "indices", "=", "torch", ".", "nonzero", "(", "rpn_match", "==", "1", ")", "\n", "\n", "# Pick bbox deltas that contribute to the loss", "\n", "rpn_bbox", "=", "rpn_bbox", "[", "indices", ".", "detach", "(", ")", "[", ":", ",", "0", "]", ",", "indices", ".", "detach", "(", ")", "[", ":", ",", "1", "]", "]", "\n", "\n", "# Trim target bounding box deltas to the same length as rpn_bbox.", "\n", "target_bbox", "=", "target_bbox", "[", "0", ",", ":", "rpn_bbox", ".", "size", "(", ")", "[", "0", "]", ",", ":", "]", "\n", "\n", "# Smooth L1 loss", "\n", "loss", "=", "F", ".", "smooth_l1_loss", "(", "rpn_bbox", ",", "target_bbox", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_class_loss": [[863, 878], ["torch.cross_entropy", "torch.autograd.Variable", "target_class_ids.size", "target_class_ids.long", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "loss.cuda.cuda"], "function", ["None"], ["", "def", "compute_mrcnn_class_loss", "(", "target_class_ids", ",", "pred_class_logits", ")", ":", "\n", "    ", "\"\"\"Loss for the classifier head of Mask RCNN.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Uses zero\n        padding to fill in the array.\n    pred_class_logits: [batch, num_rois, num_classes]\n    \"\"\"", "\n", "\n", "# Loss", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "        ", "loss", "=", "F", ".", "cross_entropy", "(", "pred_class_logits", ",", "target_class_ids", ".", "long", "(", ")", ")", "\n", "", "else", ":", "\n", "        ", "loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "target_class_ids", ".", "is_cuda", ":", "\n", "            ", "loss", "=", "loss", ".", "cuda", "(", ")", "\n", "\n", "", "", "return", "loss", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_bbox_loss": [[880, 905], ["target_class_ids[].long", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.smooth_l1_loss", "torch.autograd.Variable", "target_class_ids.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "loss.cuda.cuda", "indices[].detach", "indices[].detach", "indices[].detach", "positive_roi_ix.detach"], "function", ["None"], ["\n", "", "def", "compute_mrcnn_bbox_loss", "(", "target_bbox", ",", "target_class_ids", ",", "pred_bbox", ")", ":", "\n", "    ", "\"\"\"Loss for Mask R-CNN bounding box refinement.\n    target_bbox: [batch, num_rois, (dz, dy, dx, log(dd), log(dh), log(dw))]\n    target_class_ids: [batch, num_rois]. Integer class IDs.\n    pred_bbox: [batch, num_rois, num_classes, (dz, dy, dx, log(dd), log(dh), log(dw))]\n    \"\"\"", "\n", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the right class_id of each ROI. Get their indices.", "\n", "        ", "positive_roi_ix", "=", "torch", ".", "nonzero", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_roi_class_ids", "=", "target_class_ids", "[", "positive_roi_ix", ".", "detach", "(", ")", "]", ".", "long", "(", ")", "\n", "indices", "=", "torch", ".", "stack", "(", "(", "positive_roi_ix", ",", "positive_roi_class_ids", ")", ",", "dim", "=", "1", ")", "\n", "\n", "# Gather the deltas (predicted and true) that contribute to loss", "\n", "target_bbox", "=", "target_bbox", "[", "indices", "[", ":", ",", "0", "]", ".", "detach", "(", ")", ",", ":", "]", "\n", "pred_bbox", "=", "pred_bbox", "[", "indices", "[", ":", ",", "0", "]", ".", "detach", "(", ")", ",", "indices", "[", ":", ",", "1", "]", ".", "detach", "(", ")", ",", ":", "]", "\n", "\n", "# Smooth L1 loss", "\n", "loss", "=", "F", ".", "smooth_l1_loss", "(", "pred_bbox", ",", "target_bbox", ")", "\n", "", "else", ":", "\n", "        ", "loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "target_class_ids", ".", "is_cuda", ":", "\n", "            ", "loss", "=", "loss", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_mask_loss": [[907, 934], ["target_class_ids[].long", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "y_true_.long().cuda", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.CrossEntropyLoss().cuda", "nn.CrossEntropyLoss().cuda.", "torch.autograd.Variable", "target_class_ids.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "loss.cuda.cuda", "y_true_.long", "torch.CrossEntropyLoss", "indices[].detach", "positive_ix.detach", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "function", ["None"], ["\n", "\n", "", "def", "compute_mrcnn_mask_loss", "(", "target_masks", ",", "target_class_ids", ",", "pred_masks", ")", ":", "\n", "    ", "\"\"\"Mask binary cross-entropy loss for the masks head.\n    target_masks: [batch, num_rois, depth, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_masks: [batch, proposals, num_classes, depth, height, width] float32 tensor\n                with values from 0 to 1.\n    \"\"\"", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "# Only positive ROIs contribute to the loss. And only the class specific mask of each ROI.", "\n", "        ", "positive_ix", "=", "torch", ".", "nonzero", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "target_class_ids", "[", "positive_ix", ".", "detach", "(", ")", "]", ".", "long", "(", ")", "\n", "indices", "=", "torch", ".", "stack", "(", "(", "positive_ix", ",", "positive_class_ids", ")", ",", "dim", "=", "1", ")", "\n", "# Gather the masks (predicted and true) that contribute to loss", "\n", "y_true_", "=", "target_masks", "[", "indices", "[", ":", ",", "0", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "y_true", "=", "y_true_", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "y_true", "=", "torch", ".", "argmax", "(", "y_true", ",", "dim", "=", "1", ")", "\n", "y_pred", "=", "pred_masks", "[", "indices", "[", ":", ",", "0", "]", ".", "detach", "(", ")", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "# Binary cross entropy", "\n", "los", "=", "nn", ".", "CrossEntropyLoss", "(", ")", ".", "cuda", "(", ")", "\n", "loss", "=", "los", "(", "y_pred", ",", "y_true", ")", "\n", "", "else", ":", "\n", "        ", "loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "target_class_ids", ".", "is_cuda", ":", "\n", "            ", "loss", "=", "loss", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_mask_edge_loss": [[936, 980], ["numpy.array", "np.array.transpose", "np.array.transpose", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "target_class_ids[].long", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.MSELoss", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "range", "torch.autograd.Variable().cuda", "target_class_ids.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "y_pred[].unsqueeze", "range", "torch.stack.size", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.stack.size", "torch.conv3d", "torch.conv3d", "nn.MSELoss.", "torch.autograd.Variable", "indices[].detach", "y_true_[].unsqueeze().unsqueeze().cuda().float", "y_pred_[].unsqueeze", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "positive_ix.detach", "torch.stack.size", "numpy.array().reshape", "y_true_[].unsqueeze().unsqueeze().cuda", "numpy.array", "y_true_[].unsqueeze().unsqueeze", "y_true_[].unsqueeze"], "function", ["None"], ["\n", "\n", "", "def", "compute_mrcnn_mask_edge_loss", "(", "target_masks", ",", "target_class_ids", ",", "pred_masks", ")", ":", "\n", "    ", "\"\"\"Mask edge mean square error loss for the Edge Agreement Head.\n    Here I use the Sobel kernel without smoothing the ground_truth masks.\n        target_masks: [batch, num_rois, depth, height, width].\n        target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n        pred_masks: [batch, proposals, num_classes, depth, height, width] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "if", "target_class_ids", ".", "size", "(", ")", "[", "0", "]", "!=", "0", ":", "\n", "# Generate the xyz dimension Sobel kernels", "\n", "        ", "kernel_x", "=", "np", ".", "array", "(", "[", "[", "[", "1", ",", "2", ",", "1", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "-", "1", ",", "-", "2", ",", "-", "1", "]", "]", ",", "\n", "[", "[", "2", ",", "4", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "-", "2", ",", "-", "4", ",", "-", "2", "]", "]", ",", "\n", "[", "[", "1", ",", "2", ",", "1", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "-", "1", ",", "-", "2", ",", "-", "1", "]", "]", "]", ")", "\n", "kernel_y", "=", "kernel_x", ".", "transpose", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "kernel_z", "=", "kernel_x", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "kernel", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "kernel_x", ",", "kernel_y", ",", "kernel_z", "]", ")", ".", "reshape", "(", "(", "3", ",", "1", ",", "3", ",", "3", ",", "3", ")", ")", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "\n", "# Only positive ROIs contribute to the loss. And only the class specific mask of each ROI.", "\n", "positive_ix", "=", "torch", ".", "nonzero", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "target_class_ids", "[", "positive_ix", ".", "detach", "(", ")", "]", ".", "long", "(", ")", "\n", "indices", "=", "torch", ".", "stack", "(", "(", "positive_ix", ",", "positive_class_ids", ")", ",", "dim", "=", "1", ")", "\n", "# Gather the masks (predicted and true) that contribute to loss", "\n", "y_true", "=", "target_masks", "[", ":", "indices", ".", "size", "(", ")", "[", "0", "]", ",", "1", ":", ",", ":", ",", ":", "]", "\n", "y_pred", "=", "pred_masks", "[", "indices", "[", ":", ",", "0", "]", ".", "detach", "(", ")", ",", "1", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "# Implement the edge detection convolution", "\n", "loss_fn", "=", "nn", ".", "MSELoss", "(", ")", "\n", "loss", "=", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "cuda", "(", ")", "\n", "for", "i", "in", "range", "(", "indices", ".", "size", "(", ")", "[", "0", "]", ")", ":", "\n", "            ", "y_true_", "=", "y_true", "[", "i", "]", "\n", "y_pred_", "=", "y_pred", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "# [N, 7, 64, 64, 64]", "\n", "for", "j", "in", "range", "(", "7", ")", ":", "\n", "                ", "y_true_final", "=", "F", ".", "conv3d", "(", "y_true_", "[", "j", ",", ":", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ".", "float", "(", ")", ",", "kernel", ")", "\n", "y_pred_final", "=", "F", ".", "conv3d", "(", "y_pred_", "[", ":", ",", "j", ",", ":", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", ",", "kernel", ")", "\n", "y_true_final", "=", "torch", ".", "sqrt", "(", "torch", ".", "pow", "(", "y_true_final", "[", ":", ",", "0", "]", ",", "2", ")", "+", "torch", ".", "pow", "(", "y_true_final", "[", ":", ",", "1", "]", ",", "2", ")", "+", "\n", "torch", ".", "pow", "(", "y_true_final", "[", ":", ",", "0", "]", ",", "2", ")", ")", "\n", "y_pred_final", "=", "torch", ".", "sqrt", "(", "torch", ".", "pow", "(", "y_pred_final", "[", ":", ",", "0", "]", ",", "2", ")", "+", "torch", ".", "pow", "(", "y_pred_final", "[", ":", ",", "1", "]", ",", "2", ")", "+", "\n", "torch", ".", "pow", "(", "y_pred_final", "[", ":", ",", "0", "]", ",", "2", ")", ")", "\n", "# Mean Square Error", "\n", "loss", "+=", "loss_fn", "(", "y_pred_final", ",", "y_true_final", ")", "\n", "", "", "loss", "/=", "indices", ".", "size", "(", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "target_class_ids", ".", "is_cuda", ":", "\n", "            ", "loss", "=", "loss", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_losses": [[982, 1004], ["model.compute_rpn_class_loss", "model.compute_rpn_bbox_loss", "model.compute_mrcnn_class_loss", "model.compute_mrcnn_bbox_loss", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "model.compute_mrcnn_mask_loss", "model.compute_mrcnn_mask_edge_loss", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.where", "numpy.where"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_rpn_class_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_rpn_bbox_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_class_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_bbox_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_mask_loss", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compute_mrcnn_mask_edge_loss"], ["\n", "\n", "", "def", "compute_losses", "(", "rpn_match", ",", "rpn_bbox", ",", "rpn_class_logits", ",", "rpn_pred_bbox", ",", "target_class_ids", ",", "mrcnn_class_logits", ",", "\n", "target_deltas", ",", "mrcnn_bbox", ",", "target_mask", ",", "mrcnn_mask", ",", "mrcnn_mask_logits", ",", "stage", ")", ":", "\n", "\n", "    ", "rpn_class_loss", "=", "compute_rpn_class_loss", "(", "rpn_match", ",", "rpn_class_logits", ")", "\n", "rpn_bbox_loss", "=", "compute_rpn_bbox_loss", "(", "rpn_bbox", ",", "rpn_match", ",", "rpn_pred_bbox", ")", "\n", "mrcnn_class_loss", "=", "compute_mrcnn_class_loss", "(", "torch", ".", "from_numpy", "(", "np", ".", "where", "(", "target_class_ids", ">", "0", ",", "1", ",", "0", ")", ")", ".", "cuda", "(", ")", ",", "\n", "mrcnn_class_logits", ")", "\n", "mrcnn_bbox_loss", "=", "compute_mrcnn_bbox_loss", "(", "target_deltas", ",", "\n", "torch", ".", "from_numpy", "(", "np", ".", "where", "(", "target_class_ids", ">", "0", ",", "1", ",", "0", ")", ")", ".", "cuda", "(", ")", ",", "mrcnn_bbox", ")", "\n", "\n", "mrcnn_mask_loss", "=", "compute_mrcnn_mask_loss", "(", "target_mask", ",", "target_class_ids", ",", "mrcnn_mask_logits", ")", "\n", "if", "stage", "==", "'finetune'", ":", "\n", "        ", "mrcnn_mask_edge_loss", "=", "compute_mrcnn_mask_edge_loss", "(", "target_mask", ",", "target_class_ids", ",", "mrcnn_mask", ")", "\n", "", "else", ":", "\n", "        ", "mrcnn_mask_edge_loss", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "False", ")", ".", "cuda", "(", ")", "\n", "\n", "", "return", "[", "rpn_class_loss", ",", "rpn_bbox_loss", ",", "mrcnn_class_loss", ",", "mrcnn_bbox_loss", ",", "mrcnn_mask_loss", ",", "mrcnn_mask_edge_loss", "]", "\n", "\n", "\n", "############################################################", "\n", "#  Data Generator", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.load_image_gt": [[1010, 1033], ["utils.extract_bboxes", "utils.extend_bbox", "numpy.tile", "model.build_rpn_targets", "numpy.array"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.extract_bboxes", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.extend_bbox", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.build_rpn_targets"], ["\n", "# Augmentation", "\n", "import", "imgaug", "\n", "from", "imgaug", "import", "augmenters", "as", "iaa", "\n", "augment", "=", "iaa", ".", "Affine", "(", "rotate", "=", "angle", ",", "order", "=", "0", ")", "# randomly rotate the image between -20 degree and 20 degree", "\n", "if", "augment", "is", "not", "None", ":", "\n", "# Augmenters that are safe to apply to masks", "\n", "# Some, such as Affine, have settings that make them unsafe, so always", "\n", "# test your augmentation on masks", "\n", "        ", "MASK_AUGMENTERS", "=", "[", "\"Sequential\"", ",", "\"SomeOf\"", ",", "\"OneOf\"", ",", "\"Sometimes\"", ",", "\n", "\"Fliplr\"", ",", "\"Flipud\"", ",", "\"CropAndPad\"", ",", "\n", "\"Affine\"", ",", "\"PiecewiseAffine\"", "]", "\n", "\n", "def", "hook", "(", "images", ",", "augmenter", ",", "parents", ",", "default", ")", ":", "\n", "            ", "\"\"\"Determines which augmenters to apply to masks.\"\"\"", "\n", "return", "augmenter", ".", "__class__", ".", "__name__", "in", "MASK_AUGMENTERS", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.build_rpn_targets": [[1035, 1127], ["numpy.zeros", "numpy.zeros", "utils.compute_overlaps", "numpy.argmax", "numpy.argmax", "zip", "numpy.where", "len", "numpy.random.choice", "numpy.where", "len", "numpy.random.choice", "numpy.where", "numpy.sum", "numpy.log", "numpy.log", "numpy.log", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_overlaps", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log"], ["# Store shapes before augmentation to compare", "\n", "", "image_shape", "=", "image", ".", "shape", "\n", "mask_shape", "=", "mask", ".", "shape", "\n", "# Reshape the image to [height, width, depth] so that we can implement imgaug on it.", "\n", "# Regard every [height, width, 1] of the image as an image and do imgaug on it.", "\n", "image", "=", "np", ".", "squeeze", "(", "image", ",", "3", ")", "\n", "# Make augmenters deterministic to apply similarly to images and masks", "\n", "det", "=", "augment", ".", "to_deterministic", "(", ")", "\n", "image", "=", "det", ".", "augment_image", "(", "image", ")", "\n", "mask", "=", "det", ".", "augment_image", "(", "mask", ".", "astype", "(", "np", ".", "uint8", ")", ",", "\n", "hooks", "=", "imgaug", ".", "HooksImages", "(", "activator", "=", "hook", ")", ")", "\n", "# Reshape the image back to [height, width, length, 1]", "\n", "image", "=", "np", ".", "expand_dims", "(", "image", ",", "-", "1", ")", "\n", "# Verify that shapes didn't change", "\n", "assert", "image", ".", "shape", "==", "image_shape", ",", "\"Augmentation shouldn't change image size\"", "\n", "assert", "mask", ".", "shape", "==", "mask_shape", ",", "\"Augmentation shouldn't change mask size\"", "\n", "# Change mask back to np.int32", "\n", "mask", "=", "mask", ".", "astype", "(", "np", ".", "int32", ")", "\n", "# Transpose the image and mask to the correct shape.", "\n", "# After transpose, image: [C, D, H, W], mask: [D, H, W, C]", "\n", "", "image", "=", "image", ".", "transpose", "(", "(", "3", ",", "2", ",", "0", ",", "1", ")", ")", "\n", "mask", "=", "mask", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "# Bounding boxes: [num_instances, (z1, y1, x1, z2, y2, x2)]", "\n", "bbox", "=", "utils", ".", "extract_bboxes", "(", "np", ".", "expand_dims", "(", "mask", ",", "-", "1", ")", ")", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "bbox", "[", "0", ",", ":", "]", "\n", "depth", "=", "z2", "-", "z1", "\n", "height", "=", "y2", "-", "y1", "\n", "width", "=", "x2", "-", "x1", "\n", "z1", "-=", "depth", "*", "0.05", "\n", "z2", "+=", "depth", "*", "0.05", "\n", "y1", "-=", "height", "*", "0.05", "\n", "y2", "+=", "height", "*", "0.05", "\n", "x1", "-=", "width", "*", "0.05", "\n", "x2", "+=", "width", "*", "0.05", "\n", "z1", "=", "np", ".", "floor", "(", "max", "(", "0", ",", "z1", ")", ")", "\n", "z2", "=", "np", ".", "ceil", "(", "min", "(", "mask", ".", "shape", "[", "0", "]", ",", "z2", ")", ")", "\n", "y1", "=", "np", ".", "floor", "(", "max", "(", "0", ",", "y1", ")", ")", "\n", "y2", "=", "np", ".", "ceil", "(", "min", "(", "mask", ".", "shape", "[", "1", "]", ",", "y2", ")", ")", "\n", "x1", "=", "np", ".", "floor", "(", "max", "(", "0", ",", "x1", ")", ")", "\n", "x2", "=", "np", ".", "ceil", "(", "min", "(", "mask", ".", "shape", "[", "2", "]", ",", "x2", ")", ")", "\n", "bbox", "[", "0", ",", ":", "]", "=", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "\n", "bbox", "=", "np", ".", "tile", "(", "bbox", ".", "astype", "(", "np", ".", "int32", ")", ",", "(", "config", ".", "NUM_CLASSES", "-", "1", ",", "1", ")", ")", "\n", "# Get the whole-heart mask, instance-specific masks and class_ids.", "\n", "masks", ",", "class_ids", "=", "dataset", ".", "process_mask", "(", "mask", ")", "\n", "\n", "# RPN Targets", "\n", "rpn_match", ",", "rpn_bbox", "=", "build_rpn_targets", "(", "anchors", ",", "np", ".", "array", "(", "[", "bbox", "[", "0", "]", "]", ")", ",", "config", ")", "\n", "\n", "# Add to batch", "\n", "rpn_match", "=", "rpn_match", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "image", "=", "mold_image", "(", "image", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "return", "image", ",", "rpn_match", ",", "rpn_bbox", ",", "class_ids", ",", "bbox", ",", "masks", "\n", "\n", "\n", "", "def", "build_rpn_targets", "(", "anchors", ",", "gt_boxes", ",", "config", ")", ":", "\n", "    ", "\"\"\"Given the anchors and GT boxes, compute overlaps and identify positive\n    anchors and deltas to refine them to match their corresponding GT boxes.\n    anchors: [num_anchors, (z1, y1, x1, z2, y2, x2)]\n    gt_class_ids: [num_gt_boxes] Integer class IDs.\n    gt_boxes: [num_gt_boxes, (z1, y1, x1, z2, y2, x2)]\n    Returns:\n    rpn_match: [N] (int32) matches between anchors and GT boxes.\n               1 = positive anchor, -1 = negative anchor, 0 = neutral\n    rpn_bbox: [N, (dz, dy, dx, log(dd), log(dh), log(dw))] Anchor bbox deltas.\n    \"\"\"", "\n", "# RPN Match: 1 = positive anchor, -1 = negative anchor, 0 = neutral", "\n", "rpn_match", "=", "np", ".", "zeros", "(", "[", "anchors", ".", "shape", "[", "0", "]", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "# RPN bounding boxes: [max anchors per image, (dz, dy, dx, log(dd), log(dh), log(dw))]", "\n", "rpn_bbox", "=", "np", ".", "zeros", "(", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", ",", "6", ")", ")", "\n", "# Compute overlaps [num_anchors, num_gt_boxes]", "\n", "overlaps", "=", "utils", ".", "compute_overlaps", "(", "anchors", ",", "gt_boxes", ")", "\n", "\n", "# Match anchors to GT Boxes", "\n", "# If an anchor overlaps a GT box with IoU >= 0.7 then it's positive.", "\n", "# If an anchor overlaps a GT box with IoU < 0.3 then it's negative.", "\n", "# Neutral anchors are those that don't match the conditions above, and they don't influence the loss function.", "\n", "# However, don't keep any GT box unmatched (rare, but happens).", "\n", "# Instead, match it to the closest anchor (even if its max IoU is < 0.3).", "\n", "\n", "# 1. Set negative anchors first. They get overwritten below if a GT box is", "\n", "# matched to them. Skip boxes in crowd areas.", "\n", "anchor_iou_argmax", "=", "np", ".", "argmax", "(", "overlaps", ",", "axis", "=", "1", ")", "\n", "anchor_iou_max", "=", "overlaps", "[", "np", ".", "arange", "(", "overlaps", ".", "shape", "[", "0", "]", ")", ",", "anchor_iou_argmax", "]", "\n", "rpn_match", "[", "anchor_iou_max", "<", "0.3", "]", "=", "-", "1", "\n", "\n", "# 2. Set an anchor for each GT box (regardless of IoU value).", "\n", "gt_iou_argmax", "=", "np", ".", "argmax", "(", "overlaps", ",", "axis", "=", "0", ")", "\n", "rpn_match", "[", "gt_iou_argmax", "]", "=", "1", "\n", "\n", "# 3. Set anchors with high overlap as positive.", "\n", "rpn_match", "[", "anchor_iou_max", ">=", "0.7", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.compose_image_meta": [[1842, 1861], ["numpy.array", "list", "list", "list"], "function", ["None"], ["scales", "=", "np", ".", "array", "(", "[", "d_scale", ",", "h_scale", ",", "w_scale", ",", "d_scale", ",", "h_scale", ",", "w_scale", "]", ")", "\n", "shifts", "=", "np", ".", "array", "(", "[", "shift", "[", "0", "]", ",", "shift", "[", "1", "]", ",", "shift", "[", "2", "]", ",", "shift", "[", "0", "]", ",", "shift", "[", "1", "]", ",", "shift", "[", "2", "]", "]", ")", "\n", "boxes", "=", "np", ".", "multiply", "(", "boxes", "-", "shifts", ",", "scales", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "# Filter out detections with zero area. Often only happens in early", "\n", "# stages of training when the network weights are still a bit random.", "\n", "exclude_ix", "=", "np", ".", "where", "(", "\n", "(", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "*", "(", "boxes", "[", ":", ",", "4", "]", "-", "boxes", "[", ":", ",", "1", "]", ")", "*", "(", "boxes", "[", ":", ",", "5", "]", "-", "boxes", "[", ":", ",", "2", "]", ")", "<=", "0", ")", "[", "0", "]", "\n", "if", "exclude_ix", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "boxes", "=", "np", ".", "delete", "(", "boxes", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "class_ids", "=", "np", ".", "delete", "(", "class_ids", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "scores", "=", "np", ".", "delete", "(", "scores", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "masks", "=", "np", ".", "delete", "(", "masks", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "\n", "# Resize masks to original image size.", "\n", "", "full_masks", "=", "utils", ".", "unmold_mask", "(", "masks", "[", "0", "]", ",", "boxes", "[", "0", "]", ",", "image_shape", ")", "\n", "full_mask", "=", "np", ".", "argmax", "(", "full_masks", ",", "axis", "=", "3", ")", "\n", "\n", "# Transform the shapes of boxes to normal shape.", "\n", "boxes", "[", ":", ",", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", "]", "=", "boxes", "[", ":", ",", "[", "1", ",", "2", ",", "0", ",", "4", ",", "5", ",", "3", "]", "]", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.parse_image_meta": [[1863, 1873], ["None"], "function", ["None"], ["\n", "return", "boxes", ",", "np", ".", "arange", "(", "1", ",", "8", ")", ",", "scores", ",", "full_mask", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "\n", "\n", "############################################################", "\n", "#  Data Formatting", "\n", "############################################################", "\n", "\n", "", "", "def", "compose_image_meta", "(", "image_id", ",", "image_shape", ",", "window", ",", "active_class_ids", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.preprocess_image": [[1875, 1884], ["None"], "function", ["None"], ["\n", "meta", "=", "np", ".", "array", "(", "\n", "[", "image_id", "]", "+", "# size = 1", "\n", "list", "(", "image_shape", ")", "+", "# size = 4", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.__init__": [[224, 230], ["None"], "methods", ["None"], ["image_info", ".", "update", "(", "kwargs", ")", "\n", "self", ".", "image_info", ".", "append", "(", "image_info", ")", "\n", "\n", "", "def", "image_reference", "(", "self", ",", "image_id", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_class": [[231, 243], ["utils.Dataset.class_info.append"], "methods", ["None"], ["\n", "return", "\"\"", "\n", "\n", "", "def", "prepare", "(", "self", ",", "class_map", "=", "None", ")", ":", "\n", "        ", "\"\"\"Prepares the Dataset class for use.\n\n        TODO: class map is not supported yet. When done, it should handle mapping\n              classes from different datasets to the same class ID.\n        \"\"\"", "\n", "def", "clean_name", "(", "name", ")", ":", "\n", "            ", "\"\"\"Returns a shorter version of object names for cleaner display.\"\"\"", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.add_image": [[245, 253], ["image_info.update", "utils.Dataset.image_info.append"], "methods", ["None"], ["\n", "# Build (or rebuild) everything else from the info dicts.", "\n", "", "self", ".", "num_classes", "=", "len", "(", "self", ".", "class_info", ")", "\n", "self", ".", "class_ids", "=", "np", ".", "arange", "(", "self", ".", "num_classes", ")", "\n", "self", ".", "class_names", "=", "[", "clean_name", "(", "c", "[", "\"name\"", "]", ")", "for", "c", "in", "self", ".", "class_info", "]", "\n", "self", ".", "num_images", "=", "len", "(", "self", ".", "image_info", ")", "\n", "self", ".", "_image_ids", "=", "np", ".", "arange", "(", "self", ".", "num_images", ")", "\n", "\n", "self", ".", "class_from_source_map", "=", "{", "\"{}.{}\"", ".", "format", "(", "info", "[", "'source'", "]", ",", "info", "[", "'id'", "]", ")", ":", "id", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.image_reference": [[254, 262], ["None"], "methods", ["None"], ["for", "info", ",", "id", "in", "zip", "(", "self", ".", "class_info", ",", "self", ".", "class_ids", ")", "}", "\n", "\n", "# Map sources to class_ids they support", "\n", "self", ".", "sources", "=", "list", "(", "set", "(", "[", "i", "[", "'source'", "]", "for", "i", "in", "self", ".", "class_info", "]", ")", ")", "\n", "self", ".", "source_class_ids", "=", "{", "}", "\n", "# Loop over datasets", "\n", "for", "source", "in", "self", ".", "sources", ":", "\n", "            ", "self", ".", "source_class_ids", "[", "source", "]", "=", "[", "]", "\n", "# Find classes that belong to this dataset", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.prepare": [[263, 294], ["len", "numpy.arange", "len", "numpy.arange", "list", "utils.Dataset.prepare.clean_name"], "methods", ["None"], ["for", "i", ",", "info", "in", "enumerate", "(", "self", ".", "class_info", ")", ":", "\n", "# Include BG class in all datasets", "\n", "                ", "if", "i", "==", "0", "or", "source", "==", "info", "[", "'source'", "]", ":", "\n", "                    ", "self", ".", "source_class_ids", "[", "source", "]", ".", "append", "(", "i", ")", "\n", "\n", "", "", "", "", "def", "map_source_class_id", "(", "self", ",", "source_class_id", ")", ":", "\n", "        ", "\"\"\"Takes a source class ID and returns the int class ID assigned to it.\n\n        For example:\n        dataset.map_source_class_id(\"coco.12\") -> 23\n        \"\"\"", "\n", "return", "self", ".", "class_from_source_map", "[", "source_class_id", "]", "\n", "\n", "", "def", "get_source_class_id", "(", "self", ",", "class_id", ",", "source", ")", ":", "\n", "        ", "\"\"\"Map an internal class ID to the corresponding class ID in the source dataset.\"\"\"", "\n", "info", "=", "self", ".", "class_info", "[", "class_id", "]", "\n", "assert", "info", "[", "'source'", "]", "==", "source", "\n", "return", "info", "[", "'id'", "]", "\n", "\n", "", "def", "append_data", "(", "self", ",", "class_info", ",", "image_info", ")", ":", "\n", "        ", "self", ".", "external_to_class_id", "=", "{", "}", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "self", ".", "class_info", ")", ":", "\n", "            ", "for", "ds", ",", "id", "in", "c", "[", "\"map\"", "]", ":", "\n", "                ", "self", ".", "external_to_class_id", "[", "ds", "+", "str", "(", "id", ")", "]", "=", "i", "\n", "\n", "# Map external image IDs to internal ones.", "\n", "", "", "self", ".", "external_to_image_id", "=", "{", "}", "\n", "for", "i", ",", "info", "in", "enumerate", "(", "self", ".", "image_info", ")", ":", "\n", "            ", "self", ".", "external_to_image_id", "[", "info", "[", "\"ds\"", "]", "+", "str", "(", "info", "[", "\"id\"", "]", ")", "]", "=", "i", "\n", "\n", "", "", "@", "property", "\n", "def", "image_ids", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.map_source_class_id": [[295, 302], ["None"], "methods", ["None"], ["        ", "return", "self", ".", "_image_ids", "\n", "\n", "", "def", "source_image_link", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Returns the path or URL to the image.\n        Override this to return a URL to the image if it's available online for easy\n        debugging.\n        \"\"\"", "\n", "return", "self", ".", "image_info", "[", "image_id", "]", "[", "\"path\"", "]", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.get_source_class_id": [[303, 309], ["None"], "methods", ["None"], ["\n", "", "def", "load_image", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified image and return a [H, W, D, 1] Numpy array.\"\"\"", "\n", "# Load image", "\n", "image", "=", "nib", ".", "load", "(", "self", ".", "image_info", "[", "image_id", "]", "[", "'path'", "]", ")", ".", "get_data", "(", ")", ".", "copy", "(", ")", "\n", "return", "np", ".", "expand_dims", "(", "image", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.append_data": [[310, 320], ["enumerate", "enumerate", "str", "str"], "methods", ["None"], ["", "def", "load_mask", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified mask and return a [H, W, D] Numpy array.\"\"\"", "\n", "# Override this function to load a mask from your dataset.", "\n", "# Otherwise, it returns an empty mask.", "\n", "mask", "=", "np", ".", "empty", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "return", "mask", "\n", "\n", "\n", "", "", "def", "resize", "(", "image", ",", "output_shape", ",", "order", "=", "1", ",", "mode", "=", "'constant'", ",", "cval", "=", "0", ",", "clip", "=", "True", ",", "\n", "preserve_range", "=", "True", ",", "anti_aliasing", "=", "False", ",", "anti_aliasing_sigma", "=", "None", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.image_ids": [[321, 325], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.source_image_link": [[326, 332], ["None"], "methods", ["None"], ["\n", "if", "LooseVersion", "(", "skimage", ".", "__version__", ")", ">=", "LooseVersion", "(", "\"0.14\"", ")", ":", "\n", "# New in 0.14: anti_aliasing. Default it to False for backward", "\n", "# compatibility with skimage 0.13.", "\n", "        ", "return", "skimage", ".", "transform", ".", "resize", "(", "\n", "image", ",", "output_shape", ",", "\n", "order", "=", "order", ",", "mode", "=", "mode", ",", "cval", "=", "cval", ",", "clip", "=", "clip", ",", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.load_image": [[333, 339], ["nibabel.load().get_data().copy", "numpy.expand_dims", "nibabel.load().get_data", "nibabel.load"], "methods", ["None"], ["preserve_range", "=", "preserve_range", ",", "anti_aliasing", "=", "anti_aliasing", ",", "\n", "anti_aliasing_sigma", "=", "anti_aliasing_sigma", ")", "\n", "", "else", ":", "\n", "        ", "return", "skimage", ".", "transform", ".", "resize", "(", "\n", "image", ",", "output_shape", ",", "\n", "order", "=", "order", ",", "mode", "=", "mode", ",", "cval", "=", "cval", ",", "clip", "=", "clip", ",", "\n", "preserve_range", "=", "preserve_range", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.Dataset.load_mask": [[340, 347], ["numpy.empty"], "methods", ["None"], ["\n", "\n", "", "", "def", "resize_image", "(", "image", ",", "min_dim", "=", "None", ",", "max_dim", "=", "None", ",", "min_scale", "=", "None", ",", "mode", "=", "\"square\"", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.extract_bboxes": [[20, 47], ["numpy.where", "ix[].min", "ix[].max", "ix[].min", "ix[].max", "numpy.where", "ix[].min", "ix[].max", "numpy.array", "np.array.astype", "numpy.sum", "numpy.sum"], "function", ["None"], ["def", "extract_bboxes", "(", "mask", ")", ":", "\n", "    ", "\"\"\"Compute bounding boxes from masks.\n    mask: [depth, height, width, num_instances]. Mask pixels are either 1 or 0.\n\n    Returns: bbox array [num_instances, (z1, y1, x1, z2, y2, x2)].\n    \"\"\"", "\n", "boxes", "=", "np", ".", "zeros", "(", "[", "mask", ".", "shape", "[", "-", "1", "]", ",", "6", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "# Bounding box.", "\n", "        ", "ix", "=", "np", ".", "where", "(", "np", ".", "sum", "(", "mask", ",", "axis", "=", "2", ")", ">", "0", ")", "\n", "z1", "=", "ix", "[", "0", "]", ".", "min", "(", ")", "\n", "z2", "=", "ix", "[", "0", "]", ".", "max", "(", ")", "\n", "y1", "=", "ix", "[", "1", "]", ".", "min", "(", ")", "\n", "y2", "=", "ix", "[", "1", "]", ".", "max", "(", ")", "\n", "ix", "=", "np", ".", "where", "(", "np", ".", "sum", "(", "mask", ",", "axis", "=", "0", ")", ">", "0", ")", "\n", "x1", "=", "ix", "[", "1", "]", ".", "min", "(", ")", "\n", "x2", "=", "ix", "[", "1", "]", ".", "max", "(", ")", "\n", "# x2, y2 and z2 should not be part of the box. Increment by 1.", "\n", "if", "z1", "!=", "z2", ":", "\n", "            ", "z2", "+=", "1", "\n", "x2", "+=", "1", "\n", "y2", "+=", "1", "\n", "", "else", ":", "\n", "# No mask for this instance. Might happen due to", "\n", "# resizing or cropping. Set bbox to zeros", "\n", "            ", "x1", ",", "x2", ",", "y1", ",", "y2", ",", "z1", ",", "z2", "=", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "\n", "", "boxes", "[", "i", "]", "=", "np", ".", "array", "(", "[", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "]", ")", "\n", "", "return", "boxes", ".", "astype", "(", "np", ".", "int32", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_iou": [[49, 71], ["numpy.maximum", "numpy.minimum", "numpy.maximum", "numpy.minimum", "numpy.maximum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["\n", "", "def", "compute_iou", "(", "box", ",", "boxes", ",", "box_volume", ",", "boxes_volume", ")", ":", "\n", "    ", "\"\"\"Calculates IoU of the given box with the array of the given boxes.\n    box: 1D vector [z1, y1, x1, z2, y2, x2]\n    boxes: [boxes_count, (z1, y1, x1, z2, y2, x2)]\n    box_volume: float. the volume of 'box'\n    boxes_volume: array of depth boxes_count.\n\n    Note: the volumes are passed in rather than calculated here for\n          efficiency. Calculate once in the caller to avoid duplicate work.\n    \"\"\"", "\n", "# Calculate intersection volumes", "\n", "z1", "=", "np", ".", "maximum", "(", "box", "[", "0", "]", ",", "boxes", "[", ":", ",", "0", "]", ")", "\n", "z2", "=", "np", ".", "minimum", "(", "box", "[", "3", "]", ",", "boxes", "[", ":", ",", "3", "]", ")", "\n", "y1", "=", "np", ".", "maximum", "(", "box", "[", "1", "]", ",", "boxes", "[", ":", ",", "1", "]", ")", "\n", "y2", "=", "np", ".", "minimum", "(", "box", "[", "4", "]", ",", "boxes", "[", ":", ",", "4", "]", ")", "\n", "x1", "=", "np", ".", "maximum", "(", "box", "[", "2", "]", ",", "boxes", "[", ":", ",", "2", "]", ")", "\n", "x2", "=", "np", ".", "minimum", "(", "box", "[", "5", "]", ",", "boxes", "[", ":", ",", "5", "]", ")", "\n", "intersection", "=", "np", ".", "maximum", "(", "x2", "-", "x1", ",", "0", ")", "*", "np", ".", "maximum", "(", "y2", "-", "y1", ",", "0", ")", "*", "np", ".", "maximum", "(", "z2", "-", "z1", ",", "0", ")", "\n", "union", "=", "box_volume", "+", "boxes_volume", "[", ":", "]", "-", "intersection", "[", ":", "]", "\n", "iou", "=", "intersection", "/", "(", "union", "+", "1e-6", ")", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_overlaps": [[73, 91], ["numpy.zeros", "range", "utils.compute_iou"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_iou"], ["", "def", "compute_overlaps", "(", "boxes1", ",", "boxes2", ")", ":", "\n", "    ", "\"\"\"Computes IoU overlaps between two sets of boxes.\n    boxes1, boxes2: [N, (z1, y1, x1, z2, y2, x2)].\n\n    For better performance, pass the largest set first and the smaller second.\n    \"\"\"", "\n", "# volumes of anchors and GT boxes", "\n", "volume1", "=", "(", "boxes1", "[", ":", ",", "3", "]", "-", "boxes1", "[", ":", ",", "0", "]", ")", "*", "(", "boxes1", "[", ":", ",", "4", "]", "-", "boxes1", "[", ":", ",", "1", "]", ")", "*", "(", "boxes1", "[", ":", ",", "5", "]", "-", "boxes1", "[", ":", ",", "2", "]", ")", "\n", "volume2", "=", "(", "boxes2", "[", ":", ",", "3", "]", "-", "boxes2", "[", ":", ",", "0", "]", ")", "*", "(", "boxes2", "[", ":", ",", "4", "]", "-", "boxes2", "[", ":", ",", "1", "]", ")", "*", "(", "boxes2", "[", ":", ",", "5", "]", "-", "boxes2", "[", ":", ",", "2", "]", ")", "\n", "\n", "# Compute overlaps to generate matrix [boxes1 count, boxes2 count]", "\n", "# Each cell contains the IoU value.", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "boxes1", ".", "shape", "[", "0", "]", ",", "boxes2", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "overlaps", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "box2", "=", "boxes2", "[", "i", "]", "\n", "overlaps", "[", ":", ",", "i", "]", "=", "compute_iou", "(", "box2", ",", "boxes1", ",", "volume2", "[", "i", "]", ",", "volume1", ")", "\n", "", "return", "overlaps", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.box_refinement": [[93, 122], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.stack", "torch.stack"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.model.log"], ["    ", "\"\"\"Compute refinement needed to transform box to gt_box.\n    box and gt_box are [N, (z1, y1, x1, z2, y2, x2)]\n    \"\"\"", "\n", "\n", "depth", "=", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "0", "]", "\n", "height", "=", "box", "[", ":", ",", "4", "]", "-", "box", "[", ":", ",", "1", "]", "\n", "width", "=", "box", "[", ":", ",", "5", "]", "-", "box", "[", ":", ",", "2", "]", "\n", "center_z", "=", "box", "[", ":", ",", "0", "]", "+", "0.5", "*", "depth", "\n", "center_y", "=", "box", "[", ":", ",", "1", "]", "+", "0.5", "*", "height", "\n", "center_x", "=", "box", "[", ":", ",", "2", "]", "+", "0.5", "*", "width", "\n", "\n", "gt_depth", "=", "gt_box", "[", ":", ",", "3", "]", "-", "gt_box", "[", ":", ",", "0", "]", "\n", "gt_height", "=", "gt_box", "[", ":", ",", "4", "]", "-", "gt_box", "[", ":", ",", "1", "]", "\n", "gt_width", "=", "gt_box", "[", ":", ",", "5", "]", "-", "gt_box", "[", ":", ",", "2", "]", "\n", "gt_center_z", "=", "gt_box", "[", ":", ",", "0", "]", "+", "0.5", "*", "gt_depth", "\n", "gt_center_y", "=", "gt_box", "[", ":", ",", "1", "]", "+", "0.5", "*", "gt_height", "\n", "gt_center_x", "=", "gt_box", "[", ":", ",", "2", "]", "+", "0.5", "*", "gt_width", "\n", "\n", "dz", "=", "(", "gt_center_z", "-", "center_z", ")", "/", "depth", "\n", "dy", "=", "(", "gt_center_y", "-", "center_y", ")", "/", "height", "\n", "dx", "=", "(", "gt_center_x", "-", "center_x", ")", "/", "width", "\n", "dd", "=", "torch", ".", "log", "(", "gt_depth", "/", "depth", ")", "\n", "dh", "=", "torch", ".", "log", "(", "gt_height", "/", "height", ")", "\n", "dw", "=", "torch", ".", "log", "(", "gt_width", "/", "width", ")", "\n", "\n", "result", "=", "torch", ".", "stack", "(", "[", "dz", ",", "dy", ",", "dx", ",", "dd", ",", "dh", ",", "dw", "]", ",", "dim", "=", "1", ")", "\n", "return", "result", "\n", "\n", "\n", "", "def", "non_max_suppression", "(", "boxes", ",", "scores", ",", "threshold", ",", "max_num", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.extend_bbox": [[124, 145], ["numpy.floor", "numpy.ceil", "numpy.floor", "numpy.ceil", "numpy.floor", "numpy.ceil", "numpy.array", "max", "min", "max", "min", "max", "min"], "function", ["None"], ["\n", "# Compute box volumes", "\n", "z1", "=", "boxes", "[", ":", ",", "0", "]", "\n", "y1", "=", "boxes", "[", ":", ",", "1", "]", "\n", "x1", "=", "boxes", "[", ":", ",", "2", "]", "\n", "z2", "=", "boxes", "[", ":", ",", "3", "]", "\n", "y2", "=", "boxes", "[", ":", ",", "4", "]", "\n", "x2", "=", "boxes", "[", ":", ",", "5", "]", "\n", "volume", "=", "(", "z2", "-", "z1", ")", "*", "(", "y2", "-", "y1", ")", "*", "(", "x2", "-", "x1", ")", "\n", "\n", "# Get indices of boxes sorted by scores (highest first)", "\n", "ixs", "=", "scores", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "pick", "=", "[", "]", "\n", "while", "len", "(", "ixs", ")", ">", "0", ":", "\n", "# Pick top box and add its index to the list", "\n", "        ", "i", "=", "ixs", "[", "0", "]", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.non_max_suppression": [[147, 184], ["numpy.array", "scores.argsort", "len", "pick.append", "utils.compute_iou", "numpy.delete", "numpy.delete", "len", "numpy.where"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_iou"], ["if", "len", "(", "pick", ")", ">=", "max_num", ":", "\n", "            ", "break", "\n", "# Compute IoU of the picked box with the rest", "\n", "", "iou", "=", "compute_iou", "(", "boxes", "[", "i", "]", ",", "boxes", "[", "ixs", "[", "1", ":", "]", "]", ",", "volume", "[", "i", "]", ",", "volume", "[", "ixs", "[", "1", ":", "]", "]", ")", "\n", "# Identify boxes with IoU over the threshold. This returns indices into ixs[1:],", "\n", "# so add 1 to get indices into ixs.", "\n", "remove_ixs", "=", "np", ".", "where", "(", "iou", ">", "threshold", ")", "[", "0", "]", "+", "1", "\n", "# Remove indices of the picked and overlapped boxes.", "\n", "ixs", "=", "np", ".", "delete", "(", "ixs", ",", "remove_ixs", ")", "\n", "ixs", "=", "np", ".", "delete", "(", "ixs", ",", "0", ")", "\n", "", "return", "np", ".", "array", "(", "pick", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "\n", "", "def", "denorm_boxes_graph", "(", "boxes", ",", "size", ")", ":", "\n", "    ", "\"\"\"Converts boxes from normalized coordinates to pixel coordinates.\n    boxes: [..., (z1, y1, x1, z2, y2, x2)] in normalized coordinates\n    size: [depth, height, width], the size to denorm to.\n\n    Note: In pixel coordinates (z2, y2, x2) is outside the box.\n          But in normalized coordinates it's inside the box.\n\n    Returns:\n        [..., (z1, y1, x1, z2, y2, x2)] in pixel coordinates\n    \"\"\"", "\n", "d", ",", "h", ",", "w", "=", "size", "\n", "scale", "=", "torch", ".", "Tensor", "(", "[", "d", ",", "h", ",", "w", ",", "d", ",", "h", ",", "w", "]", ")", ".", "cuda", "(", ")", "\n", "denorm_boxes", "=", "torch", ".", "mul", "(", "boxes", ",", "scale", ")", "\n", "return", "denorm_boxes", "\n", "\n", "\n", "############################################################", "\n", "#  Dataset", "\n", "############################################################", "\n", "\n", "", "class", "Dataset", "(", "object", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.denorm_boxes_graph": [[186, 202], ["torch.Tensor().cuda", "torch.Tensor().cuda", "torch.mul", "torch.mul", "torch.Tensor", "torch.Tensor"], "function", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "class_map", "=", "None", ")", ":", "\n", "        ", "self", ".", "_image_ids", "=", "[", "]", "\n", "self", ".", "image_info", "=", "[", "]", "\n", "# Background is always the first class", "\n", "self", ".", "class_info", "=", "[", "{", "\"source\"", ":", "\"\"", ",", "\"id\"", ":", "0", ",", "\"name\"", ":", "\"BG\"", "}", "]", "\n", "self", ".", "source_class_ids", "=", "{", "}", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.minimize_mask": [[349, 364], ["numpy.zeros", "range", "skimage.transform.resize", "numpy.around().astype", "Exception", "numpy.around"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], []], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.expand_mask": [[366, 381], ["numpy.zeros", "range", "skimage.transform.resize", "numpy.around().astype", "numpy.around"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.None.utils.resize"], ["\n", "# Keep track of image dtype and return results in the same dtype", "\n", "image_dtype", "=", "image", ".", "dtype", "\n", "# Default window (z1, y1, x1, z2, y2, x2) and default scale == 1.", "\n", "h", ",", "w", ",", "d", "=", "image", ".", "shape", "[", ":", "3", "]", "\n", "window", "=", "(", "0", ",", "0", ",", "0", ",", "d", ",", "h", ",", "w", ")", "\n", "scale", "=", "1", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.unmold_mask": [[383, 409], ["numpy.zeros", "numpy.zeros", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "range", "full_mask.clip", "mask.squeeze().detach().cpu().numpy().transpose.permute().unsqueeze", "torch.interpolate", "mask.squeeze().detach().cpu().numpy().transpose.squeeze().detach().cpu().numpy().transpose", "torch.from_numpy().float", "torch.from_numpy().float", "mask.squeeze().detach().cpu().numpy().transpose.permute", "mask.squeeze().detach().cpu().numpy().transpose.squeeze().detach().cpu().numpy", "torch.from_numpy", "torch.from_numpy", "mask.squeeze().detach().cpu().numpy().transpose.squeeze().detach().cpu", "mask.squeeze().detach().cpu().numpy().transpose.squeeze().detach", "mask.squeeze().detach().cpu().numpy().transpose.squeeze"], "function", ["None"], ["crop", "=", "None", "\n", "\n", "if", "mode", "==", "\"none\"", ":", "\n", "        ", "return", "image", ",", "window", ",", "scale", ",", "padding", ",", "crop", "\n", "\n", "# Self-designed resize strategy.", "\n", "", "if", "mode", "==", "\"self\"", ":", "\n", "        ", "image", "=", "resize", "(", "image", ",", "(", "max_dim", ",", "max_dim", ",", "min_dim", ",", "1", ")", ",", "\n", "order", "=", "1", ",", "mode", "=", "\"constant\"", ",", "preserve_range", "=", "True", ")", "\n", "return", "image", ".", "astype", "(", "image_dtype", ")", ",", "(", "0", ",", "0", ",", "0", ",", "min_dim", ",", "max_dim", ",", "max_dim", ")", ",", "-", "1", ",", "[", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", "]", ",", "crop", "\n", "\n", "\n", "", "", "def", "resize_mask", "(", "mask", ",", "scale", ",", "padding", ",", "max_dim", "=", "0", ",", "min_dim", "=", "0", ",", "crop", "=", "None", ",", "mode", "=", "\"square\"", ")", ":", "\n", "    ", "\"\"\"Resizes a mask using the given scale and padding.\n    Typically, you get the scale and padding from resize_image() to\n    ensure both, the image and the mask, are resized consistently.\n\n    scale: mask scaling factor\n    padding: Padding to add to the mask in the form\n            [(top, bottom), (left, right), (front, back), (0, 0)]\n    \"\"\"", "\n", "# Self-designed resize strategy.", "\n", "if", "mode", "==", "\"self\"", ":", "\n", "        ", "mask", "=", "resize", "(", "mask", ",", "(", "max_dim", ",", "max_dim", ",", "min_dim", ")", ",", "order", "=", "0", ",", "mode", "=", "'constant'", ",", "preserve_range", "=", "True", ")", "\n", "return", "np", ".", "round", "(", "mask", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.generate_anchors": [[415, 458], ["numpy.meshgrid", "scales.flatten.flatten", "ratios.flatten.flatten", "numpy.meshgrid", "numpy.meshgrid", "numpy.meshgrid", "numpy.meshgrid", "numpy.stack().reshape", "numpy.stack().reshape", "numpy.concatenate", "numpy.array", "numpy.array", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.stack", "numpy.stack"], "function", ["None"], ["mini_mask", "=", "np", ".", "zeros", "(", "mini_shape", "+", "(", "mask", ".", "shape", "[", "-", "1", "]", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "m", "=", "mask", "[", ":", ",", ":", ",", ":", ",", "i", "]", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "bbox", "[", "i", "]", "[", ":", "6", "]", "\n", "m", "=", "m", "[", "z1", ":", "z2", ",", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "\n", "if", "m", ".", "size", "==", "0", ":", "\n", "            ", "raise", "Exception", "(", "\"Invalid bounding box with volume of zero\"", ")", "\n", "", "m", "=", "skimage", ".", "transform", ".", "resize", "(", "m", ",", "mini_shape", ",", "order", "=", "0", ",", "mode", "=", "\"constant\"", ",", "preserve_range", "=", "True", ")", "\n", "mini_mask", "[", ":", ",", ":", ",", ":", ",", "i", "]", "=", "np", ".", "around", "(", "m", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "return", "mini_mask", "\n", "\n", "\n", "", "def", "expand_mask", "(", "bbox", ",", "mini_mask", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Resizes mini masks back to image size. Reverses the change\n    of minimize_mask().\n    \"\"\"", "\n", "mask", "=", "np", ".", "zeros", "(", "image_shape", "[", ":", "3", "]", "+", "(", "mini_mask", ".", "shape", "[", "-", "1", "]", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "m", "=", "mini_mask", "[", ":", ",", ":", ",", ":", ",", "i", "]", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "bbox", "[", "i", "]", "[", ":", "6", "]", "\n", "d", "=", "z2", "-", "z1", "\n", "h", "=", "y2", "-", "y1", "\n", "w", "=", "x2", "-", "x1", "\n", "m", "=", "skimage", ".", "transform", ".", "resize", "(", "m", ",", "(", "d", ",", "h", ",", "w", ")", ",", "order", "=", "1", ",", "mode", "=", "\"constant\"", ",", "preserve_range", "=", "True", ")", "\n", "mask", "[", "z1", ":", "z2", ",", "y1", ":", "y2", ",", "x1", ":", "x2", ",", "i", "]", "=", "np", ".", "around", "(", "m", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "return", "mask", "\n", "\n", "\n", "", "def", "unmold_mask", "(", "mask", ",", "bbox", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Converts a mask generated by the neural network into a format similar\n    to it's original shape.\n    mask: [depth, height, width, num_instances] of type float. A small, typically 28x28 mask.\n    bbox: [z1, y1, x1, z2, y2, x2]. The box to fit the mask in.\n    image_shape: [channels, depth, height, width]\n\n    Returns a tf.int32 mask with the same size as the original image.\n    \"\"\"", "\n", "z1", ",", "y1", ",", "x1", ",", "z2", ",", "y2", ",", "x2", "=", "bbox", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "\n", "mask", "=", "mask", ".", "permute", "(", "3", ",", "0", ",", "1", ",", "2", ")", ".", "unsqueeze", "(", "0", ")", "\n", "mask", "=", "F", ".", "interpolate", "(", "mask", ",", "size", "=", "(", "z2", "-", "z1", ",", "y2", "-", "y1", ",", "x2", "-", "x1", ")", ",", "mode", "=", "'trilinear'", ",", "align_corners", "=", "False", ")", "\n", "mask", "=", "mask", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "3", ",", "0", ")", "\n", "# Put the mask in the right location.", "\n", "full_mask", "=", "np", ".", "zeros", "(", "(", "image_shape", "[", "1", "]", ",", "image_shape", "[", "2", "]", ",", "image_shape", "[", "3", "]", ",", "mask", ".", "shape", "[", "-", "1", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.generate_pyramid_anchors": [[460, 479], ["range", "numpy.concatenate", "len", "anchors.append", "utils.generate_anchors"], "function", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.generate_anchors"], ["return", "full_mask", "\n", "\n", "\n", "############################################################", "\n", "#  Anchors", "\n", "############################################################", "\n", "\n", "", "def", "generate_anchors", "(", "scales", ",", "ratios", ",", "shape", ",", "feature_stride", ",", "anchor_stride", ")", ":", "\n", "    ", "\"\"\"\n    scales: 1D array of anchor sizes in pixels. Example: [32, 64, 128]\n    ratios: 1D array of anchor ratios of width/height. Example: [1]\n    shape: [depth, height, width] spatial shape of the feature map over which\n            to generate anchors.\n    feature_stride: Stride of the feature map relative to the image in pixels.\n    anchor_stride: Stride of anchors on the feature map. For example, if the\n        value is 2 then generate anchors for every other feature map pixel.\n    \"\"\"", "\n", "# Get all combinations of scales and ratios", "\n", "scales", ",", "ratios", "=", "np", ".", "meshgrid", "(", "np", ".", "array", "(", "scales", ")", ",", "np", ".", "array", "(", "ratios", ")", ")", "\n", "scales", "=", "scales", ".", "flatten", "(", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.batch_slice": [[492, 528], ["range", "list", "isinstance", "graph_fn", "list.append", "zip", "torch.stack", "torch.stack", "len", "isinstance", "len", "zip"], "function", ["None"], ["shifts_x", "=", "np", ".", "arange", "(", "0", ",", "shape", "[", "2", "]", ",", "anchor_stride", ")", "*", "feature_stride", "\n", "shifts_z", ",", "shifts_y", ",", "shifts_x", "=", "np", ".", "meshgrid", "(", "shifts_z", ",", "shifts_y", ",", "shifts_x", ")", "\n", "\n", "# Enumerate combinations of shifts, widths, and heights", "\n", "box_depths", ",", "box_centers_z", "=", "np", ".", "meshgrid", "(", "depths", ",", "shifts_z", ")", "\n", "box_widths", ",", "box_centers_x", "=", "np", ".", "meshgrid", "(", "widths", ",", "shifts_x", ")", "\n", "box_heights", ",", "box_centers_y", "=", "np", ".", "meshgrid", "(", "heights", ",", "shifts_y", ")", "\n", "\n", "# Reshape to get a list of (z, y, x) and a list of (d, h, w)", "\n", "box_centers", "=", "np", ".", "stack", "(", "\n", "[", "box_centers_z", ",", "box_centers_y", ",", "box_centers_x", "]", ",", "axis", "=", "2", ")", ".", "reshape", "(", "[", "-", "1", ",", "3", "]", ")", "\n", "box_sizes", "=", "np", ".", "stack", "(", "[", "box_depths", ",", "box_heights", ",", "box_widths", "]", ",", "axis", "=", "2", ")", ".", "reshape", "(", "[", "-", "1", ",", "3", "]", ")", "\n", "\n", "# Convert to corner coordinates (z1, y1, x1, z2, y2, x2)", "\n", "boxes", "=", "np", ".", "concatenate", "(", "[", "box_centers", "-", "0.5", "*", "box_sizes", ",", "\n", "box_centers", "+", "0.5", "*", "box_sizes", "]", ",", "axis", "=", "1", ")", "\n", "return", "boxes", "\n", "\n", "\n", "", "def", "generate_pyramid_anchors", "(", "scales", ",", "ratios", ",", "feature_shapes", ",", "feature_strides", ",", "\n", "anchor_stride", ")", ":", "\n", "    ", "\"\"\"Generate anchors at different levels of a feature pyramid. Each scale\n    is associated with a level of the pyramid, but each ratio is used in\n    all levels of the pyramid.\n\n    Returns:\n    anchors: [N, (z1, y1, x1, z2, y2, x2)]. All generated anchors in one array. Sorted\n        with the same order of the given scales. So, anchors of scale[0] come\n        first, then anchors of scale[1], and so on.\n    \"\"\"", "\n", "# Anchors", "\n", "# [anchor_count, (z1, y1, x1, z2, y2, x2)]", "\n", "anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "scales", ")", ")", ":", "\n", "        ", "anchors", ".", "append", "(", "generate_anchors", "(", "scales", "[", "i", "]", ",", "ratios", ",", "feature_shapes", "[", "i", "]", ",", "\n", "feature_strides", "[", "i", "]", ",", "anchor_stride", ")", ")", "\n", "", "return", "np", ".", "concatenate", "(", "anchors", ",", "axis", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_per_class_mask_iou": [[530, 547], ["numpy.reshape().astype", "numpy.reshape().astype", "numpy.sum", "numpy.sum", "numpy.array", "numpy.reshape", "numpy.reshape", "numpy.dot", "range"], "function", ["None"], ["\n", "############################################################", "\n", "#  Miscellaneous", "\n", "############################################################", "\n", "\n", "# ## Batch Slicing", "\n", "# Some custom layers support a batch size of 1 only, and require a lot of work", "\n", "# to support batches greater than 1. This function slices an input tensor", "\n", "# across the batch dimension and feeds batches of size 1. Effectively,", "\n", "# an easy way to support batches > 1 quickly with little code modification.", "\n", "# In the long run, it's more efficient to modify the code to support large", "\n", "# batches and getting rid of this function. Consider this a temporary solution", "\n", "", "def", "batch_slice", "(", "inputs", ",", "graph_fn", ",", "batch_size", ",", "names", "=", "None", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.utils.compute_mask_iou": [[549, 568], ["numpy.reshape().astype", "numpy.reshape().astype", "numpy.sum", "numpy.sum", "numpy.dot", "numpy.reshape", "numpy.reshape"], "function", ["None"], ["\n", "if", "not", "isinstance", "(", "inputs", ",", "list", ")", ":", "\n", "        ", "inputs", "=", "[", "inputs", "]", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "inputs_slice", "=", "[", "x", "[", "i", "]", "for", "x", "in", "inputs", "]", "\n", "output_slice", "=", "graph_fn", "(", "*", "inputs_slice", ")", "\n", "if", "not", "isinstance", "(", "output_slice", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "output_slice", "=", "[", "output_slice", "]", "\n", "", "outputs", ".", "append", "(", "output_slice", ")", "\n", "# Change outputs from a list of slices where each is", "\n", "# a list of outputs to a list of outputs and each has", "\n", "# a list of slices", "\n", "", "outputs", "=", "list", "(", "zip", "(", "*", "outputs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.__init__": [[29, 57], ["torch.Module.__init__", "torch.Conv3d", "torch.BatchNorm3d", "backbone.conv_S", "torch.BatchNorm3d", "backbone.conv_T", "torch.BatchNorm3d", "torch.ReLU", "list", "torch.Conv3d", "torch.BatchNorm3d", "torch.Sequential", "torch.Conv3d", "torch.BatchNorm3d", "torch.Conv3d", "torch.BatchNorm3d", "len"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.conv_S", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.conv_T"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "block", ",", "expand", "=", "False", ",", "stride", "=", "1", ",", "ST_structure", "=", "(", "'A'", ",", "'B'", ",", "'C'", ")", ")", ":", "\n", "        ", "\"\"\"A wrapper for different Bottlenecks.\n        block: identify Block_A/B/C.\n        expand: whether to expand the final output channel by multiplying expansion.\n        \"\"\"", "\n", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "expand", "=", "expand", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv3d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm3d", "(", "planes", ")", "\n", "\n", "self", ".", "ST", "=", "list", "(", "ST_structure", ")", "[", "(", "block", "-", "1", ")", "%", "len", "(", "ST_structure", ")", "]", "\n", "self", ".", "conv2", "=", "conv_S", "(", "planes", ",", "planes", ",", "stride", "=", "1", ",", "padding", "=", "(", "0", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm3d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "conv_T", "(", "planes", ",", "planes", ",", "stride", "=", "1", ",", "padding", "=", "(", "1", ",", "0", ",", "0", ")", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm3d", "(", "planes", ")", "\n", "if", "expand", ":", "\n", "            ", "self", ".", "conv4", "=", "nn", ".", "Conv3d", "(", "planes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "bn4", "=", "nn", ".", "BatchNorm3d", "(", "planes", "*", "4", ")", "\n", "self", ".", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv3d", "(", "inplanes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "stride", "=", "2", ")", ",", "\n", "nn", ".", "BatchNorm3d", "(", "planes", "*", "4", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv4", "=", "nn", ".", "Conv3d", "(", "planes", ",", "inplanes", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "bn4", "=", "nn", ".", "BatchNorm3d", "(", "inplanes", ")", "\n", "", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_A": [[58, 68], ["backbone.Bottleneck.conv2", "backbone.Bottleneck.bn2", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv3", "backbone.Bottleneck.bn3", "backbone.Bottleneck.relu"], "methods", ["None"], ["", "def", "ST_A", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_B": [[69, 79], ["backbone.Bottleneck.conv2", "backbone.Bottleneck.bn2", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv3", "backbone.Bottleneck.bn3", "backbone.Bottleneck.relu"], "methods", ["None"], ["", "def", "ST_B", "(", "self", ",", "x", ")", ":", "\n", "        ", "tmp_x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "tmp_x", "=", "self", ".", "bn2", "(", "tmp_x", ")", "\n", "tmp_x", "=", "self", ".", "relu", "(", "tmp_x", ")", "\n", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "return", "x", "+", "tmp_x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_C": [[80, 90], ["backbone.Bottleneck.conv2", "backbone.Bottleneck.bn2", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv3", "backbone.Bottleneck.bn3", "backbone.Bottleneck.relu"], "methods", ["None"], ["", "def", "ST_C", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "tmp_x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "tmp_x", "=", "self", ".", "bn3", "(", "tmp_x", ")", "\n", "tmp_x", "=", "self", ".", "relu", "(", "tmp_x", ")", "\n", "\n", "return", "x", "+", "tmp_x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.forward": [[91, 115], ["backbone.Bottleneck.conv1", "backbone.Bottleneck.bn1", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv4", "backbone.Bottleneck.bn4", "backbone.Bottleneck.relu", "backbone.Bottleneck.ST_A", "backbone.Bottleneck.downsample", "backbone.Bottleneck.ST_B", "backbone.Bottleneck.ST_C"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_A", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_B", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.Bottleneck.ST_C"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "ST", "==", "'A'", ":", "\n", "            ", "out", "=", "self", ".", "ST_A", "(", "out", ")", "\n", "", "elif", "self", ".", "ST", "==", "'B'", ":", "\n", "            ", "out", "=", "self", ".", "ST_B", "(", "out", ")", "\n", "", "elif", "self", ".", "ST", "==", "'C'", ":", "\n", "            ", "out", "=", "self", ".", "ST_C", "(", "out", ")", "\n", "\n", "", "out", "=", "self", ".", "conv4", "(", "out", ")", "\n", "out", "=", "self", ".", "bn4", "(", "out", ")", "\n", "\n", "if", "self", ".", "expand", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "residual", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__": [[119, 144], ["torch.Module.__init__", "torch.Sequential", "backbone.P3D._make_layer", "backbone.P3D._make_layer", "backbone.P3D.modules", "torch.Conv3d", "torch.BatchNorm3d", "torch.ReLU", "torch.MaxPool3d", "isinstance", "torch.init.xavier_uniform_", "isinstance", "m.bias.data.zero_", "m.weight.data.fill_", "m.bias.data.zero_", "isinstance", "m.weight.data.normal_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.__init__", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D._make_layer", "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "layers", ",", "input_channel", "=", "1", ",", "config", "=", "None", ")", ":", "\n", "        ", "super", "(", "P3D", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inplanes", "=", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", "\n", "\n", "self", ".", "C1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv3d", "(", "input_channel", ",", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", ",", "kernel_size", "=", "(", "3", ",", "7", ",", "7", ")", ",", "stride", "=", "2", ",", "padding", "=", "(", "1", ",", "3", ",", "3", ")", ")", ",", "\n", "nn", ".", "BatchNorm3d", "(", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "MaxPool3d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", ")", "# size = 1 / 4, channel = config.BACKBONE_CHANNELS[0]", "\n", "\n", "self", ".", "C2", "=", "self", ".", "_make_layer", "(", "block", ",", "config", ".", "BACKBONE_CHANNELS", "[", "0", "]", ",", "layers", "[", "0", "]", ",", "stride", "=", "2", ")", "# 1 / 8, [0] * 4", "\n", "self", ".", "C3", "=", "self", ".", "_make_layer", "(", "block", ",", "config", ".", "BACKBONE_CHANNELS", "[", "1", "]", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "# 1 / 16, [1] * 4", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv3d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm3d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "1", ",", "True", ",", "stride", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D._make_layer": [[145, 153], ["layers.append", "range", "torch.Sequential", "block", "layers.append", "block"], "methods", ["None"], ["for", "i", "in", "range", "(", "2", ",", "blocks", "+", "1", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "i", ",", "False", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "C1", "(", "x", ")", "\n", "x", "=", "self", ".", "C2", "(", "x", ")", "\n", "x", "=", "self", ".", "C3", "(", "x", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.forward": [[154, 160], ["backbone.P3D.C1", "backbone.P3D.C2", "backbone.P3D.C3"], "methods", ["None"], ["\n", "return", "x", "\n", "\n", "", "def", "stages", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "C1", ",", "self", ".", "C2", ",", "self", ".", "C3", "]", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D.stages": [[161, 163], ["None"], "methods", ["None"], ["", "", "def", "P3D19", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Construct a P3D19 model.\"\"\"", "\n", "model", "=", "P3D", "(", "Bottleneck", ",", "[", "2", ",", "3", "]", ",", "**", "kwargs", ")", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.conv_S": [[14, 18], ["torch.Conv3d"], "function", ["None"], ["def", "conv_S", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ":", "\n", "    ", "\"\"\"conv_S is the spatial conv layer\"\"\"", "\n", "return", "nn", ".", "Conv3d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "(", "1", ",", "3", ",", "3", ")", ",", "\n", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.conv_T": [[20, 24], ["torch.Conv3d"], "function", ["None"], ["", "def", "conv_T", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ":", "\n", "    ", "\"\"\"conv_T is the temporal conv layer\"\"\"", "\n", "return", "nn", ".", "Conv3d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "(", "3", ",", "1", ",", "1", ")", ",", "\n", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D19": [[165, 170], ["backbone.P3D"], "function", ["None"], ["", ""]], "home.repos.pwc.inspect_result.Wuziyi616_CFUN.LiTS_2017.backbone.P3D35": [[172, 177], ["backbone.P3D"], "function", ["None"], []]}