{"home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.compare.mean_confidence_interval": [[31, 37], ["len", "numpy.array", "numpy.mean", "scipy.stats.sem", "scipy.stats.t.ppf"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["def", "mean_confidence_interval", "(", "data", ",", "confidence", "=", "0.95", ")", ":", "\n", "    ", "a", "=", "1.0", "*", "np", ".", "array", "(", "data", ")", "\n", "n", "=", "len", "(", "a", ")", "\n", "m", ",", "se", "=", "np", ".", "mean", "(", "a", ")", ",", "scipy", ".", "stats", ".", "sem", "(", "a", ")", "\n", "h", "=", "se", "*", "scipy", ".", "stats", ".", "t", ".", "ppf", "(", "(", "1", "+", "confidence", ")", "/", "2.", ",", "n", "-", "1", ")", "\n", "return", "m", ",", "m", "-", "h", ",", "m", "+", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.get_weighted_samples": [[33, 41], ["post.prior.rvs", "post._unnormalized_likelihood", "theta.reshape.reshape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._unnormalized_likelihood"], ["def", "get_weighted_samples", "(", "post", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "post", ".", "prior", ".", "rvs", "(", "size", "=", "N", ")", "\n", "\n", "if", "theta", ".", "ndim", "==", "1", ":", "\n", "        ", "theta", "=", "theta", ".", "reshape", "(", "theta", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "\n", "", "weights", "=", "post", ".", "_unnormalized_likelihood", "(", "theta", ")", "\n", "return", "theta", ",", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.sample_posterior": [[44, 53], ["numpy.random.choice", "pandas.DataFrame.from_records", "numpy.sum", "len"], "function", ["None"], ["", "def", "sample_posterior", "(", "samples", ",", "weights", ",", "cols", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "samples", "\n", "n_weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "\n", "\n", "# importance weighted resampling", "\n", "resample_index", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "samples", ")", ",", "size", "=", "N", ",", "replace", "=", "True", ",", "p", "=", "n_weights", ")", "\n", "theta_resampled", "=", "theta", "[", "resample_index", ",", ":", "]", "\n", "theta_df", "=", "pd", ".", "DataFrame", ".", "from_records", "(", "theta_resampled", ",", "columns", "=", "cols", ")", "\n", "return", "theta_df", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.plot_grid": [[57, 66], ["seaborn.PairGrid", "range", "g.map_diag.map_lower", "g.map_diag.map_diag", "len", "range", "len", "g.map_diag.axes[].set_xlim", "g.map_diag.axes[].set_ylim"], "function", ["None"], ["", "def", "plot_grid", "(", "theta_df", ",", "lims", ")", ":", "\n", "    ", "g", "=", "sns", ".", "PairGrid", "(", "theta_df", ")", "\n", "for", "x_ind", "in", "range", "(", "0", ",", "len", "(", "lims", ")", ")", ":", "\n", "        ", "for", "y_ind", "in", "range", "(", "0", ",", "len", "(", "lims", ")", ")", ":", "\n", "            ", "g", ".", "axes", "[", "y_ind", ",", "x_ind", "]", ".", "set_xlim", "(", "lims", "[", "x_ind", "]", ")", "\n", "g", ".", "axes", "[", "y_ind", ",", "x_ind", "]", ".", "set_ylim", "(", "lims", "[", "y_ind", "]", ")", "\n", "\n", "", "", "g", "=", "g", ".", "map_lower", "(", "plt", ".", "scatter", ",", "s", "=", "1", ")", "\n", "g", "=", "g", ".", "map_diag", "(", "plt", ".", "hist", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.plot_thresholds": [[68, 75], ["matplotlib.gca", "plt.gca.plot", "plt.gca.set_ylabel", "plt.gca.set_xlabel", "plt.gca.legend"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.plot"], ["", "def", "plot_thresholds", "(", "thrs", ",", "legend", ")", ":", "\n", "    ", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "ax", ".", "plot", "(", "thrs", ")", "\n", "ax", ".", "set_ylabel", "(", "'threshold'", ")", "\n", "ax", ".", "set_xlabel", "(", "'num of batches'", ")", "\n", "ax", ".", "legend", "(", "legend", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.plot_marginals": [[78, 122], ["list", "seaborn.set", "bounds.keys", "zip", "range", "matplotlib.gcf", "pathlib.Path().glob", "pandas.Series", "seaborn.distplot", "matplotlib.axvline", "matplotlib.yticks", "matplotlib.ylabel", "plt.gcf.set_size_inches", "matplotlib.savefig", "matplotlib.close", "len", "scipy.io.loadmat", "matplotlib.xlabel", "matplotlib.xlabel", "pathlib.Path", "seaborn.distplot", "seaborn.distplot"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "def", "plot_marginals", "(", "sim", ",", "bounds", ",", "true_samples_df", ",", "true_pars", ")", ":", "\n", "    ", "plot_methods", "=", "[", "'BO-GP(200)'", ",", "'BO-LV-2GP-0.3(200)'", "]", "\n", "par_names", "=", "list", "(", "bounds", ".", "keys", "(", ")", ")", "\n", "sns", ".", "set", "(", "style", "=", "\"ticks\"", ",", "rc", "=", "{", "\"lines.linewidth\"", ":", "0.7", "}", ")", "\n", "\n", "maps", "=", "{", "'t1'", ":", "r'$\\theta_{t1}$'", ",", "'R1'", ":", "r'$\\theta_{R1}$'", ",", "'R2'", ":", "r'$\\theta_{R2}$'", ",", "\n", "'burden'", ":", "r'$\\theta_{burden}$'", ",", "'white'", ":", "r'$\\theta_{white}$'", ",", "\n", "'yellow'", ":", "r'$\\theta_{yellow}$'", ",", "'red'", ":", "r'$\\theta_{red}$'", ",", "\n", "'green'", ":", "r'$\\theta_{green}$'", ",", "'purple'", ":", "r'$\\theta_{purple}$'", ",", "\n", "'x'", ":", "r'$\\theta_{x}$'", ",", "'y'", ":", "r'$\\theta_{y}$'", ",", "\n", "'ns'", ":", "r'$\\theta_{n_s}$'", ",", "'kc'", ":", "r'$\\theta_{k_c}$'", ",", "'alpha'", ":", "r'$\\theta_{\\alpha}$'", ",", "\n", "'r_star'", ":", "r'$\\theta_{R^*}$'", ",", "'As'", ":", "r'$\\theta_{A_s}$'", "}", "\n", "\n", "for", "plot_method", "in", "plot_methods", ":", "\n", "        ", "for", "cur_par_name", ",", "i", "in", "zip", "(", "par_names", ",", "range", "(", "len", "(", "par_names", ")", ")", ")", ":", "\n", "            ", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "for", "filename", "in", "Path", "(", "'./results/'", "+", "sim", "+", "'/'", "+", "plot_method", ")", ".", "glob", "(", "'*.samples'", ")", ":", "\n", "                ", "temp_dict", "=", "scipy", ".", "io", ".", "loadmat", "(", "filename", ")", "\n", "sur_theta", "=", "temp_dict", "[", "cur_par_name", "]", "\n", "# sns.distplot(sur_theta, color=(0.879, 0.929, 0.969), hist=False, kde_kws={'alpha':0.1}) #, scatter_kws={'alpha':0.3})", "\n", "# sns.distplot(sur_theta, color=(0.711, 0.832, 0.91), hist=False, kde_kws={'alpha':0.05}) # DGP almost good", "\n", "# sns.distplot(sur_theta, color=(0.554, 0.734, 0.855), hist=False, kde_kws={'alpha':0.05}) #GP gppd", "\n", "try", ":", "\n", "                    ", "sns", ".", "distplot", "(", "sur_theta", ",", "color", "=", "(", "0.516", ",", "0.707", ",", "0.839", ")", ",", "hist", "=", "False", ",", "kde_kws", "=", "{", "'alpha'", ":", "0.1", "}", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "                    ", "sns", ".", "distplot", "(", "sur_theta", ",", "color", "=", "(", "0.516", ",", "0.707", ",", "0.839", ")", ",", "kde", "=", "False", ",", "kde_kws", "=", "{", "'alpha'", ":", "0.1", "}", ")", "\n", "\n", "", "", "true_theta", "=", "pd", ".", "Series", "(", "true_samples_df", "[", "cur_par_name", "]", ",", "name", "=", "cur_par_name", ")", "\n", "sns", ".", "distplot", "(", "true_theta", ",", "color", "=", "\"r\"", ",", "hist", "=", "False", ",", "kde_kws", "=", "{", "\"linewidth\"", ":", "1", "}", ")", "\n", "plt", ".", "axvline", "(", "true_pars", "[", "i", "]", ",", "ls", "=", "'dashed'", ",", "color", "=", "\"black\"", ")", "\n", "plt", ".", "yticks", "(", "[", "]", ")", "\n", "\n", "if", "'TE'", "in", "sim", ":", "\n", "                ", "plt", ".", "xlabel", "(", "r'$\\theta$'", ")", "\n", "", "else", ":", "\n", "                ", "plt", ".", "xlabel", "(", "maps", "[", "cur_par_name", "]", ")", "\n", "", "plt", ".", "ylabel", "(", "''", ")", "\n", "# plt.ylim((0,2.5))", "\n", "\n", "# fig.set_size_inches(2.5,2.1) # in TE plots", "\n", "# fig.set_size_inches(1.4,1.4) # in 5 row plots", "\n", "fig", ".", "set_size_inches", "(", "1.8", ",", "1.8", ")", "\n", "plt", ".", "savefig", "(", "'plots/'", "+", "sim", "+", "'-'", "+", "plot_method", "+", "'-par-'", "+", "cur_par_name", "+", "'.png'", ",", "dpi", "=", "600", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.plot_wasserstein": [[125, 182], ["seaborn.set", "pathlib.Path", "pandas.DataFrame", "matplotlib.gcf", "matplotlib.savefig", "matplotlib.close", "pathlib.Path.iterdir", "f.is_dir", "sim_path.name.split", "pathlib.Path().glob", "seaborn.boxplot", "matplotlib.legend", "matplotlib.xlabel", "plt.gcf.set_size_inches", "matplotlib.ylabel", "seaborn.violinplot", "matplotlib.xlabel", "plt.gcf.set_size_inches", "matplotlib.ylabel", "sim_path.iterdir", "f.is_dir", "scipy.io.loadmat", "wass_dist_df.append.append", "wass_dist_df.append.Model.unique", "meth_path.name.split", "int", "pathlib.Path", "print"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "", "", "def", "plot_wasserstein", "(", "boxplot", "=", "True", ")", ":", "\n", "    ", "plot_methods", "=", "[", "'BO-GP'", ",", "'BO-LV-2GP-0.3'", "]", "\n", "\n", "sns", ".", "set", "(", "style", "=", "\"ticks\"", ",", "rc", "=", "{", "\"lines.linewidth\"", ":", "0.7", "}", ")", "\n", "datasets", "=", "[", "'20'", ",", "'50'", ",", "'100'", ",", "'150'", ",", "'200'", ",", "'250'", ",", "'300'", "]", "\n", "\n", "p", "=", "Path", "(", "'./results'", ")", "\n", "\n", "# All subdirectories in the current directory, not recursive.", "\n", "sim_paths", "=", "[", "f", "for", "f", "in", "p", ".", "iterdir", "(", ")", "if", "f", ".", "is_dir", "(", ")", "]", "\n", "\n", "for", "sim_path", "in", "sim_paths", ":", "\n", "        ", "sim", "=", "sim_path", ".", "name", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "wass_dist_df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "[", "'Model'", ",", "'dset'", ",", "'wass'", "]", ")", "\n", "meth_paths", "=", "[", "f", "for", "f", "in", "sim_path", ".", "iterdir", "(", ")", "if", "f", ".", "is_dir", "(", ")", "]", "\n", "for", "meth_path", "in", "meth_paths", ":", "\n", "            ", "if", "plot_methods", "[", "1", "]", "in", "meth_path", ".", "name", ":", "\n", "                ", "plot_method", "=", "'LV-2GP'", "\n", "", "elif", "plot_methods", "[", "0", "]", "in", "meth_path", ".", "name", ":", "\n", "                ", "plot_method", "=", "'GP'", "\n", "", "else", ":", "\n", "                ", "continue", "\n", "\n", "", "dset", "=", "meth_path", ".", "name", ".", "split", "(", "'('", ")", "[", "-", "1", "]", "[", ":", "-", "1", "]", "\n", "if", "boxplot", "is", "False", "and", "int", "(", "dset", ")", "!=", "200", ":", "\n", "                ", "continue", "\n", "\n", "", "for", "filename", "in", "Path", "(", "meth_path", ")", ".", "glob", "(", "'*.mat'", ")", ":", "\n", "                ", "temp_dict", "=", "scipy", ".", "io", ".", "loadmat", "(", "filename", ")", "\n", "\n", "if", "temp_dict", "[", "'Wass'", "]", "[", "0", "]", "[", "0", "]", "<", "0", ":", "\n", "                    ", "print", "(", "filename", ",", "temp_dict", "[", "'Wass'", "]", "[", "0", "]", "[", "0", "]", ")", "\n", "continue", "\n", "", "data", "=", "{", "'Model'", ":", "plot_method", ",", "'dset'", ":", "dset", ",", "'wass'", ":", "temp_dict", "[", "'Wass'", "]", "[", "0", "]", "[", "0", "]", "}", "\n", "wass_dist_df", "=", "wass_dist_df", ".", "append", "(", "data", ",", "ignore_index", "=", "True", ")", "\n", "\n", "", "", "if", "wass_dist_df", ".", "empty", ":", "\n", "            ", "continue", "\n", "", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "my_pal", "=", "{", "m", ":", "\"r\"", "if", "m", "==", "\"GP\"", "else", "\"b\"", "for", "m", "in", "wass_dist_df", ".", "Model", ".", "unique", "(", ")", "}", "\n", "\n", "if", "boxplot", "is", "True", ":", "\n", "            ", "ax", "=", "sns", ".", "boxplot", "(", "x", "=", "'dset'", ",", "y", "=", "'wass'", ",", "hue", "=", "'Model'", ",", "data", "=", "wass_dist_df", ",", "linewidth", "=", "2", ",", "palette", "=", "my_pal", ",", "showfliers", "=", "False", ",", "order", "=", "[", "'20'", ",", "'50'", ",", "'100'", ",", "'150'", ",", "'200'", ",", "'250'", ",", "'300'", "]", ")", "\n", "plt", ".", "legend", "(", "[", "]", ",", "[", "]", ",", "frameon", "=", "False", ")", "\n", "plt", ".", "xlabel", "(", "r'Number of simulations'", ")", "\n", "fig", ".", "set_size_inches", "(", "5", ",", "3", ")", "\n", "plt", ".", "ylabel", "(", "r''", ",", "rotation", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "ax", "=", "sns", ".", "violinplot", "(", "x", "=", "'Model'", ",", "y", "=", "'wass'", ",", "data", "=", "wass_dist_df", ",", "linewidth", "=", "1.1", ",", "palette", "=", "my_pal", ",", "cut", "=", "0", ")", "\n", "plt", ".", "xlabel", "(", "r''", ")", "\n", "fig", ".", "set_size_inches", "(", "1.5", ",", "2.2", ")", "\n", "\n", "plt", ".", "ylabel", "(", "r''", ",", "rotation", "=", "0", ")", "\n", "\n", "", "plt", ".", "savefig", "(", "'plots/'", "+", "sim", "+", "'-wass.png'", ",", "dpi", "=", "600", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.hyperparameter_learning_objective": [[187, 191], ["kelfi.kernel_means_inference.kernel_means_weights", "kelfi.kernel_means_inference.approximate_marginal_kernel_means_likelihood"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_weights", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.approximate_marginal_kernel_means_likelihood"], ["", "", "def", "hyperparameter_learning_objective", "(", "y", ",", "x_sim", ",", "t_sim", ",", "t_samples", ",", "beta", ",", "eps", ",", "reg", "=", "None", ")", ":", "\n", "    ", "\"\"\"Computes the approximate MKML for different hyperparameters.\"\"\"", "\n", "weights", "=", "kernel_means_weights", "(", "y", ",", "x_sim", ",", "t_sim", ",", "eps", ",", "beta", ",", "reg", "=", "reg", ")", "\n", "return", "approximate_marginal_kernel_means_likelihood", "(", "t_samples", ",", "t_sim", ",", "weights", ",", "beta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.kelfi": [[193, 203], ["kelfi.kernel_means_inference.kernel_means_weights", "kelfi.kernel_means_inference.approximate_marginal_kernel_means_likelihood", "kelfi.kernel_means_inference.approximate_kernel_means_posterior_embedding", "kelfi.kernel_means_inference.kernel_herding", "kelfi.kernels.gaussian_kernel_gramix"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_weights", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.approximate_marginal_kernel_means_likelihood", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.approximate_kernel_means_posterior_embedding", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.kernel_herding", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix"], ["", "def", "kelfi", "(", "y", ",", "x_sim", ",", "t_sim", ",", "t_samples", ",", "beta", ",", "eps", ",", "reg", "=", "None", ",", "n_samples", "=", "1000", ",", "beta_query", "=", "None", ")", ":", "\n", "    ", "\"\"\"Full KELFI Solution.\"\"\"", "\n", "weights", "=", "kernel_means_weights", "(", "y", ",", "x_sim", ",", "t_sim", ",", "eps", ",", "beta", ",", "reg", "=", "reg", ")", "\n", "mkml", "=", "approximate_marginal_kernel_means_likelihood", "(", "t_samples", ",", "t_sim", ",", "weights", ",", "beta", ")", "\n", "if", "beta_query", "is", "None", ":", "\n", "        ", "beta_query", "=", "beta", "\n", "", "kernel_function", "=", "lambda", "t1", ",", "t2", ":", "gaussian_kernel_gramix", "(", "t1", ",", "t2", ",", "beta_query", ")", "\n", "kmpe_", "=", "approximate_kernel_means_posterior_embedding", "(", "t_samples", ",", "t_sim", ",", "weights", ",", "beta", ",", "t_samples", ",", "marginal_likelihood", "=", "mkml", ",", "beta_query", "=", "beta_query", ")", "\n", "t_kmpe", "=", "kernel_herding", "(", "kmpe_", ",", "kernel_function", ",", "t_samples", ",", "n_samples", ")", "\n", "return", "t_kmpe", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.generate_data": [[206, 224], ["elfi_model.generate", "elfi_model.generate", "numpy.reshape", "numpy.reshape", "numpy.array", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.concatenate", "numpy.reshape", "numpy.concatenate", "len", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["", "def", "generate_data", "(", "elfi_model", ",", "y_data", ",", "n_sim", ",", "n_prior_samples", ",", "par_names", ",", "seed", ")", ":", "\n", "    ", "'''Generates the data from the ELFI model, which will be later used for training'''", "\n", "outputs", "=", "elfi_model", ".", "parameter_names", "+", "[", "'sim'", "]", "\n", "data", "=", "elfi_model", ".", "generate", "(", "batch_size", "=", "n_sim", ",", "outputs", "=", "outputs", ",", "seed", "=", "seed", ")", "\n", "prior", "=", "elfi_model", ".", "generate", "(", "batch_size", "=", "n_prior_samples", ",", "outputs", "=", "par_names", ",", "seed", "=", "seed", ")", "\n", "\n", "parameters", "=", "np", ".", "reshape", "(", "data", "[", "par_names", "[", "0", "]", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "pars_from_prior", "=", "np", ".", "reshape", "(", "prior", "[", "par_names", "[", "0", "]", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "for", "par", "in", "par_names", "[", "1", ":", "]", ":", "\n", "        ", "temp_parameters", "=", "np", ".", "reshape", "(", "data", "[", "par", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "parameters", "=", "np", ".", "concatenate", "(", "(", "parameters", ",", "temp_parameters", ")", ",", "axis", "=", "1", ")", "\n", "temp_pars_from_prior", "=", "np", ".", "reshape", "(", "prior", "[", "par", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "pars_from_prior", "=", "np", ".", "concatenate", "(", "(", "pars_from_prior", ",", "temp_pars_from_prior", ")", ",", "axis", "=", "1", ")", "\n", "\n", "", "y_data", "=", "np", ".", "array", "(", "y_data", ")", "\n", "x_data", "=", "np", ".", "reshape", "(", "data", "[", "'sim'", "]", ",", "(", "-", "1", ",", "1", ",", "len", "(", "y_data", ")", ")", ")", "\n", "y_data", "=", "np", ".", "reshape", "(", "y_data", ",", "(", "-", "1", ",", "1", ",", "len", "(", "y_data", ")", ")", ")", "\n", "return", "x_data", ",", "y_data", ",", "parameters", ",", "pars_from_prior", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.tune_hyperparameters": [[226, 251], ["kelfi.kernel_means_learning.kernel_means_hyperparameter_learning", "numpy.linspace", "numpy.linspace", "numpy.zeros", "enumerate", "enumerate", "utils.hyperparameter_learning_objective"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_hyperparameter_learning", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.hyperparameter_learning_objective"], ["", "def", "tune_hyperparameters", "(", "x_data", ",", "y_data", ",", "parameters", ",", "pars_from_prior", ",", "auto_dif", "=", "True", ")", ":", "\n", "    ", "if", "auto_dif", "==", "True", ":", "\n", "        ", "eps_tuple", "=", "(", "0.06", ",", "'learn'", ")", "\n", "beta_tuple", "=", "(", "0.6", ",", "'learn'", ")", "\n", "reg_tuple", "=", "(", "1e-6", ",", "'learn'", ")", "\n", "eps", ",", "beta", ",", "reg_opt", "=", "kernel_means_hyperparameter_learning", "(", "\n", "y_data", ",", "x_data", ",", "parameters", ",", "eps_tuple", ",", "beta_tuple", ",", "reg_tuple", ",", "\n", "eps_ratios", "=", "1.", ",", "beta_ratios", "=", "1.", ",", "offset", "=", "0.", ",", "\n", "prior_samples", "=", "pars_from_prior", ",", "prior_mean", "=", "None", ",", "prior_std", "=", "None", ",", "\n", "learning_rate", "=", "0.01", ",", "n_iter", "=", "5000", ",", "display_steps", "=", "100", ")", "\n", "", "else", ":", "\n", "        ", "beta_array", "=", "np", ".", "linspace", "(", "0.5", ",", "1.5", ",", "100", ")", "\n", "eps_array", "=", "np", ".", "linspace", "(", "0.05", ",", "0.15", ",", "100", ")", "\n", "\n", "mkml_grid", "=", "np", ".", "zeros", "(", "(", "beta_array", ".", "shape", "[", "0", "]", ",", "eps_array", ".", "shape", "[", "0", "]", ")", ")", "\n", "mkml_global", "=", "-", "np", ".", "inf", "\n", "for", "i", ",", "beta", "in", "enumerate", "(", "beta_array", ")", ":", "\n", "            ", "for", "j", ",", "eps", "in", "enumerate", "(", "eps_array", ")", ":", "\n", "                ", "mkml_grid", "[", "i", ",", "j", "]", "=", "hyperparameter_learning_objective", "(", "y_data", ",", "x_data", ",", "parameters", ",", "pars_from_prior", ",", "beta", ",", "eps", ")", "\n", "if", "mkml_grid", "[", "i", ",", "j", "]", ">", "mkml_global", ":", "\n", "                    ", "mkml_global", "=", "mkml_grid", "[", "i", ",", "j", "]", "\n", "beta", "=", "beta", "\n", "eps", "=", "eps", "\n", "\n", "", "", "", "", "return", "beta", ",", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.None.utils.get_wass_dist": [[259, 311], ["ot.dist", "ot.emd2", "numpy.sqrt", "numpy.ones", "len", "RuntimeError", "numpy.sum", "numpy.ones", "len", "RuntimeError", "numpy.sum"], "function", ["None"], ["", "def", "get_wass_dist", "(", "samples_1", ",", "samples_2", ",", "weights_1", "=", "None", ",", "weights_2", "=", "None", ",", "num_iter_max", "=", "1000000", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Computes the Wasserstein 2 distance between two empirical distributions with weights. This uses the POT library to \n    estimate Wasserstein distance. The Wasserstein distance computation can take long if the number of samples in the \n    two datasets is large (cost of the computation scales in fact quadratically with the number of samples).\n    Parameters\n    ----------\n    samples_1 : np.ndarray\n         Samples defining the first empirical distribution, with shape (nxd), n being the number of samples in the\n         first empirical distribution and d the dimension of the random variable.\n    samples_2 : np.ndarray\n         Samples defining the second empirical distribution, with shape (mxd), m being the number of samples in the\n         second empirical distribution and d the dimension of the random variable.\n    weights_1 : np.ndarray, optional\n         Weights defining the first empirical distribution, with shape (n), n being the number of samples in the\n         first empirical distribution. Weights are normalized internally to the function. If not provided, they are\n         assumed to be identical for all samples.\n    weights_2 : np.ndarray, optional\n         Weights defining the second empirical distribution, with shape (m), m being the number of samples in the\n         second empirical distribution. Weights are normalized internally to the function. If not provided, they are\n         assumed to be identical for all samples.\n    num_iter_max : integer, optional\n        The maximum number of iterations in the linear programming algorithm to estimate the Wasserstein distance. \n        Default to 100000. \n    kwargs \n        Additional arguments passed to ot.emd2\n    Returns\n    -------\n    float\n        The estimated 2-Wasserstein distance.\n    \"\"\"", "\n", "n", "=", "samples_1", ".", "shape", "[", "0", "]", "\n", "m", "=", "samples_2", ".", "shape", "[", "0", "]", "\n", "\n", "if", "weights_1", "is", "None", ":", "\n", "        ", "a", "=", "np", ".", "ones", "(", "(", "n", ",", ")", ")", "/", "n", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "weights_1", ")", "!=", "n", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Number of weights and number of samples need to be the same.\"", ")", "\n", "", "a", "=", "weights_1", "/", "np", ".", "sum", "(", "weights_1", ")", "\n", "", "if", "weights_2", "is", "None", ":", "\n", "        ", "b", "=", "np", ".", "ones", "(", "(", "m", ",", ")", ")", "/", "m", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "weights_2", ")", "!=", "m", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Number of weights and number of samples need to be the same.\"", ")", "\n", "", "b", "=", "weights_2", "/", "np", ".", "sum", "(", "weights_2", ")", "\n", "\n", "# loss matrix", "\n", "", "M", "=", "ot", ".", "dist", "(", "x1", "=", "samples_1", ",", "x2", "=", "samples_2", ")", "# this returns squared distance!", "\n", "cost", "=", "ot", ".", "emd2", "(", "a", ",", "b", ",", "M", ",", "numItermax", "=", "num_iter_max", ",", "**", "kwargs", ")", "\n", "\n", "return", "np", ".", "sqrt", "(", "cost", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.docs.conf.Mock.__getattr__": [[23, 26], ["unittest.mock.MagicMock"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "__getattr__", "(", "cls", ",", "name", ")", ":", "\n", "        ", "return", "MagicMock", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.pytest_addoption": [[23, 29], ["parser.addoption"], "function", ["None"], ["def", "pytest_addoption", "(", "parser", ")", ":", "\n", "    ", "parser", ".", "addoption", "(", "\n", "\"--client\"", ",", "\n", "action", "=", "\"store\"", ",", "\n", "default", "=", "\"all\"", ",", "\n", "help", "=", "\"perform the tests for the specified client (default all)\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.client": [[34, 52], ["pytest.fixture", "request.config.getoption", "client_module.__name__.split", "pytest.skip", "client_module.Client", "pytest.skip"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "\"session\"", ",", "params", "=", "[", "native", ",", "eipp", ",", "mp", "]", ")", "\n", "def", "client", "(", "request", ")", ":", "\n", "    ", "\"\"\"Provides a fixture for all the different supported clients\n    \"\"\"", "\n", "\n", "client_module", "=", "request", ".", "param", "\n", "client_name", "=", "client_module", ".", "__name__", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "use_client", "=", "request", ".", "config", ".", "getoption", "(", "'--client'", ")", "\n", "\n", "if", "use_client", "!=", "'all'", "and", "use_client", "!=", "client_name", ":", "\n", "        ", "pytest", ".", "skip", "(", "\"Skipping client {}\"", ".", "format", "(", "client_name", ")", ")", "\n", "\n", "", "try", ":", "\n", "        ", "client", "=", "client_module", ".", "Client", "(", ")", "\n", "", "except", "BaseException", ":", "\n", "        ", "pytest", ".", "skip", "(", "\"Client {} not available\"", ".", "format", "(", "client_name", ")", ")", "\n", "\n", "", "yield", "client", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.with_all_clients": [[56, 64], ["pytest.fixture", "elfi.get_client", "elfi.get_client", "elfi.get_client", "elfi.get_client", "elfi.get_client", "elfi.get_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client", "elfi.client.set_client"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "with_all_clients", "(", "client", ")", ":", "\n", "    ", "pre", "=", "elfi", ".", "get_client", "(", ")", "\n", "elfi", ".", "client", ".", "set_client", "(", "client", ")", "\n", "\n", "yield", "\n", "\n", "elfi", ".", "client", ".", "set_client", "(", "pre", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.use_logging": [[66, 71], ["pytest.fixture", "logging.basicConfig", "logging.getLogger().setLevel", "logging.getLogger().setLevel", "logging.getLogger", "logging.getLogger"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "use_logging", "(", ")", ":", "\n", "    ", "logging", ".", "basicConfig", "(", "level", "=", "logging", ".", "DEBUG", ")", "\n", "logging", ".", "getLogger", "(", "'elfi.executor'", ")", ".", "setLevel", "(", "logging", ".", "WARNING", ")", "\n", "logging", ".", "getLogger", "(", "'elfi.compiler'", ")", ".", "setLevel", "(", "logging", ".", "WARNING", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.skip_travis": [[73, 77], ["pytest.fixture", "pytest.skip"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "skip_travis", "(", ")", ":", "\n", "    ", "if", "\"TRAVIS\"", "in", "os", ".", "environ", "and", "os", ".", "environ", "[", "'TRAVIS'", "]", "==", "\"true\"", ":", "\n", "        ", "pytest", ".", "skip", "(", "\"Skipping this test in Travis CI due to very slow run-time. Tested \"", "\n", "\"locally!\"", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.simple_model": [[83, 90], ["pytest.fixture", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.Constant", "elfi.Constant", "elfi.Constant", "elfi.Constant", "elfi.Constant", "elfi.Constant", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", ")", "\n", "def", "simple_model", "(", ")", ":", "\n", "    ", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Constant", "(", "10", ",", "model", "=", "m", ",", "name", "=", "'tau'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "m", "[", "'tau'", "]", ",", "size", "=", "1", ",", "model", "=", "m", ",", "name", "=", "'k1'", ")", "\n", "elfi", ".", "Prior", "(", "'normal'", ",", "m", "[", "'k1'", "]", ",", "size", "=", "3", ",", "model", "=", "m", ",", "name", "=", "'k2'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.ma2": [[92, 95], ["pytest.fixture", "elfi.examples.ma2.get_model", "elfi.examples.ma2.get_model", "elfi.examples.ma2.get_model", "elfi.examples.ma2.get_model", "elfi.examples.ma2.get_model", "elfi.examples.ma2.get_model"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "ma2", "(", ")", ":", "\n", "    ", "return", "elfi", ".", "examples", ".", "ma2", ".", "get_model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.acq_maxvar": [[97, 112], ["pytest.fixture", "conftest._get_dependencies_acq_fn", "elfi.methods.bo.acquisition.MaxVar"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest._get_dependencies_acq_fn"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "acq_maxvar", "(", ")", ":", "\n", "    ", "\"\"\"Initialise a MaxVar fixture.\n\n    Returns\n    -------\n    MaxVar\n        Acquisition method.\n\n    \"\"\"", "\n", "gp", ",", "prior", "=", "_get_dependencies_acq_fn", "(", ")", "\n", "\n", "# Initialising the acquisition method.", "\n", "method_acq", "=", "MaxVar", "(", "model", "=", "gp", ",", "prior", "=", "prior", ")", "\n", "return", "method_acq", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.acq_randmaxvar": [[114, 129], ["pytest.fixture", "conftest._get_dependencies_acq_fn", "elfi.methods.bo.acquisition.RandMaxVar"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest._get_dependencies_acq_fn"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "acq_randmaxvar", "(", ")", ":", "\n", "    ", "\"\"\"Initialise a RandMaxVar fixture.\n\n    Returns\n    -------\n    RandMaxVar\n        Acquisition method.\n\n    \"\"\"", "\n", "gp", ",", "prior", "=", "_get_dependencies_acq_fn", "(", ")", "\n", "\n", "# Initialising the acquisition method.", "\n", "method_acq", "=", "RandMaxVar", "(", "model", "=", "gp", ",", "prior", "=", "prior", ")", "\n", "return", "method_acq", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.acq_expintvar": [[131, 146], ["pytest.fixture", "conftest._get_dependencies_acq_fn", "elfi.methods.bo.acquisition.ExpIntVar"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest._get_dependencies_acq_fn"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "acq_expintvar", "(", ")", ":", "\n", "    ", "\"\"\"Initialise an ExpIntVar fixture.\n\n    Returns\n    -------\n    ExpIntVar\n        Acquisition method.\n\n    \"\"\"", "\n", "gp", ",", "prior", "=", "_get_dependencies_acq_fn", "(", ")", "\n", "\n", "# Initialising the acquisition method.", "\n", "method_acq", "=", "ExpIntVar", "(", "model", "=", "gp", ",", "prior", "=", "prior", ")", "\n", "return", "method_acq", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest._get_dependencies_acq_fn": [[148, 180], ["elfi.examples.gauss.get_model", "elfi.examples.gauss.get_model", "elfi.examples.gauss.get_model", "elfi.examples.gauss.get_model", "elfi.examples.gauss.get_model", "elfi.examples.gauss.get_model", "elfi.methods.utils.ModelPrior", "numpy.random.uniform", "numpy.random.uniform", "numpy.column_stack", "numpy.random.rand", "elfi.methods.bo.gpy_regression.GPyRegression", "elfi.methods.bo.gpy_regression.GPyRegression.update"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update"], ["", "def", "_get_dependencies_acq_fn", "(", ")", ":", "\n", "    ", "\"\"\"Provide the requirements for the MaxVar-based acquisition function initialisation.\n\n    Returns\n    -------\n    (GPy.model.GPRegression, elfi.methods.utils.ModelPrior)\n        Tuple containing a fit gp and a prior.\n\n    \"\"\"", "\n", "mean", "=", "[", "4", ",", "4", "]", "\n", "cov_matrix", "=", "[", "[", "1", ",", ".5", "]", ",", "[", ".5", ",", "1", "]", "]", "\n", "names_param", "=", "[", "'mu_0'", ",", "'mu_1'", "]", "\n", "eps_prior", "=", "5", "# The prior's range indicator used in the Gaussian noise model.", "\n", "bounds_param", "=", "{", "'mu_0'", ":", "(", "mean", "[", "0", "]", "-", "eps_prior", ",", "mean", "[", "0", "]", "+", "eps_prior", ")", ",", "\n", "'mu_1'", ":", "(", "mean", "[", "1", "]", "-", "eps_prior", ",", "mean", "[", "1", "]", "+", "eps_prior", ")", "}", "\n", "\n", "# Initialising the prior.", "\n", "gm_2d", "=", "elfi", ".", "examples", ".", "gauss", ".", "get_model", "(", "true_params", "=", "mean", ",", "nd_mean", "=", "True", ",", "cov_matrix", "=", "cov_matrix", ")", "\n", "prior", "=", "ModelPrior", "(", "gm_2d", ")", "\n", "\n", "# Generating the coordinates and the values of the fitting data.", "\n", "n_pts_fit", "=", "10", "\n", "x1", "=", "np", ".", "random", ".", "uniform", "(", "*", "bounds_param", "[", "'mu_0'", "]", ",", "n_pts_fit", ")", "\n", "x2", "=", "np", ".", "random", ".", "uniform", "(", "*", "bounds_param", "[", "'mu_1'", "]", ",", "n_pts_fit", ")", "\n", "x", "=", "np", ".", "column_stack", "(", "(", "x1", ",", "x2", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "rand", "(", "n_pts_fit", ")", "\n", "\n", "# Fitting the gp with the generated points.", "\n", "gp", "=", "GPyRegression", "(", "names_param", ",", "bounds", "=", "bounds_param", ")", "\n", "gp", ".", "update", "(", "x", ",", "y", ")", "\n", "\n", "return", "gp", ",", "prior", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.sleeper": [[182, 189], ["numpy.zeros", "enumerate", "time.time", "time.sleep", "float", "time.time"], "function", ["None"], ["", "def", "sleeper", "(", "sec", ",", "batch_size", ",", "random_state", ")", ":", "\n", "    ", "secs", "=", "np", ".", "zeros", "(", "batch_size", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "sec", ")", ":", "\n", "        ", "st", "=", "time", ".", "time", "(", ")", "\n", "time", ".", "sleep", "(", "float", "(", "s", ")", ")", "\n", "secs", "[", "i", "]", "=", "time", ".", "time", "(", ")", "-", "st", "\n", "", "return", "secs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.multivariate_model": [[228, 236], ["pytest.fixture", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Distance", "elfi.Distance", "elfi.Distance", "elfi.Distance", "elfi.Distance", "elfi.Distance", "numpy.array"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "multivariate_model", "(", "request", ")", ":", "\n", "    ", "ndim", "=", "request", ".", "param", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "multivariate_normal", ",", "[", "0", "]", "*", "ndim", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Simulator", "(", "rowsummer", ",", "m", "[", "'t1'", "]", ",", "observed", "=", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", ",", "model", "=", "m", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "model", "=", "m", ",", "name", "=", "'d'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.no_op": [[205, 207], ["None"], "function", ["None"], ["", "def", "no_op", "(", "data", ")", ":", "\n", "    ", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.sleep_model": [[209, 222], ["pytest.fixture", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.Constant", "elfi.Constant", "elfi.Constant", "elfi.Constant", "elfi.Constant", "elfi.Constant", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Distance", "elfi.Distance", "elfi.Distance", "elfi.Distance", "elfi.Distance", "elfi.Distance"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "sleep_model", "(", "request", ")", ":", "\n", "    ", "\"\"\"The true param will be half of the given sleep time.\"\"\"", "\n", "ub_sec", "=", "request", ".", "param", "or", ".5", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Constant", "(", "ub_sec", ",", "model", "=", "m", ",", "name", "=", "'ub'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "m", "[", "'ub'", "]", ",", "model", "=", "m", ",", "name", "=", "'sec'", ")", "\n", "elfi", ".", "Simulator", "(", "sleeper", ",", "m", "[", "'sec'", "]", ",", "model", "=", "m", ",", "name", "=", "'slept'", ")", "\n", "elfi", ".", "Summary", "(", "no_op", ",", "m", "[", "'slept'", "]", ",", "model", "=", "m", ",", "name", "=", "'summary'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'summary'", "]", ",", "model", "=", "m", ",", "name", "=", "'d'", ")", "\n", "\n", "m", ".", "observed", "[", "'slept'", "]", "=", "ub_sec", "/", "2", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.rowsummer": [[224, 226], ["numpy.sum"], "function", ["None"], ["", "def", "rowsummer", "(", "x", ",", "batch_size", ",", "random_state", ")", ":", "\n", "    ", "return", "np", ".", "sum", "(", "x", ",", "keepdims", "=", "True", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.distribution_test": [[241, 308], ["pytest.fixture", "getattr", "getattr.", "getattr.", "getattr.", "conftest.distribution_test.test_non_rvs_attr"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", ")", "\n", "def", "distribution_test", "(", ")", ":", "\n", "    ", "def", "test_non_rvs_attr", "(", "attr", ",", "distribution", ",", "rvs", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# Run some tests that ensure outputs are coherent (similar style as with e.g.", "\n", "# scipy distributions)", "\n", "\n", "        ", "rvs_none", ",", "rvs1", ",", "rvs2", "=", "rvs", "\n", "attr_fn", "=", "getattr", "(", "distribution", ",", "attr", ")", "\n", "\n", "# Test pdf", "\n", "attr_none", "=", "attr_fn", "(", "rvs_none", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "attr1", "=", "attr_fn", "(", "rvs1", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "attr2", "=", "attr_fn", "(", "rvs2", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# With size=1 the length should be 1", "\n", "assert", "len", "(", "attr1", ")", "==", "1", "\n", "assert", "len", "(", "attr2", ")", "==", "2", "\n", "\n", "assert", "attr1", ".", "shape", "[", "1", ":", "]", "==", "attr2", ".", "shape", "[", "1", ":", "]", "\n", "\n", "assert", "attr_none", ".", "shape", "==", "attr1", ".", "shape", "[", "1", ":", "]", "\n", "\n", "# With size=None we should get data that is not wrapped to any extra dim", "\n", "return", "attr_none", ",", "attr1", ",", "attr2", "\n", "\n", "", "def", "run", "(", "distribution", ",", "*", "args", ",", "rvs", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "if", "rvs", "is", "None", ":", "\n", "# Run some tests that ensure outputs are similar to e.g. scipy distributions", "\n", "            ", "rvs_none", "=", "distribution", ".", "rvs", "(", "*", "args", ",", "size", "=", "None", ",", "**", "kwargs", ")", "\n", "rvs1", "=", "distribution", ".", "rvs", "(", "*", "args", ",", "size", "=", "1", ",", "**", "kwargs", ")", "\n", "rvs2", "=", "distribution", ".", "rvs", "(", "*", "args", ",", "size", "=", "2", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "rvs_none", ",", "rvs1", ",", "rvs2", "=", "rvs", "\n", "\n", "# Test that if rvs_none should be a scalar but is wrapped", "\n", "", "assert", "rvs_none", ".", "squeeze", "(", ")", ".", "ndim", "==", "rvs_none", ".", "ndim", "\n", "\n", "# With size=1 the length should be 1", "\n", "assert", "len", "(", "rvs1", ")", "==", "1", "\n", "assert", "len", "(", "rvs2", ")", "==", "2", "\n", "\n", "assert", "rvs1", ".", "shape", "[", "1", ":", "]", "==", "rvs2", ".", "shape", "[", "1", ":", "]", "\n", "\n", "# With size=None we should get data that is not wrapped to any extra dim", "\n", "# (possibly a scalar)", "\n", "assert", "rvs_none", ".", "shape", "==", "rvs1", ".", "shape", "[", "1", ":", "]", "\n", "\n", "rvs", "=", "(", "rvs_none", ",", "rvs1", ",", "rvs2", ")", "\n", "\n", "# Test pdf", "\n", "pdf_none", ",", "pdf1", ",", "pdf2", "=", "test_non_rvs_attr", "(", "'pdf'", ",", "distribution", ",", "rvs", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "# Should be a scalar", "\n", "assert", "pdf_none", ".", "ndim", "==", "0", "\n", "\n", "if", "hasattr", "(", "distribution", ",", "'logpdf'", ")", ":", "\n", "            ", "logpdf_none", ",", "logpdf1", ",", "logpdf2", "=", "test_non_rvs_attr", "(", "'logpdf'", ",", "distribution", ",", "rvs", ",", "*", "args", ",", "\n", "**", "kwargs", ")", "\n", "assert", "np", ".", "allclose", "(", "logpdf_none", ",", "np", ".", "log", "(", "pdf_none", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "logpdf1", ",", "np", ".", "log", "(", "pdf1", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "logpdf2", ",", "np", ".", "log", "(", "pdf2", ")", ")", "\n", "\n", "", "if", "hasattr", "(", "distribution", ",", "'gradient_logpdf'", ")", ":", "\n", "            ", "glpdf_none", ",", "glpdf1", ",", "glpdf2", "=", "test_non_rvs_attr", "(", "'gradient_logpdf'", ",", "distribution", ",", "rvs", ",", "\n", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "run", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_custom_outputs.simulator": [[8, 15], ["rs.multinomial", "dict", "numpy.random.RandomState", "zip", "range"], "function", ["None"], ["def", "simulator", "(", "p", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "n", "=", "30", "\n", "rs", "=", "random_state", "or", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "data", "=", "rs", ".", "multinomial", "(", "n", ",", "p", ")", "\n", "\n", "# Make it a dict for testing purposes", "\n", "return", "dict", "(", "zip", "(", "range", "(", "n", ")", ",", "data", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_custom_outputs.summary": [[17, 21], ["len", "numpy.array", "range"], "function", ["None"], ["", "def", "summary", "(", "dict_data", ")", ":", "\n", "    ", "n", "=", "len", "(", "dict_data", ")", "\n", "data", "=", "np", ".", "array", "(", "[", "dict_data", "[", "i", "]", "for", "i", "in", "range", "(", "n", ")", "]", ")", "\n", "return", "data", "/", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_custom_outputs.lsimulator": [[23, 30], ["rs.multinomial", "numpy.random.RandomState", "list"], "function", ["None"], ["", "def", "lsimulator", "(", "p", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "n", "=", "30", "\n", "rs", "=", "random_state", "or", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "data", "=", "rs", ".", "multinomial", "(", "n", ",", "p", ")", "\n", "\n", "# Make it a list for testing purposes", "\n", "return", "list", "(", "data", ")", "+", "[", "'test'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_custom_outputs.lsummary": [[32, 36], ["len", "numpy.array"], "function", ["None"], ["", "def", "lsummary", "(", "list_data", ")", ":", "\n", "    ", "n", "=", "len", "(", "list_data", ")", "\n", "data", "=", "np", ".", "array", "(", "list_data", "[", ":", "-", "1", "]", ")", "\n", "return", "data", "/", "(", "n", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_custom_outputs.test_dict_output": [[38, 57], ["elfi.tools.vectorize", "elfi.tools.vectorize", "test_custom_outputs.simulator", "elfi.new_model", "elfi.Prior", "elfi.Simulator", "elfi.Summary", "elfi.Distance", "elfi.OutputPool", "elfi.Rejection", "elfi.Rejection.sample", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.simulator", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "test_dict_output", "(", ")", ":", "\n", "    ", "vsim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "simulator", ")", "\n", "vsum", "=", "elfi", ".", "tools", ".", "vectorize", "(", "summary", ")", "\n", "\n", "obs", "=", "simulator", "(", "[", ".2", ",", ".8", "]", ")", "\n", "\n", "elfi", ".", "new_model", "(", ")", "\n", "p", "=", "elfi", ".", "Prior", "(", "'dirichlet'", ",", "[", "2", ",", "2", "]", ")", "\n", "sim", "=", "elfi", ".", "Simulator", "(", "vsim", ",", "p", ",", "observed", "=", "obs", ")", "\n", "S", "=", "elfi", ".", "Summary", "(", "vsum", ",", "sim", ")", "\n", "d", "=", "elfi", ".", "Distance", "(", "'euclidean'", ",", "S", ")", "\n", "\n", "pool", "=", "elfi", ".", "OutputPool", "(", "[", "'sim'", "]", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "d", ",", "batch_size", "=", "100", ",", "pool", "=", "pool", ",", "output_names", "=", "[", "'sim'", "]", ")", "\n", "sample", "=", "rej", ".", "sample", "(", "100", ",", "n_sim", "=", "1000", ")", "\n", "mean", "=", "np", ".", "mean", "(", "sample", ".", "samples", "[", "'p'", "]", ",", "axis", "=", "0", ")", "\n", "\n", "# Crude test", "\n", "assert", "mean", "[", "1", "]", ">", "mean", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_custom_outputs.test_list_output": [[59, 88], ["elfi.tools.vectorize", "elfi.tools.vectorize", "elfi.tools.vectorize.", "elfi.utils.is_array", "elfi.tools.vectorize", "elfi.tools.vectorize.", "elfi.utils.is_array", "isinstance", "test_custom_outputs.lsimulator", "elfi.new_model", "elfi.Prior", "elfi.Simulator", "elfi.Summary", "elfi.Distance", "elfi.OutputPool", "elfi.Rejection", "elfi.Rejection.sample", "numpy.mean", "numpy.array", "isinstance", "numpy.array"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.is_array", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.is_array", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_custom_outputs.lsimulator", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "test_list_output", "(", ")", ":", "\n", "    ", "vsim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "lsimulator", ")", "\n", "vsum", "=", "elfi", ".", "tools", ".", "vectorize", "(", "lsummary", ")", "\n", "\n", "v", "=", "vsim", "(", "np", ".", "array", "(", "[", "[", ".2", ",", ".8", "]", ",", "[", ".3", ",", ".7", "]", "]", ")", ")", "\n", "assert", "is_array", "(", "v", ")", "\n", "assert", "not", "isinstance", "(", "v", "[", "0", "]", ",", "list", ")", "\n", "\n", "vsim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "lsimulator", ",", "dtype", "=", "False", ")", "\n", "\n", "v", "=", "vsim", "(", "np", ".", "array", "(", "[", "[", ".2", ",", ".8", "]", ",", "[", ".3", ",", ".7", "]", "]", ")", ")", "\n", "assert", "is_array", "(", "v", ")", "\n", "assert", "isinstance", "(", "v", "[", "0", "]", ",", "list", ")", "\n", "\n", "obs", "=", "lsimulator", "(", "[", ".2", ",", ".8", "]", ")", "\n", "\n", "elfi", ".", "new_model", "(", ")", "\n", "p", "=", "elfi", ".", "Prior", "(", "'dirichlet'", ",", "[", "2", ",", "2", "]", ")", "\n", "sim", "=", "elfi", ".", "Simulator", "(", "vsim", ",", "p", ",", "observed", "=", "obs", ")", "\n", "S", "=", "elfi", ".", "Summary", "(", "vsum", ",", "sim", ")", "\n", "d", "=", "elfi", ".", "Distance", "(", "'euclidean'", ",", "S", ")", "\n", "\n", "pool", "=", "elfi", ".", "OutputPool", "(", "[", "'sim'", "]", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "d", ",", "batch_size", "=", "100", ",", "pool", "=", "pool", ",", "output_names", "=", "[", "'sim'", "]", ")", "\n", "sample", "=", "rej", ".", "sample", "(", "100", ",", "n_sim", "=", "1000", ")", "\n", "mean", "=", "np", ".", "mean", "(", "sample", ".", "samples", "[", "'p'", "]", ",", "axis", "=", "0", ")", "\n", "\n", "# Crude test", "\n", "assert", "mean", "[", "1", "]", ">", "mean", "[", "0", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_randomness.test_randomness": [[9, 16], ["k1.generate", "k1.generate", "numpy.array_equal"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["def", "test_randomness", "(", "simple_model", ")", ":", "\n", "    ", "k1", "=", "simple_model", "[", "'k1'", "]", "\n", "\n", "gen1", "=", "k1", ".", "generate", "(", "10", ")", "\n", "gen2", "=", "k1", ".", "generate", "(", "10", ")", "\n", "\n", "assert", "not", "np", ".", "array_equal", "(", "gen1", ",", "gen2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_randomness.test_randomness2": [[18, 28], ["pytest.mark.usefixtures", "len", "numpy.array_equal", "elfi.Rejection().sample", "numpy.unique", "elfi.Rejection().sample", "elfi.Rejection", "elfi.Rejection"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_randomness2", "(", "simple_model", ")", ":", "\n", "    ", "k1", "=", "simple_model", "[", "'k1'", "]", "\n", "\n", "n", "=", "30", "\n", "samples1", "=", "elfi", ".", "Rejection", "(", "simple_model", "[", "'k1'", "]", ",", "batch_size", "=", "3", ")", ".", "sample", "(", "n", ")", ".", "samples", "[", "'k1'", "]", "\n", "assert", "len", "(", "np", ".", "unique", "(", "samples1", ")", ")", "==", "n", "\n", "\n", "samples2", "=", "elfi", ".", "Rejection", "(", "simple_model", "[", "'k1'", "]", ",", "batch_size", "=", "3", ")", ".", "sample", "(", "n", ")", ".", "samples", "[", "'k1'", "]", "\n", "assert", "not", "np", ".", "array_equal", "(", "samples1", ",", "samples2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_randomness.test_global_random_state_usage": [[31, 45], ["numpy.random.seed", "k2.generate", "numpy.random.get_state", "numpy.random.seed", "scipy.uniform.rvs", "scipy.norm.rvs", "numpy.random.get_state", "test_randomness.random_state_equal"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_state", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_state", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_randomness.random_state_equal"], ["", "def", "test_global_random_state_usage", "(", "simple_model", ")", ":", "\n", "    ", "n_gen", "=", "10", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "k2", "=", "simple_model", "[", "'k2'", "]", "\n", "k2", ".", "generate", "(", "n_gen", ")", "\n", "st1", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "mu", "=", "ss", ".", "uniform", ".", "rvs", "(", "0", ",", "10", ",", "size", "=", "(", "n_gen", ",", "1", ")", ")", "\n", "ss", ".", "norm", ".", "rvs", "(", "mu", ",", "size", "=", "(", "n_gen", ",", "3", ")", ")", "\n", "st2", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "\n", "assert", "random_state_equal", "(", "st1", ",", "st2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_randomness.test_get_sub_seed": [[47, 64], ["numpy.random.randint", "range", "range", "numpy.array_equal", "sub_seeds.append", "len", "elfi.utils.get_sub_seed", "sub_seeds_cached.append", "elfi.utils.get_sub_seed", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed"], ["", "def", "test_get_sub_seed", "(", ")", ":", "\n", "    ", "n", "=", "100", "\n", "seed", "=", "np", ".", "random", ".", "randint", "(", "2", "**", "31", ")", "\n", "sub_seeds", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "sub_seeds", ".", "append", "(", "get_sub_seed", "(", "seed", ",", "i", ",", "n", ")", ")", "\n", "\n", "", "assert", "len", "(", "np", ".", "unique", "(", "sub_seeds", ")", ")", "==", "n", "\n", "\n", "# Test the cached version", "\n", "cache", "=", "{", "}", "\n", "sub_seeds_cached", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "sub_seed", "=", "get_sub_seed", "(", "seed", ",", "i", ",", "n", ",", "cache", "=", "cache", ")", "\n", "sub_seeds_cached", ".", "append", "(", "sub_seed", ")", "\n", "\n", "", "assert", "np", ".", "array_equal", "(", "sub_seeds", ",", "sub_seeds_cached", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_randomness.random_state_equal": [[69, 77], ["numpy.array_equal"], "function", ["None"], ["", "def", "random_state_equal", "(", "st1", ",", "st2", ")", ":", "\n", "# 1. the string 'MT19937'.", "\n", "    ", "tf", "=", "st1", "[", "0", "]", "==", "st2", "[", "0", "]", "\n", "# 2. a 1-D array of 624 unsigned integer keys.", "\n", "tf", "=", "tf", "and", "np", ".", "array_equal", "(", "st1", "[", "1", "]", ",", "st2", "[", "1", "]", ")", "\n", "# 3. an integer ``pos``.", "\n", "tf", "=", "tf", "and", "st1", "[", "2", "]", "==", "st2", "[", "2", "]", "\n", "return", "tf", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_simulation_reuse.test_pool_usage": [[10, 49], ["pytest.mark.parametrize", "elfi.OutputPool", "elfi.Rejection", "time.time", "elfi.Rejection.sample", "elfi.Rejection", "time.time", "elfi.Rejection.sample", "elfi.OutputPool.remove_store", "elfi.Rejection", "time.time", "elfi.Rejection.sample", "elfi.OutputPool.remove_store", "elfi.Rejection", "time.time", "elfi.Rejection.sample", "time.time", "time.time", "time.time", "time.time"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.remove_store", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.remove_store", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "'sleep_model'", ",", "[", ".2", "]", ",", "indirect", "=", "[", "'sleep_model'", "]", ")", "\n", "def", "test_pool_usage", "(", "sleep_model", ")", ":", "\n", "# Add nodes to the pool", "\n", "    ", "pool", "=", "elfi", ".", "OutputPool", "(", "outputs", "=", "sleep_model", ".", "parameter_names", "+", "[", "'slept'", ",", "'summary'", ",", "'d'", "]", ")", "\n", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "sleep_model", "[", "'d'", "]", ",", "batch_size", "=", "5", ",", "pool", "=", "pool", ")", "\n", "quantile", "=", ".25", "\n", "ts", "=", "time", ".", "time", "(", ")", "\n", "res", "=", "rej", ".", "sample", "(", "5", ",", "quantile", "=", "quantile", ")", "\n", "td", "=", "time", ".", "time", "(", ")", "-", "ts", "\n", "# Will make 5/.25 = 20 evaluations with mean time of .1 secs, so 2 secs total on", "\n", "# average. Allow some slack although still on rare occasions this may fail.", "\n", "assert", "td", ">", "1.2", "\n", "\n", "# Instantiating new inference with the same pool should be faster because we", "\n", "# use the prepopulated pool", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "sleep_model", "[", "'d'", "]", ",", "batch_size", "=", "5", ",", "pool", "=", "pool", ")", "\n", "ts", "=", "time", ".", "time", "(", ")", "\n", "res", "=", "rej", ".", "sample", "(", "5", ",", "quantile", "=", "quantile", ")", "\n", "td", "=", "time", ".", "time", "(", ")", "-", "ts", "\n", "assert", "td", "<", "1.2", "\n", "\n", "# It should work if we remove the simulation, since the Rejection sampling", "\n", "# only requires the parameters and the discrepancy", "\n", "pool", ".", "remove_store", "(", "'slept'", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "sleep_model", "[", "'d'", "]", ",", "batch_size", "=", "5", ",", "pool", "=", "pool", ")", "\n", "ts", "=", "time", ".", "time", "(", ")", "\n", "res", "=", "rej", ".", "sample", "(", "5", ",", "quantile", "=", "quantile", ")", "\n", "td", "=", "time", ".", "time", "(", ")", "-", "ts", "\n", "assert", "td", "<", "1.2", "\n", "\n", "# It should work even if we remove the discrepancy, since the discrepancy can be recomputed", "\n", "# from the stored summary", "\n", "pool", ".", "remove_store", "(", "'d'", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "sleep_model", "[", "'d'", "]", ",", "batch_size", "=", "5", ",", "pool", "=", "pool", ")", "\n", "ts", "=", "time", ".", "time", "(", ")", "\n", "res", "=", "rej", ".", "sample", "(", "5", ",", "quantile", "=", "quantile", ")", "\n", "td", "=", "time", ".", "time", "(", ")", "-", "ts", "\n", "assert", "td", "<", "1.2", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_simulation_reuse.test_pool_restarts": [[51, 95], ["elfi.ArrayPool", "elfi.Rejection", "elfi.Rejection.sample", "elfi.ArrayPool.save", "elfi.Rejection", "elfi.Rejection.set_objective", "elfi.ArrayPool.get_store().array.fs.flush", "elfi.ArrayPool.get_store().array.fs.flush", "elfi.ArrayPool.open", "elfi.Rejection", "elfi.Rejection.sample", "elfi.ArrayPool.open.save", "elfi.ArrayPool.open", "elfi.Rejection", "elfi.Rejection.sample", "elfi.Rejection", "elfi.Rejection.sample", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "elfi.ArrayPool.delete", "elfi.ArrayPool.open.delete", "os.rmdir", "elfi.Rejection.iterate", "len", "len", "len", "len", "elfi.ArrayPool.get_store", "elfi.ArrayPool.get_store"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.save", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.set_objective", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.save", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.delete", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.delete", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.iterate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.get_store", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.get_store"], ["", "def", "test_pool_restarts", "(", "ma2", ")", ":", "\n", "    ", "pool", "=", "elfi", ".", "ArrayPool", "(", "[", "'t1'", ",", "'d'", "]", ",", "name", "=", "'test'", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "10", ",", "pool", "=", "pool", ",", "seed", "=", "123", ")", "\n", "\n", "rej", ".", "sample", "(", "1", ",", "n_sim", "=", "30", ")", "\n", "pool", ".", "save", "(", ")", "\n", "\n", "# Do not save the pool...", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "10", ",", "pool", "=", "pool", ")", "\n", "rej", ".", "set_objective", "(", "3", ",", "n_sim", "=", "60", ")", "\n", "while", "not", "rej", ".", "finished", ":", "\n", "        ", "rej", ".", "iterate", "(", ")", "\n", "# ...but just flush the array content", "\n", "", "pool", ".", "get_store", "(", "'t1'", ")", ".", "array", ".", "fs", ".", "flush", "(", ")", "\n", "pool", ".", "get_store", "(", "'d'", ")", ".", "array", ".", "fs", ".", "flush", "(", ")", "\n", "\n", "assert", "(", "len", "(", "pool", ")", "==", "6", ")", "\n", "assert", "(", "len", "(", "pool", ".", "stores", "[", "'t1'", "]", ".", "array", ")", "==", "60", ")", "\n", "\n", "pool2", "=", "elfi", ".", "ArrayPool", ".", "open", "(", "'test'", ")", "\n", "assert", "(", "len", "(", "pool2", ")", "==", "3", ")", "\n", "assert", "(", "len", "(", "pool2", ".", "stores", "[", "'t1'", "]", ".", "array", ")", "==", "30", ")", "\n", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "10", ",", "pool", "=", "pool2", ")", "\n", "s9pool", "=", "rej", ".", "sample", "(", "3", ",", "n_sim", "=", "90", ")", "\n", "pool2", ".", "save", "(", ")", "\n", "\n", "pool2", "=", "elfi", ".", "ArrayPool", ".", "open", "(", "'test'", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "10", ",", "pool", "=", "pool2", ")", "\n", "s9pool_loaded", "=", "rej", ".", "sample", "(", "3", ",", "n_sim", "=", "90", ")", "\n", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "10", ",", "seed", "=", "123", ")", "\n", "s9", "=", "rej", ".", "sample", "(", "3", ",", "n_sim", "=", "90", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "s9pool", ".", "samples", "[", "'t1'", "]", ",", "s9", ".", "samples", "[", "'t1'", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "s9pool", ".", "discrepancies", ",", "s9", ".", "discrepancies", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "s9pool", ".", "samples", "[", "'t1'", "]", ",", "s9pool_loaded", ".", "samples", "[", "'t1'", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "s9pool", ".", "discrepancies", ",", "s9pool_loaded", ".", "discrepancies", ")", "\n", "\n", "pool", ".", "delete", "(", ")", "\n", "pool2", ".", "delete", "(", ")", "\n", "\n", "os", ".", "rmdir", "(", "pool", ".", "prefix", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.setup_ma2_with_informative_data": [[17, 26], ["collections.OrderedDict", "elfi.examples.ma2.get_model", "collections.OrderedDict.values"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model"], ["def", "setup_ma2_with_informative_data", "(", ")", ":", "\n", "    ", "true_params", "=", "OrderedDict", "(", "[", "(", "'t1'", ",", ".6", ")", ",", "(", "'t2'", ",", ".2", ")", "]", ")", "\n", "n_obs", "=", "100", "\n", "\n", "# In our implementation, seed 4 gives informative (enough) synthetic observed", "\n", "# data of length 100 for quite accurate inference of the true parameters using", "\n", "# posterior mean as the point estimate", "\n", "m", "=", "ma2", ".", "get_model", "(", "n_obs", "=", "n_obs", ",", "true_params", "=", "true_params", ".", "values", "(", ")", ",", "seed_obs", "=", "4", ")", "\n", "return", "m", ",", "true_params", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.check_inference_with_informative_data": [[28, 39], ["numpy.abs", "numpy.mean", "numpy.abs", "numpy.mean", "len", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "check_inference_with_informative_data", "(", "outputs", ",", "N", ",", "true_params", ",", "error_bound", "=", "0.05", ")", ":", "\n", "    ", "t1", "=", "outputs", "[", "'t1'", "]", "\n", "t2", "=", "outputs", "[", "'t2'", "]", "\n", "\n", "if", "N", ">", "1", ":", "\n", "        ", "assert", "len", "(", "t1", ")", "==", "N", "\n", "\n", "", "assert", "np", ".", "abs", "(", "np", ".", "mean", "(", "t1", ")", "-", "true_params", "[", "'t1'", "]", ")", "<", "error_bound", ",", "\"\\n\\nNot |{} - {}| < {}\\n\"", ".", "format", "(", "np", ".", "mean", "(", "t1", ")", ",", "true_params", "[", "'t1'", "]", ",", "error_bound", ")", "\n", "assert", "np", ".", "abs", "(", "np", ".", "mean", "(", "t2", ")", "-", "true_params", "[", "'t2'", "]", ")", "<", "error_bound", ",", "\"\\n\\nNot |{} - {}| < {}\\n\"", ".", "format", "(", "np", ".", "mean", "(", "t2", ")", ",", "true_params", "[", "'t2'", "]", ",", "error_bound", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.test_rejection_with_quantile": [[41, 58], ["pytest.mark.usefixtures", "test_inference.setup_ma2_with_informative_data", "elfi.Rejection", "elfi.Rejection.sample", "test_inference.check_inference_with_informative_data", "len", "int", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.setup_ma2_with_informative_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.check_inference_with_informative_data"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_rejection_with_quantile", "(", ")", ":", "\n", "    ", "m", ",", "true_params", "=", "setup_ma2_with_informative_data", "(", ")", "\n", "\n", "quantile", "=", "0.01", "\n", "N", "=", "1000", "\n", "batch_size", "=", "20000", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ",", "batch_size", "=", "batch_size", ")", "\n", "res", "=", "rej", ".", "sample", "(", "N", ",", "quantile", "=", "quantile", ")", "\n", "\n", "check_inference_with_informative_data", "(", "res", ".", "samples", ",", "N", ",", "true_params", ")", "\n", "\n", "# Check that there are no repeating values indicating a seeding problem", "\n", "assert", "len", "(", "np", ".", "unique", "(", "res", ".", "discrepancies", ")", ")", "==", "N", "\n", "\n", "assert", "res", ".", "accept_rate", "==", "quantile", "\n", "assert", "res", ".", "n_sim", "==", "int", "(", "N", "/", "quantile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.test_rejection_with_threshold": [[60, 74], ["pytest.mark.usefixtures", "test_inference.setup_ma2_with_informative_data", "elfi.Rejection", "elfi.Rejection.sample", "test_inference.check_inference_with_informative_data", "len", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.setup_ma2_with_informative_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.check_inference_with_informative_data"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_rejection_with_threshold", "(", ")", ":", "\n", "    ", "m", ",", "true_params", "=", "setup_ma2_with_informative_data", "(", ")", "\n", "\n", "t", "=", ".1", "\n", "N", "=", "1000", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ",", "batch_size", "=", "20000", ")", "\n", "res", "=", "rej", ".", "sample", "(", "N", ",", "threshold", "=", "t", ")", "\n", "\n", "check_inference_with_informative_data", "(", "res", ".", "samples", ",", "N", ",", "true_params", ")", "\n", "\n", "assert", "res", ".", "threshold", "<=", "t", "\n", "# Test that we got unique samples (no repeating of batches).", "\n", "assert", "len", "(", "np", ".", "unique", "(", "res", ".", "discrepancies", ")", ")", "==", "N", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.test_smc": [[76, 89], ["pytest.mark.usefixtures", "test_inference.setup_ma2_with_informative_data", "elfi.SMC", "elfi.SMC.sample", "test_inference.check_inference_with_informative_data"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.setup_ma2_with_informative_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.check_inference_with_informative_data"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_smc", "(", ")", ":", "\n", "    ", "m", ",", "true_params", "=", "setup_ma2_with_informative_data", "(", ")", "\n", "\n", "thresholds", "=", "[", ".5", ",", ".25", ",", ".1", "]", "\n", "N", "=", "1000", "\n", "smc", "=", "elfi", ".", "SMC", "(", "m", "[", "'d'", "]", ",", "batch_size", "=", "20000", ")", "\n", "res", "=", "smc", ".", "sample", "(", "N", ",", "thresholds", "=", "thresholds", ")", "\n", "\n", "check_inference_with_informative_data", "(", "res", ".", "samples", ",", "N", ",", "true_params", ")", "\n", "\n", "# We should be able to carry out the inference in less than six batches", "\n", "assert", "res", ".", "populations", "[", "-", "1", "]", ".", "n_batches", "<", "6", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.test_BOLFI": [[91, 166], ["pytest.mark.usefixtures", "test_inference.setup_ma2_with_informative_data", "elfi.model.elfi_model.NodeReference", "elfi.BOLFI", "elfi.BOLFI.infer", "elfi.BOLFI.infer", "numpy.array_equal", "elfi.BOLFI.extract_posterior", "dict", "test_inference.check_inference_with_informative_data", "dict", "test_inference.check_inference_with_informative_data", "elfi.BOLFI.sample", "test_inference.check_inference_with_informative_data", "numpy.random.random", "elfi.BOLFI.target_model._gp.predict", "elfi.BOLFI.target_model.predict", "numpy.allclose", "numpy.allclose", "elfi.BOLFI.target_model._gp.predictive_gradients", "elfi.BOLFI.target_model.predictive_gradients", "numpy.allclose", "numpy.allclose", "elfi.examples.ma2.CustomPrior1.logpdf", "elfi.examples.ma2.CustomPrior2.logpdf", "numpy.isclose", "numpy.abs", "numpy.abs", "elfi.methods.bo.utils.minimize", "elfi.methods.bo.utils.stochastic_optimization", "bolfi.extract_posterior.prior.logpdf", "dict", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.setup_ma2_with_informative_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.extract_posterior", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.check_inference_with_informative_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.check_inference_with_informative_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_inference.check_inference_with_informative_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.stochastic_optimization", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf"], ["", "@", "pytest", ".", "mark", ".", "slowtest", "\n", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ",", "'skip_travis'", ")", "\n", "def", "test_BOLFI", "(", ")", ":", "\n", "    ", "m", ",", "true_params", "=", "setup_ma2_with_informative_data", "(", ")", "\n", "\n", "# Log discrepancy tends to work better", "\n", "log_d", "=", "NodeReference", "(", "m", "[", "'d'", "]", ",", "state", "=", "dict", "(", "_operation", "=", "np", ".", "log", ")", ",", "model", "=", "m", ",", "name", "=", "'log_d'", ")", "\n", "\n", "bolfi", "=", "elfi", ".", "BOLFI", "(", "\n", "log_d", ",", "\n", "initial_evidence", "=", "20", ",", "\n", "update_interval", "=", "10", ",", "\n", "batch_size", "=", "5", ",", "\n", "bounds", "=", "{", "'t1'", ":", "(", "-", "2", ",", "2", ")", ",", "\n", "'t2'", ":", "(", "-", "1", ",", "1", ")", "}", ",", "\n", "acq_noise_var", "=", ".1", ")", "\n", "n", "=", "300", "\n", "res", "=", "bolfi", ".", "infer", "(", "300", ")", "\n", "assert", "bolfi", ".", "target_model", ".", "n_evidence", "==", "300", "\n", "acq_x", "=", "bolfi", ".", "target_model", ".", "_gp", ".", "X", "\n", "\n", "# check_inference_with_informative_data(res, 1, true_params, error_bound=.2)", "\n", "assert", "np", ".", "abs", "(", "res", ".", "x_min", "[", "'t1'", "]", "-", "true_params", "[", "'t1'", "]", ")", "<", "0.2", "\n", "assert", "np", ".", "abs", "(", "res", ".", "x_min", "[", "'t2'", "]", "-", "true_params", "[", "'t2'", "]", ")", "<", "0.2", "\n", "\n", "# Test that you can continue the inference where we left off", "\n", "res", "=", "bolfi", ".", "infer", "(", "n", "+", "10", ")", "\n", "assert", "bolfi", ".", "target_model", ".", "n_evidence", "==", "n", "+", "10", "\n", "assert", "np", ".", "array_equal", "(", "bolfi", ".", "target_model", ".", "_gp", ".", "X", "[", ":", "n", ",", ":", "]", ",", "acq_x", ")", "\n", "\n", "post", "=", "bolfi", ".", "extract_posterior", "(", ")", "\n", "\n", "# TODO: make cleaner.", "\n", "post_ml", "=", "minimize", "(", "\n", "post", ".", "_neg_unnormalized_loglikelihood", ",", "\n", "post", ".", "model", ".", "bounds", ",", "\n", "post", ".", "_gradient_neg_unnormalized_loglikelihood", ",", "\n", "post", ".", "prior", ",", "\n", "post", ".", "n_inits", ",", "\n", "post", ".", "max_opt_iters", ",", "\n", "random_state", "=", "post", ".", "random_state", ")", "[", "0", "]", "\n", "# TODO: Here we cannot use the minimize method due to sharp edges in the posterior.", "\n", "#       If a MAP method is implemented, one must be able to set the optimizer and", "\n", "#       provide its options.", "\n", "post_map", "=", "stochastic_optimization", "(", "post", ".", "_neg_unnormalized_logposterior", ",", "post", ".", "model", ".", "bounds", ")", "[", "0", "]", "\n", "vals_ml", "=", "dict", "(", "t1", "=", "np", ".", "array", "(", "[", "post_ml", "[", "0", "]", "]", ")", ",", "t2", "=", "np", ".", "array", "(", "[", "post_ml", "[", "1", "]", "]", ")", ")", "\n", "check_inference_with_informative_data", "(", "vals_ml", ",", "1", ",", "true_params", ",", "error_bound", "=", ".2", ")", "\n", "vals_map", "=", "dict", "(", "t1", "=", "np", ".", "array", "(", "[", "post_map", "[", "0", "]", "]", ")", ",", "t2", "=", "np", ".", "array", "(", "[", "post_map", "[", "1", "]", "]", ")", ")", "\n", "check_inference_with_informative_data", "(", "vals_map", ",", "1", ",", "true_params", ",", "error_bound", "=", ".2", ")", "\n", "\n", "n_samples", "=", "400", "\n", "n_chains", "=", "4", "\n", "res_sampling", "=", "bolfi", ".", "sample", "(", "n_samples", ",", "n_chains", "=", "n_chains", ")", "\n", "check_inference_with_informative_data", "(", "\n", "res_sampling", ".", "samples", ",", "n_samples", "//", "2", "*", "n_chains", ",", "true_params", ",", "error_bound", "=", ".2", ")", "\n", "\n", "# check the cached predictions for RBF", "\n", "x", "=", "np", ".", "random", ".", "random", "(", "(", "1", ",", "len", "(", "true_params", ")", ")", ")", "\n", "bolfi", ".", "target_model", ".", "is_sampling", "=", "True", "\n", "\n", "pred_mu", ",", "pred_var", "=", "bolfi", ".", "target_model", ".", "_gp", ".", "predict", "(", "x", ")", "\n", "pred_cached_mu", ",", "pred_cached_var", "=", "bolfi", ".", "target_model", ".", "predict", "(", "x", ")", "\n", "assert", "(", "np", ".", "allclose", "(", "pred_mu", ",", "pred_cached_mu", ")", ")", "\n", "assert", "(", "np", ".", "allclose", "(", "pred_var", ",", "pred_cached_var", ")", ")", "\n", "\n", "grad_mu", ",", "grad_var", "=", "bolfi", ".", "target_model", ".", "_gp", ".", "predictive_gradients", "(", "x", ")", "\n", "grad_cached_mu", ",", "grad_cached_var", "=", "bolfi", ".", "target_model", ".", "predictive_gradients", "(", "x", ")", "\n", "assert", "(", "np", ".", "allclose", "(", "grad_mu", "[", ":", ",", ":", ",", "0", "]", ",", "grad_cached_mu", ")", ")", "\n", "assert", "(", "np", ".", "allclose", "(", "grad_var", ",", "grad_cached_var", ")", ")", "\n", "\n", "# test calculation of prior logpdfs", "\n", "true_logpdf_prior", "=", "ma2", ".", "CustomPrior1", ".", "logpdf", "(", "x", "[", "0", ",", "0", "]", ",", "2", ")", "\n", "true_logpdf_prior", "+=", "ma2", ".", "CustomPrior2", ".", "logpdf", "(", "x", "[", "0", ",", "1", "]", ",", "x", "[", "0", ",", "0", ",", "]", ",", "1", ")", "\n", "\n", "assert", "np", ".", "isclose", "(", "true_logpdf_prior", ",", "post", ".", "prior", ".", "logpdf", "(", "x", "[", "0", ",", ":", "]", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing._statistics": [[12, 14], ["arr.mean", "arr.var"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.var"], ["def", "_statistics", "(", "arr", ")", ":", "\n", "    ", "return", "arr", ".", "mean", "(", ")", ",", "arr", ".", "var", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing.test_get_adjustment": [[16, 19], ["pytest.raises", "elfi._get_adjustment"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing._get_adjustment"], ["", "def", "test_get_adjustment", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "pp", ".", "_get_adjustment", "(", "'doesnotexist'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing.test_single_parameter_linear_adjustment": [[21, 52], ["elfi.examples.gauss.gauss", "functools.partial", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.Prior", "elfi.Prior", "elfi.Simulator", "elfi.Simulator", "elfi.Summary", "elfi.Summary", "elfi.Distance", "elfi.Distance", "elfi.Rejection().sample", "elfi.Rejection().sample", "elfi.adjust_posterior", "elfi.adjust_posterior", "numpy.allclose", "test_post_processing._statistics", "numpy.random.RandomState", "x.mean", "elfi.Rejection", "elfi.Rejection", "gauss.gauss.sum"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.gauss", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.adjust_posterior", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.adjust_posterior", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing._statistics", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "", "def", "test_single_parameter_linear_adjustment", "(", ")", ":", "\n", "    ", "\"\"\"A regression test against values obtained in the notebook.\"\"\"", "\n", "seed", "=", "20170616", "\n", "n_obs", "=", "50", "\n", "batch_size", "=", "1000", "\n", "mu", ",", "sigma", "=", "(", "5", ",", "1", ")", "\n", "\n", "# Hyperparameters", "\n", "mu0", ",", "sigma0", "=", "(", "10", ",", "100", ")", "\n", "\n", "y_obs", "=", "gauss", ".", "gauss", "(", "\n", "mu", ",", "sigma", ",", "n_obs", "=", "n_obs", ",", "batch_size", "=", "1", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", ")", "\n", "sim_fn", "=", "partial", "(", "gauss", ".", "gauss", ",", "sigma", "=", "sigma", ",", "n_obs", "=", "n_obs", ")", "\n", "\n", "# Posterior", "\n", "n", "=", "y_obs", ".", "shape", "[", "1", "]", "\n", "mu1", "=", "(", "mu0", "/", "sigma0", "**", "2", "+", "y_obs", ".", "sum", "(", ")", "/", "sigma", "**", "2", ")", "/", "(", "1", "/", "sigma0", "**", "2", "+", "n", "/", "sigma", "**", "2", ")", "\n", "sigma1", "=", "(", "1", "/", "sigma0", "**", "2", "+", "n", "/", "sigma", "**", "2", ")", "**", "(", "-", "0.5", ")", "\n", "\n", "# Model", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "'norm'", ",", "mu0", ",", "sigma0", ",", "model", "=", "m", ",", "name", "=", "'mu'", ")", "\n", "elfi", ".", "Simulator", "(", "sim_fn", ",", "m", "[", "'mu'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'gauss'", ")", "\n", "elfi", ".", "Summary", "(", "lambda", "x", ":", "x", ".", "mean", "(", "axis", "=", "1", ")", ",", "m", "[", "'gauss'", "]", ",", "name", "=", "'ss_mean'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'ss_mean'", "]", ",", "name", "=", "'d'", ")", "\n", "\n", "res", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ",", "output_names", "=", "[", "'ss_mean'", "]", ",", "batch_size", "=", "batch_size", ",", "\n", "seed", "=", "seed", ")", ".", "sample", "(", "1000", ",", "threshold", "=", "1", ")", "\n", "adj", "=", "elfi", ".", "adjust_posterior", "(", "model", "=", "m", ",", "sample", "=", "res", ",", "parameter_names", "=", "[", "'mu'", "]", ",", "summary_names", "=", "[", "'ss_mean'", "]", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "_statistics", "(", "adj", ".", "outputs", "[", "'mu'", "]", ")", ",", "(", "4.9772879640569778", ",", "0.02058680115402544", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing.test_nonfinite_values": [[55, 93], ["elfi.examples.gauss.gauss", "functools.partial", "elfi.ElfiModel", "elfi.ElfiModel", "elfi.Prior", "elfi.Prior", "elfi.Simulator", "elfi.Simulator", "elfi.Summary", "elfi.Summary", "elfi.Distance", "elfi.Distance", "elfi.Rejection().sample", "elfi.Rejection().sample", "numpy.append", "numpy.append", "numpy.allclose", "numpy.array", "numpy.array", "pytest.warns", "elfi.adjust_posterior", "elfi.adjust_posterior", "test_post_processing._statistics", "numpy.random.RandomState", "x.mean", "elfi.Rejection", "elfi.Rejection", "gauss.gauss.sum"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.gauss", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.adjust_posterior", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.adjust_posterior", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing._statistics", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "test_nonfinite_values", "(", ")", ":", "\n", "    ", "\"\"\"A regression test against values obtained in the notebook.\"\"\"", "\n", "seed", "=", "20170616", "\n", "n_obs", "=", "50", "\n", "batch_size", "=", "1000", "\n", "mu", ",", "sigma", "=", "(", "5", ",", "1", ")", "\n", "\n", "# Hyperparameters", "\n", "mu0", ",", "sigma0", "=", "(", "10", ",", "100", ")", "\n", "\n", "y_obs", "=", "gauss", ".", "gauss", "(", "\n", "mu", ",", "sigma", ",", "n_obs", "=", "n_obs", ",", "batch_size", "=", "1", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", ")", "\n", "sim_fn", "=", "partial", "(", "gauss", ".", "gauss", ",", "sigma", "=", "sigma", ",", "n_obs", "=", "n_obs", ")", "\n", "\n", "# Posterior", "\n", "n", "=", "y_obs", ".", "shape", "[", "1", "]", "\n", "mu1", "=", "(", "mu0", "/", "sigma0", "**", "2", "+", "y_obs", ".", "sum", "(", ")", "/", "sigma", "**", "2", ")", "/", "(", "1", "/", "sigma0", "**", "2", "+", "n", "/", "sigma", "**", "2", ")", "\n", "sigma1", "=", "(", "1", "/", "sigma0", "**", "2", "+", "n", "/", "sigma", "**", "2", ")", "**", "(", "-", "0.5", ")", "\n", "\n", "# Model", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "'norm'", ",", "mu0", ",", "sigma0", ",", "model", "=", "m", ",", "name", "=", "'mu'", ")", "\n", "elfi", ".", "Simulator", "(", "sim_fn", ",", "m", "[", "'mu'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'gauss'", ")", "\n", "elfi", ".", "Summary", "(", "lambda", "x", ":", "x", ".", "mean", "(", "axis", "=", "1", ")", ",", "m", "[", "'gauss'", "]", ",", "name", "=", "'ss_mean'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'ss_mean'", "]", ",", "name", "=", "'d'", ")", "\n", "\n", "res", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ",", "output_names", "=", "[", "'ss_mean'", "]", ",", "batch_size", "=", "batch_size", ",", "\n", "seed", "=", "seed", ")", ".", "sample", "(", "1000", ",", "threshold", "=", "1", ")", "\n", "\n", "# Add some invalid values", "\n", "res", ".", "outputs", "[", "'mu'", "]", "=", "np", ".", "append", "(", "res", ".", "outputs", "[", "'mu'", "]", ",", "np", ".", "array", "(", "[", "np", ".", "inf", "]", ")", ")", "\n", "res", ".", "outputs", "[", "'ss_mean'", "]", "=", "np", ".", "append", "(", "res", ".", "outputs", "[", "'ss_mean'", "]", ",", "np", ".", "array", "(", "[", "np", ".", "inf", "]", ")", ")", "\n", "\n", "with", "pytest", ".", "warns", "(", "UserWarning", ")", ":", "\n", "        ", "adj", "=", "elfi", ".", "adjust_posterior", "(", "\n", "model", "=", "m", ",", "sample", "=", "res", ",", "parameter_names", "=", "[", "'mu'", "]", ",", "summary_names", "=", "[", "'ss_mean'", "]", ")", "\n", "\n", "", "assert", "np", ".", "allclose", "(", "_statistics", "(", "adj", ".", "outputs", "[", "'mu'", "]", ")", ",", "(", "4.9772879640569778", ",", "0.02058680115402544", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing.test_multi_parameter_linear_adjustment": [[95, 127], ["elfi.examples.ma2.get_model", "elfi.methods.post_processing.LinearAdjustment", "elfi.Rejection().sample", "elfi.Rejection().sample", "elfi.methods.post_processing.adjust_posterior", "numpy.allclose", "numpy.allclose", "test_post_processing._statistics", "test_post_processing._statistics", "elfi.Rejection", "elfi.Rejection"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.adjust_posterior", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing._statistics", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_post_processing._statistics"], ["", "def", "test_multi_parameter_linear_adjustment", "(", ")", ":", "\n", "    ", "\"\"\"A regression test against values obtained in the notebook.\"\"\"", "\n", "seed", "=", "20170511", "\n", "threshold", "=", "0.2", "\n", "batch_size", "=", "1000", "\n", "n_samples", "=", "500", "\n", "m", "=", "ma2", ".", "get_model", "(", "true_params", "=", "[", "0.6", ",", "0.2", "]", ",", "seed_obs", "=", "seed", ")", "\n", "\n", "summary_names", "=", "[", "'S1'", ",", "'S2'", "]", "\n", "parameter_names", "=", "[", "'t1'", ",", "'t2'", "]", "\n", "linear_adjustment", "=", "LinearAdjustment", "(", ")", "\n", "\n", "res", "=", "elfi", ".", "Rejection", "(", "\n", "m", "[", "'d'", "]", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "output_names", "=", "[", "'S1'", ",", "'S2'", "]", ",", "\n", "# output_names=summary_names, # fails ?!?!?", "\n", "seed", "=", "seed", ")", ".", "sample", "(", "\n", "n_samples", ",", "threshold", "=", "threshold", ")", "\n", "adjusted", "=", "adjust_posterior", "(", "\n", "model", "=", "m", ",", "\n", "sample", "=", "res", ",", "\n", "parameter_names", "=", "parameter_names", ",", "\n", "summary_names", "=", "summary_names", ",", "\n", "adjustment", "=", "linear_adjustment", ")", "\n", "t1", "=", "adjusted", ".", "outputs", "[", "'t1'", "]", "\n", "t2", "=", "adjusted", ".", "outputs", "[", "'t2'", "]", "\n", "\n", "t1_mean", ",", "t1_var", "=", "(", "0.51606048286584782", ",", "0.017253007645871756", ")", "\n", "t2_mean", ",", "t2_var", "=", "(", "0.15805189695581101", ",", "0.028004406914362647", ")", "\n", "assert", "np", ".", "allclose", "(", "_statistics", "(", "t1", ")", ",", "(", "t1_mean", ",", "t1_var", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "_statistics", "(", "t2", ")", ",", "(", "t2_mean", ",", "t2_var", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.check_consistent_sample": [[11, 20], ["numpy.allclose", "numpy.allclose", "numpy.array_equal", "numpy.allclose"], "function", ["None"], ["def", "check_consistent_sample", "(", "sample", ",", "sample_diff", ",", "sample_same", ")", ":", "\n", "    ", "assert", "not", "np", ".", "array_equal", "(", "sample", ".", "outputs", "[", "'t1'", "]", ",", "sample_diff", ".", "outputs", "[", "'t1'", "]", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "sample", ".", "outputs", "[", "'t1'", "]", ",", "sample_same", ".", "outputs", "[", "'t1'", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "sample", ".", "outputs", "[", "'t2'", "]", ",", "sample_same", ".", "outputs", "[", "'t2'", "]", ")", "\n", "\n", "# BOLFI does not have d in its outputs", "\n", "if", "'d'", "in", "sample", ".", "outputs", ":", "\n", "        ", "assert", "np", ".", "allclose", "(", "sample", ".", "outputs", "[", "'d'", "]", ",", "sample_same", ".", "outputs", "[", "'d'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.test_rejection": [[22, 39], ["pytest.mark.usefixtures", "elfi.Rejection", "elfi.Rejection.sample", "elfi.Rejection", "elfi.Rejection.sample", "elfi.Rejection", "elfi.Rejection.sample", "test_consistency.check_consistent_sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.check_consistent_sample"], ["", "", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_rejection", "(", "ma2", ")", ":", "\n", "    ", "bs", "=", "3", "\n", "n_samples", "=", "3", "\n", "n_sim", "=", "9", "\n", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "bs", ")", "\n", "sample", "=", "rej", ".", "sample", "(", "n_samples", ",", "n_sim", "=", "n_sim", ")", "\n", "seed", "=", "rej", ".", "seed", "\n", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "bs", ")", "\n", "sample_diff", "=", "rej", ".", "sample", "(", "n_samples", ",", "n_sim", "=", "n_sim", ")", "\n", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "bs", ",", "seed", "=", "seed", ")", "\n", "sample_same", "=", "rej", ".", "sample", "(", "n_samples", ",", "n_sim", "=", "n_sim", ")", "\n", "\n", "check_consistent_sample", "(", "sample", ",", "sample_diff", ",", "sample_same", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.test_smc": [[41, 58], ["pytest.mark.usefixtures", "elfi.SMC", "elfi.SMC.sample", "elfi.SMC", "elfi.SMC.sample", "elfi.SMC", "elfi.SMC.sample", "test_consistency.check_consistent_sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.check_consistent_sample"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_smc", "(", "ma2", ")", ":", "\n", "    ", "bs", "=", "3", "\n", "n_samples", "=", "10", "\n", "thresholds", "=", "[", "1", ",", ".9", ",", ".8", "]", "\n", "\n", "smc", "=", "elfi", ".", "SMC", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "bs", ")", "\n", "sample", "=", "smc", ".", "sample", "(", "n_samples", ",", "thresholds", "=", "thresholds", ")", "\n", "seed", "=", "smc", ".", "seed", "\n", "\n", "smc", "=", "elfi", ".", "SMC", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "bs", ",", "seed", "=", "seed", ")", "\n", "sample_same", "=", "smc", ".", "sample", "(", "n_samples", ",", "thresholds", "=", "thresholds", ")", "\n", "\n", "smc", "=", "elfi", ".", "SMC", "(", "ma2", ",", "'d'", ",", "batch_size", "=", "bs", ")", "\n", "sample_diff", "=", "smc", ".", "sample", "(", "n_samples", ",", "thresholds", "=", "thresholds", ")", "\n", "\n", "check_consistent_sample", "(", "sample", ",", "sample_diff", ",", "sample_same", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.test_bo": [[60, 106], ["pytest.mark.usefixtures", "elfi.BayesianOptimization", "elfi.BayesianOptimization.infer", "elfi.BayesianOptimization", "elfi.BayesianOptimization.infer", "elfi.BayesianOptimization", "elfi.BayesianOptimization.infer", "test_consistency.check_consistent_sample", "numpy.allclose", "numpy.allclose", "numpy.array_equal"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.check_consistent_sample"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_bo", "(", "ma2", ")", ":", "\n", "    ", "bs", "=", "2", "\n", "upd_int", "=", "1", "\n", "n_evi", "=", "16", "\n", "init_evi", "=", "10", "\n", "bounds", "=", "{", "'t1'", ":", "(", "-", "2", ",", "2", ")", ",", "'t2'", ":", "(", "-", "1", ",", "1", ")", "}", "\n", "anv", "=", ".1", "\n", "\n", "bo", "=", "elfi", ".", "BayesianOptimization", "(", "\n", "ma2", ",", "\n", "'d'", ",", "\n", "initial_evidence", "=", "init_evi", ",", "\n", "update_interval", "=", "upd_int", ",", "\n", "batch_size", "=", "bs", ",", "\n", "bounds", "=", "bounds", ",", "\n", "acq_noise_var", "=", "anv", ")", "\n", "res", "=", "bo", ".", "infer", "(", "n_evidence", "=", "n_evi", ")", "\n", "seed", "=", "bo", ".", "seed", "\n", "\n", "bo", "=", "elfi", ".", "BayesianOptimization", "(", "\n", "ma2", ",", "\n", "'d'", ",", "\n", "seed", "=", "seed", ",", "\n", "initial_evidence", "=", "init_evi", ",", "\n", "update_interval", "=", "upd_int", ",", "\n", "batch_size", "=", "bs", ",", "\n", "bounds", "=", "bounds", ",", "\n", "acq_noise_var", "=", "anv", ")", "\n", "res_same", "=", "bo", ".", "infer", "(", "n_evidence", "=", "n_evi", ")", "\n", "\n", "bo", "=", "elfi", ".", "BayesianOptimization", "(", "\n", "ma2", ",", "\n", "'d'", ",", "\n", "initial_evidence", "=", "init_evi", ",", "\n", "update_interval", "=", "upd_int", ",", "\n", "batch_size", "=", "bs", ",", "\n", "bounds", "=", "bounds", ",", "\n", "acq_noise_var", "=", "anv", ")", "\n", "res_diff", "=", "bo", ".", "infer", "(", "n_evidence", "=", "n_evi", ")", "\n", "\n", "check_consistent_sample", "(", "res", ",", "res_diff", ",", "res_same", ")", "\n", "\n", "assert", "not", "np", ".", "array_equal", "(", "res", ".", "x_min", ",", "res_diff", ".", "x_min", ")", "\n", "assert", "np", ".", "allclose", "(", "res", ".", "x_min", "[", "'t1'", "]", ",", "res_same", ".", "x_min", "[", "'t1'", "]", ",", "atol", "=", "1e-07", ")", "\n", "assert", "np", ".", "allclose", "(", "res", ".", "x_min", "[", "'t2'", "]", ",", "res_same", ".", "x_min", "[", "'t2'", "]", ",", "atol", "=", "1e-07", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.test_bolfi": [[109, 153], ["pytest.mark.usefixtures", "elfi.BOLFI", "elfi.BOLFI.sample", "elfi.BOLFI", "elfi.BOLFI.sample", "elfi.BOLFI", "elfi.BOLFI.sample", "test_consistency.check_consistent_sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_consistency.check_consistent_sample"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ",", "'skip_travis'", ")", "\n", "def", "test_bolfi", "(", "ma2", ")", ":", "\n", "    ", "bs", "=", "2", "\n", "n_samples", "=", "4", "\n", "upd_int", "=", "1", "\n", "n_evi", "=", "16", "\n", "init_evi", "=", "10", "\n", "bounds", "=", "{", "'t1'", ":", "(", "-", "2", ",", "2", ")", ",", "'t2'", ":", "(", "-", "1", ",", "1", ")", "}", "\n", "anv", "=", ".1", "\n", "nchains", "=", "2", "\n", "\n", "bolfi", "=", "elfi", ".", "BOLFI", "(", "\n", "ma2", ",", "\n", "'d'", ",", "\n", "initial_evidence", "=", "init_evi", ",", "\n", "update_interval", "=", "upd_int", ",", "\n", "batch_size", "=", "bs", ",", "\n", "bounds", "=", "bounds", ",", "\n", "acq_noise_var", "=", "anv", ")", "\n", "sample", "=", "bolfi", ".", "sample", "(", "n_samples", ",", "n_evidence", "=", "n_evi", ",", "n_chains", "=", "nchains", ")", "\n", "seed", "=", "bolfi", ".", "seed", "\n", "\n", "bolfi", "=", "elfi", ".", "BOLFI", "(", "\n", "ma2", ",", "\n", "'d'", ",", "\n", "initial_evidence", "=", "init_evi", ",", "\n", "update_interval", "=", "upd_int", ",", "\n", "batch_size", "=", "bs", ",", "\n", "bounds", "=", "bounds", ",", "\n", "acq_noise_var", "=", "anv", ")", "\n", "sample_diff", "=", "bolfi", ".", "sample", "(", "n_samples", ",", "n_evidence", "=", "n_evi", ",", "n_chains", "=", "nchains", ")", "\n", "\n", "bolfi", "=", "elfi", ".", "BOLFI", "(", "\n", "ma2", ",", "\n", "'d'", ",", "\n", "seed", "=", "seed", ",", "\n", "initial_evidence", "=", "init_evi", ",", "\n", "update_interval", "=", "upd_int", ",", "\n", "batch_size", "=", "bs", ",", "\n", "bounds", "=", "bounds", ",", "\n", "acq_noise_var", "=", "anv", ")", "\n", "sample_same", "=", "bolfi", ".", "sample", "(", "n_samples", ",", "n_evidence", "=", "n_evi", ",", "n_chains", "=", "nchains", ")", "\n", "\n", "check_consistent_sample", "(", "sample", ",", "sample_diff", ",", "sample_same", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_serialization.test_pickle_ma2": [[11, 26], ["elfi.examples.ma2.get_model", "pickle.loads.get_reference", "numpy.random.seed", "m.get_reference.generate", "pickle.dumps", "pickle.loads", "pickle.loads.get_reference", "numpy.random.seed", "m.get_reference.generate", "numpy.array_equal"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_reference", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_reference", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["def", "test_pickle_ma2", "(", ")", ":", "\n", "    ", "m", "=", "ma2", ".", "get_model", "(", ")", "\n", "d", "=", "m", ".", "get_reference", "(", "'d'", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "res1", "=", "d", ".", "generate", "(", "10", ")", "\n", "\n", "serialized", "=", "pickle", ".", "dumps", "(", "m", ")", "\n", "m", "=", "pickle", ".", "loads", "(", "serialized", ")", "\n", "d", "=", "m", ".", "get_reference", "(", "'d'", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "res2", "=", "d", ".", "generate", "(", "10", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "res1", ",", "res2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_serialization.test_pickle_ma2_compiled_and_loaded": [[28, 44], ["elfi.client.ClientBase.compile", "elfi.client.ClientBase.load_data", "numpy.random.seed", "elfi.executor.Executor.execute", "pickle.dumps", "pickle.loads", "numpy.random.seed", "elfi.executor.Executor.execute", "numpy.array_equal", "elfi.model.elfi_model.ComputationContext"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.load_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.Executor.execute", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.Executor.execute"], ["", "def", "test_pickle_ma2_compiled_and_loaded", "(", "ma2", ")", ":", "\n", "    ", "compiled", "=", "ClientBase", ".", "compile", "(", "ma2", ".", "source_net", ",", "[", "'d'", "]", ")", "\n", "loaded", "=", "ClientBase", ".", "load_data", "(", "compiled", ",", "ComputationContext", "(", ")", ",", "0", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result", "=", "Executor", ".", "execute", "(", "loaded", ")", "\n", "res1", "=", "result", "[", "'d'", "]", "\n", "\n", "serialized", "=", "pickle", ".", "dumps", "(", "loaded", ")", "\n", "loaded", "=", "pickle", ".", "loads", "(", "serialized", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "result", "=", "Executor", ".", "execute", "(", "loaded", ")", "\n", "res2", "=", "result", "[", "'d'", "]", "\n", "\n", "assert", "np", ".", "array_equal", "(", "res1", ",", "res2", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_compilation.test_meta_param": [[7, 21], ["pytest.mark.usefixtures", "ma2.get_reference", "ma2.get_reference.generate"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_reference", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_meta_param", "(", "ma2", ")", ":", "\n", "    ", "sim", "=", "ma2", ".", "get_reference", "(", "'MA2'", ")", "\n", "\n", "# Test that it is passed", "\n", "try", ":", "\n", "# Add to state", "\n", "        ", "sim", "[", "'_uses_meta'", "]", "=", "True", "\n", "sim", ".", "generate", "(", ")", "\n", "assert", "False", ",", "\"Should raise an error\"", "\n", "", "except", "TypeError", ":", "\n", "        ", "assert", "True", "\n", "", "except", "ipyparallel", ".", "error", ".", "RemoteError", ":", "\n", "        ", "assert", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_compilation.test_batch_index_value": [[25, 40], ["elfi.ElfiModel", "elfi.Operation", "elfi.get_client", "elfi.ComputationContext", "elfi.get_client.compile", "elfi.get_client.load_data", "elfi.get_client.compute"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.load_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compute"], ["", "", "def", "test_batch_index_value", "(", "ma2", ")", ":", "\n", "    ", "def", "bi", "(", "meta", ")", ":", "\n", "        ", "return", "meta", "[", "'batch_index'", "]", "\n", "\n", "# Test the correct batch_index value", "\n", "", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "op", "=", "elfi", ".", "Operation", "(", "bi", ",", "model", "=", "m", ",", "name", "=", "'op'", ")", "\n", "op", "[", "'_uses_meta'", "]", "=", "True", "\n", "client", "=", "elfi", ".", "get_client", "(", ")", "\n", "c", "=", "elfi", ".", "ComputationContext", "(", ")", "\n", "compiled_net", "=", "client", ".", "compile", "(", "m", ".", "source_net", ",", "m", ".", "nodes", ")", "\n", "loaded_net", "=", "client", ".", "load_data", "(", "compiled_net", ",", "c", ",", "batch_index", "=", "3", ")", "\n", "res", "=", "client", ".", "compute", "(", "loaded_net", ")", "\n", "\n", "assert", "res", "[", "'op'", "]", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.functional.test_compilation.test_reduce_compiler": [[42, 48], ["client.compile", "client.compile.has_node", "client.compile", "client.compile.has_node"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node"], ["", "def", "test_reduce_compiler", "(", "ma2", ",", "client", ")", ":", "\n", "    ", "compiled_net", "=", "client", ".", "compile", "(", "ma2", ".", "source_net", ")", "\n", "assert", "compiled_net", ".", "has_node", "(", "'S1'", ")", "\n", "\n", "compiled_net2", "=", "client", ".", "compile", "(", "ma2", ".", "source_net", ",", "[", "'MA2'", "]", ")", "\n", "assert", "not", "compiled_net2", ".", "has_node", "(", "'S1'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_bo.Test_MaxVar.test_acq_bounds": [[130, 152], ["len", "range", "range", "acq_maxvar.acquire", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire"], ["def", "test_acq_bounds", "(", "self", ",", "acq_maxvar", ")", ":", "\n", "        ", "\"\"\"Check if the acquisition is performed within the bounds.\n\n        Parameters\n        ----------\n        acq_maxvar : MaxVar\n            Acquisition method.\n\n        \"\"\"", "\n", "bounds", "=", "acq_maxvar", ".", "model", ".", "bounds", "\n", "n_dim_fixture", "=", "len", "(", "acq_maxvar", ".", "model", ".", "bounds", ")", "\n", "batch_size", "=", "2", "\n", "n_it", "=", "2", "\n", "\n", "# Acquiring points.", "\n", "for", "it", "in", "range", "(", "n_it", ")", ":", "\n", "            ", "batch_theta", "=", "acq_maxvar", ".", "acquire", "(", "n", "=", "batch_size", ",", "t", "=", "it", ")", "\n", "\n", "# Checking if the acquired points are within the bounds.", "\n", "", "for", "dim", "in", "range", "(", "n_dim_fixture", ")", ":", "\n", "            ", "assert", "np", ".", "all", "(", "(", "batch_theta", "[", ":", ",", "dim", "]", ">=", "bounds", "[", "dim", "]", "[", "0", "]", ")", "&", "\n", "(", "batch_theta", "[", ":", ",", "dim", "]", "<=", "bounds", "[", "dim", "]", "[", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_bo.Test_MaxVar.test_gradient": [[153, 173], ["len", "GradientChecker", "GradientChecker.checkgrad", "numpy.random.randn"], "methods", ["None"], ["", "", "def", "test_gradient", "(", "self", ",", "acq_maxvar", ")", ":", "\n", "        ", "\"\"\"Test the gradient function using GPy's GradientChecker.\n\n        Parameters\n        ----------\n        acq_maxvar : MaxVar\n            Acquisition method.\n\n        \"\"\"", "\n", "from", "GPy", ".", "models", ".", "gradient_checker", "import", "GradientChecker", "\n", "n_pts_test", "=", "20", "\n", "n_dim_fixture", "=", "len", "(", "acq_maxvar", ".", "model", ".", "bounds", ")", "\n", "\n", "checker_grad", "=", "GradientChecker", "(", "acq_maxvar", ".", "evaluate", ",", "\n", "acq_maxvar", ".", "evaluate_gradient", ",", "\n", "np", ".", "random", ".", "randn", "(", "n_pts_test", ",", "n_dim_fixture", ")", ")", "\n", "\n", "# The tolerance corresponds to the allowed deviation from the unity of", "\n", "# the ratio between analytical and numerical gradients.", "\n", "assert", "checker_grad", ".", "checkgrad", "(", "tolerance", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_bo.Test_RandMaxVar.test_acq_bounds": [[178, 201], ["len", "range", "range", "acq_randmaxvar.acquire", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire"], ["@", "pytest", ".", "mark", ".", "slowtest", "\n", "def", "test_acq_bounds", "(", "self", ",", "acq_randmaxvar", ")", ":", "\n", "        ", "\"\"\"Check if the acquisition is performed within the bounds.\n\n        Parameters\n        ----------\n        acq_randmaxvar : RandMaxVar\n            Acquisition method.\n\n        \"\"\"", "\n", "bounds", "=", "acq_randmaxvar", ".", "model", ".", "bounds", "\n", "n_dim_fixture", "=", "len", "(", "acq_randmaxvar", ".", "model", ".", "bounds", ")", "\n", "batch_size", "=", "2", "\n", "n_it", "=", "2", "\n", "\n", "# Acquiring points.", "\n", "for", "it", "in", "range", "(", "n_it", ")", ":", "\n", "            ", "batch_theta", "=", "acq_randmaxvar", ".", "acquire", "(", "n", "=", "batch_size", ",", "t", "=", "it", ")", "\n", "\n", "# Checking if the acquired points are within the bounds.", "\n", "", "for", "dim", "in", "range", "(", "n_dim_fixture", ")", ":", "\n", "            ", "assert", "np", ".", "all", "(", "(", "batch_theta", "[", ":", ",", "dim", "]", ">=", "bounds", "[", "dim", "]", "[", "0", "]", ")", "&", "\n", "(", "batch_theta", "[", ":", ",", "dim", "]", "<=", "bounds", "[", "dim", "]", "[", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_bo.Test_ExpIntVar.test_acq_bounds": [[206, 229], ["len", "range", "range", "acq_expintvar.acquire", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire"], ["@", "pytest", ".", "mark", ".", "slowtest", "\n", "def", "test_acq_bounds", "(", "self", ",", "acq_expintvar", ")", ":", "\n", "        ", "\"\"\"Check if the acquisition is performed within the bounds.\n\n        Parameters\n        ----------\n        acq_expintvar : ExpIntVar\n            Acquisition method.\n\n        \"\"\"", "\n", "bounds", "=", "acq_expintvar", ".", "model", ".", "bounds", "\n", "n_dim_fixture", "=", "len", "(", "acq_expintvar", ".", "model", ".", "bounds", ")", "\n", "batch_size", "=", "2", "\n", "n_it", "=", "2", "\n", "\n", "# Acquiring points.", "\n", "for", "it", "in", "range", "(", "n_it", ")", ":", "\n", "            ", "batch_theta", "=", "acq_expintvar", ".", "acquire", "(", "n", "=", "batch_size", ",", "t", "=", "it", ")", "\n", "\n", "# Checking if the acquired points are within the bounds.", "\n", "", "for", "dim", "in", "range", "(", "n_dim_fixture", ")", ":", "\n", "            ", "assert", "np", ".", "all", "(", "(", "batch_theta", "[", ":", ",", "dim", "]", ">=", "bounds", "[", "dim", "]", "[", "0", "]", ")", "&", "\n", "(", "batch_theta", "[", ":", ",", "dim", "]", "<=", "bounds", "[", "dim", "]", "[", "1", "]", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_bo.test_BO": [[9, 42], ["pytest.mark.usefixtures", "elfi.Operation", "elfi.Operation", "elfi.Rejection().sample", "elfi.Rejection().sample", "elfi.BayesianOptimization", "elfi.BayesianOptimization", "elfi.BayesianOptimization.infer", "elfi.BayesianOptimization.infer", "numpy.array_equal", "elfi.Rejection", "elfi.Rejection"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer"], ["@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_BO", "(", "ma2", ")", ":", "\n", "# Log transform of the distance usually smooths the distance surface", "\n", "    ", "log_d", "=", "elfi", ".", "Operation", "(", "np", ".", "log", ",", "ma2", "[", "'d'", "]", ",", "name", "=", "'log_d'", ")", "\n", "\n", "n_init", "=", "20", "\n", "res_init", "=", "elfi", ".", "Rejection", "(", "log_d", ",", "batch_size", "=", "5", ")", ".", "sample", "(", "n_init", ",", "quantile", "=", "1", ")", "\n", "\n", "bounds", "=", "{", "n", ":", "(", "-", "2", ",", "2", ")", "for", "n", "in", "ma2", ".", "parameter_names", "}", "\n", "bo", "=", "elfi", ".", "BayesianOptimization", "(", "\n", "log_d", ",", "initial_evidence", "=", "res_init", ".", "outputs", ",", "update_interval", "=", "10", ",", "batch_size", "=", "5", ",", "bounds", "=", "bounds", ")", "\n", "assert", "bo", ".", "target_model", ".", "n_evidence", "==", "n_init", "\n", "assert", "bo", ".", "n_evidence", "==", "n_init", "\n", "assert", "bo", ".", "n_precomputed_evidence", "==", "n_init", "\n", "assert", "bo", ".", "n_initial_evidence", "==", "n_init", "\n", "\n", "n1", "=", "5", "\n", "bo", ".", "infer", "(", "n_init", "+", "n1", ")", "\n", "\n", "assert", "bo", ".", "target_model", ".", "n_evidence", "==", "n_init", "+", "n1", "\n", "assert", "bo", ".", "n_evidence", "==", "n_init", "+", "n1", "\n", "assert", "bo", ".", "n_precomputed_evidence", "==", "n_init", "\n", "assert", "bo", ".", "n_initial_evidence", "==", "n_init", "\n", "\n", "n2", "=", "5", "\n", "bo", ".", "infer", "(", "n_init", "+", "n1", "+", "n2", ")", "\n", "\n", "assert", "bo", ".", "target_model", ".", "n_evidence", "==", "n_init", "+", "n1", "+", "n2", "\n", "assert", "bo", ".", "n_evidence", "==", "n_init", "+", "n1", "+", "n2", "\n", "assert", "bo", ".", "n_precomputed_evidence", "==", "n_init", "\n", "assert", "bo", ".", "n_initial_evidence", "==", "n_init", "\n", "\n", "assert", "np", ".", "array_equal", "(", "bo", ".", "target_model", ".", "_gp", ".", "X", "[", ":", "n_init", ",", "0", "]", ",", "res_init", ".", "samples_array", "[", ":", ",", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_bo.test_async": [[44, 51], ["pytest.mark.usefixtures", "elfi.BayesianOptimization", "elfi.BayesianOptimization", "elfi.BayesianOptimization.infer"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_async", "(", "ma2", ")", ":", "\n", "    ", "bounds", "=", "{", "n", ":", "(", "-", "2", ",", "2", ")", "for", "n", "in", "ma2", ".", "parameter_names", "}", "\n", "bo", "=", "elfi", ".", "BayesianOptimization", "(", "\n", "ma2", ",", "'d'", ",", "initial_evidence", "=", "0", ",", "update_interval", "=", "2", ",", "batch_size", "=", "2", ",", "bounds", "=", "bounds", ",", "async_acq", "=", "True", ")", "\n", "n_samples", "=", "5", "\n", "bo", ".", "infer", "(", "n_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_bo.test_BO_works_with_zero_init_samples": [[53, 69], ["pytest.mark.usefixtures", "elfi.Operation", "elfi.Operation", "elfi.BayesianOptimization", "elfi.BayesianOptimization", "elfi.BayesianOptimization.infer"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_BO_works_with_zero_init_samples", "(", "ma2", ")", ":", "\n", "    ", "log_d", "=", "elfi", ".", "Operation", "(", "np", ".", "log", ",", "ma2", "[", "'d'", "]", ",", "name", "=", "'log_d'", ")", "\n", "bounds", "=", "{", "n", ":", "(", "-", "2", ",", "2", ")", "for", "n", "in", "ma2", ".", "parameter_names", "}", "\n", "bo", "=", "elfi", ".", "BayesianOptimization", "(", "\n", "log_d", ",", "initial_evidence", "=", "0", ",", "update_interval", "=", "4", ",", "batch_size", "=", "2", ",", "bounds", "=", "bounds", ")", "\n", "assert", "bo", ".", "target_model", ".", "n_evidence", "==", "0", "\n", "assert", "bo", ".", "n_evidence", "==", "0", "\n", "assert", "bo", ".", "n_precomputed_evidence", "==", "0", "\n", "assert", "bo", ".", "n_initial_evidence", "==", "0", "\n", "n_samples", "=", "4", "\n", "bo", ".", "infer", "(", "n_samples", ")", "\n", "assert", "bo", ".", "target_model", ".", "n_evidence", "==", "n_samples", "\n", "assert", "bo", ".", "n_evidence", "==", "n_samples", "\n", "assert", "bo", ".", "n_precomputed_evidence", "==", "0", "\n", "assert", "bo", ".", "n_initial_evidence", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_bo.test_acquisition": [[71, 125], ["elfi.methods.bo.gpy_regression.GPyRegression", "numpy.random.uniform", "numpy.random.uniform", "numpy.column_stack", "numpy.random.rand", "elfi.methods.bo.gpy_regression.GPyRegression.update", "elfi.LCBSC", "acquisition.UniformAcquisition.acquire", "numpy.allclose", "numpy.allclose", "elfi.LCBSC", "acquisition.UniformAcquisition.acquire", "numpy.all", "numpy.all", "numpy.random.uniform", "elfi.LCBSC", "acquisition.UniformAcquisition.acquire", "numpy.all", "numpy.all", "elfi.UniformAcquisition", "acquisition.UniformAcquisition.acquire", "numpy.all", "numpy.all", "numpy.random.rand", "numpy.eye", "pytest.raises", "elfi.LCBSC"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire"], ["", "def", "test_acquisition", "(", ")", ":", "\n", "    ", "n_params", "=", "2", "\n", "n", "=", "10", "\n", "n2", "=", "5", "\n", "parameter_names", "=", "[", "'a'", ",", "'b'", "]", "\n", "bounds", "=", "{", "'a'", ":", "[", "-", "2", ",", "3", "]", ",", "'b'", ":", "[", "5", ",", "6", "]", "}", "\n", "target_model", "=", "GPyRegression", "(", "parameter_names", ",", "bounds", "=", "bounds", ")", "\n", "x1", "=", "np", ".", "random", ".", "uniform", "(", "*", "bounds", "[", "'a'", "]", ",", "n", ")", "\n", "x2", "=", "np", ".", "random", ".", "uniform", "(", "*", "bounds", "[", "'b'", "]", ",", "n", ")", "\n", "x", "=", "np", ".", "column_stack", "(", "(", "x1", ",", "x2", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "rand", "(", "n", ")", "\n", "target_model", ".", "update", "(", "x", ",", "y", ")", "\n", "\n", "# check acquisition without noise", "\n", "acq_noise_var", "=", "0", "\n", "t", "=", "1", "\n", "acquisition_method", "=", "acquisition", ".", "LCBSC", "(", "target_model", ",", "noise_var", "=", "acq_noise_var", ")", "\n", "new", "=", "acquisition_method", ".", "acquire", "(", "n2", ",", "t", "=", "t", ")", "\n", "assert", "np", ".", "allclose", "(", "new", "[", "1", ":", ",", "0", "]", ",", "new", "[", "0", ",", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "new", "[", "1", ":", ",", "1", "]", ",", "new", "[", "0", ",", "1", "]", ")", "\n", "\n", "# check acquisition with scalar noise", "\n", "acq_noise_var", "=", "2", "\n", "t", "=", "1", "\n", "acquisition_method", "=", "acquisition", ".", "LCBSC", "(", "target_model", ",", "noise_var", "=", "acq_noise_var", ")", "\n", "new", "=", "acquisition_method", ".", "acquire", "(", "n2", ",", "t", "=", "t", ")", "\n", "assert", "new", ".", "shape", "==", "(", "n2", ",", "n_params", ")", "\n", "assert", "np", ".", "all", "(", "(", "new", "[", ":", ",", "0", "]", ">=", "bounds", "[", "'a'", "]", "[", "0", "]", ")", "&", "(", "new", "[", ":", ",", "0", "]", "<=", "bounds", "[", "'a'", "]", "[", "1", "]", ")", ")", "\n", "assert", "np", ".", "all", "(", "(", "new", "[", ":", ",", "1", "]", ">=", "bounds", "[", "'b'", "]", "[", "0", "]", ")", "&", "(", "new", "[", ":", ",", "1", "]", "<=", "bounds", "[", "'b'", "]", "[", "1", "]", ")", ")", "\n", "\n", "# check acquisition with separate variance for dimensions", "\n", "acq_noise_var", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "5", ",", "size", "=", "2", ")", "\n", "t", "=", "1", "\n", "acquisition_method", "=", "acquisition", ".", "LCBSC", "(", "target_model", ",", "noise_var", "=", "acq_noise_var", ")", "\n", "new", "=", "acquisition_method", ".", "acquire", "(", "n2", ",", "t", "=", "t", ")", "\n", "assert", "new", ".", "shape", "==", "(", "n2", ",", "n_params", ")", "\n", "assert", "np", ".", "all", "(", "(", "new", "[", ":", ",", "0", "]", ">=", "bounds", "[", "'a'", "]", "[", "0", "]", ")", "&", "(", "new", "[", ":", ",", "0", "]", "<=", "bounds", "[", "'a'", "]", "[", "1", "]", ")", ")", "\n", "assert", "np", ".", "all", "(", "(", "new", "[", ":", ",", "1", "]", ">=", "bounds", "[", "'b'", "]", "[", "0", "]", ")", "&", "(", "new", "[", ":", ",", "1", "]", "<=", "bounds", "[", "'b'", "]", "[", "1", "]", ")", ")", "\n", "\n", "# check acquisition with arbitrary covariance matrix", "\n", "acq_noise_cov", "=", "np", ".", "random", ".", "rand", "(", "n_params", ",", "n_params", ")", "*", "0.5", "\n", "acq_noise_cov", "+=", "acq_noise_cov", ".", "T", "\n", "acq_noise_cov", "+=", "n_params", "*", "np", ".", "eye", "(", "n_params", ")", "\n", "t", "=", "1", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "acquisition", ".", "LCBSC", "(", "target_model", ",", "noise_var", "=", "acq_noise_cov", ")", "\n", "\n", "# test Uniform Acquisition", "\n", "", "t", "=", "1", "\n", "acquisition_method", "=", "acquisition", ".", "UniformAcquisition", "(", "target_model", ",", "noise_var", "=", "acq_noise_var", ")", "\n", "new", "=", "acquisition_method", ".", "acquire", "(", "n2", ",", "t", "=", "t", ")", "\n", "assert", "new", ".", "shape", "==", "(", "n2", ",", "n_params", ")", "\n", "assert", "np", ".", "all", "(", "(", "new", "[", ":", ",", "0", "]", ">=", "bounds", "[", "'a'", "]", "[", "0", "]", ")", "&", "(", "new", "[", ":", ",", "0", "]", "<=", "bounds", "[", "'a'", "]", "[", "1", "]", ")", ")", "\n", "assert", "np", ".", "all", "(", "(", "new", "[", ":", ",", "1", "]", ">=", "bounds", "[", "'b'", "]", "[", "0", "]", ")", "&", "(", "new", "[", ":", ",", "1", "]", "<=", "bounds", "[", "'b'", "]", "[", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_store.test_npy_array": [[11, 72], ["numpy.random.rand", "numpy.random.rand", "numpy.ones", "numpy.random.rand", "elfi.store.NpyArray", "elfi.store.NpyArray.append", "numpy.array_equal", "elfi.store.NpyArray.close", "numpy.load", "numpy.array_equal", "elfi.store.NpyArray", "elfi.store.NpyArray.append", "elfi.store.NpyArray.flush", "numpy.load", "numpy.array_equal", "elfi.store.NpyArray.append", "numpy.array_equal", "elfi.store.NpyArray.flush", "numpy.load", "numpy.array_equal", "elfi.store.NpyArray.close", "numpy.load", "numpy.array_equal", "elfi.store.NpyArray", "pickle.dumps", "pickle.loads", "numpy.array_equal", "elfi.store.NpyArray", "elfi.store.NpyArray.truncate", "numpy.array_equal", "elfi.store.NpyArray.close", "numpy.load", "numpy.array_equal", "elfi.store.NpyArray", "elfi.store.NpyArray.append", "elfi.store.NpyArray.close", "numpy.load", "numpy.array_equal", "os.remove", "pytest.raises", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.truncate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load"], ["def", "test_npy_array", "(", ")", ":", "\n", "    ", "filename", "=", "'test.npy'", "\n", "\n", "original", "=", "np", ".", "random", ".", "rand", "(", "3", ",", "2", ")", "\n", "append", "=", "np", ".", "random", ".", "rand", "(", "10", ",", "2", ")", "\n", "ones", "=", "np", ".", "ones", "(", "(", "10", ",", "2", ")", ")", "\n", "append2", "=", "np", ".", "random", ".", "rand", "(", "23", ",", "2", ")", "\n", "\n", "arr", "=", "NpyArray", "(", "filename", ",", "truncate", "=", "True", ")", "\n", "arr", ".", "append", "(", "original", ")", "\n", "assert", "np", ".", "array_equal", "(", "original", ",", "arr", "[", ":", "]", ")", "\n", "arr", ".", "close", "(", ")", "\n", "loaded", "=", "np", ".", "load", "(", "filename", ")", "\n", "assert", "np", ".", "array_equal", "(", "original", ",", "loaded", ")", "\n", "\n", "# Test appending and reading", "\n", "arr", "=", "NpyArray", "(", "filename", ")", "\n", "arr", ".", "append", "(", "append", ")", "\n", "arr", ".", "flush", "(", ")", "\n", "loaded", "=", "np", ".", "load", "(", "filename", ")", "\n", "assert", "np", ".", "array_equal", "(", "np", ".", "r_", "[", "original", ",", "append", "]", ",", "loaded", ")", "\n", "\n", "# Test further appending", "\n", "arr", ".", "append", "(", "append2", ")", "\n", "assert", "np", ".", "array_equal", "(", "np", ".", "r_", "[", "original", ",", "append", ",", "append2", "]", ",", "arr", "[", ":", "]", ")", "\n", "arr", ".", "flush", "(", ")", "\n", "loaded", "=", "np", ".", "load", "(", "filename", ")", "\n", "assert", "np", ".", "array_equal", "(", "np", ".", "r_", "[", "original", ",", "append", ",", "append2", "]", ",", "loaded", ")", "\n", "\n", "# Test that writing over the array fails", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", ":", "\n", "        ", "arr", "[", "len", "(", "loaded", ")", ":", "len", "(", "loaded", ")", "+", "10", ",", ":", "]", "=", "ones", "\n", "\n", "# Test rewriting", "\n", "", "arr", "[", "3", ":", "13", ",", ":", "]", "=", "ones", "\n", "arr", ".", "close", "(", ")", "\n", "loaded", "=", "np", ".", "load", "(", "filename", ")", "\n", "assert", "np", ".", "array_equal", "(", "np", ".", "r_", "[", "original", ",", "ones", ",", "append2", "]", ",", "loaded", ")", "\n", "\n", "# Test pickling", "\n", "arr", "=", "NpyArray", "(", "filename", ")", "\n", "serialized", "=", "pickle", ".", "dumps", "(", "arr", ")", "\n", "arr", "=", "pickle", ".", "loads", "(", "serialized", ")", "\n", "assert", "np", ".", "array_equal", "(", "np", ".", "r_", "[", "original", ",", "ones", ",", "append2", "]", ",", "arr", "[", ":", "]", ")", "\n", "\n", "# Test truncate method", "\n", "arr", "=", "NpyArray", "(", "filename", ")", "\n", "arr", ".", "truncate", "(", "len", "(", "original", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "original", ",", "arr", "[", ":", "]", ")", "\n", "arr", ".", "close", "(", ")", "\n", "loaded", "=", "np", ".", "load", "(", "filename", ")", "\n", "assert", "np", ".", "array_equal", "(", "original", ",", "loaded", ")", "\n", "\n", "# Try that truncation in initialization works", "\n", "arr", "=", "NpyArray", "(", "filename", ",", "truncate", "=", "True", ")", "\n", "arr", ".", "append", "(", "append", ")", "\n", "arr", ".", "close", "(", ")", "\n", "loaded", "=", "np", ".", "load", "(", "filename", ")", "\n", "assert", "np", ".", "array_equal", "(", "append", ",", "loaded", ")", "\n", "\n", "os", ".", "remove", "(", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_store.test_npy_array_multiple_instances": [[74, 99], ["numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "elfi.store.NpyArray", "elfi.store.NpyArray.flush", "elfi.store.NpyArray.append", "elfi.store.NpyArray.fs.flush", "elfi.store.NpyArray", "elfi.store.NpyArray.append", "numpy.array_equal", "elfi.store.NpyArray.close", "elfi.store.NpyArray.close", "os.remove", "len", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "def", "test_npy_array_multiple_instances", "(", ")", ":", "\n", "    ", "original", "=", "np", ".", "random", ".", "rand", "(", "3", ",", "2", ")", "\n", "append", "=", "np", ".", "random", ".", "rand", "(", "10", ",", "2", ")", "\n", "append_clone", "=", "np", ".", "random", ".", "rand", "(", "10", ",", "2", ")", "\n", "\n", "filename", "=", "'test.npy'", "\n", "\n", "# Test appending and reading", "\n", "arr", "=", "NpyArray", "(", "filename", ",", "array", "=", "original", ")", "\n", "arr", ".", "flush", "(", ")", "\n", "arr", ".", "append", "(", "append", ")", "\n", "assert", "(", "len", "(", "arr", ")", "==", "13", ")", "\n", "\n", "arr", ".", "fs", ".", "flush", "(", ")", "\n", "\n", "# Make a second instance and a simultaneous append", "\n", "arr_clone", "=", "NpyArray", "(", "filename", ")", "\n", "arr_clone", ".", "append", "(", "append_clone", ")", "\n", "assert", "len", "(", "arr_clone", ")", "==", "13", "\n", "assert", "np", ".", "array_equal", "(", "arr_clone", "[", ":", "]", ",", "np", ".", "r_", "[", "original", ",", "append_clone", "]", ")", "\n", "\n", "arr", ".", "close", "(", ")", "\n", "arr_clone", ".", "close", "(", ")", "\n", "\n", "os", ".", "remove", "(", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_store.test_array_pool": [[101, 157], ["elfi.store.ArrayPool", "elfi.Rejection", "elfi.store.OutputPool", "elfi.Rejection", "elfi.Rejection.sample", "range", "elfi.Rejection.sample", "elfi.Rejection", "numpy.array_equal", "ArrayPool.open.close", "elfi.store.ArrayPool.open", "ArrayPool.open.close", "os.rename", "elfi.store.ArrayPool.open", "numpy.array_equal", "numpy.random.rand", "os.path.join", "elfi.store.NpyArray", "ArrayPool.open.add_store", "numpy.array_equal", "ArrayPool.open.delete", "os.rmdir", "elfi.Rejection.sample", "len", "len", "len", "int", "numpy.array_equal", "len", "len", "len", "elfi.store.ArrayStore", "len", "os.path.exists", "elfi.Rejection.sample", "ArrayPool.open.get_store"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.add_store", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.delete", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.get_store"], ["", "def", "test_array_pool", "(", "ma2", ")", ":", "\n", "    ", "pool", "=", "ArrayPool", "(", "[", "'MA2'", ",", "'S1'", "]", ")", "\n", "N", "=", "100", "\n", "bs", "=", "100", "\n", "total", "=", "1000", "\n", "rej_pool", "=", "elfi", ".", "Rejection", "(", "ma2", "[", "'d'", "]", ",", "batch_size", "=", "bs", ",", "pool", "=", "pool", ")", "\n", "means", "=", "rej_pool", ".", "sample", "(", "N", ",", "n_sim", "=", "total", ")", ".", "sample_means_array", "\n", "\n", "assert", "len", "(", "pool", ".", "stores", "[", "'MA2'", "]", ")", "==", "total", "/", "bs", "\n", "assert", "len", "(", "pool", ".", "stores", "[", "'S1'", "]", ")", "==", "total", "/", "bs", "\n", "assert", "len", "(", "pool", ")", "==", "total", "/", "bs", "\n", "assert", "not", "'t1'", "in", "pool", ".", "stores", "\n", "\n", "batch2", "=", "pool", "[", "2", "]", "\n", "\n", "# Test against in memory pool with using batches", "\n", "pool2", "=", "OutputPool", "(", "[", "'MA2'", ",", "'S1'", "]", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "ma2", "[", "'d'", "]", ",", "batch_size", "=", "bs", ",", "pool", "=", "pool2", ",", "seed", "=", "pool", ".", "seed", ")", "\n", "rej", ".", "sample", "(", "N", ",", "n_sim", "=", "total", ")", "\n", "for", "bi", "in", "range", "(", "int", "(", "total", "/", "bs", ")", ")", ":", "\n", "        ", "assert", "np", ".", "array_equal", "(", "pool", ".", "stores", "[", "'S1'", "]", "[", "bi", "]", ",", "pool2", ".", "stores", "[", "'S1'", "]", "[", "bi", "]", ")", "\n", "\n", "# Test running the inference again", "\n", "", "rej_pool", ".", "sample", "(", "N", ",", "n_sim", "=", "total", ")", "\n", "\n", "# Test using the same pool with another sampler", "\n", "rej_pool_new", "=", "elfi", ".", "Rejection", "(", "ma2", "[", "'d'", "]", ",", "batch_size", "=", "bs", ",", "pool", "=", "pool", ")", "\n", "assert", "len", "(", "pool", ")", "==", "total", "/", "bs", "\n", "assert", "np", ".", "array_equal", "(", "means", ",", "rej_pool_new", ".", "sample", "(", "N", ",", "n_sim", "=", "total", ")", ".", "sample_means_array", ")", "\n", "\n", "# Test closing and opening the pool", "\n", "pool", ".", "close", "(", ")", "\n", "pool", "=", "ArrayPool", ".", "open", "(", "pool", ".", "name", ")", "\n", "assert", "len", "(", "pool", ")", "==", "total", "/", "bs", "\n", "pool", ".", "close", "(", ")", "\n", "\n", "# Test opening from a moved location", "\n", "os", ".", "rename", "(", "pool", ".", "path", ",", "pool", ".", "path", "+", "'_move'", ")", "\n", "pool", "=", "ArrayPool", ".", "open", "(", "pool", ".", "name", "+", "'_move'", ")", "\n", "assert", "len", "(", "pool", ")", "==", "total", "/", "bs", "\n", "assert", "np", ".", "array_equal", "(", "pool", "[", "2", "]", "[", "'S1'", "]", ",", "batch2", "[", "'S1'", "]", ")", "\n", "\n", "# Test adding a random .npy file", "\n", "r", "=", "np", ".", "random", ".", "rand", "(", "3", "*", "bs", ")", "\n", "newfile", "=", "os", ".", "path", ".", "join", "(", "pool", ".", "path", ",", "'test.npy'", ")", "\n", "arr", "=", "NpyArray", "(", "newfile", ",", "r", ")", "\n", "pool", ".", "add_store", "(", "'test'", ",", "ArrayStore", "(", "arr", ",", "bs", ")", ")", "\n", "assert", "len", "(", "pool", ".", "get_store", "(", "'test'", ")", ")", "==", "3", "\n", "assert", "np", ".", "array_equal", "(", "pool", "[", "2", "]", "[", "'test'", "]", ",", "r", "[", "-", "bs", ":", "]", ")", "\n", "\n", "# Test removing the pool", "\n", "pool", ".", "delete", "(", ")", "\n", "assert", "not", "os", ".", "path", ".", "exists", "(", "pool", ".", "path", ")", "\n", "\n", "# Remove the pool container folder", "\n", "os", ".", "rmdir", "(", "pool", ".", "prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_store.run_basic_store_tests": [[159, 202], ["numpy.random.rand", "numpy.array_equal", "numpy.array_equal", "store.clear", "range", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear"], ["", "def", "run_basic_store_tests", "(", "store", ",", "content", ")", ":", "\n", "    ", "\"\"\"\n\n    Parameters\n    ----------\n    store : StoreBase\n    content : nd.array\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "bs", "=", "store", ".", "batch_size", "\n", "shape", "=", "content", ".", "shape", "[", "1", ":", "]", "\n", "batch", "=", "np", ".", "random", ".", "rand", "(", "bs", ",", "*", "shape", ")", "\n", "l", "=", "len", "(", "content", ")", "//", "bs", "\n", "\n", "assert", "len", "(", "store", ")", "==", "l", "\n", "\n", "assert", "np", ".", "array_equal", "(", "store", "[", "1", "]", ",", "content", "[", "bs", ":", "2", "*", "bs", "]", ")", "\n", "\n", "store", "[", "1", "]", "=", "batch", "\n", "\n", "assert", "len", "(", "store", ")", "==", "l", "\n", "assert", "np", ".", "array_equal", "(", "store", "[", "1", "]", ",", "batch", ")", "\n", "\n", "del", "store", "[", "l", "-", "1", "]", "\n", "\n", "assert", "len", "(", "store", ")", "==", "l", "-", "1", "\n", "\n", "store", "[", "l", "-", "1", "]", "=", "batch", "\n", "assert", "len", "(", "store", ")", "==", "l", "\n", "\n", "store", ".", "clear", "(", ")", "\n", "assert", "len", "(", "store", ")", "==", "0", "\n", "\n", "# Return the original condition", "\n", "for", "i", "in", "range", "(", "l", ")", ":", "\n", "        ", "store", "[", "i", "]", "=", "content", "[", "i", "*", "bs", ":", "(", "i", "+", "1", ")", "*", "bs", "]", "\n", "\n", "", "assert", "len", "(", "store", ")", "==", "l", "\n", "\n", "return", "store", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_store.test_array_store": [[204, 212], ["numpy.random.rand", "elfi.store.ArrayStore", "test_store.run_basic_store_tests", "pytest.raises", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_store.run_basic_store_tests"], ["", "def", "test_array_store", "(", ")", ":", "\n", "    ", "arr", "=", "np", ".", "random", ".", "rand", "(", "40", ",", "2", ")", "\n", "store", "=", "ArrayStore", "(", "arr", ",", "batch_size", "=", "10", ",", "n_batches", "=", "3", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "IndexError", ")", ":", "\n", "        ", "store", "[", "4", "]", "=", "np", ".", "zeros", "(", "(", "10", ",", "2", ")", ")", "\n", "\n", "", "run_basic_store_tests", "(", "store", ",", "arr", "[", ":", "30", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_store.test_npy_store": [[214, 232], ["numpy.random.rand", "elfi.store.NpyArray().close", "elfi.store.NpyStore", "test_store.run_basic_store_tests", "numpy.random.rand", "numpy.array_equal", "elfi.store.NpyStore.delete", "pytest.raises", "elfi.store.NpyArray"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_store.run_basic_store_tests", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.delete"], ["", "def", "test_npy_store", "(", ")", ":", "\n", "    ", "filename", "=", "'test'", "\n", "arr", "=", "np", ".", "random", ".", "rand", "(", "40", ",", "2", ")", "\n", "NpyArray", "(", "filename", ",", "arr", ")", ".", "close", "(", ")", "\n", "store", "=", "NpyStore", "(", "filename", ",", "batch_size", "=", "10", ",", "n_batches", "=", "4", ")", "\n", "\n", "run_basic_store_tests", "(", "store", ",", "arr", ")", "\n", "\n", "batch", "=", "np", ".", "random", ".", "rand", "(", "10", ",", "2", ")", "\n", "store", "[", "4", "]", "=", "batch", "\n", "store", "[", "5", "]", "=", "2", "*", "batch", "\n", "\n", "assert", "np", ".", "array_equal", "(", "store", "[", "5", "]", ",", "2", "*", "batch", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "IndexError", ")", ":", "\n", "        ", "store", "[", "7", "]", "=", "3", "*", "batch", "\n", "\n", "", "store", ".", "delete", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_bdm": [[11, 45], ["elfi.examples.bdm.get_sources_path", "os.path.isfile", "os.path.isfile", "os.system", "elfi.examples.bdm.get_model", "elfi.Rejection", "elfi.Rejection.sample", "os.system", "os.path.isfile", "os.system", "os.system", "pytest.warns", "elfi.examples.bdm.get_model", "os.system"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.get_sources_path", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model"], ["def", "test_bdm", "(", ")", ":", "\n", "    ", "\"\"\"Currently only works in unix-like systems and with a cloned repository.\"\"\"", "\n", "cpp_path", "=", "bdm", ".", "get_sources_path", "(", ")", "\n", "\n", "do_cleanup", "=", "False", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "cpp_path", "+", "'/bdm'", ")", ":", "\n", "        ", "os", ".", "system", "(", "'make -C {}'", ".", "format", "(", "cpp_path", ")", ")", "\n", "do_cleanup", "=", "True", "\n", "\n", "", "assert", "os", ".", "path", ".", "isfile", "(", "cpp_path", "+", "'/bdm'", ")", "\n", "\n", "# Remove the executable if it already exists", "\n", "if", "os", ".", "path", ".", "isfile", "(", "'bdm'", ")", ":", "\n", "        ", "os", ".", "system", "(", "'rm bdm'", ")", "\n", "\n", "", "with", "pytest", ".", "warns", "(", "RuntimeWarning", ")", ":", "\n", "        ", "m", "=", "bdm", ".", "get_model", "(", ")", "\n", "\n", "# Copy the file here to run the test", "\n", "", "os", ".", "system", "(", "'cp {}/bdm .'", ".", "format", "(", "cpp_path", ")", ")", "\n", "\n", "# Should no longer warn", "\n", "m", "=", "bdm", ".", "get_model", "(", ")", "\n", "\n", "# Test that you can run the inference", "\n", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "'d'", ",", "batch_size", "=", "100", ")", "\n", "rej", ".", "sample", "(", "20", ")", "\n", "\n", "# TODO: test the correctness of the result", "\n", "\n", "os", ".", "system", "(", "'rm ./bdm'", ")", "\n", "if", "do_cleanup", ":", "\n", "        ", "os", ".", "system", "(", "'rm {}/bdm'", ".", "format", "(", "cpp_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_gauss": [[46, 50], ["elfi.examples.gauss.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "", "def", "test_gauss", "(", ")", ":", "\n", "    ", "m", "=", "gauss", ".", "get_model", "(", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_gauss_1d_mean": [[51, 58], ["elfi.examples.gauss.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_gauss_1d_mean", "(", ")", ":", "\n", "    ", "params_true", "=", "[", "4", "]", "\n", "cov_matrix", "=", "[", "1", "]", "\n", "\n", "m", "=", "gauss", ".", "get_model", "(", "true_params", "=", "params_true", ",", "nd_mean", "=", "True", ",", "cov_matrix", "=", "cov_matrix", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_gauss_2d_mean": [[60, 67], ["elfi.examples.gauss.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_gauss_2d_mean", "(", ")", ":", "\n", "    ", "params_true", "=", "[", "4", ",", "4", "]", "\n", "cov_matrix", "=", "[", "[", "1", ",", ".5", "]", ",", "[", ".5", ",", "1", "]", "]", "\n", "\n", "m", "=", "gauss", ".", "get_model", "(", "true_params", "=", "params_true", ",", "nd_mean", "=", "True", ",", "cov_matrix", "=", "cov_matrix", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_Ricker": [[69, 73], ["elfi.examples.ricker.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_Ricker", "(", ")", ":", "\n", "    ", "m", "=", "ricker", ".", "get_model", "(", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "20", ",", "quantile", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_Lorenz": [[75, 79], ["elfi.examples.lorenz.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_Lorenz", "(", ")", ":", "\n", "    ", "m", "=", "lorenz", ".", "get_model", "(", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "20", ",", "quantile", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_gnk": [[81, 85], ["elfi.examples.gnk.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_gnk", "(", ")", ":", "\n", "    ", "m", "=", "gnk", ".", "get_model", "(", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_bignk": [[87, 91], ["elfi.examples.bignk.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_bignk", "(", "stats_summary", "=", "[", "'ss_octile'", "]", ")", ":", "\n", "    ", "m", "=", "bignk", ".", "get_model", "(", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_Lotka_Volterra": [[93, 97], ["elfi.examples.lotka_volterra.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_Lotka_Volterra", "(", ")", ":", "\n", "    ", "m", "=", "lotka_volterra", ".", "get_model", "(", "time_end", "=", "0.05", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", ",", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "10", ",", "quantile", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_examples.test_daycare": [[98, 102], ["elfi.examples.daycare.get_model", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_daycare", "(", ")", ":", "\n", "    ", "m", "=", "daycare", ".", "get_model", "(", "time_end", "=", "0.05", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ",", "batch_size", "=", "10", ")", "\n", "rej", ".", "sample", "(", "10", ",", "quantile", "=", "0.5", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.TestElfiModel.test_remove_node": [[55, 73], ["elfi.examples.ma2.remove_node", "elfi.examples.ma2.remove_node", "elfi.examples.ma2.has_node", "elfi.examples.ma2.has_node", "elfi.examples.ma2.get_parents", "elfi.examples.ma2.get_parents", "elfi.examples.ma2.remove_node", "elfi.examples.ma2.remove_node", "elfi.examples.ma2.has_node", "elfi.examples.ma2.has_node", "len", "elfi.examples.ma2.has_node", "elfi.examples.ma2.has_node", "elfi.examples.ma2.has_node", "elfi.examples.ma2.has_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_parents", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_parents", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node"], ["    ", "def", "test_remove_node", "(", "self", ",", "ma2", ")", ":", "\n", "        ", "ma2", ".", "remove_node", "(", "'MA2'", ")", "\n", "\n", "assert", "not", "ma2", ".", "has_node", "(", "'MA2'", ")", "\n", "assert", "ma2", ".", "has_node", "(", "'t2'", ")", "\n", "\n", "parents", "=", "ma2", ".", "get_parents", "(", "'t2'", ")", "\n", "# This needs to have at least 2 parents so that the test below makes sense", "\n", "assert", "len", "(", "parents", ")", ">", "1", "\n", "\n", "ma2", ".", "remove_node", "(", "'t2'", ")", "\n", "for", "p", "in", "parents", ":", "\n", "            ", "if", "p", "[", "0", "]", "==", "'_'", ":", "\n", "                ", "assert", "not", "ma2", ".", "has_node", "(", "p", ")", "\n", "", "else", ":", "\n", "                ", "assert", "ma2", ".", "has_node", "(", "p", ")", "\n", "\n", "", "", "assert", "'MA2'", "not", "in", "ma2", ".", "observed", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.TestElfiModel.test_save_load": [[74, 86], ["elfi.load_model.save", "elfi.load_model.save", "elfi.load_model", "elfi.load_model", "elfi.load_model", "elfi.load_model", "os.remove", "elfi.load_model.save", "elfi.load_model.save", "elfi.load_model", "elfi.load_model", "elfi.load_model", "elfi.load_model", "os.remove", "os.removedirs", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.save", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.save", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.save", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.save", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model"], ["", "def", "test_save_load", "(", "self", ",", "ma2", ")", ":", "\n", "        ", "name", "=", "ma2", ".", "name", "\n", "ma2", ".", "save", "(", ")", "\n", "ma2", "=", "elfi", ".", "load_model", "(", "name", ")", "\n", "os", ".", "remove", "(", "name", "+", "'.pkl'", ")", "\n", "\n", "# Same with a prefix", "\n", "prefix", "=", "'models_dir'", "\n", "ma2", ".", "save", "(", "prefix", ")", "\n", "ma2", "=", "elfi", ".", "load_model", "(", "name", ",", "prefix", ")", "\n", "os", ".", "remove", "(", "os", ".", "path", ".", "join", "(", "prefix", ",", "name", "+", "'.pkl'", ")", ")", "\n", "os", ".", "removedirs", "(", "prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.TestNodeReference.test_name_argument": [[89, 95], ["elfi.set_default_model", "elfi.set_default_model", "elfi.NodeReference", "elfi.NodeReference", "str"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.set_default_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.set_default_model"], ["    ", "def", "test_name_argument", "(", "self", ")", ":", "\n", "# This is important because it is used when passing NodeReferences as", "\n", "# InferenceMethod arguments", "\n", "        ", "em", ".", "set_default_model", "(", ")", "\n", "ref", "=", "em", ".", "NodeReference", "(", "name", "=", "'test'", ")", "\n", "assert", "str", "(", "ref", ")", "==", "'test'", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.TestNodeReference.test_name_determination": [[96, 120], ["elfi.set_default_model", "elfi.set_default_model", "elfi.NodeReference", "elfi.NodeReference", "elfi.NodeReference", "elfi.NodeReference", "elfi.NodeReference", "elfi.NodeReference", "elfi.Prior", "elfi.Prior", "range", "range", "nodes.append", "elfi.NodeReference", "elfi.NodeReference"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.set_default_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.set_default_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "test_name_determination", "(", "self", ")", ":", "\n", "        ", "em", ".", "set_default_model", "(", ")", "\n", "node", "=", "em", ".", "NodeReference", "(", ")", "\n", "assert", "node", ".", "name", "==", "'node'", "\n", "\n", "# Works without spaces", "\n", "node2", "=", "em", ".", "NodeReference", "(", ")", "\n", "assert", "node2", ".", "name", "==", "'node2'", "\n", "\n", "# Does not give the same name", "\n", "node", "=", "em", ".", "NodeReference", "(", ")", "\n", "assert", "node", ".", "name", "!=", "'node'", "\n", "\n", "# Works with sub classes", "\n", "pri", "=", "em", ".", "Prior", "(", "'uniform'", ")", "\n", "assert", "pri", ".", "name", "==", "'pri'", "\n", "\n", "# Assigns random names when the name isn't self explanatory", "\n", "nodes", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "            ", "nodes", ".", "append", "(", "em", ".", "NodeReference", "(", ")", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "1", ",", "5", ")", ":", "\n", "            ", "assert", "nodes", "[", "i", "-", "1", "]", ".", "name", "!=", "nodes", "[", "i", "]", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.TestNodeReference.test_positional_parents": [[121, 127], ["range"], "methods", ["None"], ["", "", "def", "test_positional_parents", "(", "self", ",", "ma2", ")", ":", "\n", "        ", "true_positional_parents", "=", "[", "'S1'", ",", "'S2'", "]", "\n", "# This tests that the order of the list is deterministic (no randomness resulting", "\n", "# from direct hash to list conversion)", "\n", "for", "i", "in", "range", "(", "100", ")", ":", "\n", "            ", "assert", "[", "p", ".", "name", "for", "p", "in", "ma2", "[", "'d'", "]", ".", "parents", "]", "==", "true_positional_parents", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.TestNodeReference.test_become": [[128, 143], ["numpy.random.get_state", "numpy.random.set_state", "ma2[].become", "numpy.random.set_state", "numpy.array_equal", "elfi.examples.ma2.generate", "elfi.examples.ma2.generate", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.examples.ma2.generate", "elfi.examples.ma2.generate", "set", "set"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_state", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.become", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["", "", "def", "test_become", "(", "self", ",", "ma2", ")", ":", "\n", "        ", "state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "dists", "=", "ma2", ".", "generate", "(", "100", ",", "'d'", ")", "[", "'d'", "]", "\n", "nodes", "=", "ma2", ".", "nodes", "\n", "np", ".", "random", ".", "set_state", "(", "state", ")", "\n", "\n", "ma2", "[", "'d'", "]", ".", "become", "(", "em", ".", "Discrepancy", "(", "euclidean_discrepancy", ",", "ma2", "[", "'S1'", "]", ",", "ma2", "[", "'S2'", "]", ")", ")", "\n", "dists2", "=", "ma2", ".", "generate", "(", "100", ",", "'d'", ")", "[", "'d'", "]", "\n", "nodes2", "=", "ma2", ".", "nodes", "\n", "np", ".", "random", ".", "set_state", "(", "state", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "dists", ",", "dists2", ")", "\n", "\n", "# Check that there are the same nodes in the graph", "\n", "assert", "set", "(", "nodes", ")", "==", "set", "(", "nodes2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.TestNodeReference.test_become_with_priors": [[144, 160], ["elfi.examples.ma2.parameter_names.copy", "elfi.examples.ma2.parameter_names.copy", "elfi.examples.ma2.get_parents", "elfi.examples.ma2.get_parents", "ma2[].become", "elfi.Rejection", "elfi.Rejection", "elfi.Rejection", "elfi.Rejection", "elfi.Rejection.sample", "elfi.Rejection.sample", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.examples.ma2.has_node", "elfi.examples.ma2.has_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_parents", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_parents", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.become", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node"], ["", "def", "test_become_with_priors", "(", "self", ",", "ma2", ")", ":", "\n", "        ", "parameters", "=", "ma2", ".", "parameter_names", ".", "copy", "(", ")", "\n", "parent_names", "=", "ma2", ".", "get_parents", "(", "'t1'", ")", "\n", "\n", "ma2", "[", "'t1'", "]", ".", "become", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "model", "=", "ma2", ")", ")", "\n", "\n", "# Test that parameters are preserved", "\n", "assert", "parameters", "==", "ma2", ".", "parameter_names", "\n", "\n", "# Test that hidden nodes are removed", "\n", "for", "name", "in", "parent_names", ":", "\n", "            ", "assert", "not", "ma2", ".", "has_node", "(", "name", ")", "\n", "\n", "# Test that inference still works", "\n", "", "r", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ")", "\n", "r", ".", "sample", "(", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.TestNodeReference.test_become_with_simulators": [[161, 172], ["numpy.zeros", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "ma2[].become", "numpy.array_equal", "elfi.Rejection", "elfi.Rejection", "elfi.Rejection", "elfi.Rejection", "elfi.Rejection.sample", "elfi.Rejection.sample"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.become", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "def", "test_become_with_simulators", "(", "self", ",", "ma2", ")", ":", "\n", "        ", "y_obs", "=", "np", ".", "zeros", "(", "100", ")", "\n", "new_sim", "=", "elfi", ".", "Simulator", "(", "ema2", ".", "MA2", ",", "ma2", "[", "'t1'", "]", ",", "ma2", "[", "'t2'", "]", ",", "observed", "=", "y_obs", ")", "\n", "ma2", "[", "'MA2'", "]", ".", "become", "(", "new_sim", ")", "\n", "\n", "# Test that observed data is changed", "\n", "assert", "np", ".", "array_equal", "(", "ma2", ".", "observed", "[", "'MA2'", "]", ",", "y_obs", ")", "\n", "\n", "# Test that inference still works", "\n", "r", "=", "elfi", ".", "Rejection", "(", "ma2", ",", "'d'", ")", "\n", "r", ".", "sample", "(", "10", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.test_generate": [[11, 20], ["pytest.mark.usefixtures", "elfi.examples.ma2.get_reference", "ma2.get_reference.generate"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_reference", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_generate", "(", "ma2", ")", ":", "\n", "    ", "n_gen", "=", "10", "\n", "\n", "d", "=", "ma2", ".", "get_reference", "(", "'d'", ")", "\n", "res", "=", "d", ".", "generate", "(", "n_gen", ")", "\n", "\n", "assert", "res", ".", "shape", "[", "0", "]", "==", "n_gen", "\n", "assert", "res", ".", "ndim", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.test_observed": [[22, 35], ["pytest.mark.usefixtures", "elfi.examples.ma2.get_model", "ema2.get_model.get_reference", "ema2.get_model.get_reference", "elfi.examples.ma2.autocov", "elfi.examples.ma2.autocov", "numpy.array_equal", "numpy.array_equal"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_reference", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_reference", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.autocov", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.autocov"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_observed", "(", ")", ":", "\n", "    ", "true_params", "=", "[", ".6", ",", ".2", "]", "\n", "m", "=", "ema2", ".", "get_model", "(", "100", ",", "true_params", "=", "true_params", ")", "\n", "y", "=", "m", ".", "observed", "[", "'MA2'", "]", "\n", "S1", "=", "m", ".", "get_reference", "(", "'S1'", ")", "\n", "S2", "=", "m", ".", "get_reference", "(", "'S2'", ")", "\n", "\n", "S1_observed", "=", "ema2", ".", "autocov", "(", "y", ")", "\n", "S2_observed", "=", "ema2", ".", "autocov", "(", "y", ",", "2", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "S1", ".", "observed", ",", "S1_observed", ")", "\n", "assert", "np", ".", "array_equal", "(", "S2", ".", "observed", ",", "S2_observed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_elfi_model.euclidean_discrepancy": [[37, 52], ["numpy.linalg.norm", "numpy.column_stack", "numpy.column_stack"], "function", ["None"], ["", "def", "euclidean_discrepancy", "(", "*", "simulated", ",", "observed", ")", ":", "\n", "    ", "\"\"\"Euclidean discrepancy between data.\n\n    Parameters\n    ----------\n    *simulated\n        simulated summaries\n    observed : tuple of 1d or 2d np.arrays of length n\n\n    Returns\n    -------\n    d : np.array of size (n,)\n    \"\"\"", "\n", "d", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "column_stack", "(", "simulated", ")", "-", "np", ".", "column_stack", "(", "observed", ")", ",", "ord", "=", "2", ",", "axis", "=", "1", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_results.test_sample": [[7, 44], ["dict", "elfi.methods.results.Sample", "hasattr", "numpy.allclose", "numpy.allclose", "numpy.allclose", "hasattr", "elfi.methods.results.Sample.summary", "numpy.random.random", "numpy.random.random", "numpy.random.random", "zip", "len", "pytest.raises"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.summary"], ["def", "test_sample", "(", ")", ":", "\n", "    ", "n_samples", "=", "10", "\n", "parameter_names", "=", "[", "'a'", ",", "'b'", "]", "\n", "distance_name", "=", "'dist'", "\n", "samples", "=", "[", "\n", "np", ".", "random", ".", "random", "(", "n_samples", ")", ",", "\n", "np", ".", "random", ".", "random", "(", "n_samples", ")", ",", "\n", "np", ".", "random", ".", "random", "(", "n_samples", ")", "\n", "]", "\n", "outputs", "=", "dict", "(", "zip", "(", "parameter_names", "+", "[", "distance_name", "]", ",", "samples", ")", ")", "\n", "sample", "=", "elfi", ".", "methods", ".", "results", ".", "Sample", "(", "\n", "method_name", "=", "\"TestRes\"", ",", "\n", "outputs", "=", "outputs", ",", "\n", "parameter_names", "=", "parameter_names", ",", "\n", "discrepancy_name", "=", "distance_name", ",", "\n", "something", "=", "'x'", ",", "\n", "something_else", "=", "'y'", ",", "\n", "n_sim", "=", "0", ",", ")", "\n", "\n", "assert", "sample", ".", "method_name", "==", "\"TestRes\"", "\n", "assert", "hasattr", "(", "sample", ",", "'samples'", ")", "\n", "assert", "sample", ".", "n_samples", "==", "n_samples", "\n", "assert", "sample", ".", "dim", "==", "len", "(", "parameter_names", ")", "\n", "assert", "not", "sample", ".", "is_multivariate", "\n", "\n", "assert", "np", ".", "allclose", "(", "samples", "[", "0", "]", ",", "sample", ".", "samples_array", "[", ":", ",", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "samples", "[", "1", "]", ",", "sample", ".", "samples_array", "[", ":", ",", "1", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "samples", "[", "-", "1", "]", ",", "sample", ".", "discrepancies", ")", "\n", "\n", "assert", "hasattr", "(", "sample", ",", "'something'", ")", "\n", "assert", "sample", ".", "something_else", "==", "'y'", "\n", "\n", "with", "pytest", ".", "raises", "(", "AttributeError", ")", ":", "\n", "        ", "sample", ".", "not_here", "\n", "\n", "# Test summary", "\n", "", "sample", ".", "summary", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_results.test_bolfi_sample": [[46, 78], ["numpy.random.random", "elfi.methods.results.BolfiSample", "hasattr", "hasattr", "hasattr", "numpy.concatenate", "numpy.concatenate", "numpy.allclose", "numpy.allclose", "hasattr", "len", "len", "range", "range"], "function", ["None"], ["", "def", "test_bolfi_sample", "(", ")", ":", "\n", "    ", "n_chains", "=", "3", "\n", "n_iters", "=", "10", "\n", "warmup", "=", "5", "\n", "parameter_names", "=", "[", "'a'", ",", "'b'", "]", "\n", "chains", "=", "np", ".", "random", ".", "random", "(", "(", "n_chains", ",", "n_iters", ",", "len", "(", "parameter_names", ")", ")", ")", "\n", "\n", "result", "=", "elfi", ".", "methods", ".", "results", ".", "BolfiSample", "(", "\n", "method_name", "=", "\"TestRes\"", ",", "\n", "chains", "=", "chains", ",", "\n", "parameter_names", "=", "parameter_names", ",", "\n", "warmup", "=", "warmup", ",", "\n", "something", "=", "'x'", ",", "\n", "something_else", "=", "'y'", ",", "\n", "n_sim", "=", "0", ",", ")", "\n", "\n", "assert", "result", ".", "method_name", "==", "\"TestRes\"", "\n", "assert", "hasattr", "(", "result", ",", "'samples'", ")", "\n", "assert", "hasattr", "(", "result", ",", "'chains'", ")", "\n", "assert", "hasattr", "(", "result", ",", "'outputs'", ")", "\n", "assert", "result", ".", "n_samples", "==", "n_chains", "*", "(", "n_iters", "-", "warmup", ")", "\n", "assert", "result", ".", "dim", "==", "len", "(", "parameter_names", ")", "\n", "assert", "not", "result", ".", "is_multivariate", "\n", "\n", "# verify that chains are merged correctly", "\n", "s0", "=", "np", ".", "concatenate", "(", "[", "chains", "[", "i", ",", "warmup", ":", ",", "0", "]", "for", "i", "in", "range", "(", "n_chains", ")", "]", ")", "\n", "s1", "=", "np", ".", "concatenate", "(", "[", "chains", "[", "i", ",", "warmup", ":", ",", "1", "]", "for", "i", "in", "range", "(", "n_chains", ")", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "s0", ",", "result", ".", "samples", "[", "parameter_names", "[", "0", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "s1", ",", "result", ".", "samples", "[", "parameter_names", "[", "1", "]", "]", ")", "\n", "\n", "assert", "hasattr", "(", "result", ",", "'something'", ")", "\n", "assert", "result", ".", "something_else", "==", "'y'", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_results.test_multivariate": [[80, 88], ["pytest.mark.parametrize", "elfi.Rejection", "elfi.Rejection.sample"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'multivariate_model'", ",", "[", "3", "]", ",", "indirect", "=", "True", ")", "\n", "def", "test_multivariate", "(", "multivariate_model", ")", ":", "\n", "    ", "n_samples", "=", "10", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "multivariate_model", "[", "'d'", "]", ",", "batch_size", "=", "5", ")", "\n", "sample", "=", "rej", ".", "sample", "(", "n_samples", ")", "\n", "assert", "sample", ".", "outputs", "[", "'t1'", "]", ".", "shape", "==", "(", "n_samples", ",", "3", ")", "\n", "assert", "sample", ".", "outputs", "[", "'d'", "]", ".", "shape", "==", "(", "n_samples", ",", ")", "\n", "assert", "sample", ".", "is_multivariate", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_tools.test_vectorize_decorator": [[9, 38], ["numpy.array", "numpy.array", "elfi.tools.vectorize", "numpy.array_equal", "elfi.tools.vectorize", "numpy.array_equal", "elfi.tools.vectorize", "numpy.array_equal", "elfi.tools.vectorize", "numpy.array_equal", "elfi.tools.vectorize.", "elfi.tools.vectorize.", "elfi.tools.vectorize.", "elfi.tools.vectorize.", "pytest.raises", "elfi.tools.vectorize."], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize"], ["def", "test_vectorize_decorator", "(", ")", ":", "\n", "    ", "batch_size", "=", "3", "\n", "a", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "b", "=", "np", ".", "array", "(", "[", "3", ",", "2", ",", "1", "]", ")", "\n", "\n", "def", "simulator", "(", "a", ",", "b", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "return", "a", "*", "b", "\n", "\n", "", "vsim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "simulator", ")", "\n", "assert", "np", ".", "array_equal", "(", "a", "*", "b", ",", "vsim", "(", "a", ",", "b", ",", "batch_size", "=", "batch_size", ")", ")", "\n", "\n", "def", "simulator", "(", "a", ",", "constant", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "return", "a", "*", "constant", "\n", "\n", "", "vsim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "simulator", ",", "constants", "=", "[", "1", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "a", "*", "5", ",", "vsim", "(", "a", ",", "5", ",", "batch_size", "=", "batch_size", ")", ")", "\n", "\n", "vsim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "simulator", ",", "[", "1", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "a", "*", "5", ",", "vsim", "(", "a", ",", "5", ",", "batch_size", "=", "batch_size", ")", ")", "\n", "\n", "def", "simulator", "(", "constant0", ",", "b", ",", "constant2", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "return", "constant0", "*", "b", "*", "constant2", "\n", "\n", "", "vsim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "simulator", ",", "constants", "=", "(", "0", ",", "2", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "2", "*", "b", "*", "7", ",", "vsim", "(", "2", ",", "b", ",", "7", ",", "batch_size", "=", "batch_size", ")", ")", "\n", "\n", "# Invalid batch size in b", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "vsim", "(", "2", ",", "b", ",", "7", ",", "batch_size", "=", "2", "*", "batch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_tools.simulator": [[40, 42], ["None"], "function", ["None"], ["", "", "def", "simulator", "(", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_tools.test_vectorized_pickling": [[44, 47], ["elfi.tools.vectorize", "pickle.dumps"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize"], ["", "def", "test_vectorized_pickling", "(", ")", ":", "\n", "    ", "sim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "simulator", ")", "\n", "pickle", ".", "dumps", "(", "sim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_tools.test_external_operation": [[49, 60], ["elfi.new_model", "elfi.tools.external_operation", "elfi.Constant", "elfi.Simulator", "elfi.Simulator.generate", "numpy.array_equal", "pickle.dumps"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.external_operation", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["", "def", "test_external_operation", "(", ")", ":", "\n", "# Note that the test string has intentionally not uniform formatting with spaces", "\n", "    ", "elfi", ".", "new_model", "(", ")", "\n", "op", "=", "elfi", ".", "tools", ".", "external_operation", "(", "'echo 1 {0} 4  5    6 {seed}'", ")", "\n", "constant", "=", "elfi", ".", "Constant", "(", "123", ")", "\n", "simulator", "=", "elfi", ".", "Simulator", "(", "op", ",", "constant", ")", "\n", "v", "=", "simulator", ".", "generate", "(", "1", ")", "\n", "assert", "np", ".", "array_equal", "(", "v", "[", ":", "5", "]", ",", "[", "1", ",", "123", ",", "4", ",", "5", ",", "6", "]", ")", "\n", "\n", "# Can be pickled", "\n", "pickle", ".", "dumps", "(", "op", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_tools.test_vectorized_and_external_combined": [[62, 86], ["pytest.mark.usefixtures", "elfi.Constant", "elfi.tools.external_operation", "elfi.tools.vectorize", "elfi.Simulator", "elfi.Simulator.generate", "len", "len", "numpy.array_equal", "len", "pytest.raises", "elfi.Simulator.generate", "numpy.unique", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.external_operation", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_vectorized_and_external_combined", "(", ")", ":", "\n", "    ", "constant", "=", "elfi", ".", "Constant", "(", "123", ")", "\n", "kwargs_sim", "=", "elfi", ".", "tools", ".", "external_operation", "(", "\n", "'echo {seed} {batch_index} {index_in_batch} {submission_index}'", ",", "process_result", "=", "'int32'", ")", "\n", "kwargs_sim", "=", "elfi", ".", "tools", ".", "vectorize", "(", "kwargs_sim", ")", "\n", "sim", "=", "elfi", ".", "Simulator", "(", "kwargs_sim", ",", "constant", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", ":", "\n", "        ", "sim", ".", "generate", "(", "3", ")", "\n", "\n", "", "sim", "[", "'_uses_meta'", "]", "=", "True", "\n", "g", "=", "sim", ".", "generate", "(", "3", ")", "\n", "\n", "# Test uniqueness of seeds", "\n", "assert", "len", "(", "np", ".", "unique", "(", "g", "[", ":", ",", "0", "]", ")", "==", "3", ")", "\n", "\n", "assert", "len", "(", "np", ".", "unique", "(", "g", "[", ":", ",", "1", "]", ")", "==", "1", ")", "\n", "\n", "# Test index_in_batch", "\n", "assert", "np", ".", "array_equal", "(", "g", "[", ":", ",", "2", "]", ",", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "\n", "# Test submission_index (all belong to the same submission)", "\n", "assert", "len", "(", "np", ".", "unique", "(", "g", "[", ":", ",", "3", "]", ")", "==", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.TestGMDistribution.test_pdf": [[64, 93], ["elfi.methods.utils.normalize_weights", "elfi.methods.utils.GMDistribution.pdf", "numpy.allclose", "distribution_test", "elfi.methods.utils.GMDistribution.pdf", "numpy.allclose", "distribution_test", "scipy.norm.pdf", "scipy.norm.pdf", "scipy.multivariate_normal.pdf", "scipy.multivariate_normal.pdf", "elfi.methods.utils.GMDistribution.pdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.normalize_weights", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.distribution_test", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.distribution_test", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf"], ["    ", "def", "test_pdf", "(", "self", ",", "distribution_test", ")", ":", "\n", "# 1d case", "\n", "        ", "x", "=", "[", "1", ",", "2", ",", "-", "1", "]", "\n", "means", "=", "[", "0", ",", "2", "]", "\n", "weights", "=", "normalize_weights", "(", "[", ".4", ",", ".1", "]", ")", "\n", "d", "=", "GMDistribution", ".", "pdf", "(", "x", ",", "means", ",", "weights", "=", "weights", ")", "\n", "d_true", "=", "weights", "[", "0", "]", "*", "ss", ".", "norm", ".", "pdf", "(", "x", ",", "loc", "=", "means", "[", "0", "]", ")", "+", "weights", "[", "1", "]", "*", "ss", ".", "norm", ".", "pdf", "(", "x", ",", "loc", "=", "means", "[", "1", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "d", ",", "d_true", ")", "\n", "\n", "# Test with a single observation", "\n", "# assert GMDistribution.pdf(x[0], means, weights=weights).ndim == 0", "\n", "\n", "# Distribution_test with 1d means", "\n", "distribution_test", "(", "GMDistribution", ",", "means", ",", "weights", "=", "weights", ")", "\n", "\n", "# 2d case", "\n", "x", "=", "[", "[", "1", ",", "2", ",", "-", "1", "]", ",", "[", "0", ",", "0", ",", "2", "]", "]", "\n", "means", "=", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "-", "1", ",", "-", ".2", ",", ".1", "]", "]", "\n", "d", "=", "GMDistribution", ".", "pdf", "(", "x", ",", "means", ",", "weights", "=", "weights", ")", "\n", "d_true", "=", "weights", "[", "0", "]", "*", "ss", ".", "multivariate_normal", ".", "pdf", "(", "x", ",", "mean", "=", "means", "[", "0", "]", ")", "+", "weights", "[", "1", "]", "*", "ss", ".", "multivariate_normal", ".", "pdf", "(", "x", ",", "mean", "=", "means", "[", "1", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "d", ",", "d_true", ")", "\n", "\n", "# Test with a single observation", "\n", "assert", "GMDistribution", ".", "pdf", "(", "x", "[", "0", "]", ",", "means", ",", "weights", "=", "weights", ")", ".", "ndim", "==", "0", "\n", "\n", "# Distribution_test with 3d means", "\n", "distribution_test", "(", "GMDistribution", ",", "means", ",", "weights", "=", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.TestGMDistribution.test_rvs": [[94, 107], ["numpy.random.RandomState", "elfi.methods.utils.GMDistribution.rvs", "numpy.abs", "numpy.abs", "numpy.mean", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "test_rvs", "(", "self", ")", ":", "\n", "        ", "means", "=", "[", "[", "1000", ",", "3", "]", ",", "[", "-", "1000", ",", "-", "3", "]", "]", "\n", "weights", "=", "[", ".3", ",", ".7", "]", "\n", "N", "=", "10000", "\n", "random", "=", "np", ".", "random", ".", "RandomState", "(", "12042017", ")", "\n", "rvs", "=", "GMDistribution", ".", "rvs", "(", "means", ",", "weights", "=", "weights", ",", "size", "=", "N", ",", "random_state", "=", "random", ")", "\n", "rvs", "=", "rvs", "[", "rvs", "[", ":", ",", "0", "]", "<", "0", ",", ":", "]", "\n", "\n", "# Test correct proportion of samples near the second mode", "\n", "assert", "np", ".", "abs", "(", "len", "(", "rvs", ")", "/", "N", "-", ".7", ")", "<", ".01", "\n", "\n", "# Test that the mean of the second mode is correct", "\n", "assert", "np", ".", "abs", "(", "np", ".", "mean", "(", "rvs", "[", ":", ",", "1", "]", ")", "+", "3", ")", "<", ".1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.TestGMDistribution.test_rvs_prior_ok": [[108, 117], ["elfi.methods.utils.GMDistribution.rvs", "numpy.all", "scipy.uniform", "numpy.isfinite", "prior_logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["", "def", "test_rvs_prior_ok", "(", "self", ")", ":", "\n", "        ", "means", "=", "[", "0.8", ",", "0.5", "]", "\n", "weights", "=", "[", ".3", ",", ".7", "]", "\n", "N", "=", "10000", "\n", "prior_logpdf", "=", "ss", ".", "uniform", "(", "0", ",", "1", ")", ".", "logpdf", "\n", "rvs", "=", "GMDistribution", ".", "rvs", "(", "means", ",", "weights", "=", "weights", ",", "size", "=", "N", ",", "prior_logpdf", "=", "prior_logpdf", ")", "\n", "\n", "# Ensure prior pdf > 0 for all samples", "\n", "assert", "np", ".", "all", "(", "np", ".", "isfinite", "(", "prior_logpdf", "(", "rvs", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.TestModelPrior.test_basics": [[126, 135], ["elfi.Prior", "elfi.methods.utils.ModelPrior", "distribution_test", "elfi.methods.utils.ModelPrior", "distribution_test", "elfi.ElfiModel"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.distribution_test", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.distribution_test"], ["    ", "def", "test_basics", "(", "self", ",", "ma2", ",", "distribution_test", ")", ":", "\n", "# A 1D case", "\n", "        ", "normal", "=", "elfi", ".", "Prior", "(", "'normal'", ",", "5", ",", "model", "=", "elfi", ".", "ElfiModel", "(", ")", ")", "\n", "normal_prior", "=", "ModelPrior", "(", "normal", ".", "model", ")", "\n", "distribution_test", "(", "normal_prior", ")", "\n", "\n", "# A 2D case", "\n", "prior", "=", "ModelPrior", "(", "ma2", ")", "\n", "distribution_test", "(", "prior", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.TestModelPrior.test_pdf": [[136, 140], ["elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior.rvs", "numpy.allclose", "elfi.methods.utils.ModelPrior.pdf", "numpy.exp", "elfi.methods.utils.ModelPrior.logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf"], ["", "def", "test_pdf", "(", "self", ",", "ma2", ")", ":", "\n", "        ", "prior", "=", "ModelPrior", "(", "ma2", ")", "\n", "rv", "=", "prior", ".", "rvs", "(", "size", "=", "10", ")", "\n", "assert", "np", ".", "allclose", "(", "prior", ".", "pdf", "(", "rv", ")", ",", "np", ".", "exp", "(", "prior", ".", "logpdf", "(", "rv", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.TestModelPrior.test_gradient_logpdf": [[141, 147], ["elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior.rvs", "elfi.methods.utils.ModelPrior.gradient_logpdf", "numpy.allclose"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.gradient_logpdf"], ["", "def", "test_gradient_logpdf", "(", "self", ",", "ma2", ")", ":", "\n", "        ", "prior", "=", "ModelPrior", "(", "ma2", ")", "\n", "rv", "=", "prior", ".", "rvs", "(", "size", "=", "10", ")", "\n", "grads", "=", "prior", ".", "gradient_logpdf", "(", "rv", ")", "\n", "assert", "grads", ".", "shape", "==", "rv", ".", "shape", "\n", "assert", "np", ".", "allclose", "(", "grads", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.TestModelPrior.test_numerical_grad_logpdf": [[148, 157], ["numpy.random.rand", "elfi.Prior", "elfi.methods.utils.ModelPrior().gradient_logpdf", "numpy.isclose", "elfi.ElfiModel", "elfi.methods.utils.ModelPrior"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.gradient_logpdf"], ["", "def", "test_numerical_grad_logpdf", "(", "self", ")", ":", "\n", "# Test gradient with a normal distribution", "\n", "        ", "loc", "=", "2.2", "\n", "scale", "=", "1.1", "\n", "x", "=", "np", ".", "random", ".", "rand", "(", ")", "\n", "analytical_grad_logpdf", "=", "-", "(", "x", "-", "loc", ")", "/", "scale", "**", "2", "\n", "prior_node", "=", "elfi", ".", "Prior", "(", "'normal'", ",", "loc", ",", "scale", ",", "model", "=", "elfi", ".", "ElfiModel", "(", ")", ")", "\n", "num_grad", "=", "ModelPrior", "(", "prior_node", ".", "model", ")", ".", "gradient_logpdf", "(", "x", ")", "\n", "assert", "np", ".", "isclose", "(", "num_grad", ",", "analytical_grad_logpdf", ",", "atol", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.test_stochastic_optimization": [[14, 24], ["int", "elfi.methods.bo.utils.stochastic_optimization", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.stochastic_optimization"], ["def", "test_stochastic_optimization", "(", ")", ":", "\n", "    ", "def", "fun", "(", "x", ")", ":", "\n", "        ", "return", "x", "**", "2", "\n", "\n", "", "bounds", "=", "(", "(", "-", "1", ",", "1", ")", ",", ")", "\n", "its", "=", "int", "(", "1e3", ")", "\n", "polish", "=", "True", "\n", "loc", ",", "val", "=", "stochastic_optimization", "(", "fun", ",", "bounds", ",", "its", ",", "polish", ")", "\n", "assert", "abs", "(", "loc", "-", "0.0", ")", "<", "1e-5", "\n", "assert", "abs", "(", "val", "-", "0.0", ")", "<", "1e-5", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.test_minimize_with_known_gradient": [[26, 37], ["elfi.methods.bo.utils.minimize", "numpy.isclose", "numpy.allclose", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize"], ["", "def", "test_minimize_with_known_gradient", "(", ")", ":", "\n", "    ", "def", "fun", "(", "x", ")", ":", "\n", "        ", "return", "x", "[", "0", "]", "**", "2", "+", "(", "x", "[", "1", "]", "-", "1", ")", "**", "4", "\n", "\n", "", "def", "grad", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "2", "*", "x", "[", "0", "]", ",", "4", "*", "(", "x", "[", "1", "]", "-", "1", ")", "**", "3", "]", ")", "\n", "\n", "", "bounds", "=", "(", "(", "-", "2", ",", "2", ")", ",", "(", "-", "2", ",", "3", ")", ")", "\n", "loc", ",", "val", "=", "minimize", "(", "fun", ",", "bounds", ",", "grad", ")", "\n", "assert", "np", ".", "isclose", "(", "val", ",", "0", ",", "atol", "=", "0.01", ")", "\n", "assert", "np", ".", "allclose", "(", "loc", ",", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", ",", "atol", "=", "0.02", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.test_minimize_with_approx_gradient": [[39, 47], ["elfi.methods.bo.utils.minimize", "numpy.isclose", "numpy.allclose", "numpy.array"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize"], ["", "def", "test_minimize_with_approx_gradient", "(", ")", ":", "\n", "    ", "def", "fun", "(", "x", ")", ":", "\n", "        ", "return", "x", "[", "0", "]", "**", "2", "+", "(", "x", "[", "1", "]", "-", "1", ")", "**", "4", "\n", "\n", "", "bounds", "=", "(", "(", "-", "2", ",", "2", ")", ",", "(", "-", "2", ",", "3", ")", ")", "\n", "loc", ",", "val", "=", "minimize", "(", "fun", ",", "bounds", ")", "\n", "assert", "np", ".", "isclose", "(", "val", ",", "0", ",", "atol", "=", "0.01", ")", "\n", "assert", "np", ".", "allclose", "(", "loc", ",", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", ",", "atol", "=", "0.02", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.test_weighted_var": [[49, 61], ["numpy.random.RandomState().normal", "numpy.array", "numpy.random.RandomState().multivariate_normal", "numpy.array", "numpy.linalg.norm", "numpy.random.RandomState", "len", "elfi.methods.utils.weighted_var", "numpy.random.RandomState", "len", "elfi.methods.utils.weighted_var", "numpy.diag"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.weighted_var", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.weighted_var"], ["", "def", "test_weighted_var", "(", ")", ":", "\n", "# 1d case", "\n", "    ", "std", "=", ".3", "\n", "x", "=", "np", ".", "random", ".", "RandomState", "(", "12345", ")", ".", "normal", "(", "-", "2", ",", "std", ",", "size", "=", "1000", ")", "\n", "w", "=", "np", ".", "array", "(", "[", "1", "]", "*", "len", "(", "x", ")", ")", "\n", "assert", "(", "weighted_var", "(", "x", ",", "w", ")", "-", "std", ")", "<", ".1", "\n", "\n", "# 2d case", "\n", "cov", "=", "[", "[", ".5", ",", "0", "]", ",", "[", "0", ",", "3.2", "]", "]", "\n", "x", "=", "np", ".", "random", ".", "RandomState", "(", "12345", ")", ".", "multivariate_normal", "(", "[", "1", ",", "2", "]", ",", "cov", ",", "size", "=", "1000", ")", "\n", "w", "=", "np", ".", "array", "(", "[", "1", "]", "*", "len", "(", "x", ")", ")", "\n", "assert", "np", ".", "linalg", ".", "norm", "(", "weighted_var", "(", "x", ",", "w", ")", "-", "np", ".", "diag", "(", "cov", ")", ")", "<", ".1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.test_numgrad": [[119, 123], ["numpy.allclose", "numpy.allclose", "numpy.allclose", "elfi.methods.utils.numgrad", "elfi.methods.utils.numgrad", "elfi.methods.utils.numgrad", "numpy.log", "numpy.prod", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numgrad", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numgrad", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numgrad"], ["", "", "def", "test_numgrad", "(", ")", ":", "\n", "    ", "assert", "np", ".", "allclose", "(", "numgrad", "(", "lambda", "x", ":", "np", ".", "log", "(", "x", ")", ",", "3", ")", ",", "[", "1", "/", "3", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "numgrad", "(", "lambda", "x", ":", "np", ".", "prod", "(", "x", ",", "axis", "=", "1", ")", ",", "[", "1", ",", "3", ",", "5", "]", ")", ",", "[", "15", ",", "5", ",", "3", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "numgrad", "(", "lambda", "x", ":", "np", ".", "sum", "(", "x", ",", "axis", "=", "1", ")", ",", "[", "1", ",", "3", ",", "5", "]", ")", ",", "[", "1", ",", "1", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.test_sample_object_to_dict": [[159, 173], ["collections.OrderedDict", "collections.OrderedDict", "elfi.examples.ma2.get_model", "elfi.Rejection", "elfi.Rejection.sample", "elfi.SMC", "elfi.SMC.sample", "elfi.methods.utils.sample_object_to_dict", "elfi.methods.utils.sample_object_to_dict", "any", "any"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.sample_object_to_dict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.sample_object_to_dict"], ["", "", "def", "test_sample_object_to_dict", "(", ")", ":", "\n", "    ", "data_rej", "=", "OrderedDict", "(", ")", "\n", "data_smc", "=", "OrderedDict", "(", ")", "\n", "m", "=", "get_model", "(", "n_obs", "=", "100", ",", "true_params", "=", "[", ".6", ",", ".2", "]", ")", "\n", "batch_size", ",", "n", "=", "1", ",", "2", "\n", "schedule", "=", "[", "0.7", ",", "0.2", ",", "0.05", "]", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ",", "batch_size", "=", "batch_size", ")", "\n", "res_rej", "=", "rej", ".", "sample", "(", "n", ",", "threshold", "=", "0.1", ")", "\n", "smc", "=", "elfi", ".", "SMC", "(", "m", "[", "'d'", "]", ",", "batch_size", "=", "batch_size", ")", "\n", "res_smc", "=", "smc", ".", "sample", "(", "n", ",", "schedule", ")", "\n", "sample_object_to_dict", "(", "data_rej", ",", "res_rej", ")", "\n", "sample_object_to_dict", "(", "data_smc", ",", "res_smc", ",", "skip", "=", "'populations'", ")", "\n", "assert", "any", "(", "x", "not", "in", "data_rej", "for", "x", "in", "[", "'meta'", ",", "'output'", "]", ")", "is", "True", "\n", "assert", "any", "(", "x", "not", "in", "data_smc", "for", "x", "in", "[", "'meta'", ",", "'output'", ",", "'populations'", "]", ")", "is", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_utils.test_numpy_to_python_type": [[175, 190], ["dict", "elfi.methods.utils.numpy_to_python_type", "test_utils.test_numpy_to_python_type.is_jsonable"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numpy_to_python_type"], ["", "def", "test_numpy_to_python_type", "(", ")", ":", "\n", "    ", "data", "=", "dict", "(", "a", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", ",", "b", "=", "np", ".", "uint", "(", "5", ")", ",", "c", "=", "np", ".", "float", "(", "10", ")", ",", "\n", "d", "=", "dict", "(", "a", "=", "np", ".", "array", "(", "[", "0", ",", "9", ",", "8", ",", "7", "]", ")", ",", "b", "=", "np", ".", "uint", "(", "15", ")", ",", "c", "=", "np", ".", "float", "(", "12", ")", ")", ")", "\n", "numpy_to_python_type", "(", "data", ")", "\n", "\n", "# checking that our objects are jsonable is enough to be sure that numpy_to_python_type", "\n", "# function works fine", "\n", "def", "is_jsonable", "(", "x", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "json", ".", "dumps", "(", "x", ")", "\n", "return", "True", "\n", "", "except", ":", "\n", "            ", "return", "False", "\n", "\n", "", "", "assert", "is_jsonable", "(", "data", ")", "is", "True", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_model_selection.test_compare_models": [[7, 23], ["elfi.examples.gauss.get_model", "elfi.Rejection().sample", "m[].become", "elfi.Rejection().sample", "m[].become", "elfi.Rejection().sample", "elfi.compare_models", "elfi.Prior", "elfi.Simulator", "elfi.Rejection", "elfi.Rejection", "elfi.Rejection"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.become", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.become", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.model_selection.compare_models"], ["@", "pytest", ".", "mark", ".", "slowtest", "\n", "def", "test_compare_models", "(", ")", ":", "\n", "    ", "m", "=", "gauss", ".", "get_model", "(", ")", "\n", "res1", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ")", ".", "sample", "(", "100", ")", "\n", "\n", "# use less informative prior", "\n", "m", "[", "'mu'", "]", ".", "become", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "10", ",", "50", ")", ")", "\n", "res2", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ")", ".", "sample", "(", "100", ")", "\n", "\n", "# use different simulator", "\n", "m", "[", "'gauss'", "]", ".", "become", "(", "elfi", ".", "Simulator", "(", "ma2", ".", "MA2", ",", "m", "[", "'mu'", "]", ",", "m", "[", "'sigma'", "]", ",", "observed", "=", "m", ".", "observed", "[", "'gauss'", "]", ")", ")", "\n", "res3", "=", "elfi", ".", "Rejection", "(", "m", "[", "'d'", "]", ")", ".", "sample", "(", "100", ")", "\n", "\n", "p", "=", "elfi", ".", "compare_models", "(", "[", "res1", ",", "res2", ",", "res3", "]", ")", "\n", "assert", "p", "[", "0", "]", ">", "p", "[", "1", "]", "\n", "assert", "p", "[", "1", "]", ">", "p", "[", "2", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_diagnostics.TestTwoStageProcedure.setup_class": [[15, 19], ["elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model"], ["@", "classmethod", "\n", "def", "setup_class", "(", "cls", ")", ":", "\n", "        ", "\"\"\"Refresh ELFI upon initialising the test class.\"\"\"", "\n", "elfi", ".", "new_model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_diagnostics.TestTwoStageProcedure.teardown_method": [[20, 23], ["elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model"], ["", "def", "teardown_method", "(", "self", ",", "method", ")", ":", "\n", "        ", "\"\"\"Refresh ELFI after the execution of the test class's each method.\"\"\"", "\n", "elfi", ".", "new_model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_diagnostics.TestTwoStageProcedure.test_ma2": [[24, 58], ["functools.partial", "functools.partial", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "fn_simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.methods.diagnostics.TwoStageSelection", "elfi.methods.diagnostics.TwoStageSelection", "elfi.methods.diagnostics.TwoStageSelection", "elfi.methods.diagnostics.TwoStageSelection.run", "elfi.methods.diagnostics.TwoStageSelection.run", "elfi.methods.diagnostics.TwoStageSelection.run", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "test_ma2", "(", "self", ",", "seed", "=", "0", ")", ":", "\n", "        ", "\"\"\"Identifying the optimal summary statistics combination following the MA2 model.\n\n        Parameters\n        ----------\n        seed : int, optional\n\n        \"\"\"", "\n", "# Defining summary statistics.", "\n", "ss_mean", "=", "Gauss", ".", "ss_mean", "\n", "ss_ac_lag1", "=", "partial", "(", "MA2", ".", "autocov", ",", "lag", "=", "1", ")", "\n", "ss_ac_lag1", ".", "__name__", "=", "'ac_lag1'", "\n", "ss_ac_lag2", "=", "partial", "(", "MA2", ".", "autocov", ",", "lag", "=", "2", ")", "\n", "ss_ac_lag2", ".", "__name__", "=", "'ac_lag2'", "\n", "\n", "list_ss", "=", "[", "ss_ac_lag1", ",", "ss_ac_lag2", ",", "ss_mean", "]", "\n", "\n", "# Initialising the simulator.", "\n", "prior_t1", "=", "elfi", ".", "Prior", "(", "MA2", ".", "CustomPrior1", ",", "2", ",", "name", "=", "'prior_t1'", ")", "\n", "prior_t2", "=", "elfi", ".", "Prior", "(", "MA2", ".", "CustomPrior2", ",", "prior_t1", ",", "1", ",", "name", "=", "'prior_t2'", ")", "\n", "\n", "t1_true", "=", ".6", "\n", "t2_true", "=", ".2", "\n", "fn_simulator", "=", "MA2", ".", "MA2", "\n", "y_obs", "=", "fn_simulator", "(", "t1_true", ",", "t2_true", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", ")", "\n", "simulator", "=", "elfi", ".", "Simulator", "(", "fn_simulator", ",", "prior_t1", ",", "prior_t2", ",", "observed", "=", "y_obs", ")", "\n", "\n", "# Identifying the optimal summary statistics based on the Two-Stage procedure.", "\n", "diagnostics", "=", "TwoStageSelection", "(", "simulator", ",", "'euclidean'", ",", "list_ss", "=", "list_ss", ",", "seed", "=", "seed", ")", "\n", "set_ss_2stage", "=", "diagnostics", ".", "run", "(", "n_sim", "=", "100000", ",", "batch_size", "=", "10000", ")", "\n", "\n", "assert", "ss_ac_lag1", "in", "set_ss_2stage", "\n", "assert", "ss_ac_lag2", "in", "set_ss_2stage", "\n", "assert", "ss_mean", "not", "in", "set_ss_2stage", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_document_examples.test_implementing_new_algorithm": [[11, 78], ["ma2.get_model", "CustomMethod", "CustomMethod.infer", "CustomMethod.set_objective", "CustomMethod.iterate", "CustomMethod.extract_result", "CustomMethod.iterate", "CustomMethod.extract_result", "super().__init__", "super().update", "Sample", "[].append", "np.concatenate"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.set_objective", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.iterate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.extract_result", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.iterate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.extract_result", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["def", "test_implementing_new_algorithm", "(", ")", ":", "\n", "    ", "import", "numpy", "as", "np", "\n", "\n", "from", "elfi", ".", "methods", ".", "parameter_inference", "import", "ParameterInference", "\n", "from", "elfi", ".", "methods", ".", "results", "import", "Sample", "\n", "\n", "import", "elfi", ".", "examples", ".", "ma2", "as", "ma2", "\n", "\n", "class", "CustomMethod", "(", "ParameterInference", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "model", ",", "discrepancy_name", ",", "threshold", ",", "**", "kwargs", ")", ":", "\n", "# Create a name list of nodes whose outputs we wish to receive", "\n", "            ", "output_names", "=", "[", "discrepancy_name", "]", "+", "model", ".", "parameter_names", "\n", "super", "(", "CustomMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "output_names", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "discrepancy_name", "=", "discrepancy_name", "\n", "\n", "# Prepare lists to push the filtered outputs into", "\n", "self", ".", "state", "[", "'filtered_outputs'", "]", "=", "{", "name", ":", "[", "]", "for", "name", "in", "output_names", "}", "\n", "\n", "", "def", "set_objective", "(", "self", ",", "n_sim", ")", ":", "\n", "            ", "self", ".", "objective", "[", "'n_sim'", "]", "=", "n_sim", "\n", "\n", "", "def", "update", "(", "self", ",", "batch", ",", "batch_index", ")", ":", "\n", "            ", "super", "(", "CustomMethod", ",", "self", ")", ".", "update", "(", "batch", ",", "batch_index", ")", "\n", "\n", "# Make a filter mask (logical numpy array) from the distance array", "\n", "filter_mask", "=", "batch", "[", "self", ".", "discrepancy_name", "]", "<=", "self", ".", "threshold", "\n", "\n", "# Append the filtered parameters to their lists", "\n", "for", "name", "in", "self", ".", "output_names", ":", "\n", "                ", "values", "=", "batch", "[", "name", "]", "\n", "self", ".", "state", "[", "'filtered_outputs'", "]", "[", "name", "]", ".", "append", "(", "values", "[", "filter_mask", "]", ")", "\n", "\n", "", "", "def", "extract_result", "(", "self", ")", ":", "\n", "            ", "filtered_outputs", "=", "self", ".", "state", "[", "'filtered_outputs'", "]", "\n", "outputs", "=", "{", "name", ":", "np", ".", "concatenate", "(", "filtered_outputs", "[", "name", "]", ")", "for", "name", "in", "self", ".", "output_names", "}", "\n", "\n", "return", "Sample", "(", "\n", "method_name", "=", "'CustomMethod'", ",", "\n", "outputs", "=", "outputs", ",", "\n", "parameter_names", "=", "self", ".", "parameter_names", ",", "\n", "discrepancy_name", "=", "self", ".", "discrepancy_name", ",", "\n", "n_sim", "=", "self", ".", "state", "[", "'n_sim'", "]", ",", "\n", "threshold", "=", "self", ".", "threshold", ")", "\n", "\n", "# Below is from the part where we demonstrate iterative advancing", "\n", "\n", "# Run it", "\n", "", "", "m", "=", "ma2", ".", "get_model", "(", ")", "\n", "custom_method", "=", "CustomMethod", "(", "m", ",", "'d'", ",", "threshold", "=", ".1", ",", "batch_size", "=", "1000", ")", "\n", "\n", "# Continue inference from the previous state (with n_sim=2000)", "\n", "custom_method", ".", "infer", "(", "n_sim", "=", "4000", ")", "\n", "\n", "# Or use it iteratively", "\n", "custom_method", ".", "set_objective", "(", "n_sim", "=", "6000", ")", "\n", "\n", "custom_method", ".", "iterate", "(", ")", "\n", "assert", "custom_method", ".", "finished", "==", "False", "\n", "\n", "# Investigate the current state", "\n", "custom_method", ".", "extract_result", "(", ")", "\n", "\n", "custom_method", ".", "iterate", "(", ")", "\n", "assert", "custom_method", ".", "finished", "\n", "custom_method", ".", "extract_result", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_mcmc.TestMetropolis.test_metropolis": [[25, 33], ["numpy.random.rand", "numpy.ones", "elfi.methods.mcmc.metropolis", "numpy.cov", "numpy.allclose"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.metropolis", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.cov"], ["    ", "def", "test_metropolis", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "200000", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "n", ")", "\n", "sigma", "=", "np", ".", "ones", "(", "n", ")", "\n", "samples", "=", "mcmc", ".", "metropolis", "(", "n_samples", ",", "x_init", ",", "log_pdf", ",", "sigma", ")", "\n", "assert", "samples", ".", "shape", "==", "(", "n_samples", ",", "n", ")", "\n", "cov", "=", "np", ".", "cov", "(", "samples", "[", "100000", ":", ",", ":", "]", ".", "T", ")", "\n", "assert", "np", ".", "allclose", "(", "cov", ",", "true_cov", ",", "atol", "=", "0.3", ",", "rtol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_mcmc.TestNUTS.test_nuts": [[37, 45], ["numpy.random.rand", "elfi.methods.mcmc.nuts", "numpy.cov", "numpy.allclose"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.nuts", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.cov"], ["    ", "def", "test_nuts", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "100000", "\n", "n_adapt", "=", "10000", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "n", ")", "\n", "samples", "=", "mcmc", ".", "nuts", "(", "n_samples", ",", "x_init", ",", "log_pdf", ",", "grad_log_pdf", ",", "n_adapt", "=", "n_adapt", ")", "\n", "assert", "samples", ".", "shape", "==", "(", "n_samples", ",", "n", ")", "\n", "cov", "=", "np", ".", "cov", "(", "samples", "[", "n_adapt", ":", ",", ":", "]", ".", "T", ")", "\n", "assert", "np", ".", "allclose", "(", "cov", ",", "true_cov", ",", "atol", "=", "0.1", ",", "rtol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_mcmc.log_pdf": [[15, 17], ["x.dot().dot", "x.dot"], "function", ["None"], ["def", "log_pdf", "(", "x", ")", ":", "\n", "    ", "return", "-", "0.5", "*", "x", ".", "dot", "(", "prec", ")", ".", "dot", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_mcmc.grad_log_pdf": [[20, 22], ["x.dot"], "function", ["None"], ["", "def", "grad_log_pdf", "(", "x", ")", ":", "\n", "    ", "return", "-", "x", ".", "dot", "(", "prec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_mcmc.test_ESS": [[63, 65], ["numpy.isclose", "elfi.methods.mcmc.eff_sample_size"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.eff_sample_size"], ["def", "test_ESS", "(", ")", ":", "\n", "    ", "assert", "np", ".", "isclose", "(", "mcmc", ".", "eff_sample_size", "(", "chains_Stan", ")", ",", "ess_Stan", ",", "atol", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_mcmc.test_Rhat": [[67, 69], ["numpy.isclose", "elfi.methods.mcmc.gelman_rubin"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.gelman_rubin"], ["", "def", "test_Rhat", "(", ")", ":", "\n", "    ", "assert", "np", ".", "isclose", "(", "mcmc", ".", "gelman_rubin", "(", "chains_Stan", ")", ",", "Rhat_Stan", ",", "atol", "=", "0.01", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_methods.test_no_model_parameters": [[9, 14], ["pytest.raises", "elfi.methods.parameter_inference.ParameterInference"], "function", ["None"], ["def", "test_no_model_parameters", "(", "simple_model", ")", ":", "\n", "    ", "simple_model", ".", "parameter_names", "=", "[", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", ":", "\n", "        ", "ParameterInference", "(", "simple_model", ",", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_methods.test_smc": [[16, 45], ["pytest.mark.usefixtures", "elfi.SMC", "elfi.SMC", "elfi.SMC.sample", "elfi.SMC._prior.logpdf", "numpy.allclose", "numpy.allclose", "smc.sample.summary", "smc.sample.summary", "smc.sample.sample_means_summary", "smc.sample.sample_means_summary", "numpy.all", "numpy.all", "numpy.average", "numpy.allclose", "numpy.mean", "elfi.CustomPrior1.pdf", "elfi.CustomPrior2.pdf"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.summary", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.summary", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.sample_means_summary", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.sample_means_summary", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf"], ["", "", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_smc", "(", "ma2", ")", ":", "\n", "    ", "thresholds", "=", "[", ".5", ",", ".2", "]", "\n", "N", "=", "1000", "\n", "smc", "=", "elfi", ".", "SMC", "(", "ma2", "[", "'d'", "]", ",", "batch_size", "=", "20000", ")", "\n", "res", "=", "smc", ".", "sample", "(", "N", ",", "thresholds", "=", "thresholds", ")", "\n", "dens", "=", "smc", ".", "_prior", ".", "logpdf", "(", "res", ".", "samples_array", ")", "\n", "# Test that the density is uniform", "\n", "assert", "np", ".", "allclose", "(", "dens", ",", "dens", "[", "0", "]", ")", "\n", "\n", "# Test that weighted mean is computed", "\n", "w", "=", "res", ".", "weights", "\n", "assert", "w", "is", "not", "None", "\n", "\n", "samples", "=", "res", ".", "samples_array", "\n", "means", "=", "res", ".", "sample_means_array", "\n", "assert", "np", ".", "allclose", "(", "means", ",", "np", ".", "average", "(", "samples", ",", "0", ",", "w", ")", ")", "\n", "assert", "not", "np", ".", "allclose", "(", "means", ",", "np", ".", "mean", "(", "samples", ",", "0", ")", ")", "\n", "\n", "# Test result summaries", "\n", "res", ".", "summary", "(", ")", "\n", "res", ".", "summary", "(", "all", "=", "True", ")", "\n", "\n", "res", ".", "sample_means_summary", "(", ")", "\n", "res", ".", "sample_means_summary", "(", "all", "=", "True", ")", "\n", "\n", "# Ensure prior pdf > 0 for samples", "\n", "assert", "np", ".", "all", "(", "exma2", ".", "CustomPrior1", ".", "pdf", "(", "samples", "[", ":", ",", "0", "]", ",", "2", ")", ">", "0", ")", "\n", "assert", "np", ".", "all", "(", "exma2", ".", "CustomPrior2", ".", "pdf", "(", "samples", "[", ":", ",", "1", "]", ",", "samples", "[", ":", ",", "0", "]", ",", "1", ")", ">", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_methods.test_BOLFI_short": [[48, 98], ["pytest.mark.usefixtures", "elfi.Operation", "elfi.Operation", "elfi.BOLFI", "elfi.BOLFI", "elfi.BOLFI.infer", "elfi.BOLFI.infer", "numpy.array_equal", "elfi.BOLFI.extract_posterior", "distribution_test", "elfi.BOLFI.sample", "elfi.BOLFI.sample", "numpy.random.random", "elfi.BOLFI.target_model._gp.predict", "elfi.BOLFI.target_model.predict", "numpy.allclose", "numpy.allclose", "elfi.BOLFI.target_model._gp.predictive_gradients", "elfi.BOLFI.target_model.predictive_gradients", "numpy.allclose", "numpy.allclose", "len", "len", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.extract_posterior", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.tests.conftest.distribution_test", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients"], ["", "@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_BOLFI_short", "(", "ma2", ",", "distribution_test", ")", ":", "\n", "# Log discrepancy tends to work better", "\n", "    ", "log_d", "=", "elfi", ".", "Operation", "(", "np", ".", "log", ",", "ma2", "[", "'d'", "]", ")", "\n", "\n", "bolfi", "=", "elfi", ".", "BOLFI", "(", "\n", "log_d", ",", "\n", "initial_evidence", "=", "10", ",", "\n", "update_interval", "=", "10", ",", "\n", "batch_size", "=", "5", ",", "\n", "bounds", "=", "{", "'t1'", ":", "(", "-", "2", ",", "2", ")", ",", "\n", "'t2'", ":", "(", "-", "1", ",", "1", ")", "}", ")", "\n", "n", "=", "20", "\n", "res", "=", "bolfi", ".", "infer", "(", "n", ")", "\n", "assert", "bolfi", ".", "target_model", ".", "n_evidence", "==", "n", "\n", "acq_x", "=", "bolfi", ".", "target_model", ".", "_gp", ".", "X", "\n", "\n", "# Test that you can continue the inference where we left off", "\n", "res", "=", "bolfi", ".", "infer", "(", "n", "+", "5", ")", "\n", "assert", "bolfi", ".", "target_model", ".", "n_evidence", "==", "n", "+", "5", "\n", "assert", "np", ".", "array_equal", "(", "bolfi", ".", "target_model", ".", "_gp", ".", "X", "[", ":", "n", ",", ":", "]", ",", "acq_x", ")", "\n", "\n", "post", "=", "bolfi", ".", "extract_posterior", "(", ")", "\n", "\n", "distribution_test", "(", "post", ",", "rvs", "=", "(", "acq_x", "[", "0", ",", ":", "]", ",", "acq_x", "[", "1", ":", "2", ",", ":", "]", ",", "acq_x", "[", "2", ":", "4", ",", ":", "]", ")", ")", "\n", "\n", "n_samples", "=", "10", "\n", "n_chains", "=", "2", "\n", "\n", "res_sampling_nuts", "=", "bolfi", ".", "sample", "(", "n_samples", ",", "n_chains", "=", "n_chains", ")", "\n", "assert", "res_sampling_nuts", ".", "samples_array", ".", "shape", "[", "1", "]", "==", "2", "\n", "assert", "len", "(", "res_sampling_nuts", ".", "samples_array", ")", "==", "n_samples", "//", "2", "*", "n_chains", "\n", "\n", "res_sampling_metropolis", "=", "bolfi", ".", "sample", "(", "n_samples", ",", "n_chains", "=", "n_chains", ",", "algorithm", "=", "'metropolis'", ",", "sigma_proposals", "=", "np", ".", "ones", "(", "2", ")", ")", "\n", "assert", "res_sampling_metropolis", ".", "samples_array", ".", "shape", "[", "1", "]", "==", "2", "\n", "assert", "len", "(", "res_sampling_metropolis", ".", "samples_array", ")", "==", "n_samples", "//", "2", "*", "n_chains", "\n", "\n", "# check the cached predictions for RBF", "\n", "x", "=", "np", ".", "random", ".", "random", "(", "(", "1", ",", "2", ")", ")", "\n", "bolfi", ".", "target_model", ".", "is_sampling", "=", "True", "\n", "\n", "pred_mu", ",", "pred_var", "=", "bolfi", ".", "target_model", ".", "_gp", ".", "predict", "(", "x", ")", "\n", "pred_cached_mu", ",", "pred_cached_var", "=", "bolfi", ".", "target_model", ".", "predict", "(", "x", ")", "\n", "assert", "(", "np", ".", "allclose", "(", "pred_mu", ",", "pred_cached_mu", ")", ")", "\n", "assert", "(", "np", ".", "allclose", "(", "pred_var", ",", "pred_cached_var", ")", ")", "\n", "\n", "grad_mu", ",", "grad_var", "=", "bolfi", ".", "target_model", ".", "_gp", ".", "predictive_gradients", "(", "x", ")", "\n", "grad_cached_mu", ",", "grad_cached_var", "=", "bolfi", ".", "target_model", ".", "predictive_gradients", "(", "x", ")", "\n", "assert", "(", "np", ".", "allclose", "(", "grad_mu", "[", ":", ",", ":", ",", "0", "]", ",", "grad_cached_mu", ")", ")", "\n", "assert", "(", "np", ".", "allclose", "(", "grad_var", ",", "grad_cached_var", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_client.test_batch_handler": [[9, 30], ["pytest.mark.usefixtures", "elfi.ComputationContext", "elfi.ComputationContext", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler.submit", "elfi.client.BatchHandler.wait_next", "elfi.client.BatchHandler.submit", "elfi.client.BatchHandler.wait_next", "elfi.client.BatchHandler.reset", "elfi.client.BatchHandler.submit", "elfi.client.BatchHandler.wait_next", "numpy.array_equal", "numpy.array_equal"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.submit", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.wait_next", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.submit", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.wait_next", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.reset", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.submit", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.wait_next"], ["@", "pytest", ".", "mark", ".", "usefixtures", "(", "'with_all_clients'", ")", "\n", "def", "test_batch_handler", "(", "simple_model", ")", ":", "\n", "    ", "m", "=", "simple_model", "\n", "computation_context", "=", "elfi", ".", "ComputationContext", "(", "seed", "=", "123", ",", "batch_size", "=", "10", ")", "\n", "batches", "=", "elfi", ".", "client", ".", "BatchHandler", "(", "m", ",", "computation_context", ",", "'k2'", ")", "\n", "\n", "batches", ".", "submit", "(", ")", "\n", "out0", ",", "i0", "=", "batches", ".", "wait_next", "(", ")", "\n", "\n", "batches", ".", "submit", "(", ")", "\n", "out1", ",", "i1", "=", "batches", ".", "wait_next", "(", ")", "\n", "\n", "batches", ".", "reset", "(", ")", "\n", "batches", ".", "submit", "(", ")", "\n", "out0_", ",", "i0_", "=", "batches", ".", "wait_next", "(", ")", "\n", "\n", "assert", "i0", "==", "0", "\n", "assert", "i1", "==", "1", "\n", "assert", "i0_", "==", "0", "\n", "assert", "np", ".", "array_equal", "(", "out0", "[", "'k2'", "]", ",", "out0_", "[", "'k2'", "]", ")", "\n", "assert", "not", "np", ".", "array_equal", "(", "out0", "[", "'k2'", "]", ",", "out1", "[", "'k2'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.unit.test_client.test_multiprocessing_kwargs": [[32, 46], ["elfi.get_client", "elfi.get_client", "elfi.set_client", "elfi.set_client", "elfi.Rejection", "elfi.Rejection", "elfi.set_client", "elfi.set_client", "elfi.Rejection", "elfi.Rejection", "elfi.set_client", "elfi.set_client"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client"], ["", "def", "test_multiprocessing_kwargs", "(", "simple_model", ")", ":", "\n", "    ", "pre", "=", "elfi", ".", "get_client", "(", ")", "\n", "\n", "m", "=", "simple_model", "\n", "num_proc", "=", "2", "\n", "elfi", ".", "set_client", "(", "'multiprocessing'", ",", "num_processes", "=", "num_proc", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", "[", "'k1'", "]", ")", "\n", "assert", "rej", ".", "client", ".", "num_cores", "==", "num_proc", "\n", "\n", "elfi", ".", "set_client", "(", "'multiprocessing'", ",", "processes", "=", "num_proc", ")", "\n", "rej", "=", "elfi", ".", "Rejection", "(", "m", "[", "'k1'", "]", ")", "\n", "assert", "rej", ".", "client", ".", "num_cores", "==", "num_proc", "\n", "\n", "elfi", ".", "set_client", "(", "pre", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.Compiler.compile": [[15, 30], ["None"], "methods", ["None"], ["@", "classmethod", "\n", "def", "compile", "(", "cls", ",", "source_net", ",", "compiled_net", ")", ":", "\n", "        ", "\"\"\"Compiles the nodes present in the `source_net`.\n\n        Parameters\n        ----------\n        source_net : nx.DiGraph\n        compiled_net : nx.DiGraph\n\n        Returns\n        -------\n        compiled_net : nx.Digraph\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.OutputCompiler.compile": [[33, 72], ["logger.debug", "compiled_net.add_nodes_from", "compiled_net.add_edges_from", "compiled_net.nodes_iter", "source_net.nodes", "source_net.edges", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.nodes"], ["    ", "@", "classmethod", "\n", "def", "compile", "(", "cls", ",", "source_net", ",", "compiled_net", ")", ":", "\n", "        ", "\"\"\"Flag nodes for running.\n\n        Augments the state dictionaries of each node with a flag\n        that determines whether the node is runnable or not.\n\n        Parameters\n        ----------\n        source_net : nx.DiGraph\n        compiled_net : nx.DiGraph\n\n        Returns\n        -------\n        compiled_net : nx.Digraph\n\n        \"\"\"", "\n", "logger", ".", "debug", "(", "\"{} compiling...\"", ".", "format", "(", "cls", ".", "__name__", ")", ")", "\n", "\n", "# Make a structural copy of the source_net", "\n", "compiled_net", ".", "add_nodes_from", "(", "source_net", ".", "nodes", "(", ")", ")", "\n", "compiled_net", ".", "add_edges_from", "(", "source_net", ".", "edges", "(", "data", "=", "True", ")", ")", "\n", "\n", "# Compile the nodes to computation nodes", "\n", "for", "name", ",", "data", "in", "compiled_net", ".", "nodes_iter", "(", "data", "=", "True", ")", ":", "\n", "            ", "state", "=", "source_net", ".", "node", "[", "name", "]", "\n", "if", "'_output'", "in", "state", "and", "'_operation'", "in", "state", ":", "\n", "                ", "raise", "ValueError", "(", "\"Cannot compile: both _output and _operation present \"", "\n", "\"for node '{}'\"", ".", "format", "(", "name", ")", ")", "\n", "\n", "", "if", "'_output'", "in", "state", ":", "\n", "                ", "data", "[", "'output'", "]", "=", "state", "[", "'_output'", "]", "\n", "", "elif", "'_operation'", "in", "state", ":", "\n", "                ", "data", "[", "'operation'", "]", "=", "state", "[", "'_operation'", "]", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Cannot compile, no _output or _operation present for \"", "\n", "\"node '{}'\"", ".", "format", "(", "name", ")", ")", "\n", "\n", "", "", "return", "compiled_net", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.ObservedCompiler.compile": [[75, 129], ["logger.debug", "networkx.topological_sort", "state.get", "elfi.utils.observed_name", "networkx.ancestors", "observable.append", "cls.make_observed_copy", "state.get", "state.get", "elfi.utils.observed_name", "source_net.predecessors", "uses_observed.append", "cls.make_observed_copy", "compiled_net.add_edge", "compiled_net.add_edge", "source_net.node.get", "ValueError", "elfi.utils.observed_name", "[].copy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.observed_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.ObservedCompiler.make_observed_copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.observed_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.ObservedCompiler.make_observed_copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_edge", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_edge", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.observed_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["    ", "@", "classmethod", "\n", "def", "compile", "(", "cls", ",", "source_net", ",", "compiled_net", ")", ":", "\n", "        ", "\"\"\"Add observed nodes to the computation graph.\n\n        Parameters\n        ----------\n        source_net : nx.DiGraph\n        compiled_net : nx.DiGraph\n\n        Returns\n        -------\n        compiled_net : nx.Digraph\n\n        \"\"\"", "\n", "logger", ".", "debug", "(", "\"{} compiling...\"", ".", "format", "(", "cls", ".", "__name__", ")", ")", "\n", "\n", "observable", "=", "[", "]", "\n", "uses_observed", "=", "[", "]", "\n", "\n", "for", "node", "in", "nx", ".", "topological_sort", "(", "source_net", ")", ":", "\n", "            ", "state", "=", "source_net", ".", "node", "[", "node", "]", "\n", "if", "state", ".", "get", "(", "'_observable'", ")", ":", "\n", "                ", "observable", ".", "append", "(", "node", ")", "\n", "cls", ".", "make_observed_copy", "(", "node", ",", "compiled_net", ")", "\n", "", "elif", "state", ".", "get", "(", "'_uses_observed'", ")", ":", "\n", "                ", "uses_observed", ".", "append", "(", "node", ")", "\n", "obs_node", "=", "cls", ".", "make_observed_copy", "(", "node", ",", "compiled_net", ",", "args_to_tuple", ")", "\n", "# Make edge to the using node", "\n", "compiled_net", ".", "add_edge", "(", "obs_node", ",", "node", ",", "param", "=", "'observed'", ")", "\n", "", "else", ":", "\n", "                ", "continue", "\n", "\n", "# Copy the edges", "\n", "", "if", "not", "state", ".", "get", "(", "'_stochastic'", ")", ":", "\n", "                ", "obs_node", "=", "observed_name", "(", "node", ")", "\n", "for", "parent", "in", "source_net", ".", "predecessors", "(", "node", ")", ":", "\n", "                    ", "if", "parent", "in", "observable", ":", "\n", "                        ", "link_parent", "=", "observed_name", "(", "parent", ")", "\n", "", "else", ":", "\n", "                        ", "link_parent", "=", "parent", "\n", "\n", "", "compiled_net", ".", "add_edge", "(", "link_parent", ",", "obs_node", ",", "source_net", "[", "parent", "]", "[", "node", "]", ".", "copy", "(", ")", ")", "\n", "\n", "# Check that there are no stochastic nodes in the ancestors", "\n", "", "", "", "for", "node", "in", "uses_observed", ":", "\n", "# Use the observed version to query observed ancestors in the compiled_net", "\n", "            ", "obs_node", "=", "observed_name", "(", "node", ")", "\n", "for", "ancestor_node", "in", "nx", ".", "ancestors", "(", "compiled_net", ",", "obs_node", ")", ":", "\n", "                ", "if", "'_stochastic'", "in", "source_net", ".", "node", ".", "get", "(", "ancestor_node", ",", "{", "}", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Observed nodes must be deterministic. Observed \"", "\n", "\"data depends on a non-deterministic node {}.\"", "\n", ".", "format", "(", "ancestor_node", ")", ")", "\n", "\n", "", "", "", "return", "compiled_net", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.ObservedCompiler.make_observed_copy": [[130, 157], ["elfi.utils.observed_name", "compiled_net.has_node", "compiled_net.add_node", "ValueError", "compiled_net.node[].copy", "dict"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.observed_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "@", "classmethod", "\n", "def", "make_observed_copy", "(", "cls", ",", "node", ",", "compiled_net", ",", "operation", "=", "None", ")", ":", "\n", "        ", "\"\"\"Make a renamed copy of an observed node and add it to `compiled_net`.\n\n        Parameters\n        ----------\n        node : str\n        compiled_net : nx.DiGraph\n        operation : callable, optional\n\n        Returns\n        -------\n        str\n\n        \"\"\"", "\n", "obs_node", "=", "observed_name", "(", "node", ")", "\n", "\n", "if", "compiled_net", ".", "has_node", "(", "obs_node", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Observed node {} already exists!\"", ".", "format", "(", "obs_node", ")", ")", "\n", "\n", "", "if", "operation", "is", "None", ":", "\n", "            ", "compiled_dict", "=", "compiled_net", ".", "node", "[", "node", "]", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "            ", "compiled_dict", "=", "dict", "(", "operation", "=", "operation", ")", "\n", "\n", "", "compiled_net", ".", "add_node", "(", "obs_node", ",", "compiled_dict", ")", "\n", "return", "obs_node", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.AdditionalNodesCompiler.compile": [[160, 186], ["logger.debug", "dict", "dict.items", "source_net.nodes_iter", "d.get", "compiled_net.add_edge", "compiled_net.has_node", "compiled_net.add_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_edge", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_node"], ["    ", "@", "classmethod", "\n", "def", "compile", "(", "cls", ",", "source_net", ",", "compiled_net", ")", ":", "\n", "        ", "\"\"\"Add runtime instruction nodes to the computation graph.\n\n        Parameters\n        ----------\n        source_net : nx.DiGraph\n        compiled_net : nx.DiGraph\n\n        Returns\n        -------\n        compiled_net : nx.Digraph\n\n        \"\"\"", "\n", "logger", ".", "debug", "(", "\"{} compiling...\"", ".", "format", "(", "cls", ".", "__name__", ")", ")", "\n", "\n", "instruction_node_map", "=", "dict", "(", "_uses_batch_size", "=", "'_batch_size'", ",", "_uses_meta", "=", "'_meta'", ")", "\n", "\n", "for", "instruction", ",", "_node", "in", "instruction_node_map", ".", "items", "(", ")", ":", "\n", "            ", "for", "node", ",", "d", "in", "source_net", ".", "nodes_iter", "(", "data", "=", "True", ")", ":", "\n", "                ", "if", "d", ".", "get", "(", "instruction", ")", ":", "\n", "                    ", "if", "not", "compiled_net", ".", "has_node", "(", "_node", ")", ":", "\n", "                        ", "compiled_net", ".", "add_node", "(", "_node", ")", "\n", "", "compiled_net", ".", "add_edge", "(", "_node", ",", "node", ",", "param", "=", "_node", "[", "1", ":", "]", ")", "\n", "\n", "", "", "", "return", "compiled_net", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.RandomStateCompiler.compile": [[189, 212], ["logger.debug", "source_net.nodes_iter", "compiled_net.add_edge", "compiled_net.has_node", "compiled_net.add_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_edge", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_node"], ["    ", "@", "classmethod", "\n", "def", "compile", "(", "cls", ",", "source_net", ",", "compiled_net", ")", ":", "\n", "        ", "\"\"\"Add a node for random state and edges to stochastic nodes in the computation graph.\n\n        Parameters\n        ----------\n        source_net : nx.DiGraph\n        compiled_net : nx.DiGraph\n\n        Returns\n        -------\n        compiled_net : nx.Digraph\n\n        \"\"\"", "\n", "logger", ".", "debug", "(", "\"{} compiling...\"", ".", "format", "(", "cls", ".", "__name__", ")", ")", "\n", "\n", "_random_node", "=", "'_random_state'", "\n", "for", "node", ",", "d", "in", "source_net", ".", "nodes_iter", "(", "data", "=", "True", ")", ":", "\n", "            ", "if", "'_stochastic'", "in", "d", ":", "\n", "                ", "if", "not", "compiled_net", ".", "has_node", "(", "_random_node", ")", ":", "\n", "                    ", "compiled_net", ".", "add_node", "(", "_random_node", ")", "\n", "", "compiled_net", ".", "add_edge", "(", "_random_node", ",", "node", ",", "param", "=", "'random_state'", ")", "\n", "", "", "return", "compiled_net", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.compiler.ReduceCompiler.compile": [[215, 237], ["logger.debug", "elfi.utils.nbunch_ancestors", "compiled_net.nodes", "compiled_net.remove_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.nbunch_ancestors", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.nodes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node"], ["    ", "@", "classmethod", "\n", "def", "compile", "(", "cls", ",", "source_net", ",", "compiled_net", ")", ":", "\n", "        ", "\"\"\"Remove redundant nodes from the computation graph.\n\n        Parameters\n        ----------\n        source_net : nx.DiGraph\n        compiled_net : nx.DiGraph\n\n        Returns\n        -------\n        compiled_net : nx.Digraph\n\n        \"\"\"", "\n", "logger", ".", "debug", "(", "\"{} compiling...\"", ".", "format", "(", "cls", ".", "__name__", ")", ")", "\n", "\n", "outputs", "=", "compiled_net", ".", "graph", "[", "'outputs'", "]", "\n", "output_ancestors", "=", "nbunch_ancestors", "(", "compiled_net", ",", "outputs", ")", "\n", "for", "node", "in", "compiled_net", ".", "nodes", "(", ")", ":", "\n", "            ", "if", "node", "not", "in", "output_ancestors", ":", "\n", "                ", "compiled_net", ".", "remove_node", "(", "node", ")", "\n", "", "", "return", "compiled_net", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.__init__": [[62, 81], ["client.compile", "collections.OrderedDict", "client.get_client"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client"], ["def", "__init__", "(", "self", ",", "model", ",", "context", ",", "output_names", "=", "None", ",", "client", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compile the computational graph and associate it with a context etc.\n\n        Parameters\n        ----------\n        model : ElfiModel\n        context : ComputationContext\n        output_names : list of str, optional\n        client : Client, optional\n\n        \"\"\"", "\n", "client", "=", "client", "or", "get_client", "(", ")", "\n", "\n", "self", ".", "compiled_net", "=", "client", ".", "compile", "(", "model", ".", "source_net", ",", "output_names", ")", "\n", "self", ".", "context", "=", "context", "\n", "self", ".", "client", "=", "client", "\n", "\n", "self", ".", "_next_batch_index", "=", "0", "\n", "self", ".", "_pending_batches", "=", "OrderedDict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.has_ready": [[82, 93], ["client.BatchHandler._pending_batches.items", "len", "client.BatchHandler.client.is_ready"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.is_ready"], ["", "def", "has_ready", "(", "self", ",", "any", "=", "False", ")", ":", "\n", "        ", "\"\"\"Check if the next batch in succession is ready.\"\"\"", "\n", "if", "len", "(", "self", ".", "_pending_batches", ")", "==", "0", ":", "\n", "            ", "return", "False", "\n", "\n", "", "for", "bi", ",", "id", "in", "self", ".", "_pending_batches", ".", "items", "(", ")", ":", "\n", "            ", "if", "self", ".", "client", ".", "is_ready", "(", "id", ")", ":", "\n", "                ", "return", "True", "\n", "", "if", "not", "any", ":", "\n", "                ", "break", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.next_index": [[94, 98], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "next_index", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the next batch index to be submitted.\"\"\"", "\n", "return", "self", ".", "_next_batch_index", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.total": [[99, 103], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "total", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the total number of submitted batches.\"\"\"", "\n", "return", "self", ".", "_next_batch_index", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.num_ready": [[104, 108], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_ready", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of finished batches.\"\"\"", "\n", "return", "self", ".", "total", "-", "self", ".", "num_pending", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.num_pending": [[109, 113], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_pending", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the total number of batches pending for evaluation.\"\"\"", "\n", "return", "len", "(", "self", ".", "pending_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.has_pending": [[114, 118], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_pending", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return whether any pending batches exist.\"\"\"", "\n", "return", "self", ".", "num_pending", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.pending_indices": [[119, 123], ["client.BatchHandler._pending_batches.keys"], "methods", ["None"], ["", "@", "property", "\n", "def", "pending_indices", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the keys to pending batches.\"\"\"", "\n", "return", "self", ".", "_pending_batches", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.cancel_pending": [[124, 140], ["reversed", "list", "logger.debug", "client.BatchHandler.client.remove_task", "client.BatchHandler._pending_batches.pop", "client.BatchHandler._pending_batches.items", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.remove_task"], ["", "def", "cancel_pending", "(", "self", ")", ":", "\n", "        ", "\"\"\"Cancel all pending batches.\n\n        Sets the next batch_index to the index of the last cancelled.\n\n        Note that we rely here on the assumption that batches are processed in order.\n\n        \"\"\"", "\n", "for", "batch_index", ",", "id", "in", "reversed", "(", "list", "(", "self", ".", "_pending_batches", ".", "items", "(", ")", ")", ")", ":", "\n", "            ", "if", "batch_index", "!=", "self", ".", "_next_batch_index", "-", "1", ":", "\n", "                ", "raise", "ValueError", "(", "'Batches are not in order'", ")", "\n", "\n", "", "logger", ".", "debug", "(", "'Cancelling batch {}'", ".", "format", "(", "batch_index", ")", ")", "\n", "self", ".", "client", ".", "remove_task", "(", "id", ")", "\n", "self", ".", "_pending_batches", ".", "pop", "(", "batch_index", ")", "\n", "self", ".", "_next_batch_index", "=", "batch_index", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.reset": [[141, 145], ["client.BatchHandler.cancel_pending"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.cancel_pending"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Cancel all pending batches and set the next index to 0.\"\"\"", "\n", "self", ".", "cancel_pending", "(", ")", "\n", "self", ".", "_next_batch_index", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.submit": [[146, 170], ["logger.debug", "client.BatchHandler.client.load_data", "batch.items", "client.BatchHandler.client.submit"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.load_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.submit"], ["", "def", "submit", "(", "self", ",", "batch", "=", "None", ")", ":", "\n", "        ", "\"\"\"Submit a batch with a batch index given by `next_index`.\n\n        Parameters\n        ----------\n        batch : dict\n            Overriding values for the batch.\n\n        \"\"\"", "\n", "batch", "=", "batch", "or", "{", "}", "\n", "batch_index", "=", "self", ".", "_next_batch_index", "\n", "\n", "logger", ".", "debug", "(", "'Submitting batch {}'", ".", "format", "(", "batch_index", ")", ")", "\n", "loaded_net", "=", "self", ".", "client", ".", "load_data", "(", "self", ".", "compiled_net", ",", "self", ".", "context", ",", "batch_index", ")", "\n", "# Override", "\n", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", ":", "\n", "            ", "loaded_net", ".", "node", "[", "k", "]", "=", "{", "'output'", ":", "v", "}", "\n", "\n", "", "task_id", "=", "self", ".", "client", ".", "submit", "(", "loaded_net", ")", "\n", "self", ".", "_pending_batches", "[", "batch_index", "]", "=", "task_id", "\n", "\n", "# Update counters", "\n", "self", ".", "_next_batch_index", "+=", "1", "\n", "self", ".", "context", ".", "num_submissions", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.wait_next": [[171, 182], ["client.BatchHandler._pending_batches.popitem", "client.BatchHandler.client.get_result", "logger.debug", "client.BatchHandler.context.callback", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.get_result", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ComputationContext.callback"], ["", "def", "wait_next", "(", "self", ")", ":", "\n", "        ", "\"\"\"Wait for the next batch in succession.\"\"\"", "\n", "if", "len", "(", "self", ".", "_pending_batches", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot wait for a batch, no batches currently submitted'", ")", "\n", "\n", "", "batch_index", ",", "task_id", "=", "self", ".", "_pending_batches", ".", "popitem", "(", "last", "=", "False", ")", "\n", "batch", "=", "self", ".", "client", ".", "get_result", "(", "task_id", ")", "\n", "logger", ".", "debug", "(", "'Received batch {}'", ".", "format", "(", "batch_index", ")", ")", "\n", "\n", "self", ".", "context", ".", "callback", "(", "batch", ",", "batch_index", ")", "\n", "return", "batch", ",", "batch_index", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.compute": [[183, 187], ["client.BatchHandler.client.load_data", "client.BatchHandler.client.compute"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.load_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compute"], ["", "def", "compute", "(", "self", ",", "batch_index", "=", "0", ")", ":", "\n", "        ", "\"\"\"Blocking call to compute a batch from the model.\"\"\"", "\n", "loaded_net", "=", "self", ".", "client", ".", "load_data", "(", "self", ".", "compiled_net", ",", "self", ".", "context", ",", "batch_index", ")", "\n", "return", "self", ".", "client", ".", "compute", "(", "loaded_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.num_cores": [[188, 192], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_cores", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of processes.\"\"\"", "\n", "return", "self", ".", "client", ".", "num_cores", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.apply": [[197, 217], ["None"], "methods", ["None"], ["def", "apply", "(", "self", ",", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Add `kallable(*args, **kwargs)` to the queue of tasks and return immediately.\n\n        Non-blocking apply.\n\n        Parameters\n        ----------\n        kallable : callable\n        args\n            Positional arguments for the kallable\n        kwargs\n            Keyword arguments for the kallable\n\n        Returns\n        -------\n        id : int\n            Number of the queued task.\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.apply_sync": [[218, 229], ["None"], "methods", ["None"], ["", "def", "apply_sync", "(", "self", ",", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Call and returns the result of `kallable(*args, **kwargs)`.\n\n        Blocking apply.\n\n        Parameters\n        ----------\n        kallable : callable\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.get_result": [[230, 242], ["None"], "methods", ["None"], ["", "def", "get_result", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Return the result from task identified by `task_id` when it arrives.\n\n        ELFI will call this only once per task_id.\n\n        Parameters\n        ----------\n        task_id : int\n            Id of the task whose result to return.\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.is_ready": [[243, 252], ["None"], "methods", ["None"], ["", "def", "is_ready", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Return whether task with identifier `task_id` is ready.\n\n        Parameters\n        ----------\n        task_id : int\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.remove_task": [[253, 262], ["None"], "methods", ["None"], ["", "def", "remove_task", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Remove task with identifier `task_id` from pool.\n\n        Parameters\n        ----------\n        task_id : int\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.reset": [[263, 266], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Stop all worker processes immediately and clear pending tasks.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.submit": [[267, 270], ["client.ClientBase.apply"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply"], ["", "def", "submit", "(", "self", ",", "loaded_net", ")", ":", "\n", "        ", "\"\"\"Add `loaded_net` to the queue of tasks and return immediately.\"\"\"", "\n", "return", "self", ".", "apply", "(", "Executor", ".", "execute", ",", "loaded_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compute": [[271, 274], ["client.ClientBase.apply_sync"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply_sync"], ["", "def", "compute", "(", "self", ",", "loaded_net", ")", ":", "\n", "        ", "\"\"\"Request evaluation of `loaded_net` and wait for result.\"\"\"", "\n", "return", "self", ".", "apply_sync", "(", "Executor", ".", "execute", ",", "loaded_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.num_cores": [[275, 279], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_cores", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of processes.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile": [[280, 314], ["networkx.DiGraph", "elfi.compiler.OutputCompiler.compile", "elfi.compiler.ObservedCompiler.compile", "elfi.compiler.AdditionalNodesCompiler.compile", "elfi.compiler.RandomStateCompiler.compile", "elfi.compiler.ReduceCompiler.compile", "source_net.nodes", "logger.warning", "isinstance"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.nodes"], ["", "@", "classmethod", "\n", "def", "compile", "(", "cls", ",", "source_net", ",", "outputs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compile the structure of the output net.\n\n        Does not insert any data into the net.\n\n        Parameters\n        ----------\n        source_net : nx.DiGraph\n            Can be acquired from `model.source_net`\n        outputs : list of node names\n\n        Returns\n        -------\n        output_net : nx.DiGraph\n            output_net codes the execution of the model\n\n        \"\"\"", "\n", "if", "outputs", "is", "None", ":", "\n", "            ", "outputs", "=", "source_net", ".", "nodes", "(", ")", "\n", "", "if", "not", "outputs", ":", "\n", "            ", "logger", ".", "warning", "(", "\"Compiling for no outputs!\"", ")", "\n", "", "outputs", "=", "outputs", "if", "isinstance", "(", "outputs", ",", "list", ")", "else", "[", "outputs", "]", "\n", "\n", "compiled_net", "=", "nx", ".", "DiGraph", "(", "\n", "outputs", "=", "outputs", ",", "name", "=", "source_net", ".", "graph", "[", "'name'", "]", ",", "observed", "=", "source_net", ".", "graph", "[", "'observed'", "]", ")", "\n", "\n", "compiled_net", "=", "OutputCompiler", ".", "compile", "(", "source_net", ",", "compiled_net", ")", "\n", "compiled_net", "=", "ObservedCompiler", ".", "compile", "(", "source_net", ",", "compiled_net", ")", "\n", "compiled_net", "=", "AdditionalNodesCompiler", ".", "compile", "(", "source_net", ",", "compiled_net", ")", "\n", "compiled_net", "=", "RandomStateCompiler", ".", "compile", "(", "source_net", ",", "compiled_net", ")", "\n", "compiled_net", "=", "ReduceCompiler", ".", "compile", "(", "source_net", ",", "compiled_net", ")", "\n", "\n", "return", "compiled_net", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.load_data": [[315, 342], ["networkx.DiGraph", "elfi.loader.ObservedLoader.load", "elfi.loader.AdditionalNodesLoader.load", "elfi.loader.RandomStateLoader.load", "elfi.loader.PoolLoader.load"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load"], ["", "@", "classmethod", "\n", "def", "load_data", "(", "cls", ",", "compiled_net", ",", "context", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Load data from the sources of the model and adds them to the compiled net.\n\n        Parameters\n        ----------\n        context : ComputationContext\n        compiled_net : nx.DiGraph\n        batch_index : int\n\n        Returns\n        -------\n        output_net : nx.DiGraph\n\n        \"\"\"", "\n", "# Make a shallow copy of the graph", "\n", "loaded_net", "=", "nx", ".", "DiGraph", "(", "compiled_net", ")", "\n", "\n", "loaded_net", "=", "ObservedLoader", ".", "load", "(", "context", ",", "loaded_net", ",", "batch_index", ")", "\n", "loaded_net", "=", "AdditionalNodesLoader", ".", "load", "(", "context", ",", "loaded_net", ",", "batch_index", ")", "\n", "loaded_net", "=", "RandomStateLoader", ".", "load", "(", "context", ",", "loaded_net", ",", "batch_index", ")", "\n", "loaded_net", "=", "PoolLoader", ".", "load", "(", "context", ",", "loaded_net", ",", "batch_index", ")", "\n", "\n", "# Add cache from the contect", "\n", "loaded_net", ".", "graph", "[", "'_executor_cache'", "]", "=", "context", ".", "caches", "[", "'executor'", "]", "\n", "\n", "return", "loaded_net", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client": [[21, 29], ["_default_class", "ValueError"], "function", ["None"], ["def", "get_client", "(", ")", ":", "\n", "    ", "\"\"\"Get the current ELFI client instance.\"\"\"", "\n", "global", "_client", "\n", "if", "_client", "is", "None", ":", "\n", "        ", "if", "_default_class", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Default client class is not defined'", ")", "\n", "", "_client", "=", "_default_class", "(", ")", "\n", "", "return", "_client", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client": [[31, 49], ["isinstance", "importlib.import_module", "importlib.import_module.Client"], "function", ["None"], ["", "def", "set_client", "(", "client", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Set the current ELFI client instance.\n\n    Parameters\n    ----------\n    client : ClientBase or str\n        Instance of a client from ClientBase,\n        or a string from ['native', 'multiprocessing', 'ipyparallel'].\n        If string, the respective constructor is called with `kwargs`.\n\n    \"\"\"", "\n", "global", "_client", "\n", "\n", "if", "isinstance", "(", "client", ",", "str", ")", ":", "\n", "        ", "m", "=", "importlib", ".", "import_module", "(", "'elfi.clients.{}'", ".", "format", "(", "client", ")", ")", "\n", "client", "=", "m", ".", "Client", "(", "**", "kwargs", ")", "\n", "\n", "", "_client", "=", "client", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_default_class": [[51, 57], ["isinstance"], "function", ["None"], ["", "def", "set_default_class", "(", "class_or_module", ")", ":", "\n", "    ", "\"\"\"Set the default client class.\"\"\"", "\n", "global", "_default_class", "\n", "if", "isinstance", "(", "class_or_module", ",", "ModuleType", ")", ":", "\n", "        ", "class_or_module", "=", "class_or_module", ".", "Client", "\n", "", "_default_class", "=", "class_or_module", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.scipy_from_str": [[18, 23], ["SCIPY_ALIASES.get.lower", "SCIPY_ALIASES.get", "getattr"], "function", ["None"], ["from", "kelfi", ".", "kernels", "import", "gaussian_kernel_gramix", "\n", "\n", "\n", "import", "warnings", "\n", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.random_seed": [[25, 31], ["numpy.random.RandomState().get_state", "numpy.random.RandomState"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_state"], ["# =====================", "\n", "# PLOTTING FUNCTIONS:", "\n", "# =====================", "\n", "\n", "mpl", ".", "rcParams", "[", "'figure.dpi'", "]", "=", "300", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.random_name": [[33, 43], ["str", "uuid.uuid4"], "function", ["None"], ["def", "get_weighted_samples", "(", "post", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "post", ".", "prior", ".", "rvs", "(", "size", "=", "N", ")", "\n", "\n", "if", "theta", ".", "ndim", "==", "1", ":", "\n", "        ", "theta", "=", "theta", ".", "reshape", "(", "theta", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "\n", "", "weights", "=", "post", ".", "_unnormalized_likelihood", "(", "theta", ")", "\n", "return", "theta", ",", "weights", "\n", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.observed_name": [[45, 48], ["None"], "function", ["None"], ["    ", "theta", "=", "samples", "\n", "n_weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "\n", "\n", "# importance weighted resampling", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.args_to_tuple": [[50, 53], ["tuple"], "function", ["None"], ["theta_resampled", "=", "theta", "[", "resample_index", ",", ":", "]", "\n", "theta_df", "=", "pd", ".", "DataFrame", ".", "from_records", "(", "theta_resampled", ",", "columns", "=", "cols", ")", "\n", "return", "theta_df", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.is_array": [[55, 58], ["hasattr"], "function", ["None"], ["\n", "# plot the grid plot of the surrogate posterior", "\n", "", "def", "plot_grid", "(", "theta_df", ",", "lims", ")", ":", "\n", "    ", "g", "=", "sns", ".", "PairGrid", "(", "theta_df", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.nbunch_ancestors": [[63, 69], ["set", "ancestors.union.union", "networkx.ancestors"], "function", ["None"], ["\n", "", "", "g", "=", "g", ".", "map_lower", "(", "plt", ".", "scatter", ",", "s", "=", "1", ")", "\n", "g", "=", "g", ".", "map_diag", "(", "plt", ".", "hist", ")", "\n", "\n", "\n", "", "def", "plot_thresholds", "(", "thrs", ",", "legend", ")", ":", "\n", "    ", "ax", "=", "plt", ".", "gca", "(", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed": [[71, 128], ["isinstance", "len", "ValueError", "numpy.random.RandomState", "set", "np.random.RandomState.randint", "set.update", "len", "ValueError", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update"], ["ax", ".", "set_ylabel", "(", "'threshold'", ")", "\n", "ax", ".", "set_xlabel", "(", "'num of batches'", ")", "\n", "ax", ".", "legend", "(", "legend", ")", "\n", "return", "\n", "\n", "\n", "\n", "", "def", "plot_marginals", "(", "sim", ",", "bounds", ",", "true_samples_df", ",", "true_pars", ")", ":", "\n", "    ", "plot_methods", "=", "[", "'BO-GP(200)'", ",", "'BO-LV-2GP-0.3(200)'", "]", "\n", "par_names", "=", "list", "(", "bounds", ".", "keys", "(", ")", ")", "\n", "sns", ".", "set", "(", "style", "=", "\"ticks\"", ",", "rc", "=", "{", "\"lines.linewidth\"", ":", "0.7", "}", ")", "\n", "\n", "maps", "=", "{", "'t1'", ":", "r'$\\theta_{t1}$'", ",", "'R1'", ":", "r'$\\theta_{R1}$'", ",", "'R2'", ":", "r'$\\theta_{R2}$'", ",", "\n", "'burden'", ":", "r'$\\theta_{burden}$'", ",", "'white'", ":", "r'$\\theta_{white}$'", ",", "\n", "'yellow'", ":", "r'$\\theta_{yellow}$'", ",", "'red'", ":", "r'$\\theta_{red}$'", ",", "\n", "'green'", ":", "r'$\\theta_{green}$'", ",", "'purple'", ":", "r'$\\theta_{purple}$'", ",", "\n", "'x'", ":", "r'$\\theta_{x}$'", ",", "'y'", ":", "r'$\\theta_{y}$'", ",", "\n", "'ns'", ":", "r'$\\theta_{n_s}$'", ",", "'kc'", ":", "r'$\\theta_{k_c}$'", ",", "'alpha'", ":", "r'$\\theta_{\\alpha}$'", ",", "\n", "'r_star'", ":", "r'$\\theta_{R^*}$'", ",", "'As'", ":", "r'$\\theta_{A_s}$'", "}", "\n", "\n", "for", "plot_method", "in", "plot_methods", ":", "\n", "        ", "for", "cur_par_name", ",", "i", "in", "zip", "(", "par_names", ",", "range", "(", "len", "(", "par_names", ")", ")", ")", ":", "\n", "            ", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "for", "filename", "in", "Path", "(", "'./results/'", "+", "sim", "+", "'/'", "+", "plot_method", ")", ".", "glob", "(", "'*.samples'", ")", ":", "\n", "                ", "temp_dict", "=", "scipy", ".", "io", ".", "loadmat", "(", "filename", ")", "\n", "sur_theta", "=", "temp_dict", "[", "cur_par_name", "]", "\n", "# sns.distplot(sur_theta, color=(0.879, 0.929, 0.969), hist=False, kde_kws={'alpha':0.1}) #, scatter_kws={'alpha':0.3})", "\n", "# sns.distplot(sur_theta, color=(0.711, 0.832, 0.91), hist=False, kde_kws={'alpha':0.05}) # DGP almost good", "\n", "# sns.distplot(sur_theta, color=(0.554, 0.734, 0.855), hist=False, kde_kws={'alpha':0.05}) #GP gppd", "\n", "try", ":", "\n", "                    ", "sns", ".", "distplot", "(", "sur_theta", ",", "color", "=", "(", "0.516", ",", "0.707", ",", "0.839", ")", ",", "hist", "=", "False", ",", "kde_kws", "=", "{", "'alpha'", ":", "0.1", "}", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "                    ", "sns", ".", "distplot", "(", "sur_theta", ",", "color", "=", "(", "0.516", ",", "0.707", ",", "0.839", ")", ",", "kde", "=", "False", ",", "kde_kws", "=", "{", "'alpha'", ":", "0.1", "}", ")", "\n", "\n", "", "", "true_theta", "=", "pd", ".", "Series", "(", "true_samples_df", "[", "cur_par_name", "]", ",", "name", "=", "cur_par_name", ")", "\n", "sns", ".", "distplot", "(", "true_theta", ",", "color", "=", "\"r\"", ",", "hist", "=", "False", ",", "kde_kws", "=", "{", "\"linewidth\"", ":", "1", "}", ")", "\n", "plt", ".", "axvline", "(", "true_pars", "[", "i", "]", ",", "ls", "=", "'dashed'", ",", "color", "=", "\"black\"", ")", "\n", "plt", ".", "yticks", "(", "[", "]", ")", "\n", "\n", "if", "'TE'", "in", "sim", ":", "\n", "                ", "plt", ".", "xlabel", "(", "r'$\\theta$'", ")", "\n", "", "else", ":", "\n", "                ", "plt", ".", "xlabel", "(", "maps", "[", "cur_par_name", "]", ")", "\n", "", "plt", ".", "ylabel", "(", "''", ")", "\n", "# plt.ylim((0,2.5))", "\n", "\n", "# fig.set_size_inches(2.5,2.1) # in TE plots", "\n", "# fig.set_size_inches(1.4,1.4) # in 5 row plots", "\n", "fig", ".", "set_size_inches", "(", "1.8", ",", "1.8", ")", "\n", "plt", ".", "savefig", "(", "'plots/'", "+", "sim", "+", "'-'", "+", "plot_method", "+", "'-par-'", "+", "cur_par_name", "+", "'.png'", ",", "dpi", "=", "600", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "\n", "\n", "", "", "", "def", "plot_wasserstein", "(", "boxplot", "=", "True", ")", ":", "\n", "    ", "plot_methods", "=", "[", "'BO-GP'", ",", "'BO-LV-2GP-0.3'", "]", "\n", "\n", "sns", ".", "set", "(", "style", "=", "\"ticks\"", ",", "rc", "=", "{", "\"lines.linewidth\"", ":", "0.7", "}", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.loader.Loader.load": [[11, 29], ["None"], "methods", ["None"], ["@", "classmethod", "\n", "def", "load", "(", "cls", ",", "context", ",", "compiled_net", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Load precomputed data into nodes of `compiled_net`.\n\n        Parameters\n        ----------\n        context : ComputationContext\n        compiled_net : nx.DiGraph\n        batch_index : int\n\n        Returns\n        -------\n        net : nx.DiGraph\n            Loaded net, which is the `compiled_net` that has been loaded with data that\n            can depend on the batch_index.\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.loader.ObservedLoader.load": [[32, 59], ["observed.items", "elfi.utils.observed_name", "dict", "compiled_net.has_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.observed_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node"], ["    ", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "context", ",", "compiled_net", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Add the observed data to the `compiled_net`.\n\n        Parameters\n        ----------\n        context : ComputationContext\n        compiled_net : nx.DiGraph\n        batch_index : int\n\n        Returns\n        -------\n        net : nx.DiGraph\n            Loaded net, which is the `compiled_net` that has been loaded with data that\n            can depend on the batch_index.\n\n        \"\"\"", "\n", "observed", "=", "compiled_net", ".", "graph", "[", "'observed'", "]", "\n", "\n", "for", "name", ",", "obs", "in", "observed", ".", "items", "(", ")", ":", "\n", "            ", "obs_name", "=", "observed_name", "(", "name", ")", "\n", "if", "not", "compiled_net", ".", "has_node", "(", "obs_name", ")", ":", "\n", "                ", "continue", "\n", "", "compiled_net", ".", "node", "[", "obs_name", "]", "=", "dict", "(", "output", "=", "obs", ")", "\n", "\n", "", "del", "compiled_net", ".", "graph", "[", "'observed'", "]", "\n", "return", "compiled_net", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.loader.AdditionalNodesLoader.load": [[62, 93], ["dict", "dict.items", "compiled_net.has_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node"], ["    ", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "context", ",", "compiled_net", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Add runtime information to instruction nodes.\n\n        Parameters\n        ----------\n        context : ComputationContext\n        compiled_net : nx.DiGraph\n        batch_index : int\n\n        Returns\n        -------\n        net : nx.DiGraph\n            Loaded net, which is the `compiled_net` that has been loaded with data that\n            can depend on the batch_index.\n\n        \"\"\"", "\n", "meta_dict", "=", "{", "\n", "'batch_index'", ":", "batch_index", ",", "\n", "'submission_index'", ":", "context", ".", "num_submissions", ",", "\n", "'master_seed'", ":", "context", ".", "seed", ",", "\n", "'model_name'", ":", "compiled_net", ".", "graph", "[", "'name'", "]", "\n", "}", "\n", "\n", "details", "=", "dict", "(", "_batch_size", "=", "context", ".", "batch_size", ",", "_meta", "=", "meta_dict", ")", "\n", "\n", "for", "node", ",", "v", "in", "details", ".", "items", "(", ")", ":", "\n", "            ", "if", "compiled_net", ".", "has_node", "(", "node", ")", ":", "\n", "                ", "compiled_net", ".", "node", "[", "node", "]", "[", "'output'", "]", "=", "v", "\n", "\n", "", "", "return", "compiled_net", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.loader.PoolLoader.load": [[96, 130], ["context.pool.get_batch", "compiled_net.has_node", "compiled_net.node[].pop", "compiled_net.graph[].append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.get_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["    ", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "context", ",", "compiled_net", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Add data from the pools in `context`.\n\n        Parameters\n        ----------\n        context : ComputationContext\n        compiled_net : nx.DiGraph\n        batch_index : int\n\n        Returns\n        -------\n        net : nx.DiGraph\n            Loaded net, which is the `compiled_net` that has been loaded with data that\n            can depend on the batch_index.\n\n        \"\"\"", "\n", "if", "context", ".", "pool", "is", "None", ":", "\n", "            ", "return", "compiled_net", "\n", "\n", "", "batch", "=", "context", ".", "pool", ".", "get_batch", "(", "batch_index", ")", "\n", "\n", "for", "node", "in", "context", ".", "pool", ".", "stores", ":", "\n", "            ", "if", "not", "compiled_net", ".", "has_node", "(", "node", ")", ":", "\n", "                ", "continue", "\n", "", "elif", "node", "in", "batch", ":", "\n", "                ", "compiled_net", ".", "node", "[", "node", "]", "[", "'output'", "]", "=", "batch", "[", "node", "]", "\n", "compiled_net", ".", "node", "[", "node", "]", ".", "pop", "(", "'operation'", ",", "None", ")", "\n", "", "elif", "node", "not", "in", "compiled_net", ".", "graph", "[", "'outputs'", "]", ":", "\n", "# We are missing this item from the batch so add the output to the", "\n", "# requested outputs so that it can be stored when the results arrive", "\n", "                ", "compiled_net", ".", "graph", "[", "'outputs'", "]", ".", "append", "(", "node", ")", "\n", "\n", "", "", "return", "compiled_net", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.loader.RandomStateLoader.load": [[140, 179], ["compiled_net.has_node", "isinstance", "context.caches.get", "elfi.utils.get_sub_seed", "numpy.random.RandomState", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed"], ["    ", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "context", ",", "compiled_net", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Add an instance of random state to the corresponding node.\n\n        Parameters\n        ----------\n        context : ComputationContext\n        compiled_net : nx.DiGraph\n        batch_index : int\n\n        Returns\n        -------\n        net : nx.DiGraph\n            Loaded net, which is the `compiled_net` that has been loaded with data that\n            can depend on the batch_index.\n\n        \"\"\"", "\n", "key", "=", "'output'", "\n", "seed", "=", "context", ".", "seed", "\n", "\n", "if", "seed", "==", "'global'", ":", "\n", "# Get the random_state of the respective worker by delaying the evaluation", "\n", "            ", "random_state", "=", "get_np_random", "\n", "key", "=", "'operation'", "\n", "", "elif", "isinstance", "(", "seed", ",", "(", "int", ",", "np", ".", "int32", ",", "np", ".", "uint32", ")", ")", ":", "\n", "# TODO: In the future, we could use https://pypi.python.org/pypi/randomstate to enable", "\n", "# jumps?", "\n", "            ", "cache", "=", "context", ".", "caches", ".", "get", "(", "'sub_seed'", ",", "None", ")", "\n", "sub_seed", "=", "get_sub_seed", "(", "seed", ",", "batch_index", ",", "cache", "=", "cache", ")", "\n", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "sub_seed", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Seed of type {} is not supported\"", ".", "format", "(", "seed", ")", ")", "\n", "\n", "# Assign the random state or its acquirer function to the corresponding node", "\n", "", "node_name", "=", "'_random_state'", "\n", "if", "compiled_net", ".", "has_node", "(", "node_name", ")", ":", "\n", "            ", "compiled_net", ".", "node", "[", "node_name", "]", "[", "key", "]", "=", "random_state", "\n", "\n", "", "return", "compiled_net", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.loader.get_np_random": [[134, 137], ["None"], "function", ["None"], ["", "", "def", "get_np_random", "(", ")", ":", "\n", "    ", "\"\"\"Get RandomState.\"\"\"", "\n", "return", "np", ".", "random", ".", "mtrand", ".", "_rand", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.Executor.execute": [[44, 82], ["cls.get_execution_order", "logger.debug", "attr.keys", "ValueError", "cls._run", "ValueError", "exc.__class__().with_traceback", "exc.__class__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.Executor.get_execution_order", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.Executor._run"], ["@", "classmethod", "\n", "def", "execute", "(", "cls", ",", "G", ")", ":", "\n", "        ", "\"\"\"Execute a graph.\n\n        Parameters\n        ----------\n        G : nx.DiGraph\n\n        Returns\n        -------\n        dict of node outputs\n\n        \"\"\"", "\n", "order", "=", "cls", ".", "get_execution_order", "(", "G", ")", "\n", "\n", "for", "node", "in", "order", ":", "\n", "            ", "attr", "=", "G", ".", "node", "[", "node", "]", "\n", "logger", ".", "debug", "(", "\"Executing {}\"", ".", "format", "(", "node", ")", ")", "\n", "\n", "if", "attr", ".", "keys", "(", ")", ">=", "{", "'operation'", ",", "'output'", "}", ":", "\n", "                ", "raise", "ValueError", "(", "'Generative graph has both op and output present for '", "\n", "'node {}'", ".", "format", "(", "node", ")", ")", "\n", "\n", "", "if", "'operation'", "in", "attr", ":", "\n", "                ", "op", "=", "attr", "[", "'operation'", "]", "\n", "try", ":", "\n", "                    ", "G", ".", "node", "[", "node", "]", "=", "cls", ".", "_run", "(", "op", ",", "node", ",", "G", ")", "\n", "", "except", "Exception", "as", "exc", ":", "\n", "                    ", "raise", "exc", ".", "__class__", "(", "\"In executing node '{}': {}.\"", "\n", ".", "format", "(", "node", ",", "exc", ")", ")", ".", "with_traceback", "(", "exc", ".", "__traceback__", ")", "\n", "\n", "", "", "elif", "'output'", "not", "in", "attr", ":", "\n", "                ", "raise", "ValueError", "(", "'Generative graph has no op or output present for node '", "\n", "'{}'", ".", "format", "(", "node", ")", ")", "\n", "\n", "# Make a result dict based on the requested outputs", "\n", "", "", "result", "=", "{", "k", ":", "G", ".", "node", "[", "k", "]", "[", "'output'", "]", "for", "k", "in", "G", ".", "graph", "[", "'outputs'", "]", "}", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.Executor.get_execution_order": [[83, 138], ["G.graph.get", "tuple", "sorted", "set", "networkx.DiGraph", "executor.nx_constant_topological_sort", "G.edges", "set.update", "attr.keys", "ValueError", "networkx.DiGraph.remove_node", "networkx.ancestors", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.nx_constant_topological_sort", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node"], ["", "@", "classmethod", "\n", "def", "get_execution_order", "(", "cls", ",", "G", ")", ":", "\n", "        ", "\"\"\"Return a list of nodes to execute.\n\n        This method returns the minimal list of nodes that need to be executed in\n        graph G in order to return the requested outputs.\n\n        The ordering of the nodes is fixed.\n\n        Parameters\n        ----------\n        G : nx.DiGraph\n\n        Returns\n        -------\n        nodes : list\n            nodes that require execution\n\n        \"\"\"", "\n", "# Get the cache dict if it exists", "\n", "cache", "=", "G", ".", "graph", ".", "get", "(", "'_executor_cache'", ",", "{", "}", ")", "\n", "\n", "output_nodes", "=", "G", ".", "graph", "[", "'outputs'", "]", "\n", "# Filter those output nodes who have an operation to run", "\n", "needed", "=", "tuple", "(", "sorted", "(", "node", "for", "node", "in", "output_nodes", "if", "'operation'", "in", "G", ".", "node", "[", "node", "]", ")", ")", "\n", "\n", "if", "needed", "not", "in", "cache", ":", "\n", "# Resolve the nodes that need to be executed in the graph", "\n", "            ", "nodes_to_execute", "=", "set", "(", "needed", ")", "\n", "\n", "if", "'sort_order'", "not", "in", "cache", ":", "\n", "                ", "cache", "[", "'sort_order'", "]", "=", "nx_constant_topological_sort", "(", "G", ")", "\n", "", "sort_order", "=", "cache", "[", "'sort_order'", "]", "\n", "\n", "# Resolve the dependencies of needed", "\n", "dep_graph", "=", "nx", ".", "DiGraph", "(", "G", ".", "edges", "(", ")", ")", "\n", "for", "node", "in", "sort_order", ":", "\n", "                ", "attr", "=", "G", ".", "node", "[", "node", "]", "\n", "if", "attr", ".", "keys", "(", ")", ">=", "{", "'operation'", ",", "'output'", "}", ":", "\n", "                    ", "raise", "ValueError", "(", "'Generative graph has both op and output present'", ")", "\n", "\n", "# Remove those nodes from the dependency graph whose outputs are present", "\n", "", "if", "'output'", "in", "attr", ":", "\n", "                    ", "dep_graph", ".", "remove_node", "(", "node", ")", "\n", "", "elif", "'operation'", "not", "in", "attr", ":", "\n", "                    ", "raise", "ValueError", "(", "'Generative graph has no op or output present'", ")", "\n", "\n", "# Add the dependencies of the needed nodes", "\n", "", "", "for", "needed_node", "in", "needed", ":", "\n", "                ", "nodes_to_execute", ".", "update", "(", "nx", ".", "ancestors", "(", "dep_graph", ",", "needed_node", ")", ")", "\n", "\n", "# Turn in to a sorted list and cache", "\n", "", "cache", "[", "needed", "]", "=", "[", "n", "for", "n", "in", "sort_order", "if", "n", "in", "nodes_to_execute", "]", "\n", "\n", "", "return", "cache", "[", "needed", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.Executor._run": [[139, 156], ["G.predecessors", "isinstance", "fn", "args.append", "sorted", "operator.itemgetter"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "@", "staticmethod", "\n", "def", "_run", "(", "fn", ",", "node", ",", "G", ")", ":", "\n", "        ", "args", "=", "[", "]", "\n", "kwargs", "=", "{", "}", "\n", "\n", "for", "parent_name", "in", "G", ".", "predecessors", "(", "node", ")", ":", "\n", "            ", "param", "=", "G", "[", "parent_name", "]", "[", "node", "]", "[", "'param'", "]", "\n", "output", "=", "G", ".", "node", "[", "parent_name", "]", "[", "'output'", "]", "\n", "if", "isinstance", "(", "param", ",", "int", ")", ":", "\n", "                ", "args", ".", "append", "(", "(", "param", ",", "output", ")", ")", "\n", "", "else", ":", "\n", "                ", "kwargs", "[", "param", "]", "=", "output", "\n", "\n", "", "", "args", "=", "[", "a", "[", "1", "]", "for", "a", "in", "sorted", "(", "args", ",", "key", "=", "itemgetter", "(", "0", ")", ")", "]", "\n", "\n", "output_dict", "=", "{", "'output'", ":", "fn", "(", "*", "args", ",", "**", "kwargs", ")", "}", "\n", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.executor.nx_constant_topological_sort": [[158, 243], ["set", "set", "G.is_directed", "networkx.NetworkXError", "sorted", "list", "G.nodes", "set.add", "sorted", "reversed", "fringe.pop", "fringe.extend", "set.add", "order.append", "fringe.pop", "new_nodes.append", "networkx.NetworkXUnfeasible"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.nodes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "", "def", "nx_constant_topological_sort", "(", "G", ",", "nbunch", "=", "None", ",", "reverse", "=", "False", ")", ":", "\n", "    ", "\"\"\"Return a list of nodes in a constant topological sort order.\n\n    This implementations is adapted from `networkx.topological_sort`.\n\n    Modified version of networkx.topological_sort. The difference is that this version\n    will always return the same order for the same graph G given that the nodes\n    are either strings or numbers. Nodes will be ordered to alphabetical order before\n    being added to the search.\n\n    A topological sort is a nonunique permutation of the nodes\n    such that an edge from u to v implies that u appears before v in the\n    topological sort order.\n\n    Parameters\n    ----------\n    G : NetworkX digraph\n        A directed graph\n\n    nbunch : container of nodes (optional)\n        Explore graph in specified order given in nbunch\n\n    reverse : bool, optional\n        Return postorder instead of preorder if True.\n        Reverse mode is a bit more efficient.\n\n    Raises\n    ------\n    NetworkXError\n        Topological sort is defined for directed graphs only. If the\n        graph G is undirected, a NetworkXError is raised.\n\n    NetworkXUnfeasible\n        If G is not a directed acyclic graph (DAG) no topological sort\n        exists and a NetworkXUnfeasible exception is raised.\n\n    Notes\n    -----\n    This algorithm is based on a description and proof in The Algorithm Design\n    Manual [1].\n\n    References\n    ----------\n    .. [1] Skiena, S. S. The Algorithm Design Manual  (Springer-Verlag, 1998).\n        http://www.amazon.com/exec/obidos/ASIN/0387948600/ref=ase_thealgorithmrepo/\n\n    \"\"\"", "\n", "if", "not", "G", ".", "is_directed", "(", ")", ":", "\n", "        ", "raise", "nx", ".", "NetworkXError", "(", "\"Topological sort not defined on undirected graphs.\"", ")", "\n", "\n", "# nonrecursive version", "\n", "", "seen", "=", "set", "(", ")", "\n", "order", "=", "[", "]", "\n", "explored", "=", "set", "(", ")", "\n", "\n", "if", "nbunch", "is", "None", ":", "\n", "# Sort them to alphabetical order", "\n", "        ", "nbunch", "=", "sorted", "(", "G", ".", "nodes", "(", ")", ")", "\n", "", "for", "v", "in", "nbunch", ":", "# process all vertices in G", "\n", "        ", "if", "v", "in", "explored", ":", "\n", "            ", "continue", "\n", "", "fringe", "=", "[", "v", "]", "# nodes yet to look at", "\n", "while", "fringe", ":", "\n", "            ", "w", "=", "fringe", "[", "-", "1", "]", "# depth first search", "\n", "if", "w", "in", "explored", ":", "# already looked down this branch", "\n", "                ", "fringe", ".", "pop", "(", ")", "\n", "continue", "\n", "", "seen", ".", "add", "(", "w", ")", "# mark as seen", "\n", "# Check successors for cycles and for new nodes", "\n", "new_nodes", "=", "[", "]", "\n", "for", "n", "in", "sorted", "(", "G", "[", "w", "]", ")", ":", "\n", "                ", "if", "n", "not", "in", "explored", ":", "\n", "                    ", "if", "n", "in", "seen", ":", "# CYCLE !!", "\n", "                        ", "raise", "nx", ".", "NetworkXUnfeasible", "(", "\"Graph contains a cycle.\"", ")", "\n", "", "new_nodes", ".", "append", "(", "n", ")", "\n", "", "", "if", "new_nodes", ":", "# Add new_nodes to fringe", "\n", "                ", "fringe", ".", "extend", "(", "new_nodes", ")", "\n", "", "else", ":", "# No new nodes so w is fully explored", "\n", "                ", "explored", ".", "add", "(", "w", ")", "\n", "order", ".", "append", "(", "w", ")", "\n", "fringe", ".", "pop", "(", ")", "# done considering this node", "\n", "", "", "", "if", "reverse", ":", "\n", "        ", "return", "order", "\n", "", "else", ":", "\n", "        ", "return", "list", "(", "reversed", "(", "order", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.__init__": [[37, 80], ["isinstance", "os.path.exists", "ValueError", "dict.fromkeys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "outputs", "=", "None", ",", "name", "=", "None", ",", "prefix", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize OutputPool.\n\n        Depending on the algorithm, some of these values may be reused\n        after making some changes to `ElfiModel` thus speeding up the inference\n        significantly. For instance, if all the simulations are stored in Rejection\n        sampling, one can change the summaries and distances without having to rerun\n        the simulator.\n\n        Parameters\n        ----------\n        outputs : list, dict, optional\n            List of node names which to store or a dictionary with existing stores. The\n            stores are created on demand.\n        name : str, optional\n            Name of the pool. Used to open a saved pool from disk.\n        prefix : str, optional\n            Path to directory under which `elfi.ArrayPool` will place its folder.\n            Default is a relative path ./pools.\n\n        Returns\n        -------\n        instance : OutputPool\n\n        \"\"\"", "\n", "if", "outputs", "is", "None", ":", "\n", "            ", "stores", "=", "{", "}", "\n", "", "elif", "isinstance", "(", "outputs", ",", "dict", ")", ":", "\n", "            ", "stores", "=", "outputs", "\n", "", "else", ":", "\n", "            ", "stores", "=", "dict", ".", "fromkeys", "(", "outputs", ")", "\n", "\n", "", "self", ".", "stores", "=", "stores", "\n", "\n", "# Context information", "\n", "self", ".", "batch_size", "=", "None", "\n", "self", ".", "seed", "=", "None", "\n", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "prefix", "=", "prefix", "or", "_default_prefix", "\n", "if", "self", ".", "path", "and", "os", ".", "path", ".", "exists", "(", "self", ".", "path", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"A pool with this name already exists in {}. You can use \"", "\n", "\"OutputPool.open() to open it.\"", ".", "format", "(", "self", ".", "prefix", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.output_names": [[81, 85], ["list", "store.OutputPool.stores.keys"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "output_names", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a list of stored names.\"\"\"", "\n", "return", "list", "(", "self", ".", "stores", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.has_context": [[86, 90], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_context", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check if current pool has context information.\"\"\"", "\n", "return", "self", ".", "seed", "is", "not", "None", "and", "self", ".", "batch_size", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.set_context": [[91, 113], ["ValueError", "store.OutputPool.__class__.__name__.lower"], "methods", ["None"], ["", "def", "set_context", "(", "self", ",", "context", ")", ":", "\n", "        ", "\"\"\"Set the context of the pool.\n\n        The pool needs to know the batch_size and the seed.\n\n        Notes\n        -----\n        Also sets the name of the pool if not set already.\n\n        Parameters\n        ----------\n        context : elfi.ComputationContext\n\n        \"\"\"", "\n", "if", "self", ".", "has_context", ":", "\n", "            ", "raise", "ValueError", "(", "'Context is already set'", ")", "\n", "\n", "", "self", ".", "batch_size", "=", "context", ".", "batch_size", "\n", "self", ".", "seed", "=", "context", ".", "seed", "\n", "\n", "if", "self", ".", "name", "is", "None", ":", "\n", "            ", "self", ".", "name", "=", "\"{}_{}\"", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ".", "lower", "(", ")", ",", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.get_batch": [[114, 137], ["dict"], "methods", ["None"], ["", "", "def", "get_batch", "(", "self", ",", "batch_index", ",", "output_names", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a batch from the stores of the pool.\n\n        Parameters\n        ----------\n        batch_index : int\n        output_names : list\n            which outputs to include to the batch\n\n        Returns\n        -------\n        batch : dict\n\n        \"\"\"", "\n", "output_names", "=", "output_names", "or", "self", ".", "output_names", "\n", "batch", "=", "dict", "(", ")", "\n", "for", "output", "in", "output_names", ":", "\n", "            ", "store", "=", "self", ".", "stores", "[", "output", "]", "\n", "if", "store", "is", "None", ":", "\n", "                ", "continue", "\n", "", "if", "batch_index", "in", "store", ":", "\n", "                ", "batch", "[", "output", "]", "=", "store", "[", "batch_index", "]", "\n", "", "", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.add_batch": [[138, 150], ["batch.items", "store.OutputPool.OutputPool._get_store_for"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool._get_store_for"], ["", "def", "add_batch", "(", "self", ",", "batch", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Add the outputs from the batch to their stores.\"\"\"", "\n", "for", "node", ",", "values", "in", "batch", ".", "items", "(", ")", ":", "\n", "            ", "if", "node", "not", "in", "self", ".", "stores", ":", "\n", "                ", "continue", "\n", "", "store", "=", "self", ".", "_get_store_for", "(", "node", ")", "\n", "\n", "# Do not add again. The output should be the same.", "\n", "if", "batch_index", "in", "store", ":", "\n", "                ", "continue", "\n", "\n", "", "store", "[", "batch_index", "]", "=", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.remove_batch": [[151, 156], ["store.OutputPool.stores.values"], "methods", ["None"], ["", "", "def", "remove_batch", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Remove the batch from all stores.\"\"\"", "\n", "for", "store", "in", "self", ".", "stores", ".", "values", "(", ")", ":", "\n", "            ", "if", "batch_index", "in", "store", ":", "\n", "                ", "del", "store", "[", "batch_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.has_store": [[157, 160], ["None"], "methods", ["None"], ["", "", "", "def", "has_store", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Check if `node` is in stores.\"\"\"", "\n", "return", "node", "in", "self", ".", "stores", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.get_store": [[161, 164], ["None"], "methods", ["None"], ["", "def", "get_store", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Return the store for `node`.\"\"\"", "\n", "return", "self", ".", "stores", "[", "node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.add_store": [[165, 179], ["ValueError", "store.OutputPool._make_store_for"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayPool._make_store_for"], ["", "def", "add_store", "(", "self", ",", "node", ",", "store", "=", "None", ")", ":", "\n", "        ", "\"\"\"Add a store object for the node.\n\n        Parameters\n        ----------\n        node : str\n        store : dict, StoreBase, optional\n\n        \"\"\"", "\n", "if", "node", "in", "self", ".", "stores", "and", "self", ".", "stores", "[", "node", "]", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Store for '{}' already exists\"", ".", "format", "(", "node", ")", ")", "\n", "\n", "", "store", "=", "store", "if", "store", "is", "not", "None", "else", "self", ".", "_make_store_for", "(", "node", ")", "\n", "self", ".", "stores", "[", "node", "]", "=", "store", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.remove_store": [[180, 195], ["store.OutputPool.OutputPool.stores.pop"], "methods", ["None"], ["", "def", "remove_store", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Remove and return a store from the pool.\n\n        Parameters\n        ----------\n        node : str\n\n        Returns\n        -------\n        store\n            The removed store\n\n        \"\"\"", "\n", "store", "=", "self", ".", "stores", ".", "pop", "(", "node", ")", "\n", "return", "store", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool._get_store_for": [[196, 201], ["store.OutputPool._make_store_for"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayPool._make_store_for"], ["", "def", "_get_store_for", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Get or make a store.\"\"\"", "\n", "if", "self", ".", "stores", "[", "node", "]", "is", "None", ":", "\n", "            ", "self", ".", "stores", "[", "node", "]", "=", "self", ".", "_make_store_for", "(", "node", ")", "\n", "", "return", "self", ".", "stores", "[", "node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool._make_store_for": [[202, 208], ["None"], "methods", ["None"], ["", "def", "_make_store_for", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Make a default store for a node.\n\n        All the default stores will be created through this method.\n        \"\"\"", "\n", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.__len__": [[209, 217], ["store.OutputPool.stores.items", "max", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the largest batch index in any of the stores.\"\"\"", "\n", "largest", "=", "0", "\n", "for", "output", ",", "store", "in", "self", ".", "stores", ".", "items", "(", ")", ":", "\n", "            ", "if", "store", "is", "None", ":", "\n", "                ", "continue", "\n", "", "largest", "=", "max", "(", "largest", ",", "len", "(", "store", ")", ")", "\n", "", "return", "largest", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.__getitem__": [[218, 221], ["store.OutputPool.get_batch"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.get_batch"], ["", "def", "__getitem__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Return the batch.\"\"\"", "\n", "return", "self", ".", "get_batch", "(", "batch_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.__setitem__": [[222, 225], ["store.OutputPool.add_batch"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.add_batch"], ["", "def", "__setitem__", "(", "self", ",", "batch_index", ",", "batch", ")", ":", "\n", "        ", "\"\"\"Add `batch` into location `batch_index`.\"\"\"", "\n", "return", "self", ".", "add_batch", "(", "batch", ",", "batch_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.__contains__": [[226, 229], ["len"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Check if the pool contains `batch_index`.\"\"\"", "\n", "return", "len", "(", "self", ")", ">", "batch_index", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.clear": [[230, 234], ["store.OutputPool.stores.values", "store.clear"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear"], ["", "def", "clear", "(", "self", ")", ":", "\n", "        ", "\"\"\"Remove all data from the stores.\"\"\"", "\n", "for", "store", "in", "self", ".", "stores", ".", "values", "(", ")", ":", "\n", "            ", "store", ".", "clear", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.save": [[235, 267], ["os.makedirs", "os.getcwd", "os.chdir", "store.OutputPool.stores.items", "os.chdir", "dict.fromkeys", "os.path.join", "pickle.dump", "ValueError", "stores.keys", "store.OutputPool.open"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open"], ["", "", "def", "save", "(", "self", ")", ":", "\n", "        ", "\"\"\"Save the pool to disk.\n\n        This will use pickle to store the pool under self.path.\n        \"\"\"", "\n", "if", "not", "self", ".", "has_context", ":", "\n", "            ", "raise", "ValueError", "(", "\"Pool context is not set, cannot save. Please see the \"", "\n", "\"set_context method.\"", ")", "\n", "\n", "", "os", ".", "makedirs", "(", "self", ".", "path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# Change the working directory so that relative paths to the pool data folder can", "\n", "# be reliably used. This allows moving and renaming of the folder.", "\n", "cwd", "=", "os", ".", "getcwd", "(", ")", "\n", "os", ".", "chdir", "(", "self", ".", "path", ")", "\n", "# Pickle the stores separately", "\n", "for", "node", ",", "store", "in", "self", ".", "stores", ".", "items", "(", ")", ":", "\n", "            ", "filename", "=", "node", "+", "'.pkl'", "\n", "try", ":", "\n", "                ", "pickle", ".", "dump", "(", "store", ",", "open", "(", "filename", ",", "'wb'", ")", ")", "\n", "", "except", "BaseException", ":", "\n", "                ", "raise", "IOError", "(", "'Failed to pickle the store for node {}, please check that '", "\n", "'it is pickleable or remove it before saving.'", ".", "format", "(", "node", ")", ")", "\n", "", "", "os", ".", "chdir", "(", "cwd", ")", "\n", "\n", "# Save the pool itself with stores replaced with Nones", "\n", "stores", "=", "self", ".", "stores", "\n", "self", ".", "stores", "=", "dict", ".", "fromkeys", "(", "stores", ".", "keys", "(", ")", ")", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "path", ",", "self", ".", "_pkl_name", ")", "\n", "pickle", ".", "dump", "(", "self", ",", "open", "(", "filename", ",", "\"wb\"", ")", ")", "\n", "# Restore the original to the object", "\n", "self", ".", "stores", "=", "stores", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.close": [[268, 278], ["store.OutputPool.save", "store.OutputPool.stores.values", "hasattr", "store.close"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.save", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"Save and close the stores that support it.\n\n        The pool will not be usable afterwards.\n        \"\"\"", "\n", "self", ".", "save", "(", ")", "\n", "\n", "for", "store", "in", "self", ".", "stores", ".", "values", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "store", ",", "'close'", ")", ":", "\n", "                ", "store", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.flush": [[279, 287], ["store.OutputPool.stores.values", "hasattr", "store.flush"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush"], ["", "", "", "def", "flush", "(", "self", ")", ":", "\n", "        ", "\"\"\"Flush all data from the stores.\n\n        If the store does not support flushing, do nothing.\n        \"\"\"", "\n", "for", "store", "in", "self", ".", "stores", ".", "values", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "store", ",", "'flush'", ")", ":", "\n", "                ", "store", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.delete": [[288, 300], ["store.OutputPool.stores.values", "shutil.rmtree", "hasattr", "store.close", "os.path.exists"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "", "", "def", "delete", "(", "self", ")", ":", "\n", "        ", "\"\"\"Remove all persisted data from disk.\"\"\"", "\n", "for", "store", "in", "self", ".", "stores", ".", "values", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "store", ",", "'close'", ")", ":", "\n", "                ", "store", ".", "close", "(", ")", "\n", "\n", "", "", "if", "self", ".", "path", "is", "None", ":", "\n", "            ", "return", "\n", "", "elif", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "path", ")", ":", "\n", "            ", "return", "\n", "\n", "", "shutil", ".", "rmtree", "(", "self", ".", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open": [[301, 341], ["cls._make_path", "os.path.join", "pickle.load", "os.getcwd", "os.chdir", "list", "os.chdir", "pickle.load.OutputPool.open"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool._make_path", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open"], ["", "@", "classmethod", "\n", "def", "open", "(", "cls", ",", "name", ",", "prefix", "=", "None", ")", ":", "\n", "        ", "\"\"\"Open a closed or saved ArrayPool from disk.\n\n        Parameters\n        ----------\n        name : str\n        prefix : str, optional\n\n        Returns\n        -------\n        ArrayPool\n\n        \"\"\"", "\n", "prefix", "=", "prefix", "or", "_default_prefix", "\n", "path", "=", "cls", ".", "_make_path", "(", "name", ",", "prefix", ")", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "path", ",", "cls", ".", "_pkl_name", ")", "\n", "\n", "pool", "=", "pickle", ".", "load", "(", "open", "(", "filename", ",", "\"rb\"", ")", ")", "\n", "\n", "# Load the stores. Change the working directory temporarily so that pickled stores", "\n", "# can find their data dependencies even if the folder has been renamed.", "\n", "cwd", "=", "os", ".", "getcwd", "(", ")", "\n", "os", ".", "chdir", "(", "path", ")", "\n", "for", "node", "in", "list", "(", "pool", ".", "stores", ".", "keys", "(", ")", ")", ":", "\n", "            ", "filename", "=", "node", "+", "'.pkl'", "\n", "try", ":", "\n", "                ", "store", "=", "pickle", ".", "load", "(", "open", "(", "filename", ",", "'rb'", ")", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "logger", ".", "warning", "(", "'Failed to load the store for node {}. Reason: {}'", "\n", ".", "format", "(", "node", ",", "str", "(", "e", ")", ")", ")", "\n", "del", "pool", ".", "stores", "[", "node", "]", "\n", "continue", "\n", "", "pool", ".", "stores", "[", "node", "]", "=", "store", "\n", "", "os", ".", "chdir", "(", "cwd", ")", "\n", "\n", "# Update the name and prefix in case the pool folder was moved", "\n", "pool", ".", "name", "=", "name", "\n", "pool", ".", "prefix", "=", "prefix", "\n", "return", "pool", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool._make_path": [[342, 345], ["os.path.join"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_make_path", "(", "cls", ",", "name", ",", "prefix", ")", ":", "\n", "        ", "return", "os", ".", "path", ".", "join", "(", "prefix", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.path": [[346, 353], ["store.OutputPool._make_path"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool._make_path"], ["", "@", "property", "\n", "def", "path", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the path to the pool.\"\"\"", "\n", "if", "self", ".", "name", "is", "None", ":", "\n", "            ", "return", "None", "\n", "\n", "", "return", "self", ".", "_make_path", "(", "self", ".", "name", ",", "self", ".", "prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayPool._make_store_for": [[369, 378], ["os.makedirs", "os.path.join", "store.NpyStore", "ValueError"], "methods", ["None"], ["def", "_make_store_for", "(", "self", ",", "node", ")", ":", "\n", "        ", "if", "not", "self", ".", "has_context", ":", "\n", "            ", "raise", "ValueError", "(", "'ArrayPool has no context set'", ")", "\n", "\n", "# Make the directory for the array pools", "\n", "", "os", ".", "makedirs", "(", "self", ".", "path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "path", ",", "node", ")", "\n", "return", "NpyStore", "(", "filename", ",", "self", ".", "batch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.StoreBase.__getitem__": [[392, 395], ["None"], "methods", ["None"], ["def", "__getitem__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Return a batch from location `batch_index`.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.StoreBase.__setitem__": [[396, 399], ["None"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "batch_index", ",", "data", ")", ":", "\n", "        ", "\"\"\"Set array to `data` at location `batch_index`.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.StoreBase.__delitem__": [[400, 403], ["None"], "methods", ["None"], ["", "def", "__delitem__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Delete data from location `batch_index`.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.StoreBase.__contains__": [[404, 407], ["None"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Check if array contains `batch_index`.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.StoreBase.__len__": [[408, 411], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of batches in the store.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.StoreBase.clear": [[412, 415], ["None"], "methods", ["None"], ["", "def", "clear", "(", "self", ")", ":", "\n", "        ", "\"\"\"Remove all batches from the store.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.StoreBase.close": [[416, 422], ["None"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close the store.\n\n        Optional method. Useful for closing i.e. file streams.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.StoreBase.flush": [[423, 429], ["None"], "methods", ["None"], ["", "def", "flush", "(", "self", ")", ":", "\n", "        ", "\"\"\"Flush the store.\n\n        Optional to implement.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.__init__": [[450, 472], ["logger.warning", "len", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "array", ",", "batch_size", ",", "n_batches", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\"Initialize ArrayStore.\n\n        Parameters\n        ----------\n        array\n            Any array like object supporting Python list indexing\n        batch_size : int\n            Size of a batch of data\n        n_batches : int, optional\n            How many batches should be made available from the array. Default is -1\n            meaning all available batches.\n\n        \"\"\"", "\n", "if", "n_batches", "==", "-", "1", ":", "\n", "            ", "if", "len", "(", "array", ")", "%", "batch_size", "!=", "0", ":", "\n", "                ", "logger", ".", "warning", "(", "\"The array length is not divisible by the batch size.\"", ")", "\n", "", "n_batches", "=", "len", "(", "array", ")", "//", "batch_size", "\n", "\n", "", "self", ".", "array", "=", "array", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "n_batches", "=", "n_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.__getitem__": [[473, 477], ["store.ArrayStore._to_slice"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore._to_slice"], ["", "def", "__getitem__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Return a batch from location `batch_index`.\"\"\"", "\n", "sl", "=", "self", ".", "_to_slice", "(", "batch_index", ")", "\n", "return", "self", ".", "array", "[", "sl", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.__setitem__": [[478, 492], ["store.ArrayStore._to_slice", "IndexError", "len", "IndexError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore._to_slice"], ["", "def", "__setitem__", "(", "self", ",", "batch_index", ",", "data", ")", ":", "\n", "        ", "\"\"\"Set array to `data` at location `batch_index`.\"\"\"", "\n", "if", "batch_index", ">", "self", ".", "n_batches", ":", "\n", "            ", "raise", "IndexError", "(", "\"Appending further than to the end of the store array is \"", "\n", "\"currently not supported.\"", ")", "\n", "\n", "", "sl", "=", "self", ".", "_to_slice", "(", "batch_index", ")", "\n", "if", "sl", ".", "stop", ">", "len", "(", "self", ".", "array", ")", ":", "\n", "            ", "raise", "IndexError", "(", "\"There is not enough space left in the store array.\"", ")", "\n", "\n", "", "self", ".", "array", "[", "sl", "]", "=", "data", "\n", "\n", "if", "batch_index", "==", "self", ".", "n_batches", ":", "\n", "            ", "self", ".", "n_batches", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.__contains__": [[493, 496], ["None"], "methods", ["None"], ["", "", "def", "__contains__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Check if array contains `batch_index`.\"\"\"", "\n", "return", "batch_index", "<", "self", ".", "n_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.__delitem__": [[497, 509], ["IndexError", "IndexError"], "methods", ["None"], ["", "def", "__delitem__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Delete data from location `batch_index`.\"\"\"", "\n", "if", "batch_index", "not", "in", "self", ":", "\n", "            ", "raise", "IndexError", "(", "\"Cannot remove, batch index {} is not in the array\"", "\n", ".", "format", "(", "batch_index", ")", ")", "\n", "", "elif", "batch_index", "!=", "self", ".", "n_batches", "-", "1", ":", "\n", "            ", "raise", "IndexError", "(", "\"Removing batches from the middle of the store array is \"", "\n", "\"currently not supported.\"", ")", "\n", "\n", "# Move the n_batches index down", "\n", "", "if", "batch_index", "==", "self", ".", "n_batches", "-", "1", ":", "\n", "            ", "self", ".", "n_batches", "-=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.__len__": [[510, 513], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of batches in store.\"\"\"", "\n", "return", "self", ".", "n_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore._to_slice": [[514, 518], ["slice"], "methods", ["None"], ["", "def", "_to_slice", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Return a slice object that covers the batch at `batch_index`.\"\"\"", "\n", "a", "=", "self", ".", "batch_size", "*", "batch_index", "\n", "return", "slice", "(", "a", ",", "a", "+", "self", ".", "batch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.clear": [[519, 524], ["hasattr", "store.ArrayStore.array.clear"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear"], ["", "def", "clear", "(", "self", ")", ":", "\n", "        ", "\"\"\"Clear array from store.\"\"\"", "\n", "if", "hasattr", "(", "self", ".", "array", ",", "'clear'", ")", ":", "\n", "            ", "self", ".", "array", ".", "clear", "(", ")", "\n", "", "self", ".", "n_batches", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.flush": [[525, 529], ["hasattr", "store.ArrayStore.array.flush"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush"], ["", "def", "flush", "(", "self", ")", ":", "\n", "        ", "\"\"\"Flush any changes in memory to array.\"\"\"", "\n", "if", "hasattr", "(", "self", ".", "array", ",", "'flush'", ")", ":", "\n", "            ", "self", ".", "array", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.close": [[530, 534], ["hasattr", "store.ArrayStore.array.close"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close array.\"\"\"", "\n", "if", "hasattr", "(", "self", ".", "array", ",", "'close'", ")", ":", "\n", "            ", "self", ".", "array", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore.__del__": [[535, 538], ["store.ArrayStore.close"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close array.\"\"\"", "\n", "self", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyStore.__init__": [[546, 561], ["store.ArrayStore.__init__", "isinstance", "store.NpyArray"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "file", ",", "batch_size", ",", "n_batches", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\"Initialize NpyStore.\n\n        Parameters\n        ----------\n        file : NpyArray or str\n            NpyArray object or path to the .npy file\n        batch_size\n        n_batches : int, optional\n            How many batches to make available from the file. Default -1 indicates that\n            all available batches.\n\n        \"\"\"", "\n", "array", "=", "file", "if", "isinstance", "(", "file", ",", "NpyArray", ")", "else", "NpyArray", "(", "file", ")", "\n", "super", "(", "NpyStore", ",", "self", ")", ".", "__init__", "(", "array", ",", "batch_size", ",", "n_batches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyStore.__setitem__": [[562, 572], ["store.NpyStore._to_slice", "store.ArrayStore.__setitem__", "store.NpyStore.array.append", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore._to_slice", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.__setitem__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "__setitem__", "(", "self", ",", "batch_index", ",", "data", ")", ":", "\n", "        ", "\"\"\"Set array to `data` at location `batch_index`.\"\"\"", "\n", "sl", "=", "self", ".", "_to_slice", "(", "batch_index", ")", "\n", "# NpyArray supports appending", "\n", "if", "batch_index", "==", "self", ".", "n_batches", "and", "sl", ".", "start", "==", "len", "(", "self", ".", "array", ")", ":", "\n", "            ", "self", ".", "array", ".", "append", "(", "data", ")", "\n", "self", ".", "n_batches", "+=", "1", "\n", "return", "\n", "\n", "", "super", "(", "NpyStore", ",", "self", ")", ".", "__setitem__", "(", "batch_index", ",", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyStore.__delitem__": [[573, 578], ["store.ArrayStore.__delitem__", "store.NpyStore._to_slice", "store.NpyStore.array.truncate"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyStore.__delitem__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.ArrayStore._to_slice", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.truncate"], ["", "def", "__delitem__", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Delete data from location `batch_index`.\"\"\"", "\n", "super", "(", "NpyStore", ",", "self", ")", ".", "__delitem__", "(", "batch_index", ")", "\n", "sl", "=", "self", ".", "_to_slice", "(", "batch_index", ")", "\n", "self", ".", "array", ".", "truncate", "(", "sl", ".", "start", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyStore.delete": [[579, 582], ["store.NpyStore.array.delete"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.delete"], ["", "def", "delete", "(", "self", ")", ":", "\n", "        ", "\"\"\"Delete array.\"\"\"", "\n", "self", ".", "array", ".", "delete", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.__init__": [[604, 650], ["os.path.exists", "open", "store.NpyArray._init_from_file_header", "open", "store.NpyArray.append", "store.NpyArray.flush"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._init_from_file_header", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush"], ["def", "__init__", "(", "self", ",", "filename", ",", "array", "=", "None", ",", "truncate", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialize NpyArray.\n\n        Parameters\n        ----------\n        filename : str\n            File name\n        array : ndarray, optional\n            Initial array\n        truncate : bool\n            Whether to truncate the file or not\n\n        \"\"\"", "\n", "self", ".", "header_length", "=", "None", "\n", "self", ".", "itemsize", "=", "None", "\n", "\n", "# Header data fields", "\n", "self", ".", "shape", "=", "None", "\n", "self", ".", "fortran_order", "=", "False", "\n", "self", ".", "dtype", "=", "None", "\n", "\n", "# The header bytes must be prepared in advance, because there is an import in", "\n", "# `numpy.lib.format._write_array_header` (1.11.3) that fails if the program is", "\n", "# being closed on exception and would corrupt the .npy file.", "\n", "self", ".", "_header_bytes_to_write", "=", "None", "\n", "\n", "if", "filename", "[", "-", "4", ":", "]", "!=", "'.npy'", ":", "\n", "            ", "filename", "+=", "'.npy'", "\n", "", "self", ".", "filename", "=", "filename", "\n", "\n", "if", "array", "is", "not", "None", ":", "\n", "            ", "truncate", "=", "True", "\n", "\n", "", "self", ".", "fs", "=", "None", "\n", "if", "truncate", "is", "False", "and", "os", ".", "path", ".", "exists", "(", "self", ".", "filename", ")", ":", "\n", "            ", "self", ".", "fs", "=", "open", "(", "self", ".", "filename", ",", "'r+b'", ")", "\n", "self", ".", "_init_from_file_header", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fs", "=", "open", "(", "self", ".", "filename", ",", "'w+b'", ")", "\n", "\n", "# Numpy memmap for the file array data", "\n", "", "self", ".", "_memmap", "=", "None", "\n", "\n", "if", "array", "is", "not", "None", ":", "\n", "            ", "self", ".", "append", "(", "array", ")", "\n", "self", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.__getitem__": [[651, 654], ["None"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "sl", ")", ":", "\n", "        ", "\"\"\"Return a slice `sl` of data.\"\"\"", "\n", "return", "self", ".", "memmap", "[", "sl", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.__setitem__": [[655, 658], ["None"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "sl", ",", "value", ")", ":", "\n", "        ", "\"\"\"Set data at slice `sl` to `value`.\"\"\"", "\n", "self", ".", "memmap", "[", "sl", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.__len__": [[659, 662], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the length of array.\"\"\"", "\n", "return", "self", ".", "shape", "[", "0", "]", "if", "self", ".", "shape", "else", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.size": [[663, 667], ["numpy.prod", "numpy.prod"], "methods", ["None"], ["", "@", "property", "\n", "def", "size", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of items in the array.\"\"\"", "\n", "return", "np", ".", "prod", "(", "self", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append": [[668, 692], ["store.NpyArray.fs.seek", "store.NpyArray.fs.write", "store.NpyArray._prepare_header_data", "ValueError", "store.NpyArray.init_from_array", "ValueError", "array.tobytes", "ValueError", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._prepare_header_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.init_from_array"], ["", "def", "append", "(", "self", ",", "array", ")", ":", "\n", "        ", "\"\"\"Append data from `array` to self.\"\"\"", "\n", "if", "self", ".", "closed", ":", "\n", "            ", "raise", "ValueError", "(", "'Array is not opened.'", ")", "\n", "\n", "", "if", "not", "self", ".", "initialized", ":", "\n", "            ", "self", ".", "init_from_array", "(", "array", ")", "\n", "\n", "", "if", "array", ".", "shape", "[", "1", ":", "]", "!=", "self", ".", "shape", "[", "1", ":", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Appended array is of different shape.\"", ")", "\n", "", "elif", "array", ".", "dtype", "!=", "self", ".", "dtype", ":", "\n", "            ", "raise", "ValueError", "(", "\"Appended array is of different dtype.\"", ")", "\n", "\n", "# Append new data", "\n", "", "pos", "=", "self", ".", "header_length", "+", "self", ".", "size", "*", "self", ".", "itemsize", "\n", "self", ".", "fs", ".", "seek", "(", "pos", ")", "\n", "self", ".", "fs", ".", "write", "(", "array", ".", "tobytes", "(", "'C'", ")", ")", "\n", "self", ".", "shape", "=", "(", "self", ".", "shape", "[", "0", "]", "+", "len", "(", "array", ")", ",", ")", "+", "self", ".", "shape", "[", "1", ":", "]", "\n", "\n", "# Only prepare the header bytes, need to be flushed to take effect", "\n", "self", ".", "_prepare_header_data", "(", ")", "\n", "\n", "# Invalidate the memmap", "\n", "self", ".", "_memmap", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.memmap": [[693, 704], ["IndexError", "numpy.memmap", "numpy.memmap"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.memmap", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.memmap"], ["", "@", "property", "\n", "def", "memmap", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a NumPy memory map to the array data.\"\"\"", "\n", "if", "not", "self", ".", "initialized", ":", "\n", "            ", "raise", "IndexError", "(", "\"NpyArray is not initialized\"", ")", "\n", "\n", "", "if", "self", ".", "_memmap", "is", "None", ":", "\n", "            ", "order", "=", "'F'", "if", "self", ".", "fortran_order", "else", "'C'", "\n", "self", ".", "_memmap", "=", "np", ".", "memmap", "(", "self", ".", "fs", ",", "dtype", "=", "self", ".", "dtype", ",", "shape", "=", "self", ".", "shape", ",", "\n", "offset", "=", "self", ".", "header_length", ",", "order", "=", "order", ")", "\n", "", "return", "self", ".", "_memmap", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._init_from_file_header": [[705, 724], ["store.NpyArray.fs.seek", "store.NpyArray.fs.tell", "numpy.read_array_header_2_0", "numpy.read_array_header_2_0", "ValueError", "numpy.empty", "numpy.empty", "ValueError"], "methods", ["None"], ["", "def", "_init_from_file_header", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the object from an existing file.\"\"\"", "\n", "self", ".", "fs", ".", "seek", "(", "self", ".", "HEADER_DATA_SIZE_OFFSET", ")", "\n", "try", ":", "\n", "            ", "self", ".", "shape", ",", "fortran_order", ",", "self", ".", "dtype", "=", "npformat", ".", "read_array_header_2_0", "(", "self", ".", "fs", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "raise", "ValueError", "(", "'Npy file {} header is not 2.0 format. You can make the '", "\n", "'conversion using elfi.store.NpyFile by passing the '", "\n", "'preloaded array as an argument.'", ".", "format", "(", "self", ".", "filename", ")", ")", "\n", "", "self", ".", "header_length", "=", "self", ".", "fs", ".", "tell", "(", ")", "\n", "\n", "if", "fortran_order", ":", "\n", "            ", "raise", "ValueError", "(", "'Column major (Fortran-style) files are not supported. Please'", "\n", "'translate if first to row major (C-style).'", ")", "\n", "\n", "# Determine itemsize", "\n", "", "shape", "=", "(", "0", ",", ")", "+", "self", ".", "shape", "[", "1", ":", "]", "\n", "self", ".", "itemsize", "=", "np", ".", "empty", "(", "shape", "=", "shape", ",", "dtype", "=", "self", ".", "dtype", ")", ".", "itemsize", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.init_from_array": [[725, 763], ["numpy.header_data_from_array_1_0", "numpy.header_data_from_array_1_0", "io.BytesIO", "numpy.write_array_header_2_0", "numpy.write_array_header_2_0", "io.BytesIO.tell", "store.NpyArray.fs.seek", "io.BytesIO.seek", "store.NpyArray.fs.write", "store.NpyArray._prepare_header_data", "store.NpyArray._write_header_data", "ValueError", "io.BytesIO.read"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._prepare_header_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._write_header_data"], ["", "def", "init_from_array", "(", "self", ",", "array", ")", ":", "\n", "        ", "\"\"\"Initialize the object from an array.\n\n        Sets the the header_length so large that it is possible to append to the array.\n\n        Returns\n        -------\n        h_bytes : io.BytesIO\n            Contains the oversized header bytes\n\n        \"\"\"", "\n", "if", "self", ".", "initialized", ":", "\n", "            ", "raise", "ValueError", "(", "\"The array has been initialized already!\"", ")", "\n", "\n", "", "self", ".", "shape", "=", "(", "0", ",", ")", "+", "array", ".", "shape", "[", "1", ":", "]", "\n", "self", ".", "dtype", "=", "array", ".", "dtype", "\n", "self", ".", "itemsize", "=", "array", ".", "itemsize", "\n", "\n", "# Read header data from array and set modify it to be large for the length", "\n", "# 1_0 is the same for 2_0", "\n", "d", "=", "npformat", ".", "header_data_from_array_1_0", "(", "array", ")", "\n", "d", "[", "'shape'", "]", "=", "(", "self", ".", "MAX_SHAPE_LEN", ",", ")", "+", "d", "[", "'shape'", "]", "[", "1", ":", "]", "\n", "d", "[", "'fortran_order'", "]", "=", "False", "\n", "\n", "# Write a prefix for a very long array to make it large enough for appending new", "\n", "# data", "\n", "h_bytes", "=", "io", ".", "BytesIO", "(", ")", "\n", "npformat", ".", "write_array_header_2_0", "(", "h_bytes", ",", "d", ")", "\n", "self", ".", "header_length", "=", "h_bytes", ".", "tell", "(", ")", "\n", "\n", "# Write header prefix to file", "\n", "self", ".", "fs", ".", "seek", "(", "0", ")", "\n", "h_bytes", ".", "seek", "(", "0", ")", "\n", "self", ".", "fs", ".", "write", "(", "h_bytes", ".", "read", "(", "self", ".", "HEADER_DATA_OFFSET", ")", ")", "\n", "\n", "# Write header data for the zero length to make it a valid file", "\n", "self", ".", "_prepare_header_data", "(", ")", "\n", "self", ".", "_write_header_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.truncate": [[764, 789], ["store.NpyArray._prepare_header_data", "store.NpyArray.fs.seek", "store.NpyArray.fs.truncate", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._prepare_header_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.truncate"], ["", "def", "truncate", "(", "self", ",", "length", "=", "0", ")", ":", "\n", "        ", "\"\"\"Truncate the array to the specified length.\n\n        Parameters\n        ----------\n        length : int\n            Length (=`shape[0]`) of the array to truncate to. Default 0.\n\n        \"\"\"", "\n", "if", "not", "self", ".", "initialized", ":", "\n", "            ", "raise", "ValueError", "(", "'The array must be initialized before it can be truncated. '", "\n", "'Please see init_from_array.'", ")", "\n", "\n", "", "if", "self", ".", "closed", ":", "\n", "            ", "raise", "ValueError", "(", "'The array has been closed.'", ")", "\n", "\n", "# Reset length", "\n", "", "self", ".", "shape", "=", "(", "length", ",", ")", "+", "self", ".", "shape", "[", "1", ":", "]", "\n", "self", ".", "_prepare_header_data", "(", ")", "\n", "\n", "self", ".", "fs", ".", "seek", "(", "self", ".", "header_length", "+", "self", ".", "size", "*", "self", ".", "itemsize", ")", "\n", "self", ".", "fs", ".", "truncate", "(", ")", "\n", "\n", "# Invalidate the memmap", "\n", "self", ".", "_memmap", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close": [[790, 797], ["store.NpyArray._write_header_data", "store.NpyArray.fs.close"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._write_header_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close the file.\"\"\"", "\n", "if", "self", ".", "initialized", ":", "\n", "            ", "self", ".", "_write_header_data", "(", ")", "\n", "self", ".", "fs", ".", "close", "(", ")", "\n", "# Invalidate the memmap", "\n", "self", ".", "_memmap", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear": [[798, 801], ["store.NpyArray.truncate"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.truncate"], ["", "", "def", "clear", "(", "self", ")", ":", "\n", "        ", "\"\"\"Truncate the array to 0.\"\"\"", "\n", "self", ".", "truncate", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.delete": [[802, 813], ["store.NpyArray.close", "os.remove"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "def", "delete", "(", "self", ")", ":", "\n", "        ", "\"\"\"Remove the file and invalidate this array.\"\"\"", "\n", "if", "self", ".", "deleted", ":", "\n", "            ", "return", "\n", "", "name", "=", "self", ".", "fs", ".", "name", "\n", "self", ".", "close", "(", ")", "\n", "os", ".", "remove", "(", "name", ")", "\n", "self", ".", "fs", "=", "None", "\n", "self", ".", "header_length", "=", "None", "\n", "# Invalidate the memmap", "\n", "self", ".", "_memmap", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush": [[814, 818], ["store.NpyArray._write_header_data", "store.NpyArray.fs.flush"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._write_header_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush"], ["", "def", "flush", "(", "self", ")", ":", "\n", "        ", "\"\"\"Flush any changes in memory to array.\"\"\"", "\n", "self", ".", "_write_header_data", "(", ")", "\n", "self", ".", "fs", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.__del__": [[819, 822], ["store.NpyArray.close"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close the array.\"\"\"", "\n", "self", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._prepare_header_data": [[823, 844], ["io.BytesIO", "numpy.write_array_header_2_0", "numpy.write_array_header_2_0", "io.BytesIO.seek", "io.BytesIO.read", "numpy.dtype_to_descr", "numpy.dtype_to_descr", "io.BytesIO.tell", "OverflowError", "io.BytesIO.write"], "methods", ["None"], ["", "def", "_prepare_header_data", "(", "self", ")", ":", "\n", "# Make header data", "\n", "        ", "d", "=", "{", "\n", "'shape'", ":", "self", ".", "shape", ",", "\n", "'fortran_order'", ":", "self", ".", "fortran_order", ",", "\n", "'descr'", ":", "npformat", ".", "dtype_to_descr", "(", "self", ".", "dtype", ")", "\n", "}", "\n", "\n", "h_bytes", "=", "io", ".", "BytesIO", "(", ")", "\n", "npformat", ".", "write_array_header_2_0", "(", "h_bytes", ",", "d", ")", "\n", "\n", "# Pad the end of the header", "\n", "fill_len", "=", "self", ".", "header_length", "-", "h_bytes", ".", "tell", "(", ")", "\n", "if", "fill_len", "<", "0", ":", "\n", "            ", "raise", "OverflowError", "(", "\n", "\"File {} cannot be appended. The header is too short.\"", ".", "format", "(", "self", ".", "filename", ")", ")", "\n", "", "elif", "fill_len", ">", "0", ":", "\n", "            ", "h_bytes", ".", "write", "(", "b'\\x20'", "*", "fill_len", ")", "\n", "\n", "", "h_bytes", ".", "seek", "(", "0", ")", "\n", "self", ".", "_header_bytes_to_write", "=", "h_bytes", ".", "read", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray._write_header_data": [[845, 856], ["store.NpyArray.fs.seek", "store.NpyArray.fs.write"], "methods", ["None"], ["", "def", "_write_header_data", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "_header_bytes_to_write", ":", "\n", "            ", "return", "\n", "\n", "# Rewrite header data", "\n", "", "self", ".", "fs", ".", "seek", "(", "self", ".", "HEADER_DATA_OFFSET", ")", "\n", "h_bytes", "=", "self", ".", "_header_bytes_to_write", "[", "self", ".", "HEADER_DATA_OFFSET", ":", "]", "\n", "self", ".", "fs", ".", "write", "(", "h_bytes", ")", "\n", "\n", "# Flag bytes off as they are now written", "\n", "self", ".", "_header_bytes_to_write", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.deleted": [[857, 861], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "deleted", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check whether file has been deleted.\"\"\"", "\n", "return", "self", ".", "fs", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.closed": [[862, 866], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "closed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check if file has been deleted or closed.\"\"\"", "\n", "return", "self", ".", "deleted", "or", "self", ".", "fs", ".", "closed", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.initialized": [[867, 871], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "initialized", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check if file is open.\"\"\"", "\n", "return", "(", "not", "self", ".", "closed", ")", "and", "(", "self", ".", "header_length", "is", "not", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.__getstate__": [[872, 877], ["store.NpyArray.flush"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.flush"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a dictionary with a key `filename`.\"\"\"", "\n", "if", "not", "self", ".", "fs", ".", "closed", ":", "\n", "            ", "self", ".", "flush", "(", ")", "\n", "", "return", "{", "'filename'", ":", "self", ".", "filename", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.__setstate__": [[878, 889], ["state.pop", "os.path.basename", "os.path.exists", "store.NpyArray.__init__", "os.path.exists", "store.NpyArray.__init__", "FileNotFoundError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "\"\"\"Initialize with `filename` from dictionary `state`.\"\"\"", "\n", "filename", "=", "state", ".", "pop", "(", "'filename'", ")", "\n", "basename", "=", "os", ".", "path", ".", "basename", "(", "filename", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "filename", ")", ":", "\n", "            ", "self", ".", "__init__", "(", "filename", ")", "\n", "", "elif", "os", ".", "path", ".", "exists", "(", "basename", ")", ":", "\n", "            ", "self", ".", "__init__", "(", "basename", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fs", "=", "None", "\n", "raise", "FileNotFoundError", "(", "'Could not find the file {}'", ".", "format", "(", "filename", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.nx_draw": [[11, 72], ["isinstance", "Digraph", "set", "G.nodes_iter", "G.edges_iter", "isinstance", "state.get", "Digraph.node", "Digraph.edge", "Digraph.render", "ImportError", "set.add", "str", "state.get"], "function", ["None"], ["def", "nx_draw", "(", "G", ",", "internal", "=", "False", ",", "param_names", "=", "False", ",", "filename", "=", "None", ",", "format", "=", "None", ")", ":", "\n", "    ", "\"\"\"Draw the `ElfiModel`.\n\n    Parameters\n    ----------\n    G : nx.DiGraph or ElfiModel\n        Graph or model to draw\n    internal : boolean, optional\n        Whether to draw internal nodes (starting with an underscore)\n    param_names : bool, optional\n        Show param names on edges\n    filename : str, optional\n        If given, save the dot file into the given filename.\n    format : str, optional\n        format of the file\n\n    Notes\n    -----\n    Requires the optional 'graphviz' library.\n\n    Returns\n    -------\n    dot\n        A GraphViz dot representation of the model.\n\n    \"\"\"", "\n", "try", ":", "\n", "        ", "from", "graphviz", "import", "Digraph", "\n", "", "except", "ImportError", ":", "\n", "        ", "raise", "ImportError", "(", "\"The graphviz library is required for this feature.\"", ")", "\n", "\n", "", "if", "isinstance", "(", "G", ",", "ElfiModel", ")", ":", "\n", "        ", "G", "=", "G", ".", "source_net", "\n", "", "elif", "isinstance", "(", "G", ",", "NodeReference", ")", ":", "\n", "        ", "G", "=", "G", ".", "model", ".", "source_net", "\n", "\n", "", "dot", "=", "Digraph", "(", "format", "=", "format", ")", "\n", "\n", "hidden", "=", "set", "(", ")", "\n", "\n", "for", "n", ",", "state", "in", "G", ".", "nodes_iter", "(", "data", "=", "True", ")", ":", "\n", "        ", "if", "not", "internal", "and", "n", "[", "0", "]", "==", "'_'", "and", "state", ".", "get", "(", "'_class'", ")", "==", "Constant", ":", "\n", "            ", "hidden", ".", "add", "(", "n", ")", "\n", "continue", "\n", "", "_format", "=", "{", "'shape'", ":", "'circle'", ",", "'fillcolor'", ":", "'gray80'", ",", "'style'", ":", "'solid'", "}", "\n", "if", "state", ".", "get", "(", "'_observable'", ")", ":", "\n", "            ", "_format", "[", "'style'", "]", "=", "'filled'", "\n", "", "dot", ".", "node", "(", "n", ",", "**", "_format", ")", "\n", "\n", "# add edges to graph", "\n", "", "for", "u", ",", "v", ",", "label", "in", "G", ".", "edges_iter", "(", "data", "=", "'param'", ",", "default", "=", "''", ")", ":", "\n", "        ", "if", "not", "internal", "and", "u", "in", "hidden", ":", "\n", "            ", "continue", "\n", "\n", "", "label", "=", "label", "if", "param_names", "else", "''", "\n", "dot", ".", "edge", "(", "u", ",", "v", ",", "str", "(", "label", ")", ")", "\n", "\n", "", "if", "filename", "is", "not", "None", ":", "\n", "        ", "dot", ".", "render", "(", "filename", ")", "\n", "\n", "", "return", "dot", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._create_axes": [[74, 104], ["kwargs.get", "numpy.atleast_2d", "matplotlib.subplots", "numpy.atleast_2d", "fig.tight_layout", "kwargs.keys", "kwargs.pop"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["", "def", "_create_axes", "(", "axes", ",", "shape", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Check the axes and create them if necessary.\n\n    Parameters\n    ----------\n    axes : plt.Axes or arraylike of plt.Axes\n    shape : tuple of int\n        (x,) or (x,y)\n    kwargs\n\n    Returns\n    -------\n    axes : np.array of plt.Axes\n    kwargs : dict\n        Input kwargs without items related to creating a figure.\n\n    \"\"\"", "\n", "fig_kwargs", "=", "{", "}", "\n", "kwargs", "[", "'figsize'", "]", "=", "kwargs", ".", "get", "(", "'figsize'", ",", "(", "16", ",", "4", "*", "shape", "[", "0", "]", ")", ")", "\n", "for", "k", "in", "[", "'figsize'", ",", "'sharex'", ",", "'sharey'", ",", "'dpi'", ",", "'num'", "]", ":", "\n", "        ", "if", "k", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "fig_kwargs", "[", "k", "]", "=", "kwargs", ".", "pop", "(", "k", ")", "\n", "\n", "", "", "if", "axes", "is", "not", "None", ":", "\n", "        ", "axes", "=", "np", ".", "atleast_2d", "(", "axes", ")", "\n", "", "else", ":", "\n", "        ", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "ncols", "=", "shape", "[", "1", "]", ",", "nrows", "=", "shape", "[", "0", "]", ",", "**", "fig_kwargs", ")", "\n", "axes", "=", "np", ".", "atleast_2d", "(", "axes", ")", "\n", "fig", ".", "tight_layout", "(", "pad", "=", "2.0", ")", "\n", "", "return", "axes", ",", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._limit_params": [[106, 128], ["collections.OrderedDict", "enumerate"], "function", ["None"], ["", "def", "_limit_params", "(", "samples", ",", "selector", "=", "None", ")", ":", "\n", "    ", "\"\"\"Pick only the selected parameters from all samples.\n\n    Parameters\n    ----------\n    samples : OrderedDict of np.arrays\n    selector : iterable of ints or strings, optional\n        Indices or keys to use from samples. Default to all.\n\n    Returns\n    -------\n    selected : OrderedDict of np.arrays\n\n    \"\"\"", "\n", "if", "selector", "is", "None", ":", "\n", "        ", "return", "samples", "\n", "", "else", ":", "\n", "        ", "selected", "=", "OrderedDict", "(", ")", "\n", "for", "ii", ",", "k", "in", "enumerate", "(", "samples", ")", ":", "\n", "            ", "if", "ii", "in", "selector", "or", "k", "in", "selector", ":", "\n", "                ", "selected", "[", "k", "]", "=", "samples", "[", "k", "]", "\n", "", "", "return", "selected", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.plot_marginals": [[130, 158], ["kwargs.pop", "visualization._limit_params", "visualization._create_axes", "axes.ravel.ravel", "enumerate", "len", "max", "min", "_limit_params.keys", "axes[].hist", "axes[].set_xlabel", "len", "_limit_params.keys", "len", "_limit_params.keys", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._limit_params", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._create_axes"], ["", "", "def", "plot_marginals", "(", "samples", ",", "selector", "=", "None", ",", "bins", "=", "20", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot marginal distributions for parameters.\n\n    Parameters\n    ----------\n    samples : OrderedDict of np.arrays\n    selector : iterable of ints or strings, optional\n        Indices or keys to use from samples. Default to all.\n    bins : int, optional\n        Number of bins in histogram.\n    axes : one or an iterable of plt.Axes, optional\n\n    Returns\n    -------\n    axes : np.array of plt.Axes\n\n    \"\"\"", "\n", "ncols", "=", "len", "(", "samples", ".", "keys", "(", ")", ")", "if", "len", "(", "samples", ".", "keys", "(", ")", ")", ">", "5", "else", "5", "\n", "ncols", "=", "kwargs", ".", "pop", "(", "'ncols'", ",", "ncols", ")", "\n", "samples", "=", "_limit_params", "(", "samples", ",", "selector", ")", "\n", "shape", "=", "(", "max", "(", "1", ",", "len", "(", "samples", ")", "//", "ncols", ")", ",", "min", "(", "len", "(", "samples", ")", ",", "ncols", ")", ")", "\n", "axes", ",", "kwargs", "=", "_create_axes", "(", "axes", ",", "shape", ",", "**", "kwargs", ")", "\n", "axes", "=", "axes", ".", "ravel", "(", ")", "\n", "for", "idx", ",", "key", "in", "enumerate", "(", "samples", ".", "keys", "(", ")", ")", ":", "\n", "        ", "axes", "[", "idx", "]", ".", "hist", "(", "samples", "[", "key", "]", ",", "bins", "=", "bins", ",", "**", "kwargs", ")", "\n", "axes", "[", "idx", "]", ".", "set_xlabel", "(", "key", ")", "\n", "\n", "", "return", "axes", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.plot_pairs": [[160, 211], ["visualization._limit_params", "kwargs.pop", "kwargs.pop", "visualization._create_axes", "enumerate", "len", "len", "samples[].min", "samples[].max", "enumerate", "axes[].set_ylabel", "axes[].set_xlabel", "numpy.histogram", "axes[].bar", "axes[].scatter", "hist.max", "hist.min", "hist.min"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._limit_params", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._create_axes"], ["", "def", "plot_pairs", "(", "samples", ",", "selector", "=", "None", ",", "bins", "=", "20", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot pairwise relationships as a matrix with marginals on the diagonal.\n\n    The y-axis of marginal histograms are scaled.\n\n    Parameters\n    ----------\n    samples : OrderedDict of np.arrays\n    selector : iterable of ints or strings, optional\n        Indices or keys to use from samples. Default to all.\n    bins : int, optional\n        Number of bins in histograms.\n    axes : one or an iterable of plt.Axes, optional\n\n    Returns\n    -------\n    axes : np.array of plt.Axes\n\n    \"\"\"", "\n", "samples", "=", "_limit_params", "(", "samples", ",", "selector", ")", "\n", "shape", "=", "(", "len", "(", "samples", ")", ",", "len", "(", "samples", ")", ")", "\n", "edgecolor", "=", "kwargs", ".", "pop", "(", "'edgecolor'", ",", "'none'", ")", "\n", "dot_size", "=", "kwargs", ".", "pop", "(", "'s'", ",", "2", ")", "\n", "axes", ",", "kwargs", "=", "_create_axes", "(", "axes", ",", "shape", ",", "**", "kwargs", ")", "\n", "\n", "for", "idx_row", ",", "key_row", "in", "enumerate", "(", "samples", ")", ":", "\n", "        ", "min_samples", "=", "samples", "[", "key_row", "]", ".", "min", "(", ")", "\n", "max_samples", "=", "samples", "[", "key_row", "]", ".", "max", "(", ")", "\n", "for", "idx_col", ",", "key_col", "in", "enumerate", "(", "samples", ")", ":", "\n", "            ", "if", "idx_row", "==", "idx_col", ":", "\n", "# create a histogram with scaled y-axis", "\n", "                ", "hist", ",", "bin_edges", "=", "np", ".", "histogram", "(", "samples", "[", "key_row", "]", ",", "bins", "=", "bins", ")", "\n", "bar_width", "=", "bin_edges", "[", "1", "]", "-", "bin_edges", "[", "0", "]", "\n", "hist", "=", "(", "hist", "-", "hist", ".", "min", "(", ")", ")", "*", "(", "max_samples", "-", "min_samples", ")", "/", "(", "\n", "hist", ".", "max", "(", ")", "-", "hist", ".", "min", "(", ")", ")", "\n", "axes", "[", "idx_row", ",", "idx_col", "]", ".", "bar", "(", "bin_edges", "[", ":", "-", "1", "]", ",", "\n", "hist", ",", "\n", "bar_width", ",", "\n", "bottom", "=", "min_samples", ",", "\n", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "                ", "axes", "[", "idx_row", ",", "idx_col", "]", ".", "scatter", "(", "samples", "[", "key_col", "]", ",", "\n", "samples", "[", "key_row", "]", ",", "\n", "s", "=", "dot_size", ",", "\n", "edgecolor", "=", "edgecolor", ",", "\n", "**", "kwargs", ")", "\n", "\n", "", "", "axes", "[", "idx_row", ",", "0", "]", ".", "set_ylabel", "(", "key_row", ")", "\n", "axes", "[", "-", "1", ",", "idx_row", "]", ".", "set_xlabel", "(", "key_row", ")", "\n", "\n", "", "return", "axes", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.plot_traces": [[213, 251], ["visualization._limit_params", "visualization._create_axes", "enumerate", "range", "len", "axes[].set_xlabel", "range", "axes[].set_ylabel", "axes[].plot", "axes[].axvline"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._limit_params", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._create_axes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.plot"], ["", "def", "plot_traces", "(", "result", ",", "selector", "=", "None", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Trace plot for MCMC samples.\n\n    The black vertical lines indicate the used warmup.\n\n    Parameters\n    ----------\n    result : Result_BOLFI\n    selector : iterable of ints or strings, optional\n        Indices or keys to use from samples. Default to all.\n    axes : one or an iterable of plt.Axes, optional\n    kwargs\n\n    Returns\n    -------\n    axes : np.array of plt.Axes\n\n    \"\"\"", "\n", "samples_sel", "=", "_limit_params", "(", "result", ".", "samples", ",", "selector", ")", "\n", "shape", "=", "(", "len", "(", "samples_sel", ")", ",", "result", ".", "n_chains", ")", "\n", "kwargs", "[", "'sharex'", "]", "=", "'all'", "\n", "kwargs", "[", "'sharey'", "]", "=", "'row'", "\n", "axes", ",", "kwargs", "=", "_create_axes", "(", "axes", ",", "shape", ",", "**", "kwargs", ")", "\n", "\n", "i1", "=", "0", "\n", "for", "i2", ",", "k", "in", "enumerate", "(", "result", ".", "samples", ")", ":", "\n", "        ", "if", "k", "in", "samples_sel", ":", "\n", "            ", "for", "i3", "in", "range", "(", "result", ".", "n_chains", ")", ":", "\n", "                ", "axes", "[", "i1", ",", "i3", "]", ".", "plot", "(", "result", ".", "chains", "[", "i3", ",", ":", ",", "i2", "]", ",", "**", "kwargs", ")", "\n", "axes", "[", "i1", ",", "i3", "]", ".", "axvline", "(", "result", ".", "warmup", ",", "color", "=", "'black'", ")", "\n", "\n", "", "axes", "[", "i1", ",", "0", "]", ".", "set_ylabel", "(", "k", ")", "\n", "i1", "+=", "1", "\n", "\n", "", "", "for", "ii", "in", "range", "(", "result", ".", "n_chains", ")", ":", "\n", "        ", "axes", "[", "-", "1", ",", "ii", "]", ".", "set_xlabel", "(", "'Iterations in Chain {}'", ".", "format", "(", "ii", ")", ")", "\n", "\n", "", "return", "axes", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar": [[253, 281], ["int", "print", "print", "float", "str"], "function", ["None"], ["", "def", "progress_bar", "(", "iteration", ",", "total", ",", "prefix", "=", "''", ",", "suffix", "=", "''", ",", "decimals", "=", "1", ",", "length", "=", "100", ",", "fill", "=", "'\u2588'", ")", ":", "\n", "    ", "\"\"\"Progress bar for showing the inference process.\n\n    Parameters\n    ----------\n    iteration : int, required\n        Current iteration\n    total : int, required\n        Total iterations\n    prefix : str, optional\n        Prefix string\n    suffix : str, optional\n        Suffix string\n    decimals : int, optional\n        Positive number of decimals in percent complete\n    length : int, optional\n        Character length of bar\n    fill : str, optional\n        Bar fill character\n\n    \"\"\"", "\n", "if", "total", ">", "0", ":", "\n", "        ", "percent", "=", "(", "\"{0:.\"", "+", "str", "(", "decimals", ")", "+", "\"f}\"", ")", ".", "format", "(", "100", "*", "(", "iteration", "/", "float", "(", "total", ")", ")", ")", "\n", "filled_length", "=", "int", "(", "length", "*", "iteration", "//", "total", ")", "\n", "bar", "=", "fill", "*", "filled_length", "+", "'-'", "*", "(", "length", "-", "filled_length", ")", "\n", "print", "(", "'\\r%s |%s| %s%% %s'", "%", "(", "prefix", ",", "bar", ",", "percent", ",", "suffix", ")", ",", "end", "=", "'\\r'", ")", "\n", "if", "iteration", "==", "total", ":", "\n", "            ", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.plot_params_vs_node": [[283, 362], ["model.generate", "visualization._create_axes", "axes.ravel.ravel", "kwargs.pop", "len", "kwargs.pop", "kwargs.pop", "kwargs.pop", "hasattr", "func", "NotImplementedError", "len", "axes[].hist", "axes[].set_xlabel", "enumerate", "axes[].set_ylabel", "range", "axes[].scatter", "axes[].set_xlabel", "len", "len", "axes[].set_axis_off"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._create_axes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "", "", "def", "plot_params_vs_node", "(", "node", ",", "n_samples", "=", "100", ",", "func", "=", "None", ",", "seed", "=", "None", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot some realizations of parameters vs. `node`.\n\n    Useful e.g. for exploring how a summary statistic varies with parameters.\n    Currently only nodes with scalar output are supported, though a function `func` can\n    be given to reduce node output. This allows giving the simulator as the `node` and\n    applying a summarizing function without incorporating it into the ELFI graph.\n\n    If `node` is one of the model parameters, its histogram is plotted.\n\n    Parameters\n    ----------\n    node : elfi.NodeReference\n        The node which to evaluate. Its output must be scalar (shape=(batch_size,1)).\n    n_samples : int, optional\n        How many samples to plot.\n    func : callable, optional\n        A function to apply to node output.\n    seed : int, optional\n    axes : one or an iterable of plt.Axes, optional\n\n    Returns\n    -------\n    axes : np.array of plt.Axes\n\n    \"\"\"", "\n", "model", "=", "node", ".", "model", "\n", "parameters", "=", "model", ".", "parameter_names", "\n", "node_name", "=", "node", ".", "name", "\n", "\n", "if", "node_name", "in", "parameters", ":", "\n", "        ", "outputs", "=", "[", "node_name", "]", "\n", "shape", "=", "(", "1", ",", "1", ")", "\n", "bins", "=", "kwargs", ".", "pop", "(", "'bins'", ",", "20", ")", "\n", "\n", "", "else", ":", "\n", "        ", "outputs", "=", "parameters", "+", "[", "node_name", "]", "\n", "n_params", "=", "len", "(", "parameters", ")", "\n", "ncols", "=", "n_params", "if", "n_params", "<", "5", "else", "5", "\n", "ncols", "=", "kwargs", ".", "pop", "(", "'ncols'", ",", "ncols", ")", "\n", "edgecolor", "=", "kwargs", ".", "pop", "(", "'edgecolor'", ",", "'none'", ")", "\n", "dot_size", "=", "kwargs", ".", "pop", "(", "'s'", ",", "20", ")", "\n", "shape", "=", "(", "1", "+", "n_params", "//", "(", "ncols", "+", "1", ")", ",", "ncols", ")", "\n", "\n", "", "data", "=", "model", ".", "generate", "(", "batch_size", "=", "n_samples", ",", "outputs", "=", "outputs", ",", "seed", "=", "seed", ")", "\n", "\n", "if", "func", "is", "not", "None", ":", "\n", "        ", "if", "hasattr", "(", "func", ",", "'__name__'", ")", ":", "\n", "            ", "node_name", "=", "func", ".", "__name__", "\n", "", "else", ":", "\n", "            ", "node_name", "=", "'func'", "\n", "", "data", "[", "node_name", "]", "=", "func", "(", "data", "[", "node", ".", "name", "]", ")", "# leaves rest of the code unmodified", "\n", "\n", "", "if", "data", "[", "node_name", "]", ".", "shape", "!=", "(", "n_samples", ",", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"The plotted quantity must have shape ({},), was {}.\"", "\n", ".", "format", "(", "n_samples", ",", "data", "[", "node_name", "]", ".", "shape", ")", ")", "\n", "\n", "", "axes", ",", "kwargs", "=", "_create_axes", "(", "axes", ",", "shape", ",", "sharey", "=", "True", ",", "**", "kwargs", ")", "\n", "axes", "=", "axes", ".", "ravel", "(", ")", "\n", "\n", "if", "len", "(", "outputs", ")", "==", "1", ":", "\n", "        ", "axes", "[", "0", "]", ".", "hist", "(", "data", "[", "node_name", "]", ",", "bins", "=", "bins", ",", "normed", "=", "True", ")", "\n", "axes", "[", "0", "]", ".", "set_xlabel", "(", "node_name", ")", "\n", "\n", "", "else", ":", "\n", "        ", "for", "idx", ",", "key", "in", "enumerate", "(", "parameters", ")", ":", "\n", "            ", "axes", "[", "idx", "]", ".", "scatter", "(", "data", "[", "key", "]", ",", "\n", "data", "[", "node_name", "]", ",", "\n", "s", "=", "dot_size", ",", "\n", "edgecolor", "=", "edgecolor", ",", "\n", "**", "kwargs", ")", "\n", "\n", "axes", "[", "idx", "]", ".", "set_xlabel", "(", "key", ")", "\n", "", "axes", "[", "0", "]", ".", "set_ylabel", "(", "node_name", ")", "\n", "\n", "for", "idx", "in", "range", "(", "len", "(", "parameters", ")", ",", "len", "(", "axes", ")", ")", ":", "\n", "            ", "axes", "[", "idx", "]", ".", "set_axis_off", "(", ")", "\n", "\n", "", "", "return", "axes", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.plot_discrepancy": [[364, 400], ["kwargs.pop", "kwargs.get", "visualization._create_axes", "axes.ravel.ravel", "range", "range", "len", "axes[].scatter", "axes[].set_xlabel", "len", "len", "axes[].set_axis_off", "len", "axes[].set_ylabel"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._create_axes"], ["", "def", "plot_discrepancy", "(", "gp", ",", "parameter_names", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot acquired parameters vs. resulting discrepancy.\n\n    Parameters\n    ----------\n    axes : plt.Axes or arraylike of plt.Axes\n    gp : GPyRegression target model, required\n    parameter_names : dict, required\n        Parameter names from model.parameters dict('parameter_name':(lower, upper), ... )`\n\n    Returns\n    -------\n    axes : np.array of plt.Axes\n\n    \"\"\"", "\n", "n_plots", "=", "gp", ".", "input_dim", "\n", "ncols", "=", "len", "(", "gp", ".", "bounds", ")", "if", "len", "(", "gp", ".", "bounds", ")", "<", "5", "else", "5", "\n", "ncols", "=", "kwargs", ".", "pop", "(", "'ncols'", ",", "ncols", ")", "\n", "kwargs", "[", "'sharey'", "]", "=", "kwargs", ".", "get", "(", "'sharey'", ",", "True", ")", "\n", "if", "n_plots", ">", "10", ":", "\n", "        ", "shape", "=", "(", "1", "+", "(", "1", "+", "n_plots", ")", "//", "(", "ncols", "+", "1", ")", ",", "ncols", ")", "\n", "", "else", ":", "\n", "        ", "shape", "=", "(", "1", "+", "n_plots", "//", "(", "ncols", "+", "1", ")", ",", "ncols", ")", "\n", "", "axes", ",", "kwargs", "=", "_create_axes", "(", "axes", ",", "shape", ",", "**", "kwargs", ")", "\n", "axes", "=", "axes", ".", "ravel", "(", ")", "\n", "\n", "for", "ii", "in", "range", "(", "n_plots", ")", ":", "\n", "        ", "axes", "[", "ii", "]", ".", "scatter", "(", "gp", ".", "X", "[", ":", ",", "ii", "]", ",", "gp", ".", "Y", "[", ":", ",", "0", "]", ",", "**", "kwargs", ")", "\n", "axes", "[", "ii", "]", ".", "set_xlabel", "(", "parameter_names", "[", "ii", "]", ")", "\n", "if", "ii", "%", "ncols", "==", "0", ":", "\n", "            ", "axes", "[", "ii", "]", ".", "set_ylabel", "(", "'Discrepancy'", ")", "\n", "\n", "", "", "for", "idx", "in", "range", "(", "len", "(", "parameter_names", ")", ",", "len", "(", "axes", ")", ")", ":", "\n", "        ", "axes", "[", "idx", "]", ".", "set_axis_off", "(", ")", "\n", "\n", "", "return", "axes", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.plot_gp": [[402, 452], ["visualization._create_axes", "range", "range", "axes[].set_xlabel", "axes[].scatter", "axes[].set_xlim", "axes[].set_ylabel", "numpy.linspace", "numpy.linspace", "numpy.meshgrid", "numpy.tile", "x.ravel", "y.ravel", "gp.predict_mean().reshape", "axes[].contourf", "axes[].set_ylabel", "numpy.argmin", "gp.predict_mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization._create_axes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict_mean"], ["", "def", "plot_gp", "(", "gp", ",", "parameter_names", ",", "axes", "=", "None", ",", "resol", "=", "50", ",", "const", "=", "None", ",", "bounds", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot pairwise relationships as a matrix with parameters vs. discrepancy.\n\n    Parameters\n    ----------\n    gp : GPyRegression, required\n    parameter_names : list, required\n        Parameter names in format ['mu_0', 'mu_1', ..]\n    axes : plt.Axes or arraylike of plt.Axes\n    resol : int, optional\n        Resolution of the plotted grid.\n    const : np.array, optional\n        Values for parameters in plots where held constant. Defaults to minimum evidence.\n    bounds: list of tuples, optional\n        List of tuples for axis boundaries.\n\n    Returns\n    -------\n    axes : np.array of plt.Axes\n\n    \"\"\"", "\n", "n_plots", "=", "gp", ".", "input_dim", "\n", "shape", "=", "(", "n_plots", ",", "n_plots", ")", "\n", "axes", ",", "kwargs", "=", "_create_axes", "(", "axes", ",", "shape", ",", "**", "kwargs", ")", "\n", "\n", "x_evidence", "=", "gp", ".", "X", "\n", "y_evidence", "=", "gp", ".", "Y", "\n", "if", "const", "is", "None", ":", "\n", "        ", "const", "=", "x_evidence", "[", "np", ".", "argmin", "(", "y_evidence", ")", ",", ":", "]", "\n", "", "bounds", "=", "bounds", "or", "gp", ".", "bounds", "\n", "\n", "for", "ix", "in", "range", "(", "n_plots", ")", ":", "\n", "        ", "for", "jy", "in", "range", "(", "n_plots", ")", ":", "\n", "            ", "if", "ix", "==", "jy", ":", "\n", "                ", "axes", "[", "jy", ",", "ix", "]", ".", "scatter", "(", "x_evidence", "[", ":", ",", "ix", "]", ",", "y_evidence", ")", "\n", "axes", "[", "jy", ",", "ix", "]", ".", "set_xlim", "(", "bounds", "[", "ix", "]", ")", "\n", "axes", "[", "jy", ",", "ix", "]", ".", "set_ylabel", "(", "'Discrepancy'", ")", "\n", "", "else", ":", "\n", "                ", "x1", "=", "np", ".", "linspace", "(", "bounds", "[", "ix", "]", "[", "0", "]", ",", "bounds", "[", "ix", "]", "[", "1", "]", ",", "resol", ")", "\n", "y1", "=", "np", ".", "linspace", "(", "bounds", "[", "jy", "]", "[", "0", "]", ",", "bounds", "[", "jy", "]", "[", "1", "]", ",", "resol", ")", "\n", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "x1", ",", "y1", ")", "\n", "predictors", "=", "np", ".", "tile", "(", "const", ",", "(", "resol", "*", "resol", ",", "1", ")", ")", "\n", "predictors", "[", ":", ",", "ix", "]", "=", "x", ".", "ravel", "(", ")", "\n", "predictors", "[", ":", ",", "jy", "]", "=", "y", ".", "ravel", "(", ")", "\n", "z", "=", "gp", ".", "predict_mean", "(", "predictors", ")", ".", "reshape", "(", "resol", ",", "resol", ")", "\n", "axes", "[", "jy", ",", "ix", "]", ".", "contourf", "(", "x", ",", "y", ",", "z", ")", "\n", "axes", "[", "jy", ",", "ix", "]", ".", "set_ylabel", "(", "parameter_names", "[", "jy", "]", ")", "\n", "", "axes", "[", "jy", ",", "ix", "]", ".", "set_xlabel", "(", "parameter_names", "[", "ix", "]", ")", "\n", "\n", "", "", "return", "axes", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.plot_sample": [[13, 48], ["interactive._prepare_axes", "isinstance", "interactive._update_interactive", "options.get", "len", "_prepare_axes.set_xlabel", "_prepare_axes.hist", "_prepare_axes.set_xlabel", "_prepare_axes.set_ylabel", "_prepare_axes.scatter", "matplotlib.close", "sorted", "len", "logger.warning", "samples.keys"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive._prepare_axes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive._update_interactive", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["def", "plot_sample", "(", "samples", ",", "nodes", "=", "None", ",", "n", "=", "-", "1", ",", "displays", "=", "None", ",", "**", "options", ")", ":", "\n", "    ", "\"\"\"Plot a scatterplot of samples.\n\n    Experimental, only dims 1-2 supported.\n\n    Parameters\n    ----------\n    samples : Sample\n    nodes : str or list[str], optional\n    n : int, optional\n        Number of plotted samples [0, n).\n    displays : IPython.display.HTML\n\n    \"\"\"", "\n", "axes", "=", "_prepare_axes", "(", "options", ")", "\n", "\n", "nodes", "=", "nodes", "or", "sorted", "(", "samples", ".", "keys", "(", ")", ")", "[", ":", "2", "]", "\n", "if", "isinstance", "(", "nodes", ",", "str", ")", ":", "\n", "        ", "nodes", "=", "[", "nodes", "]", "\n", "\n", "", "if", "len", "(", "nodes", ")", "==", "1", ":", "\n", "        ", "axes", ".", "set_xlabel", "(", "nodes", "[", "0", "]", ")", "\n", "axes", ".", "hist", "(", "samples", "[", "nodes", "[", "0", "]", "]", "[", ":", "n", "]", ")", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "nodes", ")", ">", "2", ":", "\n", "            ", "logger", ".", "warning", "(", "'Over 2-dimensional plots not supported. Falling back to 2d'", "\n", "'projection.'", ")", "\n", "", "axes", ".", "set_xlabel", "(", "nodes", "[", "0", "]", ")", "\n", "axes", ".", "set_ylabel", "(", "nodes", "[", "1", "]", ")", "\n", "axes", ".", "scatter", "(", "samples", "[", "nodes", "[", "0", "]", "]", "[", ":", "n", "]", ",", "samples", "[", "nodes", "[", "1", "]", "]", "[", ":", "n", "]", ")", "\n", "\n", "", "_update_interactive", "(", "displays", ",", "options", ")", "\n", "\n", "if", "options", ".", "get", "(", "'close'", ")", ":", "\n", "        ", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.get_axes": [[50, 55], ["matplotlib.gca"], "function", ["None"], ["", "", "def", "get_axes", "(", "**", "options", ")", ":", "\n", "    ", "\"\"\"Get an Axes object from `options`, or create one if needed.\"\"\"", "\n", "if", "'axes'", "in", "options", ":", "\n", "        ", "return", "options", "[", "'axes'", "]", "\n", "", "return", "plt", ".", "gca", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive._update_interactive": [[57, 64], ["options.get", "display.clear_output", "displays.insert", "display.display", "matplotlib.gcf"], "function", ["None"], ["", "def", "_update_interactive", "(", "displays", ",", "options", ")", ":", "\n", "    ", "displays", "=", "displays", "or", "[", "]", "\n", "if", "options", ".", "get", "(", "'interactive'", ")", ":", "\n", "        ", "from", "IPython", "import", "display", "\n", "display", ".", "clear_output", "(", "wait", "=", "True", ")", "\n", "displays", ".", "insert", "(", "0", ",", "plt", ".", "gcf", "(", ")", ")", "\n", "display", ".", "display", "(", "*", "displays", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive._prepare_axes": [[66, 79], ["interactive.get_axes", "options.get", "options.get", "options.get", "get_axes.clear", "get_axes.set_xlim", "get_axes.set_ylim", "options.get", "options.get"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.get_axes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear"], ["", "", "def", "_prepare_axes", "(", "options", ")", ":", "\n", "    ", "axes", "=", "get_axes", "(", "**", "options", ")", "\n", "ion", "=", "options", ".", "get", "(", "'interactive'", ")", "\n", "\n", "if", "ion", ":", "\n", "        ", "axes", ".", "clear", "(", ")", "\n", "\n", "", "if", "options", ".", "get", "(", "'xlim'", ")", ":", "\n", "        ", "axes", ".", "set_xlim", "(", "options", ".", "get", "(", "'xlim'", ")", ")", "\n", "", "if", "options", ".", "get", "(", "'ylim'", ")", ":", "\n", "        ", "axes", ".", "set_ylim", "(", "options", ".", "get", "(", "'ylim'", ")", ")", "\n", "\n", "", "return", "axes", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.plot_func": [[81, 165], ["interactive.get_axes", "numpy.linspace", "numpy.array().flatten", "numpy.array().flatten", "matplotlib.cla", "matplotlib.fill_between", "matplotlib.xlim", "matplotlib.xticks", "matplotlib.sca", "matplotlib.title", "print", "numpy.array().flatten", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.scatter", "numpy.arange", "matplotlib.xlabel", "numpy.array", "numpy.array", "numpy.amin", "min", "min", "mean_fn", "var_fn", "numpy.array", "max", "acq_fn"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.get_axes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.plot"], ["", "def", "plot_func", "(", "gp", ",", "acq_fn", ",", "nodes", "=", "None", ",", "points", "=", "None", ",", "new_points", "=", "None", ",", "title", "=", "None", ",", "**", "options", ")", ":", "\n", "    ", "\"\"\"Plot a contour of a function.\n\n    Experimental, only 2D supported.\n\n    Parameters\n    ----------\n    fn : callable\n    bounds : list[arraylike]\n        Bounds for the plot, e.g. [(0, 1), (0,1)].\n    nodes : list[str], optional\n    points : arraylike, optional\n        Additional points to plot.\n    title : str, optional\n\n    \"\"\"", "\n", "#print(\"Plot\")", "\n", "mean_fn", "=", "gp", ".", "predict_mean", "\n", "var_fn", "=", "gp", ".", "predict_var", "\n", "bounds", "=", "gp", ".", "bounds", "\n", "\n", "ax", "=", "get_axes", "(", "**", "options", ")", "\n", "\n", "x", "=", "np", ".", "linspace", "(", "*", "bounds", "[", "0", "]", ",", "num", "=", "1000", ")", "\n", "\n", "def", "flatten", "(", "l", ")", ":", "\n", "        ", "return", "[", "item", "for", "sublist", "in", "l", "for", "item", "in", "sublist", "]", "\n", "\n", "", "mean_vals", "=", "np", ".", "array", "(", "mean_fn", "(", "x", ")", ")", ".", "flatten", "(", ")", "\n", "var_vals", "=", "np", ".", "array", "(", "var_fn", "(", "x", ")", ")", ".", "flatten", "(", ")", "\n", "\n", "upper_bound", "=", "mean_vals", "+", "var_vals", "**", "0.5", "\n", "lower_bound", "=", "mean_vals", "-", "var_vals", "**", "0.5", "\n", "\n", "\n", "#min_acq = [min_acq] * len(x)", "\n", "#print(len(min_acq))", "\n", "#print(len(acq_vals))", "\n", "\n", "if", "ax", ":", "\n", "        ", "plt", ".", "sca", "(", "ax", ")", "\n", "", "plt", ".", "cla", "(", ")", "\n", "\n", "# plt.axhline(0, color = 'black')", "\n", "if", "title", ":", "\n", "        ", "plt", ".", "title", "(", "title", ")", "\n", "\n", "#plt.plot(x, mean_vals, color='black')", "\n", "# plt.plot(x, lowe, color='grey', linestyle='dashed')", "\n", "# plt.plot(x, mean_vals + var_vals ** 0.5, color='grey', linestyle='dashed')", "\n", "", "plt", ".", "fill_between", "(", "x", ",", "lower_bound", ",", "upper_bound", ",", "color", "=", "'gray'", ",", "alpha", "=", "0.2", ")", "\n", "if", "acq_fn", "is", "not", "None", ":", "\n", "        ", "print", "(", "'interactive.py: Acqusition!'", ")", "\n", "acq_vals", "=", "np", ".", "array", "(", "acq_fn", "(", "x", ")", ")", ".", "flatten", "(", ")", "\n", "#acq_mean = np.mean(acq_vals, 0)", "\n", "#acq_std = np.std(acq_vals, 0)", "\n", "#acq_vals = (acq_vals - acq_mean) / acq_std", "\n", "\n", "min_acq", "=", "np", ".", "amin", "(", "acq_vals", ")", "+", "min", "(", "gp", ".", "Y", ")", "\n", "plt", ".", "plot", "(", "x", ",", "acq_vals", ",", "color", "=", "'green'", ")", "\n", "plt", ".", "fill_between", "(", "x", ",", "acq_vals", ",", "min_acq", ",", "color", "=", "'green'", ",", "alpha", "=", "0.2", ")", "\n", "\n", "\n", "#print(x.shape)", "\n", "#print(mean_vals.shape)", "\n", "#print(upper_bound.shape)", "\n", "\n", "", "if", "points", "is", "not", "None", ":", "\n", "#print(len(points))", "\n", "#print(len(gp.Y.value))", "\n", "        ", "plt", ".", "scatter", "(", "points", ",", "gp", ".", "Y", ",", "s", "=", "15", ",", "color", "=", "\"red\"", ",", "zorder", "=", "10", ")", "\n", "##if new_points is not None:", "\n", "#   plt.scatter(new_points, gp.Y, s = 15, color = \"red\")", "\n", "\n", "#if options.get('interactive'):", "\n", "#    plt.scatter(points[-1, 0], points[-1, 1], color='r')", "\n", "\n", "#plt.axvline(0, color = 'black')", "\n", "", "plt", ".", "xlim", "(", "bounds", "[", "0", "]", ")", "\n", "\n", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "min", "(", "x", ")", ",", "max", "(", "x", ")", "+", "1", ",", "10.0", ")", ")", "\n", "\n", "if", "nodes", ":", "\n", "        ", "plt", ".", "xlabel", "(", "nodes", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.plot_posterior": [[167, 201], ["interactive.get_axes", "numpy.linspace", "numpy.linspace", "get_axes.set_ylim", "get_axes.set_xlim", "numpy.zeros", "enumerate", "get_axes.pcolormesh", "get_axes.scatter", "posterior", "min", "max", "min", "max", "sklearn.neighbors.KernelDensity", "sklearn.neighbors.KernelDensity.fit", "enumerate", "np.linspace.flatten", "numpy.exp", "max", "min", "min", "max", "len", "len", "Ss.reshape", "sklearn.neighbors.KernelDensity.score", "numpy.std", "len", "float", "numpy.array().reshape", "numpy.array"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.get_axes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.fit"], ["", "", "def", "plot_posterior", "(", "gp", ",", "**", "options", ")", ":", "\n", "    ", "bounds", "=", "gp", ".", "bounds", "\n", "posterior", "=", "gp", ".", "get_posterior", "\n", "S", "=", "gp", ".", "num_posterior_samples", "\n", "\n", "ax", "=", "get_axes", "(", "**", "options", ")", "\n", "Xs", "=", "np", ".", "linspace", "(", "*", "bounds", "[", "0", "]", ",", "num", "=", "1000", ")", "\n", "samples", "=", "posterior", "(", "Xs", ",", "S", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "# print(samples)", "\n", "ydif", "=", "(", "max", "(", "gp", ".", "Y", ")", "-", "min", "(", "gp", ".", "Y", ")", ")", "*", "0.15", "\n", "levels", "=", "np", ".", "linspace", "(", "min", "(", "gp", ".", "Y", ")", "-", "ydif", ",", "max", "(", "gp", ".", "Y", ")", "+", "ydif", ",", "1000", ")", "\n", "\n", "ax", ".", "set_ylim", "(", "min", "(", "levels", ")", ",", "max", "(", "levels", ")", ")", "\n", "ax", ".", "set_xlim", "(", "min", "(", "Xs", ")", ",", "max", "(", "Xs", ")", ")", "\n", "\n", "cs", "=", "np", ".", "zeros", "(", "(", "len", "(", "Xs", ")", ",", "len", "(", "levels", ")", ")", ")", "\n", "for", "i", ",", "Ss", "in", "enumerate", "(", "samples", ".", "T", ")", ":", "\n", "        ", "bandwidth", "=", "1.06", "*", "np", ".", "std", "(", "Ss", ")", "*", "len", "(", "Ss", ")", "**", "(", "-", "1.", "/", "5", ")", "# Silverman's (1986) rule of thumb.", "\n", "kde", "=", "KernelDensity", "(", "bandwidth", "=", "float", "(", "bandwidth", ")", ")", "\n", "\n", "kde", ".", "fit", "(", "Ss", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "for", "j", ",", "level", "in", "enumerate", "(", "levels", ")", ":", "\n", "            ", "cs", "[", "i", ",", "j", "]", "=", "kde", ".", "score", "(", "np", ".", "array", "(", "level", ")", ".", "reshape", "(", "1", ",", "1", ")", ")", "\n", "", "", "ax", ".", "pcolormesh", "(", "Xs", ".", "flatten", "(", ")", ",", "levels", ",", "np", ".", "exp", "(", "cs", ".", "T", ")", ",", "cmap", "=", "'Blues_r'", ")", "# , alpha=0.1)", "\n", "ax", ".", "scatter", "(", "gp", ".", "X", ",", "gp", ".", "Y", ",", "s", "=", "15", ",", "color", "=", "\"red\"", ",", "zorder", "=", "10", ")", "\n", "\n", "\n", "'''for j in range(0, 5):\n        samples = posterior(x, S)\n        for sample in samples:\n            vals = np.array(sample).flatten()\n            plt.scatter(x, vals, color='blue')\n\n    plt.scatter(gp.X, gp.Y, s = 15, color = \"red\")'''", "\n", "#plt.show()", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour": [[204, 246], ["interactive.get_axes", "numpy.meshgrid", "fn", "matplotlib.cla", "matplotlib.xlim", "matplotlib.ylim", "numpy.linspace", "numpy.linspace", "matplotlib.sca", "matplotlib.title", "matplotlib.contour", "matplotlib.scatter", "options.get", "matplotlib.xlabel", "matplotlib.ylabel", "fn.reshape", "logger.warning", "matplotlib.scatter", "x.reshape", "y.reshape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.get_axes"], ["", "def", "draw_contour", "(", "fn", ",", "bounds", ",", "nodes", "=", "None", ",", "points", "=", "None", ",", "title", "=", "None", ",", "**", "options", ")", ":", "\n", "    ", "\"\"\"Plot a contour of a function.\n\n    Experimental, only 2D supported.\n\n    Parameters\n    ----------\n    fn : callable\n    bounds : list[arraylike]\n        Bounds for the plot, e.g. [(0, 1), (0,1)].\n    nodes : list[str], optional\n    points : arraylike, optional\n        Additional points to plot.\n    title : str, optional\n\n    \"\"\"", "\n", "ax", "=", "get_axes", "(", "**", "options", ")", "\n", "\n", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "np", ".", "linspace", "(", "*", "bounds", "[", "0", "]", ")", ",", "np", ".", "linspace", "(", "*", "bounds", "[", "1", "]", ")", ")", "\n", "z", "=", "fn", "(", "np", ".", "c_", "[", "x", ".", "reshape", "(", "-", "1", ")", ",", "y", ".", "reshape", "(", "-", "1", ")", "]", ")", "\n", "\n", "if", "ax", ":", "\n", "        ", "plt", ".", "sca", "(", "ax", ")", "\n", "", "plt", ".", "cla", "(", ")", "\n", "\n", "if", "title", ":", "\n", "        ", "plt", ".", "title", "(", "title", ")", "\n", "", "try", ":", "\n", "        ", "plt", ".", "contour", "(", "x", ",", "y", ",", "z", ".", "reshape", "(", "x", ".", "shape", ")", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "logger", ".", "warning", "(", "'Could not draw a contour plot'", ")", "\n", "", "if", "points", "is", "not", "None", ":", "\n", "        ", "plt", ".", "scatter", "(", "points", "[", ":", "-", "1", ",", "0", "]", ",", "points", "[", ":", "-", "1", ",", "1", "]", ")", "\n", "if", "options", ".", "get", "(", "'interactive'", ")", ":", "\n", "            ", "plt", ".", "scatter", "(", "points", "[", "-", "1", ",", "0", "]", ",", "points", "[", "-", "1", ",", "1", "]", ",", "color", "=", "'r'", ")", "\n", "\n", "", "", "plt", ".", "xlim", "(", "bounds", "[", "0", "]", ")", "\n", "plt", ".", "ylim", "(", "bounds", "[", "1", "]", ")", "\n", "\n", "if", "nodes", ":", "\n", "        ", "plt", ".", "xlabel", "(", "nodes", "[", "0", "]", ")", "\n", "plt", ".", "ylabel", "(", "nodes", "[", "1", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.__init__": [[11, 20], ["networkx.DiGraph"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "source_net", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the graph.\n\n        Parameters\n        ----------\n        source_net : nx.DiGraph, optional\n\n        \"\"\"", "\n", "self", ".", "source_net", "=", "source_net", "or", "nx", ".", "DiGraph", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_node": [[21, 33], ["graphical_model.GraphicalModel.has_node", "graphical_model.GraphicalModel.source_net.add_node", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_node"], ["", "def", "add_node", "(", "self", ",", "name", ",", "state", ")", ":", "\n", "        ", "\"\"\"Add node `name` to the graph.\n\n        Parameters\n        ----------\n        name : str\n        state : dict\n\n        \"\"\"", "\n", "if", "self", ".", "has_node", "(", "name", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Node {} already exists'", ".", "format", "(", "name", ")", ")", "\n", "", "self", ".", "source_net", ".", "add_node", "(", "name", ",", "attr_dict", "=", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.remove_node": [[34, 44], ["graphical_model.GraphicalModel.get_parents", "graphical_model.GraphicalModel.source_net.remove_node", "graphical_model.GraphicalModel.remove_node", "len", "len", "graphical_model.GraphicalModel.source_net.successors", "graphical_model.GraphicalModel.source_net.predecessors"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_parents", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node"], ["", "def", "remove_node", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"Remove node 'name' from the graph.\"\"\"", "\n", "parent_names", "=", "self", ".", "get_parents", "(", "name", ")", "\n", "self", ".", "source_net", ".", "remove_node", "(", "name", ")", "\n", "\n", "# Remove sole private parents", "\n", "for", "p", "in", "parent_names", ":", "\n", "            ", "if", "p", "[", "0", "]", "==", "'_'", "and", "len", "(", "self", ".", "source_net", ".", "successors", "(", "p", ")", ")", "==", "0", "and", "len", "(", "self", ".", "source_net", ".", "predecessors", "(", "p", ")", ")", "==", "0", ":", "\n", "                ", "self", ".", "remove_node", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_node": [[45, 54], ["None"], "methods", ["None"], ["", "", "", "def", "get_node", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"Return the state of the node.\n\n        Returns\n        -------\n        out : dict\n\n        \"\"\"", "\n", "return", "self", ".", "source_net", ".", "node", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.set_node": [[55, 58], ["None"], "methods", ["None"], ["", "def", "set_node", "(", "self", ",", "name", ",", "state", ")", ":", "\n", "        ", "\"\"\"Set the state of the node.\"\"\"", "\n", "self", ".", "source_net", ".", "node", "[", "name", "]", "=", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node": [[59, 62], ["graphical_model.GraphicalModel.source_net.has_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node"], ["", "def", "has_node", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"Whether the graph has a node `name`.\"\"\"", "\n", "return", "self", ".", "source_net", ".", "has_node", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_edge": [[66, 91], ["graphical_model.GraphicalModel.source_net.add_edge", "len", "isinstance", "ValueError", "graphical_model.GraphicalModel.has_node", "ValueError", "graphical_model.GraphicalModel.has_node", "ValueError", "graphical_model.GraphicalModel.get_parents"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_edge", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_parents"], ["", "def", "add_edge", "(", "self", ",", "parent_name", ",", "child_name", ",", "param_name", "=", "None", ")", ":", "\n", "        ", "\"\"\"Add an edge between nodes.\n\n        Deprecated. By default, map to a positional parameter of the child.\n\n        Parameters\n        ----------\n        parent_name : str\n        child_name : str\n        param_name : str or int\n\n        \"\"\"", "\n", "if", "param_name", "is", "None", ":", "\n", "            ", "param_name", "=", "len", "(", "self", ".", "get_parents", "(", "child_name", ")", ")", "\n", "", "if", "not", "isinstance", "(", "param_name", ",", "(", "int", ",", "str", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Unrecognized type for `param_name` {}. Must be either an '", "\n", "'`int` for positional parameters or `str` for named '", "\n", "'parameters.'", ".", "format", "(", "param_name", ")", ")", "\n", "\n", "", "if", "not", "self", ".", "has_node", "(", "parent_name", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Parent {} does not exist'", ".", "format", "(", "parent_name", ")", ")", "\n", "", "if", "not", "self", ".", "has_node", "(", "child_name", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Child {} does not exist'", ".", "format", "(", "child_name", ")", ")", "\n", "\n", "", "self", ".", "source_net", ".", "add_edge", "(", "parent_name", ",", "child_name", ",", "param", "=", "param_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.update_node": [[92, 114], ["graphical_model.GraphicalModel.source_net.out_edges", "graphical_model.GraphicalModel.remove_node", "graphical_model.GraphicalModel.source_net.add_node", "graphical_model.GraphicalModel.source_net.add_edges_from", "graphical_model.GraphicalModel.source_net.in_edges", "graphical_model.GraphicalModel.remove_node", "graphical_model.GraphicalModel.source_net.add_edge"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_edge"], ["", "def", "update_node", "(", "self", ",", "node", ",", "updating_node", ")", ":", "\n", "        ", "\"\"\"Update `node` with `updating_node` in the model.\n\n        Node `node` gets the state (operation) and parents of the `updating_node`. The\n        updating node is then removed from the graph.\n\n        Parameters\n        ----------\n        node : str\n        updating_node : str\n\n        \"\"\"", "\n", "out_edges", "=", "self", ".", "source_net", ".", "out_edges", "(", "node", ",", "data", "=", "True", ")", "\n", "self", ".", "remove_node", "(", "node", ")", "\n", "self", ".", "source_net", ".", "add_node", "(", "node", ",", "self", ".", "source_net", ".", "node", "[", "updating_node", "]", ")", "\n", "self", ".", "source_net", ".", "add_edges_from", "(", "out_edges", ")", "\n", "\n", "# Transfer incoming edges", "\n", "for", "u", ",", "v", ",", "data", "in", "self", ".", "source_net", ".", "in_edges", "(", "updating_node", ",", "data", "=", "True", ")", ":", "\n", "            ", "self", ".", "source_net", ".", "add_edge", "(", "u", ",", "node", ",", "data", ")", "\n", "\n", "", "self", ".", "remove_node", "(", "updating_node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_parents": [[115, 134], ["graphical_model.GraphicalModel.source_net.predecessors", "isinstance", "args.append", "sorted", "operator.itemgetter"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "get_parents", "(", "self", ",", "child_name", ")", ":", "\n", "        ", "\"\"\"Return the names of parents of node `child_name`.\n\n        Parameters\n        ----------\n        child_name\n\n        Returns\n        -------\n        parent_names : list\n            List of positional parent names\n\n        \"\"\"", "\n", "args", "=", "[", "]", "\n", "for", "parent_name", "in", "self", ".", "source_net", ".", "predecessors", "(", "child_name", ")", ":", "\n", "            ", "param", "=", "self", ".", "source_net", "[", "parent_name", "]", "[", "child_name", "]", "[", "'param'", "]", "\n", "if", "isinstance", "(", "param", ",", "int", ")", ":", "\n", "                ", "args", ".", "append", "(", "(", "param", ",", "parent_name", ")", ")", "\n", "", "", "return", "[", "a", "[", "1", "]", "for", "a", "in", "sorted", "(", "args", ",", "key", "=", "itemgetter", "(", "0", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.nodes": [[135, 139], ["graphical_model.GraphicalModel.source_net.nodes"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.nodes"], ["", "@", "property", "\n", "def", "nodes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a list of nodes.\"\"\"", "\n", "return", "self", ".", "source_net", ".", "nodes", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.copy": [[140, 146], ["graphical_model.GraphicalModel.__class__", "networkx.DiGraph"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of the graph.\"\"\"", "\n", "kopy", "=", "self", ".", "__class__", "(", ")", "\n", "# Copy the source net", "\n", "kopy", ".", "source_net", "=", "nx", ".", "DiGraph", "(", "self", ".", "source_net", ")", "\n", "return", "kopy", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.__copy__": [[147, 150], ["graphical_model.GraphicalModel.copy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "def", "__copy__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Return a copy of the graph.\"\"\"", "\n", "return", "self", ".", "copy", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.run_vectorized": [[13, 94], ["enumerate", "range", "list", "elfi.utils.is_array", "numpy.empty", "enumerate", "operation", "numpy.array", "len", "constants.append", "np.array.append", "inputs_i.append", "inputs_i.append", "ValueError"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.is_array", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["def", "run_vectorized", "(", "operation", ",", "*", "inputs", ",", "constants", "=", "None", ",", "dtype", "=", "None", ",", "batch_size", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Run the operation as if it was vectorized over the individual runs in the batch.\n\n    Helper for cases when you have an operation that does not support vector arguments.\n    This tool is still experimental and may not work in all cases.\n\n    Parameters\n    ----------\n    operation : callable\n        Operation that will be run `batch_size` times.\n    inputs\n        Inputs from the parent nodes.\n    constants\n        See documentation from vectorize.\n    dtype\n        See documentation from vectorize.\n    batch_size : int, optional\n    kwargs\n\n    Returns\n    -------\n    operation_output\n        If batch_size > 1, a numpy array of outputs is returned\n\n    \"\"\"", "\n", "constants", "=", "[", "]", "if", "constants", "is", "None", "else", "list", "(", "constants", ")", "\n", "\n", "# Check input and set constants and batch_size if needed", "\n", "for", "i", ",", "inpt", "in", "enumerate", "(", "inputs", ")", ":", "\n", "        ", "if", "i", "in", "constants", ":", "\n", "            ", "continue", "\n", "\n", "# Test if a numpy array", "\n", "", "if", "is_array", "(", "inpt", ")", ":", "\n", "            ", "length", "=", "len", "(", "inpt", ")", "\n", "if", "batch_size", "is", "None", ":", "\n", "                ", "batch_size", "=", "length", "\n", "", "elif", "batch_size", "!=", "length", ":", "\n", "                ", "raise", "ValueError", "(", "'Batch size {} does not match with input {} length of '", "\n", "'{}. Please check `constants` argument for the '", "\n", "'vectorize decorator for marking constant inputs.'", ")", "\n", "", "", "else", ":", "\n", "            ", "constants", ".", "append", "(", "i", ")", "\n", "\n", "# If batch_size is still `None` set it to 1 as no inputs larger than it were found.", "\n", "# This occurs often with e.g. summary operations translating observed data", "\n", "", "", "if", "batch_size", "is", "None", ":", "\n", "        ", "batch_size", "=", "1", "\n", "\n", "# Prepare the array for the results", "\n", "", "if", "dtype", "is", "False", ":", "\n", "        ", "runs", "=", "np", ".", "empty", "(", "batch_size", ",", "dtype", "=", "object", ")", "\n", "", "else", ":", "\n", "        ", "runs", "=", "[", "]", "\n", "\n", "# Run the operation batch_size times", "\n", "", "for", "index_in_batch", "in", "range", "(", "batch_size", ")", ":", "\n", "# Prepare inputs for this run", "\n", "        ", "inputs_i", "=", "[", "]", "\n", "for", "i_inpt", ",", "inpt", "in", "enumerate", "(", "inputs", ")", ":", "\n", "            ", "if", "i_inpt", "in", "constants", ":", "\n", "                ", "inputs_i", ".", "append", "(", "inpt", ")", "\n", "", "else", ":", "\n", "                ", "inputs_i", ".", "append", "(", "inpt", "[", "index_in_batch", "]", ")", "\n", "\n", "# Replace the batch_size with index_in_batch", "\n", "", "", "if", "'meta'", "in", "kwargs", ":", "\n", "            ", "kwargs", "[", "'meta'", "]", "[", "'index_in_batch'", "]", "=", "index_in_batch", "\n", "\n", "", "output", "=", "operation", "(", "*", "inputs_i", ",", "**", "kwargs", ")", "\n", "\n", "if", "dtype", "is", "False", ":", "\n", "# Prevent anu potential casting of output", "\n", "            ", "runs", "[", "index_in_batch", "]", "=", "output", "\n", "", "else", ":", "\n", "            ", "runs", ".", "append", "(", "output", ")", "\n", "\n", "", "", "if", "dtype", "is", "not", "False", ":", "\n", "        ", "runs", "=", "np", ".", "array", "(", "runs", ",", "dtype", "=", "dtype", ")", "\n", "\n", "", "return", "runs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize": [[96, 139], ["functools.partial"], "function", ["None"], ["", "def", "vectorize", "(", "operation", ",", "constants", "=", "None", ",", "dtype", "=", "None", ")", ":", "\n", "    ", "\"\"\"Vectorize an operation.\n\n    Helper for cases when you have an operation that does not support vector arguments.\n    This tool is still experimental and may not work in all cases.\n\n    Parameters\n    ----------\n    operation : callable\n        Operation to vectorize.\n    constants : tuple, list, optional\n        A mask for constants in inputs, e.g. (0, 2) would indicate that the first and\n        third positional inputs are constants. The constants will be passed as they are to\n        each operation call.\n    dtype : np.dtype, bool[False], optional\n        If None, numpy converts a list of outputs automatically. In some cases this\n        produces non desired results. If you wish to keep the outputs as they are with\n        no conversion, specify dtype=False. This results into a 1d object numpy array\n        with outputs as they were returned.\n\n    Notes\n    -----\n    This is a convenience method that uses a for loop internally for the\n    vectorization. For best performance, one should aim to implement vectorized operations\n    (by using e.g. numpy functions that are mostly vectorized) if at all possible.\n\n    Examples\n    --------\n    ::\n\n        # This form works in most cases\n        vectorized_simulator = elfi.tools.vectorize(simulator)\n\n        # Tell that the second and third argument to the simulator will be a constant\n        vectorized_simulator = elfi.tools.vectorize(simulator, [1, 2])\n        elfi.Simulator(vectorized_simulator, prior, constant_1, constant_2)\n\n        # Tell the vectorizer that it should not do any conversion to the outputs\n        vectorized_simulator = elfi.tools.vectorize(simulator, dtype=False)\n\n    \"\"\"", "\n", "# Cases direct call or a decorator without arguments", "\n", "return", "partial", "(", "run_vectorized", ",", "operation", ",", "constants", "=", "constants", ",", "dtype", "=", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.unpack_meta": [[141, 149], ["kwinputs[].copy", "kwinputs[].copy.update"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update"], ["", "def", "unpack_meta", "(", "*", "inputs", ",", "**", "kwinputs", ")", ":", "\n", "    ", "\"\"\"Update ``kwinputs`` with keys and values from its ``meta`` dictionary.\"\"\"", "\n", "if", "'meta'", "in", "kwinputs", ":", "\n", "        ", "new_kwinputs", "=", "kwinputs", "[", "'meta'", "]", ".", "copy", "(", ")", "\n", "new_kwinputs", ".", "update", "(", "kwinputs", ")", "\n", "kwinputs", "=", "new_kwinputs", "\n", "\n", "", "return", "inputs", ",", "kwinputs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.prepare_seed": [[151, 163], ["elfi.utils.get_sub_seed", "kwinputs.get", "kwinputs[].get_state"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_state"], ["", "def", "prepare_seed", "(", "*", "inputs", ",", "**", "kwinputs", ")", ":", "\n", "    ", "\"\"\"Update ``kwinputs`` with the seed from its value ``random_state``.\"\"\"", "\n", "if", "'random_state'", "in", "kwinputs", ":", "\n", "# Get the seed for this batch, assuming np.RandomState instance", "\n", "        ", "seed", "=", "kwinputs", "[", "'random_state'", "]", ".", "get_state", "(", ")", "[", "1", "]", "[", "0", "]", "\n", "\n", "# Since we may not be the first operation to use this seed, lets generate a", "\n", "# a sub seed using this seed", "\n", "sub_seed_index", "=", "kwinputs", ".", "get", "(", "'index_in_batch'", ")", "or", "0", "\n", "kwinputs", "[", "'seed'", "]", "=", "get_sub_seed", "(", "seed", ",", "sub_seed_index", ")", "\n", "\n", "", "return", "inputs", ",", "kwinputs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.stdout_to_array": [[165, 168], ["numpy.fromstring"], "function", ["None"], ["", "def", "stdout_to_array", "(", "stdout", ",", "*", "inputs", ",", "sep", "=", "' '", ",", "dtype", "=", "None", ",", "**", "kwinputs", ")", ":", "\n", "    ", "\"\"\"Convert a single row from stdout to np.array.\"\"\"", "\n", "return", "np", ".", "fromstring", "(", "stdout", ",", "dtype", "=", "dtype", ",", "sep", "=", "sep", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.run_external": [[170, 210], ["tools.unpack_meta", "tools.prepare_seed", "dict", "dict.update", "subprocess.run", "process_result", "prepare_inputs", "command.format.format", "KeyError", "str"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.unpack_meta", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.prepare_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.process_result", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.prepare_inputs"], ["", "def", "run_external", "(", "command", ",", "\n", "*", "inputs", ",", "\n", "process_result", "=", "None", ",", "\n", "prepare_inputs", "=", "None", ",", "\n", "stdout", "=", "True", ",", "\n", "subprocess_kwargs", "=", "None", ",", "\n", "**", "kwinputs", ")", ":", "\n", "    ", "\"\"\"Run an external commmand (e.g. shell script, or executable) on a subprocess.\n\n    See external_operation below for parameter descriptions.\n\n    Returns\n    -------\n    output\n\n    \"\"\"", "\n", "inputs", ",", "kwinputs", "=", "unpack_meta", "(", "*", "inputs", ",", "**", "kwinputs", ")", "\n", "inputs", ",", "kwinputs", "=", "prepare_seed", "(", "*", "inputs", ",", "**", "kwinputs", ")", "\n", "if", "prepare_inputs", ":", "\n", "        ", "inputs", ",", "kwinputs", "=", "prepare_inputs", "(", "*", "inputs", ",", "**", "kwinputs", ")", "\n", "\n", "# Add arguments to the command", "\n", "", "try", ":", "\n", "        ", "command", "=", "command", ".", "format", "(", "*", "inputs", ",", "**", "kwinputs", ")", "\n", "", "except", "KeyError", "as", "e", ":", "\n", "        ", "raise", "KeyError", "(", "'The requested keyword {} was not passed to the external '", "\n", "'operation: \"{}\".'", ".", "format", "(", "str", "(", "e", ")", ",", "command", ")", ")", "\n", "\n", "", "subprocess_kwargs_", "=", "dict", "(", "shell", "=", "True", ",", "check", "=", "True", ")", "\n", "subprocess_kwargs_", ".", "update", "(", "subprocess_kwargs", "or", "{", "}", ")", "\n", "\n", "# Execute", "\n", "completed_process", "=", "subprocess", ".", "run", "(", "command", ",", "**", "subprocess_kwargs_", ")", "\n", "\n", "if", "stdout", ":", "\n", "        ", "completed_process", "=", "completed_process", ".", "stdout", "\n", "\n", "", "output", "=", "process_result", "(", "completed_process", ",", "*", "inputs", ",", "**", "kwinputs", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.external_operation": [[212, 287], ["functools.partial", "isinstance", "dict", "isinstance", "functools.partial", "str"], "function", ["None"], ["", "def", "external_operation", "(", "command", ",", "\n", "process_result", "=", "None", ",", "\n", "prepare_inputs", "=", "None", ",", "\n", "sep", "=", "' '", ",", "\n", "stdout", "=", "True", ",", "\n", "subprocess_kwargs", "=", "None", ")", ":", "\n", "    ", "\"\"\"Wrap an external command as a Python callable (function).\n\n    The external command can be e.g. a shell script, or an executable file.\n\n    Parameters\n    ----------\n    command : str\n        Command to execute. Arguments can be passed to the executable by using Python's\n        format strings, e.g. `\"myscript.sh {0} {batch_size} --seed {seed}\"`. The command\n        is expected to write to stdout. Since `random_state` is python specific object, a\n        `seed` keyword argument will be available to operations that use `random_state`.\n    process_result : callable, np.dtype, str, optional\n        Callable result handler with a signature\n        `output = callable(result, *inputs, **kwinputs)`. Here the `result` is either the\n        stdout or `subprocess.CompletedProcess` depending on the stdout flag below. The\n        inputs and kwinputs will come from ELFI. The default handler converts the stdout\n        to numpy array with `array = np.fromstring(stdout, sep=sep)`. If `process_result`\n        is `np.dtype` or a string, then the stdout data is casted to that type with\n        `stdout = np.fromstring(stdout, sep=sep, dtype=process_result)`.\n    prepare_inputs : callable, optional\n        Callable with a signature `inputs, kwinputs = callable(*inputs, **kwinputs)`. The\n        inputs will come from elfi.\n    sep : str, optional\n        Separator to use with the default `process_result` handler. Default is a space\n        `' '`. If you specify your own callable to `process_result` this value has no\n        effect.\n    stdout : bool, optional\n        Pass the `process_result` handler the stdout instead of the\n        `subprocess.CompletedProcess` instance. Default is true.\n    subprocess_kwargs : dict, optional\n        Options for Python's `subprocess.run` that is used to run the external command.\n        Defaults are `shell=True, check=True`. See the `subprocess` documentation for more\n        details.\n\n    Examples\n    --------\n    >>> import elfi\n    >>> op = elfi.tools.external_operation('echo 1 {0}', process_result='int8')\n    >>>\n    >>> constant = elfi.Constant(123)\n    >>> simulator = elfi.Simulator(op, constant)\n    >>> simulator.generate()\n    array([  1, 123], dtype=int8)\n\n    Returns\n    -------\n    operation : callable\n        ELFI compatible operation that can be used e.g. as a simulator.\n\n    \"\"\"", "\n", "if", "process_result", "is", "None", "or", "isinstance", "(", "process_result", ",", "(", "str", ",", "np", ".", "dtype", ")", ")", ":", "\n", "        ", "fromstring_kwargs", "=", "dict", "(", "sep", "=", "sep", ")", "\n", "if", "isinstance", "(", "process_result", ",", "(", "str", ",", "np", ".", "dtype", ")", ")", ":", "\n", "            ", "fromstring_kwargs", "[", "'dtype'", "]", "=", "str", "(", "process_result", ")", "\n", "", "process_result", "=", "partial", "(", "stdout_to_array", ",", "**", "fromstring_kwargs", ")", "\n", "stdout", "=", "True", "\n", "\n", "", "if", "stdout", "is", "True", ":", "\n", "# Request stdout", "\n", "        ", "subprocess_kwargs", "=", "subprocess_kwargs", "or", "{", "}", "\n", "subprocess_kwargs", "[", "'stdout'", "]", "=", "subprocess", ".", "PIPE", "\n", "\n", "", "return", "partial", "(", "\n", "run_external", ",", "\n", "command", ",", "\n", "process_result", "=", "process_result", ",", "\n", "prepare_inputs", "=", "prepare_inputs", ",", "\n", "stdout", "=", "stdout", ",", "\n", "subprocess_kwargs", "=", "subprocess_kwargs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ComputationContext.__init__": [[143, 180], ["elfi.utils.random_seed", "elfi_model.ComputationContext._pool.set_context", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.random_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.set_context"], ["def", "__init__", "(", "self", ",", "batch_size", "=", "None", ",", "seed", "=", "None", ",", "pool", "=", "None", ")", ":", "\n", "        ", "\"\"\"Set up a ComputationContext.\n\n        Parameters\n        ----------\n        batch_size : int, optional\n        seed : int, None, 'global', optional\n            When None generates a random integer seed. When `'global'` uses the global\n            numpy random state. Only recommended for debugging.\n        pool : elfi.OutputPool, optional\n            Used for storing output.\n\n        \"\"\"", "\n", "# Check pool context", "\n", "if", "pool", "is", "not", "None", "and", "pool", ".", "has_context", ":", "\n", "            ", "if", "batch_size", "is", "None", ":", "\n", "                ", "batch_size", "=", "pool", ".", "batch_size", "\n", "", "elif", "batch_size", "!=", "pool", ".", "batch_size", ":", "\n", "                ", "raise", "ValueError", "(", "'Pool batch_size differs from the given batch_size!'", ")", "\n", "\n", "", "if", "seed", "is", "None", ":", "\n", "                ", "seed", "=", "pool", ".", "seed", "\n", "", "elif", "seed", "!=", "pool", ".", "seed", ":", "\n", "                ", "raise", "ValueError", "(", "'Pool seed differs from the given seed!'", ")", "\n", "\n", "", "", "self", ".", "_batch_size", "=", "batch_size", "or", "1", "\n", "self", ".", "_seed", "=", "random_seed", "(", ")", "if", "seed", "is", "None", "else", "seed", "\n", "self", ".", "_pool", "=", "pool", "\n", "\n", "# Caches will not be used if they are not found from the caches dict", "\n", "self", ".", "caches", "=", "{", "'executor'", ":", "{", "}", ",", "'sub_seed'", ":", "{", "}", "}", "\n", "\n", "# Count the number of submissions from this context", "\n", "self", ".", "num_submissions", "=", "0", "\n", "\n", "if", "pool", "is", "not", "None", "and", "not", "pool", ".", "has_context", ":", "\n", "            ", "self", ".", "_pool", ".", "set_context", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ComputationContext.pool": [[181, 185], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "pool", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the output pool.\"\"\"", "\n", "return", "self", ".", "_pool", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ComputationContext.batch_size": [[186, 190], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "batch_size", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the batch size.\"\"\"", "\n", "return", "self", ".", "_batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ComputationContext.seed": [[191, 195], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "seed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the random seed.\"\"\"", "\n", "return", "self", ".", "_seed", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ComputationContext.callback": [[196, 207], ["elfi_model.ComputationContext._pool.add_batch"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.add_batch"], ["", "def", "callback", "(", "self", ",", "batch", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Add the batch to pool.\n\n        Parameters\n        ----------\n        batch : dict\n        batch_index : int\n\n        \"\"\"", "\n", "if", "self", ".", "_pool", "is", "not", "None", ":", "\n", "            ", "self", ".", "_pool", ".", "add_batch", "(", "batch", ",", "batch_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.__init__": [[217, 233], ["elfi.model.graphical_model.GraphicalModel.__init__", "elfi_model.random_name"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.random_name"], ["def", "__init__", "(", "self", ",", "name", "=", "None", ",", "observed", "=", "None", ",", "source_net", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the inference model.\n\n        Parameters\n        ----------\n        name : str, optional\n        observed : dict, optional\n            Observed data with node names as keys.\n        source_net : nx.DiGraph, optional\n        set_current : bool, optional\n            Sets this model as the current (default) ELFI model\n\n        \"\"\"", "\n", "super", "(", "ElfiModel", ",", "self", ")", ".", "__init__", "(", "source_net", ")", "\n", "self", ".", "name", "=", "name", "or", "\"model_{}\"", ".", "format", "(", "random_name", "(", ")", ")", "\n", "self", ".", "observed", "=", "observed", "or", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.name": [[239, 243], ["None"], "methods", ["None"], ["", "@", "name", ".", "setter", "\n", "def", "name", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"Set the name of the model.\"\"\"", "\n", "self", ".", "source_net", ".", "graph", "[", "'name'", "]", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.observed": [[249, 262], ["isinstance", "ValueError"], "methods", ["None"], ["", "@", "observed", ".", "setter", "\n", "def", "observed", "(", "self", ",", "observed", ")", ":", "\n", "        ", "\"\"\"Set the observed data of the model.\n\n        Parameters\n        ----------\n        observed : dict\n\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "observed", ",", "dict", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Observed data must be given in a dictionary with the node\"", "\n", "\"name as the key\"", ")", "\n", "", "self", ".", "source_net", ".", "graph", "[", "'observed'", "]", "=", "observed", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.generate": [[263, 298], ["elfi_model.ComputationContext", "elfi.client.get_client", "elfi.client.get_client.compile", "elfi.client.get_client.load_data", "elfi.client.get_client.compute", "elfi_model.ElfiModel.source_net.nodes", "isinstance", "isinstance", "ValueError", "elfi.store.OutputPool", "elfi.store.OutputPool.add_batch", "with_values.keys"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.load_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compute", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.nodes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.add_batch"], ["", "def", "generate", "(", "self", ",", "batch_size", "=", "1", ",", "outputs", "=", "None", ",", "with_values", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate a batch of outputs.\n\n        This method is useful for testing that the ELFI graph works.\n\n        Parameters\n        ----------\n        batch_size : int, optional\n        outputs : list, optional\n        with_values : dict, optional\n            You can specify values for nodes to use when generating data\n        seed : int, optional\n            Defaults to global numpy seed.\n\n        \"\"\"", "\n", "if", "outputs", "is", "None", ":", "\n", "            ", "outputs", "=", "self", ".", "source_net", ".", "nodes", "(", ")", "\n", "", "elif", "isinstance", "(", "outputs", ",", "str", ")", ":", "\n", "            ", "outputs", "=", "[", "outputs", "]", "\n", "", "if", "not", "isinstance", "(", "outputs", ",", "list", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Outputs must be a list of node names'", ")", "\n", "\n", "", "if", "seed", "is", "None", ":", "\n", "            ", "seed", "=", "'global'", "\n", "\n", "", "pool", "=", "None", "\n", "if", "with_values", "is", "not", "None", ":", "\n", "            ", "pool", "=", "OutputPool", "(", "with_values", ".", "keys", "(", ")", ")", "\n", "pool", ".", "add_batch", "(", "with_values", ",", "0", ")", "\n", "", "context", "=", "ComputationContext", "(", "batch_size", ",", "seed", "=", "seed", ",", "pool", "=", "pool", ")", "\n", "\n", "client", "=", "elfi", ".", "client", ".", "get_client", "(", ")", "\n", "compiled_net", "=", "client", ".", "compile", "(", "self", ".", "source_net", ",", "outputs", ")", "\n", "loaded_net", "=", "client", ".", "load_data", "(", "compiled_net", ",", "context", ",", "batch_index", "=", "0", ")", "\n", "return", "client", ".", "compute", "(", "loaded_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_reference": [[299, 309], ["cls.reference", "elfi_model.ElfiModel.get_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.reference", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_node"], ["", "def", "get_reference", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"Return a new reference object for a node in the model.\n\n        Parameters\n        ----------\n        name : str\n\n        \"\"\"", "\n", "cls", "=", "self", ".", "get_node", "(", "name", ")", "[", "'_class'", "]", "\n", "return", "cls", ".", "reference", "(", "name", ",", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_state": [[310, 319], ["None"], "methods", ["None"], ["", "def", "get_state", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"Return the state of the node.\n\n        Parameters\n        ----------\n        name : str\n\n        \"\"\"", "\n", "return", "self", ".", "source_net", ".", "node", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.update_node": [[320, 344], ["super().update_node", "elfi_model.ElfiModel.observed.pop"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.update_node"], ["", "def", "update_node", "(", "self", ",", "name", ",", "updating_name", ")", ":", "\n", "        ", "\"\"\"Update `node` with `updating_node` in the model.\n\n        The node with name `name` gets the state (operation), parents and observed\n        data (if applicable) of the updating_node. The updating node is then removed\n        from the graph.\n\n        Parameters\n        ----------\n        name : str\n        updating_name : str\n\n        \"\"\"", "\n", "update_observed", "=", "False", "\n", "obs", "=", "None", "\n", "if", "updating_name", "in", "self", ".", "observed", ":", "\n", "            ", "update_observed", "=", "True", "\n", "obs", "=", "self", ".", "observed", ".", "pop", "(", "updating_name", ")", "\n", "\n", "", "super", "(", "ElfiModel", ",", "self", ")", ".", "update_node", "(", "name", ",", "updating_name", ")", "\n", "\n", "# Move data to the updated node", "\n", "if", "update_observed", ":", "\n", "            ", "self", ".", "observed", "[", "name", "]", "=", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node": [[345, 356], ["super().remove_node", "elfi_model.ElfiModel.observed.pop"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.remove_node"], ["", "", "def", "remove_node", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"Remove a node from the graph.\n\n        Parameters\n        ----------\n        name : str\n\n        \"\"\"", "\n", "if", "name", "in", "self", ".", "observed", ":", "\n", "            ", "self", ".", "observed", ".", "pop", "(", "name", ")", "\n", "", "super", "(", "ElfiModel", ",", "self", ")", ".", "remove_node", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.parameter_names": [[362, 386], ["set", "elfi_model.ElfiModel.get_state", "len", "ValueError", "set.remove", "elfi_model.ElfiModel.pop"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_state"], ["", "@", "parameter_names", ".", "setter", "\n", "def", "parameter_names", "(", "self", ",", "parameter_names", ")", ":", "\n", "        ", "\"\"\"Set the model parameter nodes.\n\n        For each node name in parameters, the corresponding node will be marked as being a\n        parameter node. Other nodes will be marked as not being parameter nodes.\n\n        Parameters\n        ----------\n        parameter_names : list\n            A list of parameter names\n\n        \"\"\"", "\n", "parameter_names", "=", "set", "(", "parameter_names", ")", "\n", "for", "n", "in", "self", ".", "nodes", ":", "\n", "            ", "state", "=", "self", ".", "get_state", "(", "n", ")", "\n", "if", "n", "in", "parameter_names", ":", "\n", "                ", "parameter_names", ".", "remove", "(", "n", ")", "\n", "state", "[", "'_parameter'", "]", "=", "True", "\n", "", "else", ":", "\n", "                ", "if", "'_parameter'", "in", "state", ":", "\n", "                    ", "state", ".", "pop", "(", "'_parameter'", ")", "\n", "", "", "", "if", "len", "(", "parameter_names", ")", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Parameters {} not found from the model'", ".", "format", "(", "parameter_names", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.copy": [[387, 398], ["super().copy", "elfi_model.random_name"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.random_name"], ["", "", "def", "copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of the ElfiModel instance.\n\n        Returns\n        -------\n        ElfiModel\n\n        \"\"\"", "\n", "kopy", "=", "super", "(", "ElfiModel", ",", "self", ")", ".", "copy", "(", ")", "\n", "kopy", ".", "name", "=", "\"{}_copy_{}\"", ".", "format", "(", "self", ".", "name", ",", "random_name", "(", ")", ")", "\n", "return", "kopy", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.save": [[399, 414], ["pickle.dump", "os.makedirs", "os.path.join", "open"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open"], ["", "def", "save", "(", "self", ",", "prefix", "=", "None", ")", ":", "\n", "        ", "\"\"\"Save the current model to pickled file.\n\n        Parameters\n        ----------\n        prefix : str, optional\n            Path to the directory under which to save the model. Default is the current working\n            directory.\n\n        \"\"\"", "\n", "path", "=", "self", ".", "name", "+", "'.pkl'", "\n", "if", "prefix", "is", "not", "None", ":", "\n", "            ", "os", ".", "makedirs", "(", "prefix", ",", "exist_ok", "=", "True", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "prefix", ",", "path", ")", "\n", "", "pickle", ".", "dump", "(", "self", ",", "open", "(", "path", ",", "\"wb\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load": [[415, 437], ["pickle.load", "os.path.join", "open"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open"], ["", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "name", ",", "prefix", ")", ":", "\n", "        ", "\"\"\"Load the pickled ElfiModel.\n\n        Assumes there exists a file \"name.pkl\" in the current directory.\n\n        Parameters\n        ----------\n        name : str\n            Name of the model file to load (without the .pkl extension).\n        prefix : str\n            Path to directory where the model file is located, optional.\n\n        Returns\n        -------\n        ElfiModel\n\n        \"\"\"", "\n", "path", "=", "name", "+", "'.pkl'", "\n", "if", "prefix", "is", "not", "None", ":", "\n", "            ", "path", "=", "os", ".", "path", ".", "join", "(", "prefix", ",", "path", ")", "\n", "", "return", "pickle", ".", "load", "(", "open", "(", "path", ",", "\"rb\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.__getitem__": [[438, 447], ["elfi_model.ElfiModel.get_reference"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.get_reference"], ["", "def", "__getitem__", "(", "self", ",", "node_name", ")", ":", "\n", "        ", "\"\"\"Return a new reference object for a node in the model.\n\n        Parameters\n        ----------\n        node_name : str\n\n        \"\"\"", "\n", "return", "self", ".", "get_reference", "(", "node_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.InstructionsMapper.state": [[450, 453], ["NotImplementedError"], "methods", ["None"], ["    ", "@", "property", "\n", "def", "state", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.InstructionsMapper.uses_meta": [[458, 461], ["None"], "methods", ["None"], ["", "@", "uses_meta", ".", "setter", "\n", "def", "uses_meta", "(", "self", ",", "val", ")", ":", "\n", "        ", "self", ".", "state", "[", "'_uses_meta'", "]", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.__init__": [[490, 518], ["elfi_model.NodeReference._determine_model", "elfi_model.NodeReference._give_name", "elfi_model.NodeReference.add_node", "elfi_model.NodeReference._init_reference", "elfi_model.NodeReference._add_parents"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._determine_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._give_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._init_reference", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._add_parents"], ["def", "__init__", "(", "self", ",", "*", "parents", ",", "state", "=", "None", ",", "model", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize a NodeReference.\n\n        Parameters\n        ----------\n        parents : variable, optional\n        name : string, optional\n            If name ends in an asterisk '*' character, the asterisk will be replaced with\n            a random string and the name is ensured to be unique within the model.\n        state : dict, optional\n        model : elfi.ElfiModel, optional\n\n        Examples\n        --------\n        >>> node = NodeReference(name='name*') # doctest: +SKIP\n        >>> node.name # doctest: +SKIP\n        name_1f4rgh\n\n        \"\"\"", "\n", "state", "=", "state", "or", "{", "}", "\n", "state", "[", "'_class'", "]", "=", "self", ".", "__class__", "\n", "model", "=", "self", ".", "_determine_model", "(", "model", ",", "parents", ")", "\n", "\n", "name", "=", "self", ".", "_give_name", "(", "name", ",", "model", ")", "\n", "model", ".", "add_node", "(", "name", ",", "state", ")", "\n", "\n", "self", ".", "_init_reference", "(", "name", ",", "model", ")", "\n", "self", ".", "_add_parents", "(", "parents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._add_parents": [[519, 525], ["elfi_model.NodeReference.model.add_edge", "isinstance", "elfi_model.NodeReference._new_name", "elfi_model.Constant"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.add_edge", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._new_name"], ["", "def", "_add_parents", "(", "self", ",", "parents", ")", ":", "\n", "        ", "for", "parent", "in", "parents", ":", "\n", "            ", "if", "not", "isinstance", "(", "parent", ",", "NodeReference", ")", ":", "\n", "                ", "parent_name", "=", "self", ".", "_new_name", "(", "'_'", "+", "self", ".", "name", ")", "\n", "parent", "=", "Constant", "(", "parent", ",", "name", "=", "parent_name", ",", "model", "=", "self", ".", "model", ")", "\n", "", "self", ".", "model", ".", "add_edge", "(", "parent", ".", "name", ",", "self", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._determine_model": [[526, 542], ["ValueError", "isinstance", "elfi_model.get_default_model", "isinstance", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.get_default_model"], ["", "", "def", "_determine_model", "(", "self", ",", "model", ",", "parents", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "model", ",", "ElfiModel", ")", "and", "model", "is", "not", "None", ":", "\n", "            ", "return", "ValueError", "(", "'Invalid model passed {}'", ".", "format", "(", "model", ")", ")", "\n", "\n", "# Check that parents belong to the same model and inherit the model if needed", "\n", "", "for", "p", "in", "parents", ":", "\n", "            ", "if", "isinstance", "(", "p", ",", "NodeReference", ")", ":", "\n", "                ", "if", "model", "is", "None", ":", "\n", "                    ", "model", "=", "p", ".", "model", "\n", "", "elif", "model", "!=", "p", ".", "model", ":", "\n", "                    ", "raise", "ValueError", "(", "'Parents are from different models!'", ")", "\n", "\n", "", "", "", "if", "model", "is", "None", ":", "\n", "            ", "model", "=", "get_default_model", "(", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.parents": [[543, 554], ["elfi_model.NodeReference.model.get_parents"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_parents"], ["", "@", "property", "\n", "def", "parents", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get all positional parent nodes (inputs) of this node.\n\n        Returns\n        -------\n        parents : list\n            List of positional parents\n\n        \"\"\"", "\n", "return", "[", "self", ".", "model", "[", "p", "]", "for", "p", "in", "self", ".", "model", ".", "get_parents", "(", "self", ".", "name", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.reference": [[555, 573], ["cls.__new__", "cls.__new__._init_reference"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._init_reference"], ["", "@", "classmethod", "\n", "def", "reference", "(", "cls", ",", "name", ",", "model", ")", ":", "\n", "        ", "\"\"\"Construct a reference for an existing node in the model.\n\n        Parameters\n        ----------\n        name : string\n            name of the node\n        model : ElfiModel\n\n        Returns\n        -------\n        NodePointer instance\n\n        \"\"\"", "\n", "instance", "=", "cls", ".", "__new__", "(", "cls", ")", "\n", "instance", ".", "_init_reference", "(", "name", ",", "model", ")", "\n", "return", "instance", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.become": [[574, 597], ["elfi_model.NodeReference.model.update_node", "elfi_model.NodeReference.state.get", "ValueError", "isinstance"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.update_node"], ["", "def", "become", "(", "self", ",", "other_node", ")", ":", "\n", "        ", "\"\"\"Make this node become the `other_node`.\n\n        The children of this node will be preserved.\n\n        Parameters\n        ----------\n        other_node : NodeReference\n\n        \"\"\"", "\n", "if", "other_node", ".", "model", "is", "not", "self", ".", "model", ":", "\n", "            ", "raise", "ValueError", "(", "'The other node belongs to a different model'", ")", "\n", "\n", "", "self", ".", "model", ".", "update_node", "(", "self", ".", "name", ",", "other_node", ".", "name", ")", "\n", "\n", "# Update the reference class", "\n", "_class", "=", "self", ".", "state", ".", "get", "(", "'_class'", ",", "NodeReference", ")", "\n", "if", "not", "isinstance", "(", "self", ",", "_class", ")", ":", "\n", "            ", "self", ".", "__class__", "=", "_class", "\n", "\n", "# Update also the other node reference", "\n", "", "other_node", ".", "name", "=", "self", ".", "name", "\n", "other_node", ".", "model", "=", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._init_reference": [[598, 609], ["None"], "methods", ["None"], ["", "def", "_init_reference", "(", "self", ",", "name", ",", "model", ")", ":", "\n", "        ", "\"\"\"Initialize all internal variables of the instance.\n\n        Parameters\n        ----------\n        name : name of the node in the model\n        model : ElfiModel\n\n        \"\"\"", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate": [[610, 623], ["elfi_model.NodeReference.model.generate"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["", "def", "generate", "(", "self", ",", "batch_size", "=", "1", ",", "with_values", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate output from this node.\n\n        Useful for testing.\n\n        Parameters\n        ----------\n        batch_size : int, optional\n        with_values : dict, optional\n\n        \"\"\"", "\n", "result", "=", "self", ".", "model", ".", "generate", "(", "batch_size", ",", "self", ".", "name", ",", "with_values", "=", "with_values", ")", "\n", "return", "result", "[", "self", ".", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._give_name": [[624, 645], ["elfi_model.NodeReference._inspect_name", "model.has_node", "elfi_model.NodeReference._new_name", "elfi_model.NodeReference._new_name", "logger.warning"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._inspect_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._new_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._new_name"], ["", "def", "_give_name", "(", "self", ",", "name", ",", "model", ")", ":", "\n", "        ", "if", "name", "is", "not", "None", ":", "\n", "            ", "if", "name", "[", "-", "1", "]", "==", "'*'", ":", "\n", "# Generate unique name", "\n", "                ", "name", "=", "self", ".", "_new_name", "(", "name", "[", ":", "-", "1", "]", ",", "model", ")", "\n", "", "return", "name", "\n", "\n", "", "try", ":", "\n", "            ", "name", "=", "self", ".", "_inspect_name", "(", ")", "\n", "", "except", "BaseException", ":", "\n", "            ", "logger", ".", "warning", "(", "\"Automatic name inspection failed, using a random name \"", "\n", "\"instead. This may be caused by using an interactive Python \"", "\n", "\"shell. You can provide a name parameter e.g. \"", "\n", "\"elfi.Prior('uniform', name='nodename') to suppress this \"", "\n", "\"warning.\"", ")", "\n", "name", "=", "None", "\n", "\n", "", "if", "name", "is", "None", "or", "model", ".", "has_node", "(", "name", ")", ":", "\n", "            ", "name", "=", "self", ".", "_new_name", "(", "model", "=", "model", ")", "\n", "\n", "", "return", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._inspect_name": [[646, 677], ["inspect.currentframe", "inspect.getframeinfo", "re.match", "re.match", "inspect.getframeinfo", "re.match.groups"], "methods", ["None"], ["", "def", "_inspect_name", "(", "self", ")", ":", "\n", "        ", "\"\"\"Magic method that tries to infer the name from the code.\n\n        Does not work in interactive python shell.\n        \"\"\"", "\n", "# Test if context info is available and try to give the same name as the variable", "\n", "# Please note that this is only a convenience method which is not guaranteed to", "\n", "# work in all cases. If you require a specific name, pass the name argument.", "\n", "frame", "=", "inspect", ".", "currentframe", "(", ")", "\n", "if", "frame", "is", "None", ":", "\n", "            ", "return", "None", "\n", "\n", "# Frames are available", "\n", "# Take the callers frame", "\n", "", "frame", "=", "frame", ".", "f_back", ".", "f_back", ".", "f_back", "\n", "info", "=", "inspect", ".", "getframeinfo", "(", "frame", ",", "1", ")", "\n", "\n", "# Skip super calls to find the assignment frame", "\n", "while", "re", ".", "match", "(", "'\\s*super\\('", ",", "info", ".", "code_context", "[", "0", "]", ")", ":", "\n", "            ", "frame", "=", "frame", ".", "f_back", "\n", "info", "=", "inspect", ".", "getframeinfo", "(", "frame", ",", "1", ")", "\n", "\n", "# Match simple direct assignment with the class name, no commas or semicolons", "\n", "# Also do not accept a name starting with an underscore", "\n", "", "rex", "=", "'\\s*([^\\W_][\\w]*)\\s*=\\s*\\w?[\\w\\.]*{}\\('", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ")", "\n", "match", "=", "re", ".", "match", "(", "rex", ",", "info", ".", "code_context", "[", "0", "]", ")", "\n", "if", "match", ":", "\n", "            ", "name", "=", "match", ".", "groups", "(", ")", "[", "0", "]", "\n", "return", "name", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference._new_name": [[678, 687], ["elfi_model.NodeReference.__class__.__name__.lower", "elfi_model.random_name", "model.has_node"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.random_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node"], ["", "", "def", "_new_name", "(", "self", ",", "basename", "=", "''", ",", "model", "=", "None", ")", ":", "\n", "        ", "model", "=", "model", "or", "self", ".", "model", "\n", "if", "not", "basename", ":", "\n", "            ", "basename", "=", "'_{}'", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ".", "lower", "(", ")", ")", "\n", "", "while", "True", ":", "\n", "            ", "name", "=", "\"{}_{}\"", ".", "format", "(", "basename", ",", "random_name", "(", ")", ")", "\n", "if", "not", "model", ".", "has_node", "(", "name", ")", ":", "\n", "                ", "break", "\n", "", "", "return", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.state": [[688, 694], ["elfi_model.NodeReference.model.get_node", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.get_node"], ["", "@", "property", "\n", "def", "state", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the state dictionary of the node.\"\"\"", "\n", "if", "self", ".", "model", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'{} {} is not initialized'", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ",", "self", ".", "name", ")", ")", "\n", "", "return", "self", ".", "model", ".", "get_node", "(", "self", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.__getitem__": [[695, 698], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Get item from the state dict of the node.\"\"\"", "\n", "return", "self", ".", "state", "[", "item", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.__setitem__": [[699, 702], ["None"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "item", ",", "value", ")", ":", "\n", "        ", "\"\"\"Set item into the state dict of the node.\"\"\"", "\n", "self", ".", "state", "[", "item", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.__repr__": [[703, 706], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a representation comprised of the names of the class and the node.\"\"\"", "\n", "return", "\"{}(name='{}')\"", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ",", "self", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.__str__": [[707, 710], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the name of the node.\"\"\"", "\n", "return", "self", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.StochasticMixin.__init__": [[718, 722], ["elfi_model.NodeReference.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "*", "parents", ",", "state", ",", "**", "kwargs", ")", ":", "\n", "# Flag that this node is stochastic", "\n", "        ", "state", "[", "'_stochastic'", "]", "=", "True", "\n", "super", "(", "StochasticMixin", ",", "self", ")", ".", "__init__", "(", "*", "parents", ",", "state", "=", "state", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ObservableMixin.__init__": [[732, 740], ["elfi_model.NodeReference.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "*", "parents", ",", "state", ",", "observed", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "# Flag that this node can be observed", "\n", "        ", "state", "[", "'_observable'", "]", "=", "True", "\n", "super", "(", "ObservableMixin", ",", "self", ")", ".", "__init__", "(", "*", "parents", ",", "state", "=", "state", ",", "**", "kwargs", ")", "\n", "\n", "# Set the observed value", "\n", "if", "observed", "is", "not", "None", ":", "\n", "            ", "self", ".", "model", ".", "observed", "[", "self", ".", "name", "]", "=", "observed", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ObservableMixin.observed": [[741, 746], ["elfi.utils.observed_name", "elfi_model.ObservableMixin.model.generate"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.observed_name", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.NodeReference.generate"], ["", "", "@", "property", "\n", "def", "observed", "(", "self", ")", ":", "\n", "        ", "obs_name", "=", "observed_name", "(", "self", ".", "name", ")", "\n", "result", "=", "self", ".", "model", ".", "generate", "(", "0", ",", "obs_name", ")", "\n", "return", "result", "[", "obs_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.Constant.__init__": [[754, 765], ["dict", "elfi_model.NodeReference.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "value", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a node holding a constant value.\n\n        Parameters\n        ----------\n        value\n            The constant value of the node.\n\n        \"\"\"", "\n", "state", "=", "dict", "(", "_output", "=", "value", ")", "\n", "super", "(", "Constant", ",", "self", ")", ".", "__init__", "(", "state", "=", "state", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.Operation.__init__": [[770, 781], ["dict", "elfi_model.NodeReference.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "fn", ",", "*", "parents", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a node that performs an operation.\n\n        Parameters\n        ----------\n        fn : callable\n            The operation of the node.\n\n        \"\"\"", "\n", "state", "=", "dict", "(", "_operation", "=", "fn", ")", "\n", "super", "(", "Operation", ",", "self", ")", ".", "__init__", "(", "*", "parents", ",", "state", "=", "state", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.RandomVariable.__init__": [[786, 800], ["dict", "elfi_model.RandomVariable.compile_operation", "elfi_model.StochasticMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.RandomVariable.compile_operation", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "distribution", ",", "*", "params", ",", "size", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a node that represents a random variable.\n\n        Parameters\n        ----------\n        distribution : str or scipy-like distribution object\n        params : params of the distribution\n        size : int, tuple or None, optional\n            Output size of a single random draw.\n\n        \"\"\"", "\n", "state", "=", "dict", "(", "distribution", "=", "distribution", ",", "size", "=", "size", ",", "_uses_batch_size", "=", "True", ")", "\n", "state", "[", "'_operation'", "]", "=", "self", ".", "compile_operation", "(", "state", ")", "\n", "super", "(", "RandomVariable", ",", "self", ")", ".", "__init__", "(", "*", "params", ",", "state", "=", "state", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.RandomVariable.compile_operation": [[801, 826], ["isinstance", "functools.partial", "elfi.utils.scipy_from_str", "hasattr", "ValueError", "isinstance"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.scipy_from_str"], ["", "@", "staticmethod", "\n", "def", "compile_operation", "(", "state", ")", ":", "\n", "        ", "\"\"\"Compile a callable operation that samples the associated distribution.\n\n        Parameters\n        ----------\n        state : dict\n\n        \"\"\"", "\n", "size", "=", "state", "[", "'size'", "]", "\n", "distribution", "=", "state", "[", "'distribution'", "]", "\n", "if", "not", "(", "size", "is", "None", "or", "isinstance", "(", "size", ",", "tuple", ")", ")", ":", "\n", "            ", "size", "=", "(", "size", ",", ")", "\n", "\n", "# Note: sending the scipy distribution object also pickles the global numpy random", "\n", "# state with it. If this needs to be avoided, the object needs to be constructed", "\n", "# on the worker.", "\n", "", "if", "isinstance", "(", "distribution", ",", "str", ")", ":", "\n", "            ", "distribution", "=", "scipy_from_str", "(", "distribution", ")", "\n", "\n", "", "if", "not", "hasattr", "(", "distribution", ",", "'rvs'", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Distribution {} \"", "\"must implement a rvs method\"", ".", "format", "(", "distribution", ")", ")", "\n", "\n", "", "op", "=", "partial", "(", "rvs_from_distribution", ",", "distribution", "=", "distribution", ",", "size", "=", "size", ")", "\n", "return", "op", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.RandomVariable.distribution": [[827, 834], ["isinstance", "elfi.utils.scipy_from_str"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.scipy_from_str"], ["", "@", "property", "\n", "def", "distribution", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the distribution object.\"\"\"", "\n", "distribution", "=", "self", "[", "'distribution'", "]", "\n", "if", "isinstance", "(", "distribution", ",", "str", ")", ":", "\n", "            ", "distribution", "=", "scipy_from_str", "(", "distribution", ")", "\n", "", "return", "distribution", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.RandomVariable.size": [[835, 839], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the size of the output from the distribution.\"\"\"", "\n", "return", "self", "[", "'size'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.RandomVariable.__repr__": [[840, 854], ["isinstance", "hasattr", "isinstance", "elfi_model.NodeReference.__repr__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a string representation of the node.\"\"\"", "\n", "d", "=", "self", ".", "distribution", "\n", "\n", "if", "isinstance", "(", "d", ",", "str", ")", ":", "\n", "            ", "name", "=", "\"'{}'\"", ".", "format", "(", "d", ")", "\n", "", "elif", "hasattr", "(", "d", ",", "'name'", ")", ":", "\n", "            ", "name", "=", "\"'{}'\"", ".", "format", "(", "d", ".", "name", ")", "\n", "", "elif", "isinstance", "(", "d", ",", "type", ")", ":", "\n", "            ", "name", "=", "d", ".", "__name__", "\n", "", "else", ":", "\n", "            ", "name", "=", "d", ".", "__class__", ".", "__name__", "\n", "\n", "", "return", "super", "(", "RandomVariable", ",", "self", ")", ".", "__repr__", "(", ")", "[", "0", ":", "-", "1", "]", "+", "\", {})\"", ".", "format", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.Prior.__init__": [[859, 890], ["elfi_model.RandomVariable.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "distribution", ",", "*", "params", ",", "size", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a Prior.\n\n        Parameters\n        ----------\n        distribution : str, object\n            Any distribution from `scipy.stats`, either as a string or an object. Objects\n            must implement at least an `rvs` method with signature\n            `rvs(*parameters, size, random_state)`. Can also be a custom distribution\n            object that implements at least an `rvs` method. Many of the algorithms also\n            require the `pdf` and `logpdf` methods to be available.\n        size : int, tuple or None, optional\n            Output size of a single random draw.\n        params\n            Parameters of the prior distribution\n        kwargs\n\n        Notes\n        -----\n        The parameters of the `scipy` distributions (typically `loc` and `scale`) must be\n        given as positional arguments.\n\n        Many algorithms (e.g. SMC) also require a `pdf` method for the distribution. In\n        general the definition of the distribution is a subset of\n        `scipy.stats.rv_continuous`.\n\n        Scipy distributions: https://docs.scipy.org/doc/scipy-0.19.0/reference/stats.html\n\n        \"\"\"", "\n", "super", "(", "Prior", ",", "self", ")", ".", "__init__", "(", "distribution", ",", "*", "params", ",", "size", "=", "size", ",", "**", "kwargs", ")", "\n", "self", "[", "'_parameter'", "]", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.Simulator.__init__": [[898, 912], ["dict", "elfi_model.StochasticMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "fn", ",", "*", "params", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a Simulator.\n\n        Parameters\n        ----------\n        fn : callable\n            Simulator function with a signature `sim(*params, batch_size, random_state)`\n        params\n            Input parameters for the simulator.\n        kwargs\n\n        \"\"\"", "\n", "state", "=", "dict", "(", "_operation", "=", "fn", ",", "_uses_batch_size", "=", "True", ")", "\n", "super", "(", "Simulator", ",", "self", ")", ".", "__init__", "(", "*", "params", ",", "state", "=", "state", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.Summary.__init__": [[921, 937], ["dict", "elfi_model.ObservableMixin.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "fn", ",", "*", "parents", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a Summary.\n\n        Parameters\n        ----------\n        fn : callable\n            Summary function with a signature `summary(*parents)`\n        parents\n            Input data for the summary function.\n        kwargs\n\n        \"\"\"", "\n", "if", "not", "parents", ":", "\n", "            ", "raise", "ValueError", "(", "'This node requires that at least one parent is specified.'", ")", "\n", "", "state", "=", "dict", "(", "_operation", "=", "fn", ")", "\n", "super", "(", "Summary", ",", "self", ")", ".", "__init__", "(", "*", "parents", ",", "state", "=", "state", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.Discrepancy.__init__": [[945, 970], ["dict", "elfi_model.NodeReference.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "discrepancy", ",", "*", "parents", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a Discrepancy.\n\n        Parameters\n        ----------\n        discrepancy : callable\n            Signature of the discrepancy function is of the form:\n            `discrepancy(summary_1, summary_2, ..., observed)`, where summaries are\n            arrays containing `batch_size` simulated values and observed is a tuple\n            (observed_summary_1, observed_summary_2, ...). The callable object should\n            return a vector of discrepancies between the simulated summaries and the\n            observed summaries.\n        *parents\n            Typically the summaries for the discrepancy function.\n        **kwargs\n\n        See Also\n        --------\n        elfi.Distance : creating common distance discrepancies.\n\n        \"\"\"", "\n", "if", "not", "parents", ":", "\n", "            ", "raise", "ValueError", "(", "'This node requires that at least one parent is specified.'", ")", "\n", "", "state", "=", "dict", "(", "_operation", "=", "discrepancy", ",", "_uses_observed", "=", "True", ")", "\n", "super", "(", "Discrepancy", ",", "self", ")", ".", "__init__", "(", "*", "parents", ",", "state", "=", "state", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.Distance.__init__": [[976, 1044], ["isinstance", "functools.partial", "elfi_model.Discrepancy.__init__", "ValueError", "dict", "functools.partial", "ValueError", "kwargs.keys", "ValueError", "kwargs.keys", "kwargs.pop", "kwargs.keys", "ValueError", "kwargs.keys"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "distance", ",", "*", "summaries", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a distance node of an ELFI graph.\n\n        This class contains many common distance implementations through scipy.\n\n        Parameters\n        ----------\n        distance : str, callable\n            If string it must be a valid metric from `scipy.spatial.distance.cdist`.\n\n            Is a callable, the signature must be `distance(X, Y)`, where X is a n x m\n            array containing n simulated values (summaries) in rows and Y is a 1 x m array\n            that contains the observed values (summaries). The callable should return\n            a vector of distances between the simulated summaries and the observed\n            summaries.\n        *summaries\n            Summary nodes of the model.\n        **kwargs\n            Additional parameters may be required depending on the chosen distance.\n            See the scipy documentation. (The support is not exhaustive.)\n            ELFI-related kwargs are passed on to elfi.Discrepancy.\n\n        Examples\n        --------\n        >>> d = elfi.Distance('euclidean', summary1, summary2...) # doctest: +SKIP\n\n        >>> d = elfi.Distance('minkowski', summary, p=1) # doctest: +SKIP\n\n        Notes\n        -----\n        Your summaries need to be scalars or vectors for this method to work. The\n        summaries will be first stacked to a single 2D array with the simulated\n        summaries in the rows for every simulation and the distance is taken row\n        wise against the corresponding observed summary vector.\n\n        Scipy distances:\n        https://docs.scipy.org/doc/scipy/reference/generated/generated/scipy.spatial.distance.cdist.html  # noqa\n\n        See Also\n        --------\n        elfi.Discrepancy : A general discrepancy node\n\n        \"\"\"", "\n", "if", "not", "summaries", ":", "\n", "            ", "raise", "ValueError", "(", "\"This node requires that at least one parent is specified.\"", ")", "\n", "\n", "", "if", "isinstance", "(", "distance", ",", "str", ")", ":", "\n", "            ", "cdist_kwargs", "=", "dict", "(", "metric", "=", "distance", ")", "\n", "if", "distance", "==", "'wminkowski'", "and", "'w'", "not", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Parameter w must be specified for distance=wminkowski.'", ")", "\n", "", "elif", "distance", "==", "'seuclidean'", "and", "'V'", "not", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Parameter V must be specified for distance=seuclidean.'", ")", "\n", "", "elif", "distance", "==", "'mahalanobis'", "and", "'VI'", "not", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Parameter VI must be specified for distance=mahalanobis.'", ")", "\n", "\n", "# extract appropriate keyword arguments (depends on distance, not exhaustive!)", "\n", "", "for", "key", "in", "[", "'p'", ",", "'w'", ",", "'V'", ",", "'VI'", "]", ":", "\n", "                ", "if", "key", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "                    ", "cdist_kwargs", "[", "key", "]", "=", "kwargs", ".", "pop", "(", "key", ")", "\n", "\n", "", "", "dist_fn", "=", "partial", "(", "scipy", ".", "spatial", ".", "distance", ".", "cdist", ",", "**", "cdist_kwargs", ")", "\n", "", "else", ":", "\n", "            ", "dist_fn", "=", "distance", "\n", "\n", "", "discrepancy", "=", "partial", "(", "distance_as_discrepancy", ",", "dist_fn", ")", "\n", "super", "(", "Distance", ",", "self", ")", ".", "__init__", "(", "discrepancy", ",", "*", "summaries", ",", "**", "kwargs", ")", "\n", "# Store the original passed distance", "\n", "self", ".", "state", "[", "'distance'", "]", "=", "distance", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.get_default_model": [[36, 45], ["elfi_model.ElfiModel"], "function", ["None"], ["def", "get_default_model", "(", ")", ":", "\n", "    ", "\"\"\"Return the current default ``ElfiModel`` instance.\n\n    New nodes will be added to this model by default.\n    \"\"\"", "\n", "global", "_default_model", "\n", "if", "_default_model", "is", "None", ":", "\n", "        ", "_default_model", "=", "ElfiModel", "(", ")", "\n", "", "return", "_default_model", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.set_default_model": [[47, 64], ["elfi_model.ElfiModel", "isinstance", "ValueError"], "function", ["None"], ["", "def", "set_default_model", "(", "model", "=", "None", ")", ":", "\n", "    ", "\"\"\"Set the current default ``ElfiModel`` instance.\n\n    New nodes will be placed the given model by default.\n\n    Parameters\n    ----------\n    model : ElfiModel, optional\n        If None, creates a new ``ElfiModel``.\n\n    \"\"\"", "\n", "global", "_default_model", "\n", "if", "model", "is", "None", ":", "\n", "        ", "model", "=", "ElfiModel", "(", ")", "\n", "", "if", "not", "isinstance", "(", "model", ",", "ElfiModel", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'{} is not an instance of ElfiModel'", ".", "format", "(", "ElfiModel", ")", ")", "\n", "", "_default_model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model": [[66, 83], ["elfi_model.ElfiModel", "elfi_model.set_default_model"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.set_default_model"], ["", "def", "new_model", "(", "name", "=", "None", ",", "set_default", "=", "True", ")", ":", "\n", "    ", "\"\"\"Create a new ``ElfiModel`` instance.\n\n    In addition to making a new ElfiModel instance, this method sets the new instance as\n    the default for new nodes.\n\n    Parameters\n    ----------\n    name : str, optional\n    set_default : bool, optional\n        Whether to set the newly created model as the current model.\n\n    \"\"\"", "\n", "model", "=", "ElfiModel", "(", "name", "=", "name", ")", "\n", "if", "set_default", ":", "\n", "        ", "set_default_model", "(", "model", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.load_model": [[85, 109], ["elfi_model.ElfiModel.load", "elfi_model.set_default_model"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.ElfiModel.load", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.set_default_model"], ["", "def", "load_model", "(", "name", ",", "prefix", "=", "None", ",", "set_default", "=", "True", ")", ":", "\n", "    ", "\"\"\"Load the pickled ElfiModel.\n\n    Assumes there exists a file \"name.pkl\" in the current directory. Also sets the loaded\n    model as the default model for new nodes.\n\n    Parameters\n    ----------\n    name : str\n        Name of the model file to load (without the .pkl extension).\n    prefix : str\n        Path to directory where the model file is located, optional.\n    set_default : bool, optional\n        Set the loaded model as the default model. Default is True.\n\n    Returns\n    -------\n    ElfiModel\n\n    \"\"\"", "\n", "model", "=", "ElfiModel", ".", "load", "(", "name", ",", "prefix", "=", "prefix", ")", "\n", "if", "set_default", ":", "\n", "        ", "set_default_model", "(", "model", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.random_name": [[111, 121], ["str", "uuid.uuid4"], "function", ["None"], ["", "def", "random_name", "(", "length", "=", "4", ",", "prefix", "=", "''", ")", ":", "\n", "    ", "\"\"\"Generate a random string.\n\n    Parameters\n    ----------\n    length : int, optional\n    prefix : str, optional\n\n    \"\"\"", "\n", "return", "prefix", "+", "str", "(", "uuid", ".", "uuid4", "(", ")", ".", "hex", "[", "0", ":", "length", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.extensions.ScipyLikeDistribution.__init__": [[21, 31], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", "=", "None", ")", ":", "\n", "        ", "\"\"\"Constuctor (optional, only if instances are meant to be used).\n\n        Parameters\n        ----------\n        name : str\n            Name of the distribution.\n\n        \"\"\"", "\n", "self", ".", "_name", "=", "name", "or", "self", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.extensions.ScipyLikeDistribution.rvs": [[32, 50], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "rvs", "(", "this", ",", "*", "params", ",", "size", "=", "1", ",", "random_state", ")", ":", "\n", "        ", "\"\"\"Generate random variates.\n\n        Parameters\n        ----------\n        param1, param2, ... : array_like\n            Parameter(s) of the distribution\n        size : int or tuple of ints, optional\n        random_state : RandomState\n\n        Returns\n        -------\n        rvs : ndarray\n            Random variates of given size.\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.extensions.ScipyLikeDistribution.pdf": [[51, 69], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "pdf", "(", "this", ",", "x", ",", "*", "params", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Probability density function at x.\n\n        Parameters\n        ----------\n        x : array_like\n           points where to evaluate the pdf\n        param1, param2, ... : array_like\n           parameters of the model\n\n        Returns\n        -------\n        pdf : ndarray\n           Probability density function evaluated at x\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.extensions.ScipyLikeDistribution.logpdf": [[70, 95], ["this.pdf", "numpy.warnings.catch_warnings", "numpy.warnings.filterwarnings", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf"], ["", "@", "classmethod", "\n", "def", "logpdf", "(", "this", ",", "x", ",", "*", "params", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Log of the probability density function at x.\n\n        Parameters\n        ----------\n        x : array_like\n            Points where to evaluate the logpdf.\n        param1, param2, ... : array_like\n            Parameters of the model.\n        kwargs\n\n        Returns\n        -------\n        logpdf : ndarray\n           Log of the probability density function evaluated at x.\n\n        \"\"\"", "\n", "p", "=", "this", ".", "pdf", "(", "x", ",", "*", "params", ",", "**", "kwargs", ")", "\n", "\n", "with", "np", ".", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "np", ".", "warnings", ".", "filterwarnings", "(", "'ignore'", ")", "\n", "ans", "=", "np", ".", "log", "(", "p", ")", "\n", "\n", "", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.extensions.ScipyLikeDistribution.name": [[96, 105], ["hasattr", "isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "this", ")", ":", "\n", "        ", "\"\"\"Return the name of the distribution.\"\"\"", "\n", "if", "hasattr", "(", "this", ",", "'_name'", ")", ":", "\n", "            ", "return", "this", ".", "_name", "\n", "", "elif", "isinstance", "(", "this", ",", "type", ")", ":", "\n", "            ", "return", "this", ".", "__name__", "\n", "", "else", ":", "\n", "            ", "return", "this", ".", "__class__", ".", "__name__", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter.add_pdf_gradient_nodes": [[12, 39], ["augmenter._add_distribution_nodes"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter._add_distribution_nodes"], ["def", "add_pdf_gradient_nodes", "(", "model", ",", "log", "=", "False", ",", "nodes", "=", "None", ")", ":", "\n", "    ", "\"\"\"Add gradient nodes for distribution nodes to the model.\n\n    Returns the node names.\n\n    By default this gives the pdfs of the generated model parameters.\n\n    Parameters\n    ----------\n    model : elfi.ElfiModel\n    log : bool, optional\n        Use gradient of logpdf, default False.\n    nodes : list, optional\n        List of distribution node names. Default is `model.parameters`.\n\n    Returns\n    -------\n    gradients : list\n        List of gradient node names.\n\n    \"\"\"", "\n", "nodes", "=", "nodes", "or", "model", ".", "parameter_names", "\n", "gradattr", "=", "'gradient_pdf'", "if", "log", "is", "False", "else", "'gradient_logpdf'", "\n", "\n", "grad_nodes", "=", "_add_distribution_nodes", "(", "model", ",", "nodes", ",", "gradattr", ")", "\n", "\n", "return", "[", "g", ".", "name", "for", "g", "in", "grad_nodes", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter.add_pdf_nodes": [[42, 78], ["augmenter._add_distribution_nodes", "augmenter.add_reduce_node", "augmenter.add_reduce_node"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter._add_distribution_nodes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter.add_reduce_node", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter.add_reduce_node"], ["", "def", "add_pdf_nodes", "(", "model", ",", "joint", "=", "True", ",", "log", "=", "False", ",", "nodes", "=", "None", ")", ":", "\n", "    ", "\"\"\"Add pdf nodes for distribution nodes to the model.\n\n    Returns the node names.\n\n    By default this gives the pdfs of the generated model parameters.\n\n    Parameters\n    ----------\n    model : elfi.ElfiModel\n    joint : bool, optional\n        If True (default) return a the joint pdf of the priors\n    log : bool, optional\n        Use logpdf, default False.\n    nodes : list, optional\n        List of distribution node names. Default is `model.parameters`.\n\n    Returns\n    -------\n    pdfs : list\n        List of node names. Either only the joint pdf node name or the separate pdf node\n        names depending on the `joint` argument.\n\n    \"\"\"", "\n", "nodes", "=", "nodes", "or", "model", ".", "parameter_names", "\n", "pdfattr", "=", "'pdf'", "if", "log", "is", "False", "else", "'logpdf'", "\n", "\n", "pdfs", "=", "_add_distribution_nodes", "(", "model", ",", "nodes", ",", "pdfattr", ")", "\n", "\n", "if", "joint", ":", "\n", "        ", "if", "log", ":", "\n", "            ", "return", "[", "add_reduce_node", "(", "model", ",", "pdfs", ",", "add", ",", "'_joint_{}*'", ".", "format", "(", "pdfattr", ")", ")", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "add_reduce_node", "(", "model", ",", "pdfs", ",", "mul", ",", "'_joint_{}*'", ".", "format", "(", "pdfattr", ")", ")", "]", "\n", "", "", "else", ":", "\n", "        ", "return", "[", "pdf", ".", "name", "for", "pdf", "in", "pdfs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter._add_distribution_nodes": [[80, 88], ["getattr", "distribution_nodes.append", "elfi.model.elfi_model.Operation"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "", "def", "_add_distribution_nodes", "(", "model", ",", "nodes", ",", "attr", ")", ":", "\n", "    ", "distribution_nodes", "=", "[", "]", "\n", "for", "n", "in", "nodes", ":", "\n", "        ", "node", "=", "model", "[", "n", "]", "\n", "op", "=", "getattr", "(", "node", ".", "distribution", ",", "attr", ")", "\n", "distribution_nodes", ".", "append", "(", "\n", "Operation", "(", "op", ",", "*", "(", "[", "node", "]", "+", "node", ".", "parents", ")", ",", "model", "=", "model", ",", "name", "=", "'_{}_{}'", ".", "format", "(", "n", ",", "attr", ")", ")", ")", "\n", "", "return", "distribution_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter.add_reduce_node": [[90, 113], ["elfi.model.elfi_model.Operation", "toolz.functoolz.compose", "isinstance", "functools.partial", "operator.add", "operator.mul"], "function", ["None"], ["", "def", "add_reduce_node", "(", "model", ",", "nodes", ",", "reduce_operation", ",", "name", ")", ":", "\n", "    ", "\"\"\"Reduce the output from a collection of nodes.\n\n    Parameters\n    ----------\n    model : elfi.ElfiModel\n    nodes : list\n        Either a list of node names or a list of node reference objects\n    reduce_operation : callable\n    name : str\n        Name for the reduce node\n\n    Returns\n    -------\n    name : str\n        name of the new node\n\n    \"\"\"", "\n", "name", "=", "'_reduce*'", "if", "name", "is", "None", "else", "name", "\n", "nodes", "=", "[", "n", "if", "isinstance", "(", "n", ",", "NodeReference", ")", "else", "model", "[", "n", "]", "for", "n", "in", "nodes", "]", "\n", "op", "=", "Operation", "(", "\n", "compose", "(", "partial", "(", "reduce", ",", "reduce_operation", ")", ",", "args_to_tuple", ")", ",", "*", "nodes", ",", "model", "=", "model", ",", "name", "=", "name", ")", "\n", "return", "op", ".", "name", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.utils.rvs_from_distribution": [[6, 35], ["distribution.rvs"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["import", "ot", ",", "scipy", "\n", "\n", "import", "matplotlib", "as", "mpl", "\n", "\n", "import", "numpy", "as", "np", "\n", "import", "pandas", "as", "pd", "\n", "from", "os", "import", "path", "\n", "from", "pathlib", "import", "Path", "\n", "\n", "from", "kelfi", ".", "kernel_means_inference", "import", "kernel_means_weights", ",", "approximate_marginal_kernel_means_likelihood", "\n", "from", "kelfi", ".", "kernel_means_inference", "import", "approximate_kernel_means_posterior_embedding", ",", "kernel_herding", "\n", "from", "kelfi", ".", "kernel_means_learning", "import", "kernel_means_hyperparameter_learning", "\n", "from", "kelfi", ".", "kernels", "import", "gaussian_kernel_gramix", "\n", "\n", "\n", "import", "warnings", "\n", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ")", "\n", "\n", "\n", "# =====================", "\n", "# PLOTTING FUNCTIONS:", "\n", "# =====================", "\n", "\n", "mpl", ".", "rcParams", "[", "'figure.dpi'", "]", "=", "300", "\n", "\n", "\n", "# sample posterior of the trained surrogate model", "\n", "def", "get_weighted_samples", "(", "post", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "post", ".", "prior", ".", "rvs", "(", "size", "=", "N", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.utils.distance_as_discrepancy": [[37, 53], ["numpy.column_stack", "numpy.concatenate", "dist", "d.reshape.reshape", "numpy.atleast_2d", "ValueError"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["        ", "theta", "=", "theta", ".", "reshape", "(", "theta", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "\n", "", "weights", "=", "post", ".", "_unnormalized_likelihood", "(", "theta", ")", "\n", "return", "theta", ",", "weights", "\n", "\n", "\n", "\n", "", "def", "sample_posterior", "(", "samples", ",", "weights", ",", "cols", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "samples", "\n", "n_weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "\n", "\n", "# importance weighted resampling", "\n", "resample_index", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "samples", ")", ",", "size", "=", "N", ",", "replace", "=", "True", ",", "p", "=", "n_weights", ")", "\n", "theta_resampled", "=", "theta", "[", "resample_index", ",", ":", "]", "\n", "theta_df", "=", "pd", ".", "DataFrame", ".", "from_records", "(", "theta_resampled", ",", "columns", "=", "cols", ")", "\n", "return", "theta_df", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.__init__": [[39, 90], ["simple_rl.tasks.NavigationWorldMDP", "simple_rl.agents.QLearningAgent", "navworld.navworld_simulator.get_grid_locs", "print", "navworld.navworld_simulator.mdp.get_actions", "navworld.navworld_simulator.nav_cell_p_or_locs.append", "navworld.navworld_simulator.nav_cell_p_or_locs.append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.get_grid_locs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["    ", "def", "__init__", "(", "self", ",", "ep", "=", "8000", ",", "steps", "=", "100", ",", "side", "=", "15", ",", "slip", "=", "0.2", ",", "eps", "=", "0.5", ",", "\n", "start", "=", "(", "2", ",", "2", ")", ",", "end", "=", "[", "[", "(", "14", ",", "14", ")", "]", "]", ",", "goal_rew", "=", "[", "100", "]", ")", ":", "\n", "# number of episodes per mdp and agent", "\n", "        ", "self", ".", "episodes", "=", "ep", "\n", "self", ".", "steps", "=", "steps", "\n", "self", ".", "side", "=", "side", "\n", "self", ".", "nav_cell_types", "=", "[", "\"white\"", ",", "\"yellow\"", ",", "\"red\"", ",", "\"green\"", ",", "\"purple\"", ",", "\"black\"", "]", "\n", "self", ".", "goal_cell_types", "=", "[", "\"blue\"", "]", "\n", "self", ".", "slip", "=", "slip", "\n", "self", ".", "start_loc", "=", "start", "\n", "self", ".", "goal_cell_loc", "=", "end", "\n", "self", ".", "goal_rew", "=", "goal_rew", "\n", "self", ".", "prev_cell_rewards", "=", "None", "\n", "self", ".", "eps", "=", "eps", "\n", "\n", "# generate map for the rest of experiments", "\n", "self", ".", "mdp", "=", "NavigationWorldMDP", "(", "width", "=", "self", ".", "side", ",", "height", "=", "self", ".", "side", ",", "\n", "nav_cell_types", "=", "self", ".", "nav_cell_types", ",", "\n", "nav_cell_rewards", "=", "[", "0.0", ",", "-", "1.0", ",", "-", "1.0", ",", "-", "5.0", ",", "-", "10.0", ",", "-", "500", "]", ",", "\n", "nav_cell_p_or_locs", "=", "[", "0.1", ",", "0.2", ",", "0.2", ",", "0.25", ",", "0.25", ",", "\n", "[", "(", "13", ",", "12", ")", ",", "(", "13", ",", "13", ")", ",", "(", "15", ",", "13", ")", "]", "]", ",", "\n", "goal_cell_types", "=", "self", ".", "goal_cell_types", ",", "\n", "goal_cell_rewards", "=", "self", ".", "goal_rew", ",", "\n", "goal_cell_locs", "=", "self", ".", "goal_cell_loc", ",", "\n", "init_loc", "=", "self", ".", "start_loc", ",", "rand_init", "=", "False", ",", "\n", "gamma", "=", "0.95", ",", "slip_prob", "=", "0", ",", "step_cost", "=", "0", ")", "\n", "\n", "# self.agent = QLearningAgent(self.mdp.get_actions(), epsilon=0.1)", "\n", "\n", "# get observed data", "\n", "self", ".", "agent", "=", "QLearningAgent", "(", "self", ".", "mdp", ".", "get_actions", "(", ")", ",", "epsilon", "=", "self", ".", "eps", ")", "\n", "#run_single_agent_on_mdp(self.agent, self.mdp, episodes=self.episodes, steps=self.steps)", "\n", "#self.agent.epsilon = 0", "\n", "#self.mdp.slip_prob = 0 ", "\n", "#_, steps_taken, reward, states = self.run_experiment(self.agent, self.mdp)", "\n", "self", ".", "observed_data", "=", "[", "9", ",", "24", ",", "51", "]", "\n", "\n", "# save grid for future simulations", "\n", "self", ".", "grid", "=", "self", ".", "get_grid_locs", "(", "self", ".", "mdp", ")", "\n", "self", ".", "nav_cell_p_or_locs", "=", "[", "]", "\n", "self", ".", "nav_cell_types", "=", "self", ".", "nav_cell_types", "[", ":", "-", "1", "]", "\n", "for", "color", "in", "self", ".", "nav_cell_types", ":", "\n", "            ", "if", "color", "==", "'white'", ":", "\n", "                ", "self", ".", "nav_cell_p_or_locs", ".", "append", "(", "1.0", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "nav_cell_p_or_locs", ".", "append", "(", "self", ".", "grid", "[", "color", "]", ")", "\n", "\n", "", "", "print", "(", "self", ".", "observed_data", ")", "\n", "self", ".", "param_dim", "=", "5", "\n", "# self.mdp.visualize_grid(trajectories=[states], traj_colors_auto=False)", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.count_turns": [[92, 105], ["range", "len", "abs"], "methods", ["None"], ["", "def", "count_turns", "(", "self", ",", "states", ")", ":", "\n", "        ", "prev_direction", "=", "None", "\n", "prev_state", "=", "states", "[", "0", "]", "\n", "turns", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "states", ")", ")", ":", "\n", "            ", "direction", "=", "\"x\"", "if", "abs", "(", "prev_state", ".", "x", "-", "states", "[", "i", "]", ".", "x", ")", "!=", "0", "else", "\"y\"", "\n", "if", "prev_direction", "!=", "direction", "and", "prev_direction", "!=", "None", ":", "\n", "                ", "turns", "+=", "1", "\n", "\n", "", "prev_direction", "=", "direction", "\n", "prev_state", "=", "states", "[", "i", "]", "\n", "", "return", "turns", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.get_observed_data": [[107, 109], ["None"], "methods", ["None"], ["", "def", "get_observed_data", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "observed_data", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.get_grid_locs": [[111, 123], ["cell_types.append", "dict.fromkeys", "dict.fromkeys.keys", "range", "range", "mdp._xy_to_rowcol", "grid_locs[].append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "get_grid_locs", "(", "self", ",", "mdp", ")", ":", "\n", "        ", "cell_types", "=", "mdp", ".", "nav_cell_types", "\n", "cell_types", ".", "append", "(", "\"blue\"", ")", "\n", "grid_locs", "=", "dict", ".", "fromkeys", "(", "cell_types", ")", "\n", "for", "keys", "in", "grid_locs", ".", "keys", "(", ")", ":", "\n", "            ", "grid_locs", "[", "keys", "]", "=", "[", "]", "\n", "\n", "", "for", "x", "in", "range", "(", "1", ",", "self", ".", "side", "+", "1", ")", ":", "\n", "            ", "for", "y", "in", "range", "(", "1", ",", "self", ".", "side", "+", "1", ")", ":", "\n", "                ", "r", ",", "c", "=", "mdp", ".", "_xy_to_rowcol", "(", "x", ",", "y", ")", "\n", "grid_locs", "[", "mdp", ".", "nav_cell_types", "[", "mdp", ".", "map_state_cell_id", "[", "r", ",", "c", "]", "]", "]", ".", "append", "(", "(", "x", ",", "y", ")", ")", "\n", "", "", "return", "grid_locs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.get_q_func": [[125, 133], ["dict", "agent.q_func.items", "dict", "actiond.items"], "methods", ["None"], ["", "def", "get_q_func", "(", "self", ",", "agent", ")", ":", "\n", "        ", "q_func", "=", "dict", "(", ")", "\n", "for", "state", ",", "actiond", "in", "agent", ".", "q_func", ".", "items", "(", ")", ":", "\n", "            ", "q_func", "[", "state", "]", "=", "dict", "(", ")", "\n", "for", "action", ",", "q_val", "in", "actiond", ".", "items", "(", ")", ":", "\n", "                ", "q_func", "[", "state", "]", "[", "action", "]", "=", "q_val", "\n", "\n", "", "", "return", "q_func", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.run_experiment": [[135, 157], ["mdp.get_init_state", "mdp.get_gamma", "range", "mdp.reset", "agent.end_of_episode", "mdp.get_init_state", "agent.act", "mdp.execute_agent_action", "states.append", "next_state.is_terminal", "mdp.reset"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.reset", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.reset"], ["", "def", "run_experiment", "(", "self", ",", "agent", ",", "mdp", ",", "steps", "=", "100", ")", ":", "\n", "        ", "states", "=", "[", "mdp", ".", "get_init_state", "(", ")", "]", "\n", "total_reward", "=", "0", "\n", "state", "=", "mdp", ".", "get_init_state", "(", ")", "\n", "gamma", "=", "mdp", ".", "get_gamma", "(", ")", "\n", "reward", "=", "0", "\n", "\n", "for", "step", "in", "range", "(", "1", ",", "steps", "+", "1", ")", ":", "\n", "            ", "action", "=", "agent", ".", "act", "(", "state", ",", "reward", ",", "False", ")", "\n", "\n", "reward", ",", "next_state", "=", "mdp", ".", "execute_agent_action", "(", "action", ")", "\n", "states", ".", "append", "(", "next_state", ")", "\n", "total_reward", "+=", "reward", "\n", "\n", "if", "next_state", ".", "is_terminal", "(", ")", ":", "\n", "                ", "mdp", ".", "reset", "(", ")", "\n", "return", "True", ",", "step", ",", "total_reward", ",", "states", "\n", "", "state", "=", "next_state", "\n", "\n", "", "mdp", ".", "reset", "(", ")", "\n", "agent", ".", "end_of_episode", "(", ")", "\n", "return", "False", ",", "steps", ",", "total_reward", ",", "states", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.func": [[159, 212], ["numpy.array().reshape", "range", "cur_cell_rewards.append", "range", "rewards.append", "numpy.array", "simple_rl.tasks.NavigationWorldMDP", "simple_rl.agents.QLearningAgent", "simple_rl.run_experiments.run_single_agent_on_mdp", "navworld.navworld_simulator.run_experiment", "navworld.navworld_simulator.count_turns", "navworld.navworld_simulator.mdp.get_actions"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.run_experiment", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.count_turns"], ["", "def", "func", "(", "self", ",", "*", "params", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate a sequence of samples from the Open AI env.\n\n        Parameters\n        ----------\n        params : array of envs\n        random_state : RandomState, optional\n\n        \"\"\"", "\n", "\n", "# fix locations instead of probabilities! fixed map multiple init_locs!", "\n", "rewards", "=", "[", "]", "\n", "params", "=", "np", ".", "array", "(", "params", ")", ".", "reshape", "(", "self", ".", "param_dim", ",", "-", "1", ")", "\n", "batches", "=", "params", ".", "shape", "[", "1", "]", "\n", "\n", "for", "i", "in", "range", "(", "batches", ")", ":", "\n", "            ", "cur_cell_rewards", "=", "[", "x", "for", "x", "in", "params", "[", ":", ",", "i", "]", "]", "\n", "# reward for black cells is fixed", "\n", "cur_cell_rewards", ".", "append", "(", "-", "500", ")", "\n", "\n", "if", "self", ".", "prev_cell_rewards", "!=", "cur_cell_rewards", ":", "\n", "                ", "self", ".", "mdp", "=", "NavigationWorldMDP", "(", "width", "=", "self", ".", "side", ",", "height", "=", "self", ".", "side", ",", "\n", "nav_cell_types", "=", "self", ".", "nav_cell_types", ",", "\n", "nav_cell_rewards", "=", "cur_cell_rewards", ",", "\n", "nav_cell_p_or_locs", "=", "self", ".", "nav_cell_p_or_locs", ",", "\n", "goal_cell_types", "=", "self", ".", "goal_cell_types", ",", "\n", "goal_cell_rewards", "=", "self", ".", "goal_rew", ",", "\n", "goal_cell_locs", "=", "self", ".", "goal_cell_loc", ",", "\n", "init_loc", "=", "self", ".", "start_loc", ",", "\n", "rand_init", "=", "False", ",", "\n", "slip_prob", "=", "0", ")", "\n", "\n", "self", ".", "agent", "=", "QLearningAgent", "(", "self", ".", "mdp", ".", "get_actions", "(", ")", ",", "epsilon", "=", "self", ".", "eps", ")", "\n", "run_single_agent_on_mdp", "(", "self", ".", "agent", ",", "self", ".", "mdp", ",", "episodes", "=", "self", ".", "episodes", ",", "steps", "=", "self", ".", "steps", ")", "\n", "\n", "\n", "", "self", ".", "agent", ".", "epsilon", "=", "0", "\n", "self", ".", "mdp", ".", "slip_prob", "=", "self", ".", "slip", "\n", "\n", "# print('Parameters:')", "\n", "# print(cur_cell_rewards)", "\n", "for", "j", "in", "range", "(", "1", ")", ":", "\n", "                ", "finished", ",", "steps_taken", ",", "reward", ",", "states", "=", "self", ".", "run_experiment", "(", "self", ".", "agent", ",", "self", ".", "mdp", ")", "\n", "turns", "=", "self", ".", "count_turns", "(", "states", ")", "\n", "ep_reward", "=", "[", "turns", ",", "steps_taken", ",", "reward", "]", "\n", "# print('Corresponding reward:')", "\n", "# print([turns, steps_taken, reward])", "\n", "# self.mdp.visualize_grid(trajectories=[states], traj_colors_auto=False)", "\n", "\n", "", "rewards", ".", "append", "(", "ep_reward", ")", "\n", "\n", "self", ".", "prev_cell_rewards", "=", "cur_cell_rewards", "\n", "", "return", "rewards", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.discrepancyI": [[213, 229], ["set", "list", "numpy.array", "print", "print", "set", "max", "numpy.abs", "numpy.array.append", "len", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "discrepancyI", "(", "s1", ",", "s2", ",", "obs", ")", ":", "\n", "        ", "traj_obs", "=", "set", "(", "obs", "[", "0", "]", "[", "0", "]", ")", "\n", "rew_obs", "=", "obs", "[", "0", "]", "[", "1", "]", "\n", "dis", "=", "list", "(", ")", "\n", "\n", "for", "entry", "in", "s2", ":", "\n", "            ", "traj", "=", "set", "(", "entry", "[", "0", "]", ")", "\n", "rew", "=", "entry", "[", "1", "]", "\n", "traj_dis", "=", "max", "(", "len", "(", "traj_obs", "-", "traj", ")", ",", "len", "(", "traj", "-", "traj_obs", ")", ")", "\n", "rew_dis", "=", "np", ".", "abs", "(", "rew_obs", "-", "rew", ")", "\n", "dis", ".", "append", "(", "traj_dis", "+", "rew_dis", ")", "\n", "\n", "", "dis", "=", "np", ".", "array", "(", "dis", ")", "\n", "print", "(", "'Discrepancy:'", ")", "\n", "print", "(", "dis", ")", "\n", "return", "dis", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.discrepancyII": [[231, 250], ["list", "numpy.array", "print", "print", "numpy.array.append", "numpy.linalg.norm", "numpy.multiply", "numpy.multiply"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "discrepancyII", "(", "s1", ",", "s2", ",", "obs", ")", ":", "\n", "        ", "ws", "=", "[", "6", ",", "3", ",", "1", "]", "\n", "obs", "=", "obs", "[", "0", "]", "\n", "dis", "=", "list", "(", ")", "\n", "\n", "#print('+')", "\n", "#rint(obs)", "\n", "\n", "for", "entry", "in", "s2", ":", "\n", "#print(entry)", "\n", "#print(ws)", "\n", "#print(np.multiply(entry, ws))", "\n", "#print(np.multiply(obs, ws))", "\n", "            ", "dis", ".", "append", "(", "np", ".", "linalg", ".", "norm", "(", "np", ".", "multiply", "(", "entry", ",", "ws", ")", "-", "np", ".", "multiply", "(", "obs", ",", "ws", ")", ")", ")", "\n", "\n", "", "dis", "=", "np", ".", "array", "(", "dis", ")", "\n", "print", "(", "'Discrepancy:'", ")", "\n", "print", "(", "dis", ")", "\n", "return", "dis", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.get_model": [[252, 285], ["elfi.ElfiModel", "navworld.navworld_simulator.get_observed_data", "elfi.Simulator", "elfi.Distance", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.get_observed_data"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "20.0", ",", "20.0", ",", "model", "=", "m", ",", "name", "=", "'white'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "20.0", ",", "20.0", ",", "model", "=", "m", ",", "name", "=", "'yellow'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "20.0", ",", "20.0", ",", "model", "=", "m", ",", "name", "=", "'red'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "20.0", ",", "20.0", ",", "model", "=", "m", ",", "name", "=", "'green'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "20.0", ",", "20.0", ",", "model", "=", "m", ",", "name", "=", "'purple'", ")", "\n", "params", "=", "[", "m", "[", "'white'", "]", ",", "m", "[", "'yellow'", "]", ",", "m", "[", "'red'", "]", ",", "\n", "m", "[", "'green'", "]", ",", "m", "[", "'purple'", "]", "]", "\n", "\n", "", "y_obs", "=", "self", ".", "get_observed_data", "(", ")", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "*", "params", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "# elfi.Distance(self.discrepancyII, m['DGP'], name='d')", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.plot_parameters": [[11, 37], ["print", "simple_rl.tasks.NavigationWorldMDP", "simple_rl.agents.QLearningAgent", "simple_rl.run_experiments.run_single_agent_on_mdp", "md.run_experiment", "print", "md.mdp.visualize_grid", "md.mdp.get_actions", "md.count_turns", "md.count_turns"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.run_experiment", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.count_turns", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.navworld.navworld_simulator.count_turns"], ["def", "plot_parameters", "(", "pars", ",", "md", ")", ":", "\n", "    ", "cur_cell_rewards", "=", "[", "pars", "[", "\"white\"", "]", "[", "0", "]", ",", "pars", "[", "\"yellow\"", "]", "[", "0", "]", ",", "pars", "[", "\"red\"", "]", "[", "0", "]", ",", "\n", "pars", "[", "\"green\"", "]", "[", "0", "]", ",", "pars", "[", "\"purple\"", "]", "[", "0", "]", ",", "-", "500", "]", "\n", "# cur_cell_rewards = pars", "\n", "print", "(", "cur_cell_rewards", ")", "\n", "md", ".", "mdp", "=", "NavigationWorldMDP", "(", "width", "=", "md", ".", "side", ",", "height", "=", "md", ".", "side", ",", "\n", "nav_cell_types", "=", "md", ".", "nav_cell_types", ",", "\n", "nav_cell_rewards", "=", "cur_cell_rewards", ",", "\n", "nav_cell_p_or_locs", "=", "md", ".", "nav_cell_p_or_locs", ",", "\n", "goal_cell_types", "=", "md", ".", "goal_cell_types", ",", "\n", "goal_cell_rewards", "=", "md", ".", "goal_rew", ",", "\n", "goal_cell_locs", "=", "md", ".", "goal_cell_loc", ",", "\n", "init_loc", "=", "md", ".", "start_loc", ",", "\n", "rand_init", "=", "False", ",", "gamma", "=", "0.95", ",", "slip_prob", "=", "0", ",", "step_cost", "=", "0", ")", "\n", "\n", "md", ".", "agent", "=", "QLearningAgent", "(", "md", ".", "mdp", ".", "get_actions", "(", ")", ",", "epsilon", "=", "md", ".", "eps", ")", "\n", "run_single_agent_on_mdp", "(", "md", ".", "agent", ",", "md", ".", "mdp", ",", "episodes", "=", "md", ".", "episodes", ",", "steps", "=", "md", ".", "steps", ")", "\n", "md", ".", "agent", ".", "epsilon", "=", "0", "\n", "md", ".", "mdp", ".", "slip_prob", "=", "0", "\n", "_", ",", "steps_taken", ",", "reward", ",", "states", "=", "md", ".", "run_experiment", "(", "md", ".", "agent", ",", "md", ".", "mdp", ")", "\n", "# print('Best result observation:')", "\n", "print", "(", "[", "md", ".", "count_turns", "(", "states", ")", ",", "steps_taken", ",", "reward", "]", ")", "\n", "# print('Observed data result:')", "\n", "# print(md.observed_data)", "\n", "md", ".", "mdp", ".", "visualize_grid", "(", "trajectories", "=", "[", "states", "]", ",", "plot", "=", "False", ")", "\n", "return", "[", "md", ".", "count_turns", "(", "states", ")", ",", "steps_taken", ",", "reward", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.prepare_inputs": [[19, 43], ["numpy.row_stack", "numpy.savetxt", "numpy.broadcast"], "function", ["None"], ["def", "prepare_inputs", "(", "*", "inputs", ",", "**", "kwinputs", ")", ":", "\n", "    ", "\"\"\"Prepare the inputs for the simulator.\n\n    The signature follows that given in `elfi.tools.external_operation`. This function\n    appends kwinputs with unique and descriptive filenames and writes an input file for\n    the bdm executable.\n    \"\"\"", "\n", "alpha", ",", "delta", ",", "tau", ",", "N", "=", "inputs", "\n", "meta", "=", "kwinputs", "[", "'meta'", "]", "\n", "\n", "# Organize the parameters to an array. The broadcasting works nicely with constant", "\n", "# arguments.", "\n", "param_array", "=", "np", ".", "row_stack", "(", "np", ".", "broadcast", "(", "alpha", ",", "delta", ",", "tau", ",", "N", ")", ")", "\n", "\n", "# Prepare a unique filename for parallel settings", "\n", "filename", "=", "'{model_name}_{batch_index}_{submission_index}.txt'", ".", "format", "(", "**", "meta", ")", "\n", "np", ".", "savetxt", "(", "filename", ",", "param_array", ",", "fmt", "=", "'%.4f %.4f %.4f %d'", ")", "\n", "\n", "# Add the filenames to kwinputs", "\n", "kwinputs", "[", "'filename'", "]", "=", "filename", "\n", "kwinputs", "[", "'output_filename'", "]", "=", "filename", "[", ":", "-", "4", "]", "+", "'_out.txt'", "\n", "\n", "# Return new inputs that the command will receive", "\n", "return", "inputs", ",", "kwinputs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.process_result": [[45, 61], ["numpy.loadtxt", "os.remove", "os.remove"], "function", ["None"], ["", "def", "process_result", "(", "completed_process", ",", "*", "inputs", ",", "**", "kwinputs", ")", ":", "\n", "    ", "\"\"\"Process the result of the BDM simulation.\n\n    The signature follows that given in `elfi.tools.external_operation`.\n    \"\"\"", "\n", "output_filename", "=", "kwinputs", "[", "'output_filename'", "]", "\n", "\n", "# Read the simulations from the file.", "\n", "simulations", "=", "np", ".", "loadtxt", "(", "output_filename", ",", "dtype", "=", "'int16'", ")", "\n", "\n", "# Clean up the files after reading the data in", "\n", "os", ".", "remove", "(", "kwinputs", "[", "'filename'", "]", ")", "\n", "os", ".", "remove", "(", "output_filename", ")", "\n", "\n", "# This will be passed to ELFI as the result of the command", "\n", "return", "simulations", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.T1": [[71, 75], ["numpy.atleast_2d", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["def", "T1", "(", "clusters", ")", ":", "\n", "    ", "\"\"\"Summary statistic for BDM.\"\"\"", "\n", "clusters", "=", "np", ".", "atleast_2d", "(", "clusters", ")", "\n", "return", "np", ".", "sum", "(", "clusters", ">", "0", ",", "1", ")", "/", "np", ".", "sum", "(", "clusters", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.T2": [[77, 81], ["numpy.atleast_2d", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["", "def", "T2", "(", "clusters", ",", "n", "=", "20", ")", ":", "\n", "    ", "\"\"\"Another summary statistic for BDM.\"\"\"", "\n", "clusters", "=", "np", ".", "atleast_2d", "(", "clusters", ")", "\n", "return", "1", "-", "np", ".", "sum", "(", "(", "clusters", "/", "n", ")", "**", "2", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.get_sources_path": [[83, 86], ["os.path.join", "os.path.dirname", "os.path.realpath"], "function", ["None"], ["", "def", "get_sources_path", "(", ")", ":", "\n", "    ", "\"\"\"Return the path to the C++ source code.\"\"\"", "\n", "return", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "realpath", "(", "__file__", ")", ")", ",", "'cpp'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.get_model": [[88, 139], ["elfi.ElfiModel", "elfi.Prior", "elfi.Simulator", "elfi.Summary", "elfi.Distance", "numpy.zeros", "numpy.array", "BDM", "bdm.get_sources_path", "warnings.warn", "os.path.isfile", "os.path.isfile", "len", "numpy.random.RandomState"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm.get_sources_path"], ["", "def", "get_model", "(", "alpha", "=", "0.2", ",", "delta", "=", "0", ",", "tau", "=", "0.198", ",", "N", "=", "20", ",", "seed_obs", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return the example model used in Lintusaari et al. 2016.\n\n    Here we infer alpha using the summary statistic T1. We expect the executable `bdm` be\n    available in the working directory.\n\n    Parameters\n    ----------\n    alpha : float\n        birth rate\n    delta : float\n        death rate\n    tau : float\n        mutation rate\n    N : int\n        size of the population\n    seed_obs : None, int\n        Seed for the observed data generation. None gives the same data as in\n        Lintusaari et al. 2016\n\n    Returns\n    -------\n    m : elfi.ElfiModel\n\n    \"\"\"", "\n", "if", "seed_obs", "is", "None", "and", "N", "==", "20", ":", "\n", "        ", "y", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "'int16'", ")", "\n", "data", "=", "np", ".", "array", "(", "[", "6", ",", "3", ",", "2", ",", "2", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "dtype", "=", "'int16'", ")", "\n", "y", "[", "0", ":", "len", "(", "data", ")", "]", "=", "data", "\n", "\n", "", "else", ":", "\n", "        ", "y", "=", "BDM", "(", "alpha", ",", "delta", ",", "tau", ",", "N", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "\n", "", "m", "=", "elfi", ".", "ElfiModel", "(", "name", "=", "'bdm'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", ".005", ",", "2", ",", "model", "=", "m", ",", "name", "=", "'alpha'", ")", "\n", "elfi", ".", "Simulator", "(", "BDM", ",", "m", "[", "'alpha'", "]", ",", "delta", ",", "tau", ",", "N", ",", "observed", "=", "y", ",", "name", "=", "'BDM'", ")", "\n", "elfi", ".", "Summary", "(", "T1", ",", "m", "[", "'BDM'", "]", ",", "name", "=", "'T1'", ")", "\n", "elfi", ".", "Distance", "(", "'minkowski'", ",", "m", "[", "'T1'", "]", ",", "p", "=", "1", ",", "name", "=", "'d'", ")", "\n", "\n", "m", "[", "'BDM'", "]", ".", "uses_meta", "=", "True", "\n", "\n", "# Warn the user if the executable is not present", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "'bdm'", ")", "and", "not", "os", ".", "path", ".", "isfile", "(", "'bdm.exe'", ")", ":", "\n", "        ", "cpp_path", "=", "get_sources_path", "(", ")", "\n", "warnings", ".", "warn", "(", "\"This model uses an external simulator `bdm` implemented in C++ \"", "\n", "\"that needs to be compiled and copied to your working directory. \"", "\n", "\"We could not find it from your current working directory. Please\"", "\n", "\"copy the folder `{}` to your working directory \"", "\n", "\"and compile the source.\"", ".", "format", "(", "cpp_path", ")", ",", "RuntimeWarning", ")", "\n", "\n", "", "return", "m", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ma2.CustomPrior1.rvs": [[102, 120], ["scipy.uniform.rvs", "numpy.where", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["@", "classmethod", "\n", "def", "rvs", "(", "cls", ",", "b", ",", "size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Get random variates.\n\n        Parameters\n        ----------\n        b : float\n        size : int or tuple, optional\n        random_state : RandomState, optional\n\n        Returns\n        -------\n        arraylike\n\n        \"\"\"", "\n", "u", "=", "ss", ".", "uniform", ".", "rvs", "(", "loc", "=", "0", ",", "scale", "=", "1", ",", "size", "=", "size", ",", "random_state", "=", "random_state", ")", "\n", "t1", "=", "np", ".", "where", "(", "u", "<", "0.5", ",", "np", ".", "sqrt", "(", "2.", "*", "u", ")", "*", "b", "-", "b", ",", "-", "np", ".", "sqrt", "(", "2.", "*", "(", "1.", "-", "u", ")", ")", "*", "b", "+", "b", ")", "\n", "return", "t1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ma2.CustomPrior1.pdf": [[121, 139], ["numpy.where", "numpy.abs"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "pdf", "(", "cls", ",", "x", ",", "b", ")", ":", "\n", "        ", "\"\"\"Return density at `x`.\n\n        Parameters\n        ----------\n        x : float or arraylike\n        b : float\n\n        Returns\n        -------\n        arraylike\n\n        \"\"\"", "\n", "p", "=", "1.", "/", "b", "-", "np", ".", "abs", "(", "x", ")", "/", "(", "b", "*", "b", ")", "\n", "# set values outside of [-b, b] to zero", "\n", "p", "=", "np", ".", "where", "(", "p", "<", "0.", ",", "0.", ",", "p", ")", "\n", "return", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ma2.CustomPrior2.rvs": [[147, 167], ["numpy.maximum", "scipy.uniform.rvs"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["@", "classmethod", "\n", "def", "rvs", "(", "cls", ",", "t1", ",", "a", ",", "size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Get random variates.\n\n        Parameters\n        ----------\n        t1 : float or arraylike\n        a : float\n        size : int or tuple, optional\n        random_state : RandomState, optional\n\n        Returns\n        -------\n        arraylike\n\n        \"\"\"", "\n", "locs", "=", "np", ".", "maximum", "(", "-", "a", "-", "t1", ",", "-", "a", "+", "t1", ")", "\n", "scales", "=", "a", "-", "locs", "\n", "t2", "=", "ss", ".", "uniform", ".", "rvs", "(", "loc", "=", "locs", ",", "scale", "=", "scales", ",", "size", "=", "size", ",", "random_state", "=", "random_state", ")", "\n", "return", "t2", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ma2.CustomPrior2.pdf": [[168, 187], ["numpy.maximum", "numpy.where"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "pdf", "(", "cls", ",", "x", ",", "t1", ",", "a", ")", ":", "\n", "        ", "\"\"\"Return density at `x`.\n\n        Parameters\n        ----------\n        x : float or arraylike\n        t1 : float or arraylike\n        a : float\n\n        Returns\n        -------\n        arraylike\n\n        \"\"\"", "\n", "locs", "=", "np", ".", "maximum", "(", "-", "a", "-", "t1", ",", "-", "a", "+", "t1", ")", "\n", "scales", "=", "a", "-", "locs", "\n", "p", "=", "(", "x", ">=", "locs", ")", "*", "(", "x", "<=", "locs", "+", "scales", ")", "*", "1", "/", "np", ".", "where", "(", "scales", ">", "0", ",", "scales", ",", "1", ")", "\n", "return", "p", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ma2.MA2": [[11, 38], ["numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "random_state.randn", "numpy.asanyarray", "numpy.asanyarray"], "function", ["None"], ["def", "MA2", "(", "t1", ",", "t2", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "r\"\"\"Generate a sequence of samples from the MA2 model.\n\n    The sequence is a moving average\n\n        x_i = w_i + \\theta_1 w_{i-1} + \\theta_2 w_{i-2}\n\n    where w_i are white noise ~ N(0,1).\n\n    Parameters\n    ----------\n    t1 : float, array_like\n    t2 : float, array_like\n    n_obs : int, optional\n    batch_size : int, optional\n    random_state : RandomState, optional\n\n    \"\"\"", "\n", "# Make inputs 2d arrays for broadcasting with w", "\n", "t1", "=", "np", ".", "asanyarray", "(", "t1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "t2", "=", "np", ".", "asanyarray", "(", "t2", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "# i.i.d. sequence ~ N(0,1)", "\n", "w", "=", "random_state", ".", "randn", "(", "batch_size", ",", "n_obs", "+", "2", ")", "\n", "x", "=", "w", "[", ":", ",", "2", ":", "]", "+", "t1", "*", "w", "[", ":", ",", "1", ":", "-", "1", "]", "+", "t2", "*", "w", "[", ":", ",", ":", "-", "2", "]", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ma2.autocov": [[40, 60], ["numpy.atleast_2d", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "autocov", "(", "x", ",", "lag", "=", "1", ")", ":", "\n", "    ", "\"\"\"Return the autocovariance.\n\n    Assumes a (weak) univariate stationary process with mean 0.\n    Realizations are in rows.\n\n    Parameters\n    ----------\n    x : np.array of size (n, m)\n    lag : int, optional\n\n    Returns\n    -------\n    C : np.array of size (n,)\n\n    \"\"\"", "\n", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "# In R this is normalized with x.shape[1]", "\n", "C", "=", "np", ".", "mean", "(", "x", "[", ":", ",", "lag", ":", "]", "*", "x", "[", ":", ",", ":", "-", "lag", "]", ",", "axis", "=", "1", ")", "\n", "return", "C", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ma2.get_model": [[62, 93], ["ma2.MA2", "functools.partial", "elfi.ElfiModel", "elfi.Prior", "elfi.Prior", "elfi.Simulator", "elfi.Summary", "elfi.Summary", "elfi.Distance", "numpy.random.RandomState"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ma2.MA2"], ["", "def", "get_model", "(", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return a complete MA2 model in inference task.\n\n    Parameters\n    ----------\n    n_obs : int, optional\n        observation length of the MA2 process\n    true_params : list, optional\n        parameters with which the observed data is generated\n    seed_obs : int, optional\n        seed for the observed data generation\n\n    Returns\n    -------\n    m : elfi.ElfiModel\n\n    \"\"\"", "\n", "if", "true_params", "is", "None", ":", "\n", "        ", "true_params", "=", "[", ".6", ",", ".2", "]", "\n", "\n", "", "y", "=", "MA2", "(", "*", "true_params", ",", "n_obs", "=", "n_obs", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "sim_fn", "=", "partial", "(", "MA2", ",", "n_obs", "=", "n_obs", ")", "\n", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "CustomPrior1", ",", "2", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Prior", "(", "CustomPrior2", ",", "m", "[", "'t1'", "]", ",", "1", ",", "name", "=", "'t2'", ")", "\n", "elfi", ".", "Simulator", "(", "sim_fn", ",", "m", "[", "'t1'", "]", ",", "m", "[", "'t2'", "]", ",", "observed", "=", "y", ",", "name", "=", "'MA2'", ")", "\n", "elfi", ".", "Summary", "(", "autocov", ",", "m", "[", "'MA2'", "]", ",", "name", "=", "'S1'", ")", "\n", "elfi", ".", "Summary", "(", "autocov", ",", "m", "[", "'MA2'", "]", ",", "2", ",", "name", "=", "'S2'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'S1'", "]", ",", "m", "[", "'S2'", "]", ",", "name", "=", "'d'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.cosm_inflation.cosmological_inflation.__init__": [[7, 9], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "param_dim", "=", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.cosm_inflation.cosmological_inflation.func": [[11, 36], ["list", "numpy.array().reshape", "range", "numpy.float64", "numpy.float64", "numpy.float64", "numpy.float64", "numpy.float64", "numpy.random.uniform", "cosm_inflation.cosmological_inflation.get_power_law_spectrum", "list.append", "numpy.array", "float", "math.isnan", "float"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.cosm_inflation.cosmological_inflation.get_power_law_spectrum", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "func", "(", "self", ",", "*", "params", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "results", "=", "list", "(", ")", "\n", "params", "=", "np", ".", "array", "(", "params", ")", ".", "reshape", "(", "self", ".", "param_dim", ",", "-", "1", ")", "\n", "batches", "=", "params", ".", "shape", "[", "1", "]", "\n", "# print('Sim:', params)", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "batches", ")", ":", "\n", "            ", "ns", "=", "np", ".", "float64", "(", "params", "[", "0", ",", "i", "]", ")", "\n", "kc", "=", "np", ".", "float64", "(", "params", "[", "1", ",", "i", "]", ")", "\n", "alpha", "=", "np", ".", "float64", "(", "params", "[", "2", ",", "i", "]", ")", "\n", "r_star", "=", "np", ".", "float64", "(", "params", "[", "3", ",", "i", "]", ")", "\n", "As", "=", "np", ".", "float64", "(", "params", "[", "4", ",", "i", "]", ")", "\n", "\n", "k", "=", "np", ".", "random", ".", "uniform", "(", "0.0008", ",", "0.00085", ")", "\n", "y", "=", "k", "/", "kc", "\n", "temp", "=", "self", ".", "get_power_law_spectrum", "(", "As", ",", "y", ",", "alpha", ",", "k", ",", "ns", ",", "r_star", ")", "\n", "if", "temp", "==", "float", "(", "\"-inf\"", ")", "or", "temp", "<", "-", "1e7", ":", "\n", "                ", "temp", "=", "-", "1e7", "\n", "", "elif", "temp", "==", "float", "(", "\"inf\"", ")", "or", "temp", ">", "1e7", ":", "\n", "                ", "temp", "=", "1e7", "\n", "", "elif", "math", ".", "isnan", "(", "temp", ")", ":", "\n", "                ", "temp", "=", "1e7", "\n", "\n", "", "results", ".", "append", "(", "temp", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.cosm_inflation.cosmological_inflation.get_power_law_spectrum": [[38, 40], ["cosm_inflation.cosmological_inflation.get_T2", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.cosm_inflation.cosmological_inflation.get_T2"], ["", "def", "get_power_law_spectrum", "(", "self", ",", "As", ",", "y", ",", "alpha", ",", "k", ",", "ns", ",", "r_star", ")", ":", "\n", "        ", "return", "As", "*", "(", "1", "-", "np", ".", "exp", "(", "(", "0.75", "*", "y", ")", "**", "alpha", ")", ")", "*", "k", "**", "(", "ns", "-", "1", ")", "*", "self", ".", "get_T2", "(", "y", ",", "r_star", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.cosm_inflation.cosmological_inflation.get_T2": [[42, 46], ["numpy.sin", "numpy.sin", "numpy.cos", "numpy.cos"], "methods", ["None"], ["", "def", "get_T2", "(", "self", ",", "y", ",", "r_star", ")", ":", "\n", "        ", "term_1", "=", "1", "-", "3", "*", "(", "r_star", "-", "1", ")", "*", "(", "1.", "/", "y", ")", "*", "(", "(", "1", "-", "(", "1.", "/", "y", "**", "2", ")", ")", "*", "np", ".", "sin", "(", "2", "*", "y", ")", "+", "(", "2.", "/", "y", ")", "*", "np", ".", "cos", "(", "2", "*", "y", ")", ")", "\n", "term_2", "=", "4.5", "*", "r_star", "**", "2", "*", "(", "1.", "/", "y", "**", "2", ")", "*", "(", "1", "+", "(", "1.", "/", "y", "**", "2", ")", ")", "*", "(", "1", "+", "1.", "/", "y", "**", "2", "+", "(", "1", "-", "1.", "/", "y", "**", "2", ")", "*", "np", ".", "cos", "(", "2", "*", "y", ")", "-", "2.", "/", "y", "*", "np", ".", "sin", "(", "2", "*", "y", ")", ")", "\n", "return", "term_1", "+", "term_2", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.cosm_inflation.cosmological_inflation.get_model": [[48, 67], ["elfi.new_model", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "cosm_inflation.cosmological_inflation.func", "elfi.Simulator", "elfi.Distance", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "10", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "m", "=", "elfi", ".", "new_model", "(", ")", "\n", "\n", "# Parameters: ns, kc, alpha, r_star, As", "\n", "# priors from Sinha and Souradeep 2006.", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.5", ",", "1.0", ",", "name", "=", "'ns'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "1e-7", ",", "1e-3", ",", "name", "=", "'kc'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.", ",", "10.", ",", "name", "=", "'alpha'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.", ",", "1.", ",", "name", "=", "'r_star'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "2.7", ",", "1.3", ",", "name", "=", "'As'", ")", "\n", "params", "=", "[", "m", "[", "'ns'", "]", ",", "m", "[", "'kc'", "]", ",", "m", "[", "'alpha'", "]", ",", "m", "[", "'r_star'", "]", ",", "m", "[", "'As'", "]", "]", "\n", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "[", "0.96", ",", "0.0003", ",", "0.58", ",", "0.75", ",", "3.35", "]", "]", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "*", "params", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "return", "m", "", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm_dgp.bdm_simulator.__init__": [[8, 24], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "# Observation pediod in years", "\n", "        ", "self", ".", "t_obs", "=", "2", "\n", "\n", "# Some bounds that discard unrealistic initial values to optimize the computation", "\n", "self", ".", "mean_obs_bounds", "=", "(", "0", ",", "350", ")", "\n", "# Upper bounds for t1 and a1", "\n", "self", ".", "t1_bound", "=", "30", "\n", "self", ".", "a1_bound", "=", "40", "\n", "\n", "# Upper bound for the largest allowed cluster size within the observation period.", "\n", "# These are chosen to eliminate outcomes that are clearly different from the", "\n", "# observed data early", "\n", "self", ".", "cluster_size_bound", "=", "80", "\n", "# Restrict warmup between 15 and 300 years", "\n", "self", ".", "warmup_bounds", "=", "(", "15", ",", "300", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm_dgp.bdm_simulator.func": [[29, 62], ["list", "len", "range", "elfi.Rt_to_d", "elfi.Rt_to_d", "elfi.Rt_to_d", "elfi.Rt_to_a", "elfi.Rt_to_a", "elfi.Rt_to_a", "elfi.simulator", "elfi.simulator", "elfi.simulator", "elfi.distance", "elfi.distance", "elfi.distance", "list.append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_a", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_a", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_a", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.simulator", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.simulator", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.simulator", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.distance", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.distance", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.distance", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "func", "(", "self", ",", "*", "params", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "results", "=", "list", "(", ")", "\n", "batches", "=", "len", "(", "params", ")", "\n", "\n", "# {'R1':(1.01, 12), 'R2': (0.01, 0.4),'burden': (120, 220), 't1':(0.01, 30)}", "\n", "for", "i", "in", "range", "(", "0", ",", "batches", ")", ":", "\n", "\n", "            ", "R1", "=", "params", "[", "i", "]", "[", "0", "]", "# R2, t1", "\n", "R2", "=", "params", "[", "i", "]", "[", "1", "]", "# burden", "\n", "burden", "=", "params", "[", "i", "]", "[", "2", "]", "# R1, t1", "\n", "t1", "=", "params", "[", "i", "]", "[", "3", "]", "# R1, t1", "\n", "d1", "=", "ops", ".", "Rt_to_d", "(", "R1", ",", "t1", ")", "\n", "d2", "=", "5.95", "\n", "a2", "=", "R2", "*", "d2", "\n", "a1", "=", "ops", ".", "Rt_to_a", "(", "R1", ",", "t1", ")", "\n", "res", "=", "ops", ".", "simulator", "(", "burden", ",", "a2", ",", "d2", ",", "a1", ",", "d1", ",", "2", ",", "self", ".", "cluster_size_bound", ",", "self", ".", "warmup_bounds", ")", "\n", "\n", "#print('')", "\n", "#print(self.y0)", "\n", "#print(self.y0[0])", "\n", "#print(res)", "\n", "#raise ValueError", "\n", "\n", "n_obs", "=", "res", "[", "'n_obs'", "]", "\n", "n_clusters", "=", "res", "[", "'n_clusters'", "]", "\n", "largest", "=", "res", "[", "'largest'", "]", "\n", "clusters", "=", "res", "[", "'clusters'", "]", "\n", "obs_times", "=", "res", "[", "'obs_times'", "]", "\n", "d", "=", "ops", ".", "distance", "(", "n_obs", ",", "n_clusters", ",", "largest", ",", "clusters", ",", "obs_times", ",", "self", ".", "y0_sum", ")", "\n", "# results.append([n_obs, n_clusters, largest, clusters, obs_times])", "\n", "results", ".", "append", "(", "d", ")", "\n", "# print(results)", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm_dgp.bdm_simulator.identity": [[63, 65], ["None"], "methods", ["None"], ["", "def", "identity", "(", "self", ",", "n_obs", ",", "n_clusters", ",", "largest", ",", "clusters", ",", "obs_times", ")", ":", "\n", "        ", "return", "[", "n_obs", ",", "n_clusters", ",", "largest", ",", "clusters", ",", "obs_times", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm_dgp.bdm_simulator.get_model": [[66, 133], ["elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.new_model", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.RandomVariable", "elfi.RandomVariable", "elfi.RandomVariable", "elfi.RandomVariable", "elfi.RandomVariable", "elfi.RandomVariable", "elfi.RandomVariable", "elfi.RandomVariable", "elfi.RandomVariable", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Simulator", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Operation", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.Discrepancy", "elfi.Rt_to_d", "elfi.Rt_to_d", "elfi.Rt_to_d", "operator.mul", "elfi.Rt_to_a", "elfi.Rt_to_a", "elfi.Rt_to_a", "elfi.simulator", "elfi.simulator", "elfi.simulator"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_a", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_a", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_a", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.simulator", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.simulator", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.simulator"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "\n", "m", "=", "elfi", ".", "new_model", "(", ")", "\n", "burden", "=", "elfi", ".", "Prior", "(", "'normal'", ",", "200", ",", "30", ",", "name", "=", "'burden'", ")", "\n", "\n", "joint", "=", "elfi", ".", "RandomVariable", "(", "ops", ".", "JointPrior", ",", "burden", ",", "self", ".", "mean_obs_bounds", ",", "\n", "self", ".", "t1_bound", ",", "self", ".", "a1_bound", ")", "\n", "\n", "# DummyPrior takes a marginal from the joint prior", "\n", "R2", "=", "elfi", ".", "Prior", "(", "ops", ".", "DummyPrior", ",", "joint", ",", "0", ",", "name", "=", "'R2'", ")", "\n", "R1", "=", "elfi", ".", "Prior", "(", "ops", ".", "DummyPrior", ",", "joint", ",", "1", ",", "name", "=", "'R1'", ")", "\n", "t1", "=", "elfi", ".", "Prior", "(", "ops", ".", "DummyPrior", ",", "joint", ",", "2", ",", "name", "=", "'t1'", ")", "\n", "\n", "# Turn the epidemiological parameters to rate parameters for the simulator", "\n", "d1", "=", "elfi", ".", "Operation", "(", "ops", ".", "Rt_to_d", ",", "R1", ",", "t1", ")", "\n", "d2", "=", "5.95", "\n", "a2", "=", "elfi", ".", "Operation", "(", "operator", ".", "mul", ",", "R2", ",", "d2", ")", "\n", "a1", "=", "elfi", ".", "Operation", "(", "ops", ".", "Rt_to_a", ",", "R1", ",", "t1", ")", "\n", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "y0_burden", "=", "192", "\n", "y0_R2", "=", "0.09", "\n", "y0_R1", "=", "5.88", "\n", "y0_t1", "=", "6.74", "\n", "\n", "y0_d1", "=", "ops", ".", "Rt_to_d", "(", "y0_R1", ",", "y0_t1", ")", "\n", "y0_a2", "=", "operator", ".", "mul", "(", "y0_R2", ",", "d2", ")", "\n", "y0_a1", "=", "ops", ".", "Rt_to_a", "(", "y0_R1", ",", "y0_t1", ")", "\n", "self", ".", "y0", "=", "ops", ".", "simulator", "(", "y0_burden", ",", "y0_a2", ",", "d2", ",", "y0_a1", ",", "y0_d1", ",", "2", ",", "\n", "self", ".", "cluster_size_bound", ",", "self", ".", "warmup_bounds", ")", "\n", "\n", "self", ".", "y0_sum", "=", "[", "self", ".", "y0", "[", "'n_obs'", "]", ",", "self", ".", "y0", "[", "'n_clusters'", "]", ",", "self", ".", "y0", "[", "'largest'", "]", ",", "self", ".", "y0", "[", "'clusters'", "]", ",", "self", ".", "y0", "[", "'obs_times'", "]", "]", "\n", "\n", "# Add the simulator", "\n", "", "sim", "=", "elfi", ".", "Simulator", "(", "ops", ".", "simulator", ",", "burden", ",", "a2", ",", "d2", ",", "a1", ",", "d1", ",", "2", ",", "\n", "self", ".", "cluster_size_bound", ",", "self", ".", "warmup_bounds", ",", "observed", "=", "self", ".", "y0", ")", "\n", "\n", "# Summaries extracted from the simulator output", "\n", "n_obs", "=", "elfi", ".", "Summary", "(", "ops", ".", "pick", ",", "sim", ",", "'n_obs'", ")", "\n", "n_clusters", "=", "elfi", ".", "Summary", "(", "ops", ".", "pick", ",", "sim", ",", "'n_clusters'", ")", "\n", "largest", "=", "elfi", ".", "Summary", "(", "ops", ".", "pick", ",", "sim", ",", "'largest'", ")", "\n", "clusters", "=", "elfi", ".", "Summary", "(", "ops", ".", "pick", ",", "sim", ",", "'clusters'", ")", "\n", "obs_times", "=", "elfi", ".", "Summary", "(", "ops", ".", "pick", ",", "sim", ",", "'obs_times'", ")", "\n", "\n", "sim", "=", "elfi", ".", "Operation", "(", "ops", ".", "distance", ",", "n_obs", ",", "n_clusters", ",", "largest", ",", "clusters", ",", "\n", "obs_times", ",", "self", ".", "y0_sum", ",", "name", "=", "'sim'", ")", "\n", "\n", "# Distance", "\n", "dist", "=", "elfi", ".", "Discrepancy", "(", "ops", ".", "distance", ",", "n_obs", ",", "n_clusters", ",", "largest", ",", "clusters", ",", "\n", "obs_times", ",", "name", "=", "'dist'", ")", "\n", "return", "m", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ricker.ricker": [[11, 41], ["numpy.empty", "range", "numpy.exp"], "function", ["None"], ["def", "ricker", "(", "log_rate", ",", "stock_init", "=", "1.", ",", "n_obs", "=", "50", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generate samples from the Ricker model.\n\n    Ricker, W. E. (1954) Stock and Recruitment Journal of the Fisheries\n    Research Board of Canada, 11(5): 559-623.\n\n    Parameters\n    ----------\n    log_rate : float or np.array\n        Log growth rate of population.\n    stock_init : float or np.array, optional\n        Initial stock.\n    n_obs : int, optional\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n\n    Returns\n    -------\n    stock : np.array\n\n    \"\"\"", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "stock", "=", "np", ".", "empty", "(", "(", "batch_size", ",", "n_obs", ")", ")", "\n", "stock", "[", ":", ",", "0", "]", "=", "stock_init", "\n", "\n", "for", "ii", "in", "range", "(", "1", ",", "n_obs", ")", ":", "\n", "        ", "stock", "[", ":", ",", "ii", "]", "=", "stock", "[", ":", ",", "ii", "-", "1", "]", "*", "np", ".", "exp", "(", "log_rate", "-", "stock", "[", ":", ",", "ii", "-", "1", "]", ")", "\n", "\n", "", "return", "stock", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ricker.stochastic_ricker": [[43, 86], ["numpy.empty", "range", "random_state.poisson", "numpy.exp", "random_state.randn"], "function", ["None"], ["", "def", "stochastic_ricker", "(", "log_rate", ",", "\n", "std", ",", "\n", "scale", ",", "\n", "stock_init", "=", "1.", ",", "\n", "n_obs", "=", "50", ",", "\n", "batch_size", "=", "1", ",", "\n", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generate samples from the stochastic Ricker model.\n\n    Here the observed stock ~ Poisson(true stock * scaling).\n\n    Parameters\n    ----------\n    log_rate : float or np.array\n        Log growth rate of population.\n    std : float or np.array\n        Standard deviation of innovations.\n    scale : float or np.array\n        Scaling of the expected value from Poisson distribution.\n    stock_init : float or np.array, optional\n        Initial stock.\n    n_obs : int, optional\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n\n    Returns\n    -------\n    stock_obs : np.array\n\n    \"\"\"", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "stock_obs", "=", "np", ".", "empty", "(", "(", "batch_size", ",", "n_obs", ")", ")", "\n", "stock_prev", "=", "stock_init", "\n", "\n", "for", "ii", "in", "range", "(", "n_obs", ")", ":", "\n", "        ", "stock", "=", "stock_prev", "*", "np", ".", "exp", "(", "log_rate", "-", "stock_prev", "+", "std", "*", "random_state", ".", "randn", "(", "batch_size", ")", ")", "\n", "stock_prev", "=", "stock", "\n", "\n", "# the observed stock is Poisson distributed", "\n", "stock_obs", "[", ":", ",", "ii", "]", "=", "random_state", ".", "poisson", "(", "scale", "*", "stock", ",", "batch_size", ")", "\n", "\n", "", "return", "stock_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ricker.get_model": [[88, 145], ["elfi.ElfiModel", "functools.partial.", "functools.partial", "functools.partial", "functools.partial", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Simulator", "sumstats.append", "sumstats.append", "sumstats.append", "elfi.Discrepancy", "elfi.Prior", "elfi.Simulator", "sumstats.append", "elfi.Distance", "numpy.random.RandomState", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "functools.partial", "functools.partial", "functools.partial"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "get_model", "(", "n_obs", "=", "50", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ",", "stochastic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Return a complete Ricker model in inference task.\n\n    This is a simplified example that achieves reasonable predictions. For more extensive treatment\n    and description using 13 summary statistics, see:\n\n    Wood, S. N. (2010) Statistical inference for noisy nonlinear ecological dynamic systems,\n    Nature 466, 1102\u20131107.\n\n    Parameters\n    ----------\n    n_obs : int, optional\n        Number of observations.\n    true_params : list, optional\n        Parameters with which the observed data is generated.\n    seed_obs : int, optional\n        Seed for the observed data generation.\n    stochastic : bool, optional\n        Whether to use the stochastic or deterministic Ricker model.\n\n    Returns\n    -------\n    m : elfi.ElfiModel\n\n    \"\"\"", "\n", "if", "stochastic", ":", "\n", "        ", "simulator", "=", "partial", "(", "stochastic_ricker", ",", "n_obs", "=", "n_obs", ")", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "3.8", ",", "0.3", ",", "10.", "]", "\n", "\n", "", "", "else", ":", "\n", "        ", "simulator", "=", "partial", "(", "ricker", ",", "n_obs", "=", "n_obs", ")", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "3.8", "]", "\n", "\n", "", "", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "y_obs", "=", "simulator", "(", "*", "true_params", ",", "n_obs", "=", "n_obs", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "sim_fn", "=", "partial", "(", "simulator", ",", "n_obs", "=", "n_obs", ")", "\n", "sumstats", "=", "[", "]", "\n", "\n", "if", "stochastic", ":", "\n", "        ", "elfi", ".", "Prior", "(", "ss", ".", "expon", ",", "np", ".", "e", ",", "2", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "truncnorm", ",", "0", ",", "5", ",", "model", "=", "m", ",", "name", "=", "'t2'", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "uniform", ",", "0", ",", "100", ",", "model", "=", "m", ",", "name", "=", "'t3'", ")", "\n", "elfi", ".", "Simulator", "(", "sim_fn", ",", "m", "[", "'t1'", "]", ",", "m", "[", "'t2'", "]", ",", "m", "[", "'t3'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'Ricker'", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "partial", "(", "np", ".", "mean", ",", "axis", "=", "1", ")", ",", "m", "[", "'Ricker'", "]", ",", "name", "=", "'Mean'", ")", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "partial", "(", "np", ".", "var", ",", "axis", "=", "1", ")", ",", "m", "[", "'Ricker'", "]", ",", "name", "=", "'Var'", ")", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "num_zeros", ",", "m", "[", "'Ricker'", "]", ",", "name", "=", "'#0'", ")", ")", "\n", "elfi", ".", "Discrepancy", "(", "chi_squared", ",", "*", "sumstats", ",", "name", "=", "'d'", ")", "\n", "\n", "", "else", ":", "# very simple deterministic case", "\n", "        ", "elfi", ".", "Prior", "(", "ss", ".", "expon", ",", "np", ".", "e", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Simulator", "(", "sim_fn", ",", "m", "[", "'t1'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'Ricker'", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "partial", "(", "np", ".", "mean", ",", "axis", "=", "1", ")", ",", "m", "[", "'Ricker'", "]", ",", "name", "=", "'Mean'", ")", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "*", "sumstats", ",", "name", "=", "'d'", ")", "\n", "\n", "", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ricker.chi_squared": [[147, 162], ["numpy.column_stack", "numpy.column_stack", "numpy.sum"], "function", ["None"], ["", "def", "chi_squared", "(", "*", "simulated", ",", "observed", ")", ":", "\n", "    ", "\"\"\"Return Chi squared goodness of fit.\n\n    Adjusts for differences in magnitude between dimensions.\n\n    Parameters\n    ----------\n    simulated : np.arrays\n    observed : tuple of np.arrays\n\n    \"\"\"", "\n", "simulated", "=", "np", ".", "column_stack", "(", "simulated", ")", "\n", "observed", "=", "np", ".", "column_stack", "(", "observed", ")", "\n", "d", "=", "np", ".", "sum", "(", "(", "simulated", "-", "observed", ")", "**", "2.", "/", "observed", ",", "axis", "=", "1", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.ricker.num_zeros": [[164, 168], ["numpy.sum"], "function", ["None"], ["", "def", "num_zeros", "(", "x", ")", ":", "\n", "    ", "\"\"\"Return a summary statistic: number of zero observations.\"\"\"", "\n", "n", "=", "np", ".", "sum", "(", "x", "==", "0", ",", "axis", "=", "1", ")", "\n", "return", "n", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk.GNK": [[11, 69], ["numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "scipy.norm.rvs", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.exp", "numpy.exp"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["def", "GNK", "(", "A", ",", "B", ",", "g", ",", "k", ",", "c", "=", "0.8", ",", "n_obs", "=", "50", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"Sample the univariate g-and-k distribution.\n\n    References\n    ----------\n    [1] Drovandi, C. C., & Pettitt, A. N. (2011).\n    Likelihood-free Bayesian estimation of multivariate quantile distributions.\n    Computational Statistics & Data Analysis, 55(9), 2541-2556.\n    [2] Allingham, D., King, R. A. R., & Mengersen, K. L. (2009).\n    Bayesian estimation of quantile distributions.\n    Statistics and Computing, 19(2), 189-201.\n\n    The quantile function of g-and-k distribution is defined as follows:\n\n    Q_{gnk} = A + B * (1 + c * (1 - exp(-g * z(p)) / 1 + exp(-g * z(p))))\n            * (1 + z(p)^2)^k * z(p), where\n\n    z(p) is the p-th standard normal quantile.\n\n    To sample from the g-and-k distribution, draw z(p) ~ N(0, 1) and evaluate Q_{gnk}.\n\n    Parameters\n    ----------\n    A : float or array_like\n        Location parameter.\n    B : float or array_like\n        Scale parameter.\n    g : float or array_like\n        Skewness parameter.\n    k : float or array_like\n        Kurtosis parameter.\n    c : float, optional\n        Overall asymmetry parameter, by default fixed to 0.8 as in Allingham et al. (2009).\n    n_obs : int, optional\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n\n    Returns\n    -------\n    array_like\n        Yielded points (the array's shape corresponds to (batch_size, n_points, n_dims).\n\n    \"\"\"", "\n", "# Transforming the arrays' shape to be compatible with batching.", "\n", "A", "=", "np", ".", "asanyarray", "(", "A", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "B", "=", "np", ".", "asanyarray", "(", "B", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "g", "=", "np", ".", "asanyarray", "(", "g", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "k", "=", "np", ".", "asanyarray", "(", "k", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "# Obtaining z(p) ~ N(0, 1).", "\n", "z", "=", "ss", ".", "norm", ".", "rvs", "(", "size", "=", "(", "batch_size", ",", "n_obs", ")", ",", "random_state", "=", "random_state", ")", "\n", "\n", "# Evaluating the quantile function Q_{gnk}.", "\n", "y", "=", "A", "+", "B", "*", "(", "1", "+", "c", "*", "(", "(", "1", "-", "np", ".", "exp", "(", "-", "g", "*", "z", ")", ")", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "g", "*", "z", ")", ")", ")", ")", "*", "(", "1", "+", "z", "**", "2", ")", "**", "k", "*", "z", "\n", "\n", "# Dedicating a dummy axis for the dimensionality of the points.", "\n", "y", "=", "y", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk.get_model": [[71, 114], ["elfi.new_model", "priors.append", "priors.append", "priors.append", "priors.append", "gnk.GNK", "functools.partial", "elfi.Simulator", "elfi.Summary", "elfi.Discrepancy", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "numpy.random.RandomState"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk.GNK"], ["", "def", "get_model", "(", "n_obs", "=", "50", ",", "true_params", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"Initialise the g-and-k model.\n\n    Parameters\n    ----------\n    n_obs : int, optional\n        Number of the observations.\n    true_params : array_like, optional\n        Parameters defining the model.\n    seed : np.random.RandomState, optional\n\n    Returns\n    -------\n    elfi.ElfiModel\n\n    \"\"\"", "\n", "m", "=", "elfi", ".", "new_model", "(", ")", "\n", "\n", "# Initialising the parameters as in Allingham et al. (2009).", "\n", "if", "true_params", "is", "None", ":", "\n", "        ", "true_params", "=", "[", "3", ",", "1", ",", "2", ",", ".5", "]", "\n", "\n", "# Initialising the prior settings as in Allingham et al. (2009).", "\n", "", "priors", "=", "[", "]", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "10", ",", "model", "=", "m", ",", "name", "=", "'A'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "10", ",", "model", "=", "m", ",", "name", "=", "'B'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "10", ",", "model", "=", "m", ",", "name", "=", "'g'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "10", ",", "model", "=", "m", ",", "name", "=", "'k'", ")", ")", "\n", "\n", "# Obtaining the observations.", "\n", "y_obs", "=", "GNK", "(", "*", "true_params", ",", "n_obs", "=", "n_obs", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", ")", "\n", "\n", "# Defining the simulator.", "\n", "fn_simulator", "=", "partial", "(", "GNK", ",", "n_obs", "=", "n_obs", ")", "\n", "elfi", ".", "Simulator", "(", "fn_simulator", ",", "*", "priors", ",", "observed", "=", "y_obs", ",", "name", "=", "'GNK'", ")", "\n", "\n", "# Initialising the summary statistics as in Allingham et al. (2009).", "\n", "default_ss", "=", "elfi", ".", "Summary", "(", "ss_order", ",", "m", "[", "'GNK'", "]", ",", "name", "=", "'ss_order'", ")", "\n", "\n", "# Using the multi-dimensional Euclidean distance function as", "\n", "# the summary statistics' implementations are designed for multi-dimensional cases.", "\n", "elfi", ".", "Discrepancy", "(", "euclidean_multiss", ",", "default_ss", ",", "name", "=", "'d'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk.euclidean_multiss": [[116, 144], ["numpy.sum", "numpy.sum", "numpy.sqrt"], "function", ["None"], ["", "def", "euclidean_multiss", "(", "*", "simulated", ",", "observed", ")", ":", "\n", "    ", "\"\"\"Calculate the Euclidean distances merging summary statistics.\n\n    The shape of the arrays corresponds to (batch_size, dim_ss, dim_ss_point), where\n    dim_ss corresponds to the dimensionality of the summary statistics, and\n    dim_ss_point corresponds to the dimensionality a summary statistic data point.\n\n    Parameters\n    ----------\n    *simulated: array_like\n    observed : array_like\n\n    Returns\n    -------\n    array_like\n\n    \"\"\"", "\n", "pts_sim", "=", "simulated", "[", "0", "]", "\n", "pts_obs", "=", "observed", "[", "0", "]", "\n", "\n", "# Integrating over the summary statistics.", "\n", "d_ss_merged", "=", "np", ".", "sum", "(", "(", "pts_sim", "-", "pts_obs", ")", "**", "2.", ",", "axis", "=", "1", ")", "\n", "\n", "# Integrating over the summary statistics' data point dimensionality.", "\n", "d_ss_point_merged", "=", "np", ".", "sum", "(", "d_ss_merged", ",", "axis", "=", "1", ")", "\n", "\n", "d", "=", "np", ".", "sqrt", "(", "d_ss_point_merged", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk.ss_order": [[146, 163], ["numpy.sort"], "function", ["None"], ["", "def", "ss_order", "(", "y", ")", ":", "\n", "    ", "\"\"\"Obtain the order summary statistic described in Allingham et al. (2009).\n\n    The statistic reaches the optimal performance upon a low number of observations.\n\n    Parameters\n    ----------\n    y : array_like\n        Yielded points.\n\n    Returns\n    -------\n    array_like of the shape (batch_size, dim_ss=len(y), dim_ss_point)\n\n    \"\"\"", "\n", "ss_order", "=", "np", ".", "sort", "(", "y", ")", "\n", "return", "ss_order", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk.ss_robust": [[165, 190], ["gnk._get_ss_A", "gnk._get_ss_B", "gnk._get_ss_g", "gnk._get_ss_k", "numpy.hstack"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_A", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_B", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_g", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_k"], ["", "def", "ss_robust", "(", "y", ")", ":", "\n", "    ", "\"\"\"Obtain the robust summary statistic described in Drovandi and Pettitt (2011).\n\n    The statistic reaches the optimal performance upon a high number of\n    observations.\n\n    Parameters\n    ----------\n    y : array_like\n        Yielded points.\n\n    Returns\n    -------\n    array_like of the shape (batch_size, dim_ss=4, dim_ss_point)\n\n    \"\"\"", "\n", "ss_A", "=", "_get_ss_A", "(", "y", ")", "\n", "ss_B", "=", "_get_ss_B", "(", "y", ")", "\n", "ss_g", "=", "_get_ss_g", "(", "y", ")", "\n", "ss_k", "=", "_get_ss_k", "(", "y", ")", "\n", "\n", "# Combining the summary statistics.", "\n", "ss_robust", "=", "np", ".", "hstack", "(", "(", "ss_A", ",", "ss_B", ",", "ss_g", ",", "ss_k", ")", ")", "\n", "ss_robust", "=", "ss_robust", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "return", "ss_robust", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk.ss_octile": [[192, 215], ["numpy.linspace", "numpy.percentile", "numpy.hstack"], "function", ["None"], ["", "def", "ss_octile", "(", "y", ")", ":", "\n", "    ", "\"\"\"Obtain the octile summary statistic.\n\n    The statistic reaches the optimal performance upon a high number of\n    observations. According to Allingham et al. (2009), it is more stable than ss_robust.\n\n    Parameters\n    ----------\n    y : array_like\n        Yielded points.\n\n    Returns\n    -------\n    array_like of the shape (batch_size, dim_ss=8, dim_ss_point)\n\n    \"\"\"", "\n", "octiles", "=", "np", ".", "linspace", "(", "12.5", ",", "87.5", ",", "7", ")", "\n", "E1", ",", "E2", ",", "E3", ",", "E4", ",", "E5", ",", "E6", ",", "E7", "=", "np", ".", "percentile", "(", "y", ",", "octiles", ",", "axis", "=", "1", ")", "\n", "\n", "# Combining the summary statistics.", "\n", "ss_octile", "=", "np", ".", "hstack", "(", "(", "E1", ",", "E2", ",", "E3", ",", "E4", ",", "E5", ",", "E6", ",", "E7", ")", ")", "\n", "ss_octile", "=", "ss_octile", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "return", "ss_octile", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_A": [[217, 221], ["numpy.percentile"], "function", ["None"], ["", "def", "_get_ss_A", "(", "y", ")", ":", "\n", "    ", "L2", "=", "np", ".", "percentile", "(", "y", ",", "50", ",", "axis", "=", "1", ")", "\n", "ss_A", "=", "L2", "\n", "return", "ss_A", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_B": [[223, 236], ["numpy.percentile", "ss_B.reshape.reshape", "numpy.where", "numpy.finfo"], "function", ["None"], ["", "def", "_get_ss_B", "(", "y", ")", ":", "\n", "    ", "L1", ",", "L3", "=", "np", ".", "percentile", "(", "y", ",", "[", "25", ",", "75", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Avoiding the zero value (ss_B is used for division).", "\n", "ss_B", "=", "(", "L3", "-", "L1", ")", ".", "ravel", "(", ")", "\n", "idxs_zero", "=", "np", ".", "where", "(", "ss_B", "==", "0", ")", "[", "0", "]", "\n", "ss_B", "[", "idxs_zero", "]", "+=", "np", ".", "finfo", "(", "float", ")", ".", "eps", "\n", "\n", "# Transforming the summary statistics back into the compatible shape.", "\n", "n_dim", "=", "y", ".", "shape", "[", "-", "1", "]", "\n", "n_batches", "=", "y", ".", "shape", "[", "0", "]", "\n", "ss_B", "=", "ss_B", ".", "reshape", "(", "n_batches", ",", "n_dim", ")", "\n", "return", "ss_B", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_g": [[238, 243], ["numpy.percentile", "gnk._get_ss_B", "numpy.divide"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_B"], ["", "def", "_get_ss_g", "(", "y", ")", ":", "\n", "    ", "L1", ",", "L2", ",", "L3", "=", "np", ".", "percentile", "(", "y", ",", "[", "25", ",", "50", ",", "75", "]", ",", "axis", "=", "1", ")", "\n", "ss_B", "=", "_get_ss_B", "(", "y", ")", "\n", "ss_g", "=", "np", ".", "divide", "(", "L3", "+", "L1", "-", "2", "*", "L2", ",", "ss_B", ")", "\n", "return", "ss_g", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_k": [[245, 250], ["numpy.percentile", "gnk._get_ss_B", "numpy.divide"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gnk._get_ss_B"], ["", "def", "_get_ss_k", "(", "y", ")", ":", "\n", "    ", "E1", ",", "E3", ",", "E5", ",", "E7", "=", "np", ".", "percentile", "(", "y", ",", "[", "12.5", ",", "37.5", ",", "62.5", ",", "87.5", "]", ",", "axis", "=", "1", ")", "\n", "ss_B", "=", "_get_ss_B", "(", "y", ")", "\n", "ss_k", "=", "np", ".", "divide", "(", "E7", "-", "E5", "+", "E3", "-", "E1", ",", "ss_B", ")", "\n", "return", "ss_k", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz._lorenz_ode": [[18, 56], ["numpy.empty_like"], "function", ["None"], ["def", "_lorenz_ode", "(", "y", ",", "params", ")", ":", "\n", "    ", "\"\"\"Parametrized Lorenz 96 system defined by a coupled stochastic differential equations (SDE).\n\n    Parameters\n    ----------\n    y : numpy.ndarray of dimension (batch_size, n_obs)\n        Current state of the SDE.\n    params : list\n        The list of parameters needed to evaluate function. In this case it is\n        list of four elements - eta, theta1, theta2 and f.\n\n    Returns\n    -------\n    dy_dt : np.array\n        Rate of change of the SDE.\n\n    \"\"\"", "\n", "dy_dt", "=", "np", ".", "empty_like", "(", "y", ")", "\n", "\n", "eta", "=", "params", "[", "0", "]", "\n", "theta1", "=", "params", "[", "1", "]", "\n", "theta2", "=", "params", "[", "2", "]", "\n", "\n", "f", "=", "params", "[", "3", "]", "\n", "\n", "g", "=", "theta1", "+", "y", "*", "theta2", "\n", "\n", "dy_dt", "[", ":", ",", "0", "]", "=", "-", "y", "[", ":", ",", "-", "2", "]", "*", "y", "[", ":", ",", "-", "1", "]", "+", "y", "[", ":", ",", "-", "1", "]", "*", "y", "[", ":", ",", "1", "]", "-", "y", "[", ":", ",", "0", "]", "+", "f", "-", "g", "[", ":", ",", "0", "]", "+", "eta", "[", ":", ",", "0", "]", "\n", "\n", "dy_dt", "[", ":", ",", "1", "]", "=", "-", "y", "[", ":", ",", "-", "1", "]", "*", "y", "[", ":", ",", "0", "]", "+", "y", "[", ":", ",", "0", "]", "*", "y", "[", ":", ",", "2", "]", "-", "y", "[", ":", ",", "1", "]", "+", "f", "-", "g", "[", ":", ",", "1", "]", "+", "eta", "[", ":", ",", "1", "]", "\n", "\n", "dy_dt", "[", ":", ",", "2", ":", "-", "1", "]", "=", "(", "-", "y", "[", ":", ",", ":", "-", "3", "]", "*", "y", "[", ":", ",", "1", ":", "-", "2", "]", "+", "y", "[", ":", ",", "1", ":", "-", "2", "]", "*", "y", "[", ":", ",", "3", ":", "]", "-", "y", "[", ":", ",", "2", ":", "-", "1", "]", "+", "f", "-", "g", "[", ":", ",", "2", ":", "-", "1", "]", "\n", "+", "eta", "[", ":", ",", "2", ":", "-", "1", "]", ")", "\n", "\n", "dy_dt", "[", ":", ",", "-", "1", "]", "=", "(", "-", "y", "[", ":", ",", "-", "3", "]", "*", "y", "[", ":", ",", "-", "2", "]", "+", "y", "[", ":", ",", "-", "2", "]", "*", "y", "[", ":", ",", "0", "]", "-", "y", "[", ":", ",", "-", "1", "]", "+", "f", "-", "g", "[", ":", ",", "-", "1", "]", "\n", "+", "eta", "[", ":", ",", "-", "1", "]", ")", "\n", "\n", "return", "dy_dt", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.runge_kutta_ode_solver": [[58, 92], ["ode", "ode", "ode", "ode"], "function", ["None"], ["", "def", "runge_kutta_ode_solver", "(", "ode", ",", "time_step", ",", "y", ",", "params", ")", ":", "\n", "    ", "\"\"\"4th order Runge-Kutta ODE solver.\n\n    Carnahan, B., Luther, H. A., and Wilkes, J. O. (1969).\n    Applied Numerical Methods. Wiley, New York.\n\n    Parameters\n    ----------\n    ode : function\n        Ordinary differential equation function. In the Lorenz model it is SDE.\n    time_step : float\n    y : np.ndarray of dimension (batch_size, n_obs)\n        Current state of the time-series.\n    params : list of parameters\n        The parameters needed to evaluate the ode. In this case it is\n        list of four elements - eta, theta1, theta2 and f.\n\n    Returns\n    -------\n    np.ndarray\n        Resulting state initiated at y and satisfying ode solved by this solver.\n\n    \"\"\"", "\n", "k1", "=", "time_step", "*", "ode", "(", "y", ",", "params", ")", "\n", "\n", "k2", "=", "time_step", "*", "ode", "(", "y", "+", "k1", "/", "2", ",", "params", ")", "\n", "\n", "k3", "=", "time_step", "*", "ode", "(", "y", "+", "k2", "/", "2", ",", "params", ")", "\n", "\n", "k4", "=", "time_step", "*", "ode", "(", "y", "+", "k3", ",", "params", ")", "\n", "\n", "y", "=", "y", "+", "(", "k1", "+", "2", "*", "k2", "+", "2", "*", "k3", "+", "k4", ")", "/", "6", "\n", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.forecast_lorenz": [[94, 164], ["numpy.asarray().reshape", "numpy.asarray().reshape", "numpy.empty", "range", "numpy.tile", "random_state.normal", "lorenz.runge_kutta_ode_solver", "numpy.asarray", "numpy.asarray", "numpy.sqrt", "pow"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.runge_kutta_ode_solver"], ["", "def", "forecast_lorenz", "(", "theta1", "=", "None", ",", "theta2", "=", "None", ",", "f", "=", "10.", ",", "phi", "=", "0.984", ",", "n_obs", "=", "40", ",", "n_timestep", "=", "160", ",", "\n", "batch_size", "=", "1", ",", "initial_state", "=", "None", ",", "random_state", "=", "None", ",", "total_duration", "=", "4", ")", ":", "\n", "    ", "\"\"\"Forecast Lorenz model.\n\n    Wilks, D. S. (2005). Effects of stochastic parametrizations in the\n    Lorenz \u201996 system. Quarterly Journal of the Royal Meteorological Society,\n    131(606), 389\u2013407.\n\n    Parameters\n    ----------\n    theta1, theta2: list or numpy.ndarray\n        Closure parameters.\n    phi : float, optional\n        This value is used to express stochastic forcing term. It should be configured according\n        to force term and eventually impacts to the result of eta.\n        More details in Wilks (2005) et al.\n    initial_state: numpy.ndarray, optional\n        Initial state value of the time-series.\n    f : float, optional\n        Force term\n    n_obs : int, optional\n        Size of the observed 1D grid\n    n_timestep : int, optional\n        Number of the time step intervals\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n    total_duration : float, optional\n\n    Returns\n    -------\n    np.ndarray of size (b, n, m) which is (batch_size, time, n_obs)\n        The computed SDE with time series.\n\n    \"\"\"", "\n", "if", "not", "initial_state", ":", "\n", "        ", "initial_state", "=", "np", ".", "tile", "(", "[", "2.40711741e-01", ",", "4.75597337e+00", ",", "1.19145654e+01", ",", "1.31324866e+00", ",", "\n", "2.82675744e+00", ",", "3.96016971e+00", ",", "2.10479504e+00", ",", "5.47742826e+00", ",", "\n", "5.42519447e+00", ",", "-", "1.45166074e+00", ",", "2.01991521e+00", ",", "3.93873313e+00", ",", "\n", "8.22837848e+00", ",", "4.89401702e+00", ",", "-", "5.66278973e+00", ",", "1.58617220e+00", ",", "\n", "-", "1.23849251e+00", ",", "-", "6.04649288e-01", ",", "6.04132264e+00", ",", "7.47588536e+00", ",", "\n", "1.82761402e+00", ",", "3.19209639e+00", ",", "-", "7.58539653e-02", ",", "-", "6.00928508e-03", ",", "\n", "4.52902964e-01", ",", "3.22063602e+00", ",", "7.18613523e+00", ",", "2.39210634e+00", ",", "\n", "-", "2.65743666e+00", ",", "2.32046235e-01", ",", "1.28079141e+00", ",", "4.23344286e+00", ",", "\n", "6.94213238e+00", ",", "-", "1.15939497e+00", ",", "-", "5.23037351e-01", ",", "1.54618811e+00", ",", "\n", "1.77863869e+00", ",", "3.30139201e+00", ",", "7.47769309e+00", ",", "-", "3.91312909e-01", "]", ",", "\n", "(", "batch_size", ",", "1", ")", ")", "\n", "\n", "", "y", "=", "initial_state", "\n", "eta", "=", "0", "\n", "\n", "theta1", "=", "np", ".", "asarray", "(", "theta1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "theta2", "=", "np", ".", "asarray", "(", "theta2", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "time_step", "=", "total_duration", "/", "n_timestep", "\n", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "time_series", "=", "np", ".", "empty", "(", "shape", "=", "(", "batch_size", ",", "n_timestep", ",", "n_obs", ")", ")", "\n", "time_series", "[", ":", ",", "0", ",", ":", "]", "=", "y", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n_timestep", ")", ":", "\n", "        ", "e", "=", "random_state", ".", "normal", "(", "0", ",", "1", ",", "y", ".", "shape", ")", "\n", "eta", "=", "phi", "*", "eta", "+", "e", "*", "np", ".", "sqrt", "(", "1", "-", "pow", "(", "phi", ",", "2", ")", ")", "\n", "params", "=", "(", "eta", ",", "theta1", ",", "theta2", ",", "f", ")", "\n", "\n", "y", "=", "runge_kutta_ode_solver", "(", "ode", "=", "_lorenz_ode", ",", "time_step", "=", "time_step", ",", "y", "=", "y", ",", "params", "=", "params", ")", "\n", "time_series", "[", ":", ",", "i", ",", ":", "]", "=", "y", "\n", "\n", "", "return", "time_series", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.get_model": [[166, 229], ["functools.partial", "elfi.ElfiModel", "functools.partial.", "elfi.Prior", "elfi.Prior", "elfi.Simulator", "sumstats.append", "sumstats.append", "sumstats.append", "sumstats.append", "sumstats.append", "sumstats.append", "elfi.Distance", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "numpy.random.RandomState"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "get_model", "(", "true_params", "=", "None", ",", "seed_obs", "=", "None", ",", "initial_state", "=", "None", ",", "n_obs", "=", "40", ",", "f", "=", "10.", ",", "phi", "=", "0.984", ",", "\n", "total_duration", "=", "4", ")", ":", "\n", "    ", "\"\"\"Return a complete Lorenz model in inference task.\n\n    This is a simplified example that achieves reasonable predictions.\n\n    Hakkarainen, J., Ilin, A., Solonen, A., Laine, M., Haario, H., Tamminen,\n    J., Oja, E., and J\u00e4rvinen, H. (2012). On closure parameter estimation in\n    chaotic systems. Nonlinear Processes in Geophysics, 19(1), 127\u2013143.\n\n    Parameters\n    ----------\n    true_params : list, optional\n        Parameters with which the observed data is generated.\n    seed_obs : int, optional\n        Seed for the observed data generation.\n    initial_state : ndarray\n        Initial state value of the time-series.\n    n_obs : int, optional\n        Number of observed variables\n    f : float, optional\n        Force term\n    phi : float, optional\n        This value is used to express stochastic forcing term. It should be configured according\n        to force term and eventually impacts to the result of eta.\n        More details in Wilks (2005) et al.\n    total_duration : float, optional\n\n    Returns\n    -------\n    m : elfi.ElfiModel\n\n    \"\"\"", "\n", "simulator", "=", "partial", "(", "forecast_lorenz", ",", "initial_state", "=", "initial_state", ",", "f", "=", "f", ",", "n_obs", "=", "n_obs", ",", "phi", "=", "phi", ",", "\n", "total_duration", "=", "total_duration", ")", "\n", "\n", "if", "not", "true_params", ":", "\n", "        ", "true_params", "=", "[", "2.0", ",", "0.1", "]", "\n", "\n", "", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "\n", "y_obs", "=", "simulator", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "sumstats", "=", "[", "]", "\n", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.5", ",", "3.", ",", "model", "=", "m", ",", "name", "=", "'theta1'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "0.3", ",", "model", "=", "m", ",", "name", "=", "'theta2'", ")", "\n", "elfi", ".", "Simulator", "(", "simulator", ",", "m", "[", "'theta1'", "]", ",", "m", "[", "'theta2'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'Lorenz'", ")", "\n", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "mean", ",", "m", "[", "'Lorenz'", "]", ",", "name", "=", "'Mean'", ")", ")", "\n", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "var", ",", "m", "[", "'Lorenz'", "]", ",", "name", "=", "'Var'", ")", ")", "\n", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "autocov", ",", "m", "[", "'Lorenz'", "]", ",", "name", "=", "'Autocov'", ")", ")", "\n", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "cov", ",", "m", "[", "'Lorenz'", "]", ",", "name", "=", "'Cov'", ")", ")", "\n", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "xcov", ",", "m", "[", "'Lorenz'", "]", ",", "True", ",", "name", "=", "'CrosscovPrev'", ")", ")", "\n", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "xcov", ",", "m", "[", "'Lorenz'", "]", ",", "False", ",", "name", "=", "'CrosscovNext'", ")", ")", "\n", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "*", "sumstats", ",", "name", "=", "'d'", ")", "\n", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean": [[231, 245], ["numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "mean", "(", "x", ")", ":", "\n", "    ", "\"\"\"Return the mean of Y_{k}.\n\n    Parameters\n    ----------\n    x : np.array of size (b, n, m) which is (batch_size, time, n_obs)\n\n    Returns\n    -------\n    np.array of size (b,)\n        The computed mean of statistics over time and space.\n\n    \"\"\"", "\n", "return", "np", ".", "mean", "(", "x", ",", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.var": [[247, 261], ["numpy.mean", "numpy.var"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.var"], ["", "def", "var", "(", "x", ")", ":", "\n", "    ", "\"\"\"Return the variance of Y_{k}.\n\n    Parameters\n    ----------\n    x : np.array of size (b, n, m) which is (batch_size, time, n_obs)\n\n    Returns\n    -------\n    np.array of size (b,)\n        The average over space of computed variance with respect to time.\n\n    \"\"\"", "\n", "return", "np", ".", "mean", "(", "np", ".", "var", "(", "x", ",", "axis", "=", "1", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.cov": [[263, 280], ["numpy.roll", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "cov", "(", "x", ")", ":", "\n", "    ", "\"\"\"Return the covariance of Y_{k} with its neighbour Y_{k+1}.\n\n    Parameters\n    ----------\n    x : np.array of size (b, n, m) which is (batch_size, time, n_obs)\n\n    Returns\n    -------\n    np.array of size (b,)\n        The average over space of computed covariance with respect to time.\n\n    \"\"\"", "\n", "x_next", "=", "np", ".", "roll", "(", "x", ",", "-", "1", ",", "axis", "=", "2", ")", "\n", "return", "np", ".", "mean", "(", "np", ".", "mean", "(", "(", "x", "-", "np", ".", "mean", "(", "x", ",", "keepdims", "=", "True", ",", "axis", "=", "1", ")", ")", "*", "\n", "(", "x_next", "-", "np", ".", "mean", "(", "x_next", ",", "keepdims", "=", "True", ",", "axis", "=", "1", ")", ")", ",", "\n", "axis", "=", "1", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.xcov": [[282, 301], ["numpy.mean", "numpy.roll", "numpy.roll", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "xcov", "(", "x", ",", "prev", "=", "True", ")", ":", "\n", "    ", "\"\"\"Return the cross-covariance of Y_{k} with its neighbours from previous time step.\n\n    Parameters\n    ----------\n    x : np.array of size (b, n, m) which is (batch_size, time, n_obs)\n    prev : bool\n        The side of previous neighbour. True for previous neighbour, False for next.\n\n    Returns\n    -------\n    np.array of size (b,)\n        The average over space of computed cross-covariance with respect to time.\n\n    \"\"\"", "\n", "x_lag", "=", "np", ".", "roll", "(", "x", ",", "1", ",", "axis", "=", "2", ")", "if", "prev", "else", "np", ".", "roll", "(", "x", ",", "-", "1", ",", "axis", "=", "2", ")", "\n", "return", "np", ".", "mean", "(", "(", "x", "[", ":", ",", ":", "-", "1", ",", ":", "]", "-", "np", ".", "mean", "(", "x", "[", ":", ",", ":", "-", "1", ",", ":", "]", ",", "keepdims", "=", "True", ",", "axis", "=", "1", ")", ")", "*", "\n", "(", "x_lag", "[", ":", ",", "1", ":", ",", ":", "]", "-", "np", ".", "mean", "(", "x_lag", "[", ":", ",", "1", ":", ",", ":", "]", ",", "keepdims", "=", "True", ",", "axis", "=", "1", ")", ")", ",", "\n", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.autocov": [[303, 321], ["numpy.mean", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "autocov", "(", "x", ")", ":", "\n", "    ", "\"\"\"Return the auto-covariance with time lag 1.\n\n    Parameters\n    ----------\n    x : np.array of size (b, n, m) which is (batch_size, time, n_obs)\n\n    Returns\n    -------\n    C : np.array of size (b,)\n        The average over space of computed auto-covariance with respect to time.\n\n    \"\"\"", "\n", "c", "=", "np", ".", "mean", "(", "(", "x", "[", ":", ",", ":", "-", "1", ",", ":", "]", "-", "np", ".", "mean", "(", "x", "[", ":", ",", ":", "-", "1", ",", ":", "]", ",", "keepdims", "=", "True", ",", "axis", "=", "1", ")", ")", "*", "\n", "(", "x", "[", ":", ",", "1", ":", ",", ":", "]", "-", "np", ".", "mean", "(", "x", "[", ":", ",", "1", ":", ",", ":", "]", ",", "keepdims", "=", "True", ",", "axis", "=", "1", ")", ")", ",", "\n", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", "\n", "return", "c", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.sound_loc.sound_localization.__init__": [[13, 19], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "# locations of two pairs of microphones", "\n", "        ", "self", ".", "mic_pair_1", "=", "[", "(", "-", "0.5", ",", "0", ")", ",", "(", "0.5", ",", "0", ")", "]", "\n", "self", ".", "mic_pair_2", "=", "[", "(", "0", ",", "-", "0.5", ")", ",", "(", "0", ",", "0.5", ")", "]", "\n", "self", ".", "param_dim", "=", "2", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.sound_loc.sound_localization.func": [[21, 40], ["list", "numpy.array().reshape", "range", "sound_loc.sound_localization.choose_rand_mic_pair", "sound_loc.sound_localization.get_itd", "range", "list.append", "numpy.array", "temp.append", "scipy.stats.t.rvs", "numpy.mean", "numpy.std"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.sound_loc.sound_localization.choose_rand_mic_pair", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.sound_loc.sound_localization.get_itd", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "func", "(", "self", ",", "*", "params", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "results", "=", "list", "(", ")", "\n", "params", "=", "np", ".", "array", "(", "params", ")", ".", "reshape", "(", "self", ".", "param_dim", ",", "-", "1", ")", "\n", "batches", "=", "params", ".", "shape", "[", "1", "]", "\n", "# print('Sim:', params)", "\n", "for", "i", "in", "range", "(", "0", ",", "batches", ")", ":", "\n", "            ", "x", "=", "params", "[", "0", ",", "i", "]", "\n", "y", "=", "params", "[", "1", ",", "i", "]", "\n", "# print(x, y)", "\n", "mic_pair", "=", "self", ".", "choose_rand_mic_pair", "(", ")", "\n", "itd", "=", "self", ".", "get_itd", "(", "x", ",", "y", ",", "mic_pair", ")", "\n", "temp", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "                ", "temp", ".", "append", "(", "t", ".", "rvs", "(", "df", "=", "3", ",", "scale", "=", "0.01", ",", "loc", "=", "itd", ")", ")", "\n", "", "results", ".", "append", "(", "[", "np", ".", "mean", "(", "temp", ")", ",", "np", ".", "std", "(", "temp", ")", "]", ")", "\n", "# print(results)", "\n", "# print('mean:', np.mean(results, axis=1))", "\n", "# print('std:', np.std(y_obs, axis=1))", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.sound_loc.sound_localization.get_itd": [[42, 46], ["scipy.spatial.distance.euclidean", "scipy.spatial.distance.euclidean", "numpy.abs"], "methods", ["None"], ["", "def", "get_itd", "(", "self", ",", "x", ",", "y", ",", "mic_pair", ")", ":", "\n", "        ", "norm_1", "=", "distance", ".", "euclidean", "(", "(", "x", ",", "y", ")", ",", "mic_pair", "[", "0", "]", ")", "\n", "norm_2", "=", "distance", ".", "euclidean", "(", "(", "x", ",", "y", ")", ",", "mic_pair", "[", "1", "]", ")", "\n", "return", "np", ".", "abs", "(", "norm_1", "-", "norm_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.sound_loc.sound_localization.choose_rand_mic_pair": [[48, 54], ["random.random"], "methods", ["None"], ["", "def", "choose_rand_mic_pair", "(", "self", ")", ":", "\n", "        ", "n", "=", "random", ".", "random", "(", ")", "\n", "if", "n", "<", "0.5", ":", "\n", "            ", "return", "self", ".", "mic_pair_1", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "mic_pair_2", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.sound_loc.sound_localization.get_model": [[56, 74], ["elfi.new_model", "elfi.Prior", "elfi.Prior", "sound_loc.sound_localization.func", "elfi.Simulator", "elfi.Distance", "numpy.mean", "numpy.std", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "m", "=", "elfi", ".", "new_model", "(", ")", "\n", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "2", ",", "4", ",", "name", "=", "'x'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "2", ",", "4", ",", "name", "=", "'y'", ")", "\n", "params", "=", "[", "m", "[", "'x'", "]", ",", "m", "[", "'y'", "]", "]", "\n", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "[", "1.5", ",", "1", "]", "]", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "y_obs", "=", "[", "np", ".", "mean", "(", "y_obs", ")", ",", "np", ".", "std", "(", "y_obs", ")", "]", "\n", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "*", "params", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "# elfi.Summary(partial(np.mean, axis=1), m['sim'], name='Mean')", "\n", "# elfi.Summary(partial(np.std, axis=1), m['sim'], name='Std')", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "\n", "return", "m", "", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bignk.BiGNK": [[12, 109], ["numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "range", "numpy.array", "numpy.einsum", "numpy.einsum", "numpy.repeat", "numpy.swapaxes", "numpy.power", "numpy.swapaxes", "numpy.add", "numpy.swapaxes", "numpy.array", "scipy.multivariate_normal.rvs", "z_batches.append", "numpy.power", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.exp", "numpy.exp"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["def", "BiGNK", "(", "A1", ",", "A2", ",", "B1", ",", "B2", ",", "g1", ",", "g2", ",", "k1", ",", "k2", ",", "rho", ",", "c", "=", ".8", ",", "n_obs", "=", "150", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"Sample the bivariate g-and-k distribution.\n\n    References\n    ----------\n    [1] Drovandi, C. C., & Pettitt, A. N. (2011).\n    Likelihood-free Bayesian estimation of multivariate quantile distributions.\n    Computational Statistics & Data Analysis, 55(9), 2541-2556.\n    [2] Allingham, D., King, R. A. R., & Mengersen, K. L. (2009).\n    Bayesian estimation of quantile distributions.\n    Statistics and Computing, 19(2), 189-201.\n\n    The quantile function of g-and-k distribution is defined as follows:\n\n    Q_{gnk} = A + B * (1 + c * (1 - exp(-g * z(p)) / 1 + exp(-g * z(p))))\n            * (1 + z(p)^2)^k * z(p), where\n\n    z(p) is the p-th standard normal quantile.\n\n    To sample from the g-and-k distribution, draw z(p) ~ N(0, 1) and evaluate Q_{gnk}.\n\n    Parameters\n    ----------\n    A1 : float or array_like\n        Location parameter (the 1st dimension).\n    A2 : float or array_like\n        Location parameter (the 2nd dimension).\n    B1 : float or array_like\n        Scale parameter (the 1st dimension).\n    B2 : float or array_like\n        Scale parameter (the 2nd dimension).\n    g1 : float or array_like\n        Skewness parameter (the 1st dimension).\n    g2 : float or array_like\n        Skewness parameter (the 2nd dimension).\n    k1 : float or array_like\n        Kurtosis parameter (the 1st dimension).\n    k2 : float or array_like\n        Kurtosis parameter (the 2nd dimension).\n    rho : float or array_like\n        Parameters' covariance.\n    c : float, optional\n        Overall asymmetry parameter, by default fixed to 0.8 as in Allingham et al. (2009).\n    n_obs : int, optional\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n\n    Returns\n    -------\n    array_like\n        Yielded points.\n\n    \"\"\"", "\n", "# Transforming the arrays' shape to be compatible with batching.", "\n", "A1", "=", "np", ".", "asanyarray", "(", "A1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "A2", "=", "np", ".", "asanyarray", "(", "A2", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "B1", "=", "np", ".", "asanyarray", "(", "B1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "B2", "=", "np", ".", "asanyarray", "(", "B2", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "g1", "=", "np", ".", "asanyarray", "(", "g1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "g2", "=", "np", ".", "asanyarray", "(", "g2", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "k1", "=", "np", ".", "asanyarray", "(", "k1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "k2", "=", "np", ".", "asanyarray", "(", "k2", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "rho", "=", "np", ".", "asanyarray", "(", "rho", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "# Merging the multi-dimensional parameters.", "\n", "A", "=", "np", ".", "hstack", "(", "(", "A1", ",", "A2", ")", ")", "\n", "B", "=", "np", ".", "hstack", "(", "(", "B1", ",", "B2", ")", ")", "\n", "g", "=", "np", ".", "hstack", "(", "(", "g1", ",", "g2", ")", ")", "\n", "k", "=", "np", ".", "hstack", "(", "(", "k1", ",", "k2", ")", ")", "\n", "\n", "# Obtaining z(p) ~ N(0, 1).", "\n", "z_batches", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "# Initialising a separate covariance matrix for each batch.", "\n", "        ", "matrix_cov", "=", "np", ".", "array", "(", "[", "[", "1", ",", "rho", "[", "i", "]", "]", ",", "[", "rho", "[", "i", "]", ",", "1", "]", "]", ")", "\n", "\n", "z_batch", "=", "ss", ".", "multivariate_normal", ".", "rvs", "(", "cov", "=", "matrix_cov", ",", "size", "=", "n_obs", ",", "random_state", "=", "random_state", ")", "\n", "z_batches", ".", "append", "(", "z_batch", ")", "\n", "", "z", "=", "np", ".", "array", "(", "z_batches", ")", "\n", "\n", "# Obtaining the first bracket term of the quantile function Q_{gnk}.", "\n", "gdotz", "=", "np", ".", "einsum", "(", "'ik,ijk->ijk'", ",", "g", ",", "z", ")", "\n", "term_exp", "=", "(", "1", "-", "np", ".", "exp", "(", "-", "gdotz", ")", ")", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "gdotz", ")", ")", "\n", "term_first", "=", "np", ".", "einsum", "(", "'ik,ijk->ijk'", ",", "B", ",", "(", "1", "+", "c", "*", "(", "term_exp", ")", ")", ")", "\n", "\n", "# Obtaining the second bracket term, of the quantile function Q_{gnk}.", "\n", "term_second_unraised", "=", "1", "+", "np", ".", "power", "(", "z", ",", "2", ")", "\n", "k", "=", "np", ".", "repeat", "(", "k", ",", "n_obs", ",", "axis", "=", "2", ")", "\n", "k", "=", "np", ".", "swapaxes", "(", "k", ",", "1", ",", "2", ")", "\n", "term_second", "=", "np", ".", "power", "(", "term_second_unraised", ",", "k", ")", "\n", "\n", "# Evaluating the quantile function Q_{gnk}.", "\n", "term_product", "=", "term_first", "*", "term_second", "*", "z", "\n", "term_product_misaligned", "=", "np", ".", "swapaxes", "(", "term_product", ",", "1", ",", "0", ")", "\n", "y_misaligned", "=", "np", ".", "add", "(", "A", ",", "term_product_misaligned", ")", "\n", "y_obs", "=", "np", ".", "swapaxes", "(", "y_misaligned", ",", "1", ",", "0", ")", "\n", "return", "y_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bignk.get_model": [[111, 160], ["elfi.new_model", "priors.append", "priors.append", "priors.append", "priors.append", "priors.append", "priors.append", "priors.append", "priors.append", "priors.append", "bignk.BiGNK", "functools.partial", "elfi.Simulator", "elfi.Summary", "elfi.Discrepancy", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "numpy.finfo", "elfi.Prior", "numpy.random.RandomState"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bignk.BiGNK"], ["", "def", "get_model", "(", "n_obs", "=", "150", ",", "true_params", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return an initialised bivariate g-and-k model.\n\n    Parameters\n    ----------\n    n_obs : int, optional\n        Number of the observations.\n    true_params : array_like, optional\n        Parameters defining the model.\n    seed : np.random.RandomState, optional\n\n    Returns\n    -------\n    elfi.ElfiModel\n\n    \"\"\"", "\n", "m", "=", "elfi", ".", "new_model", "(", ")", "\n", "\n", "# Initialising the parameters as in Drovandi & Pettitt (2011).", "\n", "if", "true_params", "is", "None", ":", "\n", "        ", "true_params", "=", "[", "3", ",", "4", ",", "1", ",", "0.5", ",", "1", ",", "2", ",", ".5", ",", ".4", ",", "0.6", "]", "\n", "\n", "# Initialising the prior settings as in Drovandi & Pettitt (2011).", "\n", "", "priors", "=", "[", "]", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "5", ",", "model", "=", "m", ",", "name", "=", "'a1'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "5", ",", "model", "=", "m", ",", "name", "=", "'a2'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "5", ",", "model", "=", "m", ",", "name", "=", "'b1'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "5", ",", "model", "=", "m", ",", "name", "=", "'b2'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "5", ",", "10", ",", "model", "=", "m", ",", "name", "=", "'g1'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "5", ",", "10", ",", "model", "=", "m", ",", "name", "=", "'g2'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", ".5", ",", "5.5", ",", "model", "=", "m", ",", "name", "=", "'k1'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", ".5", ",", "5.5", ",", "model", "=", "m", ",", "name", "=", "'k2'", ")", ")", "\n", "EPS", "=", "np", ".", "finfo", "(", "float", ")", ".", "eps", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "1", "+", "EPS", ",", "2", "-", "2", "*", "EPS", ",", "model", "=", "m", ",", "name", "=", "'rho'", ")", ")", "\n", "\n", "# Obtaining the observations.", "\n", "y_obs", "=", "BiGNK", "(", "*", "true_params", ",", "n_obs", "=", "n_obs", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", ")", "\n", "\n", "# Defining the simulator.", "\n", "fn_simulator", "=", "partial", "(", "BiGNK", ",", "n_obs", "=", "n_obs", ")", "\n", "elfi", ".", "Simulator", "(", "fn_simulator", ",", "*", "priors", ",", "observed", "=", "y_obs", ",", "name", "=", "'BiGNK'", ")", "\n", "\n", "# Initialising the default summary statistics.", "\n", "default_ss", "=", "elfi", ".", "Summary", "(", "ss_robust", ",", "m", "[", "'BiGNK'", "]", ",", "name", "=", "'ss_robust'", ")", "\n", "\n", "# Using the customEuclidean distance function designed for", "\n", "# the summary statistics of shape (batch_size, dim_ss, dim_ss_point).", "\n", "elfi", ".", "Discrepancy", "(", "euclidean_multiss", ",", "default_ss", ",", "name", "=", "'d'", ")", "\n", "return", "m", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.xcosx.__init__": [[135, 137], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.xcosx.func": [[138, 164], ["numpy.asanyarray().reshape", "random_state.randn", "numpy.cos", "numpy.asanyarray"], "methods", ["None"], ["", "def", "func", "(", "self", ",", "t1", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Generate a sequence of samples from the MA2 model.\n\n        The sequence is a moving average\n\n            x_i = w_i + \\theta_1 w_{i-1} + \\theta_2 w_{i-2}\n\n        where w_i are white noise ~ N(0,1).\n\n        Parameters\n        ----------\n        t1 : float, array_like\n        t2 : float, array_like\n        n_obs : int, optional\n        batch_size : int, optional\n        random_state : RandomState, optional\n\n        \"\"\"", "\n", "# Make inputs 2d arrays for broadcasting with w", "\n", "t1", "=", "np", ".", "asanyarray", "(", "t1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "# i.i.d. sequence ~ N(0,1)", "\n", "w", "=", "random_state", ".", "randn", "(", "batch_size", ",", "1", ")", "\n", "x", "=", "t1", "*", "np", ".", "cos", "(", "t1", "*", "np", ".", "pi", "/", "180", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.xcosx.get_model": [[165, 190], ["dgp_funcs.xcosx.func", "elfi.ElfiModel", "elfi.Prior", "elfi.Simulator", "elfi.Distance", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete MA2 model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "90", "]", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "uniform", ",", "0", ",", "360", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "m", "[", "'t1'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.logistic.__init__": [[193, 195], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.logistic.func": [[196, 219], ["numpy.asanyarray().reshape", "random_state.randn", "numpy.asanyarray", "numpy.exp"], "methods", ["None"], ["", "def", "func", "(", "self", ",", "t1", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Generate a sequence of samples from the MA2 model.\n\n        The sequence is a moving average\n\n            x_i = w_i + \\theta_1 w_{i-1} + \\theta_2 w_{i-2}\n\n        where w_i are white noise ~ N(0,1).\n\n        Parameters\n        ----------\n        t1 : float, array_like\n        t2 : float, array_like\n        n_obs : int, optional\n        batch_size : int, optional\n        random_state : RandomState, optional\n\n        \"\"\"", "\n", "t1", "=", "np", ".", "asanyarray", "(", "t1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "w", "=", "random_state", ".", "randn", "(", "batch_size", ",", "1", ")", "\n", "x", "=", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "0.1", "*", "(", "t1", "-", "180", ")", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.logistic.get_model": [[221, 247], ["dgp_funcs.logistic.func", "elfi.ElfiModel", "elfi.Prior", "elfi.Simulator", "elfi.Distance", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete MA2 model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "90", "]", "\n", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "uniform", ",", "0", ",", "360", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "m", "[", "'t1'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.multigaussian.__init__": [[250, 252], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.multigaussian.N": [[253, 255], ["numpy.exp", "numpy.sqrt", "numpy.power"], "methods", ["None"], ["", "def", "N", "(", "self", ",", "mu", ",", "sigma", ",", "x", ")", ":", "\n", "        ", "return", "(", "1", "/", "(", "sigma", "*", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", ")", ")", "*", "np", ".", "exp", "(", "(", "-", "1", "/", "2", ")", "*", "np", ".", "power", "(", "(", "x", "-", "mu", ")", "/", "sigma", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.multigaussian.func": [[257, 280], ["numpy.asanyarray().reshape", "random_state.randn", "numpy.asanyarray", "dgp_funcs.multigaussian.N", "dgp_funcs.multigaussian.N", "dgp_funcs.multigaussian.N"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.N", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.N", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.N"], ["", "def", "func", "(", "self", ",", "t1", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Generate a sequence of samples from the MA2 model.\n\n        The sequence is a moving average\n\n            x_i = w_i + \\theta_1 w_{i-1} + \\theta_2 w_{i-2}\n\n        where w_i are white noise ~ N(0,1).\n\n        Parameters\n        ----------\n        t1 : float, array_like\n        t2 : float, array_like\n        n_obs : int, optional\n        batch_size : int, optional\n        random_state : RandomState, optional\n\n        \"\"\"", "\n", "t1", "=", "np", ".", "asanyarray", "(", "t1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "w", "=", "random_state", ".", "randn", "(", "batch_size", ",", "1", ")", "/", "400", "\n", "x", "=", "self", ".", "N", "(", "30", ",", "15", ",", "t1", ")", "+", "self", ".", "N", "(", "60", ",", "5", ",", "t1", ")", "+", "self", ".", "N", "(", "100", ",", "4", ",", "t1", ")", "+", "w", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.multigaussian.get_model": [[282, 308], ["dgp_funcs.multigaussian.func", "elfi.ElfiModel", "elfi.Prior", "elfi.Simulator", "elfi.Distance", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete MA2 model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "50", "]", "\n", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "uniform", ",", "0", ",", "100", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "m", "[", "'t1'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.multimodal_logistic.__init__": [[313, 317], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "n", "=", "0.5", ",", "offset", "=", "50", ",", "noise", "=", "0.01", ")", ":", "\n", "        ", "self", ".", "offset", "=", "offset", "\n", "self", ".", "n", "=", "n", "\n", "self", ".", "noise", "=", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.multimodal_logistic.func": [[319, 355], ["numpy.asanyarray().reshape", "len", "random_state.randn", "random_state.uniform", "list", "range", "numpy.array", "list.append", "numpy.asanyarray", "numpy.exp", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "func", "(", "self", ",", "t1", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Generate a sequence of samples from the MA2 model.\n\n        The sequence is a moving average\n\n            x_i = w_i + \\theta_1 w_{i-1} + \\theta_2 w_{i-2}\n\n        where w_i are white noise ~ N(0,1).\n\n        Parameters\n        ----------\n        t1 : float, array_like\n        t2 : float, array_like\n        n_obs : int, optional\n        batch_size : int, optional\n        random_state : RandomState, optional\n\n        \"\"\"", "\n", "t1", "=", "np", ".", "asanyarray", "(", "t1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "batch_size", "=", "len", "(", "t1", ")", "\n", "w", "=", "random_state", ".", "randn", "(", "batch_size", ",", "1", ")", "\n", "source", "=", "random_state", ".", "uniform", "(", "size", "=", "batch_size", ")", "\n", "x", "=", "list", "(", ")", "\n", "# print(source)", "\n", "#print(w)", "\n", "\n", "for", "el", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "if", "source", "[", "el", "]", "<", "self", ".", "n", ":", "\n", "                ", "temp", "=", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "0.1", "*", "(", "t1", "[", "el", "]", "-", "self", ".", "offset", ")", ")", ")", "+", "w", "[", "el", "]", "*", "self", ".", "noise", "\n", "", "else", ":", "\n", "                ", "temp", "=", "-", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "0.1", "*", "(", "t1", "[", "el", "]", "-", "self", ".", "offset", ")", ")", ")", "+", "w", "[", "el", "]", "*", "self", ".", "noise", "+", "1", "\n", "", "x", ".", "append", "(", "temp", ")", "\n", "#zprint(x)", "\n", "", "return", "np", ".", "array", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.multimodal_logistic.get_model": [[357, 383], ["dgp_funcs.multimodal_logistic.func", "elfi.ElfiModel", "elfi.Prior", "elfi.Simulator", "elfi.Distance", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete MA2 model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "20", "]", "\n", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "uniform", ",", "0", ",", "100", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "m", "[", "'t1'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.beta_x.__init__": [[387, 389], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.beta_x.func": [[390, 419], ["numpy.asanyarray().reshape", "len", "list", "range", "numpy.array", "list.append", "numpy.asanyarray", "numpy.random.beta", "numpy.random.beta"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "func", "(", "self", ",", "t1", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Generate a sequence of samples from the MA2 model.\n\n        The sequence is a moving average\n\n            x_i = w_i + \\theta_1 w_{i-1} + \\theta_2 w_{i-2}\n\n        where w_i are white noise ~ N(0,1).\n\n        Parameters\n        ----------\n        t1 : float, array_like\n        t2 : float, array_like\n        n_obs : int, optional\n        batch_size : int, optional\n        random_state : RandomState, optional\n\n        \"\"\"", "\n", "t1", "=", "np", ".", "asanyarray", "(", "t1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "batch_size", "=", "len", "(", "t1", ")", "\n", "x", "=", "list", "(", ")", "\n", "\n", "#print(t1)", "\n", "for", "el", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "w", "=", "np", ".", "random", ".", "beta", "(", "t1", "[", "el", "]", "+", "1", ",", "5", ",", "size", "=", "1", ")", "+", "np", ".", "random", ".", "beta", "(", "5", ",", "t1", "[", "el", "]", "+", "1", ",", "size", "=", "1", ")", "\n", "x", ".", "append", "(", "w", ")", "\n", "# print(x)", "\n", "", "return", "np", ".", "array", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.beta_x.get_model": [[421, 448], ["dgp_funcs.beta_x.func", "numpy.mean", "elfi.ElfiModel", "elfi.Prior", "elfi.Simulator", "elfi.Distance", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete MA2 model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "20", "]", "\n", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "batch_size", "=", "100", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "y_obs", "=", "np", ".", "mean", "(", "y_obs", ")", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "uniform", ",", "0", ",", "100", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "m", "[", "'t1'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.__init__": [[453, 455], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.N": [[456, 458], ["numpy.exp", "numpy.sqrt", "numpy.power"], "methods", ["None"], ["", "def", "N", "(", "self", ",", "mu", ",", "sigma", ",", "x", ")", ":", "\n", "        ", "return", "(", "1", "/", "(", "sigma", "*", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", ")", ")", "*", "np", ".", "exp", "(", "(", "-", "1", "/", "2", ")", "*", "np", ".", "power", "(", "(", "x", "-", "mu", ")", "/", "sigma", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.func": [[460, 494], ["numpy.asanyarray().reshape", "len", "random_state.uniform", "range", "numpy.array().flatten", "random_state.randn", "x.append", "numpy.asanyarray", "numpy.array", "dgp_funcs.bigaussian.N", "dgp_funcs.bigaussian.N"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.N", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.N"], ["", "def", "func", "(", "self", ",", "t1", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Generate a sequence of samples from the MA2 model.\n\n        The sequence is a moving average\n\n            x_i = w_i + \\theta_1 w_{i-1} + \\theta_2 w_{i-2}\n\n        where w_i are white noise ~ N(0,1).\n\n        Parameters\n        ----------\n        t1 : float, array_like\n        t2 : float, array_like\n        n_obs : int, optional\n        batch_size : int, optional\n        random_state : RandomState, optional\n\n        \"\"\"", "\n", "t1", "=", "np", ".", "asanyarray", "(", "t1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "batch_size", "=", "len", "(", "t1", ")", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "w", "=", "random_state", ".", "randn", "(", "batch_size", ",", "1", ")", "/", "10000", "\n", "source", "=", "random_state", ".", "uniform", "(", "size", "=", "batch_size", ")", "\n", "\n", "x", "=", "[", "]", "\n", "for", "el", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "if", "source", "[", "el", "]", "<", "0.4", ":", "\n", "                ", "k1", ",", "k2", "=", "1", ",", "0", "\n", "", "elif", "source", "[", "el", "]", ">=", "0.4", ":", "\n", "                ", "k1", ",", "k2", "=", "0", ",", "1", "\n", "\n", "", "temp", "=", "100", "*", "(", "self", ".", "N", "(", "0", ",", "50", ",", "t1", "[", "el", "]", ")", "*", "k1", "+", "self", ".", "N", "(", "60", ",", "55", ",", "t1", "[", "el", "]", ")", "*", "k2", "+", "w", "[", "el", "]", ")", "\n", "x", ".", "append", "(", "temp", ")", "\n", "", "return", "np", ".", "array", "(", "x", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.bigaussian.get_model": [[496, 522], ["dgp_funcs.bigaussian.func", "elfi.ElfiModel", "elfi.Prior", "elfi.Simulator", "elfi.Distance", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete MA2 model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "if", "true_params", "is", "None", ":", "\n", "            ", "true_params", "=", "[", "60", "]", "\n", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "elfi", ".", "Prior", "(", "ss", ".", "uniform", ",", "0", ",", "100", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "m", "[", "'t1'", "]", ",", "observed", "=", "y_obs", ",", "name", "=", "'sim'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'sim'", "]", ",", "name", "=", "'dist'", ")", "\n", "return", "m", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.plot_posterior_samples": [[9, 50], ["numpy.linspace", "posterior", "numpy.linspace", "matplotlib.gca", "matplotlib.xticks", "matplotlib.xlabel", "matplotlib.ylabel", "numpy.arange", "numpy.zeros", "enumerate", "plt.gca.pcolormesh", "plt.gca.scatter", "type", "ValueError", "max", "min", "min", "max", "sklearn.neighbors.KernelDensity", "sklearn.neighbors.KernelDensity.fit", "enumerate", "np.linspace.flatten", "numpy.exp", "type", "len", "len", "Ss.reshape", "sklearn.neighbors.KernelDensity.score", "numpy.std", "len", "float", "numpy.array().reshape", "numpy.array"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.fit"], ["def", "plot_posterior_samples", "(", "target_model", ",", "x_counts", "=", "1000", ",", "samples", "=", "100", ",", "points", "=", "True", ",", "kde", "=", "True", ")", ":", "\n", "    ", "m", "=", "target_model", "\n", "bounds", "=", "m", ".", "bounds", "\n", "S", "=", "samples", "\n", "\n", "if", "type", "(", "m", ")", ".", "__name__", "==", "'DGPRegression'", ":", "\n", "        ", "posterior", "=", "m", ".", "get_posterior", "\n", "", "elif", "type", "(", "m", ")", ".", "__name__", "==", "'GPyRegression'", ":", "\n", "        ", "posterior", "=", "m", ".", "get_posterior", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"The target_model should be either 'DGPRegression'\"", "\n", "\"or 'GpyRegression'\"", ")", "\n", "\n", "", "Xs", "=", "np", ".", "linspace", "(", "*", "bounds", "[", "0", "]", ",", "x_counts", ")", "\n", "samples", "=", "posterior", "(", "Xs", ",", "size", "=", "S", ")", "\n", "samples", "=", "samples", "[", ":", ",", ":", ",", "0", "]", "\n", "ydif", "=", "(", "max", "(", "m", ".", "Y", ")", "-", "min", "(", "m", ".", "Y", ")", ")", "*", "0.15", "\n", "levels", "=", "np", ".", "linspace", "(", "min", "(", "m", ".", "Y", ")", "-", "ydif", ",", "max", "(", "m", ".", "Y", ")", "+", "ydif", ",", "1000", ")", "\n", "\n", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "# ax.set_ylim(min(levels), max(levels))", "\n", "# ax.set_ylim(min(levels), 1.0)", "\n", "# ax.set_xlim(min(Xs), max(Xs))", "\n", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "0", ",", "100", ",", "step", "=", "10", ")", ")", "\n", "plt", ".", "xlabel", "(", "r\"$\\theta$\"", ")", "\n", "plt", ".", "ylabel", "(", "r\"$d(x_\\theta, x_{obs})$\"", ")", "\n", "\n", "if", "kde", "==", "True", ":", "\n", "        ", "cs", "=", "np", ".", "zeros", "(", "(", "len", "(", "Xs", ")", ",", "len", "(", "levels", ")", ")", ")", "\n", "for", "i", ",", "Ss", "in", "enumerate", "(", "samples", ".", "T", ")", ":", "\n", "            ", "bandwidth", "=", "1.06", "*", "np", ".", "std", "(", "Ss", ")", "*", "len", "(", "Ss", ")", "**", "(", "-", "1.", "/", "5", ")", "# Silverman's (1986) rule of thumb.", "\n", "kde", "=", "KernelDensity", "(", "bandwidth", "=", "float", "(", "bandwidth", ")", ")", "\n", "\n", "kde", ".", "fit", "(", "Ss", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "for", "j", ",", "level", "in", "enumerate", "(", "levels", ")", ":", "\n", "                ", "cs", "[", "i", ",", "j", "]", "=", "kde", ".", "score", "(", "np", ".", "array", "(", "level", ")", ".", "reshape", "(", "1", ",", "1", ")", ")", "\n", "", "", "ax", ".", "pcolormesh", "(", "Xs", ".", "flatten", "(", ")", ",", "levels", ",", "np", ".", "exp", "(", "cs", ".", "T", ")", ",", "cmap", "=", "'Blues_r'", ")", "# , alpha=0.1)", "\n", "\n", "", "if", "points", "==", "True", ":", "\n", "        ", "ax", ".", "scatter", "(", "m", ".", "X", ",", "m", ".", "Y", ",", "s", "=", "15", ",", "color", "=", "\"red\"", ",", "zorder", "=", "10", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.plot_variance": [[52, 94], ["numpy.linspace", "posterior", "numpy.linspace", "matplotlib.gca", "matplotlib.xticks", "matplotlib.xlabel", "matplotlib.ylabel", "print", "range", "numpy.arange", "len", "len", "range", "type", "ValueError", "max", "min", "min", "max", "len", "len", "print", "len", "plt.gca.scatter", "type", "cov[].flatten", "np.linspace.flatten", "cov[].flatten", "cov[].flatten"], "function", ["None"], ["", "def", "plot_variance", "(", "target_model", ",", "x_counts", "=", "1000", ",", "samples", "=", "100", ",", "points", "=", "True", ",", "kde", "=", "True", ")", ":", "\n", "    ", "m", "=", "target_model", "\n", "bounds", "=", "m", ".", "bounds", "\n", "S", "=", "samples", "\n", "\n", "if", "type", "(", "m", ")", ".", "__name__", "==", "'DGPRegression'", ":", "\n", "        ", "posterior", "=", "m", ".", "get_posterior", "\n", "", "elif", "type", "(", "m", ")", ".", "__name__", "==", "'GPyRegression'", ":", "\n", "        ", "posterior", "=", "m", ".", "get_posterior", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"The target_model should be either 'DGPRegression'\"", "\n", "\"or 'GpyRegression'\"", ")", "\n", "\n", "", "Xs", "=", "np", ".", "linspace", "(", "*", "bounds", "[", "0", "]", ",", "x_counts", ")", "\n", "samples", ",", "res_mean", ",", "res_var", "=", "posterior", "(", "Xs", ",", "size", "=", "S", ")", "\n", "samples", "=", "samples", "[", ":", ",", ":", ",", "0", "]", "\n", "ydif", "=", "(", "max", "(", "m", ".", "Y", ")", "-", "min", "(", "m", ".", "Y", ")", ")", "*", "0.15", "\n", "levels", "=", "np", ".", "linspace", "(", "min", "(", "m", ".", "Y", ")", "-", "ydif", ",", "max", "(", "m", ".", "Y", ")", "+", "ydif", ",", "1000", ")", "\n", "\n", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "# ax.set_ylim(min(levels), max(levels))", "\n", "# ax.set_ylim(min(levels), 1.0)", "\n", "# ax.set_xlim(min(Xs), max(Xs))", "\n", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "0", ",", "100", ",", "step", "=", "10", ")", ")", "\n", "plt", ".", "xlabel", "(", "r\"$\\theta$\"", ")", "\n", "plt", ".", "ylabel", "(", "r\"$d(x_\\theta, x_{obs})$\"", ")", "\n", "\n", "# build variance", "\n", "#print(res_mean)", "\n", "#print(res_var)", "\n", "print", "(", "len", "(", "res_var", ")", ")", "\n", "clrs", "=", "[", "\"red\"", ",", "\"green\"", ",", "\"blue\"", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "res_var", ")", ")", ":", "\n", "        ", "cov", "=", "res_var", "[", "i", "]", "\n", "\n", "if", "len", "(", "cov", "[", "-", "1", "]", ".", "flatten", "(", ")", ")", "!=", "len", "(", "Xs", ")", ":", "\n", "            ", "print", "(", "cov", "[", "-", "1", "]", ".", "flatten", "(", ")", "[", "0", "]", ")", "\n", "continue", "\n", "\n", "", "for", "j", "in", "range", "(", "0", ",", "len", "(", "cov", ")", ")", ":", "\n", "            ", "ax", ".", "scatter", "(", "Xs", ".", "flatten", "(", ")", ",", "cov", "[", "j", "]", ".", "flatten", "(", ")", ",", "s", "=", "1", ",", "color", "=", "clrs", "[", "i", "]", ",", "zorder", "=", "10", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.plot_d": [[96, 121], ["numpy.linspace", "func", "func", "numpy.sqrt", "matplotlib.gcf", "matplotlib.gca().yaxis.set_major_formatter", "matplotlib.scatter", "matplotlib.rcParams.update", "matplotlib.xticks", "matplotlib.xlabel", "matplotlib.ylabel", "plt.gcf.set_size_inches", "matplotlib.savefig", "matplotlib.close", "matplotlib.ticker.StrMethodFormatter", "numpy.arange", "matplotlib.gca"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "def", "plot_d", "(", "func", ",", "true_params", ",", "bounds", ")", ":", "\n", "    ", "x", "=", "np", ".", "linspace", "(", "*", "bounds", "[", "'t1'", "]", ",", "num", "=", "4000", ")", "\n", "y_true", "=", "func", "(", "*", "true_params", ")", "\n", "ys", "=", "func", "(", "x", ")", "\n", "d", "=", "(", "ys", "-", "y_true", ")", "**", "2", "\n", "sqrtd", "=", "np", ".", "sqrt", "(", "d", ")", "\n", "\n", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "plt", ".", "gca", "(", ")", ".", "yaxis", ".", "set_major_formatter", "(", "StrMethodFormatter", "(", "'{x:,.1f}'", ")", ")", "\n", "plt", ".", "scatter", "(", "x", ",", "sqrtd", ",", "color", "=", "'black'", ",", "s", "=", "1", ")", "\n", "# plt.yticks([])", "\n", "plt", ".", "rcParams", ".", "update", "(", "{", "'font.size'", ":", "10", "}", ")", "\n", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "0", ",", "101", ",", "step", "=", "50", ")", ")", "\n", "\n", "plt", ".", "xlabel", "(", "r\"$\\theta$\"", ")", "\n", "plt", ".", "ylabel", "(", "r\"\"", ")", "\n", "\n", "fig", ".", "set_size_inches", "(", "2.5", ",", "2.1", ")", "\n", "plt", ".", "savefig", "(", "'plots/func.png'", ",", "dpi", "=", "600", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "# plt.xticks(np.arange(min(x), max(x)+1, 10.0))", "\n", "# plt.axvline(0, color = 'black')", "\n", "# plt.axhline(0, color = 'black')", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.dgp_funcs.plot_func": [[123, 132], ["numpy.linspace", "func", "matplotlib.scatter", "matplotlib.xticks", "matplotlib.axvline", "matplotlib.axhline", "numpy.arange", "min", "max"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "def", "plot_func", "(", "func", ",", "bounds", ")", ":", "\n", "    ", "x", "=", "np", ".", "linspace", "(", "*", "bounds", "[", "0", "]", ",", "num", "=", "2000", ")", "\n", "ys", "=", "func", "(", "x", ")", "\n", "\n", "plt", ".", "scatter", "(", "x", ",", "ys", ",", "color", "=", "'black'", ")", "\n", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "min", "(", "x", ")", ",", "max", "(", "x", ")", "+", "1", ",", "10.0", ")", ")", "\n", "plt", ".", "axvline", "(", "0", ",", "color", "=", "'black'", ")", "\n", "plt", ".", "axhline", "(", "0", ",", "color", "=", "'black'", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.__init__": [[9, 19], ["tensorflow.Session().__enter__", "gym.make", "baselines.deepq.learn", "tensorflow.Session"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "env_name", ")", ":", "\n", "        ", "self", ".", "env_name", "=", "env_name", "\n", "if", "self", ".", "env_name", "==", "\"CartPole-v0\"", ":", "\n", "            ", "self", ".", "load_path", "=", "\"cartpole_model.pkl\"", "\n", "", "elif", "self", ".", "env_name", "==", "\"MountainCar-v0\"", ":", "\n", "            ", "self", ".", "load_path", "=", "\"mountaincar_model.pkl\"", "\n", "", "self", ".", "sess", "=", "tf", ".", "Session", "(", ")", ".", "__enter__", "(", ")", "\n", "self", ".", "env", "=", "gym", ".", "make", "(", "self", ".", "env_name", ")", "\n", "self", ".", "act", "=", "deepq", ".", "learn", "(", "self", ".", "env", ",", "network", "=", "'mlp'", ",", "total_timesteps", "=", "0", ",", "load_path", "=", "self", ".", "load_path", ")", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func": [[21, 50], ["len", "range", "openai_gym.control_env.apply_pars", "print", "rewards.append", "openai_gym.control_env.env.reset", "openai_gym.control_env.env.step", "openai_gym.control_env.act"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.apply_pars", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.reset"], ["", "def", "func", "(", "self", ",", "*", "params", ",", "n_obs", "=", "100", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate a sequence of samples from the Open AI env.\n\n        Parameters\n        ----------\n        params : array of envs\n        random_state : RandomState, optional\n\n        \"\"\"", "\n", "batch_size", "=", "len", "(", "params", "[", "0", "]", ")", "\n", "rewards", "=", "[", "]", "\n", "# print('unbatched params:')", "\n", "# print(params)", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "cur_pars", "=", "[", "x", "[", "i", "]", "for", "x", "in", "params", "]", "\n", "#print('Params:')", "\n", "# print(cur_pars)", "\n", "self", ".", "env", "=", "self", ".", "apply_pars", "(", "self", ".", "env", ",", "cur_pars", ")", "\n", "obs", ",", "done", "=", "self", ".", "env", ".", "reset", "(", ")", ",", "False", "\n", "episode_rew", "=", "0", "\n", "while", "not", "done", ":", "\n", "# self.env.render()", "\n", "                ", "obs", ",", "rew", ",", "done", ",", "_", "=", "self", ".", "env", ".", "step", "(", "self", ".", "act", "(", "obs", "[", "None", "]", ")", "[", "0", "]", ")", "\n", "episode_rew", "+=", "rew", "\n", "\n", "# print('Reward:')", "\n", "", "print", "(", "episode_rew", ")", "\n", "rewards", ".", "append", "(", "episode_rew", ")", "\n", "", "return", "rewards", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.get_model": [[52, 96], ["elfi.ElfiModel", "openai_gym.control_env.func", "elfi.Simulator", "elfi.Distance", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.func"], ["", "def", "get_model", "(", "self", ",", "n_obs", "=", "100", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a complete model in inference task.\n\n        Parameters\n        ----------\n        n_obs : int, optional\n            observation length of the MA2 process\n        true_params : list, optional\n            parameters with which the observed data is generated\n        seed_obs : int, optional\n            seed for the observed data generation\n\n        Returns\n        -------\n        m : elfi.ElfiModel\n\n        \"\"\"", "\n", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "if", "true_params", "is", "None", "and", "self", ".", "env_name", "==", "\"CartPole-v0\"", ":", "\n", "# gravity, masscart, masspole, length, force_mag", "\n", "            ", "true_params", "=", "[", "[", "9.8", "]", ",", "[", "1.0", "]", ",", "[", "0.1", "]", ",", "[", "0.5", "]", ",", "[", "10.0", "]", "]", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "5.0", ",", "10.0", ",", "model", "=", "m", ",", "name", "=", "'gravity'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.1", ",", "5", ",", "model", "=", "m", ",", "name", "=", "'masscart'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.1", ",", "5", ",", "model", "=", "m", ",", "name", "=", "'masspole'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.1", ",", "5", ",", "model", "=", "m", ",", "name", "=", "'length'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "5.0", ",", "10.0", ",", "model", "=", "m", ",", "name", "=", "'force_mag'", ")", "\n", "params", "=", "[", "m", "[", "'gravity'", "]", ",", "m", "[", "'masscart'", "]", ",", "m", "[", "'masspole'", "]", ",", "\n", "m", "[", "'length'", "]", ",", "m", "[", "'force_mag'", "]", "]", "\n", "\n", "", "elif", "true_params", "is", "None", "and", "self", ".", "env_name", "==", "\"MountainCar-v0\"", ":", "\n", "# goal_position, goal_velocity, force, gravity", "\n", "            ", "true_params", "=", "[", "0.5", ",", "0", ",", "0.001", ",", "0.0025", "]", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "-", "1.2", ",", "0.6", ",", "model", "=", "m", ",", "name", "=", "'goal_position'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "5.0", ",", "model", "=", "m", ",", "name", "=", "'goal_velocity'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.0001", ",", "0.01", ",", "model", "=", "m", ",", "name", "=", "'force'", ")", "\n", "elfi", ".", "Prior", "(", "'uniform'", ",", "0.0001", ",", "0.01", ",", "model", "=", "m", ",", "name", "=", "'gravity'", ")", "\n", "params", "=", "[", "m", "[", "'goal_position'", "]", ",", "m", "[", "'goal_velocity'", "]", ",", "\n", "m", "[", "'force'", "]", ",", "m", "[", "'gravity'", "]", "]", "\n", "\n", "", "y_obs", "=", "self", ".", "func", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "elfi", ".", "Simulator", "(", "self", ".", "func", ",", "*", "params", ",", "observed", "=", "y_obs", ",", "name", "=", "'DGP'", ")", "\n", "elfi", ".", "Distance", "(", "'euclidean'", ",", "m", "[", "'DGP'", "]", ",", "name", "=", "'d'", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.openai_gym.control_env.apply_pars": [[98, 113], ["None"], "methods", ["None"], ["", "def", "apply_pars", "(", "self", ",", "env", ",", "params", ")", ":", "\n", "        ", "if", "self", ".", "env_name", "==", "\"CartPole-v0\"", ":", "\n", "            ", "env", ".", "gravity", "=", "params", "[", "0", "]", "\n", "env", ".", "masscart", "=", "params", "[", "1", "]", "\n", "env", ".", "masspole", "=", "params", "[", "2", "]", "\n", "env", ".", "total_mass", "=", "(", "env", ".", "masspole", "+", "env", ".", "masscart", ")", "\n", "env", ".", "length", "=", "params", "[", "3", "]", "# actually half the pole's length", "\n", "env", ".", "polemass_length", "=", "(", "env", ".", "masspole", "*", "env", ".", "length", ")", "\n", "env", ".", "force_mag", "=", "params", "[", "4", "]", "\n", "", "elif", "self", ".", "env_name", "==", "\"MountainCar-v0\"", ":", "\n", "            ", "env", ".", "goal_position", "=", "params", "[", "0", "]", "\n", "env", ".", "goal_velocity", "=", "params", "[", "1", "]", "\n", "env", ".", "force", "=", "params", "[", "2", "]", "\n", "env", ".", "gravity", "=", "params", "[", "3", "]", "\n", "", "return", "env", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lotka_volterra.ExpUniform.rvs": [[199, 218], ["scipy.uniform.rvs", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["@", "classmethod", "\n", "def", "rvs", "(", "cls", ",", "a", ",", "b", ",", "size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Draw random variates.\n\n        Parameters\n        ----------\n        a : float or array-like\n        b : float or array-like\n        size : int, optional\n        random_state : RandomState, optional\n\n        Returns\n        -------\n        np.array\n\n        \"\"\"", "\n", "u", "=", "ss", ".", "uniform", ".", "rvs", "(", "loc", "=", "a", ",", "scale", "=", "b", "-", "a", ",", "size", "=", "size", ",", "random_state", "=", "random_state", ")", "\n", "x", "=", "np", ".", "exp", "(", "u", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lotka_volterra.ExpUniform.pdf": [[219, 238], ["numpy.errstate", "numpy.where", "numpy.reciprocal", "numpy.exp", "numpy.exp"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "pdf", "(", "cls", ",", "x", ",", "a", ",", "b", ")", ":", "\n", "        ", "\"\"\"Density function at `x`.\n\n        Parameters\n        ----------\n        x : float or array-like\n        a : float or array-like\n        b : float or array-like\n\n        Returns\n        -------\n        np.array\n\n        \"\"\"", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ")", ":", "\n", "            ", "p", "=", "np", ".", "where", "(", "(", "x", "<", "np", ".", "exp", "(", "a", ")", ")", "|", "(", "x", ">", "np", ".", "exp", "(", "b", ")", ")", ",", "0", ",", "np", ".", "reciprocal", "(", "x", ")", ")", "\n", "p", "/=", "(", "b", "-", "a", ")", "# normalize", "\n", "", "return", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lotka_volterra.lotka_volterra": [[18, 142], ["numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.empty", "numpy.array", "numpy.empty", "numpy.any", "numpy.linspace", "numpy.empty", "range", "numpy.column_stack", "numpy.where", "numpy.where", "numpy.where", "numpy.unique", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.concatenate", "numpy.concatenate", "numpy.errstate", "random_state.exponential", "numpy.cumsum", "random_state.uniform", "numpy.sum", "numpy.isinf", "random_state.normal", "random_state.normal", "numpy.sum", "inv_sum_hazards.ravel", "inv_sum_hazards.ravel", "numpy.empty", "numpy.empty"], "function", ["None"], ["def", "lotka_volterra", "(", "r1", ",", "r2", ",", "r3", ",", "prey_init", "=", "50", ",", "predator_init", "=", "100", ",", "sigma", "=", "0.", ",", "n_obs", "=", "16", ",", "time_end", "=", "30.", ",", "\n", "batch_size", "=", "1", ",", "random_state", "=", "None", ",", "return_full", "=", "False", ")", ":", "\n", "    ", "r\"\"\"Generate sequences from the stochastic Lotka-Volterra model.\n\n    The Lotka-Volterra model is described by 3 reactions\n\n    R1 : X1 -> 2X1       # prey reproduction\n    R2 : X1 + X2 -> 2X2  # predator hunts prey and reproduces\n    R3 : X2 -> 0         # predator death\n\n    The system is solved using the Direct method.\n\n    Gillespie, D. T. (1977) Exact stochastic simulation of coupled chemical reactions.\n        The Journal of Physical Chemistry 81 (25), 2340\u20132361.\n    Lotka, A. J. (1925) Elements of physical biology. Williams & Wilkins Baltimore.\n    Volterra, V. (1926) Fluctuations in the abundance of a species considered mathematically.\n        Nature 118, 558\u2013560.\n\n\n    Parameters\n    ----------\n    r1 : float or np.array\n        Rate of R1.\n    r2 : float or np.array\n        Rate of R2.\n    r3 : float or np.array\n        Rate of R3.\n    prey_init : int or np.array, optional\n        Initial number of prey.\n    predator_init : int or np.array, optional\n        Initial number of predators.\n    sigma : float or np.array, optional\n        Standard deviation of the Gaussian noise added to measurements.\n    n_obs : int, optional\n        Number of observations to return at integer frequency.\n    time_end : float, optional\n        Time allowed for reactions in the Direct method (not the wall time).\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n    return_full : bool, optional\n        If True, return a tuple (observed_stock, observed_times, full_stock, full_times).\n\n    Returns\n    -------\n    stock_obs : np.array\n        Observations in shape (batch_size, n_obs, 2).\n\n    \"\"\"", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "r1", "=", "np", ".", "asanyarray", "(", "r1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "r2", "=", "np", ".", "asanyarray", "(", "r2", ")", ".", "reshape", "(", "-", "1", ")", "\n", "r3", "=", "np", ".", "asanyarray", "(", "r3", ")", ".", "reshape", "(", "-", "1", ")", "\n", "prey_init", "=", "np", ".", "asanyarray", "(", "prey_init", ")", ".", "reshape", "(", "-", "1", ")", "\n", "predator_init", "=", "np", ".", "asanyarray", "(", "predator_init", ")", ".", "reshape", "(", "-", "1", ")", "\n", "sigma", "=", "np", ".", "asanyarray", "(", "sigma", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "n_full", "=", "20000", "\n", "stock", "=", "np", ".", "empty", "(", "(", "batch_size", ",", "n_full", ",", "2", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "stock", "[", ":", ",", "0", ",", "0", "]", "=", "prey_init", "\n", "stock", "[", ":", ",", "0", ",", "1", "]", "=", "predator_init", "\n", "stoichiometry", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "-", "1", ",", "1", "]", ",", "[", "0", ",", "-", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "times", "=", "np", ".", "empty", "(", "(", "batch_size", ",", "n_full", ")", ")", "\n", "times", "[", ":", ",", "0", "]", "=", "0", "\n", "\n", "# iterate until all in batch ok", "\n", "ii", "=", "0", "\n", "while", "np", ".", "any", "(", "times", "[", ":", ",", "ii", "]", "<", "time_end", ")", ":", "\n", "        ", "ii", "+=", "1", "\n", "\n", "# increase the size of arrays if needed", "\n", "if", "ii", "==", "n_full", ":", "\n", "            ", "stock", "=", "np", ".", "concatenate", "(", "(", "stock", ",", "np", ".", "empty", "(", "(", "batch_size", ",", "n_full", ",", "2", ")", ")", ")", ",", "axis", "=", "1", ")", "\n", "times", "=", "np", ".", "concatenate", "(", "(", "times", ",", "np", ".", "empty", "(", "(", "batch_size", ",", "n_full", ")", ")", ")", ",", "axis", "=", "1", ")", "\n", "n_full", "*=", "2", "\n", "\n", "# reaction probabilities", "\n", "", "hazards", "=", "np", ".", "column_stack", "(", "(", "r1", "*", "stock", "[", ":", ",", "ii", "-", "1", ",", "0", "]", ",", "\n", "r2", "*", "stock", "[", ":", ",", "ii", "-", "1", ",", "0", "]", "*", "stock", "[", ":", ",", "ii", "-", "1", ",", "1", "]", ",", "\n", "r3", "*", "stock", "[", ":", ",", "ii", "-", "1", ",", "1", "]", ")", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "inv_sum_hazards", "=", "1.", "/", "np", ".", "sum", "(", "hazards", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "# inf if all dead", "\n", "\n", "delta_t", "=", "random_state", ".", "exponential", "(", "inv_sum_hazards", ".", "ravel", "(", ")", ")", "\n", "times", "[", ":", ",", "ii", "]", "=", "times", "[", ":", ",", "ii", "-", "1", "]", "+", "delta_t", "\n", "\n", "# choose reaction according to their probabilities", "\n", "probs", "=", "hazards", "*", "inv_sum_hazards", "\n", "cumprobs", "=", "np", ".", "cumsum", "(", "probs", "[", ":", ",", ":", "-", "1", "]", ",", "axis", "=", "1", ")", "\n", "x", "=", "random_state", ".", "uniform", "(", "size", "=", "(", "batch_size", ",", "1", ")", ")", "\n", "reaction", "=", "np", ".", "sum", "(", "x", ">=", "cumprobs", ",", "axis", "=", "1", ")", "\n", "\n", "# null reaction if both populations dead", "\n", "", "reaction", "=", "np", ".", "where", "(", "np", ".", "isinf", "(", "inv_sum_hazards", ".", "ravel", "(", ")", ")", ",", "3", ",", "reaction", ")", "\n", "\n", "# update stock", "\n", "stock", "[", ":", ",", "ii", ",", ":", "]", "=", "stock", "[", ":", ",", "ii", "-", "1", ",", ":", "]", "+", "stoichiometry", "[", "reaction", ",", ":", "]", "\n", "\n", "# no point to continue if predators = 0", "\n", "times", "[", ":", ",", "ii", "]", "=", "np", ".", "where", "(", "stock", "[", ":", ",", "ii", ",", "1", "]", "==", "0", ",", "time_end", ",", "times", "[", ":", ",", "ii", "]", ")", "\n", "\n", "", "stock", "=", "stock", "[", ":", ",", ":", "ii", "+", "1", ",", ":", "]", "\n", "times", "=", "times", "[", ":", ",", ":", "ii", "+", "1", "]", "\n", "\n", "times_out", "=", "np", ".", "linspace", "(", "0", ",", "time_end", ",", "n_obs", ")", "\n", "stock_out", "=", "np", ".", "empty", "(", "(", "batch_size", ",", "n_obs", ",", "2", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "stock_out", "[", ":", ",", "0", ",", ":", "]", "=", "stock", "[", ":", ",", "0", ",", ":", "]", "\n", "\n", "# observations at even intervals", "\n", "for", "ii", "in", "range", "(", "1", ",", "n_obs", ")", ":", "\n", "        ", "iy", ",", "ix", "=", "np", ".", "where", "(", "times", ">=", "times_out", "[", "ii", "]", ")", "\n", "iy", ",", "iix", "=", "np", ".", "unique", "(", "iy", ",", "return_index", "=", "True", ")", "\n", "ix", "=", "ix", "[", "iix", "]", "-", "1", "\n", "time_term", "=", "(", "times_out", "[", "ii", "]", "-", "times", "[", "iy", ",", "ix", "]", ")", "/", "(", "times", "[", "iy", ",", "ix", "+", "1", "]", "-", "times", "[", "iy", ",", "ix", "]", ")", "\n", "stock_out", "[", ":", ",", "ii", ",", "0", "]", "=", "(", "stock", "[", "iy", ",", "ix", "+", "1", ",", "0", "]", "-", "stock", "[", "iy", ",", "ix", ",", "0", "]", ")", "*", "time_term", "+", "stock", "[", "iy", ",", "ix", ",", "0", "]", "+", "random_state", ".", "normal", "(", "scale", "=", "sigma", ",", "size", "=", "batch_size", ")", "\n", "stock_out", "[", ":", ",", "ii", ",", "1", "]", "=", "(", "stock", "[", "iy", ",", "ix", "+", "1", ",", "1", "]", "-", "stock", "[", "iy", ",", "ix", ",", "1", "]", ")", "*", "time_term", "+", "stock", "[", "iy", ",", "ix", ",", "1", "]", "+", "random_state", ".", "normal", "(", "scale", "=", "sigma", ",", "size", "=", "batch_size", ")", "\n", "\n", "", "if", "return_full", ":", "\n", "        ", "return", "(", "stock_out", ",", "times_out", ",", "stock", ",", "times", ")", "\n", "\n", "", "return", "stock_out", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lotka_volterra.get_model": [[144, 189], ["logging.getLogger", "lotka_volterra.lotka_volterra", "elfi.ElfiModel", "functools.partial", "priors.append", "priors.append", "priors.append", "priors.append", "priors.append", "priors.append", "elfi.Simulator", "sumstats.append", "sumstats.append", "elfi.Distance", "logging.getLogger.info", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Summary", "elfi.Summary", "numpy.random.RandomState", "numpy.log", "numpy.log", "functools.partial", "functools.partial"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lotka_volterra.lotka_volterra", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "get_model", "(", "n_obs", "=", "50", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return a complete Lotka-Volterra model in inference task.\n\n    Parameters\n    ----------\n    n_obs : int, optional\n        Number of observations.\n    true_params : list, optional\n        Parameters with which the observed data is generated.\n    seed_obs : int, optional\n        Seed for the observed data generation.\n\n    Returns\n    -------\n    m : elfi.ElfiModel\n\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", ")", "\n", "if", "true_params", "is", "None", ":", "\n", "        ", "true_params", "=", "[", "1.0", ",", "0.005", ",", "0.6", ",", "50", ",", "100", ",", "10.", "]", "\n", "\n", "", "kwargs", "[", "'n_obs'", "]", "=", "n_obs", "\n", "y_obs", "=", "lotka_volterra", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ",", "**", "kwargs", ")", "\n", "\n", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "sim_fn", "=", "partial", "(", "lotka_volterra", ",", "**", "kwargs", ")", "\n", "priors", "=", "[", "]", "\n", "sumstats", "=", "[", "]", "\n", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "ExpUniform", ",", "-", "2", ",", "0", ",", "model", "=", "m", ",", "name", "=", "'r1'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "ExpUniform", ",", "-", "5", ",", "-", "2.5", ",", "model", "=", "m", ",", "name", "=", "'r2'", ")", ")", "# easily kills populations", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "ExpUniform", ",", "-", "2", ",", "0", ",", "model", "=", "m", ",", "name", "=", "'r3'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'poisson'", ",", "50", ",", "model", "=", "m", ",", "name", "=", "'prey0'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'poisson'", ",", "100", ",", "model", "=", "m", ",", "name", "=", "'predator0'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "ExpUniform", ",", "np", ".", "log", "(", "0.5", ")", ",", "np", ".", "log", "(", "50", ")", ",", "model", "=", "m", ",", "name", "=", "'sigma'", ")", ")", "\n", "\n", "elfi", ".", "Simulator", "(", "sim_fn", ",", "*", "priors", ",", "observed", "=", "y_obs", ",", "name", "=", "'LV'", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "partial", "(", "pick_stock", ",", "species", "=", "0", ")", ",", "m", "[", "'LV'", "]", ",", "name", "=", "'prey'", ")", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "partial", "(", "pick_stock", ",", "species", "=", "1", ")", ",", "m", "[", "'LV'", "]", ",", "name", "=", "'predator'", ")", ")", "\n", "elfi", ".", "Distance", "(", "'sqeuclidean'", ",", "*", "sumstats", ",", "name", "=", "'d'", ")", "\n", "\n", "logger", ".", "info", "(", "\"Generated %i observations with true parameters r1: %.1f, r2: %.3f, r3: %.1f, \"", "\n", "\"prey0: %i, predator0: %i, sigma: %.1f.\"", ",", "n_obs", ",", "*", "true_params", ")", "\n", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lotka_volterra.pick_stock": [[240, 255], ["None"], "function", ["None"], ["", "", "def", "pick_stock", "(", "stock", ",", "species", ")", ":", "\n", "    ", "\"\"\"Return the stock for single species.\n\n    Parameters\n    ----------\n    stock : np.array\n    species : int\n        0 for prey, 1 for predator.\n\n    Returns\n    -------\n    np.array\n\n    \"\"\"", "\n", "return", "stock", "[", ":", ",", ":", ",", "species", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.daycare.daycare": [[16, 139], ["numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "numpy.zeros", "numpy.zeros", "numpy.any", "numpy.full", "numpy.repeat", "numpy.tile", "numpy.where", "numpy.tile", "numpy.any", "numpy.where", "random_state.exponential", "probs.reshape.reshape", "numpy.cumsum", "random_state.uniform", "numpy.sum", "numpy.logical_not", "numpy.asanyarray", "numpy.asanyarray", "numpy.asanyarray", "numpy.arange", "numpy.arange", "numpy.errstate", "numpy.isfinite", "numpy.sum", "list", "numpy.sum", "numpy.unravel_index", "np.sum.ravel", "numpy.sum"], "function", ["None"], ["def", "daycare", "(", "t1", ",", "t2", ",", "t3", ",", "n_dcc", "=", "29", ",", "n_ind", "=", "53", ",", "n_strains", "=", "33", ",", "freq_strains_commun", "=", "None", ",", "\n", "n_obs", "=", "36", ",", "time_end", "=", "10.", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "r\"\"\"Generate cross-sectional data from a stochastic variant of the SIS-model.\n\n    This function simulates the transmission dynamics of bacterial infections in daycare centers\n    (DCC) as described in Nummelin et al. [2013]. The observation model is however simplified to\n    an equal number of sampled individuals among the daycare centers.\n\n    The model is defined as a continuous-time Markov process with transition probabilities:\n\n    Pr(I_{is}(t+dt)=1 | I_{is}(t)=0) = t1 * E_s(I(t)) + t2 * P_s, if \\sum_{j=1}^N_s I_{ij}(t)=0\n    Pr(I_{is}(t+dt)=1 | I_{is}(t)=0) = t3 * (t1 * E_s(I(t)) + t2 * P_s), otherwise\n    Pr(I_{is}(t+dt)=0 | I_{is}(t)=1) = \\gamma\n\n    where:\n    I_{is}(t) is the status of carriage of strain s for individual i.\n    E_s(I(t)) is the probability of sampling the strain s\n    t1 is the rate of transmission from other children at the DCC (\\beta in paper).\n    t2 is the rate of transmission from the community outside the DCC (\\Lambda in paper).\n    t3 scales the rate of an infected child being infected with another strain (\\theta in paper).\n    \\gamma is the relative probability of healing from a strain.\n\n    As in the paper, \\gamma=1, and the other inferred parameters are relative to it.\n\n    The system is solved using the Direct method [Gillespie, 1977].\n\n    References\n    ----------\n    Numminen, E., Cheng, L., Gyllenberg, M. and Corander, J. (2013) Estimating the transmission\n        dynamics of Streptococcus pneumoniae from strain prevalence data, Biometrics, 69, 748-757.\n    Gillespie, D. T. (1977) Exact stochastic simulation of coupled chemical reactions.\n        The Journal of Physical Chemistry 81 (25), 2340\u20132361.\n\n    Parameters\n    ----------\n    t1 : float or np.array\n        Rate of transmission from other individuals at the DCC.\n    t2 : float or np.array\n        Rate of transmission from the community outside the DCC.\n    t3 : float or np.array\n        Scaling of co-infection for individuals infected with another strain.\n    n_dcc : int, optional\n        Number of daycare centers.\n    n_ind : int, optional\n        Number of individuals in a DCC (same for all).\n    n_strains : int, optional\n        Number of bacterial strains considered.\n    freq_strains_commun : np.array of shape (n_strains,), optional\n        Prevalence of each strain in the community outside the DCC. Defaults to 0.1.\n    n_obs : int, optional\n        Number of individuals sampled from each DCC (same for all).\n    time_end : float, optional\n        The system is solved using the Direct method until all cases within the batch exceed this.\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n\n    Returns\n    -------\n    state_obs : np.array\n        Observations in shape (batch_size, n_dcc, n_obs, n_strains).\n\n    \"\"\"", "\n", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "t1", "=", "np", ".", "asanyarray", "(", "t1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "t2", "=", "np", ".", "asanyarray", "(", "t2", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "t3", "=", "np", ".", "asanyarray", "(", "t3", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "if", "freq_strains_commun", "is", "None", ":", "\n", "        ", "freq_strains_commun", "=", "np", ".", "full", "(", "n_strains", ",", "0.1", ")", "\n", "\n", "", "prob_commun", "=", "t2", "*", "freq_strains_commun", "\n", "\n", "# the state (infection status) is a 4D tensor for computational performance", "\n", "state", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "n_dcc", ",", "n_ind", ",", "n_strains", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "\n", "# time for each DCC in the batch", "\n", "time", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "n_dcc", ")", ")", "\n", "\n", "n_factor", "=", "1.", "/", "(", "n_ind", "-", "1", ")", "\n", "gamma", "=", "1.", "# relative, see paper", "\n", "ind_b_dcc", "=", "[", "np", ".", "repeat", "(", "np", ".", "arange", "(", "batch_size", ")", ",", "n_dcc", ")", ",", "np", ".", "tile", "(", "np", ".", "arange", "(", "n_dcc", ")", ",", "batch_size", ")", "]", "\n", "\n", "while", "np", ".", "any", "(", "time", "<", "time_end", ")", ":", "\n", "        ", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "# probability of sampling a strain; in paper: E_s(I(t))", "\n", "            ", "prob_strain", "=", "np", ".", "sum", "(", "state", "/", "np", ".", "sum", "(", "state", ",", "axis", "=", "3", ",", "keepdims", "=", "True", ")", ",", "\n", "axis", "=", "2", ",", "keepdims", "=", "True", ")", "*", "n_factor", "\n", "", "prob_strain", "=", "np", ".", "where", "(", "np", ".", "isfinite", "(", "prob_strain", ")", ",", "prob_strain", ",", "0", ")", "\n", "\n", "# init prob to get infected, same for all", "\n", "hazards", "=", "t1", "*", "prob_strain", "+", "prob_commun", "# shape (batch_size, n_dcc, 1, n_strains)", "\n", "\n", "# co-infection, depends on the individual's state", "\n", "hazards", "=", "np", ".", "tile", "(", "hazards", ",", "(", "1", ",", "1", ",", "n_ind", ",", "1", ")", ")", "\n", "any_infection", "=", "np", ".", "any", "(", "state", ",", "axis", "=", "3", ",", "keepdims", "=", "True", ")", "\n", "hazards", "=", "np", ".", "where", "(", "any_infection", ",", "t3", "*", "hazards", ",", "hazards", ")", "\n", "\n", "# (relative) probability to be cured", "\n", "hazards", "[", "state", "]", "=", "gamma", "\n", "\n", "# normalize to probabilities", "\n", "inv_sum_hazards", "=", "1.", "/", "np", ".", "sum", "(", "hazards", ",", "axis", "=", "(", "2", ",", "3", ")", ",", "keepdims", "=", "True", ")", "\n", "probs", "=", "hazards", "*", "inv_sum_hazards", "\n", "\n", "# times until next transition (for each DCC in the batch)", "\n", "delta_t", "=", "random_state", ".", "exponential", "(", "inv_sum_hazards", "[", ":", ",", ":", ",", "0", ",", "0", "]", ")", "\n", "time", "=", "time", "+", "delta_t", "\n", "\n", "# choose transition", "\n", "probs", "=", "probs", ".", "reshape", "(", "(", "batch_size", ",", "n_dcc", ",", "-", "1", ")", ")", "\n", "cumprobs", "=", "np", ".", "cumsum", "(", "probs", "[", ":", ",", ":", ",", ":", "-", "1", "]", ",", "axis", "=", "2", ")", "\n", "x", "=", "random_state", ".", "uniform", "(", "size", "=", "(", "batch_size", ",", "n_dcc", ",", "1", ")", ")", "\n", "ind_transit", "=", "np", ".", "sum", "(", "x", ">=", "cumprobs", ",", "axis", "=", "2", ")", "\n", "\n", "# update state, need to find the correct indices first", "\n", "ind_transit", "=", "ind_b_dcc", "+", "list", "(", "np", ".", "unravel_index", "(", "ind_transit", ".", "ravel", "(", ")", ",", "(", "n_ind", ",", "n_strains", ")", ")", ")", "\n", "state", "[", "ind_transit", "]", "=", "np", ".", "logical_not", "(", "state", "[", "ind_transit", "]", ")", "\n", "\n", "# observation model: simply take the first n_obs individuals", "\n", "", "state_obs", "=", "state", "[", ":", ",", ":", ",", ":", "n_obs", ",", ":", "]", "\n", "\n", "return", "state_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.daycare.get_model": [[141, 193], ["logging.getLogger", "elfi.ElfiModel", "daycare.daycare", "functools.partial", "priors.append", "priors.append", "priors.append", "elfi.Simulator", "sumstats.append", "sumstats.append", "sumstats.append", "sumstats.append", "elfi.Discrepancy", "logging.getLogger.info", "elfi.Prior", "elfi.Prior", "elfi.Prior", "elfi.Summary", "elfi.Summary", "elfi.Summary", "elfi.Summary", "numpy.random.RandomState"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.daycare.daycare", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "get_model", "(", "true_params", "=", "None", ",", "seed_obs", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return a complete ELFI graph ready for inference.\n\n    Selection of true values, priors etc. follows the approach in\n\n    Numminen, E., Cheng, L., Gyllenberg, M. and Corander, J.: Estimating the transmission dynamics\n    of Streptococcus pneumoniae from strain prevalence data, Biometrics, 69, 748-757, 2013.\n\n    and\n\n    Gutmann M U, Corander J (2016). Bayesian Optimization for Likelihood-Free Inference\n    of Simulator-Based Statistical Models. JMLR 17(125):1\u221247, 2016.\n\n    Parameters\n    ----------\n    true_params : list, optional\n        Parameters with which the observed data is generated.\n    seed_obs : int, optional\n        Seed for the observed data generation.\n\n    Returns\n    -------\n    m : elfi.ElfiModel\n\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", ")", "\n", "if", "true_params", "is", "None", ":", "\n", "        ", "true_params", "=", "[", "3.6", ",", "0.6", ",", "0.1", "]", "\n", "\n", "", "m", "=", "elfi", ".", "ElfiModel", "(", ")", "\n", "y_obs", "=", "daycare", "(", "*", "true_params", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ",", "**", "kwargs", ")", "\n", "sim_fn", "=", "partial", "(", "daycare", ",", "**", "kwargs", ")", "\n", "priors", "=", "[", "]", "\n", "sumstats", "=", "[", "]", "\n", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "11", ",", "model", "=", "m", ",", "name", "=", "'t1'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "2", ",", "model", "=", "m", ",", "name", "=", "'t2'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "0", ",", "1", ",", "model", "=", "m", ",", "name", "=", "'t3'", ")", ")", "\n", "\n", "elfi", ".", "Simulator", "(", "sim_fn", ",", "*", "priors", ",", "observed", "=", "y_obs", ",", "name", "=", "'DCC'", ")", "\n", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "ss_shannon", ",", "m", "[", "'DCC'", "]", ",", "name", "=", "'Shannon'", ")", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "ss_strains", ",", "m", "[", "'DCC'", "]", ",", "name", "=", "'n_strains'", ")", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "ss_prevalence", ",", "m", "[", "'DCC'", "]", ",", "name", "=", "'prevalence'", ")", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "ss_prevalence_multi", ",", "m", "[", "'DCC'", "]", ",", "name", "=", "'multi'", ")", ")", "\n", "\n", "elfi", ".", "Discrepancy", "(", "distance", ",", "*", "sumstats", ",", "name", "=", "'d'", ")", "\n", "\n", "logger", ".", "info", "(", "\"Generated observations with true parameters \"", "\n", "\"t1: %.1f, t2: %.3f, t3: %.1f, \"", ",", "*", "true_params", ")", "\n", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.daycare.ss_shannon": [[195, 215], ["numpy.sum", "numpy.sum", "numpy.log"], "function", ["None"], ["", "def", "ss_shannon", "(", "data", ")", ":", "\n", "    ", "r\"\"\"Calculate the Shannon index of diversity of the distribution of observed strains.\n\n    H = -\\sum p \\log(p)\n\n    https://en.wikipedia.org/wiki/Diversity_index#Shannon_index\n\n    Parameters\n    ----------\n    data : np.array of shape (batch_size, n_dcc, n_obs, n_strains)\n\n    Returns\n    -------\n    np.array of shape (batch_size, n_dcc)\n\n    \"\"\"", "\n", "proportions", "=", "np", ".", "sum", "(", "data", ",", "axis", "=", "2", ")", "/", "data", ".", "shape", "[", "2", "]", "\n", "shannon", "=", "-", "np", ".", "sum", "(", "proportions", "*", "np", ".", "log", "(", "proportions", "+", "1e-9", ")", ",", "axis", "=", "2", ")", "# axis 3 is now 2", "\n", "\n", "return", "shannon", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.daycare.ss_strains": [[217, 233], ["numpy.any", "numpy.sum"], "function", ["None"], ["", "def", "ss_strains", "(", "data", ")", ":", "\n", "    ", "\"\"\"Calculate the number of different strains observed.\n\n    Parameters\n    ----------\n    data : np.array of shape (batch_size, n_dcc, n_obs, n_strains)\n\n    Returns\n    -------\n    np.array of shape (batch_size, n_dcc)\n\n    \"\"\"", "\n", "strain_active", "=", "np", ".", "any", "(", "data", ",", "axis", "=", "2", ")", "\n", "n_strain_obs", "=", "np", ".", "sum", "(", "strain_active", ",", "axis", "=", "2", ")", "# axis 3 is now 2", "\n", "\n", "return", "n_strain_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.daycare.ss_prevalence": [[235, 251], ["numpy.any", "numpy.sum"], "function", ["None"], ["", "def", "ss_prevalence", "(", "data", ")", ":", "\n", "    ", "\"\"\"Calculate the prevalence of carriage among the observed individuals.\n\n    Parameters\n    ----------\n    data : np.array of shape (batch_size, n_dcc, n_obs, n_strains)\n\n    Returns\n    -------\n    np.array of shape (batch_size, n_dcc)\n\n    \"\"\"", "\n", "any_infection", "=", "np", ".", "any", "(", "data", ",", "axis", "=", "3", ")", "\n", "n_infected", "=", "np", ".", "sum", "(", "any_infection", ",", "axis", "=", "2", ")", "\n", "\n", "return", "n_infected", "/", "data", ".", "shape", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.daycare.ss_prevalence_multi": [[253, 269], ["numpy.sum", "numpy.sum"], "function", ["None"], ["", "def", "ss_prevalence_multi", "(", "data", ")", ":", "\n", "    ", "\"\"\"Calculate the prevalence of multiple infections among the observed individuals.\n\n    Parameters\n    ----------\n    data : np.array of shape (batch_size, n_dcc, n_obs, n_strains)\n\n    Returns\n    -------\n    np.array of shape (batch_size, n_dcc)\n\n    \"\"\"", "\n", "n_infections", "=", "np", ".", "sum", "(", "data", ",", "axis", "=", "3", ")", "\n", "n_multi_infections", "=", "np", ".", "sum", "(", "n_infections", ">", "1", ",", "axis", "=", "2", ")", "\n", "\n", "return", "n_multi_infections", "/", "data", ".", "shape", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.daycare.distance": [[271, 306], ["numpy.stack", "numpy.stack", "numpy.max", "numpy.where", "numpy.sort", "numpy.sort", "numpy.sum", "numpy.abs"], "function", ["None"], ["", "def", "distance", "(", "*", "summaries", ",", "observed", ")", ":", "\n", "    ", "\"\"\"Calculate an L1-based distance between the simulated and observed summaries.\n\n    Follows the simplified single-distance approach in:\n    Gutmann M U, Corander J (2016). Bayesian Optimization for Likelihood-Free Inference\n    of Simulator-Based Statistical Models. JMLR 17(125):1\u221247, 2016.\n\n    Parameters\n    ----------\n    *summaries : k np.arrays of shape (m, n)\n    observed : list of k np.arrays of shape (1, n)\n\n    Returns\n    -------\n    np.array of shape (m,)\n\n    \"\"\"", "\n", "summaries", "=", "np", ".", "stack", "(", "summaries", ")", "\n", "observed", "=", "np", ".", "stack", "(", "observed", ")", "\n", "n_ss", ",", "_", ",", "n_dcc", "=", "summaries", ".", "shape", "\n", "\n", "# scale summaries with max observed", "\n", "obs_max", "=", "np", ".", "max", "(", "observed", ",", "axis", "=", "2", ",", "keepdims", "=", "True", ")", "\n", "obs_max", "=", "np", ".", "where", "(", "obs_max", "==", "0", ",", "1", ",", "obs_max", ")", "\n", "y", "=", "observed", "/", "obs_max", "\n", "x", "=", "summaries", "/", "obs_max", "\n", "\n", "# sort to make comparison more robust", "\n", "y", "=", "np", ".", "sort", "(", "y", ",", "axis", "=", "2", ")", "\n", "x", "=", "np", ".", "sort", "(", "x", ",", "axis", "=", "2", ")", "\n", "\n", "# L1 norm divided by the dimension", "\n", "dist", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "x", "-", "y", ")", ",", "axis", "=", "(", "0", ",", "2", ")", ")", "/", "(", "n_ss", "*", "n_dcc", ")", "\n", "\n", "return", "dist", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.gauss": [[11, 36], ["numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "scipy.norm.rvs", "numpy.asanyarray", "numpy.asanyarray"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["def", "gauss", "(", "mu", ",", "sigma", ",", "n_obs", "=", "50", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"Sample the 1-D Gaussian distribution.\n\n    Parameters\n    ----------\n    mu : float, array_like\n    sigma : float, array_like\n    n_obs : int, optional\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n\n    Returns\n    -------\n    array_like\n        1-D observations.\n\n    \"\"\"", "\n", "# Transforming the arrays' shape to be compatible with batching.", "\n", "batches_mu", "=", "np", ".", "asanyarray", "(", "mu", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "batches_sigma", "=", "np", ".", "asanyarray", "(", "sigma", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "# Sampling observations.", "\n", "y_obs", "=", "ss", ".", "norm", ".", "rvs", "(", "loc", "=", "batches_mu", ",", "scale", "=", "batches_sigma", ",", "\n", "size", "=", "(", "batch_size", ",", "n_obs", ")", ",", "random_state", "=", "random_state", ")", "\n", "return", "y_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.gauss_nd_mean": [[38, 73], ["len", "numpy.zeros", "enumerate", "numpy.zeros", "range", "scipy.multivariate_normal.rvs"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["", "def", "gauss_nd_mean", "(", "*", "mu", ",", "cov_matrix", ",", "n_obs", "=", "15", ",", "batch_size", "=", "1", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"Sample an n-D Gaussian distribution.\n\n    Parameters\n    ----------\n    *mu : array_like\n        Mean parameters.\n    cov_matrix : array_like\n        Covariance matrix.\n    n_obs : int, optional\n    batch_size : int, optional\n    random_state : np.random.RandomState, optional\n\n    Returns\n    -------\n    array_like\n        n-D observations.\n\n    \"\"\"", "\n", "n_dim", "=", "len", "(", "mu", ")", "\n", "\n", "# Transforming the arrays' shape to be compatible with batching.", "\n", "batches_mu", "=", "np", ".", "zeros", "(", "shape", "=", "(", "batch_size", ",", "n_dim", ")", ")", "\n", "for", "idx_dim", ",", "param_mu", "in", "enumerate", "(", "mu", ")", ":", "\n", "        ", "batches_mu", "[", ":", ",", "idx_dim", "]", "=", "param_mu", "\n", "\n", "# Sampling the observations.", "\n", "", "y_obs", "=", "np", ".", "zeros", "(", "shape", "=", "(", "batch_size", ",", "n_obs", ",", "n_dim", ")", ")", "\n", "for", "idx_batch", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "y_batch", "=", "ss", ".", "multivariate_normal", ".", "rvs", "(", "mean", "=", "batches_mu", "[", "idx_batch", "]", ",", "cov", "=", "cov_matrix", ",", "\n", "size", "=", "n_obs", ",", "random_state", "=", "random_state", ")", "\n", "if", "n_dim", "==", "1", ":", "\n", "            ", "y_batch", "=", "y_batch", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "", "y_obs", "[", "idx_batch", ",", ":", ",", ":", "]", "=", "y_batch", "\n", "", "return", "y_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.get_model": [[75, 140], ["functools.partial.", "elfi.new_model", "elfi.Simulator", "sumstats.append", "sumstats.append", "functools.partial", "functools.partial", "len", "range", "priors.append", "priors.append", "elfi.Summary", "elfi.Summary", "elfi.Discrepancy", "elfi.Distance", "numpy.random.RandomState", "elfi.Prior", "priors.append", "elfi.Prior", "elfi.Prior", "numpy.amax"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.elfi_model.new_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "get_model", "(", "n_obs", "=", "50", ",", "true_params", "=", "None", ",", "seed_obs", "=", "None", ",", "nd_mean", "=", "False", ",", "cov_matrix", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return a Gaussian noise model.\n\n    Parameters\n    ----------\n    n_obs : int, optional\n    true_params : list, optional\n        Default parameter settings.\n    seed_obs : int, optional\n        Seed for the observed data generation.\n    nd_mean : bool, optional\n        Option to use an n-D mean Gaussian noise model.\n    cov_matrix : array_like, optional\n        Covariance matrix, a requirement for the nd_mean model.\n\n    Returns\n    -------\n    elfi.ElfiModel\n\n    \"\"\"", "\n", "# Defining the default settings.", "\n", "if", "true_params", "is", "None", ":", "\n", "        ", "if", "nd_mean", ":", "\n", "            ", "true_params", "=", "[", "4", ",", "4", "]", "# 2-D mean.", "\n", "", "else", ":", "\n", "            ", "true_params", "=", "[", "4", ",", ".4", "]", "# mean and standard deviation.", "\n", "\n", "# Choosing the simulator for both observations and simulations.", "\n", "", "", "if", "nd_mean", ":", "\n", "        ", "fn_simulator", "=", "partial", "(", "gauss_nd_mean", ",", "cov_matrix", "=", "cov_matrix", ",", "n_obs", "=", "n_obs", ")", "\n", "", "else", ":", "\n", "        ", "fn_simulator", "=", "partial", "(", "gauss", ",", "n_obs", "=", "n_obs", ")", "\n", "\n", "# Obtaining the observations.", "\n", "", "y_obs", "=", "fn_simulator", "(", "*", "true_params", ",", "n_obs", "=", "n_obs", ",", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed_obs", ")", ")", "\n", "\n", "m", "=", "elfi", ".", "new_model", "(", ")", "\n", "# Initialising the priors.", "\n", "eps_prior", "=", "5", "# The longest distance from the median of an initialised prior's distribution.", "\n", "priors", "=", "[", "]", "\n", "if", "nd_mean", ":", "\n", "        ", "n_dim", "=", "len", "(", "true_params", ")", "\n", "for", "i", "in", "range", "(", "n_dim", ")", ":", "\n", "            ", "name_prior", "=", "'mu_{}'", ".", "format", "(", "i", ")", "\n", "prior_mu", "=", "elfi", ".", "Prior", "(", "'uniform'", ",", "true_params", "[", "i", "]", "-", "eps_prior", ",", "\n", "2", "*", "eps_prior", ",", "model", "=", "m", ",", "name", "=", "name_prior", ")", "\n", "priors", ".", "append", "(", "prior_mu", ")", "\n", "", "", "else", ":", "\n", "        ", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'uniform'", ",", "true_params", "[", "0", "]", "-", "eps_prior", ",", "\n", "2", "*", "eps_prior", ",", "model", "=", "m", ",", "name", "=", "'mu'", ")", ")", "\n", "priors", ".", "append", "(", "elfi", ".", "Prior", "(", "'truncnorm'", ",", "np", ".", "amax", "(", "[", ".01", ",", "true_params", "[", "1", "]", "-", "eps_prior", "]", ")", ",", "\n", "2", "*", "eps_prior", ",", "model", "=", "m", ",", "name", "=", "'sigma'", ")", ")", "\n", "", "elfi", ".", "Simulator", "(", "fn_simulator", ",", "*", "priors", ",", "observed", "=", "y_obs", ",", "name", "=", "'gauss'", ")", "\n", "\n", "# Initialising the summary statistics.", "\n", "sumstats", "=", "[", "]", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "ss_mean", ",", "m", "[", "'gauss'", "]", ",", "name", "=", "'ss_mean'", ")", ")", "\n", "sumstats", ".", "append", "(", "elfi", ".", "Summary", "(", "ss_var", ",", "m", "[", "'gauss'", "]", ",", "name", "=", "'ss_var'", ")", ")", "\n", "\n", "# Choosing the discrepancy metric.", "\n", "if", "nd_mean", ":", "\n", "        ", "elfi", ".", "Discrepancy", "(", "euclidean_multidim", ",", "*", "sumstats", ",", "name", "=", "'d'", ")", "\n", "", "else", ":", "\n", "        ", "elfi", ".", "Distance", "(", "'euclidean'", ",", "*", "sumstats", ",", "name", "=", "'d'", ")", "\n", "", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.ss_mean": [[142, 157], ["numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "ss_mean", "(", "y", ")", ":", "\n", "    ", "\"\"\"Obtain the mean summary statistic.\n\n    Parameters\n    ----------\n    y : array_like\n        Yielded points.\n\n    Returns\n    -------\n    array_like of the shape (batch_size, dim_point)\n\n    \"\"\"", "\n", "ss", "=", "np", ".", "mean", "(", "y", ",", "axis", "=", "1", ")", "\n", "return", "ss", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.ss_var": [[159, 174], ["numpy.var"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.var"], ["", "def", "ss_var", "(", "y", ")", ":", "\n", "    ", "\"\"\"Return the variance summary statistic.\n\n    Parameters\n    ----------\n    y : array_like\n        Yielded points.\n\n    Returns\n    -------\n    array_like of the shape (batch_size, dim_point)\n\n    \"\"\"", "\n", "ss", "=", "np", ".", "var", "(", "y", ",", "axis", "=", "1", ")", "\n", "return", "ss", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.gauss.euclidean_multidim": [[176, 199], ["numpy.sum", "numpy.sqrt"], "function", ["None"], ["", "def", "euclidean_multidim", "(", "*", "simulated", ",", "observed", ")", ":", "\n", "    ", "\"\"\"Calculate the Euclidean distances merging data dimensions.\n\n    The shape of the input arrays corresponds to (batch_size, dim_point).\n\n    Parameters\n    ----------\n    *simulated: array_like\n    observed : array_like\n\n    Returns\n    -------\n    array_like\n\n    \"\"\"", "\n", "pts_sim", "=", "simulated", "[", "0", "]", "\n", "pts_obs", "=", "observed", "[", "0", "]", "\n", "\n", "# Integrating over the summary statistics.", "\n", "d_dim_merged", "=", "np", ".", "sum", "(", "(", "pts_sim", "-", "pts_obs", ")", "**", "2.", ",", "axis", "=", "1", ")", "\n", "\n", "d", "=", "np", ".", "sqrt", "(", "d_dim_merged", ")", "\n", "return", "d", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.JointPrior.rvs": [[67, 156], ["isinstance", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty", "warnings.warn", "random_state.uniform", "random_state.uniform", "elfi_operations.analytic_R0_upper_bound", "elfi_operations.Rt_to_d", "elfi_operations.Rt_to_a", "numpy.ones", "slice", "numpy.array", "len", "ValueError", "random_state.uniform", "numpy.array", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "min", "elfi.analytical_means", "elfi.analytical_means", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.analytic_R0_upper_bound", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_a", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.analytical_means", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.analytical_means"], ["    ", "@", "staticmethod", "\n", "def", "rvs", "(", "burden", ",", "mean_obs_bounds", "=", "None", ",", "t1_bound", "=", "100", ",", "a1_bound", "=", "300", ",", "p_compliance", "=", ".95", ",", "R1_bound", "=", "None", ",", "size", "=", "None", ",", "\n", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"The joint prior for the San Francisco data\n\n        Parameters\n        ----------\n        burden : float, np.array\n        mean_obs_bounds : list, tuple, optional\n            Non-inclusive lower and upper bounds for the mean of observed hosts in one year.\n        t1_bound : float\n            Upper bound for the allowed net transmission rate of the non-compliant hosts (a1 - d1).\n        a1_bound : float\n            Upper bound for the transmission rate of the non-compliant hosts.\n        p_compliance : float, optional\n            Probability that a new host will be compliant to therapy. Default value is 0.95.\n        R1_bound : float, optional\n            Will be set automatically to 1/(1 - p_compliance), which is the non-inclusive upper limit\n            for stabile populations.\n        size : int, optional\n        random_state : np.random.RandomState, optional\n\n        \"\"\"", "\n", "\n", "p_non_c", "=", "1", "-", "p_compliance", "\n", "R1_bound", "=", "R1_bound", "or", "1", "/", "p_non_c", "\n", "if", "not", "p_non_c", "*", "R1_bound", "<=", "1", ":", "\n", "            ", "warnings", ".", "warn", "(", "'R1_bound is too high for a stabile population.'", ")", "\n", "\n", "", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "\n", "size_", "=", "size", "or", "1", "\n", "if", "isinstance", "(", "size_", ",", "tuple", ")", ":", "\n", "            ", "if", "len", "(", "size_", ")", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "'Size must be scalar'", ")", "\n", "", "size_", "=", "size_", "[", "0", "]", "\n", "\n", "", "burden", "=", "burden", "\n", "d0", "=", "5.95", "\n", "\n", "i", "=", "0", "\n", "R1", "=", "np", ".", "empty", "(", "size_", ")", "\n", "t1", "=", "np", ".", "empty", "(", "size_", ")", "\n", "R0", "=", "np", ".", "empty", "(", "size_", ")", "\n", "m_obs", "=", "np", ".", "empty", "(", "size_", ")", "\n", "\n", "while", "True", ":", "\n", "            ", "R1_", "=", "random_state", ".", "uniform", "(", "1.01", ",", "R1_bound", ",", "size", "=", "size_", ")", "\n", "t1_", "=", "random_state", ".", "uniform", "(", "0.01", ",", "t1_bound", ",", "size", "=", "size_", ")", "\n", "\n", "R0_bounds_", "=", "analytic_R0_upper_bound", "(", "R1_", ",", "p_compliance", ")", "\n", "R0_", "=", "random_state", ".", "uniform", "(", "0.01", ",", "1", ",", "size", "=", "size_", ")", "*", "R0_bounds_", "\n", "\n", "a0_", "=", "R0_", "*", "d0", "\n", "d1_", "=", "Rt_to_d", "(", "R1_", ",", "t1_", ")", "\n", "a1_", "=", "Rt_to_a", "(", "R1_", ",", "t1_", ")", "\n", "\n", "means_", "=", "np", ".", "array", "(", "si", ".", "analytical_means", "(", "burden", ",", "a0_", ",", "d0", ",", "a1_", ",", "d1_", ")", ")", ".", "T", "\n", "\n", "mask", "=", "np", ".", "ones", "(", "size_", ",", "dtype", "=", "bool", ")", "\n", "if", "mean_obs_bounds", "is", "not", "None", ":", "\n", "                ", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "means_", "[", ":", ",", "2", "]", "<", "mean_obs_bounds", "[", "1", "]", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "means_", "[", ":", ",", "2", "]", ">", "mean_obs_bounds", "[", "0", "]", ")", "\n", "", "if", "a1_bound", ":", "\n", "                ", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "a1_", "<", "a1_bound", ")", "\n", "\n", "", "sl", "=", "slice", "(", "i", ",", "min", "(", "i", "+", "np", ".", "sum", "(", "mask", ")", ",", "size_", ")", ")", "\n", "l", "=", "sl", ".", "stop", "-", "sl", ".", "start", "\n", "\n", "R0", "[", "sl", "]", "=", "R0_", "[", "mask", "]", "[", ":", "l", "]", "\n", "R1", "[", "sl", "]", "=", "R1_", "[", "mask", "]", "[", ":", "l", "]", "\n", "t1", "[", "sl", "]", "=", "t1_", "[", "mask", "]", "[", ":", "l", "]", "\n", "m_obs", "[", "sl", "]", "=", "means_", "[", "mask", ",", "2", "]", "[", ":", "l", "]", "\n", "\n", "i", "=", "sl", ".", "stop", "\n", "\n", "if", "i", "==", "size_", ":", "\n", "                ", "break", "\n", "\n", "", "", "if", "size", "is", "None", ":", "\n", "#print(R0)", "\n", "#print(R1)", "\n", "#print(t1)", "\n", "            ", "R0", "=", "R0", "[", "0", "]", "\n", "R1", "=", "R1", "[", "0", "]", "\n", "t1", "=", "t1", "[", "0", "]", "\n", "m_obs", "=", "m_obs", "[", "0", "]", "\n", "\n", "", "return", "np", ".", "array", "(", "(", "R0", ",", "R1", ",", "t1", ",", "m_obs", ")", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.DummyPrior.rvs": [[162, 180], ["None"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "rvs", "(", "joint_rvs", ",", "index", ",", "size", ",", "random_state", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        joint_rvs : np.ndarray\n            Random variates from the joint prior\n        index : int\n            Index for choosing the specific variable from the joint prior\n        size\n        random_state\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "return", "joint_rvs", "[", ":", ",", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d": [[12, 28], ["numpy.abs"], "function", ["None"], ["def", "Rt_to_d", "(", "R", ",", "t", ")", ":", "\n", "    ", "\"\"\"Compute death rates from the reproductive value and net transmission rate\n\n    Parameters\n    ----------\n    R : float, np.ndarray\n        Reproductive value\n    t : float, np.ndarray\n        Net transmission rate\n\n    Returns\n    -------\n    float, np.ndarray\n        Death rate\n    \"\"\"", "\n", "return", "t", "/", "np", ".", "abs", "(", "R", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_a": [[30, 46], ["elfi_operations.Rt_to_d"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.Rt_to_d"], ["", "def", "Rt_to_a", "(", "R", ",", "t", ")", ":", "\n", "    ", "\"\"\"Compute birth rates from the reproductive value and net transmission rate\n\n    Parameters\n    ----------\n    R : float, np.ndarray\n        Reproductive value\n    t : float, np.ndarray\n        Net transmission rate\n\n    Returns\n    -------\n    float, np.ndarray\n        Birth rate(s)\n    \"\"\"", "\n", "return", "t", "+", "Rt_to_d", "(", "R", ",", "t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.analytic_R0_upper_bound": [[48, 64], ["None"], "function", ["None"], ["", "def", "analytic_R0_upper_bound", "(", "R1", ",", "p_compliance", ")", ":", "\n", "    ", "\"\"\"Compute the upper bound for R0 ensuring that the population size balance value exists.\n\n    Parameters\n    ----------\n    R1 : float, np.ndarray\n        Reproductive value of the non-compliant population\n    p_compliance : float\n\n    Returns\n    -------\n    float, np.ndarray\n        The non-inclusive upper bound(s)\n    \"\"\"", "\n", "p_non_c", "=", "1", "-", "p_compliance", "\n", "return", "(", "1", "-", "R1", "*", "p_non_c", ")", "/", "p_compliance", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.pick": [[182, 188], ["None"], "function", ["None"], ["", "", "def", "pick", "(", "y", ",", "column", ")", ":", "\n", "    ", "\"\"\"A helper method to pick a specific output from the simulator node output.\n\n    Allows one to create separate nodes for specific outputs, e.g. number of clusters.\n    \"\"\"", "\n", "return", "y", "[", "column", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations._get_n_clusters": [[190, 203], ["numpy.atleast_1d", "numpy.atleast_2d", "numpy.sum", "np.sum.item"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_1d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["", "def", "_get_n_clusters", "(", "observed", ")", ":", "\n", "    ", "\"\"\"Compute the number of clusters in the data produced directly by the simulator\n\n    Parameters\n    ----------\n    observed : np.ndarray\n        Vector of cluster sizes produced directly by the simulator\n\n    \"\"\"", "\n", "observed", "=", "np", ".", "atleast_1d", "(", "observed", ")", "\n", "clusters_", "=", "np", ".", "atleast_2d", "(", "observed", ")", "\n", "n", "=", "np", ".", "sum", "(", "clusters_", ">", "0", ",", "1", ")", "\n", "return", "n", ".", "item", "(", ")", "if", "observed", ".", "ndim", "==", "1", "else", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.cluster_size_hist": [[205, 225], ["numpy.histogram", "list", "csh.astype", "numpy.sum", "range"], "function", ["None"], ["", "def", "cluster_size_hist", "(", "observed", ",", "cluster_size_bound", ")", ":", "\n", "    ", "\"\"\"Compute a histogram of cluster sizes\n\n    Parameters\n    ----------\n    observed : np.array\n        Data directly from the simulator\n    cluster_size_bound : int\n        Largest allowed cluster size in the histogram (for saving storage)\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "# Do not get multiple values to the last bin because the endpoint is included", "\n", "bins", "=", "list", "(", "range", "(", "cluster_size_bound", "+", "1", ")", ")", "+", "[", "cluster_size_bound", "+", "1.5", "]", "\n", "csh", ",", "_", "=", "np", ".", "histogram", "(", "observed", ",", "bins", "=", "bins", ",", ")", "\n", "csh", "[", "0", "]", "=", "0", "\n", "return", "csh", ".", "astype", "(", "dtype", "=", "observed", ".", "dtype", ")", ",", "np", ".", "sum", "(", "observed", ">", "cluster_size_bound", ",", "dtype", "=", "observed", ".", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.obs_times_hist": [[227, 250], ["numpy.arange", "numpy.histogram", "counts.astype"], "function", ["None"], ["", "def", "obs_times_hist", "(", "obs_times", ",", "t_obs", ")", ":", "\n", "    ", "\"\"\"Return a histogram of observations per month\n\n    Parameters\n    ----------\n    obs_times : np.ndarray\n        Observation times from the simulator\n    t_obs : int\n        Observation period in years\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "# Convert to months", "\n", "t_obs", "*=", "12", "\n", "t", "=", "obs_times", "*", "12", "\n", "\n", "# Note that the dtype must match that produced by the simulator", "\n", "bins", "=", "np", ".", "arange", "(", "t_obs", "+", "1", ",", "dtype", "=", "obs_times", ".", "dtype", ")", "\n", "counts", ",", "_", "=", "np", ".", "histogram", "(", "t", ",", "bins", "=", "bins", ",", "range", "=", "(", "0", ",", "t_obs", "+", "1", ")", ")", "\n", "\n", "return", "counts", ".", "astype", "(", "'i2'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.get_SF_data": [[252, 292], ["numpy.array", "elfi_operations.cluster_size_hist", "elfi_operations.obs_times_hist", "numpy.array", "numpy.ones", "numpy.array", "sum", "elfi_operations._get_n_clusters", "len", "sum", "numpy.sum", "numpy.arange", "numpy.max", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.cluster_size_hist", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.obs_times_hist", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations._get_n_clusters"], ["", "def", "get_SF_data", "(", "cluster_size_bound", ",", "dtype", "=", "np", ".", "int16", ")", ":", "\n", "    ", "\"\"\"Get San Francisco Bay area Tuberculosis epidemic data.\n\n    The data is formatted to work with the provided ELFI model.\n    \"\"\"", "\n", "clusters_list", "=", "[", "]", "\n", "for", "c_size", ",", "c_num", "in", "[", "(", "30", ",", "1", ")", ",", "(", "23", ",", "1", ")", ",", "(", "15", ",", "1", ")", ",", "(", "10", ",", "1", ")", ",", "(", "8", ",", "1", ")", ",", "(", "5", ",", "2", ")", ",", "(", "4", ",", "4", ")", ",", "(", "3", ",", "13", ")", ",", "(", "2", ",", "20", ")", ",", "(", "1", ",", "282", ")", "]", ":", "\n", "        ", "clusters_list", "+=", "[", "c_size", "]", "*", "c_num", "\n", "\n", "", "clusters", "=", "np", ".", "array", "(", "clusters_list", ",", "dtype", "=", "dtype", ")", "\n", "\n", "obs_times", "=", "np", ".", "ones", "(", "cluster_size_bound", ",", "dtype", "=", "np", ".", "float16", ")", "*", "np", ".", "nan", "\n", "obs_times", "[", ":", "30", "]", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "2", ",", "3", ",", "3", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "5", ",", "5", ",", "5", ",", "5", ",", "5", ",", "7", ",", "8", ",", "8", ",", "10", ",", "11", ",", "12", ",", "14", ",", "16", ",", "16", ",", "18", ",", "20", ",", "21", ",", "23", "]", ")", "/", "12", "\n", "\n", "# True values for checking", "\n", "n_obs", "=", "473", "\n", "n_clusters", "=", "326", "\n", "\n", "# Test some known statistics", "\n", "assert", "sum", "(", "clusters", ")", "==", "n_obs", "\n", "assert", "_get_n_clusters", "(", "clusters", ")", "==", "n_clusters", "\n", "\n", "# Test that those are preserved after transform", "\n", "csh", ",", "n_o", "=", "cluster_size_hist", "(", "clusters", ",", "cluster_size_bound", ")", "\n", "assert", "len", "(", "csh", ")", "==", "cluster_size_bound", "+", "1", "\n", "assert", "sum", "(", "csh", ")", "==", "n_clusters", "\n", "assert", "np", ".", "sum", "(", "np", ".", "arange", "(", "len", "(", "csh", ")", ")", "*", "csh", ")", "==", "n_obs", "\n", "\n", "oth", "=", "obs_times_hist", "(", "obs_times", ",", "2", ")", "\n", "\n", "y", "=", "np", ".", "array", "(", "[", "(", "csh", ",", "n_obs", ",", "n_clusters", ",", "np", ".", "max", "(", "clusters", ")", ",", "oth", ",", "n_o", ",", "0", ")", "]", ",", "\n", "dtype", "=", "[", "(", "'clusters'", ",", "dtype", ",", "cluster_size_bound", "+", "1", ")", ",", "\n", "(", "'n_obs'", ",", "dtype", ")", ",", "\n", "(", "'n_clusters'", ",", "dtype", ")", ",", "\n", "(", "'largest'", ",", "dtype", ")", ",", "\n", "(", "'obs_times'", ",", "dtype", ",", "24", ")", ",", "\n", "(", "'n_oversized'", ",", "dtype", ")", ",", "# TODO: allow ELFI to run without these two", "\n", "(", "'time'", ",", "np", ".", "float16", ")", "]", ")", "\n", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.simulator": [[294, 380], ["numpy.zeros", "range", "elfi.Simulator", "max", "si.Simulator.next_event", "elfi_operations.cluster_size_hist", "elfi_operations._get_n_clusters", "numpy.max", "elfi_operations.obs_times_hist", "si.Simulator.advance_to", "si.Simulator.extract_death_times", "hasattr"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.next_event", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.cluster_size_hist", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations._get_n_clusters", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.obs_times_hist", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.advance_to", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.extract_death_times"], ["", "def", "simulator", "(", "burden", ",", "a0", ",", "d0", ",", "a1", ",", "d1", ",", "t_obs", ",", "cluster_size_bound", ",", "warmup_bounds", "=", "(", "0", ",", "300", ")", ",", "batch_size", "=", "1", ",", "\n", "random_state", "=", "None", ",", "dtype", "=", "np", ".", "int16", ")", ":", "\n", "    ", "\"\"\"Wrapper for the simulator to make it compatible with the ELFI model\n\n    This adds support for batch_size, transforms the data to a form that is efficient to store\n    etc.\n\n    Parameters\n    ----------\n    burden\n    a0\n    d0\n    a1\n    d1\n    t_obs\n    cluster_size_bound : int\n        Upper bound for the cluster sizes\n    min_warmup : int\n        Minimum years for the warmup.\n    batch_size\n    random_state\n    dtype : np.dtype\n\n    Notes\n    -----\n    Observed clusters will be truncated to fit clusters_bound if exceeded. Also obs_times will be\n    truncated to cluster_size_bound.\n\n    Returns\n    -------\n    np.ndarray\n\n    \"\"\"", "\n", "y", "=", "np", ".", "zeros", "(", "batch_size", ",", "dtype", "=", "[", "(", "'clusters'", ",", "dtype", ",", "cluster_size_bound", "+", "1", ")", ",", "\n", "(", "'n_obs'", ",", "dtype", ")", ",", "\n", "(", "'n_clusters'", ",", "dtype", ")", ",", "\n", "(", "'largest'", ",", "dtype", ")", ",", "\n", "(", "'obs_times'", ",", "dtype", ",", "t_obs", "*", "12", ")", ",", "\n", "(", "'n_oversized'", ",", "dtype", ")", ",", "\n", "(", "'n_c'", ",", "dtype", ")", ",", "\n", "(", "'n_nc'", ",", "dtype", ")", ",", "\n", "(", "'time'", ",", "np", ".", "float16", ")", ",", "]", ")", "\n", "\n", "min_warmup", ",", "max_warmup", "=", "warmup_bounds", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "args", "=", "[", "a", "[", "i", "]", "if", "hasattr", "(", "a", ",", "'__len__'", ")", "else", "a", "for", "a", "in", "(", "burden", ",", "a0", ",", "d0", ",", "a1", ",", "d1", ")", "]", "\n", "s", "=", "si", ".", "Simulator", "(", "*", "args", ",", "t_obs", "=", "t_obs", ",", "t_warmup", "=", "np", ".", "inf", ",", "random_state", "=", "random_state", ",", "\n", "dtype", "=", "dtype", ")", "\n", "\n", "m_c", ",", "m_nc", ",", "m_obs", "=", "s", ".", "analytical_means", "\n", "\n", "# Determine warmup", "\n", "years", "=", "0", "\n", "m_c_unreached", "=", "True", "\n", "m_nc_unreached", "=", "True", "\n", "while", "years", "<", "max_warmup", "/", "2", "and", "(", "m_c_unreached", "or", "m_nc_unreached", ")", ":", "\n", "            ", "years", "+=", "1", "\n", "s", ".", "advance_to", "(", "years", ")", "\n", "\n", "if", "s", ".", "n_c", ">=", "m_c", ":", "\n", "                ", "m_c_unreached", "=", "False", "\n", "", "if", "s", ".", "n_nc", ">=", "m_nc", ":", "\n", "                ", "m_nc_unreached", "=", "False", "\n", "\n", "# Set warmup", "\n", "", "", "s", ".", "t_warmup", "=", "max", "(", "2", "*", "years", ",", "min_warmup", ")", "\n", "\n", "# Run the rest of the warmup and the observation time", "\n", "while", "s", ".", "next_event", "(", ")", ":", "\n", "            ", "pass", "\n", "\n", "", "y", "[", "i", "]", "[", "'clusters'", "]", ",", "n_o", "=", "cluster_size_hist", "(", "s", ".", "observed", ",", "cluster_size_bound", ")", "\n", "y", "[", "i", "]", "[", "'n_obs'", "]", "=", "s", ".", "n_obs", "\n", "y", "[", "i", "]", "[", "'n_clusters'", "]", "=", "_get_n_clusters", "(", "s", ".", "observed", ")", "\n", "y", "[", "i", "]", "[", "'largest'", "]", "=", "np", ".", "max", "(", "s", ".", "observed", ")", "\n", "y", "[", "i", "]", "[", "'obs_times'", "]", "=", "obs_times_hist", "(", "s", ".", "extract_death_times", "(", "dtype", "=", "np", ".", "float16", ")", ",", "t_obs", ")", "\n", "y", "[", "i", "]", "[", "'n_oversized'", "]", "=", "n_o", "\n", "y", "[", "i", "]", "[", "'n_c'", "]", "=", "s", ".", "n_c", "\n", "y", "[", "i", "]", "[", "'n_nc'", "]", "=", "s", ".", "n_nc", "\n", "y", "[", "i", "]", "[", "'time'", "]", "=", "s", ".", "time", "\n", "\n", "#print('\\nY (elfi_operators.py):')", "\n", "#print(y)", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.obs_period": [[386, 392], ["numpy.atleast_2d", "numpy.argmax", "numpy.argmax", "numpy.flip"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["def", "obs_period", "(", "times", ")", ":", "\n", "    ", "times", "=", "np", ".", "atleast_2d", "(", "times", ")", "\n", "mask", "=", "times", ">", "0", "\n", "a", "=", "np", ".", "argmax", "(", "mask", ",", "1", ")", "\n", "b", "=", "times", ".", "shape", "[", "1", "]", "-", "np", ".", "argmax", "(", "np", ".", "flip", "(", "mask", ",", "1", ")", ",", "1", ")", "\n", "return", "b", "-", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.get_largest_cluster_sizes": [[394, 407], ["clusters.copy.copy", "numpy.zeros", "range", "numpy.max", "len", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "def", "get_largest_cluster_sizes", "(", "clusters", ",", "n", "=", "4", ")", ":", "\n", "    ", "clusters", "=", "clusters", ".", "copy", "(", ")", "\n", "largest", "=", "np", ".", "zeros", "(", "(", "len", "(", "clusters", ")", ",", "n", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "cluster_sizes", "=", "(", "clusters", ">", "0", ")", "*", "np", ".", "arange", "(", "clusters", ".", "shape", "[", "1", "]", ")", "\n", "current_largest", "=", "np", ".", "max", "(", "cluster_sizes", ",", "1", ")", "\n", "\n", "# Mark it as used", "\n", "clusters", "[", ":", ",", "current_largest", "]", "-=", "1", "\n", "\n", "largest", "[", ":", ",", "i", "]", "=", "current_largest", "\n", "\n", "", "return", "largest", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.mean_largest_diff": [[409, 412], ["elfi_operations.get_largest_cluster_sizes", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.get_largest_cluster_sizes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "mean_largest_diff", "(", "clusters", ")", ":", "\n", "    ", "sizes", "=", "get_largest_cluster_sizes", "(", "clusters", ",", "4", ")", "\n", "return", "np", ".", "mean", "(", "sizes", "[", ":", ",", ":", "-", "1", "]", "-", "sizes", "[", ":", ",", "1", ":", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.distance": [[417, 459], ["slice", "numpy.linalg.norm", "elfi_operations.mean_largest_diff", "elfi_operations.mean_largest_diff", "numpy.zeros", "numpy.zeros", "elfi_operations.obs_period", "elfi_operations.obs_period", "numpy.sum", "numpy.sum", "len", "len"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.mean_largest_diff", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.mean_largest_diff", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.obs_period", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.elfi_operations.obs_period"], ["def", "distance", "(", "n_obs", ",", "n_clusters", ",", "largest", ",", "clusters", ",", "obs_times", "=", "None", ",", "observed", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n\n    Parameters\n    ----------\n    n_obs\n    n_clusters\n    largest\n    clusters\n    obs_times\n    observed\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "d0", "=", "n_obs", "-", "observed", "[", "0", "]", "\n", "d1", "=", "n_clusters", "-", "observed", "[", "1", "]", "\n", "\n", "d_largest", "=", "largest", "-", "observed", "[", "2", "]", "\n", "d_largest_diff", "=", "mean_largest_diff", "(", "clusters", ")", "-", "mean_largest_diff", "(", "observed", "[", "3", "]", ")", "\n", "\n", "# Compare the number of small clusters by relative error", "\n", "c_sizes", "=", "slice", "(", "1", ",", "3", ")", "\n", "true_relative_size", "=", "observed", "[", "3", "]", "[", ":", ",", "c_sizes", "]", "/", "observed", "[", "0", "]", "\n", "dc", "=", "clusters", "[", ":", ",", "c_sizes", "]", "/", "n_obs", "[", ":", ",", "None", "]", "-", "observed", "[", "3", "]", "[", ":", ",", "c_sizes", "]", "/", "observed", "[", "0", "]", "\n", "\n", "# Relative error", "\n", "dc", "=", "dc", "/", "true_relative_size", "\n", "\n", "# Observation times are optional", "\n", "if", "obs_times", "is", "not", "None", ":", "\n", "        ", "d_op", "=", "obs_period", "(", "obs_times", ")", "-", "obs_period", "(", "observed", "[", "4", "]", ")", "\n", "d_om", "=", "np", ".", "sum", "(", "obs_times", ">", "0", ",", "1", ")", "-", "np", ".", "sum", "(", "observed", "[", "4", "]", ">", "0", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "d_op", "=", "np", ".", "zeros", "(", "len", "(", "largest", ")", ")", "\n", "d_om", "=", "np", ".", "zeros", "(", "len", "(", "largest", ")", ")", "\n", "\n", "", "d", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "c_", "[", "d0", ",", "d1", ",", "2", "*", "d_largest", ",", "10", "*", "d_largest_diff", ",", "100", "*", "dc", ",", "10", "*", "d_op", ",", "10", "*", "d_om", "]", ",", "\n", "ord", "=", "2", ",", "axis", "=", "1", ")", "\n", "\n", "return", "d", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.__init__": [[20, 83], ["numpy.zeros", "numpy.zeros", "numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "burden", ",", "trans", ",", "death", ",", "trans_non_c", ",", "death_non_c", ",", "p_compliance", "=", ".95", ",", "\n", "p_observed", "=", ".80", ",", "t_obs", "=", "2", ",", "t_warmup", "=", "None", ",", "random_state", "=", "None", ",", "\n", "track_clusters", "=", "True", ",", "dtype", "=", "np", ".", "int32", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        burden : float\n            Rate of new active TB cases appearing as a result of reactivations and\n            immigration. These will all have a distinct mutation of the pathogen.\n        trans : float\n            Transmission rate for the compliant population\n        death : float\n        trans_non_c : float\n            Transmission rate for the non-compliant cases\n        death_non_c : float\n            Death rate for the non-compliant cases\n        p_compliance : float\n            Probability that a new active TB case will be compliant with therapy\n        p_observed : float\n            Probability that the case becomes observed at \"death\" event\n        t_obs : float, optional\n            The observation time in years for the self.observed data. Default is 2 years\n        t_warmup : float, optional\n            The time to run the process before starting the observation period. Default is\n            t_obs.\n        random_state : np.random.RandomState, optional\n        track_clusters : bool, optional\n            Whether to track clusters in the population. Works slower if True (default).\n        dtype : np.dtype, optional\n            dtype of the cluster vectors and population size integers.\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "\n", "self", ".", "t_obs", "=", "t_obs", "\n", "self", ".", "t_warmup", "=", "t_warmup", "if", "t_warmup", "is", "not", "None", "else", "self", ".", "t_obs", "\n", "self", ".", "random_state", "=", "random_state", "or", "np", ".", "random", "\n", "self", ".", "p_compliance", "=", "p_compliance", "\n", "\n", "self", ".", "p_observed", "=", "p_observed", "\n", "self", ".", "track_clusters", "=", "track_clusters", "\n", "\n", "# State variables", "\n", "self", ".", "time", "=", "0", "\n", "self", ".", "n_events", "=", "0", "\n", "\n", "# Cluster book keeping, non_compliant, compliant and observed respectively", "\n", "self", ".", "clusters", "=", "np", ".", "zeros", "(", "(", "3", ",", "0", ")", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# Population sizes book keeping as above", "\n", "self", ".", "n", "=", "np", ".", "zeros", "(", "3", ",", "dtype", "=", "np", ".", "dtype", ")", "\n", "\n", "# Number of clusters that have ever existed", "\n", "self", ".", "n_clusters", "=", "0", "\n", "\n", "# Death times book keeping only for clusters of size > 1", "\n", "self", ".", "death_times", "=", "{", "}", "\n", "self", ".", "_free_slots", "=", "[", "]", "\n", "\n", "self", ".", "base_rates", "=", "np", ".", "array", "(", "[", "burden", ",", "trans", ",", "death", ",", "trans_non_c", ",", "death_non_c", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.burden": [[84, 87], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "burden", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "base_rates", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.trans": [[88, 91], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "trans", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "base_rates", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.death": [[92, 95], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "death", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "base_rates", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.trans_non_c": [[96, 99], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "trans_non_c", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "base_rates", "[", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.death_non_c": [[100, 103], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "death_non_c", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "base_rates", "[", "4", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.n_nc": [[104, 107], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_nc", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.n_c": [[108, 111], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_c", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.n_obs": [[112, 115], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_obs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.non_compliant": [[116, 119], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "non_compliant", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "clusters", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.compliant": [[120, 123], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "compliant", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "clusters", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.observed": [[124, 127], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "observed", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "clusters", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.advance_to": [[128, 153], ["simulator.Simulator.next_event"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.next_event"], ["", "def", "advance_to", "(", "self", ",", "time", "=", "1", ")", ":", "\n", "        ", "\"\"\"Advance the simulator to time `time` in years.\n\n        New events are drawn until we reach or go above the parameter `time`.\n\n        Parameters\n        ----------\n\n        time : float, optional\n            Time in years to advance to. Default is one year.\n\n        Notes\n        -----\n        The simulation is stopped immediately when the observation time has been passed even\n        if the time has not been reached.\n\n        Returns\n        -------\n        bool\n            Returns False when the simulation has stopped.\n        \"\"\"", "\n", "cont", "=", "True", "\n", "while", "self", ".", "time", "<", "time", "and", "cont", ":", "\n", "            ", "cont", "=", "self", ".", "next_event", "(", ")", "\n", "", "return", "cont", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.next_event": [[154, 209], ["numpy.sum", "simulator.Simulator.random_state.exponential", "simulator.Simulator.random_state.multinomial", "simulator.Simulator._add_cluster", "simulator.Simulator._add_transmission", "simulator.Simulator._add_death", "simulator.Simulator._add_transmission", "simulator.Simulator._add_death", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._add_cluster", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._add_transmission", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._add_death", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._add_transmission", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._add_death"], ["", "def", "next_event", "(", "self", ")", ":", "\n", "        ", "\"\"\"Draw the next event.\n\n        Notes\n        -----\n        The next event will not be simulated if it goes beyond the observation time.\n\n        Returns\n        -------\n        bool\n            Returns False when the simulation has stopped.\n\n        \"\"\"", "\n", "\n", "n_c", "=", "self", ".", "n", "[", "1", "]", "\n", "n_nc", "=", "self", ".", "n", "[", "0", "]", "\n", "rates", "=", "self", ".", "base_rates", "*", "(", "1", ",", "n_c", ",", "n_c", ",", "n_nc", ",", "n_nc", ")", "\n", "sum_rates", "=", "np", ".", "sum", "(", "rates", ")", "\n", "\n", "# Draw the time to the next event ...", "\n", "dt", "=", "self", ".", "random_state", ".", "exponential", "(", "scale", "=", "1", "/", "sum_rates", ")", "\n", "if", "self", ".", "time", "+", "dt", ">=", "self", ".", "t_warmup", "+", "self", ".", "t_obs", ":", "\n", "            ", "return", "False", "\n", "\n", "# ... and advance the time", "\n", "", "self", ".", "time", "+=", "dt", "\n", "self", ".", "n_events", "+=", "1", "\n", "\n", "# Which event", "\n", "e", "=", "self", ".", "random_state", ".", "multinomial", "(", "1", ",", "rates", "/", "sum_rates", ")", "\n", "\n", "# New TB cluster appears", "\n", "if", "e", "[", "0", "]", ":", "\n", "            ", "self", ".", "_add_cluster", "(", ")", "\n", "\n", "# Transmission from compliant hosts", "\n", "", "elif", "e", "[", "1", "]", ":", "\n", "            ", "self", ".", "_add_transmission", "(", "self", ".", "n", "[", "1", "]", ",", "self", ".", "clusters", "[", "1", "]", ")", "\n", "\n", "# Death from compliant hosts", "\n", "", "elif", "e", "[", "2", "]", ":", "\n", "            ", "self", ".", "_add_death", "(", "1", ")", "\n", "\n", "# Transmission from non-compliant hosts", "\n", "", "elif", "e", "[", "3", "]", ":", "\n", "            ", "self", ".", "_add_transmission", "(", "self", ".", "n", "[", "0", "]", ",", "self", ".", "clusters", "[", "0", "]", ")", "\n", "\n", "# Death from non-compliant hosts", "\n", "", "elif", "e", "[", "4", "]", ":", "\n", "            ", "self", ".", "_add_death", "(", "0", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Something went wrong'", ")", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._draw_compliance": [[210, 212], ["int", "simulator.Simulator.random_state.rand"], "methods", ["None"], ["", "def", "_draw_compliance", "(", "self", ")", ":", "\n", "        ", "return", "int", "(", "self", ".", "random_state", ".", "rand", "(", ")", "<=", "self", ".", "p_compliance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._add_cluster": [[213, 224], ["simulator.Simulator._draw_compliance", "simulator.Simulator._get_slot"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._draw_compliance", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._get_slot"], ["", "def", "_add_cluster", "(", "self", ")", ":", "\n", "        ", "self", ".", "n_clusters", "+=", "1", "\n", "\n", "compliant", "=", "self", ".", "_draw_compliance", "(", ")", "\n", "self", ".", "n", "[", "compliant", "]", "+=", "1", "\n", "\n", "if", "not", "self", ".", "track_clusters", ":", "\n", "            ", "return", "\n", "\n", "", "slot", "=", "self", ".", "_get_slot", "(", ")", "\n", "self", ".", "clusters", "[", "compliant", ",", "slot", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._add_transmission": [[225, 243], ["simulator.Simulator._draw_compliance", "simulator._choose_cluster"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._draw_compliance", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator._choose_cluster"], ["", "def", "_add_transmission", "(", "self", ",", "n", ",", "clusters", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        n : int\n            Population size of clusters\n        clusters\n            The cluster array from where the transmission originated\n        \"\"\"", "\n", "compliant", "=", "self", ".", "_draw_compliance", "(", ")", "\n", "self", ".", "n", "[", "compliant", "]", "+=", "1", "\n", "\n", "if", "not", "self", ".", "track_clusters", ":", "\n", "            ", "return", "\n", "\n", "", "i", "=", "_choose_cluster", "(", "clusters", ",", "n", ",", "self", ".", "random_state", ")", "\n", "self", ".", "clusters", "[", "compliant", ",", "i", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._add_death": [[244, 264], ["simulator._choose_cluster", "simulator.Simulator.random_state.rand", "simulator.Simulator.death_times[].append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator._choose_cluster", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "_add_death", "(", "self", ",", "compliant", ")", ":", "\n", "        ", "self", ".", "n", "[", "compliant", "]", "-=", "1", "\n", "\n", "observe", "=", "(", "self", ".", "time", ">=", "self", ".", "t_warmup", ")", "and", "(", "self", ".", "random_state", ".", "rand", "(", ")", "<=", "self", ".", "p_observed", ")", "\n", "if", "observe", ":", "\n", "            ", "self", ".", "n", "[", "2", "]", "+=", "1", "\n", "\n", "", "if", "not", "self", ".", "track_clusters", ":", "\n", "            ", "return", "\n", "\n", "# Record the death to the cluster", "\n", "", "i", "=", "_choose_cluster", "(", "self", ".", "clusters", "[", "compliant", "]", ",", "self", ".", "n", "[", "compliant", "]", "+", "1", ",", "self", ".", "random_state", ")", "\n", "self", ".", "clusters", "[", "compliant", ",", "i", "]", "-=", "1", "\n", "\n", "if", "observe", ":", "\n", "            ", "self", ".", "clusters", "[", "2", ",", "i", "]", "+=", "1", "\n", "if", "i", "in", "self", ".", "death_times", ":", "\n", "                ", "self", ".", "death_times", "[", "i", "]", ".", "append", "(", "self", ".", "time", "-", "self", ".", "t_warmup", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "death_times", "[", "i", "]", "=", "[", "self", ".", "time", "-", "self", ".", "t_warmup", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._extend_clusters": [[265, 276], ["numpy.max", "int", "numpy.concatenate", "list", "numpy.max", "range", "numpy.zeros"], "methods", ["None"], ["", "", "", "def", "_extend_clusters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Extend the cluster np.array\"\"\"", "\n", "w", "=", "self", ".", "clusters", ".", "shape", "[", "1", "]", "\n", "\n", "m", "=", "np", ".", "max", "(", "self", ".", "analytical_means", "[", ":", "2", "]", ")", "\n", "# Extend by a minimum of 10", "\n", "m", "=", "int", "(", "np", ".", "max", "(", "(", "10", ",", "m", "/", "4", ",", ".2", "*", "w", ")", ")", ")", "\n", "\n", "self", ".", "clusters", "=", "np", ".", "concatenate", "(", "(", "self", ".", "clusters", ",", "np", ".", "zeros", "(", "(", "3", ",", "m", ")", ")", ")", ",", "1", ")", "\n", "\n", "return", "list", "(", "range", "(", "w", ",", "w", "+", "m", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._get_slot": [[277, 287], ["simulator.Simulator._free_slots.pop", "list", "numpy.flatnonzero", "simulator.Simulator._extend_clusters", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator._extend_clusters"], ["", "def", "_get_slot", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "_free_slots", ":", "\n", "# A slot is free if no population has any individuals left in the cluster", "\n", "# and it has not been observed.", "\n", "            ", "self", ".", "_free_slots", "=", "list", "(", "np", ".", "flatnonzero", "(", "np", ".", "all", "(", "self", ".", "clusters", "==", "0", ",", "axis", "=", "0", ")", ")", ")", "\n", "if", "not", "self", ".", "_free_slots", ":", "\n", "# Make new slots", "\n", "                ", "self", ".", "_free_slots", "=", "self", ".", "_extend_clusters", "(", ")", "\n", "\n", "", "", "return", "self", ".", "_free_slots", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.extract_death_times": [[288, 293], ["numpy.argmax", "numpy.array"], "methods", ["None"], ["", "def", "extract_death_times", "(", "self", ",", "dtype", "=", "None", ")", ":", "\n", "        ", "\"\"\"Find the largest cluster and return it's death times\"\"\"", "\n", "observed", "=", "self", ".", "clusters", "[", "2", "]", "\n", "i_max", "=", "np", ".", "argmax", "(", "observed", ")", "\n", "return", "np", ".", "array", "(", "self", ".", "death_times", "[", "i_max", "]", ",", "dtype", "=", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.analytical_means": [[294, 304], ["simulator.Simulator.analytical_means"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.analytical_means"], ["", "@", "property", "\n", "def", "analytical_means", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the balance population sizes and the approximated mean number of observations in one year\n\n        Returns\n        -------\n        list\n        \"\"\"", "\n", "return", "analytical_means", "(", "self", ".", "burden", ",", "self", ".", "trans", ",", "self", ".", "death", ",", "self", ".", "trans_non_c", ",", "\n", "self", ".", "death_non_c", ",", "self", ".", "p_compliance", ",", "self", ".", "p_observed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator._choose_cluster": [[306, 309], ["numpy.flatnonzero().item", "numpy.flatnonzero", "random_state.multinomial"], "function", ["None"], ["", "", "def", "_choose_cluster", "(", "clusters", ",", "sum_clusters", ",", "random_state", ")", ":", "\n", "    ", "p", "=", "clusters", "/", "sum_clusters", "\n", "return", "np", ".", "flatnonzero", "(", "random_state", ".", "multinomial", "(", "1", ",", "p", ")", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.analytical_means": [[311, 336], ["None"], "function", ["None"], ["", "def", "analytical_means", "(", "burden", ",", "trans", ",", "death", ",", "trans_non_c", ",", "death_non_c", ",", "p_compliance", "=", ".95", ",", "\n", "p_observed", "=", ".80", ")", ":", "\n", "    ", "\"\"\"Return the balance population sizes and the approximated mean number of observations in one year\n\n    Returns\n    -------\n    list\n    \"\"\"", "\n", "\n", "p_c_neg", "=", "1", "-", "p_compliance", "\n", "\n", "# Compute the mean of the non-compliant population", "\n", "n_nc", "=", "burden", "*", "death", "*", "p_c_neg", "\n", "n_nc", "/=", "(", "death", "*", "death_non_c", "-", "\n", "trans", "*", "death_non_c", "*", "p_compliance", "-", "\n", "trans_non_c", "*", "death", "*", "p_c_neg", ")", "\n", "\n", "# Compute the mean of the compliant population", "\n", "n_c", "=", "n_nc", "*", "(", "death_non_c", "-", "trans_non_c", "*", "p_c_neg", ")", "-", "burden", "*", "p_c_neg", "\n", "n_c", "/=", "(", "trans", "*", "p_c_neg", ")", "\n", "\n", "# Compute the mean of observed in one year", "\n", "n_obs", "=", "(", "n_c", "*", "death", "+", "n_nc", "*", "death_non_c", ")", "*", "p_observed", "\n", "\n", "return", "n_c", ",", "n_nc", ",", "n_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.test_simulator": [[338, 346], ["simulator.Simulator", "simulator.Simulator.next_event", "numpy.array_equal", "numpy.all", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bdm_dgp_simulator.simulator.Simulator.next_event"], ["", "def", "test_simulator", "(", ")", ":", "\n", "    ", "\"\"\"A quick test sanity check for the simulator.\"\"\"", "\n", "s", "=", "Simulator", "(", "200", ",", "1", ",", "6", ",", "trans_non_c", "=", "1.1", ",", "death_non_c", "=", ".52", ",", "t_obs", "=", "2", ",", "t_warmup", "=", "10", ")", "\n", "while", "s", ".", "next_event", "(", ")", ":", "\n", "        ", "pass", "\n", "\n", "", "assert", "np", ".", "array_equal", "(", "s", ".", "n", ",", "np", ".", "sum", "(", "s", ".", "clusters", ",", "1", ")", ")", "\n", "assert", "np", ".", "all", "(", "s", ".", "clusters", ">=", "0", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.Client.__init__": [[21, 35], ["multiprocessing.Pool", "itertools.count", "kwargs.pop"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_processes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Create a multiprocessing client.\n\n        Parameters\n        ----------\n        num_processes : int, optional\n            Number of worker processes to use. Defaults to os.cpu_count().\n\n        \"\"\"", "\n", "num_processes", "=", "num_processes", "or", "kwargs", ".", "pop", "(", "'processes'", ",", "None", ")", "\n", "self", ".", "pool", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "num_processes", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "tasks", "=", "{", "}", "\n", "self", ".", "_id_counter", "=", "itertools", ".", "count", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.Client.apply": [[36, 53], ["multiprocessing.Client._id_counter.__next__", "multiprocessing.Client.pool.apply_async"], "methods", ["None"], ["", "def", "apply", "(", "self", ",", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Add `kallable(*args, **kwargs)` to the queue of tasks. Returns immediately.\n\n        Parameters\n        ----------\n        kallable : callable\n\n        Returns\n        -------\n        id : int\n            Number of the queued task.\n\n        \"\"\"", "\n", "id", "=", "self", ".", "_id_counter", ".", "__next__", "(", ")", "\n", "async_res", "=", "self", ".", "pool", ".", "apply_async", "(", "kallable", ",", "args", ",", "kwargs", ")", "\n", "self", ".", "tasks", "[", "id", "]", "=", "async_res", "\n", "return", "id", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.Client.apply_sync": [[54, 63], ["multiprocessing.Client.pool.apply"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply"], ["", "def", "apply_sync", "(", "self", ",", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Call and returns the result of `kallable(*args, **kwargs)`.\n\n        Parameters\n        ----------\n        kallable : callable\n\n        \"\"\"", "\n", "return", "self", ".", "pool", ".", "apply", "(", "kallable", ",", "args", ",", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.Client.get_result": [[64, 75], ["multiprocessing.Client.tasks.pop", "multiprocessing.Client.get"], "methods", ["None"], ["", "def", "get_result", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Return the result from task identified by `task_id` when it arrives.\n\n        Parameters\n        ----------\n        task_id : int\n            Id of the task whose result to return.\n\n        \"\"\"", "\n", "async_result", "=", "self", ".", "tasks", ".", "pop", "(", "task_id", ")", "\n", "return", "async_result", ".", "get", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.Client.is_ready": [[76, 85], ["multiprocessing.Client.tasks[].ready"], "methods", ["None"], ["", "def", "is_ready", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Return whether task with identifier `task_id` is ready.\n\n        Parameters\n        ----------\n        task_id : int\n\n        \"\"\"", "\n", "return", "self", ".", "tasks", "[", "task_id", "]", ".", "ready", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.Client.remove_task": [[86, 96], ["None"], "methods", ["None"], ["", "def", "remove_task", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Remove task with identifier `task_id` from pool.\n\n        Parameters\n        ----------\n        task_id : int\n\n        \"\"\"", "\n", "if", "task_id", "in", "self", ".", "tasks", ":", "\n", "            ", "del", "self", ".", "tasks", "[", "task_id", "]", "\n", "# TODO: also kill the pid?", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.Client.reset": [[98, 103], ["multiprocessing.Client.pool.terminate", "multiprocessing.Client.pool.join", "multiprocessing.Client.tasks.clear"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Stop all worker processes immediately and clear pending tasks.\"\"\"", "\n", "self", ".", "pool", ".", "terminate", "(", ")", "\n", "self", ".", "pool", ".", "join", "(", ")", "\n", "self", ".", "tasks", ".", "clear", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.Client.num_cores": [[104, 108], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_cores", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of processes.\"\"\"", "\n", "return", "self", ".", "pool", ".", "_processes", "# N.B. Not necessarily the number of actual cores.", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.multiprocessing.set_as_default": [[12, 16], ["elfi.client.set_client", "elfi.client.set_default_class"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_default_class"], ["def", "set_as_default", "(", ")", ":", "\n", "    ", "\"\"\"Set this as the default client.\"\"\"", "\n", "elfi", ".", "client", ".", "set_client", "(", ")", "\n", "elfi", ".", "client", ".", "set_default_class", "(", "Client", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.Client.__init__": [[28, 42], ["ipyparallel.Client.ipp_client.load_balanced_view", "itertools.count", "ipyparallel.Client"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "ipp_client", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Create an ipyparallel client for ELFI.\n\n        Parameters\n        ----------\n        ipp_client : ipyparallel.Client, optional\n            Use this ipyparallel client with ELFI.\n\n        \"\"\"", "\n", "self", ".", "ipp_client", "=", "ipp_client", "or", "ipp", ".", "Client", "(", "**", "kwargs", ")", "\n", "self", ".", "view", "=", "self", ".", "ipp_client", ".", "load_balanced_view", "(", ")", "\n", "\n", "self", ".", "tasks", "=", "{", "}", "\n", "self", ".", "_id_counter", "=", "itertools", ".", "count", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.Client.apply": [[43, 60], ["ipyparallel.Client._id_counter.__next__", "ipyparallel.Client.view.apply"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply"], ["", "def", "apply", "(", "self", ",", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Add `kallable(*args, **kwargs)` to the queue of tasks. Returns immediately.\n\n        Parameters\n        ----------\n        kallable : callable\n\n        Returns\n        -------\n        id : int\n            Number of the queued task.\n\n        \"\"\"", "\n", "id", "=", "self", ".", "_id_counter", ".", "__next__", "(", ")", "\n", "async_res", "=", "self", ".", "view", ".", "apply", "(", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "tasks", "[", "id", "]", "=", "async_res", "\n", "return", "id", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.Client.apply_sync": [[61, 70], ["ipyparallel.Client.view.apply_sync"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply_sync"], ["", "def", "apply_sync", "(", "self", ",", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Call and returns the result of `kallable(*args, **kwargs)`.\n\n        Parameters\n        ----------\n        kallable : callable\n\n        \"\"\"", "\n", "return", "self", ".", "view", ".", "apply_sync", "(", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.Client.get_result": [[71, 82], ["ipyparallel.Client.tasks.pop", "ipyparallel.Client.get"], "methods", ["None"], ["", "def", "get_result", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Return the result from task identified by `task_id` when it arrives.\n\n        Parameters\n        ----------\n        task_id : int\n            Id of the task whose result to return.\n\n        \"\"\"", "\n", "async_result", "=", "self", ".", "tasks", ".", "pop", "(", "task_id", ")", "\n", "return", "async_result", ".", "get", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.Client.is_ready": [[83, 92], ["ipyparallel.Client.tasks[].ready"], "methods", ["None"], ["", "def", "is_ready", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Return whether task with identifier `task_id` is ready.\n\n        Parameters\n        ----------\n        task_id : int\n\n        \"\"\"", "\n", "return", "self", ".", "tasks", "[", "task_id", "]", ".", "ready", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.Client.remove_task": [[93, 105], ["ipyparallel.Client.tasks.pop", "ipyparallel.Client.ready", "ipyparallel.Client.ipp_client.abort"], "methods", ["None"], ["", "def", "remove_task", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Remove task with identifier `task_id` from pool.\n\n        Parameters\n        ----------\n        task_id : int\n\n        \"\"\"", "\n", "async_result", "=", "self", ".", "tasks", ".", "pop", "(", "task_id", ")", "\n", "if", "not", "async_result", ".", "ready", "(", ")", ":", "\n", "# Note: Ipyparallel is only able to abort if the job hasn't started.", "\n", "            ", "return", "self", ".", "ipp_client", ".", "abort", "(", "async_result", ",", "block", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.Client.reset": [[106, 113], ["ipyparallel.Client.view.abort", "ipyparallel.Client.tasks.clear"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Stop all worker processes immediately and clear pending tasks.\n\n        Note: Ipyparallel is only able to abort if the job hasn't started.\n        \"\"\"", "\n", "self", ".", "view", ".", "abort", "(", "block", "=", "False", ")", "\n", "self", ".", "tasks", ".", "clear", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.Client.num_cores": [[114, 118], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_cores", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of processes.\"\"\"", "\n", "return", "len", "(", "self", ".", "view", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.ipyparallel.set_as_default": [[16, 20], ["elfi.client.set_client", "elfi.client.set_default_class"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_default_class"], ["def", "set_as_default", "(", ")", ":", "\n", "    ", "\"\"\"Set this as the default client.\"\"\"", "\n", "elfi", ".", "client", ".", "set_client", "(", ")", "\n", "elfi", ".", "client", ".", "set_default_class", "(", "Client", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.__init__": [[23, 27], ["itertools.count"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Create a native client.\"\"\"", "\n", "self", ".", "tasks", "=", "{", "}", "\n", "self", ".", "_ids", "=", "itertools", ".", "count", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply": [[28, 44], ["native.Client._ids.__next__"], "methods", ["None"], ["", "def", "apply", "(", "self", ",", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Add `kallable(*args, **kwargs)` to the queue of tasks. Returns immediately.\n\n        Parameters\n        ----------\n        kallable : callable\n\n        Returns\n        -------\n        id : int\n            Number of the queued task.\n\n        \"\"\"", "\n", "id", "=", "self", ".", "_ids", ".", "__next__", "(", ")", "\n", "self", ".", "tasks", "[", "id", "]", "=", "(", "kallable", ",", "args", ",", "kwargs", ")", "\n", "return", "id", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply_sync": [[45, 54], ["kallable"], "methods", ["None"], ["", "def", "apply_sync", "(", "self", ",", "kallable", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Call and returns the result of `kallable(*args, **kwargs)`.\n\n        Parameters\n        ----------\n        kallable : callable\n\n        \"\"\"", "\n", "return", "kallable", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.get_result": [[55, 66], ["native.Client.tasks.pop", "kallable"], "methods", ["None"], ["", "def", "get_result", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Return the result from task identified by `task_id` when it arrives.\n\n        Parameters\n        ----------\n        task_id : int\n            Id of the task whose result to return.\n\n        \"\"\"", "\n", "kallable", ",", "args", ",", "kwargs", "=", "self", ".", "tasks", ".", "pop", "(", "task_id", ")", "\n", "return", "kallable", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.is_ready": [[67, 76], ["None"], "methods", ["None"], ["", "def", "is_ready", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Return whether task with identifier `task_id` is ready.\n\n        Parameters\n        ----------\n        task_id : int\n\n        \"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.remove_task": [[77, 87], ["None"], "methods", ["None"], ["", "def", "remove_task", "(", "self", ",", "task_id", ")", ":", "\n", "        ", "\"\"\"Remove task with identifier `task_id` from pool.\n\n        Parameters\n        ----------\n        task_id : int\n\n        \"\"\"", "\n", "if", "task_id", "in", "self", ".", "tasks", ":", "\n", "            ", "del", "self", ".", "tasks", "[", "task_id", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.reset": [[88, 91], ["native.Client.tasks.clear"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Stop all worker processes immediately and clear pending tasks.\"\"\"", "\n", "self", ".", "tasks", ".", "clear", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.num_cores": [[92, 96], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_cores", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of processes, which is always 1 for the native client.\"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.set_as_default": [[11, 15], ["elfi.client.set_client", "elfi.client.set_default_class"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.set_default_class"], ["def", "set_as_default", "(", ")", ":", "\n", "    ", "\"\"\"Set this as the default client.\"\"\"", "\n", "elfi", ".", "client", ".", "set_client", "(", ")", "\n", "elfi", ".", "client", ".", "set_default_class", "(", "Client", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.__init__": [[43, 76], ["elfi.OutputPool", "ValueError", "diagnostics.TwoStageSelection._combine_ss"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection._combine_ss"], ["def", "__init__", "(", "self", ",", "simulator", ",", "fn_distance", ",", "list_ss", "=", "None", ",", "prepared_ss", "=", "None", ",", "\n", "max_cardinality", "=", "4", ",", "seed", "=", "0", ")", ":", "\n", "        ", "\"\"\"Initialise the summary-statistics selection for the Two Stage Procedure.\n\n        Parameters\n        ----------\n        simulator : elfi.Node\n            Node (often elfi.Simulator) for which the summary statistics will be applied.\n            The node is the final node of a coherent ElfiModel (i.e. it has no child nodes).\n        fn_distance : str or callable function\n            Distance metric, consult the elfi.Distance documentation for calling as a string.\n        list_ss : List of callable functions, optional\n            List of candidate summary statistics.\n        prepared_ss : List of lists of callable functions, optional\n            List of prepared combinations of candidate summary statistics.\n            No other combinations will be evaluated.\n        max_cardinality : int, optional\n            Maximum cardinality of a candidate summary-statistics combination.\n        seed : int, optional\n\n        \"\"\"", "\n", "if", "list_ss", "is", "None", "and", "prepared_ss", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'No summary statistics to assess.'", ")", "\n", "\n", "", "self", ".", "simulator", "=", "simulator", "\n", "self", ".", "fn_distance", "=", "fn_distance", "\n", "self", ".", "seed", "=", "seed", "\n", "if", "prepared_ss", "is", "not", "None", ":", "\n", "            ", "self", ".", "ss_candidates", "=", "prepared_ss", "\n", "", "else", ":", "\n", "            ", "self", ".", "ss_candidates", "=", "self", ".", "_combine_ss", "(", "list_ss", ",", "max_cardinality", "=", "max_cardinality", ")", "\n", "# Initialising an output pool as the rejection sampling will be used several times.", "\n", "", "self", ".", "pool", "=", "elfi", ".", "OutputPool", "(", "simulator", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection._combine_ss": [[77, 102], ["range", "len", "len", "itertools.combinations", "combinations_ss.append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "_combine_ss", "(", "self", ",", "list_ss", ",", "max_cardinality", ")", ":", "\n", "        ", "\"\"\"Create all combinations of the initialised summary statistics up till the maximum cardinality.\n\n        Parameters\n        ----------\n        list_ss : List of callable functions\n            List of candidate summary statistics.\n        max_cardinality : int\n            Maximum cardinality of a candidate summary-statistics combination.\n\n        Returns\n        -------\n        List\n            Combinations of candidate summary statistics.\n\n        \"\"\"", "\n", "if", "max_cardinality", ">", "len", "(", "list_ss", ")", ":", "\n", "            ", "max_cardinality", "=", "len", "(", "list_ss", ")", "\n", "\n", "# Combine the candidate summary statistics.", "\n", "", "combinations_ss", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "max_cardinality", ")", ":", "\n", "            ", "for", "combination", "in", "combinations", "(", "list_ss", ",", "i", "+", "1", ")", ":", "\n", "                ", "combinations_ss", ".", "append", "(", "combination", ")", "\n", "", "", "return", "combinations_ss", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run": [[103, 171], ["logger.info", "logger.info", "int", "int", "ValueError", "diagnostics.TwoStageSelection._obtain_accepted_thetas", "diagnostics.TwoStageSelection._calc_entropy", "logger.info", "diagnostics.TwoStageSelection._calc_MRSSE", "logger.info", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection._obtain_accepted_thetas", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection._calc_entropy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection._calc_MRSSE"], ["", "def", "run", "(", "self", ",", "n_sim", ",", "n_acc", "=", "None", ",", "n_closest", "=", "None", ",", "batch_size", "=", "1", ",", "k", "=", "4", ")", ":", "\n", "        ", "\"\"\"Run the Two Stage Procedure for identifying relevant summary statistics.\n\n        Parameters\n        ----------\n        n_sim : int\n            Number of the total ABC-rejection simulations.\n        n_acc : int, optional\n            Number of the accepted ABC-rejection simulations.\n        n_closest : int, optional\n            Number of the 'closest' datasets\n            (i.e., the closest n simulation datasets w.r.t the observations).\n        batch_size : int, optional\n            Number of samples per batch.\n        k : int, optional\n            Parameter for the kth-nearest-neighbour search performed in the minimum-entropy step\n            (in Nunes & Balding, 2010 it is fixed to 4).\n\n        Returns\n        -------\n        array_like\n            Summary-statistics combination showing the optimal performance.\n\n        \"\"\"", "\n", "# Setting the default value of n_acc to the .01 quantile of n_sim,", "\n", "# and n_closest to the .01 quantile of n_acc as in Nunes and Balding (2010).", "\n", "if", "n_acc", "is", "None", ":", "\n", "            ", "n_acc", "=", "int", "(", "n_sim", "/", "100", ")", "\n", "", "if", "n_closest", "is", "None", ":", "\n", "            ", "n_closest", "=", "int", "(", "n_acc", "/", "100", ")", "\n", "", "if", "n_sim", "<", "n_acc", "or", "n_acc", "<", "n_closest", "or", "n_closest", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"The number of simulations is too small.\"", ")", "\n", "\n", "# Find the summary-statistics combination with the minimum entropy, and", "\n", "# preserve the parameters (thetas) corresponding to the `closest' datasets.", "\n", "", "thetas", "=", "{", "}", "\n", "E_me", "=", "np", ".", "inf", "\n", "names_ss_me", "=", "[", "]", "\n", "for", "set_ss", "in", "self", ".", "ss_candidates", ":", "\n", "            ", "names_ss", "=", "[", "ss", ".", "__name__", "for", "ss", "in", "set_ss", "]", "\n", "thetas_ss", "=", "self", ".", "_obtain_accepted_thetas", "(", "set_ss", ",", "n_sim", ",", "n_acc", ",", "batch_size", ")", "\n", "thetas", "[", "set_ss", "]", "=", "thetas_ss", "\n", "E_ss", "=", "self", ".", "_calc_entropy", "(", "thetas_ss", ",", "n_acc", ",", "k", ")", "\n", "# If equal, dismiss the combination which contains uninformative summary statistics.", "\n", "if", "(", "E_ss", "==", "E_me", "and", "(", "len", "(", "names_ss_me", ")", ">", "len", "(", "names_ss", ")", ")", ")", "or", "E_ss", "<", "E_me", ":", "\n", "                ", "E_me", "=", "E_ss", "\n", "names_ss_me", "=", "names_ss", "\n", "thetas_closest", "=", "thetas_ss", "[", ":", "n_closest", "]", "\n", "", "logger", ".", "info", "(", "'Combination %s shows the entropy of %f'", "%", "(", "names_ss", ",", "E_ss", ")", ")", "\n", "# Note: entropy is in the log space (negative values allowed).", "\n", "", "logger", ".", "info", "(", "'\\nThe minimum entropy of %f was found in %s.\\n'", "%", "(", "E_me", ",", "names_ss_me", ")", ")", "\n", "\n", "# Find the summary-statistics combination with", "\n", "# the minimum mean root sum of squared error (MRSSE).", "\n", "MRSSE_min", "=", "np", ".", "inf", "\n", "names_ss_MRSSE", "=", "[", "]", "\n", "for", "set_ss", "in", "self", ".", "ss_candidates", ":", "\n", "            ", "names_ss", "=", "[", "ss", ".", "__name__", "for", "ss", "in", "set_ss", "]", "\n", "MRSSE_ss", "=", "self", ".", "_calc_MRSSE", "(", "set_ss", ",", "thetas_closest", ",", "thetas", "[", "set_ss", "]", ")", "\n", "# If equal, dismiss the combination which contains uninformative summary statistics.", "\n", "if", "(", "MRSSE_ss", "==", "MRSSE_min", "and", "(", "len", "(", "names_ss_MRSSE", ")", ">", "len", "(", "names_ss", ")", ")", ")", "or", "MRSSE_ss", "<", "MRSSE_min", ":", "\n", "                ", "MRSSE_min", "=", "MRSSE_ss", "\n", "names_ss_MRSSE", "=", "names_ss", "\n", "set_ss_2stage", "=", "set_ss", "\n", "", "logger", ".", "info", "(", "'Combination %s shows the MRSSE of %f'", "%", "(", "names_ss", ",", "MRSSE_ss", ")", ")", "\n", "", "logger", ".", "info", "(", "'\\nThe minimum MRSSE of %f was found in %s.'", "%", "(", "MRSSE_min", ",", "names_ss_MRSSE", ")", ")", "\n", "return", "set_ss_2stage", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection._obtain_accepted_thetas": [[172, 213], ["diagnostics.TwoStageSelection.simulator.model.copy", "isinstance", "elfi.Rejection", "elfi.Rejection.sample", "list_ss.append", "elfi.Distance", "elfi.Discrepancy", "elfi.Summary"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "_obtain_accepted_thetas", "(", "self", ",", "set_ss", ",", "n_sim", ",", "n_acc", ",", "batch_size", ")", ":", "\n", "        ", "\"\"\"Perform the ABC-rejection sampling and identify `closest' parameters.\n\n        The sampling is performed using the initialised simulator.\n\n        Parameters\n        ----------\n        set_ss : List\n            Summary-statistics combination to be used in the rejection sampling.\n        n_sim : int\n            Number of the iterations of the rejection sampling.\n        n_acc : int\n            Number of the accepted parameters.\n        batch_size : int\n            Number of samples per batch.\n\n        Returns\n        -------\n        array_like\n            Accepted parameters.\n\n        \"\"\"", "\n", "# Initialise the distance function.", "\n", "m", "=", "self", ".", "simulator", ".", "model", ".", "copy", "(", ")", "\n", "list_ss", "=", "[", "]", "\n", "for", "ss", "in", "set_ss", ":", "\n", "            ", "list_ss", ".", "append", "(", "elfi", ".", "Summary", "(", "ss", ",", "m", "[", "self", ".", "simulator", ".", "name", "]", ",", "model", "=", "m", ")", ")", "\n", "", "if", "isinstance", "(", "self", ".", "fn_distance", ",", "str", ")", ":", "\n", "            ", "d", "=", "elfi", ".", "Distance", "(", "self", ".", "fn_distance", ",", "*", "list_ss", ",", "model", "=", "m", ")", "\n", "", "else", ":", "\n", "            ", "d", "=", "elfi", ".", "Discrepancy", "(", "self", ".", "fn_distance", ",", "*", "list_ss", ",", "model", "=", "m", ")", "\n", "\n", "# Run the simulations.", "\n", "# TODO: include different distance functions in the summary-statistics combinations.", "\n", "", "sampler_rejection", "=", "elfi", ".", "Rejection", "(", "d", ",", "batch_size", "=", "batch_size", ",", "\n", "seed", "=", "self", ".", "seed", ",", "pool", "=", "self", ".", "pool", ")", "\n", "result", "=", "sampler_rejection", ".", "sample", "(", "n_acc", ",", "n_sim", "=", "n_sim", ")", "\n", "\n", "# Extract the accepted parameters.", "\n", "thetas_acc", "=", "result", ".", "samples_array", "\n", "return", "thetas_acc", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection._calc_entropy": [[214, 254], ["scipy.spatial.cKDTree", "numpy.log", "numpy.log", "scipy.spatial.cKDTree.query", "numpy.log", "scipy.special.digamma", "scipy.special.gamma"], "methods", ["None"], ["", "def", "_calc_entropy", "(", "self", ",", "thetas_ss", ",", "n_acc", ",", "k", ")", ":", "\n", "        ", "\"\"\"Calculate the entropy as described in Nunes & Balding, 2010.\n\n        E = log( pi^(q/2) / gamma(q/2+1) ) - digamma(k) + log(n)\n            + q/n * sum_{i=1}^n( log(R_{i, k}) ), where\n\n        R_{i, k} is the Euclidean distance from the parameter theta_i to\n        its kth nearest neighbour;\n        q is the dimensionality of the parameter; and\n        n is the number of the accepted parameters n_acc in the rejection sampling.\n\n        Parameters\n        ----------\n        thetas_ss : array_like\n            Parameters accepted upon the rejection sampling using\n            the summary-statistics combination ss.\n        n_acc : int\n            Number of the accepted parameters.\n        k : int\n            Nearest neighbour to be searched.\n\n        Returns\n        -------\n        float\n            Entropy.\n\n        \"\"\"", "\n", "q", "=", "thetas_ss", ".", "shape", "[", "1", "]", "\n", "\n", "# Calculate the distance to the kth nearest neighbour across all accepted parameters.", "\n", "searcher_knn", "=", "cKDTree", "(", "thetas_ss", ")", "\n", "sum_log_dist_knn", "=", "0", "\n", "for", "theta_ss", "in", "thetas_ss", ":", "\n", "            ", "dist_knn", "=", "searcher_knn", ".", "query", "(", "theta_ss", ",", "k", "=", "k", ")", "[", "0", "]", "[", "-", "1", "]", "\n", "sum_log_dist_knn", "+=", "np", ".", "log", "(", "dist_knn", ")", "\n", "\n", "# Calculate the entropy.", "\n", "", "E", "=", "np", ".", "log", "(", "np", ".", "pi", "**", "(", "q", "/", "2", ")", "/", "gamma", "(", "(", "q", "/", "2", ")", "+", "1", ")", ")", "-", "digamma", "(", "k", ")", "+", "np", ".", "log", "(", "n_acc", ")", "+", "(", "q", "/", "n_acc", ")", "*", "sum_log_dist_knn", "\n", "return", "E", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection._calc_MRSSE": [[255, 290], ["numpy.sqrt", "len", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "_calc_MRSSE", "(", "self", ",", "set_ss", ",", "thetas_obs", ",", "thetas_sim", ")", ":", "\n", "        ", "\"\"\"Calculate the mean root of squared error (MRSSE) as described in Nunes & Balding, 2010.\n\n        MRSSE = 1/n * sum_{j=1}^n( RSSE(j) ),\n\n        RSSE = 1/m * sum_{i=1}^m( theta_i - theta_true ), where\n\n        n is the number of the `closest' datasets identified using\n        the summary-statistics combination corresponding to the minimum entropy;\n        m is the number of the accepted parameters in the rejection sampling for set_ss;\n        theta_i is an instance of the parameters corresponding to set_ss; and\n        theta_true is the parameters corresponding to a `closest' dataset.\n\n        Parameters\n        ----------\n        set_ss : List\n            Summary-statistics combination used in the rejection sampling.\n        thetas_obs : array_like\n            List of parameters corresponding to the `closest' datasets.\n        thetas_sim : array_like\n            Parameters corresponding to set_ss.\n\n        Returns\n        -------\n        float\n            Mean root of squared error.\n\n        \"\"\"", "\n", "RSSE_total", "=", "0", "\n", "for", "theta_obs", "in", "thetas_obs", ":", "\n", "            ", "SSE", "=", "np", ".", "linalg", ".", "norm", "(", "thetas_sim", "-", "theta_obs", ")", "**", "2", "\n", "RSSE", "=", "np", ".", "sqrt", "(", "SSE", ")", "\n", "RSSE_total", "+=", "RSSE", "\n", "", "MRSSE", "=", "RSSE_total", "/", "len", "(", "thetas_obs", ")", "\n", "return", "MRSSE", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.model_selection.compare_models": [[6, 60], ["len", "min", "numpy.empty", "range", "numpy.concatenate", "numpy.argsort", "numpy.logical_and().sum", "np.empty.sum", "ValueError", "numpy.logical_and"], "function", ["None"], ["def", "compare_models", "(", "sample_objs", ",", "model_priors", "=", "None", ")", ":", "\n", "    ", "\"\"\"Find posterior probabilities for different models.\n\n    The algorithm requires elfi.Sample objects from prerun inference methods. For example the\n    output from elfi.Rejection.sample is valid. The portion of samples for each model in the top\n    discrepancies are adjusted by each models acceptance ratio and prior probability.\n\n    The discrepancies (including summary statistics) must be comparable so that it is\n    meaningful to sort them!\n\n    Parameters\n    ----------\n    sample_objs : list of elfi.Sample\n        Resulting Sample objects from prerun inference models. The objects must include\n        a valid `discrepancies` attribute.\n    model_priors : array_like, optional\n        Prior probability of each model. Defaults to 1 / n_models.\n\n    Returns\n    -------\n    np.array\n        Posterior probabilities for the considered models.\n\n    \"\"\"", "\n", "n_models", "=", "len", "(", "sample_objs", ")", "\n", "n_min", "=", "min", "(", "[", "s", ".", "n_samples", "for", "s", "in", "sample_objs", "]", ")", "\n", "\n", "# concatenate discrepancy vectors", "\n", "try", ":", "\n", "        ", "discrepancies", "=", "np", ".", "concatenate", "(", "[", "s", ".", "discrepancies", "for", "s", "in", "sample_objs", "]", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "raise", "ValueError", "(", "\"All Sample objects must include valid discrepancies.\"", ")", "\n", "\n", "# sort and take the smallest n_min", "\n", "", "inds", "=", "np", ".", "argsort", "(", "discrepancies", ")", "[", ":", "n_min", "]", "\n", "\n", "# calculate the portions of accepted samples for each model in the top discrepancies", "\n", "p_models", "=", "np", ".", "empty", "(", "n_models", ")", "\n", "up_bound", "=", "0", "\n", "for", "i", "in", "range", "(", "n_models", ")", ":", "\n", "        ", "low_bound", "=", "up_bound", "\n", "up_bound", "+=", "sample_objs", "[", "i", "]", ".", "n_samples", "\n", "p_models", "[", "i", "]", "=", "np", ".", "logical_and", "(", "inds", ">=", "low_bound", ",", "inds", "<", "up_bound", ")", ".", "sum", "(", ")", "\n", "\n", "# adjust by the number of simulations run", "\n", "p_models", "[", "i", "]", "/=", "sample_objs", "[", "i", "]", ".", "n_sim", "\n", "\n", "# adjust by the prior model probability", "\n", "if", "model_priors", "is", "not", "None", ":", "\n", "            ", "p_models", "[", "i", "]", "*=", "model_priors", "[", "i", "]", "\n", "\n", "", "", "p_models", "=", "p_models", "/", "p_models", ".", "sum", "(", ")", "\n", "\n", "return", "p_models", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.__init__": [[35, 82], ["super().__init__", "numpy.random.RandomState", "elfi.methods.bo.utils.minimize", "logger.info", "type", "type"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize"], ["def", "__init__", "(", "self", ",", "model", ",", "threshold", "=", "None", ",", "prior", "=", "None", ",", "n_inits", "=", "10", ",", "max_opt_iters", "=", "1000", ",", "seed", "=", "0", ")", ":", "\n", "        ", "\"\"\"Initialize a BOLFI posterior.\n\n        Parameters\n        ----------\n        model : elfi.bo.gpy_regression.GPyRegression\n            Instance of the surrogate model\n        threshold : float, optional\n            The threshold value used in the calculation of the posterior, see the BOLFI paper\n            for details. By default, the minimum value of discrepancy estimate mean is used.\n        prior : ScipyLikeDistribution, optional\n            By default uniform distribution within model bounds.\n        n_inits : int, optional\n            Number of initialization points in internal optimization.\n        max_opt_iters : int, optional\n            Maximum number of iterations performed in internal optimization.\n        seed : int, optional\n\n        \"\"\"", "\n", "super", "(", "BolfiPosterior", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "self", ".", "n_inits", "=", "n_inits", "\n", "self", ".", "max_opt_iters", "=", "max_opt_iters", "\n", "\n", "self", ".", "prior", "=", "prior", "\n", "self", ".", "dim", "=", "self", ".", "model", ".", "input_dim", "\n", "\n", "if", "type", "(", "self", ".", "model", ")", ".", "__name__", "==", "'DGPRegression'", ":", "\n", "            ", "predictive_gradient_mean", "=", "None", "\n", "", "elif", "type", "(", "self", ".", "model", ")", ".", "__name__", "==", "'GPyRegression'", ":", "\n", "            ", "predictive_gradient_mean", "=", "self", ".", "model", ".", "predictive_gradient_mean", "\n", "\n", "", "if", "self", ".", "threshold", "is", "None", ":", "\n", "# TODO: the evidence could be used for a good guess for starting locations", "\n", "            ", "minloc", ",", "minval", "=", "minimize", "(", "\n", "self", ".", "model", ".", "predict_mean", ",", "\n", "self", ".", "model", ".", "bounds", ",", "\n", "predictive_gradient_mean", ",", "\n", "self", ".", "prior", ",", "\n", "self", ".", "n_inits", ",", "\n", "self", ".", "max_opt_iters", ",", "\n", "random_state", "=", "self", ".", "random_state", ")", "\n", "self", ".", "threshold", "=", "minval", "\n", "logger", ".", "info", "(", "\"Using optimized minimum value (%.4f) of the GP discrepancy mean \"", "\n", "\"function as a threshold\"", "%", "(", "self", ".", "threshold", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.rvs": [[83, 89], ["NotImplementedError"], "methods", ["None"], ["", "", "def", "rvs", "(", "self", ",", "size", "=", "None", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Sample the posterior.\n\n        Currently unimplemented. Please use a sampler to sample from the posterior.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "'Currently not implemented. Please use a sampler to '", "\n", "'sample from the posterior.'", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.logpdf": [[91, 104], ["posteriors.BolfiPosterior._unnormalized_loglikelihood", "posteriors.BolfiPosterior.prior.logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._unnormalized_loglikelihood", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf"], ["", "def", "logpdf", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Return the unnormalized log-posterior pdf at x.\n\n        Parameters\n        ----------\n        x : np.array\n\n        Returns\n        -------\n        float\n\n        \"\"\"", "\n", "return", "self", ".", "_unnormalized_loglikelihood", "(", "x", ")", "+", "self", ".", "prior", ".", "logpdf", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.pdf": [[105, 118], ["numpy.exp", "posteriors.BolfiPosterior.logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf"], ["", "def", "pdf", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Return the unnormalized posterior pdf at x.\n\n        Parameters\n        ----------\n        x : np.array\n\n        Returns\n        -------\n        float\n\n        \"\"\"", "\n", "return", "np", ".", "exp", "(", "self", ".", "logpdf", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.gradient_logpdf": [[119, 137], ["posteriors.BolfiPosterior._gradient_unnormalized_loglikelihood", "posteriors.BolfiPosterior.prior.gradient_logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._gradient_unnormalized_loglikelihood", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.gradient_logpdf"], ["", "def", "gradient_logpdf", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Return the gradient of the unnormalized log-posterior pdf at x.\n\n        Parameters\n        ----------\n        x : np.array\n\n        Returns\n        -------\n        np.array\n\n        \"\"\"", "\n", "grads", "=", "self", ".", "_gradient_unnormalized_loglikelihood", "(", "x", ")", "+", "self", ".", "prior", ".", "gradient_logpdf", "(", "x", ")", "\n", "\n", "# nan grads are result from -inf logpdf", "\n", "# return np.where(np.isnan(grads), 0, grads)[0]", "\n", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._unnormalized_loglikelihood": [[138, 159], ["numpy.asanyarray", "x.reshape.reshape.reshape", "posteriors.BolfiPosterior._within_bounds", "posteriors.BolfiPosterior.model.predict", "scipy.norm.logcdf().squeeze", "len", "numpy.ones", "scipy.norm.logcdf", "len", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._within_bounds", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict"], ["", "def", "_unnormalized_loglikelihood", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "np", ".", "asanyarray", "(", "x", ")", "\n", "ndim", "=", "x", ".", "ndim", "\n", "x", "=", "x", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "dim", ")", ")", "\n", "\n", "logpdf", "=", "-", "np", ".", "ones", "(", "len", "(", "x", ")", ")", "*", "np", ".", "inf", "\n", "\n", "logi", "=", "self", ".", "_within_bounds", "(", "x", ")", "\n", "x", "=", "x", "[", "logi", ",", ":", "]", "\n", "if", "len", "(", "x", ")", "==", "0", ":", "\n", "            ", "if", "ndim", "==", "0", "or", "(", "ndim", "==", "1", "and", "self", ".", "dim", ">", "1", ")", ":", "\n", "                ", "logpdf", "=", "logpdf", "[", "0", "]", "\n", "", "return", "logpdf", "\n", "\n", "", "mean", ",", "var", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "logpdf", "[", "logi", "]", "=", "ss", ".", "norm", ".", "logcdf", "(", "self", ".", "threshold", ",", "mean", ",", "np", ".", "sqrt", "(", "var", ")", ")", ".", "squeeze", "(", ")", "\n", "\n", "if", "ndim", "==", "0", "or", "(", "ndim", "==", "1", "and", "self", ".", "dim", ">", "1", ")", ":", "\n", "            ", "logpdf", "=", "logpdf", "[", "0", "]", "\n", "\n", "", "return", "logpdf", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._gradient_unnormalized_loglikelihood": [[160, 191], ["numpy.asanyarray", "x.reshape.reshape.reshape", "numpy.zeros_like", "posteriors.BolfiPosterior._within_bounds", "posteriors.BolfiPosterior.model.predict", "numpy.sqrt", "posteriors.BolfiPosterior.model.predictive_gradients", "scipy.norm.pdf", "scipy.norm.cdf", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._within_bounds", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf"], ["", "def", "_gradient_unnormalized_loglikelihood", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "np", ".", "asanyarray", "(", "x", ")", "\n", "ndim", "=", "x", ".", "ndim", "\n", "x", "=", "x", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "dim", ")", ")", "\n", "\n", "grad", "=", "np", ".", "zeros_like", "(", "x", ")", "\n", "\n", "logi", "=", "self", ".", "_within_bounds", "(", "x", ")", "\n", "x", "=", "x", "[", "logi", ",", ":", "]", "\n", "if", "len", "(", "x", ")", "==", "0", ":", "\n", "            ", "if", "ndim", "==", "0", "or", "(", "ndim", "==", "1", "and", "self", ".", "dim", ">", "1", ")", ":", "\n", "                ", "grad", "=", "grad", "[", "0", "]", "\n", "", "return", "grad", "\n", "\n", "", "mean", ",", "var", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "std", "=", "np", ".", "sqrt", "(", "var", ")", "\n", "\n", "grad_mean", ",", "grad_var", "=", "self", ".", "model", ".", "predictive_gradients", "(", "x", ")", "\n", "\n", "factor", "=", "-", "grad_mean", "*", "std", "-", "(", "self", ".", "threshold", "-", "mean", ")", "*", "0.5", "*", "grad_var", "/", "std", "\n", "factor", "=", "factor", "/", "var", "\n", "term", "=", "(", "self", ".", "threshold", "-", "mean", ")", "/", "std", "\n", "pdf", "=", "ss", ".", "norm", ".", "pdf", "(", "term", ")", "\n", "cdf", "=", "ss", ".", "norm", ".", "cdf", "(", "term", ")", "\n", "\n", "grad", "[", "logi", ",", ":", "]", "=", "factor", "*", "pdf", "/", "cdf", "\n", "\n", "if", "ndim", "==", "0", "or", "(", "ndim", "==", "1", "and", "self", ".", "dim", ">", "1", ")", ":", "\n", "            ", "grad", "=", "grad", "[", "0", "]", "\n", "\n", "", "return", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._unnormalized_likelihood": [[193, 195], ["numpy.exp", "posteriors.BolfiPosterior._unnormalized_loglikelihood"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._unnormalized_loglikelihood"], ["", "def", "_unnormalized_likelihood", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "np", ".", "exp", "(", "self", ".", "_unnormalized_loglikelihood", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._neg_unnormalized_loglikelihood": [[196, 198], ["posteriors.BolfiPosterior._unnormalized_loglikelihood"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._unnormalized_loglikelihood"], ["", "def", "_neg_unnormalized_loglikelihood", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "-", "1", "*", "self", ".", "_unnormalized_loglikelihood", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._gradient_neg_unnormalized_loglikelihood": [[199, 201], ["posteriors.BolfiPosterior._gradient_unnormalized_loglikelihood"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._gradient_unnormalized_loglikelihood"], ["", "def", "_gradient_neg_unnormalized_loglikelihood", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "-", "1", "*", "self", ".", "_gradient_unnormalized_loglikelihood", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._neg_unnormalized_logposterior": [[202, 204], ["posteriors.BolfiPosterior.logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf"], ["", "def", "_neg_unnormalized_logposterior", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "-", "1", "*", "self", ".", "logpdf", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._gradient_neg_unnormalized_logposterior": [[205, 207], ["posteriors.BolfiPosterior.gradient_logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.gradient_logpdf"], ["", "def", "_gradient_neg_unnormalized_logposterior", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "-", "1", "*", "self", ".", "gradient_logpdf", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior._within_bounds": [[208, 215], ["x.reshape.reshape.reshape", "numpy.ones", "range", "len"], "methods", ["None"], ["", "def", "_within_bounds", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "dim", ")", ")", "\n", "logical", "=", "np", ".", "ones", "(", "len", "(", "x", ")", ",", "dtype", "=", "bool", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "            ", "logical", "*=", "(", "x", "[", ":", ",", "i", "]", ">=", "self", ".", "model", ".", "bounds", "[", "i", "]", "[", "0", "]", ")", "\n", "logical", "*=", "(", "x", "[", ":", ",", "i", "]", "<=", "self", ".", "model", ".", "bounds", "[", "i", "]", "[", "1", "]", ")", "\n", "", "return", "logical", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.plot": [[216, 258], ["numpy.warnings.catch_warnings", "numpy.warnings.filterwarnings", "len", "numpy.arange", "numpy.zeros", "range", "matplotlib.figure", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.show", "len", "len", "fun", "len", "numpy.meshgrid", "matplotlib.contour", "matplotlib.show", "NotImplementedError", "min", "max", "numpy.linspace", "numpy.linspace", "numpy.vectorize", "fun", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.plot", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.tools.vectorize"], ["", "def", "plot", "(", "self", ",", "logpdf", "=", "False", ")", ":", "\n", "        ", "\"\"\"Plot the posterior pdf.\n\n        Currently only supports 1 and 2 dimensional cases.\n\n        Parameters\n        ----------\n        logpdf : bool\n            Whether to plot logpdf instead of pdf.\n\n        \"\"\"", "\n", "if", "logpdf", ":", "\n", "            ", "fun", "=", "self", ".", "logpdf", "\n", "", "else", ":", "\n", "            ", "fun", "=", "self", ".", "pdf", "\n", "\n", "", "with", "np", ".", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "np", ".", "warnings", ".", "filterwarnings", "(", "'ignore'", ")", "\n", "\n", "if", "len", "(", "self", ".", "model", ".", "bounds", ")", "==", "1", ":", "\n", "                ", "mn", "=", "self", ".", "model", ".", "bounds", "[", "0", "]", "[", "0", "]", "\n", "mx", "=", "self", ".", "model", ".", "bounds", "[", "0", "]", "[", "1", "]", "\n", "dx", "=", "(", "mx", "-", "mn", ")", "/", "200.0", "\n", "x", "=", "np", ".", "arange", "(", "mn", ",", "mx", ",", "dx", ")", "\n", "pd", "=", "np", ".", "zeros", "(", "len", "(", "x", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", ":", "\n", "                    ", "pd", "[", "i", "]", "=", "fun", "(", "[", "x", "[", "i", "]", "]", ")", "\n", "", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "plot", "(", "x", ",", "pd", ")", "\n", "plt", ".", "xlim", "(", "mn", ",", "mx", ")", "\n", "plt", ".", "ylim", "(", "min", "(", "pd", ")", "*", "1.05", ",", "max", "(", "pd", ")", "*", "1.05", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "elif", "len", "(", "self", ".", "model", ".", "bounds", ")", "==", "2", ":", "\n", "                ", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "\n", "np", ".", "linspace", "(", "*", "self", ".", "model", ".", "bounds", "[", "0", "]", ")", ",", "np", ".", "linspace", "(", "*", "self", ".", "model", ".", "bounds", "[", "1", "]", ")", ")", "\n", "z", "=", "(", "np", ".", "vectorize", "(", "lambda", "a", ",", "b", ":", "fun", "(", "np", ".", "array", "(", "[", "a", ",", "b", "]", ")", ")", ")", ")", "(", "x", ",", "y", ")", "\n", "plt", ".", "contour", "(", "x", ",", "y", ",", "z", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\"Currently unsupported for dim > 2\"", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment.__init__": [[56, 64], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "_model_kwargs", "=", "kwargs", "\n", "self", ".", "_fitted", "=", "False", "\n", "self", ".", "regression_models", "=", "[", "]", "\n", "self", ".", "_X", "=", "None", "\n", "self", ".", "_sample", "=", "None", "\n", "self", ".", "_parameter_names", "=", "None", "\n", "self", ".", "_finite", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment.parameter_names": [[65, 69], ["post_processing.RegressionAdjustment._check_fitted"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._check_fitted"], ["", "@", "property", "\n", "def", "parameter_names", "(", "self", ")", ":", "\n", "        ", "self", ".", "_check_fitted", "(", ")", "\n", "return", "self", ".", "_parameter_names", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment.sample": [[70, 74], ["post_processing.RegressionAdjustment._check_fitted"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._check_fitted"], ["", "@", "property", "\n", "def", "sample", "(", "self", ")", ":", "\n", "        ", "self", ".", "_check_fitted", "(", ")", "\n", "return", "self", ".", "_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment.X": [[75, 79], ["post_processing.RegressionAdjustment._check_fitted"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._check_fitted"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "self", ".", "_check_fitted", "(", ")", "\n", "return", "self", ".", "_X", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._check_fitted": [[80, 83], ["ValueError"], "methods", ["None"], ["", "def", "_check_fitted", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "_fitted", ":", "\n", "            ", "raise", "ValueError", "(", "\"The regression model must be fitted first. \"", "\"Use the fit() method.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment.fit": [[84, 111], ["post_processing.RegressionAdjustment._input_variables", "post_processing.RegressionAdjustment._get_finite", "post_processing.RegressionAdjustment._pairs", "post_processing.RegressionAdjustment.regression_models.append", "post_processing.RegressionAdjustment._fit1"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.LinearAdjustment._input_variables", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._get_finite", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._pairs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._fit1"], ["", "", "def", "fit", "(", "self", ",", "sample", ",", "model", ",", "summary_names", ",", "parameter_names", "=", "None", ")", ":", "\n", "        ", "\"\"\"Fit a regression adjustment model to the posterior sample.\n\n        Non-finite values in the summary statistics and parameters\n        will be omitted.\n\n        Parameters\n        ----------\n        sample : elfi.methods.Sample\n          a sample object from an ABC method\n        model : elfi.ElfiModel\n          the inference model\n        summary_names : list[str]\n          a list of names for the summary nodes\n        parameter_names : list[str] (optional)\n          a list of parameter names\n\n        \"\"\"", "\n", "self", ".", "_X", "=", "self", ".", "_input_variables", "(", "model", ",", "sample", ",", "summary_names", ")", "\n", "self", ".", "_sample", "=", "sample", "\n", "self", ".", "_parameter_names", "=", "parameter_names", "or", "sample", ".", "parameter_names", "\n", "self", ".", "_get_finite", "(", ")", "\n", "\n", "for", "pair", "in", "self", ".", "_pairs", "(", ")", ":", "\n", "            ", "self", ".", "regression_models", ".", "append", "(", "self", ".", "_fit1", "(", "*", "pair", ")", ")", "\n", "\n", "", "self", ".", "_fitted", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._fit1": [[112, 114], ["post_processing.RegressionAdjustment._regression_model().fit", "post_processing.RegressionAdjustment._regression_model"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.fit"], ["", "def", "_fit1", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "return", "self", ".", "_regression_model", "(", "**", "self", ".", "_model_kwargs", ")", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._pairs": [[115, 121], ["enumerate"], "methods", ["None"], ["", "def", "_pairs", "(", "self", ")", ":", "\n", "# TODO: Access the variables through the getters", "\n", "        ", "for", "(", "i", ",", "name", ")", "in", "enumerate", "(", "self", ".", "_parameter_names", ")", ":", "\n", "            ", "X", "=", "self", ".", "_X", "[", "self", ".", "_finite", "[", "i", "]", ",", ":", "]", "\n", "p", "=", "self", ".", "_sample", ".", "outputs", "[", "name", "]", "[", "self", ".", "_finite", "[", "i", "]", "]", "\n", "yield", "X", ",", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment.adjust": [[122, 142], ["enumerate", "results.Sample", "post_processing.RegressionAdjustment._adjust"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.LinearAdjustment._adjust"], ["", "", "def", "adjust", "(", "self", ")", ":", "\n", "        ", "\"\"\"Adjust the posterior.\n\n        Only the non-finite values used to fit the regression model\n        will be adjusted.\n\n        Returns\n        -------\n          a Sample object containing the adjusted posterior\n\n        \"\"\"", "\n", "outputs", "=", "{", "}", "\n", "for", "(", "i", ",", "name", ")", "in", "enumerate", "(", "self", ".", "parameter_names", ")", ":", "\n", "            ", "theta_i", "=", "self", ".", "sample", ".", "outputs", "[", "name", "]", "[", "self", ".", "_finite", "[", "i", "]", "]", "\n", "adjusted", "=", "self", ".", "_adjust", "(", "i", ",", "theta_i", ",", "self", ".", "regression_models", "[", "i", "]", ")", "\n", "outputs", "[", "name", "]", "=", "adjusted", "\n", "\n", "", "res", "=", "results", ".", "Sample", "(", "\n", "method_name", "=", "self", ".", "_name", ",", "outputs", "=", "outputs", ",", "parameter_names", "=", "self", ".", "_parameter_names", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._adjust": [[143, 162], ["None"], "methods", ["None"], ["", "def", "_adjust", "(", "self", ",", "i", ",", "theta_i", ",", "regression_model", ")", ":", "\n", "        ", "\"\"\"Adjust a single parameter using a fitted regression model.\n\n        Parameters\n        ----------\n        i : int\n          the index of the parameter\n        theta_i : np.ndarray\n          a vector of parameter values to adjust\n        regression_model\n          a fitted regression model\n\n        Returns\n        -------\n        adjusted_theta_i : np.ndarray\n          an adjusted version of the parameter values\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._input_variables": [[163, 182], ["None"], "methods", ["None"], ["", "def", "_input_variables", "(", "self", ",", "model", ",", "sample", ",", "summary_names", ")", ":", "\n", "        ", "\"\"\"Construct a matrix of regressors.\n\n        Parameters\n        ----------\n        model : elfi.ElfiModel\n          the inference model\n        sample\n          a sample object from an ABC algorithm\n        summary_names : list[str]\n          names of the summary nodes\n\n        Returns\n        -------\n        X\n          a numpy array of regressors\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment._get_finite": [[183, 193], ["numpy.isfinite().all", "all", "map", "warnings.warn", "numpy.isfinite", "numpy.isfinite", "all"], "methods", ["None"], ["", "def", "_get_finite", "(", "self", ")", ":", "\n", "# TODO: Access the variables through the getters", "\n", "        ", "finite_inputs", "=", "np", ".", "isfinite", "(", "self", ".", "_X", ")", ".", "all", "(", "axis", "=", "1", ")", "\n", "finite", "=", "[", "\n", "finite_inputs", "&", "np", ".", "isfinite", "(", "self", ".", "_sample", ".", "outputs", "[", "p", "]", ")", "for", "p", "in", "self", ".", "_parameter_names", "\n", "]", "\n", "all_finite", "=", "all", "(", "map", "(", "all", ",", "finite", ")", ")", "\n", "self", ".", "_finite", "=", "finite", "\n", "if", "not", "(", "all", "(", "finite_inputs", ")", "and", "all_finite", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "\"Non-finite inputs and outputs will be omitted.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.LinearAdjustment._adjust": [[201, 204], ["post_processing.LinearAdjustment.X[].dot"], "methods", ["None"], ["def", "_adjust", "(", "self", ",", "i", ",", "theta_i", ",", "regression_model", ")", ":", "\n", "        ", "b", "=", "regression_model", ".", "coef_", "\n", "return", "theta_i", "-", "self", ".", "X", "[", "self", ".", "_finite", "[", "i", "]", ",", ":", "]", ".", "dot", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.LinearAdjustment._input_variables": [[205, 210], ["numpy.stack", "numpy.stack"], "methods", ["None"], ["", "def", "_input_variables", "(", "self", ",", "model", ",", "sample", ",", "summary_names", ")", ":", "\n", "        ", "\"\"\"Regress on the differences to the observed summaries.\"\"\"", "\n", "observed_summaries", "=", "np", ".", "stack", "(", "[", "model", "[", "s", "]", ".", "observed", "for", "s", "in", "summary_names", "]", ",", "axis", "=", "1", ")", "\n", "summaries", "=", "np", ".", "stack", "(", "[", "sample", ".", "outputs", "[", "name", "]", "for", "name", "in", "summary_names", "]", ",", "axis", "=", "1", ")", "\n", "return", "summaries", "-", "observed_summaries", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.adjust_posterior": [[212, 253], ["post_processing._get_adjustment", "_get_adjustment.fit", "_get_adjustment.adjust"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing._get_adjustment", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.fit", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing.RegressionAdjustment.adjust"], ["", "", "def", "adjust_posterior", "(", "sample", ",", "model", ",", "summary_names", ",", "parameter_names", "=", "None", ",", "adjustment", "=", "'linear'", ")", ":", "\n", "    ", "\"\"\"Adjust the posterior using local regression.\n\n    Note that the summary nodes need to be explicitly included to the\n    sample object with the `output_names` keyword argument when performing\n    the inference.\n\n    Parameters\n    ----------\n    sample : elfi.methods.results.Sample\n      a sample object from an ABC algorithm\n    model : elfi.ElfiModel\n      the inference model\n    summary_names : list[str]\n      names of the summary nodes\n    parameter_names : list[str] (optional)\n      names of the parameters\n    adjustment : RegressionAdjustment or string\n      a regression adjustment object or a string specification\n\n      Accepted values for the string specification:\n       - 'linear'\n\n    Returns\n    -------\n    elfi.methods.results.Sample\n      a Sample object with the adjusted posterior\n\n    Examples\n    --------\n    import elfi\n    from elfi.examples import gauss\n    m = gauss.get_model()\n    res = elfi.Rejection(m['d'], output_names=['ss_mean', 'ss_var']).sample(1000)\n    adj = adjust_posterior(res, m, ['ss_mean', 'ss_var'], ['mu'], LinearAdjustment())\n\n    \"\"\"", "\n", "adjustment", "=", "_get_adjustment", "(", "adjustment", ")", "\n", "adjustment", ".", "fit", "(", "\n", "model", "=", "model", ",", "sample", "=", "sample", ",", "parameter_names", "=", "parameter_names", ",", "summary_names", "=", "summary_names", ")", "\n", "return", "adjustment", ".", "adjust", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.post_processing._get_adjustment": [[255, 265], ["isinstance", "isinstance", "adjustments.get", "ValueError"], "function", ["None"], ["", "def", "_get_adjustment", "(", "adjustment", ")", ":", "\n", "    ", "adjustments", "=", "{", "'linear'", ":", "LinearAdjustment", "}", "\n", "\n", "if", "isinstance", "(", "adjustment", ",", "RegressionAdjustment", ")", ":", "\n", "        ", "return", "adjustment", "\n", "", "elif", "isinstance", "(", "adjustment", ",", "str", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "adjustments", ".", "get", "(", "adjustment", ",", "None", ")", "(", ")", "\n", "", "except", "TypeError", ":", "\n", "            ", "raise", "ValueError", "(", "\"Could not find \"", "\"adjustment method:{}\"", ".", "format", "(", "adjustment", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.eff_sample_size": [[13, 64], ["numpy.atleast_2d", "numpy.mean", "numpy.var", "numpy.mean", "int", "numpy.fft.rfft", "numpy.arange", "numpy.var", "numpy.ceil", "numpy.fft.irfft", "numpy.log2", "numpy.abs", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.var", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.var", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["def", "eff_sample_size", "(", "chains", ")", ":", "\n", "    ", "\"\"\"Calculate the effective sample size for 1 or more chains.\n\n    See:\n\n    Gelman, Carlin, Stern, Dunson, Vehtari, Rubin: Bayesian Data Analysis, 2013.\n\n    Stan modeling language user's guide and reference manual, v. 2.14.0.\n\n    Parameters\n    ----------\n    chains : np.array of shape (N,) or (M, N)\n        Samples of a parameter from an MCMC algorithm. No burn-in subtracted here!\n\n    Returns\n    -------\n    ess : float\n\n    \"\"\"", "\n", "chains", "=", "np", ".", "atleast_2d", "(", "chains", ")", "\n", "n_chains", ",", "n_samples", "=", "chains", ".", "shape", "\n", "means", "=", "np", ".", "mean", "(", "chains", ",", "axis", "=", "1", ")", "\n", "variances", "=", "np", ".", "var", "(", "chains", ",", "ddof", "=", "1", ",", "axis", "=", "1", ")", "\n", "\n", "var_between", "=", "0", "if", "n_chains", "==", "1", "else", "n_samples", "*", "np", ".", "var", "(", "means", ",", "ddof", "=", "1", ")", "\n", "var_within", "=", "np", ".", "mean", "(", "variances", ")", "\n", "var_pooled", "=", "(", "(", "n_samples", "-", "1.", ")", "*", "var_within", "+", "var_between", ")", "/", "n_samples", "\n", "\n", "# autocovariances for lags 1..n_samples", "\n", "# https://en.wikipedia.org/wiki/Autocorrelation#Estimation", "\n", "n_padded", "=", "int", "(", "2", "**", "np", ".", "ceil", "(", "1", "+", "np", ".", "log2", "(", "n_samples", ")", ")", ")", "\n", "freqs", "=", "np", ".", "fft", ".", "rfft", "(", "chains", "-", "means", "[", ":", ",", "None", "]", ",", "n_padded", ")", "\n", "autocov", "=", "np", ".", "fft", ".", "irfft", "(", "np", ".", "abs", "(", "freqs", ")", "**", "2", ")", "[", ":", ",", ":", "n_samples", "]", ".", "real", "\n", "autocov", "=", "autocov", "/", "np", ".", "arange", "(", "n_samples", ",", "0", ",", "-", "1", ")", "\n", "\n", "estimator_sum", "=", "0.", "\n", "lag", "=", "1", "\n", "while", "lag", "<", "n_samples", ":", "\n", "# estimate multi-chain autocorrelation using variogram", "\n", "        ", "temp", "=", "1.", "-", "(", "var_within", "-", "np", ".", "mean", "(", "autocov", "[", ":", ",", "lag", "]", ")", ")", "/", "var_pooled", "\n", "\n", "# only use the first non-negative autocorrelations to avoid noise", "\n", "if", "temp", ">=", "0", ":", "\n", "            ", "estimator_sum", "+=", "temp", "\n", "lag", "+=", "1", "\n", "", "else", ":", "\n", "            ", "break", "\n", "\n", "", "", "ess", "=", "n_chains", "*", "n_samples", "/", "(", "1.", "+", "2.", "*", "estimator_sum", ")", "\n", "\n", "return", "ess", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.gelman_rubin": [[66, 112], ["numpy.atleast_2d", "chains[].reshape", "numpy.mean", "numpy.var", "numpy.mean", "numpy.sqrt", "numpy.var"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.var", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.var"], ["", "def", "gelman_rubin", "(", "chains", ")", ":", "\n", "    ", "r\"\"\"Calculate the Gelman--Rubin convergence statistic.\n\n    Also known as the potential scale reduction factor, or \\hat{R}.\n    Uses the split version, as in Stan.\n\n    See:\n\n    Gelman, Carlin, Stern, Dunson, Vehtari, Rubin: Bayesian Data Analysis, 2013.\n\n    Gelman, A. and D. B. Rubin: Inference from iterative simulation using\n    multiple sequences (with discussion). Statistical Science, 7:457-511, 1992.\n\n    Stan modeling language user's guide and reference manual, v. 2.14.0.\n\n    Parameters\n    ----------\n    chains : np.array of shape (M, N)\n        Samples of a parameter from an MCMC algorithm, 1 row per chain. No burn-in subtracted here!\n\n    Returns\n    -------\n    psrf : float\n        Should be below 1.1 to support convergence, or at least below 1.2 for all parameters.\n\n    \"\"\"", "\n", "chains", "=", "np", ".", "atleast_2d", "(", "chains", ")", "\n", "n_chains", ",", "n_samples", "=", "chains", ".", "shape", "\n", "\n", "# split chains in the middle", "\n", "n_chains", "*=", "2", "\n", "n_samples", "//=", "2", "# drop 1 if odd", "\n", "chains", "=", "chains", "[", ":", ",", ":", "2", "*", "n_samples", "]", ".", "reshape", "(", "(", "n_chains", ",", "n_samples", ")", ")", "\n", "\n", "means", "=", "np", ".", "mean", "(", "chains", ",", "axis", "=", "1", ")", "\n", "variances", "=", "np", ".", "var", "(", "chains", ",", "ddof", "=", "1", ",", "axis", "=", "1", ")", "\n", "\n", "var_between", "=", "n_samples", "*", "np", ".", "var", "(", "means", ",", "ddof", "=", "1", ")", "\n", "var_within", "=", "np", ".", "mean", "(", "variances", ")", "\n", "\n", "var_pooled", "=", "(", "(", "n_samples", "-", "1.", ")", "*", "var_within", "+", "var_between", ")", "/", "n_samples", "\n", "\n", "# potential scale reduction factor, should be close to 1", "\n", "psrf", "=", "np", ".", "sqrt", "(", "var_pooled", "/", "var_within", ")", "\n", "\n", "return", "psrf", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.nuts": [[114, 311], ["numpy.random.RandomState", "logger.info", "target", "numpy.isinf", "logger.debug", "numpy.log", "numpy.empty", "range", "logger.info", "ValueError", "grad_target", "logger.debug", "np.random.RandomState.randn", "logger.warning", "numpy.exp", "np.random.RandomState.randn", "numpy.isfinite", "target", "np.random.RandomState.exponential", "numpy.exp", "logger.info", "float", "grad_target", "target", "logger.debug", "numpy.exp", "numpy.exp", "SystemExit", "grad_target", "target", "random_state.randn.dot", "mcmc._build_tree_nuts", "mcmc._build_tree_nuts", "logger.debug", "numpy.exp", "logger.info", "logger.debug", "random_state.randn.dot", "momentum1.dot", "ValueError", "momentum1.dot", "np.random.RandomState.rand", "np.random.RandomState.rand", "float", "numpy.sqrt", "float"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc._build_tree_nuts", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc._build_tree_nuts"], ["", "def", "nuts", "(", "n_iter", ",", "\n", "params0", ",", "\n", "target", ",", "\n", "grad_target", ",", "\n", "n_adapt", "=", "None", ",", "\n", "target_prob", "=", "0.6", ",", "\n", "max_depth", "=", "5", ",", "\n", "seed", "=", "0", ",", "\n", "info_freq", "=", "100", ",", "\n", "max_retry_inits", "=", "20", ",", "\n", "stepsize", "=", "None", ")", ":", "\n", "    ", "r\"\"\"Sample the target using the NUTS algorithm.\n\n    No-U-Turn Sampler, an improved version of the Hamiltonian (Markov Chain) Monte Carlo sampler.\n\n    Based on Algorithm 6 in\n    Hoffman & Gelman, depthMLR 15, 1351-1381, 2014.\n\n    Parameters\n    ----------\n    n_iter : int\n        The number of iterations, including n_adapt and possible other warmup iterations.\n    params0 : np.array\n        Initial values for sampled parameters.\n    target : function\n        The target's log density to sample (possibly unnormalized).\n    grad_target : function\n        The gradient of target.\n    n_adapt : int, optional\n        The number of automatic adjustments to stepsize. Defaults to n_iter/2.\n    target_prob : float, optional\n        Desired average acceptance probability. (Parameter \\delta in the original paper.)\n    max_depth : int, optional\n        Maximum recursion depth.\n    seed : int, optional\n        Seed for pseudo-random number generator.\n    info_freq : int, optional\n        How often to log progress to loglevel INFO.\n    max_retry_inits : int, optional\n        How many times to retry finding initial stepsize (if stepped outside allowed region).\n    stepsize : float, optional\n        Initial stepsize (will be still adapted). Defaults to finding by trial and error.\n\n    Returns\n    -------\n    samples : np.array\n        Samples from the MCMC algorithm, including those during adaptation.\n\n    \"\"\"", "\n", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "n_adapt", "=", "n_adapt", "if", "n_adapt", "is", "not", "None", "else", "n_iter", "//", "2", "\n", "\n", "logger", ".", "info", "(", "\"NUTS: Performing {} iterations with {} adaptation steps.\"", ".", "format", "(", "n_iter", ",", "n_adapt", ")", ")", "\n", "\n", "target0", "=", "target", "(", "params0", ")", "\n", "if", "np", ".", "isinf", "(", "target0", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"NUTS: Bad initialization point {}, logpdf -> -inf.\"", ".", "format", "(", "params0", ")", ")", "\n", "\n", "# ********************************", "\n", "# Find reasonable initial stepsize", "\n", "# ********************************", "\n", "", "if", "stepsize", "is", "None", ":", "\n", "        ", "grad0", "=", "grad_target", "(", "params0", ")", "\n", "logger", ".", "debug", "(", "\"NUTS: Trying to find initial stepsize from point {} with gradient {}.\"", ".", "\n", "format", "(", "params0", ",", "grad0", ")", ")", "\n", "init_tries", "=", "0", "\n", "while", "init_tries", "<", "max_retry_inits", ":", "# might step into region unallowed by priors", "\n", "            ", "stepsize", "=", "np", ".", "exp", "(", "-", "init_tries", ")", "\n", "init_tries", "+=", "1", "\n", "momentum0", "=", "random_state", ".", "randn", "(", "*", "params0", ".", "shape", ")", "\n", "\n", "# leapfrog", "\n", "momentum1", "=", "momentum0", "+", "0.5", "*", "stepsize", "*", "grad0", "\n", "params1", "=", "params0", "+", "stepsize", "*", "momentum1", "\n", "momentum1", "+=", "0.5", "*", "stepsize", "*", "grad_target", "(", "params1", ")", "\n", "\n", "joint0", "=", "target0", "-", "0.5", "*", "momentum0", ".", "dot", "(", "momentum0", ")", "\n", "joint1", "=", "target", "(", "params1", ")", "-", "0.5", "*", "momentum1", ".", "dot", "(", "momentum1", ")", "\n", "\n", "if", "np", ".", "isfinite", "(", "joint1", ")", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "if", "init_tries", "==", "max_retry_inits", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"NUTS: Cannot find acceptable stepsize starting from point {}. All \"", "\n", "\"trials ended in region with 0 probability.\"", ".", "format", "(", "params0", ")", ")", "\n", "# logger.debug(\"momentum0 {}, momentum1 {}, params1 {}, joint0 {}, joint1 {}\"", "\n", "#              .format(momentum0, momentum1, params1, joint0, joint1))", "\n", "", "logger", ".", "debug", "(", "\"NUTS: Problem finding acceptable stepsize, now {}. Retrying {}/{}.\"", "\n", ".", "format", "(", "stepsize", ",", "init_tries", ",", "max_retry_inits", ")", ")", "\n", "\n", "", "", "plusminus", "=", "1", "if", "np", ".", "exp", "(", "joint1", "-", "joint0", ")", ">", "0.5", "else", "-", "1", "\n", "factor", "=", "2.", "if", "plusminus", "==", "1", "else", "0.5", "\n", "while", "factor", "*", "np", ".", "exp", "(", "plusminus", "*", "(", "joint1", "-", "joint0", ")", ")", ">", "1.", ":", "\n", "            ", "stepsize", "*=", "factor", "\n", "if", "stepsize", "==", "0.", "or", "stepsize", ">", "1e7", ":", "# bounds as in STAN", "\n", "                ", "raise", "SystemExit", "(", "\"NUTS: Found invalid stepsize {} starting from point {}.\"", "\n", ".", "format", "(", "stepsize", ",", "params0", ")", ")", "\n", "\n", "# leapfrog", "\n", "", "momentum1", "=", "momentum0", "+", "0.5", "*", "stepsize", "*", "grad0", "\n", "params1", "=", "params0", "+", "stepsize", "*", "momentum1", "\n", "momentum1", "+=", "0.5", "*", "stepsize", "*", "grad_target", "(", "params1", ")", "\n", "\n", "joint1", "=", "target", "(", "params1", ")", "-", "0.5", "*", "momentum1", ".", "dot", "(", "momentum1", ")", "\n", "\n", "", "", "logger", ".", "debug", "(", "\"NUTS: Set initial stepsize {}.\"", ".", "format", "(", "stepsize", ")", ")", "\n", "\n", "# Some parameters from the NUTS paper, used for adapting the stepsize", "\n", "target_stepsize", "=", "np", ".", "log", "(", "10.", "*", "stepsize", ")", "\n", "log_avg_stepsize", "=", "0.", "\n", "accept_ratio", "=", "0.", "# tends to target_prob", "\n", "shrinkage", "=", "0.05", "# controls shrinkage accept_ratio to target_prob", "\n", "ii_offset", "=", "10.", "# stabilizes initialization", "\n", "discount", "=", "-", "0.75", "# reduce weight of past", "\n", "\n", "# ********", "\n", "# Sampling", "\n", "# ********", "\n", "samples", "=", "np", ".", "empty", "(", "(", "n_iter", "+", "1", ",", ")", "+", "params0", ".", "shape", ")", "\n", "samples", "[", "0", ",", ":", "]", "=", "params0", "\n", "n_diverged", "=", "0", "# counter for proposals whose error diverged", "\n", "n_outside", "=", "0", "# counter for proposals outside priors (pdf=0)", "\n", "n_total", "=", "0", "# total number of proposals", "\n", "\n", "for", "ii", "in", "range", "(", "1", ",", "n_iter", "+", "1", ")", ":", "\n", "        ", "momentum0", "=", "random_state", ".", "randn", "(", "*", "params0", ".", "shape", ")", "\n", "samples_prev", "=", "samples", "[", "ii", "-", "1", ",", ":", "]", "\n", "log_joint0", "=", "target", "(", "samples_prev", ")", "-", "0.5", "*", "momentum0", ".", "dot", "(", "momentum0", ")", "\n", "log_slicevar", "=", "log_joint0", "-", "random_state", ".", "exponential", "(", ")", "\n", "samples", "[", "ii", ",", ":", "]", "=", "samples_prev", "\n", "params_left", "=", "samples_prev", "\n", "params_right", "=", "samples_prev", "\n", "momentum_left", "=", "momentum0", "\n", "momentum_right", "=", "momentum0", "\n", "depth", "=", "0", "\n", "n_ok", "=", "1", "\n", "all_ok", "=", "True", "# criteria for no U-turn, diverging error", "\n", "\n", "while", "all_ok", "and", "depth", "<=", "max_depth", ":", "\n", "            ", "direction", "=", "1", "if", "random_state", ".", "rand", "(", ")", "<", "0.5", "else", "-", "1", "\n", "if", "direction", "==", "-", "1", ":", "\n", "                ", "params_left", ",", "momentum_left", ",", "_", ",", "_", ",", "params1", ",", "n_sub", ",", "sub_ok", ",", "mh_ratio", ",", "n_steps", ",", "is_div", ",", "is_out", "=", "_build_tree_nuts", "(", "\n", "params_left", ",", "momentum_left", ",", "log_slicevar", ",", "-", "stepsize", ",", "depth", ",", "log_joint0", ",", "\n", "target", ",", "grad_target", ",", "random_state", ")", "\n", "", "else", ":", "\n", "                ", "_", ",", "_", ",", "params_right", ",", "momentum_right", ",", "params1", ",", "n_sub", ",", "sub_ok", ",", "mh_ratio", ",", "n_steps", ",", "is_div", ",", "is_out", "=", "_build_tree_nuts", "(", "\n", "params_right", ",", "momentum_right", ",", "log_slicevar", ",", "stepsize", ",", "depth", ",", "log_joint0", ",", "\n", "target", ",", "grad_target", ",", "random_state", ")", "\n", "\n", "", "if", "sub_ok", "==", "1", ":", "\n", "                ", "if", "random_state", ".", "rand", "(", ")", "<", "float", "(", "n_sub", ")", "/", "n_ok", ":", "\n", "                    ", "samples", "[", "ii", ",", ":", "]", "=", "params1", "# accept proposal", "\n", "", "", "n_ok", "+=", "n_sub", "\n", "if", "not", "is_out", ":", "# params1 outside allowed region; don't count this as diverging error", "\n", "                ", "n_diverged", "+=", "is_div", "\n", "", "n_outside", "+=", "is_out", "\n", "n_total", "+=", "n_steps", "\n", "all_ok", "=", "sub_ok", "and", "(", "(", "params_right", "-", "params_left", ")", ".", "dot", "(", "momentum_left", ")", ">=", "0", ")", "and", "(", "(", "params_right", "-", "params_left", ")", ".", "dot", "(", "momentum_right", ")", ">=", "0", ")", "\n", "depth", "+=", "1", "\n", "if", "depth", ">", "max_depth", ":", "\n", "                ", "logger", ".", "debug", "(", "\"NUTS: Maximum recursion depth {} exceeded.\"", ".", "format", "(", "max_depth", ")", ")", "\n", "\n", "# adjust stepsize according to target acceptance ratio", "\n", "", "", "if", "ii", "<=", "n_adapt", ":", "\n", "            ", "accept_ratio", "=", "(", "1.", "-", "1.", "/", "(", "ii", "+", "ii_offset", ")", ")", "*", "accept_ratio", "+", "(", "target_prob", "-", "float", "(", "mh_ratio", ")", "/", "n_steps", ")", "/", "(", "ii", "+", "ii_offset", ")", "\n", "log_stepsize", "=", "target_stepsize", "-", "np", ".", "sqrt", "(", "ii", ")", "/", "shrinkage", "*", "accept_ratio", "\n", "log_avg_stepsize", "=", "ii", "**", "discount", "*", "log_stepsize", "+", "(", "1.", "-", "ii", "**", "discount", ")", "*", "log_avg_stepsize", "\n", "stepsize", "=", "np", ".", "exp", "(", "log_stepsize", ")", "\n", "\n", "", "elif", "ii", "==", "n_adapt", "+", "1", ":", "# adaptation/warmup finished", "\n", "            ", "stepsize", "=", "np", ".", "exp", "(", "log_avg_stepsize", ")", "# final stepsize", "\n", "n_diverged", "=", "0", "\n", "n_outside", "=", "0", "\n", "n_total", "=", "0", "\n", "logger", ".", "info", "(", "\"NUTS: Adaptation/warmup finished. Sampling...\"", ")", "\n", "logger", ".", "debug", "(", "\"NUTS: Set final stepsize {}.\"", ".", "format", "(", "stepsize", ")", ")", "\n", "\n", "", "if", "ii", "%", "info_freq", "==", "0", "and", "ii", "<", "n_iter", ":", "\n", "            ", "logger", ".", "info", "(", "\"NUTS: Iterations performed: {}/{}...\"", ".", "format", "(", "ii", ",", "n_iter", ")", ")", "\n", "\n", "", "", "info_str", "=", "\"NUTS: Acceptance ratio: {:.3f}\"", ".", "format", "(", "float", "(", "n_iter", "-", "n_adapt", ")", "/", "n_total", ")", "\n", "if", "n_outside", ">", "0", ":", "\n", "        ", "info_str", "+=", "\". After warmup {} proposals were outside of the region allowed by priors \"", "\"and rejected, decreasing acceptance ratio.\"", ".", "format", "(", "n_outside", ")", "\n", "", "logger", ".", "info", "(", "info_str", ")", "\n", "\n", "if", "n_diverged", ">", "0", ":", "\n", "        ", "logger", ".", "warning", "(", "\"NUTS: Diverged proposals after warmup (i.e. n_adapt={} steps): {}\"", ".", "format", "(", "\n", "n_adapt", ",", "n_diverged", ")", ")", "\n", "\n", "", "return", "samples", "[", "1", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc._build_tree_nuts": [[313, 375], ["float", "mcmc._build_tree_nuts", "target", "numpy.isinf", "min", "grad_target", "grad_target", "momentum1.dot", "target", "logger.debug", "numpy.exp", "mcmc._build_tree_nuts", "mcmc._build_tree_nuts", "random_state.rand", "float"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc._build_tree_nuts", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc._build_tree_nuts", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc._build_tree_nuts"], ["", "def", "_build_tree_nuts", "(", "params", ",", "momentum", ",", "log_slicevar", ",", "step", ",", "depth", ",", "log_joint0", ",", "target", ",", "grad_target", ",", "\n", "random_state", ")", ":", "\n", "    ", "\"\"\"Recursively build a balanced binary tree needed by NUTS.\n\n    Based on Algorithm 6 in\n    Hoffman & Gelman, JMLR 15, 1351-1381, 2014.\n\n    \"\"\"", "\n", "# Base case: one leapfrog step", "\n", "if", "depth", "==", "0", ":", "\n", "        ", "momentum1", "=", "momentum", "+", "0.5", "*", "step", "*", "grad_target", "(", "params", ")", "\n", "params1", "=", "params", "+", "step", "*", "momentum1", "\n", "momentum1", "=", "momentum1", "+", "0.5", "*", "step", "*", "grad_target", "(", "params1", ")", "\n", "\n", "log_joint", "=", "target", "(", "params1", ")", "-", "0.5", "*", "momentum1", ".", "dot", "(", "momentum1", ")", "\n", "n_ok", "=", "float", "(", "log_slicevar", "<=", "log_joint", ")", "\n", "sub_ok", "=", "log_slicevar", "<", "(", "1000.", "+", "log_joint", ")", "# check for diverging error", "\n", "is_out", "=", "False", "\n", "if", "not", "sub_ok", ":", "\n", "            ", "if", "np", ".", "isinf", "(", "target", "(", "params1", ")", ")", ":", "# logpdf(params1) = -inf i.e. pdf(params1) = 0", "\n", "                ", "is_out", "=", "True", "\n", "", "else", ":", "\n", "                ", "logger", ".", "debug", "(", "\n", "\"NUTS: Diverging error: log_joint={}, params={}, params1={}, momentum={}, \"", "\n", "\"momentum1={}.\"", ".", "format", "(", "log_joint", ",", "params", ",", "params1", ",", "momentum", ",", "momentum1", ")", ")", "\n", "", "mh_ratio", "=", "0.", "# reject", "\n", "", "else", ":", "\n", "            ", "mh_ratio", "=", "min", "(", "1.", ",", "np", ".", "exp", "(", "log_joint", "-", "log_joint0", ")", ")", "\n", "\n", "", "return", "params1", ",", "momentum1", ",", "params1", ",", "momentum1", ",", "params1", ",", "n_ok", ",", "sub_ok", ",", "mh_ratio", ",", "1.", ",", "not", "sub_ok", ",", "is_out", "\n", "\n", "", "else", ":", "\n", "# Recursion to build subtrees, doubling size", "\n", "        ", "params_left", ",", "momentum_left", ",", "params_right", ",", "momentum_right", ",", "params1", ",", "n_sub", ",", "sub_ok", ",", "mh_ratio", ",", "n_steps", ",", "is_div", ",", "is_out", "=", "_build_tree_nuts", "(", "\n", "params", ",", "momentum", ",", "log_slicevar", ",", "step", ",", "depth", "-", "1", ",", "log_joint0", ",", "target", ",", "\n", "grad_target", ",", "random_state", ")", "\n", "\n", "if", "sub_ok", ":", "# recurse further", "\n", "            ", "if", "step", "<", "0", ":", "\n", "                ", "params_left", ",", "momentum_left", ",", "_", ",", "_", ",", "params2", ",", "n_sub2", ",", "sub_ok", ",", "mh_ratio2", ",", "n_steps2", ",", "is_div", ",", "is_out", "=", "_build_tree_nuts", "(", "\n", "params_left", ",", "momentum_left", ",", "log_slicevar", ",", "\n", "step", ",", "depth", "-", "1", ",", "log_joint0", ",", "target", ",", "grad_target", ",", "random_state", ")", "\n", "", "else", ":", "\n", "                ", "_", ",", "_", ",", "params_right", ",", "momentum_right", ",", "params2", ",", "n_sub2", ",", "sub_ok", ",", "mh_ratio2", ",", "n_steps2", ",", "is_div", ",", "is_out", "=", "_build_tree_nuts", "(", "\n", "params_right", ",", "momentum_right", ",", "log_slicevar", ",", "\n", "step", ",", "depth", "-", "1", ",", "log_joint0", ",", "target", ",", "grad_target", ",", "random_state", ")", "\n", "\n", "", "if", "n_sub2", ">", "0", ":", "\n", "                ", "if", "float", "(", "n_sub2", ")", "/", "(", "n_sub", "+", "n_sub2", ")", ">", "random_state", ".", "rand", "(", ")", ":", "\n", "                    ", "params1", "=", "params2", "# accept move", "\n", "", "", "mh_ratio", "+=", "mh_ratio2", "\n", "n_steps", "+=", "n_steps2", "\n", "sub_ok", "=", "sub_ok", "and", "(", "(", "params_right", "-", "params_left", ")", ".", "dot", "(", "momentum_left", ")", ">=", "0", ")", "and", "(", "(", "params_right", "-", "params_left", ")", ".", "dot", "(", "momentum_right", ")", ">=", "0", ")", "\n", "n_sub", "+=", "n_sub2", "\n", "\n", "", "return", "params_left", ",", "momentum_left", ",", "params_right", ",", "momentum_right", ",", "params1", ",", "n_sub", ",", "sub_ok", ",", "mh_ratio", ",", "n_steps", ",", "is_div", ",", "is_out", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.metropolis": [[377, 428], ["numpy.random.RandomState", "numpy.empty", "target", "numpy.isinf", "range", "logger.info", "ValueError", "target", "numpy.isinf", "numpy.isnan", "np.random.RandomState.randn", "numpy.exp", "np.random.RandomState.rand", "float"], "function", ["None"], ["", "", "def", "metropolis", "(", "n_samples", ",", "params0", ",", "target", ",", "sigma_proposals", ",", "warmup", "=", "0", ",", "seed", "=", "0", ")", ":", "\n", "    ", "\"\"\"Sample the target with a Metropolis Markov Chain Monte Carlo using Gaussian proposals.\n\n    Parameters\n    ----------\n    n_samples : int\n        The number of requested samples.\n    params0 : np.array\n        Initial values for each sampled parameter.\n    target : function\n        The target log density to sample (possibly unnormalized).\n    sigma_proposals : np.array\n        Standard deviations for Gaussian proposals of each parameter.\n    warmup : int\n        Number of warmup samples.\n    seed : int, optional\n        Seed for pseudo-random number generator.\n\n    Returns\n    -------\n    samples : np.array\n\n    \"\"\"", "\n", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "\n", "samples", "=", "np", ".", "empty", "(", "(", "n_samples", "+", "warmup", "+", "1", ",", ")", "+", "params0", ".", "shape", ")", "\n", "samples", "[", "0", ",", ":", "]", "=", "params0", "\n", "target_current", "=", "target", "(", "params0", ")", "\n", "if", "np", ".", "isinf", "(", "target_current", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Metropolis: Bad initialization point {},logpdf -> -inf.\"", ".", "format", "(", "params0", ")", ")", "\n", "\n", "", "n_accepted", "=", "0", "\n", "\n", "for", "ii", "in", "range", "(", "1", ",", "n_samples", "+", "warmup", "+", "1", ")", ":", "\n", "        ", "samples", "[", "ii", ",", ":", "]", "=", "samples", "[", "ii", "-", "1", ",", ":", "]", "+", "sigma_proposals", "*", "random_state", ".", "randn", "(", "*", "params0", ".", "shape", ")", "\n", "target_prev", "=", "target_current", "\n", "target_current", "=", "target", "(", "samples", "[", "ii", ",", ":", "]", ")", "\n", "if", "(", "(", "np", ".", "exp", "(", "target_current", "-", "target_prev", ")", "<", "random_state", ".", "rand", "(", ")", ")", "\n", "or", "np", ".", "isinf", "(", "target_current", ")", "\n", "or", "np", ".", "isnan", "(", "target_current", ")", ")", ":", "# reject proposal", "\n", "            ", "samples", "[", "ii", ",", ":", "]", "=", "samples", "[", "ii", "-", "1", ",", ":", "]", "\n", "target_current", "=", "target_prev", "\n", "", "else", ":", "\n", "            ", "n_accepted", "+=", "1", "\n", "\n", "", "", "logger", ".", "info", "(", "\n", "\"{}: Total acceptance ratio: {:.3f}\"", ".", "format", "(", "__name__", ",", "\n", "float", "(", "n_accepted", ")", "/", "(", "n_samples", "+", "warmup", ")", ")", ")", "\n", "\n", "return", "samples", "[", "(", "1", "+", "warmup", ")", ":", ",", ":", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.ParameterInferenceResult.__init__": [[23, 42], ["outputs.copy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["def", "__init__", "(", "self", ",", "method_name", ",", "outputs", ",", "parameter_names", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize result.\n\n        Parameters\n        ----------\n        method_name : string\n            Name of inference method.\n        outputs : dict\n            Dictionary with outputs from the nodes, e.g. samples.\n        parameter_names : list\n            Names of the parameter nodes\n        **kwargs\n            Any other information from the inference algorithm, usually from it's state.\n\n        \"\"\"", "\n", "self", ".", "method_name", "=", "method_name", "\n", "self", ".", "outputs", "=", "outputs", ".", "copy", "(", ")", "\n", "self", ".", "parameter_names", "=", "parameter_names", "\n", "self", ".", "meta", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.ParameterInferenceResult.is_multivariate": [[43, 50], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_multivariate", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check whether the result contains multivariate parameters.\"\"\"", "\n", "for", "p", "in", "self", ".", "parameter_names", ":", "\n", "            ", "if", "self", ".", "outputs", "[", "p", "]", ".", "ndim", ">", "1", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.OptimizationResult.__init__": [[55, 68], ["results.ParameterInferenceResult.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "x_min", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize result.\n\n        Parameters\n        ----------\n        x_min\n            The optimized parameters\n        **kwargs\n            See `ParameterInferenceResult`\n\n        \"\"\"", "\n", "super", "(", "OptimizationResult", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "x_min", "=", "x_min", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.__init__": [[73, 106], ["results.ParameterInferenceResult.__init__", "collections.OrderedDict"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "\n", "method_name", ",", "\n", "outputs", ",", "\n", "parameter_names", ",", "\n", "discrepancy_name", "=", "None", ",", "\n", "weights", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize result.\n\n        Parameters\n        ----------\n        method_name : string\n            Name of inference method.\n        outputs : dict\n            Dictionary with outputs from the nodes, e.g. samples.\n        parameter_names : list\n            Names of the parameter nodes\n        discrepancy_name : string, optional\n            Name of the discrepancy in outputs.\n        weights : array_like\n        **kwargs\n            Other meta information for the result\n\n        \"\"\"", "\n", "super", "(", "Sample", ",", "self", ")", ".", "__init__", "(", "\n", "method_name", "=", "method_name", ",", "outputs", "=", "outputs", ",", "parameter_names", "=", "parameter_names", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "samples", "=", "OrderedDict", "(", ")", "\n", "for", "n", "in", "self", ".", "parameter_names", ":", "\n", "            ", "self", ".", "samples", "[", "n", "]", "=", "self", ".", "outputs", "[", "n", "]", "\n", "\n", "", "self", ".", "discrepancy_name", "=", "discrepancy_name", "\n", "self", ".", "weights", "=", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.__getattr__": [[107, 113], ["results.Sample.meta.keys", "AttributeError"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Allow more convenient access to items under self.meta.\"\"\"", "\n", "if", "item", "in", "self", ".", "meta", ".", "keys", "(", ")", ":", "\n", "            ", "return", "self", ".", "meta", "[", "item", "]", "\n", "", "else", ":", "\n", "            ", "raise", "AttributeError", "(", "\"No attribute '{}' in this sample\"", ".", "format", "(", "item", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.__dir__": [[114, 122], ["items.extend", "dir", "list", "results.Sample.meta.keys", "type", "results.Sample.__dict__.keys"], "methods", ["None"], ["", "", "def", "__dir__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Allow autocompletion for items under self.meta.\n\n        http://stackoverflow.com/questions/13603088/python-dynamic-help-and-autocomplete-generation\n        \"\"\"", "\n", "items", "=", "dir", "(", "type", "(", "self", ")", ")", "+", "list", "(", "self", ".", "__dict__", ".", "keys", "(", ")", ")", "\n", "items", ".", "extend", "(", "self", ".", "meta", ".", "keys", "(", ")", ")", "\n", "return", "items", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.n_samples": [[123, 127], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_samples", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of samples.\"\"\"", "\n", "return", "len", "(", "self", ".", "outputs", "[", "self", ".", "parameter_names", "[", "0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.dim": [[128, 132], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of parameters.\"\"\"", "\n", "return", "len", "(", "self", ".", "parameter_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.discrepancies": [[133, 138], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "discrepancies", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the discrepancy values.\"\"\"", "\n", "return", "None", "if", "self", ".", "discrepancy_name", "is", "None", "else", "self", ".", "outputs", "[", "self", ".", "discrepancy_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.samples_array": [[139, 151], ["numpy.column_stack", "tuple", "results.Sample.samples.values"], "methods", ["None"], ["", "@", "property", "\n", "def", "samples_array", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the samples as an array.\n\n        The columns are in the same order as in self.parameter_names.\n\n        Returns\n        -------\n        list of np.arrays\n\n        \"\"\"", "\n", "return", "np", ".", "column_stack", "(", "tuple", "(", "self", ".", "samples", ".", "values", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.__str__": [[152, 161], ["io.StringIO", "results.Sample.summary", "io.StringIO.getvalue"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.summary"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a summary of results as a string.\"\"\"", "\n", "# create a buffer for capturing the output from summary's print statement", "\n", "stdout0", "=", "sys", ".", "stdout", "\n", "buffer", "=", "io", ".", "StringIO", "(", ")", "\n", "sys", ".", "stdout", "=", "buffer", "\n", "self", ".", "summary", "(", ")", "\n", "sys", ".", "stdout", "=", "stdout0", "# revert to original stdout", "\n", "return", "buffer", ".", "getvalue", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.__repr__": [[162, 165], ["results.Sample.__str__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a summary of results as a string.\"\"\"", "\n", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.summary": [[166, 180], ["hasattr", "hasattr", "print", "results.Sample.sample_means_summary"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.sample_means_summary"], ["", "def", "summary", "(", "self", ")", ":", "\n", "        ", "\"\"\"Print a verbose summary of contained results.\"\"\"", "\n", "# TODO: include __str__ of Inference Task, seed?", "\n", "desc", "=", "\"Method: {}\\nNumber of samples: {}\\n\"", ".", "format", "(", "self", ".", "method_name", ",", "self", ".", "n_samples", ")", "\n", "if", "hasattr", "(", "self", ",", "'n_sim'", ")", ":", "\n", "            ", "desc", "+=", "\"Number of simulations: {}\\n\"", ".", "format", "(", "self", ".", "n_sim", ")", "\n", "", "if", "hasattr", "(", "self", ",", "'threshold'", ")", ":", "\n", "            ", "desc", "+=", "\"Threshold: {:.3g}\\n\"", ".", "format", "(", "self", ".", "threshold", ")", "\n", "", "print", "(", "desc", ",", "end", "=", "''", ")", "\n", "try", ":", "\n", "            ", "self", ".", "sample_means_summary", "(", ")", "\n", "", "except", "TypeError", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.sample_means_summary": [[181, 186], ["print", "results.Sample.sample_means.items"], "methods", ["None"], ["", "", "def", "sample_means_summary", "(", "self", ")", ":", "\n", "        ", "\"\"\"Print a representation of sample means.\"\"\"", "\n", "s", "=", "\"Sample means: \"", "\n", "s", "+=", "', '", ".", "join", "(", "[", "\"{}: {:.3g}\"", ".", "format", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "self", ".", "sample_means", ".", "items", "(", ")", "]", ")", "\n", "print", "(", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.sample_means": [[187, 198], ["collections.OrderedDict", "numpy.average", "results.Sample.samples.items"], "methods", ["None"], ["", "@", "property", "\n", "def", "sample_means", "(", "self", ")", ":", "\n", "        ", "\"\"\"Evaluate weighted averages of sampled parameters.\n\n        Returns\n        -------\n        OrderedDict\n\n        \"\"\"", "\n", "return", "OrderedDict", "(", "[", "(", "k", ",", "np", ".", "average", "(", "v", ",", "axis", "=", "0", ",", "weights", "=", "self", ".", "weights", ")", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "samples", ".", "items", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.sample_means_array": [[199, 209], ["numpy.array", "list", "results.Sample.sample_means.values"], "methods", ["None"], ["", "@", "property", "\n", "def", "sample_means_array", "(", "self", ")", ":", "\n", "        ", "\"\"\"Evaluate weighted averages of sampled parameters.\n\n        Returns\n        -------\n        np.array\n\n        \"\"\"", "\n", "return", "np", ".", "array", "(", "list", "(", "self", ".", "sample_means", ".", "values", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.__getstate__": [[210, 213], ["None"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Says to pickle the exact objects to pickle.\"\"\"", "\n", "return", "self", ".", "meta", ",", "self", ".", "__dict__", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.__setstate__": [[214, 217], ["None"], "methods", ["None"], ["", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "\"\"\"Says to pickle which objects to unpickle.\"\"\"", "\n", "self", ".", "meta", ",", "self", ".", "__dict__", "=", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.save": [[218, 280], ["os.path.splitext", "open", "csv.writer", "csv.writer.writerow", "csv.writer.writerows", "results.Sample.samples.keys", "itertools.zip_longest", "open", "collections.OrderedDict", "elfi.methods.utils.sample_object_to_dict", "elfi.methods.utils.numpy_to_python_type", "json.dumps", "f.write", "print", "collections.OrderedDict", "enumerate", "data[].items", "open", "pickle.dump", "results.Sample.samples.values", "string.ascii_letters.upper", "collections.OrderedDict", "elfi.methods.utils.sample_object_to_dict", "elfi.methods.utils.numpy_to_python_type", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.sample_object_to_dict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numpy_to_python_type", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.OutputPool.open", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.sample_object_to_dict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numpy_to_python_type"], ["", "def", "save", "(", "self", ",", "fname", "=", "None", ")", ":", "\n", "        ", "\"\"\"Save samples in csv, json or pickle file formats.\n\n        Clarification: csv saves only samples, json saves the whole object's dictionary except\n        `outputs` key and pickle saves the whole object.\n\n        Parameters\n        ----------\n        fname : str, required\n            File name to be saved. The type is inferred from extension ('csv', 'json' or 'pkl').\n\n        \"\"\"", "\n", "import", "csv", "\n", "import", "json", "\n", "import", "pickle", "\n", "\n", "kind", "=", "os", ".", "path", ".", "splitext", "(", "fname", ")", "[", "1", "]", "[", "1", ":", "]", "\n", "\n", "if", "kind", "==", "'csv'", ":", "\n", "            ", "with", "open", "(", "fname", ",", "'w'", ",", "newline", "=", "''", ")", "as", "f", ":", "\n", "                ", "w", "=", "csv", ".", "writer", "(", "f", ")", "\n", "w", ".", "writerow", "(", "self", ".", "samples", ".", "keys", "(", ")", ")", "\n", "w", ".", "writerows", "(", "itertools", ".", "zip_longest", "(", "*", "self", ".", "samples", ".", "values", "(", ")", ",", "fillvalue", "=", "''", ")", ")", "\n", "", "", "elif", "kind", "==", "'json'", ":", "\n", "            ", "with", "open", "(", "fname", ",", "'w'", ")", "as", "f", ":", "\n", "\n", "                ", "data", "=", "OrderedDict", "(", ")", "\n", "\n", "data", "[", "'n_samples'", "]", "=", "self", ".", "n_samples", "\n", "data", "[", "'discrepancies'", "]", "=", "self", ".", "discrepancies", "\n", "data", "[", "'dim'", "]", "=", "self", ".", "dim", "\n", "\n", "# populations key exists in SMC-ABC sampler and contains the history of all", "\n", "# inferences with different number of simulations and thresholds", "\n", "populations", "=", "'populations'", "\n", "if", "populations", "in", "self", ".", "__dict__", ":", "\n", "# setting populations in the following form:", "\n", "# data = {'populations': {'A': dict(), 'B': dict()}, ...}", "\n", "# this helps to save all kind of populations", "\n", "                    ", "pop_num", "=", "string", ".", "ascii_letters", ".", "upper", "(", ")", "[", ":", "len", "(", "self", ".", "__dict__", "[", "populations", "]", ")", "]", "\n", "data", "[", "populations", "]", "=", "OrderedDict", "(", ")", "\n", "for", "n", ",", "elem", "in", "enumerate", "(", "self", ".", "__dict__", "[", "populations", "]", ")", ":", "\n", "                        ", "data", "[", "populations", "]", "[", "pop_num", "[", "n", "]", "]", "=", "OrderedDict", "(", ")", "\n", "sample_object_to_dict", "(", "data", "[", "populations", "]", "[", "pop_num", "[", "n", "]", "]", ",", "elem", ")", "\n", "\n", "# convert numpy types into python types in populations key", "\n", "", "for", "key", ",", "val", "in", "data", "[", "populations", "]", ".", "items", "(", ")", ":", "\n", "                        ", "numpy_to_python_type", "(", "val", ")", "\n", "\n", "# skip populations because it was processed previously", "\n", "", "", "sample_object_to_dict", "(", "data", ",", "self", ",", "skip", "=", "'populations'", ")", "\n", "\n", "# convert numpy types into python types", "\n", "numpy_to_python_type", "(", "data", ")", "\n", "\n", "js", "=", "json", ".", "dumps", "(", "data", ")", "\n", "f", ".", "write", "(", "js", ")", "\n", "", "", "elif", "kind", "==", "'pkl'", ":", "\n", "            ", "with", "open", "(", "fname", ",", "'wb'", ")", "as", "f", ":", "\n", "                ", "pickle", ".", "dump", "(", "self", ",", "f", ",", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "\"Wrong file type format. Please use 'csv', 'json' or 'pkl'.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.plot_marginals": [[281, 303], ["print", "elfi.plot_marginals"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.plot_marginals"], ["", "", "def", "plot_marginals", "(", "self", ",", "selector", "=", "None", ",", "bins", "=", "20", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Plot marginal distributions for parameters.\n\n        Supports only univariate distributions.\n\n        Parameters\n        ----------\n        selector : iterable of ints or strings, optional\n            Indices or keys to use from samples. Default to all.\n        bins : int, optional\n            Number of bins in histograms.\n        axes : one or an iterable of plt.Axes, optional\n\n        Returns\n        -------\n        axes : np.array of plt.Axes\n\n        \"\"\"", "\n", "if", "self", ".", "is_multivariate", ":", "\n", "            ", "print", "(", "\"Plotting multivariate distributions is unsupported.\"", ")", "\n", "", "else", ":", "\n", "            ", "return", "vis", ".", "plot_marginals", "(", "self", ".", "samples", ",", "selector", ",", "bins", ",", "axes", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.Sample.plot_pairs": [[304, 327], ["print", "elfi.plot_pairs"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.plot_pairs"], ["", "", "def", "plot_pairs", "(", "self", ",", "selector", "=", "None", ",", "bins", "=", "20", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Plot pairwise relationships as a matrix with marginals on the diagonal.\n\n        The y-axis of marginal histograms are scaled.\n        Supports only univariate distributions.\n\n        Parameters\n        ----------\n        selector : iterable of ints or strings, optional\n            Indices or keys to use from samples. Default to all.\n        bins : int, optional\n            Number of bins in histograms.\n        axes : one or an iterable of plt.Axes, optional\n\n        Returns\n        -------\n        axes : np.array of plt.Axes\n\n        \"\"\"", "\n", "if", "self", ".", "is_multivariate", ":", "\n", "            ", "print", "(", "\"Plotting multivariate distributions is unsupported.\"", ")", "\n", "", "else", ":", "\n", "            ", "return", "vis", ".", "plot_pairs", "(", "self", ".", "samples", ",", "selector", ",", "bins", ",", "axes", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.__init__": [[332, 356], ["results.Sample.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "method_name", ",", "outputs", ",", "parameter_names", ",", "populations", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize result.\n\n        Parameters\n        ----------\n        method_name : str\n        outputs : dict\n        parameter_names : list\n        populations : list[Sample]\n            List of Sample objects\n        args\n        kwargs\n\n        \"\"\"", "\n", "super", "(", "SmcSample", ",", "self", ")", ".", "__init__", "(", "\n", "method_name", "=", "method_name", ",", "\n", "outputs", "=", "outputs", ",", "\n", "parameter_names", "=", "parameter_names", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "populations", "=", "populations", "\n", "\n", "if", "self", ".", "weights", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"No weights provided for the sample\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.n_populations": [[357, 361], ["len"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "n_populations", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of populations.\"\"\"", "\n", "return", "len", "(", "self", ".", "populations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.summary": [[362, 378], ["results.Sample.summary", "enumerate", "print", "pop.summary"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.summary", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.summary"], ["", "def", "summary", "(", "self", ",", "all", "=", "False", ")", ":", "\n", "        ", "\"\"\"Print a verbose summary of contained results.\n\n        Parameters\n        ----------\n        all : bool, optional\n            Whether to print the summary for all populations separately,\n            or just the final population (default).\n\n        \"\"\"", "\n", "super", "(", "SmcSample", ",", "self", ")", ".", "summary", "(", ")", "\n", "\n", "if", "all", ":", "\n", "            ", "for", "i", ",", "pop", "in", "enumerate", "(", "self", ".", "populations", ")", ":", "\n", "                ", "print", "(", "'\\nPopulation {}:'", ".", "format", "(", "i", ")", ")", "\n", "pop", ".", "summary", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.sample_means_summary": [[379, 399], ["enumerate", "print", "results.Sample.sample_means_summary", "pop.sample_means.items"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.sample_means_summary"], ["", "", "", "def", "sample_means_summary", "(", "self", ",", "all", "=", "False", ")", ":", "\n", "        ", "\"\"\"Print a representation of sample means.\n\n        Parameters\n        ----------\n        all : bool, optional\n            Whether to print the means for all populations separately,\n            or just the final population (default).\n\n        \"\"\"", "\n", "if", "all", "is", "False", ":", "\n", "            ", "super", "(", "SmcSample", ",", "self", ")", ".", "sample_means_summary", "(", ")", "\n", "return", "\n", "\n", "", "out", "=", "''", "\n", "for", "i", ",", "pop", "in", "enumerate", "(", "self", ".", "populations", ")", ":", "\n", "            ", "out", "+=", "\"Sample means for population {}: \"", ".", "format", "(", "i", ")", "\n", "out", "+=", "', '", ".", "join", "(", "[", "\"{}: {:.3g}\"", ".", "format", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "pop", ".", "sample_means", ".", "items", "(", ")", "]", ")", "\n", "out", "+=", "'\\n'", "\n", "", "print", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.plot_marginals": [[400, 422], ["kwargs.pop", "enumerate", "results.Sample.plot_marginals", "pop.plot_marginals", "matplotlib.pyplot.suptitle"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.plot_marginals", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.plot_marginals"], ["", "def", "plot_marginals", "(", "self", ",", "selector", "=", "None", ",", "bins", "=", "20", ",", "axes", "=", "None", ",", "all", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Plot marginal distributions for parameters for all populations.\n\n        Parameters\n        ----------\n        selector : iterable of ints or strings, optional\n            Indices or keys to use from samples. Default to all.\n        bins : int, optional\n            Number of bins in histograms.\n        axes : one or an iterable of plt.Axes, optional\n        all : bool, optional\n            Plot the marginals of all populations\n\n        \"\"\"", "\n", "if", "all", "is", "False", ":", "\n", "            ", "super", "(", "SmcSample", ",", "self", ")", ".", "plot_marginals", "(", ")", "\n", "return", "\n", "\n", "", "fontsize", "=", "kwargs", ".", "pop", "(", "'fontsize'", ",", "13", ")", "\n", "for", "i", ",", "pop", "in", "enumerate", "(", "self", ".", "populations", ")", ":", "\n", "            ", "pop", ".", "plot_marginals", "(", "selector", "=", "selector", ",", "bins", "=", "bins", ",", "axes", "=", "axes", ")", "\n", "plt", ".", "suptitle", "(", "\"Population {}\"", ".", "format", "(", "i", ")", ",", "fontsize", "=", "fontsize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.plot_pairs": [[423, 447], ["kwargs.pop", "enumerate", "results.Sample.plot_marginals", "pop.plot_pairs", "matplotlib.pyplot.suptitle"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.plot_marginals", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.SmcSample.plot_pairs"], ["", "", "def", "plot_pairs", "(", "self", ",", "selector", "=", "None", ",", "bins", "=", "20", ",", "axes", "=", "None", ",", "all", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Plot pairwise relationships as a matrix with marginals on the diagonal.\n\n        The y-axis of marginal histograms are scaled.\n\n        Parameters\n        ----------\n        selector : iterable of ints or strings, optional\n            Indices or keys to use from samples. Default to all.\n        bins : int, optional\n            Number of bins in histograms.\n        axes : one or an iterable of plt.Axes, optional\n        all : bool, optional\n            Plot for all populations\n\n        \"\"\"", "\n", "if", "all", "is", "False", ":", "\n", "            ", "super", "(", "SmcSample", ",", "self", ")", ".", "plot_marginals", "(", ")", "\n", "return", "\n", "\n", "", "fontsize", "=", "kwargs", ".", "pop", "(", "'fontsize'", ",", "13", ")", "\n", "for", "i", ",", "pop", "in", "enumerate", "(", "self", ".", "populations", ")", ":", "\n", "            ", "pop", ".", "plot_pairs", "(", "selector", "=", "selector", ",", "bins", "=", "bins", ",", "axes", "=", "axes", ")", "\n", "plt", ".", "suptitle", "(", "\"Population {}\"", ".", "format", "(", "i", ")", ",", "fontsize", "=", "fontsize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.BolfiSample.__init__": [[452, 482], ["chains.copy.copy.copy", "warmed_up.reshape", "dict", "results.Sample.__init__", "zip"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "method_name", ",", "chains", ",", "parameter_names", ",", "warmup", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize result.\n\n        Parameters\n        ----------\n        method_name : string\n            Name of inference method.\n        chains : np.array\n            Chains from sampling, warmup included. Shape: (n_chains, n_samples, n_parameters).\n        parameter_names : list : list of strings\n            List of names in the outputs dict that refer to model parameters.\n        warmup : int\n            Number of warmup iterations in chains.\n\n        \"\"\"", "\n", "chains", "=", "chains", ".", "copy", "(", ")", "\n", "shape", "=", "chains", ".", "shape", "\n", "n_chains", "=", "shape", "[", "0", "]", "\n", "warmed_up", "=", "chains", "[", ":", ",", "warmup", ":", ",", ":", "]", "\n", "concatenated", "=", "warmed_up", ".", "reshape", "(", "(", "-", "1", ",", ")", "+", "shape", "[", "2", ":", "]", ")", "\n", "outputs", "=", "dict", "(", "zip", "(", "parameter_names", ",", "concatenated", ".", "T", ")", ")", "\n", "\n", "super", "(", "BolfiSample", ",", "self", ")", ".", "__init__", "(", "\n", "method_name", "=", "method_name", ",", "\n", "outputs", "=", "outputs", ",", "\n", "parameter_names", "=", "parameter_names", ",", "\n", "chains", "=", "chains", ",", "\n", "n_chains", "=", "n_chains", ",", "\n", "warmup", "=", "warmup", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.BolfiSample.plot_traces": [[483, 486], ["elfi.plot_traces"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.results.BolfiSample.plot_traces"], ["", "def", "plot_traces", "(", "self", ",", "selector", "=", "None", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Plot MCMC traces.\"\"\"", "\n", "return", "vis", ".", "plot_traces", "(", "self", ",", "selector", ",", "axes", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.__init__": [[62, 122], ["model.copy", "parameter_inference.ParameterInference._check_outputs", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.client.get_client", "elfi.model.elfi_model.ComputationContext", "elfi.model.elfi_model.ComputationContext", "elfi.model.elfi_model.ComputationContext", "elfi.model.elfi_model.ComputationContext", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "elfi.client.BatchHandler", "dict", "dict", "isinstance", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._check_outputs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.get_client"], ["def", "__init__", "(", "self", ",", "\n", "model", ",", "\n", "output_names", ",", "\n", "batch_size", "=", "1", ",", "\n", "seed", "=", "None", ",", "\n", "pool", "=", "None", ",", "\n", "max_parallel_batches", "=", "None", ")", ":", "\n", "        ", "\"\"\"Construct the inference algorithm object.\n\n        If you are implementing your own algorithm do not forget to call `super`.\n\n        Parameters\n        ----------\n        model : ElfiModel\n            Model to perform the inference with.\n        output_names : list\n            Names of the nodes whose outputs will be requested from the ELFI graph.\n        batch_size : int, optional\n            The number of parameter evaluations in each pass through the ELFI graph.\n            When using a vectorized simulator, using a suitably large batch_size can provide\n            a significant performance boost.\n        seed : int, optional\n            Seed for the data generation from the ElfiModel\n        pool : OutputPool, optional\n            OutputPool both stores and provides precomputed values for batches.\n        max_parallel_batches : int, optional\n            Maximum number of batches allowed to be in computation at the same time.\n            Defaults to number of cores in the client\n\n\n        \"\"\"", "\n", "model", "=", "model", ".", "model", "if", "isinstance", "(", "model", ",", "NodeReference", ")", "else", "model", "\n", "if", "not", "model", ".", "parameter_names", ":", "\n", "            ", "raise", "ValueError", "(", "'Model {} defines no parameters'", ".", "format", "(", "model", ")", ")", "\n", "\n", "", "self", ".", "model", "=", "model", ".", "copy", "(", ")", "\n", "self", ".", "output_names", "=", "self", ".", "_check_outputs", "(", "output_names", ")", "\n", "\n", "self", ".", "client", "=", "elfi", ".", "client", ".", "get_client", "(", ")", "\n", "\n", "# Prepare the computation_context", "\n", "context", "=", "ComputationContext", "(", "batch_size", "=", "batch_size", ",", "seed", "=", "seed", ",", "pool", "=", "pool", ")", "\n", "self", ".", "batches", "=", "elfi", ".", "client", ".", "BatchHandler", "(", "\n", "self", ".", "model", ",", "context", "=", "context", ",", "output_names", "=", "output_names", ",", "client", "=", "self", ".", "client", ")", "\n", "self", ".", "computation_context", "=", "context", "\n", "self", ".", "max_parallel_batches", "=", "max_parallel_batches", "or", "self", ".", "client", ".", "num_cores", "\n", "\n", "if", "self", ".", "max_parallel_batches", "<=", "0", ":", "\n", "            ", "msg", "=", "'Value for max_parallel_batches ({}) must be at least one.'", ".", "format", "(", "\n", "self", ".", "max_parallel_batches", ")", "\n", "if", "self", ".", "client", ".", "num_cores", "==", "0", ":", "\n", "                ", "msg", "+=", "' Client has currently no workers available. Please make sure '", "'the cluster has fully started or set the max_parallel_batches '", "'parameter by hand.'", "\n", "", "raise", "ValueError", "(", "msg", ")", "\n", "\n", "# State and objective should contain all information needed to continue the", "\n", "# inference after an iteration.", "\n", "", "self", ".", "state", "=", "dict", "(", "n_sim", "=", "0", ",", "n_batches", "=", "0", ")", "\n", "self", ".", "objective", "=", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.pool": [[123, 127], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "pool", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the output pool of the inference.\"\"\"", "\n", "return", "self", ".", "computation_context", ".", "pool", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.seed": [[128, 132], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "seed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the seed of the inference.\"\"\"", "\n", "return", "self", ".", "computation_context", ".", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.parameter_names": [[133, 137], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "parameter_names", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the parameters to be inferred.\"\"\"", "\n", "return", "self", ".", "model", ".", "parameter_names", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.batch_size": [[138, 142], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "batch_size", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the current batch_size.\"\"\"", "\n", "return", "self", ".", "computation_context", ".", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.set_objective": [[143, 155], ["None"], "methods", ["None"], ["", "def", "set_objective", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Set the objective of the inference.\n\n        This method sets the objective of the inference (values typically stored in the\n        `self.objective` dict).\n\n        Returns\n        -------\n        None\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.extract_result": [[156, 167], ["None"], "methods", ["None"], ["", "def", "extract_result", "(", "self", ")", ":", "\n", "        ", "\"\"\"Prepare the result from the current state of the inference.\n\n        ELFI calls this method in the end of the inference to return the result.\n\n        Returns\n        -------\n        result : elfi.methods.result.Result\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.update": [[168, 189], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "batch", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Update the inference state with a new batch.\n\n        ELFI calls this method when a new batch has been computed and the state of\n        the inference should be updated with it. It is also possible to bypass ELFI and\n        call this directly to update the inference.\n\n        Parameters\n        ----------\n        batch : dict\n            dict with `self.outputs` as keys and the corresponding outputs for the batch\n            as values\n        batch_index : int\n\n        Returns\n        -------\n        None\n\n        \"\"\"", "\n", "self", ".", "state", "[", "'n_batches'", "]", "+=", "1", "\n", "self", ".", "state", "[", "'n_sim'", "]", "+=", "self", ".", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.prepare_new_batch": [[190, 214], ["None"], "methods", ["None"], ["", "def", "prepare_new_batch", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Prepare values for a new batch.\n\n        ELFI calls this method before submitting a new batch with an increasing index\n        `batch_index`. This is an optional method to override. Use this if you have a need\n        do do preparations, e.g. in Bayesian optimization algorithm, the next acquisition\n        points would be acquired here.\n\n        If you need provide values for certain nodes, you can do so by constructing a\n        batch dictionary and returning it. See e.g. BayesianOptimization for an example.\n\n        Parameters\n        ----------\n        batch_index : int\n            next batch_index to be submitted\n\n        Returns\n        -------\n        batch : dict or None\n            Keys should match to node names in the model. These values will override any\n            default values or operations in those nodes.\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.plot_state": [[215, 237], ["None"], "methods", ["None"], ["", "def", "plot_state", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Plot the current state of the algorithm.\n\n        Parameters\n        ----------\n        axes : matplotlib.axes.Axes (optional)\n        figure : matplotlib.figure.Figure (optional)\n        xlim\n            x-axis limits\n        ylim\n            y-axis limits\n        interactive : bool (default False)\n            If true, uses IPython.display to update the cell figure\n        close\n            Close figure in the end of plotting. Used in the end of interactive mode.\n\n        Returns\n        -------\n        None\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer": [[238, 277], ["parameter_inference.ParameterInference.set_objective", "parameter_inference.ParameterInference.batches.cancel_pending", "parameter_inference.ParameterInference.extract_result", "isinstance", "elfi.visualization.visualization.progress_bar", "elfi.visualization.visualization.progress_bar", "elfi.visualization.visualization.progress_bar", "elfi.visualization.visualization.progress_bar", "parameter_inference.ParameterInference.iterate", "parameter_inference.ParameterInference.plot_state", "parameter_inference.ParameterInference.plot_state", "elfi.visualization.visualization.progress_bar", "elfi.visualization.visualization.progress_bar", "elfi.visualization.visualization.progress_bar", "elfi.visualization.visualization.progress_bar"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.set_objective", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.cancel_pending", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.extract_result", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.iterate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.plot_state", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.plot_state", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.visualization.progress_bar"], ["", "def", "infer", "(", "self", ",", "*", "args", ",", "vis", "=", "None", ",", "bar", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Set the objective and start the iterate loop until the inference is finished.\n\n        See the other arguments from the `set_objective` method.\n\n        Parameters\n        ----------\n        vis : dict, optional\n            Plotting options. More info in self.plot_state method\n        bar : bool, optional\n            Flag to remove (False) or keep (True) the progress bar from/in output.\n\n        Returns\n        -------\n        result : Sample\n\n        \"\"\"", "\n", "vis_opt", "=", "vis", "if", "isinstance", "(", "vis", ",", "dict", ")", "else", "{", "}", "\n", "\n", "self", ".", "set_objective", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "if", "bar", ":", "\n", "            ", "progress_bar", "(", "0", ",", "self", ".", "_objective_n_batches", ",", "prefix", "=", "'Progress:'", ",", "\n", "suffix", "=", "'Complete'", ",", "length", "=", "50", ")", "\n", "\n", "", "while", "not", "self", ".", "finished", ":", "\n", "            ", "self", ".", "iterate", "(", ")", "\n", "if", "vis", ":", "\n", "                ", "self", ".", "plot_state", "(", "interactive", "=", "True", ",", "**", "vis_opt", ")", "\n", "\n", "", "if", "bar", ":", "\n", "                ", "progress_bar", "(", "self", ".", "state", "[", "'n_batches'", "]", ",", "self", ".", "_objective_n_batches", ",", "\n", "prefix", "=", "'Progress:'", ",", "suffix", "=", "'Complete'", ",", "length", "=", "50", ")", "\n", "\n", "", "", "self", ".", "batches", ".", "cancel_pending", "(", ")", "\n", "if", "vis", ":", "\n", "            ", "self", ".", "plot_state", "(", "close", "=", "True", ",", "**", "vis_opt", ")", "\n", "\n", "", "return", "self", ".", "extract_result", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.iterate": [[278, 309], ["parameter_inference.ParameterInference._allow_submit", "parameter_inference.ParameterInference.batches.wait_next", "logger.debug", "parameter_inference.ParameterInference.update", "parameter_inference.ParameterInference.prepare_new_batch", "logger.debug", "parameter_inference.ParameterInference.batches.submit"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._allow_submit", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.wait_next", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.prepare_new_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.submit"], ["", "def", "iterate", "(", "self", ")", ":", "\n", "        ", "\"\"\"Advance the inference by one iteration.\n\n        This is a way to manually progress the inference. One iteration consists of\n        waiting and processing the result of the next batch in succession and possibly\n        submitting new batches.\n\n        Notes\n        -----\n        If the next batch is ready, it will be processed immediately and no new batches\n        are submitted.\n\n        New batches are submitted only while waiting for the next one to complete. There\n        will never be more batches submitted in parallel than the `max_parallel_batches`\n        setting allows.\n\n        Returns\n        -------\n        None\n\n        \"\"\"", "\n", "# Submit new batches if allowed", "\n", "while", "self", ".", "_allow_submit", "(", "self", ".", "batches", ".", "next_index", ")", ":", "\n", "            ", "next_batch", "=", "self", ".", "prepare_new_batch", "(", "self", ".", "batches", ".", "next_index", ")", "\n", "logger", ".", "debug", "(", "\"Submitting batch %d\"", "%", "self", ".", "batches", ".", "next_index", ")", "\n", "self", ".", "batches", ".", "submit", "(", "next_batch", ")", "\n", "\n", "# Handle the next ready batch in succession", "\n", "", "batch", ",", "batch_index", "=", "self", ".", "batches", ".", "wait_next", "(", ")", "\n", "logger", ".", "debug", "(", "'Received batch %d'", "%", "batch_index", ")", "\n", "self", ".", "update", "(", "batch", ",", "batch_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.finished": [[310, 313], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "finished", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_objective_n_batches", "<=", "self", ".", "state", "[", "'n_batches'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._allow_submit": [[314, 317], ["parameter_inference.ParameterInference.batches.has_ready"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.has_ready"], ["", "def", "_allow_submit", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "return", "(", "self", ".", "max_parallel_batches", ">", "self", ".", "batches", ".", "num_pending", "and", "\n", "self", ".", "_has_batches_to_submit", "and", "(", "not", "self", ".", "batches", ".", "has_ready", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._has_batches_to_submit": [[318, 321], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "_has_batches_to_submit", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_objective_n_batches", ">", "self", ".", "state", "[", "'n_batches'", "]", "+", "self", ".", "batches", ".", "num_pending", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._objective_n_batches": [[322, 332], ["math.ceil", "ValueError"], "methods", ["None"], ["", "@", "property", "\n", "def", "_objective_n_batches", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check that n_batches can be computed from the objective.\"\"\"", "\n", "if", "'n_batches'", "in", "self", ".", "objective", ":", "\n", "            ", "n_batches", "=", "self", ".", "objective", "[", "'n_batches'", "]", "\n", "", "elif", "'n_sim'", "in", "self", ".", "objective", ":", "\n", "            ", "n_batches", "=", "ceil", "(", "self", ".", "objective", "[", "'n_sim'", "]", "/", "self", ".", "batch_size", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Objective must define either `n_batches` or `n_sim`.'", ")", "\n", "", "return", "n_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._extract_result_kwargs": [[333, 341], ["None"], "methods", ["None"], ["", "def", "_extract_result_kwargs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Extract common arguments for the ParameterInferenceResult object.\"\"\"", "\n", "return", "{", "\n", "'method_name'", ":", "self", ".", "__class__", ".", "__name__", ",", "\n", "'parameter_names'", ":", "self", ".", "parameter_names", ",", "\n", "'seed'", ":", "self", ".", "seed", ",", "\n", "'n_sim'", ":", "self", ".", "state", "[", "'n_sim'", "]", ",", "\n", "'n_batches'", ":", "self", ".", "state", "[", "'n_batches'", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._resolve_model": [[343, 359], ["isinstance", "isinstance", "isinstance", "NotImplementedError", "isinstance", "ValueError"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_resolve_model", "(", "model", ",", "target", ",", "default_reference_class", "=", "NodeReference", ")", ":", "\n", "        ", "if", "isinstance", "(", "model", ",", "ElfiModel", ")", "and", "target", "is", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Please specify the target node of the inference method\"", ")", "\n", "\n", "", "if", "isinstance", "(", "model", ",", "NodeReference", ")", ":", "\n", "            ", "target", "=", "model", "\n", "model", "=", "target", ".", "model", "\n", "\n", "", "if", "isinstance", "(", "target", ",", "str", ")", ":", "\n", "            ", "target", "=", "model", "[", "target", "]", "\n", "\n", "", "if", "not", "isinstance", "(", "target", ",", "default_reference_class", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown target node class'", ")", "\n", "\n", "", "return", "model", ",", "target", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._check_outputs": [[360, 384], ["set", "isinstance", "set.add", "checked_names.append", "isinstance", "ValueError", "parameter_inference.ParameterInference.model.has_node", "ValueError"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.graphical_model.GraphicalModel.has_node"], ["", "def", "_check_outputs", "(", "self", ",", "output_names", ")", ":", "\n", "        ", "\"\"\"Filter out duplicates and check that corresponding nodes exist.\n\n        Preserves the order.\n        \"\"\"", "\n", "output_names", "=", "output_names", "or", "[", "]", "\n", "checked_names", "=", "[", "]", "\n", "seen", "=", "set", "(", ")", "\n", "for", "name", "in", "output_names", ":", "\n", "            ", "if", "isinstance", "(", "name", ",", "NodeReference", ")", ":", "\n", "                ", "name", "=", "name", ".", "name", "\n", "\n", "", "if", "name", "in", "seen", ":", "\n", "                ", "continue", "\n", "", "elif", "not", "isinstance", "(", "name", ",", "str", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "'All output names must be strings, object {} was given'", ".", "format", "(", "name", ")", ")", "\n", "", "elif", "not", "self", ".", "model", ".", "has_node", "(", "name", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Node {} output was requested, but it is not in the model.'", ")", "\n", "\n", "", "seen", ".", "add", "(", "name", ")", "\n", "checked_names", ".", "append", "(", "name", ")", "\n", "\n", "", "return", "checked_names", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Sampler.sample": [[387, 407], ["kwargs.pop", "parameter_inference.Sampler.infer"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer"], ["    ", "def", "sample", "(", "self", ",", "n_samples", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample from the approximate posterior.\n\n        See the other arguments from the `set_objective` method.\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples to generate from the (approximate) posterior\n        *args\n        **kwargs\n\n        Returns\n        -------\n        result : Sample\n\n        \"\"\"", "\n", "bar", "=", "kwargs", ".", "pop", "(", "'bar'", ",", "True", ")", "\n", "\n", "return", "self", ".", "infer", "(", "n_samples", ",", "*", "args", ",", "bar", "=", "bar", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Sampler._extract_result_kwargs": [[408, 416], ["parameter_inference.ParameterInference._extract_result_kwargs", "hasattr"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Sampler._extract_result_kwargs"], ["", "def", "_extract_result_kwargs", "(", "self", ")", ":", "\n", "        ", "kwargs", "=", "super", "(", "Sampler", ",", "self", ")", ".", "_extract_result_kwargs", "(", ")", "\n", "for", "state_key", "in", "[", "'threshold'", ",", "'accept_rate'", "]", ":", "\n", "            ", "if", "state_key", "in", "self", ".", "state", ":", "\n", "                ", "kwargs", "[", "state_key", "]", "=", "self", ".", "state", "[", "state_key", "]", "\n", "", "", "if", "hasattr", "(", "self", ",", "'discrepancy_name'", ")", ":", "\n", "            ", "kwargs", "[", "'discrepancy_name'", "]", "=", "self", ".", "discrepancy_name", "\n", "", "return", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection.__init__": [[432, 452], ["parameter_inference.Rejection._resolve_model", "parameter_inference.ParameterInference.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._resolve_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "discrepancy_name", "=", "None", ",", "output_names", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize the Rejection sampler.\n\n        Parameters\n        ----------\n        model : ElfiModel or NodeReference\n        discrepancy_name : str, NodeReference, optional\n            Only needed if model is an ElfiModel\n        output_names : list, optional\n            Additional outputs from the model to be included in the inference result, e.g.\n            corresponding summaries to the acquired samples\n        kwargs:\n            See InferenceMethod\n\n        \"\"\"", "\n", "model", ",", "discrepancy_name", "=", "self", ".", "_resolve_model", "(", "model", ",", "discrepancy_name", ")", "\n", "output_names", "=", "[", "discrepancy_name", "]", "+", "model", ".", "parameter_names", "+", "(", "output_names", "or", "[", "]", ")", "\n", "super", "(", "Rejection", ",", "self", ")", ".", "__init__", "(", "model", ",", "output_names", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "discrepancy_name", "=", "discrepancy_name", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection.set_objective": [[453, 487], ["dict", "dict", "parameter_inference.Rejection.batches.reset", "math.ceil", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.reset"], ["", "def", "set_objective", "(", "self", ",", "n_samples", ",", "threshold", "=", "None", ",", "quantile", "=", "None", ",", "n_sim", "=", "None", ")", ":", "\n", "        ", "\"\"\"Set objective for inference.\n\n        Parameters\n        ----------\n        n_samples : int\n            number of samples to generate\n        threshold : float\n            Acceptance threshold\n        quantile : float\n            In between (0,1). Define the threshold as the p-quantile of all the\n            simulations. n_sim = n_samples/quantile.\n        n_sim : int\n            Total number of simulations. The threshold will be the n_samples smallest\n            discrepancy among n_sim simulations.\n\n        \"\"\"", "\n", "if", "quantile", "is", "None", "and", "threshold", "is", "None", "and", "n_sim", "is", "None", ":", "\n", "            ", "quantile", "=", ".01", "\n", "", "self", ".", "state", "=", "dict", "(", "samples", "=", "None", ",", "threshold", "=", "np", ".", "Inf", ",", "n_sim", "=", "0", ",", "accept_rate", "=", "1", ",", "n_batches", "=", "0", ")", "\n", "\n", "if", "quantile", ":", "\n", "            ", "n_sim", "=", "ceil", "(", "n_samples", "/", "quantile", ")", "\n", "\n", "# Set initial n_batches estimate", "\n", "", "if", "n_sim", ":", "\n", "            ", "n_batches", "=", "ceil", "(", "n_sim", "/", "self", ".", "batch_size", ")", "\n", "", "else", ":", "\n", "            ", "n_batches", "=", "self", ".", "max_parallel_batches", "\n", "\n", "", "self", ".", "objective", "=", "dict", "(", "n_samples", "=", "n_samples", ",", "threshold", "=", "threshold", ",", "n_batches", "=", "n_batches", ")", "\n", "\n", "# Reset the inference", "\n", "self", ".", "batches", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection.update": [[488, 506], ["parameter_inference.ParameterInference.update", "parameter_inference.Rejection._merge_batch", "parameter_inference.Rejection._update_state_meta", "parameter_inference.Rejection._update_objective_n_batches", "parameter_inference.Rejection._init_samples_lazy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection._merge_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection._update_state_meta", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection._update_objective_n_batches", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection._init_samples_lazy"], ["", "def", "update", "(", "self", ",", "batch", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Update the inference state with a new batch.\n\n        Parameters\n        ----------\n        batch : dict\n            dict with `self.outputs` as keys and the corresponding outputs for the batch\n            as values\n        batch_index : int\n\n        \"\"\"", "\n", "super", "(", "Rejection", ",", "self", ")", ".", "update", "(", "batch", ",", "batch_index", ")", "\n", "if", "self", ".", "state", "[", "'samples'", "]", "is", "None", ":", "\n", "# Lazy initialization of the outputs dict", "\n", "            ", "self", ".", "_init_samples_lazy", "(", "batch", ")", "\n", "", "self", ".", "_merge_batch", "(", "batch", ")", "\n", "self", ".", "_update_state_meta", "(", ")", "\n", "self", ".", "_update_objective_n_batches", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection.extract_result": [[507, 524], ["dict", "parameter_inference.Rejection.state[].items", "elfi.methods.results.Sample", "elfi.methods.results.Sample", "elfi.methods.results.Sample", "elfi.methods.results.Sample", "ValueError", "parameter_inference.Rejection._extract_result_kwargs"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Sampler._extract_result_kwargs"], ["", "def", "extract_result", "(", "self", ")", ":", "\n", "        ", "\"\"\"Extract the result from the current state.\n\n        Returns\n        -------\n        result : Sample\n\n        \"\"\"", "\n", "if", "self", ".", "state", "[", "'samples'", "]", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Nothing to extract'", ")", "\n", "\n", "# Take out the correct number of samples", "\n", "", "outputs", "=", "dict", "(", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "state", "[", "'samples'", "]", ".", "items", "(", ")", ":", "\n", "            ", "outputs", "[", "k", "]", "=", "v", "[", ":", "self", ".", "objective", "[", "'n_samples'", "]", "]", "\n", "\n", "", "return", "Sample", "(", "outputs", "=", "outputs", ",", "**", "self", ".", "_extract_result_kwargs", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection._init_samples_lazy": [[525, 553], ["KeyError", "elfi.utils.is_array", "elfi.utils.is_array", "elfi.utils.is_array", "elfi.utils.is_array", "ValueError", "numpy.empty", "e_noarr.format", "len", "ValueError", "numpy.ones", "e_len.format", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.is_array", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.is_array", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.is_array", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.is_array"], ["", "def", "_init_samples_lazy", "(", "self", ",", "batch", ")", ":", "\n", "        ", "\"\"\"Initialize the outputs dict based on the received batch.\"\"\"", "\n", "samples", "=", "{", "}", "\n", "e_noarr", "=", "\"Node {} output must be in a numpy array of length {} (batch_size).\"", "\n", "e_len", "=", "\"Node {} output has array length {}. It should be equal to the batch size {}.\"", "\n", "\n", "for", "node", "in", "self", ".", "output_names", ":", "\n", "# Check the requested outputs", "\n", "            ", "if", "node", "not", "in", "batch", ":", "\n", "                ", "raise", "KeyError", "(", "\"Did not receive outputs for node {}\"", ".", "format", "(", "node", ")", ")", "\n", "\n", "", "nbatch", "=", "batch", "[", "node", "]", "\n", "if", "not", "is_array", "(", "nbatch", ")", ":", "\n", "                ", "raise", "ValueError", "(", "e_noarr", ".", "format", "(", "node", ",", "self", ".", "batch_size", ")", ")", "\n", "", "elif", "len", "(", "nbatch", ")", "!=", "self", ".", "batch_size", ":", "\n", "                ", "raise", "ValueError", "(", "e_len", ".", "format", "(", "node", ",", "len", "(", "nbatch", ")", ",", "self", ".", "batch_size", ")", ")", "\n", "\n", "# Prepare samples", "\n", "", "shape", "=", "(", "self", ".", "objective", "[", "'n_samples'", "]", "+", "self", ".", "batch_size", ",", ")", "+", "nbatch", ".", "shape", "[", "1", ":", "]", "\n", "dtype", "=", "nbatch", ".", "dtype", "\n", "\n", "if", "node", "==", "self", ".", "discrepancy_name", ":", "\n", "# Initialize the distances to inf", "\n", "                ", "samples", "[", "node", "]", "=", "np", ".", "ones", "(", "shape", ",", "dtype", "=", "dtype", ")", "*", "np", ".", "inf", "\n", "", "else", ":", "\n", "                ", "samples", "[", "node", "]", "=", "np", ".", "empty", "(", "shape", ",", "dtype", "=", "dtype", ")", "\n", "\n", "", "", "self", ".", "state", "[", "'samples'", "]", "=", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection._merge_batch": [[554, 565], ["samples.items", "numpy.argsort().ravel", "samples.items", "numpy.argsort"], "methods", ["None"], ["", "def", "_merge_batch", "(", "self", ",", "batch", ")", ":", "\n", "# TODO: add index vector so that you can recover the original order", "\n", "        ", "samples", "=", "self", ".", "state", "[", "'samples'", "]", "\n", "# Put the acquired samples to the end", "\n", "for", "node", ",", "v", "in", "samples", ".", "items", "(", ")", ":", "\n", "            ", "v", "[", "self", ".", "objective", "[", "'n_samples'", "]", ":", "]", "=", "batch", "[", "node", "]", "\n", "\n", "# Sort the smallest to the beginning", "\n", "", "sort_mask", "=", "np", ".", "argsort", "(", "samples", "[", "self", ".", "discrepancy_name", "]", ",", "axis", "=", "0", ")", ".", "ravel", "(", ")", "\n", "for", "k", ",", "v", "in", "samples", ".", "items", "(", ")", ":", "\n", "            ", "v", "[", ":", "]", "=", "v", "[", "sort_mask", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection._update_state_meta": [[566, 572], ["[].item", "min"], "methods", ["None"], ["", "", "def", "_update_state_meta", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update `n_sim`, `threshold`, and `accept_rate`.\"\"\"", "\n", "o", "=", "self", ".", "objective", "\n", "s", "=", "self", ".", "state", "\n", "s", "[", "'threshold'", "]", "=", "s", "[", "'samples'", "]", "[", "self", ".", "discrepancy_name", "]", "[", "o", "[", "'n_samples'", "]", "-", "1", "]", ".", "item", "(", ")", "\n", "s", "[", "'accept_rate'", "]", "=", "min", "(", "1", ",", "o", "[", "'n_samples'", "]", "/", "s", "[", "'n_sim'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection._update_objective_n_batches": [[573, 597], ["logger.debug", "parameter_inference.Rejection.objective.get", "parameter_inference.Rejection.objective.get", "numpy.sum", "math.ceil", "int"], "methods", ["None"], ["", "def", "_update_objective_n_batches", "(", "self", ")", ":", "\n", "# Only in the case that the threshold is used", "\n", "        ", "if", "self", ".", "objective", ".", "get", "(", "'threshold'", ")", "is", "None", ":", "\n", "            ", "return", "\n", "\n", "", "s", "=", "self", ".", "state", "\n", "t", ",", "n_samples", "=", "[", "self", ".", "objective", ".", "get", "(", "k", ")", "for", "k", "in", "(", "'threshold'", ",", "'n_samples'", ")", "]", "\n", "\n", "# noinspection PyTypeChecker", "\n", "n_acceptable", "=", "np", ".", "sum", "(", "s", "[", "'samples'", "]", "[", "self", ".", "discrepancy_name", "]", "<=", "t", ")", "if", "s", "[", "'samples'", "]", "else", "0", "\n", "if", "n_acceptable", "==", "0", ":", "\n", "# No acceptable samples found yet, increase n_batches of objective by one in", "\n", "# order to keep simulating", "\n", "            ", "n_batches", "=", "self", ".", "objective", "[", "'n_batches'", "]", "+", "1", "\n", "", "else", ":", "\n", "            ", "accept_rate_t", "=", "n_acceptable", "/", "s", "[", "'n_sim'", "]", "\n", "# Add some margin to estimated n_batches. One could also use confidence", "\n", "# bounds here", "\n", "margin", "=", ".2", "*", "self", ".", "batch_size", "*", "int", "(", "n_acceptable", "<", "n_samples", ")", "\n", "n_batches", "=", "(", "n_samples", "/", "accept_rate_t", "+", "margin", ")", "/", "self", ".", "batch_size", "\n", "n_batches", "=", "ceil", "(", "n_batches", ")", "\n", "\n", "", "self", ".", "objective", "[", "'n_batches'", "]", "=", "n_batches", "\n", "logger", ".", "debug", "(", "'Estimated objective n_batches=%d'", "%", "self", ".", "objective", "[", "'n_batches'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Rejection.plot_state": [[598, 615], ["options.get", "elfi.plot_sample", "elfi.plot_sample", "elfi.plot_sample", "elfi.plot_sample", "displays.append", "display.HTML"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.plot_sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.plot_sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.plot_sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.plot_sample", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "plot_state", "(", "self", ",", "**", "options", ")", ":", "\n", "        ", "\"\"\"Plot the current state of the inference algorithm.\n\n        This feature is still experimental and only supports 1d or 2d cases.\n        \"\"\"", "\n", "displays", "=", "[", "]", "\n", "if", "options", ".", "get", "(", "'interactive'", ")", ":", "\n", "            ", "from", "IPython", "import", "display", "\n", "displays", ".", "append", "(", "\n", "display", ".", "HTML", "(", "'<span>Threshold: {}</span>'", ".", "format", "(", "self", ".", "state", "[", "'threshold'", "]", ")", ")", ")", "\n", "\n", "", "visin", ".", "plot_sample", "(", "\n", "self", ".", "state", "[", "'samples'", "]", ",", "\n", "nodes", "=", "self", ".", "parameter_names", ",", "\n", "n", "=", "self", ".", "objective", "[", "'n_samples'", "]", ",", "\n", "displays", "=", "displays", ",", "\n", "**", "options", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC.__init__": [[620, 645], ["parameter_inference.SMC._resolve_model", "parameter_inference.ParameterInference.__init__", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._resolve_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "discrepancy_name", "=", "None", ",", "output_names", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize the SMC-ABC sampler.\n\n        Parameters\n        ----------\n        model : ElfiModel or NodeReference\n        discrepancy_name : str, NodeReference, optional\n            Only needed if model is an ElfiModel\n        output_names : list, optional\n            Additional outputs from the model to be included in the inference result, e.g.\n            corresponding summaries to the acquired samples\n        kwargs:\n            See InferenceMethod\n\n        \"\"\"", "\n", "model", ",", "discrepancy_name", "=", "self", ".", "_resolve_model", "(", "model", ",", "discrepancy_name", ")", "\n", "\n", "super", "(", "SMC", ",", "self", ")", ".", "__init__", "(", "model", ",", "output_names", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "_prior", "=", "ModelPrior", "(", "self", ".", "model", ")", "\n", "self", ".", "discrepancy_name", "=", "discrepancy_name", "\n", "self", ".", "state", "[", "'round'", "]", "=", "0", "\n", "self", ".", "_populations", "=", "[", "]", "\n", "self", ".", "_rejection", "=", "None", "\n", "self", ".", "_round_random_state", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC.set_objective": [[646, 655], ["parameter_inference.SMC.objective.update", "parameter_inference.SMC._init_new_round", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._init_new_round"], ["", "def", "set_objective", "(", "self", ",", "n_samples", ",", "thresholds", ")", ":", "\n", "        ", "\"\"\"Set the objective of the inference.\"\"\"", "\n", "self", ".", "objective", ".", "update", "(", "\n", "dict", "(", "\n", "n_samples", "=", "n_samples", ",", "\n", "n_batches", "=", "self", ".", "max_parallel_batches", ",", "\n", "round", "=", "len", "(", "thresholds", ")", "-", "1", ",", "\n", "thresholds", "=", "thresholds", ")", ")", "\n", "self", ".", "_init_new_round", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC.extract_result": [[656, 672], ["parameter_inference.SMC._extract_population", "elfi.methods.results.SmcSample", "elfi.methods.results.SmcSample", "elfi.methods.results.SmcSample", "elfi.methods.results.SmcSample", "parameter_inference.SMC._extract_result_kwargs", "parameter_inference.SMC._populations.copy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._extract_population", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Sampler._extract_result_kwargs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "def", "extract_result", "(", "self", ")", ":", "\n", "        ", "\"\"\"Extract the result from the current state.\n\n        Returns\n        -------\n        SmcSample\n\n        \"\"\"", "\n", "# Extract information from the population", "\n", "pop", "=", "self", ".", "_extract_population", "(", ")", "\n", "return", "SmcSample", "(", "\n", "outputs", "=", "pop", ".", "outputs", ",", "\n", "populations", "=", "self", ".", "_populations", ".", "copy", "(", ")", "+", "[", "pop", "]", ",", "\n", "weights", "=", "pop", ".", "weights", ",", "\n", "threshold", "=", "pop", ".", "threshold", ",", "\n", "**", "self", ".", "_extract_result_kwargs", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC.update": [[673, 695], ["parameter_inference.ParameterInference.update", "parameter_inference.SMC._rejection.update", "parameter_inference.SMC._update_objective", "parameter_inference.SMC.batches.cancel_pending", "parameter_inference.SMC._populations.append", "parameter_inference.SMC._init_new_round", "parameter_inference.SMC._extract_population"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._update_objective", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.cancel_pending", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._init_new_round", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._extract_population"], ["", "def", "update", "(", "self", ",", "batch", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Update the inference state with a new batch.\n\n        Parameters\n        ----------\n        batch : dict\n            dict with `self.outputs` as keys and the corresponding outputs for the batch\n            as values\n        batch_index : int\n\n        \"\"\"", "\n", "super", "(", "SMC", ",", "self", ")", ".", "update", "(", "batch", ",", "batch_index", ")", "\n", "self", ".", "_rejection", ".", "update", "(", "batch", ",", "batch_index", ")", "\n", "\n", "if", "self", ".", "_rejection", ".", "finished", ":", "\n", "            ", "self", ".", "batches", ".", "cancel_pending", "(", ")", "\n", "if", "self", ".", "state", "[", "'round'", "]", "<", "self", ".", "objective", "[", "'round'", "]", ":", "\n", "                ", "self", ".", "_populations", ".", "append", "(", "self", ".", "_extract_population", "(", ")", ")", "\n", "self", ".", "state", "[", "'round'", "]", "+=", "1", "\n", "self", ".", "_init_new_round", "(", ")", "\n", "\n", "", "", "self", ".", "_update_objective", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC.prepare_new_batch": [[696, 722], ["elfi.methods.utils.GMDistribution.rvs", "elfi.methods.utils.GMDistribution.rvs", "elfi.methods.utils.GMDistribution.rvs", "elfi.methods.utils.GMDistribution.rvs", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch"], ["", "def", "prepare_new_batch", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Prepare values for a new batch.\n\n        Parameters\n        ----------\n        batch_index : int\n            next batch_index to be submitted\n\n        Returns\n        -------\n        batch : dict or None\n            Keys should match to node names in the model. These values will override any\n            default values or operations in those nodes.\n\n        \"\"\"", "\n", "if", "self", ".", "state", "[", "'round'", "]", "==", "0", ":", "\n", "# Use the actual prior", "\n", "            ", "return", "\n", "\n", "# Sample from the proposal, condition on actual prior", "\n", "", "params", "=", "GMDistribution", ".", "rvs", "(", "*", "self", ".", "_gm_params", ",", "size", "=", "self", ".", "batch_size", ",", "\n", "prior_logpdf", "=", "self", ".", "_prior", ".", "logpdf", ",", "\n", "random_state", "=", "self", ".", "_round_random_state", ")", "\n", "\n", "batch", "=", "arr2d_to_batch", "(", "params", ",", "self", ".", "parameter_names", ")", "\n", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._init_new_round": [[723, 743], ["logger.info", "numpy.random.RandomState", "parameter_inference.Rejection", "parameter_inference.SMC._rejection.set_objective", "elfi.loader.get_sub_seed", "elfi.loader.get_sub_seed", "elfi.loader.get_sub_seed", "elfi.loader.get_sub_seed"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.set_objective", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed"], ["", "def", "_init_new_round", "(", "self", ")", ":", "\n", "        ", "round", "=", "self", ".", "state", "[", "'round'", "]", "\n", "\n", "dashes", "=", "'-'", "*", "16", "\n", "logger", ".", "info", "(", "'%s Starting round %d %s'", "%", "(", "dashes", ",", "round", ",", "dashes", ")", ")", "\n", "\n", "# Get a subseed for this round for ensuring consistent results for the round", "\n", "seed", "=", "self", ".", "seed", "if", "round", "==", "0", "else", "get_sub_seed", "(", "self", ".", "seed", ",", "round", ")", "\n", "self", ".", "_round_random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "\n", "self", ".", "_rejection", "=", "Rejection", "(", "\n", "self", ".", "model", ",", "\n", "discrepancy_name", "=", "self", ".", "discrepancy_name", ",", "\n", "output_names", "=", "self", ".", "output_names", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "seed", "=", "seed", ",", "\n", "max_parallel_batches", "=", "self", ".", "max_parallel_batches", ")", "\n", "\n", "self", ".", "_rejection", ".", "set_objective", "(", "\n", "self", ".", "objective", "[", "'n_samples'", "]", ",", "threshold", "=", "self", ".", "current_population_threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._extract_population": [[744, 752], ["parameter_inference.SMC._rejection.extract_result", "parameter_inference.SMC._compute_weights_and_cov"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.extract_result", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._compute_weights_and_cov"], ["", "def", "_extract_population", "(", "self", ")", ":", "\n", "        ", "sample", "=", "self", ".", "_rejection", ".", "extract_result", "(", ")", "\n", "# Append the sample object", "\n", "sample", ".", "method_name", "=", "\"Rejection within SMC-ABC\"", "\n", "w", ",", "cov", "=", "self", ".", "_compute_weights_and_cov", "(", "sample", ")", "\n", "sample", ".", "weights", "=", "w", "\n", "sample", ".", "meta", "[", "'cov'", "]", "=", "cov", "\n", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._compute_weights_and_cov": [[753, 778], ["numpy.column_stack", "tuple", "elfi.methods.utils.GMDistribution.logpdf", "elfi.methods.utils.GMDistribution.logpdf", "elfi.methods.utils.GMDistribution.logpdf", "elfi.methods.utils.GMDistribution.logpdf", "parameter_inference.SMC._prior.logpdf", "numpy.exp", "numpy.ones", "numpy.count_nonzero", "RuntimeError", "numpy.diag", "numpy.all", "logger.warning", "numpy.diag", "elfi.methods.utils.weighted_var", "elfi.methods.utils.weighted_var", "elfi.methods.utils.weighted_var", "elfi.methods.utils.weighted_var", "numpy.isfinite", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.weighted_var", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.weighted_var", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.weighted_var", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.weighted_var"], ["", "def", "_compute_weights_and_cov", "(", "self", ",", "pop", ")", ":", "\n", "        ", "params", "=", "np", ".", "column_stack", "(", "tuple", "(", "[", "pop", ".", "outputs", "[", "p", "]", "for", "p", "in", "self", ".", "parameter_names", "]", ")", ")", "\n", "\n", "if", "self", ".", "_populations", ":", "\n", "            ", "q_logpdf", "=", "GMDistribution", ".", "logpdf", "(", "params", ",", "*", "self", ".", "_gm_params", ")", "\n", "p_logpdf", "=", "self", ".", "_prior", ".", "logpdf", "(", "params", ")", "\n", "w", "=", "np", ".", "exp", "(", "p_logpdf", "-", "q_logpdf", ")", "\n", "", "else", ":", "\n", "            ", "w", "=", "np", ".", "ones", "(", "pop", ".", "n_samples", ")", "\n", "\n", "", "if", "np", ".", "count_nonzero", "(", "w", ")", "==", "0", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"All sample weights are zero. If you are using a prior \"", "\n", "\"with a bounded support, this may be caused by specifying \"", "\n", "\"a too small sample size.\"", ")", "\n", "\n", "# New covariance", "\n", "", "cov", "=", "2", "*", "np", ".", "diag", "(", "weighted_var", "(", "params", ",", "w", ")", ")", "\n", "\n", "if", "not", "np", ".", "all", "(", "np", ".", "isfinite", "(", "cov", ")", ")", ":", "\n", "            ", "logger", ".", "warning", "(", "\"Could not estimate the sample covariance. This is often \"", "\n", "\"caused by majority of the sample weights becoming zero.\"", "\n", "\"Falling back to using unit covariance.\"", ")", "\n", "cov", "=", "np", ".", "diag", "(", "np", ".", "ones", "(", "params", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "return", "w", ",", "cov", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._update_objective": [[779, 783], ["sum"], "methods", ["None"], ["", "def", "_update_objective", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update the objective n_batches.\"\"\"", "\n", "n_batches", "=", "sum", "(", "[", "pop", ".", "n_batches", "for", "pop", "in", "self", ".", "_populations", "]", ")", "\n", "self", ".", "objective", "[", "'n_batches'", "]", "=", "n_batches", "+", "self", ".", "_rejection", ".", "objective", "[", "'n_batches'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC._gm_params": [[784, 789], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "_gm_params", "(", "self", ")", ":", "\n", "        ", "sample", "=", "self", ".", "_populations", "[", "-", "1", "]", "\n", "params", "=", "sample", ".", "samples_array", "\n", "return", "params", ",", "sample", ".", "cov", ",", "sample", ".", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.SMC.current_population_threshold": [[790, 794], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "current_population_threshold", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the threshold for current population.\"\"\"", "\n", "return", "self", ".", "objective", "[", "'thresholds'", "]", "[", "self", ".", "state", "[", "'round'", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.__init__": [[799, 886], ["parameter_inference.BayesianOptimization._resolve_model", "parameter_inference.ParameterInference.__init__", "parameter_inference.BayesianOptimization._resolve_initial_evidence", "list", "elfi.methods.bo.gpy_regression.GPyRegression", "elfi.methods.bo.gpy_regression.GPyRegression", "elfi.methods.bo.gpy_regression.GPyRegression", "elfi.methods.bo.gpy_regression.GPyRegression", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "len", "parameter_inference.BayesianOptimization.target_model.update", "elfi.methods.bo.acquisition.LCBSC", "elfi.methods.bo.acquisition.LCBSC", "elfi.methods.bo.acquisition.LCBSC", "elfi.methods.bo.acquisition.LCBSC", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference._resolve_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._resolve_initial_evidence", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update"], ["def", "__init__", "(", "self", ",", "\n", "model", ",", "\n", "target_name", "=", "None", ",", "\n", "bounds", "=", "None", ",", "\n", "initial_evidence", "=", "None", ",", "\n", "update_interval", "=", "10", ",", "\n", "target_model", "=", "None", ",", "\n", "acquisition_method", "=", "None", ",", "\n", "acq_noise_var", "=", "0", ",", "\n", "exploration_rate", "=", "10", ",", "\n", "batch_size", "=", "1", ",", "\n", "batches_per_acquisition", "=", "None", ",", "\n", "asynchr", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize Bayesian optimization.\n\n        Parameters\n        ----------\n        model : ElfiModel or NodeReference\n        target_name : str or NodeReference\n            Only needed if model is an ElfiModel\n        bounds : dict, optional\n            The region where to estimate the posterior for each parameter in\n            model.parameters: dict('parameter_name':(lower, upper), ... )`. Not used if\n            custom target_model is given.\n        initial_evidence : int, dict, optional\n            Number of initial evidence or a precomputed batch dict containing parameter\n            and discrepancy values. Default value depends on the dimensionality.\n        update_interval : int, optional\n            How often to update the GP hyperparameters of the target_model\n        target_model : GPyRegression, optional\n        acquisition_method : Acquisition, optional\n            Method of acquiring evidence points. Defaults to LCBSC.\n        acq_noise_var : float or np.array, optional\n            Variance(s) of the noise added in the default LCBSC acquisition method.\n            If an array, should be 1d specifying the variance for each dimension.\n        exploration_rate : float, optional\n            Exploration rate of the acquisition method\n        batch_size : int, optional\n            Elfi batch size. Defaults to 1.\n        batches_per_acquisition : int, optional\n            How many batches will be requested from the acquisition function at one go.\n            Defaults to max_parallel_batches.\n        asynchr : bool, optional\n            Allow acquisitions to be made asynchronously, i.e. do not wait for all the\n            results from the previous acquisition before making the next. This can be more\n            efficient with a large amount of workers (e.g. in cluster environments) but\n            forgoes the guarantee for the exactly same result with the same initial\n            conditions (e.g. the seed). Default False.\n        **kwargs\n\n        \"\"\"", "\n", "model", ",", "target_name", "=", "self", ".", "_resolve_model", "(", "model", ",", "target_name", ")", "\n", "output_names", "=", "[", "target_name", "]", "+", "model", ".", "parameter_names", "\n", "super", "(", "BayesianOptimization", ",", "self", ")", ".", "__init__", "(", "\n", "model", ",", "output_names", ",", "batch_size", "=", "batch_size", ",", "**", "kwargs", ")", "\n", "\n", "target_model", "=", "target_model", "or", "GPyRegression", "(", "self", ".", "model", ".", "parameter_names", ",", "bounds", "=", "bounds", ")", "\n", "\n", "self", ".", "target_name", "=", "target_name", "\n", "self", ".", "target_model", "=", "target_model", "\n", "\n", "n_precomputed", "=", "0", "\n", "n_initial", ",", "precomputed", "=", "self", ".", "_resolve_initial_evidence", "(", "initial_evidence", ")", "\n", "if", "precomputed", "is", "not", "None", ":", "\n", "            ", "params", "=", "batch_to_arr2d", "(", "precomputed", ",", "self", ".", "parameter_names", ")", "\n", "n_precomputed", "=", "len", "(", "params", ")", "\n", "self", ".", "target_model", ".", "update", "(", "params", ",", "precomputed", "[", "target_name", "]", ")", "\n", "\n", "", "self", ".", "batches_per_acquisition", "=", "batches_per_acquisition", "or", "self", ".", "max_parallel_batches", "\n", "self", ".", "acquisition_method", "=", "acquisition_method", "or", "LCBSC", "(", "self", ".", "target_model", ",", "\n", "prior", "=", "ModelPrior", "(", "self", ".", "model", ")", ",", "\n", "noise_var", "=", "acq_noise_var", ",", "\n", "exploration_rate", "=", "exploration_rate", ",", "\n", "seed", "=", "self", ".", "seed", ")", "\n", "\n", "self", ".", "n_initial_evidence", "=", "n_initial", "\n", "self", ".", "n_precomputed_evidence", "=", "n_precomputed", "\n", "self", ".", "update_interval", "=", "update_interval", "\n", "self", ".", "asynchr", "=", "asynchr", "\n", "self", ".", "it", "=", "1", "\n", "self", ".", "mses", "=", "list", "(", ")", "\n", "\n", "self", ".", "state", "[", "'n_evidence'", "]", "=", "self", ".", "n_precomputed_evidence", "\n", "# Important change #0", "\n", "self", ".", "state", "[", "'last_GP_update'", "]", "=", "self", ".", "n_initial_evidence", "-", "self", ".", "update_interval", "# - self.update_interval", "\n", "self", ".", "state", "[", "'acquisition'", "]", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._resolve_initial_evidence": [[887, 915], ["max", "elfi.methods.utils.ceil_to_batch_size", "elfi.methods.utils.ceil_to_batch_size", "elfi.methods.utils.ceil_to_batch_size", "elfi.methods.utils.ceil_to_batch_size", "isinstance", "ValueError", "logger.warning", "elfi.methods.utils.ceil_to_batch_size", "elfi.methods.utils.ceil_to_batch_size", "elfi.methods.utils.ceil_to_batch_size", "elfi.methods.utils.ceil_to_batch_size", "int", "len", "logger.warning"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size"], ["", "def", "_resolve_initial_evidence", "(", "self", ",", "initial_evidence", ")", ":", "\n", "# Some sensibility limit for starting GP regression", "\n", "        ", "precomputed", "=", "None", "\n", "n_required", "=", "max", "(", "10", ",", "2", "**", "self", ".", "target_model", ".", "input_dim", "+", "1", ")", "\n", "n_required", "=", "ceil_to_batch_size", "(", "n_required", ",", "self", ".", "batch_size", ")", "\n", "\n", "if", "initial_evidence", "is", "None", ":", "\n", "            ", "n_initial_evidence", "=", "n_required", "\n", "", "elif", "isinstance", "(", "initial_evidence", ",", "(", "int", ",", "np", ".", "int", ",", "float", ")", ")", ":", "\n", "            ", "n_initial_evidence", "=", "int", "(", "initial_evidence", ")", "\n", "", "else", ":", "\n", "            ", "precomputed", "=", "initial_evidence", "\n", "n_initial_evidence", "=", "len", "(", "precomputed", "[", "self", ".", "target_name", "]", ")", "\n", "\n", "", "if", "n_initial_evidence", "<", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Number of initial evidence must be positive or zero '", "\n", "'(was {})'", ".", "format", "(", "initial_evidence", ")", ")", "\n", "", "elif", "n_initial_evidence", "<", "n_required", ":", "\n", "            ", "logger", ".", "warning", "(", "'We recommend having at least {} initialization points for '", "\n", "'the initialization (now {})'", ".", "format", "(", "n_required", ",", "n_initial_evidence", ")", ")", "\n", "\n", "", "if", "precomputed", "is", "None", "and", "(", "n_initial_evidence", "%", "self", ".", "batch_size", "!=", "0", ")", ":", "\n", "            ", "logger", ".", "warning", "(", "'Number of initial_evidence %d is not divisible by '", "\n", "'batch_size %d. Rounding it up...'", "%", "(", "n_initial_evidence", ",", "\n", "self", ".", "batch_size", ")", ")", "\n", "n_initial_evidence", "=", "ceil_to_batch_size", "(", "n_initial_evidence", ",", "self", ".", "batch_size", ")", "\n", "\n", "", "return", "n_initial_evidence", ",", "precomputed", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.n_evidence": [[916, 920], ["parameter_inference.BayesianOptimization.state.get"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_evidence", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of acquired evidence points.\"\"\"", "\n", "return", "self", ".", "state", ".", "get", "(", "'n_evidence'", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.acq_batch_size": [[921, 925], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "acq_batch_size", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the total number of acquisition per iteration.\"\"\"", "\n", "return", "self", ".", "batch_size", "*", "self", ".", "batches_per_acquisition", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.set_objective": [[926, 946], ["parameter_inference.BayesianOptimization.objective.get", "logger.warning"], "methods", ["None"], ["", "def", "set_objective", "(", "self", ",", "n_evidence", "=", "None", ")", ":", "\n", "        ", "\"\"\"Set objective for inference.\n\n        You can continue BO by giving a larger n_evidence.\n\n        Parameters\n        ----------\n        n_evidence : int\n            Number of total evidence for the GP fitting. This includes any initial\n            evidence.\n\n        \"\"\"", "\n", "if", "n_evidence", "is", "None", ":", "\n", "            ", "n_evidence", "=", "self", ".", "objective", ".", "get", "(", "'n_evidence'", ",", "self", ".", "n_evidence", ")", "\n", "\n", "", "if", "n_evidence", "<", "self", ".", "n_evidence", ":", "\n", "            ", "logger", ".", "warning", "(", "'Requesting less evidence than there already exists'", ")", "\n", "\n", "", "self", ".", "objective", "[", "'n_evidence'", "]", "=", "n_evidence", "\n", "self", ".", "objective", "[", "'n_sim'", "]", "=", "n_evidence", "-", "self", ".", "n_precomputed_evidence", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.extract_result": [[947, 964], ["elfi.methods.bo.utils.stochastic_optimization", "elfi.methods.bo.utils.stochastic_optimization", "elfi.methods.bo.utils.stochastic_optimization", "elfi.methods.bo.utils.stochastic_optimization", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.results.OptimizationResult", "elfi.methods.results.OptimizationResult", "elfi.methods.results.OptimizationResult", "elfi.methods.results.OptimizationResult", "parameter_inference.BayesianOptimization._extract_result_kwargs"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.stochastic_optimization", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.stochastic_optimization", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.stochastic_optimization", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.stochastic_optimization", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.Sampler._extract_result_kwargs"], ["", "def", "extract_result", "(", "self", ")", ":", "\n", "        ", "\"\"\"Extract the result from the current state.\n\n        Returns\n        -------\n        OptimizationResult\n\n        \"\"\"", "\n", "x_min", ",", "_", "=", "stochastic_optimization", "(", "\n", "self", ".", "target_model", ".", "predict_mean", ",", "self", ".", "target_model", ".", "bounds", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n", "batch_min", "=", "arr2d_to_batch", "(", "x_min", ",", "self", ".", "parameter_names", ")", "\n", "outputs", "=", "arr2d_to_batch", "(", "self", ".", "target_model", ".", "X", ",", "self", ".", "parameter_names", ")", "\n", "outputs", "[", "self", ".", "target_name", "]", "=", "self", ".", "target_model", ".", "Y", "\n", "\n", "return", "OptimizationResult", "(", "\n", "x_min", "=", "batch_min", ",", "outputs", "=", "outputs", ",", "**", "self", ".", "_extract_result_kwargs", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.update": [[965, 991], ["parameter_inference.ParameterInference.update", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "parameter_inference.BayesianOptimization._report_batch", "parameter_inference.BayesianOptimization._should_optimize", "parameter_inference.BayesianOptimization.target_model.update", "print", "str", "str"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._report_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._should_optimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update"], ["", "def", "update", "(", "self", ",", "batch", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"Update the GP regression model of the target node with a new batch.\n\n        Parameters\n        ----------\n        batch : dict\n            dict with `self.outputs` as keys and the corresponding outputs for the batch\n            as values\n        batch_index : int\n\n        \"\"\"", "\n", "super", "(", "BayesianOptimization", ",", "self", ")", ".", "update", "(", "batch", ",", "batch_index", ")", "\n", "self", ".", "state", "[", "'n_evidence'", "]", "+=", "self", ".", "batch_size", "\n", "\n", "params", "=", "batch_to_arr2d", "(", "batch", ",", "self", ".", "parameter_names", ")", "\n", "self", ".", "_report_batch", "(", "batch_index", ",", "params", ",", "batch", "[", "self", ".", "target_name", "]", ")", "\n", "\n", "optimize", "=", "self", ".", "_should_optimize", "(", ")", "\n", "self", ".", "target_model", ".", "update", "(", "params", ",", "batch", "[", "self", ".", "target_name", "]", ",", "optimize", ")", "\n", "\n", "print", "(", "str", "(", "self", ".", "it", ")", "+", "', optimize = '", "+", "str", "(", "optimize", ")", ")", "\n", "self", ".", "it", "+=", "1", "\n", "\n", "if", "optimize", ":", "\n", "# Important change #1", "\n", "            ", "self", ".", "state", "[", "'last_GP_update'", "]", "=", "self", ".", "state", "[", "'n_evidence'", "]", "# self.target_model.n_evidence", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.prepare_new_batch": [[993, 1026], ["parameter_inference.BayesianOptimization._get_acquisition_index", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "elfi.methods.utils.arr2d_to_batch", "len", "parameter_inference.BayesianOptimization.acquisition_method.acquire"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._get_acquisition_index", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire"], ["", "", "def", "prepare_new_batch", "(", "self", ",", "batch_index", ",", "points", "=", "None", ")", ":", "\n", "        ", "\"\"\"Prepare values for a new batch.\n\n        Parameters\n        ----------\n        batch_index : int\n            next batch_index to be submitted\n\n        Returns\n        -------\n        batch : dict or None\n            Keys should match to node names in the model. These values will override any\n            default values or operations in those nodes.\n\n        \"\"\"", "\n", "t", "=", "self", ".", "_get_acquisition_index", "(", "batch_index", ")", "\n", "\n", "# Check if we still should take initial points from the prior", "\n", "if", "t", "<", "0", ":", "\n", "            ", "return", "\n", "\n", "", "if", "points", "is", "None", ":", "\n", "            ", "points", "=", "self", ".", "acq_batch_size", "\n", "\n", "# Take the next batch from the acquisition_batch", "\n", "", "acquisition", "=", "self", ".", "state", "[", "'acquisition'", "]", "\n", "if", "len", "(", "acquisition", ")", "==", "0", ":", "\n", "            ", "acquisition", "=", "self", ".", "acquisition_method", ".", "acquire", "(", "points", ",", "t", "=", "t", ")", "\n", "\n", "", "batch", "=", "arr2d_to_batch", "(", "acquisition", "[", ":", "self", ".", "batch_size", "]", ",", "self", ".", "parameter_names", ")", "\n", "self", ".", "state", "[", "'acquisition'", "]", "=", "acquisition", "[", "self", ".", "batch_size", ":", "]", "\n", "\n", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._get_acquisition_index": [[1027, 1034], ["None"], "methods", ["None"], ["", "def", "_get_acquisition_index", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "acq_batch_size", "=", "self", ".", "batch_size", "*", "self", ".", "batches_per_acquisition", "\n", "initial_offset", "=", "self", ".", "n_initial_evidence", "-", "self", ".", "n_precomputed_evidence", "\n", "starting_sim_index", "=", "self", ".", "batch_size", "*", "batch_index", "\n", "\n", "t", "=", "(", "starting_sim_index", "-", "initial_offset", ")", "//", "acq_batch_size", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._n_submitted_evidence": [[1036, 1039], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "_n_submitted_evidence", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "batches", ".", "total", "*", "self", ".", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._allow_submit": [[1040, 1059], ["parameter_inference.BayesianOptimization._get_acquisition_index", "len", "parameter_inference.ParameterInference._allow_submit"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._get_acquisition_index", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._allow_submit"], ["", "def", "_allow_submit", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "if", "not", "super", "(", "BayesianOptimization", ",", "self", ")", ".", "_allow_submit", "(", "batch_index", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "if", "self", ".", "asynchr", ":", "\n", "            ", "return", "True", "\n", "\n", "# Allow submitting freely as long we are still submitting initial evidence", "\n", "", "t", "=", "self", ".", "_get_acquisition_index", "(", "batch_index", ")", "\n", "if", "t", "<", "0", ":", "\n", "            ", "return", "True", "\n", "\n", "# Do not allow acquisition until previous acquisitions are ready (as well", "\n", "# as all initial acquisitions)", "\n", "", "acquisitions_left", "=", "len", "(", "self", ".", "state", "[", "'acquisition'", "]", ")", "\n", "if", "acquisitions_left", "==", "0", "and", "self", ".", "batches", ".", "has_pending", ":", "\n", "            ", "return", "False", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._should_optimize": [[1060, 1065], ["None"], "methods", ["None"], ["", "def", "_should_optimize", "(", "self", ")", ":", "\n", "# Important change #2", "\n", "        ", "current", "=", "self", ".", "state", "[", "'n_evidence'", "]", "#  self.target_model.n_evidence ", "\n", "next_update", "=", "self", ".", "state", "[", "'last_GP_update'", "]", "+", "self", ".", "update_interval", "\n", "return", "current", ">=", "self", ".", "n_initial_evidence", "and", "current", ">=", "next_update", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization._report_batch": [[1066, 1072], ["range", "logger.debug", "distances[].item"], "methods", ["None"], ["", "def", "_report_batch", "(", "self", ",", "batch_index", ",", "params", ",", "distances", ")", ":", "\n", "        ", "str", "=", "\"Received batch {}:\\n\"", ".", "format", "(", "batch_index", ")", "\n", "fill", "=", "6", "*", "' '", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "            ", "str", "+=", "\"{}{} at {}\\n\"", ".", "format", "(", "fill", ",", "distances", "[", "i", "]", ".", "item", "(", ")", ",", "params", "[", "i", "]", ")", "\n", "", "logger", ".", "debug", "(", "str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.plot_state": [[1073, 1126], ["matplotlib.gcf", "elfi.draw_contour", "elfi.draw_contour", "elfi.draw_contour", "elfi.draw_contour", "options.get", "options.get", "elfi._update_interactive", "elfi._update_interactive", "elfi._update_interactive", "elfi._update_interactive", "elfi.draw_contour", "elfi.draw_contour", "elfi.draw_contour", "elfi.draw_contour", "options.get", "len", "matplotlib.subplots", "displays.insert", "parameter_inference.BayesianOptimization.acquisition_method.evaluate", "matplotlib.close", "len", "matplotlib.gcf.axes[].scatter", "display.HTML", "len", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive._update_interactive", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive._update_interactive", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive._update_interactive", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive._update_interactive", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.visualization.interactive.draw_contour", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close"], ["", "def", "plot_state", "(", "self", ",", "**", "options", ")", ":", "\n", "        ", "\"\"\"Plot the GP surface.\n        This feature is still experimental and currently supports only 2D cases.\n        \"\"\"", "\n", "f", "=", "plt", ".", "gcf", "(", ")", "\n", "if", "len", "(", "f", ".", "axes", ")", "<", "2", ":", "\n", "            ", "f", ",", "_", "=", "plt", ".", "subplots", "(", "1", ",", "2", ",", "figsize", "=", "(", "13", ",", "6", ")", ",", "sharex", "=", "'row'", ",", "sharey", "=", "'row'", ")", "\n", "\n", "", "gp", "=", "self", ".", "target_model", "\n", "\n", "# Draw the GP surface", "\n", "visin", ".", "draw_contour", "(", "\n", "gp", ".", "predict_mean", ",", "\n", "gp", ".", "bounds", ",", "\n", "self", ".", "parameter_names", ",", "\n", "title", "=", "'GP target surface'", ",", "\n", "points", "=", "gp", ".", "X", ",", "\n", "axes", "=", "f", ".", "axes", "[", "0", "]", ",", "\n", "**", "options", ")", "\n", "\n", "# Draw the latest acquisitions", "\n", "if", "options", ".", "get", "(", "'interactive'", ")", ":", "\n", "            ", "point", "=", "gp", ".", "X", "[", "-", "1", ",", ":", "]", "\n", "if", "len", "(", "gp", ".", "X", ")", ">", "1", ":", "\n", "                ", "f", ".", "axes", "[", "1", "]", ".", "scatter", "(", "*", "point", ",", "color", "=", "'red'", ")", "\n", "\n", "", "", "displays", "=", "[", "gp", ".", "_gp", "]", "\n", "\n", "if", "options", ".", "get", "(", "'interactive'", ")", ":", "\n", "            ", "from", "IPython", "import", "display", "\n", "displays", ".", "insert", "(", "\n", "0", ",", "\n", "display", ".", "HTML", "(", "'<span><b>Iteration {}:</b> Acquired {} at {}</span>'", ".", "format", "(", "\n", "len", "(", "gp", ".", "Y", ")", ",", "gp", ".", "Y", "[", "-", "1", "]", "[", "0", "]", ",", "point", ")", ")", ")", "\n", "\n", "# Update", "\n", "", "visin", ".", "_update_interactive", "(", "displays", ",", "options", ")", "\n", "\n", "def", "acq", "(", "x", ")", ":", "\n", "            ", "return", "self", ".", "acquisition_method", ".", "evaluate", "(", "x", ",", "len", "(", "gp", ".", "X", ")", ")", "\n", "\n", "# Draw the acquisition surface", "\n", "", "visin", ".", "draw_contour", "(", "\n", "acq", ",", "\n", "gp", ".", "bounds", ",", "\n", "self", ".", "parameter_names", ",", "\n", "title", "=", "'Acquisition surface'", ",", "\n", "points", "=", "None", ",", "\n", "axes", "=", "f", ".", "axes", "[", "1", "]", ",", "\n", "**", "options", ")", "\n", "\n", "if", "options", ".", "get", "(", "'close'", ")", ":", "\n", "            ", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.plot_discrepancy": [[1128, 1141], ["elfi.plot_discrepancy", "elfi.plot_discrepancy", "elfi.plot_discrepancy", "elfi.plot_discrepancy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.plot_discrepancy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.plot_discrepancy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.plot_discrepancy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.plot_discrepancy"], ["", "", "def", "plot_discrepancy", "(", "self", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Plot acquired parameters vs. resulting discrepancy.\n\n        Parameters\n        ----------\n        axes : plt.Axes or arraylike of plt.Axes\n\n        Return\n        ------\n        axes : np.array of plt.Axes\n\n        \"\"\"", "\n", "return", "vis", ".", "plot_discrepancy", "(", "self", ".", "target_model", ",", "self", ".", "parameter_names", ",", "axes", "=", "axes", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.evaluate_mse": [[1145, 1169], ["elfi.methods.bo.acquisition.UniformAcquisition", "elfi.methods.bo.acquisition.UniformAcquisition", "elfi.methods.bo.acquisition.UniformAcquisition", "elfi.methods.bo.acquisition.UniformAcquisition", "range", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "elfi.methods.utils.batch_to_arr2d", "parameter_inference.BayesianOptimization.target_model.predict_mean().flatten", "parameter_inference.BayesianOptimization.prepare_new_batch", "parameter_inference.BayesianOptimization.batches.submit", "parameter_inference.BayesianOptimization.batches.wait_next", "batch.keys", "parameter_inference.BayesianOptimization.target_model.predict_mean", "numpy.append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BayesianOptimization.prepare_new_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.submit", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.BatchHandler.wait_next", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict_mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "evaluate_mse", "(", "self", ",", "points", "=", "1000", ")", ":", "\n", "        ", "model_acq", "=", "self", ".", "acquisition_method", "\n", "self", ".", "acquisition_method", "=", "UniformAcquisition", "(", "self", ".", "target_model", ")", "\n", "\n", "batch", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "0", ",", "points", "//", "self", ".", "batch_size", ")", ":", "\n", "            ", "next_batch", "=", "self", ".", "prepare_new_batch", "(", "self", ".", "batches", ".", "next_index", ",", "points", ")", "\n", "self", ".", "batches", ".", "submit", "(", "next_batch", ")", "\n", "t_batch", ",", "batch_index", "=", "self", ".", "batches", ".", "wait_next", "(", ")", "\n", "\n", "if", "not", "batch", ":", "\n", "                ", "batch", "=", "t_batch", "\n", "", "else", ":", "\n", "                ", "for", "key", "in", "batch", ".", "keys", "(", ")", ":", "\n", "                    ", "batch", "[", "key", "]", "=", "np", ".", "append", "(", "batch", "[", "key", "]", ",", "t_batch", "[", "key", "]", ")", "\n", "\n", "", "", "", "self", ".", "acquisition_method", "=", "model_acq", "\n", "params", "=", "batch_to_arr2d", "(", "batch", ",", "self", ".", "parameter_names", ")", "\n", "\n", "true_y", "=", "batch", "[", "self", ".", "target_name", "]", "\n", "pred_y", "=", "self", ".", "target_model", ".", "predict_mean", "(", "params", ")", ".", "flatten", "(", ")", "\n", "\n", "# print(((true_y - pred_y)**2).mean())", "\n", "return", "(", "(", "true_y", "-", "pred_y", ")", "**", "2", ")", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.fit": [[1188, 1213], ["logger.info", "parameter_inference.BOLFI.infer", "ValueError", "parameter_inference.BOLFI.extract_posterior"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.infer", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.extract_posterior"], ["def", "fit", "(", "self", ",", "n_evidence", ",", "threshold", "=", "None", ",", "bar", "=", "True", ")", ":", "\n", "        ", "\"\"\"Fit the surrogate model.\n\n        Generates a regression model for the discrepancy given the parameters.\n\n        Currently only Gaussian processes are supported as surrogate models.\n\n        Parameters\n        ----------\n        n_evidence : int, required\n            Number of evidence for fitting\n        threshold : float, optional\n            Discrepancy threshold for creating the posterior (log with log discrepancy).\n        bar : bool, optional\n            Flag to remove (False) the progress bar from output.\n\n        \"\"\"", "\n", "logger", ".", "info", "(", "\"BOLFI: Fitting the surrogate model...\"", ")", "\n", "\n", "if", "n_evidence", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "'You must specify the number of evidence (n_evidence) for the fitting'", ")", "\n", "\n", "", "self", ".", "infer", "(", "n_evidence", ",", "bar", "=", "bar", ")", "\n", "return", "self", ".", "extract_posterior", "(", "threshold", ")", ",", "self", ".", "mses", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.extract_posterior": [[1214, 1233], ["elfi.methods.posteriors.BolfiPosterior", "elfi.methods.posteriors.BolfiPosterior", "elfi.methods.posteriors.BolfiPosterior", "elfi.methods.posteriors.BolfiPosterior", "ValueError", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior", "elfi.methods.utils.ModelPrior"], "methods", ["None"], ["", "def", "extract_posterior", "(", "self", ",", "threshold", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return an object representing the approximate posterior.\n\n        The approximation is based on surrogate model regression.\n\n        Parameters\n        ----------\n        threshold: float, optional\n            Discrepancy threshold for creating the posterior (log with log discrepancy).\n\n        Returns\n        -------\n        posterior : elfi.methods.posteriors.BolfiPosterior\n\n        \"\"\"", "\n", "if", "self", ".", "state", "[", "'n_batches'", "]", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Model is not fitted yet, please see the `fit` method.'", ")", "\n", "\n", "", "return", "BolfiPosterior", "(", "self", ".", "target_model", ",", "threshold", "=", "threshold", ",", "prior", "=", "ModelPrior", "(", "self", ".", "model", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.sample": [[1234, 1364], ["parameter_inference.BOLFI.extract_posterior", "range", "numpy.asarray", "print", "enumerate", "elfi.methods.results.BolfiSample", "elfi.methods.results.BolfiSample", "elfi.methods.results.BolfiSample", "elfi.methods.results.BolfiSample", "parameter_inference.BOLFI.fit", "ValueError", "numpy.argsort", "numpy.asarray", "elfi.loader.get_sub_seed", "elfi.loader.get_sub_seed", "elfi.loader.get_sub_seed", "elfi.loader.get_sub_seed", "numpy.isinf", "numpy.asarray.append", "print", "ValueError", "ValueError", "parameter_inference.BOLFI.logpdf", "tasks_ids.append", "parameter_inference.BOLFI.client.get_result", "elfi.eff_sample_size", "elfi.eff_sample_size", "elfi.eff_sample_size", "elfi.eff_sample_size", "elfi.gelman_rubin", "elfi.gelman_rubin", "elfi.gelman_rubin", "elfi.gelman_rubin", "float", "numpy.asarray", "ValueError", "len", "ValueError", "parameter_inference.BOLFI.client.apply", "tasks_ids.append", "parameter_inference.BOLFI.client.apply"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.extract_posterior", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.BOLFI.fit", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.utils.get_sub_seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.get_result", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.eff_sample_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.eff_sample_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.eff_sample_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.eff_sample_size", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.gelman_rubin", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.gelman_rubin", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.gelman_rubin", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.mcmc.gelman_rubin", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.clients.native.Client.apply"], ["", "def", "sample", "(", "self", ",", "\n", "n_samples", ",", "\n", "warmup", "=", "None", ",", "\n", "n_chains", "=", "4", ",", "\n", "threshold", "=", "None", ",", "\n", "initials", "=", "None", ",", "\n", "algorithm", "=", "'nuts'", ",", "\n", "sigma_proposals", "=", "None", ",", "\n", "n_evidence", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "r\"\"\"Sample the posterior distribution of BOLFI.\n        Here the likelihood is defined through the cumulative density function\n        of the standard normal distribution:\n        L(\\theta) \\propto F((h-\\mu(\\theta)) / \\sigma(\\theta))\n        where h is the threshold, and \\mu(\\theta) and \\sigma(\\theta) are the posterior mean and\n        (noisy) standard deviation of the associated Gaussian process.\n        The sampling is performed with an MCMC sampler (the No-U-Turn Sampler, NUTS).\n        Parameters\n        ----------\n        n_samples : int\n            Number of requested samples from the posterior for each chain. This includes warmup,\n            and note that the effective sample size is usually considerably smaller.\n        warmpup : int, optional\n            Length of warmup sequence in MCMC sampling. Defaults to n_samples//2.\n        n_chains : int, optional\n            Number of independent chains.\n        threshold : float, optional\n            The threshold (bandwidth) for posterior (give as log if log discrepancy).\n        initials : np.array of shape (n_chains, n_params), optional\n            Initial values for the sampled parameters for each chain.\n            Defaults to best evidence points.\n        algorithm : string, optional\n            Sampling algorithm to use. Currently 'nuts'(default) and 'metropolis' are supported.\n        sigma_proposals : np.array\n            Standard deviations for Gaussian proposals of each parameter for Metropolis\n            Markov Chain sampler.\n        n_evidence : int\n            If the regression model is not fitted yet, specify the amount of evidence\n        Returns\n        -------\n        BolfiSample\n        \"\"\"", "\n", "if", "self", ".", "state", "[", "'n_batches'", "]", "==", "0", ":", "\n", "            ", "self", ".", "fit", "(", "n_evidence", ")", "\n", "\n", "# TODO: add more MCMC algorithms", "\n", "", "if", "algorithm", "not", "in", "[", "'nuts'", ",", "'metropolis'", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown posterior sampler.\"", ")", "\n", "\n", "", "posterior", "=", "self", ".", "extract_posterior", "(", "threshold", ")", "\n", "warmup", "=", "warmup", "or", "n_samples", "//", "2", "\n", "\n", "# Unless given, select the evidence points with smallest discrepancy", "\n", "if", "initials", "is", "not", "None", ":", "\n", "            ", "if", "np", ".", "asarray", "(", "initials", ")", ".", "shape", "!=", "(", "n_chains", ",", "self", ".", "target_model", ".", "input_dim", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"The shape of initials must be (n_chains, n_params).\"", ")", "\n", "", "", "else", ":", "\n", "            ", "inds", "=", "np", ".", "argsort", "(", "self", ".", "target_model", ".", "Y", "[", ":", ",", "0", "]", ")", "\n", "initials", "=", "np", ".", "asarray", "(", "self", ".", "target_model", ".", "X", "[", "inds", "]", ")", "\n", "\n", "", "self", ".", "target_model", ".", "is_sampling", "=", "True", "# enables caching for default RBF kernel", "\n", "\n", "tasks_ids", "=", "[", "]", "\n", "ii_initial", "=", "0", "\n", "if", "algorithm", "==", "'metropolis'", ":", "\n", "            ", "if", "sigma_proposals", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\"Gaussian proposal standard deviations \"", "\n", "\"have to be provided for Metropolis-sampling.\"", ")", "\n", "", "elif", "sigma_proposals", ".", "shape", "[", "0", "]", "!=", "self", ".", "target_model", ".", "input_dim", ":", "\n", "                ", "raise", "ValueError", "(", "\"The length of Gaussian proposal standard \"", "\n", "\"deviations must be n_params.\"", ")", "\n", "\n", "# sampling is embarrassingly parallel, so depending on self.client this may parallelize", "\n", "", "", "for", "ii", "in", "range", "(", "n_chains", ")", ":", "\n", "            ", "seed", "=", "get_sub_seed", "(", "self", ".", "seed", ",", "ii", ")", "\n", "# discard bad initialization points", "\n", "while", "np", ".", "isinf", "(", "posterior", ".", "logpdf", "(", "initials", "[", "ii_initial", "]", ")", ")", ":", "\n", "                ", "ii_initial", "+=", "1", "\n", "if", "ii_initial", "==", "len", "(", "inds", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"BOLFI.sample: Cannot find enough acceptable initialization points!\"", ")", "\n", "\n", "", "", "if", "algorithm", "==", "'nuts'", ":", "\n", "                ", "tasks_ids", ".", "append", "(", "\n", "self", ".", "client", ".", "apply", "(", "\n", "mcmc", ".", "nuts", ",", "\n", "n_samples", ",", "\n", "initials", "[", "ii_initial", "]", ",", "\n", "posterior", ".", "logpdf", ",", "\n", "posterior", ".", "gradient_logpdf", ",", "\n", "n_adapt", "=", "warmup", ",", "\n", "seed", "=", "seed", ",", "\n", "**", "kwargs", ")", ")", "\n", "\n", "", "elif", "algorithm", "==", "'metropolis'", ":", "\n", "                ", "tasks_ids", ".", "append", "(", "\n", "self", ".", "client", ".", "apply", "(", "\n", "mcmc", ".", "metropolis", ",", "\n", "n_samples", ",", "\n", "initials", "[", "ii_initial", "]", ",", "\n", "posterior", ".", "logpdf", ",", "\n", "sigma_proposals", ",", "\n", "warmup", ",", "\n", "seed", "=", "seed", ",", "\n", "**", "kwargs", ")", ")", "\n", "\n", "", "ii_initial", "+=", "1", "\n", "\n", "# get results from completed tasks or run sampling (client-specific)", "\n", "", "chains", "=", "[", "]", "\n", "for", "id", "in", "tasks_ids", ":", "\n", "            ", "chains", ".", "append", "(", "self", ".", "client", ".", "get_result", "(", "id", ")", ")", "\n", "\n", "", "chains", "=", "np", ".", "asarray", "(", "chains", ")", "\n", "print", "(", "\n", "\"{} chains of {} iterations acquired. Effective sample size and Rhat for each \"", "\n", "\"parameter:\"", ".", "format", "(", "n_chains", ",", "n_samples", ")", ")", "\n", "for", "ii", ",", "node", "in", "enumerate", "(", "self", ".", "parameter_names", ")", ":", "\n", "            ", "print", "(", "node", ",", "mcmc", ".", "eff_sample_size", "(", "chains", "[", ":", ",", ":", ",", "ii", "]", ")", ",", "\n", "mcmc", ".", "gelman_rubin", "(", "chains", "[", ":", ",", ":", ",", "ii", "]", ")", ")", "\n", "", "self", ".", "target_model", ".", "is_sampling", "=", "False", "\n", "\n", "return", "BolfiSample", "(", "\n", "method_name", "=", "'BOLFI'", ",", "\n", "chains", "=", "chains", ",", "\n", "parameter_names", "=", "self", ".", "parameter_names", ",", "\n", "warmup", "=", "warmup", ",", "\n", "threshold", "=", "float", "(", "posterior", ".", "threshold", ")", ",", "\n", "n_sim", "=", "self", ".", "state", "[", "'n_sim'", "]", ",", "\n", "seed", "=", "self", ".", "seed", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.GMDistribution.pdf": [[131, 165], ["cls._normalize_params", "numpy.zeros", "zip", "numpy.asanyarray", "numpy.atleast_1d", "numpy.atleast_2d", "len", "numpy.zeros.squeeze", "scipy.multivariate_normal.pdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.GMDistribution._normalize_params", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_1d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf"], ["p", "=", "Path", "(", "'./results'", ")", "\n", "\n", "# All subdirectories in the current directory, not recursive.", "\n", "sim_paths", "=", "[", "f", "for", "f", "in", "p", ".", "iterdir", "(", ")", "if", "f", ".", "is_dir", "(", ")", "]", "\n", "\n", "for", "sim_path", "in", "sim_paths", ":", "\n", "        ", "sim", "=", "sim_path", ".", "name", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "wass_dist_df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "[", "'Model'", ",", "'dset'", ",", "'wass'", "]", ")", "\n", "meth_paths", "=", "[", "f", "for", "f", "in", "sim_path", ".", "iterdir", "(", ")", "if", "f", ".", "is_dir", "(", ")", "]", "\n", "for", "meth_path", "in", "meth_paths", ":", "\n", "            ", "if", "plot_methods", "[", "1", "]", "in", "meth_path", ".", "name", ":", "\n", "                ", "plot_method", "=", "'LV-2GP'", "\n", "", "elif", "plot_methods", "[", "0", "]", "in", "meth_path", ".", "name", ":", "\n", "                ", "plot_method", "=", "'GP'", "\n", "", "else", ":", "\n", "                ", "continue", "\n", "\n", "", "dset", "=", "meth_path", ".", "name", ".", "split", "(", "'('", ")", "[", "-", "1", "]", "[", ":", "-", "1", "]", "\n", "if", "boxplot", "is", "False", "and", "int", "(", "dset", ")", "!=", "200", ":", "\n", "                ", "continue", "\n", "\n", "", "for", "filename", "in", "Path", "(", "meth_path", ")", ".", "glob", "(", "'*.mat'", ")", ":", "\n", "                ", "temp_dict", "=", "scipy", ".", "io", ".", "loadmat", "(", "filename", ")", "\n", "\n", "if", "temp_dict", "[", "'Wass'", "]", "[", "0", "]", "[", "0", "]", "<", "0", ":", "\n", "                    ", "print", "(", "filename", ",", "temp_dict", "[", "'Wass'", "]", "[", "0", "]", "[", "0", "]", ")", "\n", "continue", "\n", "", "data", "=", "{", "'Model'", ":", "plot_method", ",", "'dset'", ":", "dset", ",", "'wass'", ":", "temp_dict", "[", "'Wass'", "]", "[", "0", "]", "[", "0", "]", "}", "\n", "wass_dist_df", "=", "wass_dist_df", ".", "append", "(", "data", ",", "ignore_index", "=", "True", ")", "\n", "\n", "", "", "if", "wass_dist_df", ".", "empty", ":", "\n", "            ", "continue", "\n", "", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "my_pal", "=", "{", "m", ":", "\"r\"", "if", "m", "==", "\"GP\"", "else", "\"b\"", "for", "m", "in", "wass_dist_df", ".", "Model", ".", "unique", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.GMDistribution.logpdf": [[166, 184], ["numpy.log", "cls.pdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf"], ["if", "boxplot", "is", "True", ":", "\n", "            ", "ax", "=", "sns", ".", "boxplot", "(", "x", "=", "'dset'", ",", "y", "=", "'wass'", ",", "hue", "=", "'Model'", ",", "data", "=", "wass_dist_df", ",", "linewidth", "=", "2", ",", "palette", "=", "my_pal", ",", "showfliers", "=", "False", ",", "order", "=", "[", "'20'", ",", "'50'", ",", "'100'", ",", "'150'", ",", "'200'", ",", "'250'", ",", "'300'", "]", ")", "\n", "plt", ".", "legend", "(", "[", "]", ",", "[", "]", ",", "frameon", "=", "False", ")", "\n", "plt", ".", "xlabel", "(", "r'Number of simulations'", ")", "\n", "fig", ".", "set_size_inches", "(", "5", ",", "3", ")", "\n", "plt", ".", "ylabel", "(", "r''", ",", "rotation", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "ax", "=", "sns", ".", "violinplot", "(", "x", "=", "'Model'", ",", "y", "=", "'wass'", ",", "data", "=", "wass_dist_df", ",", "linewidth", "=", "1.1", ",", "palette", "=", "my_pal", ",", "cut", "=", "0", ")", "\n", "plt", ".", "xlabel", "(", "r''", ")", "\n", "fig", ".", "set_size_inches", "(", "1.5", ",", "2.2", ")", "\n", "\n", "plt", ".", "ylabel", "(", "r''", ",", "rotation", "=", "0", ")", "\n", "\n", "", "plt", ".", "savefig", "(", "'plots/'", "+", "sim", "+", "'-wass.png'", ",", "dpi", "=", "600", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "# =====================", "\n", "# KELFI FUNCTIONS:", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.GMDistribution.rvs": [[185, 249], ["cls._normalize_params", "numpy.empty", "logger.debug", "random_state.choice", "scipy.multivariate_normal.rvs", "len", "len", "logger.warning", "numpy.isfinite", "prior_logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.GMDistribution._normalize_params", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["# =====================", "\n", "\n", "", "", "def", "hyperparameter_learning_objective", "(", "y", ",", "x_sim", ",", "t_sim", ",", "t_samples", ",", "beta", ",", "eps", ",", "reg", "=", "None", ")", ":", "\n", "    ", "\"\"\"Computes the approximate MKML for different hyperparameters.\"\"\"", "\n", "weights", "=", "kernel_means_weights", "(", "y", ",", "x_sim", ",", "t_sim", ",", "eps", ",", "beta", ",", "reg", "=", "reg", ")", "\n", "return", "approximate_marginal_kernel_means_likelihood", "(", "t_samples", ",", "t_sim", ",", "weights", ",", "beta", ")", "\n", "\n", "\n", "", "def", "kelfi", "(", "y", ",", "x_sim", ",", "t_sim", ",", "t_samples", ",", "beta", ",", "eps", ",", "reg", "=", "None", ",", "n_samples", "=", "1000", ",", "beta_query", "=", "None", ")", ":", "\n", "    ", "\"\"\"Full KELFI Solution.\"\"\"", "\n", "weights", "=", "kernel_means_weights", "(", "y", ",", "x_sim", ",", "t_sim", ",", "eps", ",", "beta", ",", "reg", "=", "reg", ")", "\n", "mkml", "=", "approximate_marginal_kernel_means_likelihood", "(", "t_samples", ",", "t_sim", ",", "weights", ",", "beta", ")", "\n", "if", "beta_query", "is", "None", ":", "\n", "        ", "beta_query", "=", "beta", "\n", "", "kernel_function", "=", "lambda", "t1", ",", "t2", ":", "gaussian_kernel_gramix", "(", "t1", ",", "t2", ",", "beta_query", ")", "\n", "kmpe_", "=", "approximate_kernel_means_posterior_embedding", "(", "t_samples", ",", "t_sim", ",", "weights", ",", "beta", ",", "t_samples", ",", "marginal_likelihood", "=", "mkml", ",", "beta_query", "=", "beta_query", ")", "\n", "t_kmpe", "=", "kernel_herding", "(", "kmpe_", ",", "kernel_function", ",", "t_samples", ",", "n_samples", ")", "\n", "return", "t_kmpe", "\n", "\n", "\n", "\n", "", "def", "generate_data", "(", "elfi_model", ",", "y_data", ",", "n_sim", ",", "n_prior_samples", ",", "par_names", ",", "seed", ")", ":", "\n", "    ", "'''Generates the data from the ELFI model, which will be later used for training'''", "\n", "outputs", "=", "elfi_model", ".", "parameter_names", "+", "[", "'sim'", "]", "\n", "data", "=", "elfi_model", ".", "generate", "(", "batch_size", "=", "n_sim", ",", "outputs", "=", "outputs", ",", "seed", "=", "seed", ")", "\n", "prior", "=", "elfi_model", ".", "generate", "(", "batch_size", "=", "n_prior_samples", ",", "outputs", "=", "par_names", ",", "seed", "=", "seed", ")", "\n", "\n", "parameters", "=", "np", ".", "reshape", "(", "data", "[", "par_names", "[", "0", "]", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "pars_from_prior", "=", "np", ".", "reshape", "(", "prior", "[", "par_names", "[", "0", "]", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "for", "par", "in", "par_names", "[", "1", ":", "]", ":", "\n", "        ", "temp_parameters", "=", "np", ".", "reshape", "(", "data", "[", "par", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "parameters", "=", "np", ".", "concatenate", "(", "(", "parameters", ",", "temp_parameters", ")", ",", "axis", "=", "1", ")", "\n", "temp_pars_from_prior", "=", "np", ".", "reshape", "(", "prior", "[", "par", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "pars_from_prior", "=", "np", ".", "concatenate", "(", "(", "pars_from_prior", ",", "temp_pars_from_prior", ")", ",", "axis", "=", "1", ")", "\n", "\n", "", "y_data", "=", "np", ".", "array", "(", "y_data", ")", "\n", "x_data", "=", "np", ".", "reshape", "(", "data", "[", "'sim'", "]", ",", "(", "-", "1", ",", "1", ",", "len", "(", "y_data", ")", ")", ")", "\n", "y_data", "=", "np", ".", "reshape", "(", "y_data", ",", "(", "-", "1", ",", "1", ",", "len", "(", "y_data", ")", ")", ")", "\n", "return", "x_data", ",", "y_data", ",", "parameters", ",", "pars_from_prior", "\n", "\n", "\n", "", "def", "tune_hyperparameters", "(", "x_data", ",", "y_data", ",", "parameters", ",", "pars_from_prior", ",", "auto_dif", "=", "True", ")", ":", "\n", "    ", "if", "auto_dif", "==", "True", ":", "\n", "        ", "eps_tuple", "=", "(", "0.06", ",", "'learn'", ")", "\n", "beta_tuple", "=", "(", "0.6", ",", "'learn'", ")", "\n", "reg_tuple", "=", "(", "1e-6", ",", "'learn'", ")", "\n", "eps", ",", "beta", ",", "reg_opt", "=", "kernel_means_hyperparameter_learning", "(", "\n", "y_data", ",", "x_data", ",", "parameters", ",", "eps_tuple", ",", "beta_tuple", ",", "reg_tuple", ",", "\n", "eps_ratios", "=", "1.", ",", "beta_ratios", "=", "1.", ",", "offset", "=", "0.", ",", "\n", "prior_samples", "=", "pars_from_prior", ",", "prior_mean", "=", "None", ",", "prior_std", "=", "None", ",", "\n", "learning_rate", "=", "0.01", ",", "n_iter", "=", "5000", ",", "display_steps", "=", "100", ")", "\n", "", "else", ":", "\n", "        ", "beta_array", "=", "np", ".", "linspace", "(", "0.5", ",", "1.5", ",", "100", ")", "\n", "eps_array", "=", "np", ".", "linspace", "(", "0.05", ",", "0.15", ",", "100", ")", "\n", "\n", "mkml_grid", "=", "np", ".", "zeros", "(", "(", "beta_array", ".", "shape", "[", "0", "]", ",", "eps_array", ".", "shape", "[", "0", "]", ")", ")", "\n", "mkml_global", "=", "-", "np", ".", "inf", "\n", "for", "i", ",", "beta", "in", "enumerate", "(", "beta_array", ")", ":", "\n", "            ", "for", "j", ",", "eps", "in", "enumerate", "(", "eps_array", ")", ":", "\n", "                ", "mkml_grid", "[", "i", ",", "j", "]", "=", "hyperparameter_learning_objective", "(", "y_data", ",", "x_data", ",", "parameters", ",", "pars_from_prior", ",", "beta", ",", "eps", ")", "\n", "if", "mkml_grid", "[", "i", ",", "j", "]", ">", "mkml_global", ":", "\n", "                    ", "mkml_global", "=", "mkml_grid", "[", "i", ",", "j", "]", "\n", "beta", "=", "beta", "\n", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.GMDistribution._normalize_params": [[250, 260], ["numpy.atleast_1d", "utils.normalize_weights", "ValueError", "numpy.ones", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_1d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.normalize_weights"], ["", "", "", "", "return", "beta", ",", "eps", "\n", "\n", "\n", "\n", "# =====================", "\n", "# WASSERSTEIN DISTANCE:", "\n", "# =====================", "\n", "\n", "\n", "", "def", "get_wass_dist", "(", "samples_1", ",", "samples_2", ",", "weights_1", "=", "None", ",", "weights_2", "=", "None", ",", "num_iter_max", "=", "1000000", ",", "**", "kwargs", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.__init__": [[312, 332], ["model.copy.copy.copy", "len", "elfi.clients.native.Client", "utils.ModelPrior.client.compile", "utils.ModelPrior.client.compile", "utils.ModelPrior.client.compile", "elfi.add_pdf_nodes", "elfi.add_pdf_nodes"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter.add_pdf_nodes", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.model.augmenter.add_pdf_nodes"], ["\n", "\n", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs": [[333, 351], ["elfi.model.elfi_model.ComputationContext", "utils.ModelPrior.client.load_data", "utils.ModelPrior.client.compute", "numpy.column_stack", "rvs.reshape.reshape.reshape"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.load_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compute"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf": [[352, 355], ["utils.ModelPrior._evaluate_pdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior._evaluate_pdf"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.logpdf": [[356, 359], ["utils.ModelPrior._evaluate_pdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior._evaluate_pdf"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior._evaluate_pdf": [[360, 387], ["numpy.asanyarray", "x.reshape.reshape.reshape", "utils.ModelPrior._to_batch", "elfi.model.elfi_model.ComputationContext", "utils.ModelPrior.client.load_data", "utils.ModelPrior.items", "len", "utils.ModelPrior.client.compute"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior._to_batch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.load_data", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compute"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.gradient_pdf": [[388, 391], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.gradient_logpdf": [[392, 418], ["numpy.asanyarray", "x.reshape.reshape.reshape", "numpy.zeros_like", "range", "len", "utils.numgrad", "numpy.isinf", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numgrad"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior._to_batch": [[419, 421], ["enumerate"], "methods", ["None"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.arr2d_to_batch": [[16, 41], ["x.reshape.reshape", "ValueError", "enumerate", "len"], "function", ["None"], ["from", "kelfi", ".", "kernel_means_inference", "import", "approximate_kernel_means_posterior_embedding", ",", "kernel_herding", "\n", "from", "kelfi", ".", "kernel_means_learning", "import", "kernel_means_hyperparameter_learning", "\n", "from", "kelfi", ".", "kernels", "import", "gaussian_kernel_gramix", "\n", "\n", "\n", "import", "warnings", "\n", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ")", "\n", "\n", "\n", "# =====================", "\n", "# PLOTTING FUNCTIONS:", "\n", "# =====================", "\n", "\n", "mpl", ".", "rcParams", "[", "'figure.dpi'", "]", "=", "300", "\n", "\n", "\n", "# sample posterior of the trained surrogate model", "\n", "def", "get_weighted_samples", "(", "post", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "post", ".", "prior", ".", "rvs", "(", "size", "=", "N", ")", "\n", "\n", "if", "theta", ".", "ndim", "==", "1", ":", "\n", "        ", "theta", "=", "theta", ".", "reshape", "(", "theta", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "\n", "", "weights", "=", "post", ".", "_unnormalized_likelihood", "(", "theta", ")", "\n", "return", "theta", ",", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.batch_to_arr2d": [[43, 69], ["numpy.vstack", "isinstance", "rows.append", "numpy.column_stack"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["\n", "", "def", "sample_posterior", "(", "samples", ",", "weights", ",", "cols", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "samples", "\n", "n_weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "\n", "\n", "# importance weighted resampling", "\n", "resample_index", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "samples", ")", ",", "size", "=", "N", ",", "replace", "=", "True", ",", "p", "=", "n_weights", ")", "\n", "theta_resampled", "=", "theta", "[", "resample_index", ",", ":", "]", "\n", "theta_df", "=", "pd", ".", "DataFrame", ".", "from_records", "(", "theta_resampled", ",", "columns", "=", "cols", ")", "\n", "return", "theta_df", "\n", "\n", "\n", "\n", "# plot the grid plot of the surrogate posterior", "\n", "", "def", "plot_grid", "(", "theta_df", ",", "lims", ")", ":", "\n", "    ", "g", "=", "sns", ".", "PairGrid", "(", "theta_df", ")", "\n", "for", "x_ind", "in", "range", "(", "0", ",", "len", "(", "lims", ")", ")", ":", "\n", "        ", "for", "y_ind", "in", "range", "(", "0", ",", "len", "(", "lims", ")", ")", ":", "\n", "            ", "g", ".", "axes", "[", "y_ind", ",", "x_ind", "]", ".", "set_xlim", "(", "lims", "[", "x_ind", "]", ")", "\n", "g", ".", "axes", "[", "y_ind", ",", "x_ind", "]", ".", "set_ylim", "(", "lims", "[", "y_ind", "]", ")", "\n", "\n", "", "", "g", "=", "g", ".", "map_lower", "(", "plt", ".", "scatter", ",", "s", "=", "1", ")", "\n", "g", "=", "g", ".", "map_diag", "(", "plt", ".", "hist", ")", "\n", "\n", "\n", "", "def", "plot_thresholds", "(", "thrs", ",", "legend", ")", ":", "\n", "    ", "ax", "=", "plt", ".", "gca", "(", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ceil_to_batch_size": [[71, 81], ["int", "math.ceil"], "function", ["None"], ["ax", ".", "set_ylabel", "(", "'threshold'", ")", "\n", "ax", ".", "set_xlabel", "(", "'num of batches'", ")", "\n", "ax", ".", "legend", "(", "legend", ")", "\n", "return", "\n", "\n", "\n", "\n", "", "def", "plot_marginals", "(", "sim", ",", "bounds", ",", "true_samples_df", ",", "true_pars", ")", ":", "\n", "    ", "plot_methods", "=", "[", "'BO-GP(200)'", ",", "'BO-LV-2GP-0.3(200)'", "]", "\n", "par_names", "=", "list", "(", "bounds", ".", "keys", "(", ")", ")", "\n", "sns", ".", "set", "(", "style", "=", "\"ticks\"", ",", "rc", "=", "{", "\"lines.linewidth\"", ":", "0.7", "}", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.normalize_weights": [[83, 92], ["numpy.atleast_1d", "numpy.any", "numpy.sum", "ValueError", "ValueError"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_1d"], ["maps", "=", "{", "'t1'", ":", "r'$\\theta_{t1}$'", ",", "'R1'", ":", "r'$\\theta_{R1}$'", ",", "'R2'", ":", "r'$\\theta_{R2}$'", ",", "\n", "'burden'", ":", "r'$\\theta_{burden}$'", ",", "'white'", ":", "r'$\\theta_{white}$'", ",", "\n", "'yellow'", ":", "r'$\\theta_{yellow}$'", ",", "'red'", ":", "r'$\\theta_{red}$'", ",", "\n", "'green'", ":", "r'$\\theta_{green}$'", ",", "'purple'", ":", "r'$\\theta_{purple}$'", ",", "\n", "'x'", ":", "r'$\\theta_{x}$'", ",", "'y'", ":", "r'$\\theta_{y}$'", ",", "\n", "'ns'", ":", "r'$\\theta_{n_s}$'", ",", "'kc'", ":", "r'$\\theta_{k_c}$'", ",", "'alpha'", ":", "r'$\\theta_{\\alpha}$'", ",", "\n", "'r_star'", ":", "r'$\\theta_{R^*}$'", ",", "'As'", ":", "r'$\\theta_{A_s}$'", "}", "\n", "\n", "for", "plot_method", "in", "plot_methods", ":", "\n", "        ", "for", "cur_par_name", ",", "i", "in", "zip", "(", "par_names", ",", "range", "(", "len", "(", "par_names", ")", ")", ")", ":", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.weighted_var": [[94, 126], ["numpy.sum", "numpy.sum", "numpy.average", "np.ones.dot", "numpy.ones", "len"], "function", ["None"], ["for", "filename", "in", "Path", "(", "'./results/'", "+", "sim", "+", "'/'", "+", "plot_method", ")", ".", "glob", "(", "'*.samples'", ")", ":", "\n", "                ", "temp_dict", "=", "scipy", ".", "io", ".", "loadmat", "(", "filename", ")", "\n", "sur_theta", "=", "temp_dict", "[", "cur_par_name", "]", "\n", "# sns.distplot(sur_theta, color=(0.879, 0.929, 0.969), hist=False, kde_kws={'alpha':0.1}) #, scatter_kws={'alpha':0.3})", "\n", "# sns.distplot(sur_theta, color=(0.711, 0.832, 0.91), hist=False, kde_kws={'alpha':0.05}) # DGP almost good", "\n", "# sns.distplot(sur_theta, color=(0.554, 0.734, 0.855), hist=False, kde_kws={'alpha':0.05}) #GP gppd", "\n", "try", ":", "\n", "                    ", "sns", ".", "distplot", "(", "sur_theta", ",", "color", "=", "(", "0.516", ",", "0.707", ",", "0.839", ")", ",", "hist", "=", "False", ",", "kde_kws", "=", "{", "'alpha'", ":", "0.1", "}", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "                    ", "sns", ".", "distplot", "(", "sur_theta", ",", "color", "=", "(", "0.516", ",", "0.707", ",", "0.839", ")", ",", "kde", "=", "False", ",", "kde_kws", "=", "{", "'alpha'", ":", "0.1", "}", ")", "\n", "\n", "", "", "true_theta", "=", "pd", ".", "Series", "(", "true_samples_df", "[", "cur_par_name", "]", ",", "name", "=", "cur_par_name", ")", "\n", "sns", ".", "distplot", "(", "true_theta", ",", "color", "=", "\"r\"", ",", "hist", "=", "False", ",", "kde_kws", "=", "{", "\"linewidth\"", ":", "1", "}", ")", "\n", "plt", ".", "axvline", "(", "true_pars", "[", "i", "]", ",", "ls", "=", "'dashed'", ",", "color", "=", "\"black\"", ")", "\n", "plt", ".", "yticks", "(", "[", "]", ")", "\n", "\n", "if", "'TE'", "in", "sim", ":", "\n", "                ", "plt", ".", "xlabel", "(", "r'$\\theta$'", ")", "\n", "", "else", ":", "\n", "                ", "plt", ".", "xlabel", "(", "maps", "[", "cur_par_name", "]", ")", "\n", "", "plt", ".", "ylabel", "(", "''", ")", "\n", "# plt.ylim((0,2.5))", "\n", "\n", "# fig.set_size_inches(2.5,2.1) # in TE plots", "\n", "# fig.set_size_inches(1.4,1.4) # in 5 row plots", "\n", "fig", ".", "set_size_inches", "(", "1.8", ",", "1.8", ")", "\n", "plt", ".", "savefig", "(", "'plots/'", "+", "sim", "+", "'-'", "+", "plot_method", "+", "'-par-'", "+", "cur_par_name", "+", "'.png'", ",", "dpi", "=", "600", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "\n", "\n", "", "", "", "def", "plot_wasserstein", "(", "boxplot", "=", "True", ")", ":", "\n", "    ", "plot_methods", "=", "[", "'BO-GP'", ",", "'BO-LV-2GP-0.3'", "]", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numgrad": [[262, 302], ["numpy.asanyarray().reshape", "numpy.asanyarray().reshape", "len", "numpy.zeros", "range", "fn", "f.reshape.reshape", "numpy.gradient", "numpy.tile", "numpy.fill_diagonal", "numpy.any", "numpy.asanyarray", "numpy.asanyarray", "numpy.isneginf", "numpy.zeros", "np.tile.diagonal"], "function", ["None"], ["\n", "n", "=", "samples_1", ".", "shape", "[", "0", "]", "\n", "m", "=", "samples_2", ".", "shape", "[", "0", "]", "\n", "\n", "if", "weights_1", "is", "None", ":", "\n", "        ", "a", "=", "np", ".", "ones", "(", "(", "n", ",", ")", ")", "/", "n", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "weights_1", ")", "!=", "n", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Number of weights and number of samples need to be the same.\"", ")", "\n", "", "a", "=", "weights_1", "/", "np", ".", "sum", "(", "weights_1", ")", "\n", "", "if", "weights_2", "is", "None", ":", "\n", "        ", "b", "=", "np", ".", "ones", "(", "(", "m", ",", ")", ")", "/", "m", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "weights_2", ")", "!=", "m", ":", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.sample_object_to_dict": [[423, 446], ["elem.__dict__.items", "elem.__dict__[].items"], "function", ["None"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.numpy_to_python_type": [[448, 483], ["data.items", "isinstance", "type", "str", "val.items", "type", "str", "val.tolist", "int", "nested_val.tolist", "float", "int", "float"], "function", ["None"], []], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.__init__": [[39, 129], ["range", "isinstance", "logger.warning", "len", "len", "ValueError", "isinstance", "ValueError", "len", "len", "bounds.keys"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "parameter_names", "=", "None", ",", "bounds", "=", "None", ",", "GPlayers", "=", "3", ",", "LVlayer", "=", "True", ",", "Ms", "=", "50", ",", "IW_samples", "=", "5", ",", "pred_samples", "=", "100", ",", "opt_steps", "=", "20000", ",", "q", "=", "0.3", ")", ":", "\n", "\n", "        ", "'''Initialize DGPRegression.\n\n        Parameters\n        ----------\n        parameter_names : list of str, optional\n            Names of parameter nodes. If None, sets dimension to 1.\n        bounds : dict, optional\n            The region where to estimate the posterior for each parameter in\n            model.parameters.\n            `{'parameter_name':(lower, upper), ... }`\n            If not supplied, defaults to (0, 1) bounds for all dimensions.\n        layers : int, optional\n            number of layers in a DGP model.\n        Ms: int, optional\n            number of inducing points per each layer.\n        IW_samples : int, optional\n            number of Importance-Weighted samples.\n        pred_samples : int, optional\n            number of samples are used for predictions and gradients. \n        opt_steps : int, optional\n            number of hyperparameter optimization steps\n        '''", "\n", "\n", "class", "ARGS", ":", "\n", "            ", "minibatch_size", "=", "None", "\n", "lr", "=", "5e-3", "\n", "lr_decay", "=", "0.99", "\n", "\n", "", "class", "Model", "(", "ARGS", ")", ":", "\n", "# 'VI', 'HMC', 'IWAE'", "\n", "            ", "mode", "=", "'IWAE'", "\n", "M", "=", "Ms", "# 100", "\n", "likelihood_variance", "=", "0.1", "\n", "fix_linear", "=", "True", "\n", "num_IW_samples", "=", "IW_samples", "# was 20 # 5", "\n", "gamma", "=", "5e-2", "\n", "gamma_decay", "=", "0.99", "\n", "\n", "if", "LVlayer", "is", "True", ":", "\n", "                ", "configuration", "=", "'L1'", "# L1", "\n", "", "else", ":", "\n", "                ", "configuration", "=", "'G1'", "\n", "\n", "", "for", "_", "in", "range", "(", "GPlayers", ")", ":", "\n", "                ", "configuration", "+=", "'_G1'", "\n", "\n", "", "", "self", ".", "its", "=", "opt_steps", "\n", "self", ".", "_gp", "=", "None", "\n", "self", ".", "session", "=", "None", "\n", "self", ".", "quantile", "=", "q", "\n", "\n", "self", ".", "model_type", "=", "Model", "\n", "\n", "self", ".", "X", "=", "None", "\n", "self", ".", "Y", "=", "None", "\n", "self", ".", "x_mean", "=", "None", "\n", "self", ".", "x_std", "=", "None", "\n", "self", ".", "y_mean", "=", "None", "\n", "self", ".", "y_std", "=", "None", "\n", "\n", "if", "parameter_names", "is", "None", ":", "\n", "            ", "input_dim", "=", "1", "\n", "", "elif", "isinstance", "(", "parameter_names", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "input_dim", "=", "len", "(", "parameter_names", ")", "\n", "\n", "", "if", "bounds", "is", "None", ":", "\n", "            ", "logger", ".", "warning", "(", "'Parameter bounds not specified. Using [0,1] for each parameter.'", ")", "\n", "bounds", "=", "[", "(", "0", ",", "1", ")", "]", "*", "input_dim", "\n", "", "elif", "len", "(", "bounds", ")", "!=", "input_dim", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "'Length of `bounds` ({}) does not match the length of `parameter_names` ({}).'", "\n", ".", "format", "(", "len", "(", "bounds", ")", ",", "input_dim", ")", ")", "\n", "", "elif", "isinstance", "(", "bounds", ",", "dict", ")", ":", "\n", "            ", "if", "len", "(", "bounds", ")", "==", "1", ":", "# might be the case parameter_names=None", "\n", "                ", "bounds", "=", "[", "bounds", "[", "n", "]", "for", "n", "in", "bounds", ".", "keys", "(", ")", "]", "\n", "", "else", ":", "\n", "# turn bounds dict into a list in the same order as parameter_names", "\n", "                ", "bounds", "=", "[", "bounds", "[", "n", "]", "for", "n", "in", "parameter_names", "]", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Keyword `bounds` must be a dictionary \"", "\n", "\"`{'parameter_name': (lower, upper), ... }`\"", ")", "\n", "", "self", ".", "bounds", "=", "bounds", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "S", "=", "pred_samples", "\n", "self", ".", "mlls", "=", "[", "]", "\n", "self", ".", "posterior", "=", "None", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.__str__": [[132, 135], ["dgp_regression.DGPRegression._gp.__str__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__str__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return GPy's __str__.\"\"\"", "\n", "return", "self", ".", "_gp", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.__repr__": [[137, 140], ["dgp_regression.DGPRegression.__str__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return GPy's __str__.\"\"\"", "\n", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.predict": [[143, 223], ["numpy.asanyarray().reshape", "dgp_regression.DGPRegression._gp.predict_y_samples", "numpy.quantile", "list", "numpy.array", "numpy.nanmean", "numpy.nanvar", "numpy.array.append", "range", "numpy.array", "isinstance", "numpy.concatenate", "numpy.concatenate", "numpy.asanyarray", "list", "len", "numpy.array.reshape", "q_fs[].append", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI.predict_y_samples", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "predict", "(", "self", ",", "X", ",", "noiseless", "=", "False", ")", ":", "\n", "        ", "\"\"\"Return the GP model mean and variance at x.\n\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n        noiseless : bool\n            whether to include the noise variance or not to the returned variance\n\n        Returns\n        -------\n        tuple\n            GP (mean, var) at x where\n                mean : np.array\n                    with shape (x.shape[0], 1)\n                var : np.array\n                    with shape (x.shape[0], 1)\n\n        \"\"\"", "\n", "X", "=", "np", ".", "asanyarray", "(", "X", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "X", "=", "(", "X", "-", "self", ".", "x_mean", ")", "/", "self", ".", "x_std", "\n", "# y = self._gp.predict_y_samples(X, self.S)", "\n", "# return y * self.y_std + self.y_mean #, v * self.y_std", "\n", "# m, v = self._gp.predict_y(X, session=self.session)", "\n", "# ms, vs = self._gp.predict_f_multisample(X, self.S)", "\n", "# m = np.average(ms, 0)", "\n", "# v = np.average(vs + ms**2, 0) - m**2", "\n", "\n", "fs", "=", "self", ".", "_gp", ".", "predict_y_samples", "(", "X", ",", "self", ".", "S", ")", "\n", "# m = np.mean(fs, 0)", "\n", "# v = np.var(fs, 0)", "\n", "q", "=", "np", ".", "quantile", "(", "fs", ",", "self", ".", "quantile", ",", "axis", "=", "0", ")", "\n", "# print(fs.shape)", "\n", "# print(q)", "\n", "# print(X", "\n", "# print(fs)", "\n", "q_fs", "=", "list", "(", ")", "\n", "for", "sample", "in", "fs", ":", "\n", "            ", "q_fs", ".", "append", "(", "list", "(", ")", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "sample", ")", ")", ":", "\n", "# print(sample)", "\n", "# print(q)", "\n", "                ", "if", "sample", "[", "i", "]", "<=", "q", "[", "i", "]", ":", "\n", "                    ", "el", "=", "sample", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "el", "=", "np", ".", "array", "(", "np", ".", "nan", ")", "\n", "# print(el)", "\n", "", "el", "=", "el", ".", "reshape", "(", "(", "1", ")", ")", "\n", "q_fs", "[", "-", "1", "]", ".", "append", "(", "np", ".", "array", "(", "el", ")", ")", "\n", "\n", "", "q_fs", "[", "-", "1", "]", "=", "np", ".", "array", "(", "q_fs", "[", "-", "1", "]", ")", "\n", "\n", "", "q_fs", "=", "np", ".", "array", "(", "q_fs", ")", "\n", "\n", "# q_fs = np.array(q_fs).reshape(20, 1, 1)", "\n", "# q_fs = fs[np.where(fs[i] < q[i] for i in range(0, self.S))]", "\n", "\n", "# print('Q_fs' + str(q_fs.shape))", "\n", "# print('Fs' + str(fs.shape))", "\n", "# print(q_fs)", "\n", "\n", "# q_fs = [f for f in fs if f < q[0]]", "\n", "q_mean", "=", "np", ".", "nanmean", "(", "q_fs", ",", "0", ")", "\n", "q_var", "=", "np", ".", "nanvar", "(", "q_fs", ",", "0", ")", "\n", "\n", "# print('Fs shape ' + str(fs.shape)) ", "\n", "# print('Qmean shape ' + str(q_mean.shape))", "\n", "\n", "if", "isinstance", "(", "q_mean", "[", "0", "]", ",", "float", ")", "==", "False", ":", "\n", "            ", "q_mean", "=", "np", ".", "concatenate", "(", "q_mean", ",", "axis", "=", "0", ")", "\n", "q_var", "=", "np", ".", "concatenate", "(", "q_var", ",", "axis", "=", "0", ")", "\n", "# # print(q_mean)", "\n", "# print(q_var)", "\n", "# print(q_mean.ndim)", "\n", "# print(q_mean.shape)", "\n", "\n", "# print(np.concatenate( q_fs, axis=0 ))", "\n", "", "return", "q_mean", "*", "self", ".", "y_std", "+", "self", ".", "y_mean", ",", "q_var", "*", "self", ".", "y_std", "\n", "#return m * self.y_std + self.y_mean, v * self.y_std", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.sample_fs": [[226, 265], ["numpy.asanyarray().reshape", "dgp_regression.DGPRegression._gp.predict_y_samples", "print", "numpy.asanyarray", "dgp_regression.DGPRegression.sghmc_optimizer.collect_samples", "feed_dict.update", "dgp_regression.DGPRegression.session.run", "dgp_regression.DGPRegression.append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI.predict_y_samples", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.collect_samples", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "sample_fs", "(", "self", ",", "X", ",", "noiseless", "=", "False", ")", ":", "\n", "        ", "\"\"\"Return the GP model mean and variance at x.\n\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n        noiseless : bool\n            whether to include the noise variance or not to the returned variance\n\n        Returns\n        -------\n        tuple\n            GP (mean, var) at x where\n                mean : np.array\n                    with shape (x.shape[0], 1)\n                var : np.array\n                    with shape (x.shape[0], 1)\n\n        \"\"\"", "\n", "X", "=", "np", ".", "asanyarray", "(", "X", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "X", "=", "(", "X", "-", "self", ".", "x_mean", ")", "/", "self", ".", "x_std", "\n", "\n", "\n", "if", "self", ".", "model_type", ".", "mode", "==", "'SGHMC'", ":", "\n", "            ", "fs", "=", "self", ".", "_gp", ".", "predict_y_samples", "(", "X", ",", "self", ".", "S", ")", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "posterior", "is", "None", ":", "\n", "                ", "self", ".", "posterior", "=", "self", ".", "sghmc_optimizer", ".", "collect_samples", "(", "self", ".", "session", ",", "self", ".", "S", ")", "\n", "\n", "", "feed_dict", "=", "{", "}", "\n", "fs", "=", "[", "]", "\n", "for", "s", "in", "self", ".", "posterior", ":", "\n", "                ", "feed_dict", ".", "update", "(", "s", ")", "\n", "sample_fs", "=", "self", ".", "session", ".", "run", "(", "self", ".", "Fs", ",", "feed_dict", "=", "feed_dict", ")", "\n", "fs", ".", "append", "(", "sample_fs", ")", "\n", "", "print", "(", "self", ".", "posterior", ")", "\n", "", "return", "fs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.predict_mean": [[269, 285], ["dgp_regression.DGPRegression.predict"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict"], ["", "def", "predict_mean", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Return the GP model mean function at x.\n\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n\n        Returns\n        -------\n        np.array\n            with shape (x.shape[0], 1)\n\n        \"\"\"", "\n", "return", "self", ".", "predict", "(", "X", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.predict_var": [[287, 303], ["dgp_regression.DGPRegression.predict"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict"], ["", "def", "predict_var", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Return the GP model variance function at x.\n\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n\n        Returns\n        -------\n        np.array\n            with shape (x.shape[0], 1)\n\n        \"\"\"", "\n", "return", "self", ".", "predict", "(", "X", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.predictive_gradients": [[305, 334], ["X.reshape.reshape.reshape", "dgp_regression.DGPRegression.session.run"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "predictive_gradients", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Return the gradients of the GP model mean and variance at x.\n\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n\n        Returns\n        -------\n        tuple\n            GP (grad_mean, grad_var) at x where\n                grad_mean : np.array\n                    with shape (x.shape[0], input_dim)\n                grad_var : np.array\n                    with shape (x.shape[0], input_dim)\n\n        \"\"\"", "\n", "X", "=", "X", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "X", "=", "(", "X", "-", "self", ".", "x_mean", ")", "/", "self", ".", "x_std", "\n", "\n", "feed_dict", "=", "{", "self", ".", "X_placeholder", ":", "X", "}", "\n", "mean_grad_val", ",", "var_grad_val", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "mean_grad", ",", "self", ".", "var_grad", ")", ",", "\n", "feed_dict", "=", "feed_dict", ")", "\n", "# qmean_grad_val, qvar_grad_val = self.session.run((self.qmean_grad, self.qvar_grad),", "\n", "#                                                 feed_dict=feed_dict)", "\n", "# return qmean_grad_val[0], qvar_grad_val[0]", "\n", "return", "mean_grad_val", "[", "0", "]", ",", "var_grad_val", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.predictive_gradient_mean": [[337, 352], ["dgp_regression.DGPRegression.predictive_gradients"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients"], ["", "def", "predictive_gradient_mean", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Return the gradient of the GP model mean at x.\n\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n\n        Returns\n        -------\n        np.array\n            with shape (x.shape[0], input_dim)\n        \"\"\"", "\n", "return", "self", ".", "predictive_gradients", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression._init_gp": [[355, 391], ["numpy.mean", "numpy.std", "map", "numpy.abs", "dgp_regression.DGPRegression.build_model", "dgp_regression.DGPRegression._gp.enquire_session", "dgp_regression.DGPRegression._gp.init_op", "zip", "numpy.array", "numpy.array", "dgp_regression.DGPRegression._gp.clear"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.build_model", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear"], ["", "def", "_init_gp", "(", "self", ",", "X", ",", "Y", ",", "optimize", ")", ":", "\n", "        ", "if", "self", ".", "x_mean", "is", "None", "or", "self", ".", "x_std", "is", "None", ":", "\n", "            ", "min_x", ",", "max_x", "=", "map", "(", "list", ",", "zip", "(", "*", "self", ".", "bounds", ")", ")", "\n", "min_x", ",", "max_x", "=", "np", ".", "array", "(", "min_x", ")", ",", "np", ".", "array", "(", "max_x", ")", "\n", "self", ".", "x_mean", "=", "(", "max_x", "+", "min_x", ")", "/", "2.0", "\n", "self", ".", "x_std", "=", "np", ".", "abs", "(", "max_x", "-", "self", ".", "x_mean", ")", "\n", "\n", "", "self", ".", "y_mean", "=", "np", ".", "mean", "(", "Y", ",", "0", ")", "\n", "self", ".", "y_std", "=", "np", ".", "std", "(", "Y", ",", "0", ")", "\n", "X", "=", "(", "X", "-", "self", ".", "x_mean", ")", "/", "self", ".", "x_std", "\n", "Y", "=", "(", "Y", "-", "self", ".", "y_mean", ")", "/", "self", ".", "y_std", "\n", "\n", "cond", "=", "False", "\n", "if", "self", ".", "_gp", "is", "not", "None", ":", "\n", "            ", "self", ".", "_gp", ".", "X", "=", "X", "\n", "self", ".", "_gp", ".", "Y", "=", "Y", "\n", "cond", "=", "False", "\n", "\n", "\n", "", "if", "optimize", "==", "True", ":", "\n", "\n", "            ", "if", "self", ".", "_gp", "is", "not", "None", ":", "\n", "                ", "self", ".", "_gp", ".", "clear", "(", ")", "\n", "", "self", ".", "_gp", "=", "self", ".", "build_model", "(", "self", ".", "model_type", ",", "X", ",", "Y", ",", "conditioning", "=", "cond", ",", "apply_name", "=", "None", ")", "\n", "self", ".", "_gp", ".", "model_name", "=", "'LV-GP-GP'", "\n", "self", ".", "session", "=", "self", ".", "_gp", ".", "enquire_session", "(", ")", "\n", "self", ".", "_gp", ".", "init_op", "(", "self", ".", "session", ")", "\n", "\n", "", "'''if cond == False:\n            self.optimize()\n\n            self.mlls.append(self._gp.compute_log_likelihood())\n            print('\\n\\n')\n            print(self.mlls[-1])\n            print(\"Finished training\")\n            self._gp.anchor(self.session)'''", "\n", "#plot_samples(model, path)", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.build_model": [[396, 613], ["tensorflow.Variable", "tensorflow.assign_add", "tensorflow.placeholder", "elfi.methods.bo.iwvi.models.DGP_IWVI._build_predict", "tensorflow.gradients", "tensorflow.gradients", "dgp_regression.DGPRegression._gp.clear", "gpflow.defer_build", "elfi.methods.bo.iwvi.models.DGP_IWVI.compile", "elfi.methods.bo.iwvi.models.DGP_IWVI.layers[].q_mu.set_trainable", "elfi.methods.bo.iwvi.models.DGP_IWVI.layers[].q_sqrt.set_trainable", "tensorflow.cast", "tensorflow.cast", "gpflow.training.NatGradOptimizer().make_optimize_tensor", "gpflow.training.AdamOptimizer().make_optimize_tensor", "elfi.methods.bo.iwvi.models.DGP_IWVI.compile", "gpflow.training.AdamOptimizer().make_optimize_tensor", "elfi.methods.bo.iwvi.sghmc.SGHMC", "gpflow.settings.get_settings", "numpy.linspace", "Z.reshape.reshape.reshape", "numpy.linalg.svd", "gpflow.defer_build", "gpflow.likelihoods.Gaussian", "gpflow.kernels.RBF", "numpy.random.randn", "layers.append", "elfi.methods.bo.iwvi.models.DGP_VI", "isinstance", "tensorflow.train.exponential_decay", "tensorflow.train.exponential_decay", "s.run", "s.run", "s.run", "s.run", "hasattr", "dgp_regression.DGPRegression.sghmc_optimizer.train_hypers", "tensorflow.get_collection", "s.run", "s.run", "scipy.cluster.vq.kmeans2", "len", "ARGS.configuration.split", "elfi.methods.bo.iwvi.layers.GPLayer", "elfi.methods.bo.iwvi.models.DGP_VI", "gpflow.training.NatGradOptimizer", "gpflow.training.AdamOptimizer", "tensorflow.variables_initializer", "sghmc_vars.append", "gpflow.training.AdamOptimizer", "s.run", "dgp_regression.DGPRegression.sghmc_optimizer.sghmc_step", "tensorflow.variable_scope", "dgp_regression.DGPRegression.sghmc_optimizer.generate_update_step", "tensorflow.variables_initializer", "tensorflow.variables_initializer", "gpflow.features.InducingPoints", "hasattr", "elfi.methods.bo.iwvi.models.DGP_IWVI", "layer.q_sqrt.read_value", "int", "numpy.zeros", "min", "numpy.eye", "gpflow.mean_functions.Linear", "gpflow.mean_functions.Linear.b.set_trainable", "numpy.zeros", "numpy.random.randn", "elfi.methods.bo.iwvi.temp_workaround.SharedMixedMok", "gpflow.multioutput.features.MixedKernelSharedMof", "elfi.methods.bo.iwvi.layers.GPLayer", "layers.append", "float", "min", "min", "layer.q_mu.set_trainable", "gpflow.kernels.RBF", "gpflow.kernels.RBF.variance.set_trainable", "dgp_regression.DGPRegression.build_model.make_kern"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI._build_predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.clear", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.train_hypers", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.sghmc_step", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.generate_update_step", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "build_model", "(", "self", ",", "ARGS", ",", "X", ",", "Y", ",", "conditioning", "=", "False", ",", "apply_name", "=", "True", ",", "\n", "noise_var", "=", "None", ",", "mean_function", "=", "None", ")", ":", "\n", "\n", "        ", "if", "conditioning", "==", "False", ":", "\n", "            ", "N", ",", "D", "=", "X", ".", "shape", "\n", "\n", "# first layer inducing points", "\n", "if", "N", ">", "ARGS", ".", "M", ":", "\n", "                ", "Z", "=", "kmeans2", "(", "X", ",", "ARGS", ".", "M", ",", "minit", "=", "'points'", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "# This is the old way of initializing Zs", "\n", "# M_pad = ARGS.M - N", "\n", "# Z = np.concatenate([X.copy(), np.random.randn(M_pad, D)], 0)", "\n", "\n", "# This is the new way of initializing Zs", "\n", "                ", "min_x", ",", "max_x", "=", "self", ".", "bounds", "[", "0", "]", "\n", "min_x", "=", "(", "min_x", "-", "self", ".", "x_mean", ")", "/", "self", ".", "x_std", "\n", "max_x", "=", "(", "max_x", "-", "self", ".", "x_mean", ")", "/", "self", ".", "x_std", "\n", "\n", "Z", "=", "np", ".", "linspace", "(", "min_x", ",", "max_x", ",", "num", "=", "ARGS", ".", "M", ")", "# * X.shape[1])", "\n", "Z", "=", "Z", ".", "reshape", "(", "(", "-", "1", ",", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "#print(min_x)", "\n", "#print(max_x)", "\n", "#print(Z)", "\n", "\n", "\n", "#################################### layers", "\n", "", "P", "=", "np", ".", "linalg", ".", "svd", "(", "X", ",", "full_matrices", "=", "False", ")", "[", "2", "]", "\n", "# PX = P.copy()", "\n", "\n", "layers", "=", "[", "]", "\n", "# quad_layers = []", "\n", "\n", "DX", "=", "D", "\n", "DY", "=", "1", "\n", "\n", "D_in", "=", "D", "\n", "D_out", "=", "D", "\n", "\n", "with", "defer_build", "(", ")", ":", "\n", "\n", "# variance initialiaztion", "\n", "                ", "lik", "=", "Gaussian", "(", ")", "\n", "lik", ".", "variance", "=", "ARGS", ".", "likelihood_variance", "\n", "\n", "if", "len", "(", "ARGS", ".", "configuration", ")", ">", "0", ":", "\n", "                    ", "for", "c", ",", "d", "in", "ARGS", ".", "configuration", ".", "split", "(", "'_'", ")", ":", "\n", "                        ", "if", "c", "==", "'G'", ":", "\n", "                            ", "num_gps", "=", "int", "(", "d", ")", "\n", "A", "=", "np", ".", "zeros", "(", "(", "D_in", ",", "D_out", ")", ")", "\n", "D_min", "=", "min", "(", "D_in", ",", "D_out", ")", "\n", "A", "[", ":", "D_min", ",", ":", "D_min", "]", "=", "np", ".", "eye", "(", "D_min", ")", "\n", "mf", "=", "Linear", "(", "A", "=", "A", ")", "\n", "mf", ".", "b", ".", "set_trainable", "(", "False", ")", "\n", "\n", "def", "make_kern", "(", ")", ":", "\n", "                                ", "k", "=", "RBF", "(", "D_in", ",", "lengthscales", "=", "float", "(", "D_in", ")", "**", "0.5", ",", "variance", "=", "1.", ",", "ARD", "=", "True", ")", "\n", "k", ".", "variance", ".", "set_trainable", "(", "False", ")", "\n", "return", "k", "\n", "\n", "", "PP", "=", "np", ".", "zeros", "(", "(", "D_out", ",", "num_gps", ")", ")", "\n", "PP", "[", ":", ",", ":", "min", "(", "num_gps", ",", "DX", ")", "]", "=", "P", "[", ":", ",", ":", "min", "(", "num_gps", ",", "DX", ")", "]", "\n", "ZZ", "=", "np", ".", "random", ".", "randn", "(", "ARGS", ".", "M", ",", "D_in", ")", "\n", "# print(Z.shape)", "\n", "# print(ZZ.shape)", "\n", "ZZ", "[", ":", ",", ":", "min", "(", "D_in", ",", "DX", ")", "]", "=", "Z", "[", ":", ",", ":", "min", "(", "D_in", ",", "DX", ")", "]", "\n", "\n", "kern", "=", "SharedMixedMok", "(", "make_kern", "(", ")", ",", "W", "=", "PP", ")", "\n", "inducing", "=", "MixedKernelSharedMof", "(", "InducingPoints", "(", "ZZ", ")", ")", "\n", "\n", "l", "=", "GPLayer", "(", "kern", ",", "inducing", ",", "num_gps", ",", "mean_function", "=", "mf", ")", "\n", "if", "ARGS", ".", "fix_linear", "is", "True", ":", "\n", "                                ", "kern", ".", "W", ".", "set_trainable", "(", "False", ")", "\n", "mf", ".", "set_trainable", "(", "False", ")", "\n", "\n", "", "layers", ".", "append", "(", "l", ")", "\n", "\n", "D_in", "=", "D_out", "\n", "\n", "", "elif", "c", "==", "'L'", ":", "\n", "                            ", "d", "=", "int", "(", "d", ")", "\n", "D_in", "+=", "d", "\n", "layers", ".", "append", "(", "LatentVariableLayer", "(", "d", ",", "XY_dim", "=", "DX", "+", "1", ")", ")", "\n", "\n", "# kernel initialization", "\n", "", "", "", "kern", "=", "RBF", "(", "D_in", ",", "lengthscales", "=", "float", "(", "D_in", ")", "**", "0.5", ",", "variance", "=", "1.", ",", "ARD", "=", "True", ")", "\n", "ZZ", "=", "np", ".", "random", ".", "randn", "(", "ARGS", ".", "M", ",", "D_in", ")", "\n", "ZZ", "[", ":", ",", ":", "min", "(", "D_in", ",", "DX", ")", "]", "=", "Z", "[", ":", ",", ":", "min", "(", "D_in", ",", "DX", ")", "]", "\n", "layers", ".", "append", "(", "GPLayer", "(", "kern", ",", "InducingPoints", "(", "ZZ", ")", ",", "DY", ")", ")", "\n", "self", ".", "layers", "=", "layers", "\n", "self", ".", "lik", "=", "lik", "\n", "\n", "# global_step = tf.Variable(0, dtype=tf.int32)", "\n", "# self.global_step = global_step", "\n", "", "", "else", ":", "\n", "            ", "lik", "=", "self", ".", "_gp", ".", "likelihood", "\n", "layers", "=", "self", ".", "_gp", ".", "layers", ".", "_list", "\n", "# val = self.session.run(self.global_step)", "\n", "# global_step = tf.Variable(val, dtype=tf.int32)", "\n", "# self.global_step = global_step", "\n", "self", ".", "_gp", ".", "clear", "(", ")", "\n", "\n", "\n", "", "with", "defer_build", "(", ")", ":", "\n", "\n", "#################################### model", "\n", "            ", "name", "=", "'Model'", "if", "apply_name", "else", "None", "\n", "\n", "\n", "if", "ARGS", ".", "mode", "==", "'VI'", ":", "\n", "                ", "model", "=", "DGP_VI", "(", "X", ",", "Y", ",", "layers", ",", "lik", ",", "\n", "minibatch_size", "=", "ARGS", ".", "minibatch_size", ",", "\n", "name", "=", "name", ")", "\n", "\n", "", "elif", "ARGS", ".", "mode", "==", "'SGHMC'", ":", "\n", "                ", "for", "layer", "in", "layers", ":", "\n", "                    ", "if", "hasattr", "(", "layer", ",", "'q_sqrt'", ")", ":", "\n", "                        ", "del", "layer", ".", "q_sqrt", "\n", "layer", ".", "q_sqrt", "=", "None", "\n", "layer", ".", "q_mu", ".", "set_trainable", "(", "False", ")", "\n", "\n", "", "", "model", "=", "DGP_VI", "(", "X", ",", "Y", ",", "layers", ",", "lik", ",", "\n", "minibatch_size", "=", "ARGS", ".", "minibatch_size", ",", "\n", "name", "=", "name", ")", "\n", "\n", "\n", "", "elif", "ARGS", ".", "mode", "==", "'IWAE'", ":", "\n", "                ", "model", "=", "DGP_IWVI", "(", "X", ",", "Y", ",", "layers", ",", "lik", ",", "\n", "minibatch_size", "=", "ARGS", ".", "minibatch_size", ",", "\n", "num_samples", "=", "ARGS", ".", "num_IW_samples", ",", "\n", "name", "=", "name", ")", "\n", "\n", "", "", "global_step", "=", "tf", ".", "Variable", "(", "0", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "op_increment", "=", "tf", ".", "assign_add", "(", "global_step", ",", "1", ")", "\n", "\n", "if", "not", "(", "'SGHMC'", "==", "ARGS", ".", "mode", ")", ":", "\n", "            ", "for", "layer", "in", "model", ".", "layers", "[", ":", "-", "1", "]", ":", "\n", "                ", "if", "isinstance", "(", "layer", ",", "GPLayer", ")", ":", "\n", "                    ", "layer", ".", "q_sqrt", "=", "layer", ".", "q_sqrt", ".", "read_value", "(", ")", "*", "1e-5", "\n", "\n", "", "", "model", ".", "compile", "(", ")", "\n", "\n", "#################################### optimization", "\n", "\n", "var_list", "=", "[", "[", "model", ".", "layers", "[", "-", "1", "]", ".", "q_mu", ",", "model", ".", "layers", "[", "-", "1", "]", ".", "q_sqrt", "]", "]", "\n", "\n", "model", ".", "layers", "[", "-", "1", "]", ".", "q_mu", ".", "set_trainable", "(", "False", ")", "\n", "model", ".", "layers", "[", "-", "1", "]", ".", "q_sqrt", ".", "set_trainable", "(", "False", ")", "\n", "\n", "gamma", "=", "tf", ".", "cast", "(", "tf", ".", "train", ".", "exponential_decay", "(", "ARGS", ".", "gamma", ",", "global_step", ",", "1000", ",", "ARGS", ".", "gamma_decay", ",", "staircase", "=", "True", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", "\n", "lr", "=", "tf", ".", "cast", "(", "tf", ".", "train", ".", "exponential_decay", "(", "ARGS", ".", "lr", ",", "global_step", ",", "1000", ",", "ARGS", ".", "lr_decay", ",", "staircase", "=", "True", ")", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "\n", "op_ng", "=", "NatGradOptimizer", "(", "gamma", "=", "gamma", ")", ".", "make_optimize_tensor", "(", "model", ",", "var_list", "=", "var_list", ")", "\n", "\n", "op_adam", "=", "AdamOptimizer", "(", "lr", ")", ".", "make_optimize_tensor", "(", "model", ")", "\n", "\n", "def", "train", "(", "s", ")", ":", "\n", "                ", "s", ".", "run", "(", "op_increment", ")", "\n", "s", ".", "run", "(", "op_ng", ")", "\n", "s", ".", "run", "(", "op_adam", ")", "\n", "\n", "", "model", ".", "train_op", "=", "train", "\n", "model", ".", "init_op", "=", "lambda", "s", ":", "s", ".", "run", "(", "tf", ".", "variables_initializer", "(", "[", "global_step", "]", ")", ")", "\n", "model", ".", "global_step", "=", "global_step", "\n", "\n", "", "else", ":", "\n", "            ", "model", ".", "compile", "(", ")", "\n", "\n", "sghmc_vars", "=", "[", "]", "\n", "for", "layer", "in", "layers", ":", "\n", "                ", "if", "hasattr", "(", "layer", ",", "'q_mu'", ")", ":", "\n", "                    ", "sghmc_vars", ".", "append", "(", "layer", ".", "q_mu", ".", "unconstrained_tensor", ")", "\n", "\n", "", "", "hyper_train_op", "=", "AdamOptimizer", "(", "ARGS", ".", "lr", ")", ".", "make_optimize_tensor", "(", "model", ")", "\n", "\n", "self", ".", "sghmc_optimizer", "=", "SGHMC", "(", "model", ",", "sghmc_vars", ",", "hyper_train_op", ",", "100", ")", "\n", "\n", "def", "train_op", "(", "s", ")", ":", "\n", "                ", "s", ".", "run", "(", "op_increment", ")", ",", "\n", "self", ".", "sghmc_optimizer", ".", "sghmc_step", "(", "s", ")", ",", "\n", "self", ".", "sghmc_optimizer", ".", "train_hypers", "(", "s", ")", "\n", "\n", "", "model", ".", "train_op", "=", "train_op", "\n", "model", ".", "sghmc_optimizer", "=", "self", ".", "sghmc_optimizer", "\n", "def", "init_op", "(", "s", ")", ":", "\n", "                ", "epsilon", "=", "0.01", "\n", "mdecay", "=", "0.05", "\n", "with", "tf", ".", "variable_scope", "(", "'sghmc'", ")", ":", "\n", "                    ", "self", ".", "sghmc_optimizer", ".", "generate_update_step", "(", "epsilon", ",", "mdecay", ")", "\n", "", "v", "=", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "GLOBAL_VARIABLES", ",", "scope", "=", "'sghmc'", ")", "\n", "s", ".", "run", "(", "tf", ".", "variables_initializer", "(", "v", ")", ")", "\n", "s", ".", "run", "(", "tf", ".", "variables_initializer", "(", "[", "global_step", "]", ")", ")", "\n", "\n", "# Added jitter due to input matrix invertability problems", "\n", "", "custom_config", "=", "gpflow", ".", "settings", ".", "get_settings", "(", ")", "\n", "custom_config", ".", "numerics", ".", "jitter_level", "=", "1e-8", "\n", "\n", "model", ".", "init_op", "=", "init_op", "\n", "model", ".", "global_step", "=", "global_step", "\n", "\n", "# build the computation graph for the gradient", "\n", "", "self", ".", "X_placeholder", "=", "tf", ".", "placeholder", "(", "tf", ".", "float64", ",", "shape", "=", "[", "None", ",", "X", ".", "shape", "[", "1", "]", "]", ")", "\n", "self", ".", "Fs", ",", "Fmu", ",", "Fvar", "=", "model", ".", "_build_predict", "(", "self", ".", "X_placeholder", ")", "\n", "self", ".", "mean_grad", "=", "tf", ".", "gradients", "(", "Fmu", ",", "self", ".", "X_placeholder", ")", "\n", "self", ".", "var_grad", "=", "tf", ".", "gradients", "(", "Fvar", ",", "self", ".", "X_placeholder", ")", "\n", "\n", "# calculated the gradient of the mean for the quantile-filtered distribution", "\n", "# print(Fs)", "\n", "# q = np.quantile(Fs, self.quantile, axis=0)", "\n", "# qFs = [f for f in Fs if f < q]", "\n", "# q_mean = np.mean(qFs, axis=0)", "\n", "# q_var = np.var(qFs, axis=0)", "\n", "# self.qmean_grad = tf.gradients(q_mean, self.X_placeholder)", "\n", "# self.qvar_grad = tf.gradients(q_var, self.X_placeholder)", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.update": [[616, 650], ["X.reshape.reshape.reshape", "Y.reshape.reshape.reshape", "dgp_regression.DGPRegression._init_gp", "dgp_regression.DGPRegression.optimize", "dgp_regression.DGPRegression.mlls.append", "print", "dgp_regression.DGPRegression._gp.anchor", "dgp_regression.DGPRegression._gp.compute_log_likelihood", "str"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._init_gp", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.optimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "update", "(", "self", ",", "X", ",", "Y", ",", "optimize", "=", "False", ")", ":", "\n", "        ", "\"\"\"Update the GP model with new data.\n\n        Parameters\n        ----------\n        x : np.array\n        y : np.array\n        optimize : bool, optional\n            Whether to optimize hyperparameters.\n\n        \"\"\"", "\n", "# Must cast these as 2d for GPy      ", "\n", "X", "=", "X", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "Y", "=", "Y", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "if", "self", ".", "X", "is", "None", "or", "self", ".", "Y", "is", "None", ":", "\n", "            ", "self", ".", "X", "=", "X", "\n", "self", ".", "Y", "=", "Y", "\n", "", "else", ":", "\n", "            ", "self", ".", "X", "=", "np", ".", "r_", "[", "self", ".", "X", ",", "X", "]", "\n", "self", ".", "Y", "=", "np", ".", "r_", "[", "self", ".", "Y", ",", "Y", "]", "\n", "\n", "", "self", ".", "_init_gp", "(", "self", ".", "X", ",", "self", ".", "Y", ",", "optimize", ")", "\n", "\n", "# print(self.X)", "\n", "# print(\"Optimize? (dgp_regression.py)\" + str(optimize))", "\n", "\n", "if", "optimize", ":", "\n", "            ", "self", ".", "optimize", "(", ")", "\n", "\n", "", "if", "self", ".", "_gp", "is", "not", "None", ":", "\n", "            ", "self", ".", "mlls", ".", "append", "(", "self", ".", "_gp", ".", "compute_log_likelihood", "(", ")", ")", "\n", "print", "(", "'\\nMLL of the iteration: '", "+", "str", "(", "self", ".", "mlls", "[", "-", "1", "]", ")", "+", "'\\n'", ")", "\n", "self", ".", "_gp", ".", "anchor", "(", "self", ".", "session", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.optimize": [[652, 657], ["logger.debug", "range", "dgp_regression.DGPRegression._gp.train_op"], "methods", ["None"], ["", "", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Optimize DGP hyperparameters.\"\"\"", "\n", "logger", ".", "debug", "(", "\"Optimizing DGP hyperparameters\"", ")", "\n", "for", "it", "in", "range", "(", "self", ".", "its", ")", ":", "\n", "            ", "self", ".", "_gp", ".", "train_op", "(", "self", ".", "session", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.get_HMC_samples": [[661, 663], ["dgp_regression.DGPRegression.sghmc_optimizer.collect_samples"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.collect_samples"], ["", "", "def", "get_HMC_samples", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sghmc_optimizer", ".", "collect_samples", "(", "self", ".", "session", ",", "num", "=", "1000", ",", "spacing", "=", "50", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.get_posterior": [[665, 683], ["numpy.asanyarray().reshape", "dgp_regression.DGPRegression._gp.predict_y_samples", "numpy.asanyarray"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI.predict_y_samples"], ["", "def", "get_posterior", "(", "self", ",", "x", ",", "size", ")", ":", "\n", "        ", "x", "=", "np", ".", "asanyarray", "(", "x", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "x", "=", "(", "x", "-", "self", ".", "x_mean", ")", "/", "self", ".", "x_std", "\n", "# f = self._gp.predict_y_samples(x, size, session=self.session)", "\n", "\n", "fs", "=", "self", ".", "_gp", ".", "predict_y_samples", "(", "x", ",", "size", ",", "session", "=", "self", ".", "session", ")", "\n", "\n", "'''if self.model_type.mode == None: \n            if self.posterior is None:\n                self.posterior =  self.hmc_optimizer.collect_samples(self.session, self.S)\n\n            fs = []\n            for s in self.posterior:\n                feed_dict = {self.X_placeholder: x}\n                feed_dict.update(s)\n                sample_fs = self.session.run(self.Fmu, feed_dict=feed_dict)\n                fs.append(sample_fs)'''", "\n", "return", "fs", "*", "self", ".", "y_std", "+", "self", ".", "y_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.plot_mlls": [[685, 697], ["list", "range", "matplotlib.xticks", "matplotlib.grid", "matplotlib.plot", "matplotlib.legend", "len", "list.append", "numpy.arange", "min", "max"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.plot", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "plot_mlls", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_gp", "is", "None", ":", "\n", "            ", "return", "\n", "\n", "", "x", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "mlls", ")", ")", ":", "\n", "            ", "x", ".", "append", "(", "i", "+", "1", ")", "\n", "", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "min", "(", "x", ")", ",", "max", "(", "x", ")", "+", "1", ")", ")", "\n", "plt", ".", "grid", "(", "color", "=", "'grey'", ",", "linestyle", "=", "'-'", ",", "linewidth", "=", "0.5", ")", "\n", "plt", ".", "plot", "(", "x", ",", "self", ".", "mlls", ",", "color", "=", "'blue'", ",", "label", "=", "'LogLik'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'upper left'", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.del_graph": [[709, 712], ["gpflow.reset_default_graph_and_session"], "methods", ["None"], ["def", "del_graph", "(", "self", ")", ":", "\n", "        ", "gpflow", ".", "reset_default_graph_and_session", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.n_evidence": [[713, 719], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_evidence", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of observed samples.\"\"\"", "\n", "if", "self", ".", "_gp", "is", "None", ":", "\n", "            ", "return", "0", "\n", "", "return", "self", ".", "_gp", ".", "X", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.noise": [[732, 736], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "noise", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the noise.\"\"\"", "\n", "return", "self", ".", "_gp", ".", "Gaussian_noise", ".", "variance", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.instance": [[738, 742], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "instance", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the gp instance.\"\"\"", "\n", "return", "self", ".", "_gp", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.copy": [[744, 748], ["copy.copy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of current instance.\"\"\"", "\n", "kopy", "=", "copy", ".", "copy", "(", "self", ")", "\n", "return", "kopy", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.dgp_regression.DGPRegression.__copy__": [[749, 752], ["dgp_regression.DGPRegression.copy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "def", "__copy__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of current instance.\"\"\"", "\n", "return", "self", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__init__": [[21, 89], ["isinstance", "logger.warning", "len", "ValueError", "len", "ValueError", "isinstance", "ValueError", "len", "len", "bounds.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "parameter_names", "=", "None", ",", "\n", "bounds", "=", "None", ",", "\n", "optimizer", "=", "\"scg\"", ",", "\n", "max_opt_iters", "=", "50", ",", "\n", "gp", "=", "None", ",", "\n", "**", "gp_params", ")", ":", "\n", "        ", "\"\"\"Initialize GPyRegression.\n\n        Parameters\n        ----------\n        parameter_names : list of str, optional\n            Names of parameter nodes. If None, sets dimension to 1.\n        bounds : dict, optional\n            The region where to estimate the posterior for each parameter in\n            model.parameters.\n            `{'parameter_name':(lower, upper), ... }`\n            If not supplied, defaults to (0, 1) bounds for all dimensions.\n        optimizer : string, optional\n            Optimizer for the GP hyper parameters\n            Alternatives: \"scg\", \"fmin_tnc\", \"simplex\", \"lbfgsb\", \"lbfgs\", \"sgd\"\n            See also: paramz.Model.optimize()\n        max_opt_iters : int, optional\n        gp : GPy.model.GPRegression instance, optional\n        **gp_params\n            kernel : GPy.Kern\n            noise_var : float\n            mean_function\n\n        \"\"\"", "\n", "if", "parameter_names", "is", "None", ":", "\n", "            ", "input_dim", "=", "1", "\n", "", "elif", "isinstance", "(", "parameter_names", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "input_dim", "=", "len", "(", "parameter_names", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Keyword `parameter_names` must be a list of strings\"", ")", "\n", "\n", "", "if", "bounds", "is", "None", ":", "\n", "            ", "logger", ".", "warning", "(", "'Parameter bounds not specified. Using [0,1] for each parameter.'", ")", "\n", "bounds", "=", "[", "(", "0", ",", "1", ")", "]", "*", "input_dim", "\n", "", "elif", "len", "(", "bounds", ")", "!=", "input_dim", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "'Length of `bounds` ({}) does not match the length of `parameter_names` ({}).'", "\n", ".", "format", "(", "len", "(", "bounds", ")", ",", "input_dim", ")", ")", "\n", "\n", "", "elif", "isinstance", "(", "bounds", ",", "dict", ")", ":", "\n", "            ", "if", "len", "(", "bounds", ")", "==", "1", ":", "# might be the case parameter_names=None", "\n", "                ", "bounds", "=", "[", "bounds", "[", "n", "]", "for", "n", "in", "bounds", ".", "keys", "(", ")", "]", "\n", "", "else", ":", "\n", "# turn bounds dict into a list in the same order as parameter_names", "\n", "                ", "bounds", "=", "[", "bounds", "[", "n", "]", "for", "n", "in", "parameter_names", "]", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Keyword `bounds` must be a dictionary \"", "\n", "\"`{'parameter_name': (lower, upper), ... }`\"", ")", "\n", "\n", "", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "bounds", "=", "bounds", "\n", "\n", "self", ".", "gp_params", "=", "gp_params", "\n", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "max_opt_iters", "=", "max_opt_iters", "\n", "\n", "self", ".", "_gp", "=", "gp", "\n", "self", ".", "mlls", "=", "[", "]", "\n", "\n", "self", ".", "_rbf_is_cached", "=", "False", "\n", "self", ".", "is_sampling", "=", "False", "# set to True once in sampling phase", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__str__": [[90, 93], ["gpy_regression.GPyRegression._gp.__str__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__str__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return GPy's __str__.\"\"\"", "\n", "return", "self", ".", "_gp", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__repr__": [[94, 97], ["gpy_regression.GPyRegression.__str__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return GPy's __str__.\"\"\"", "\n", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict": [[98, 147], ["numpy.asanyarray().reshape", "kx.dot", "kx.dot", "gpy_regression.GPyRegression._gp.predict_noiseless", "gpy_regression.GPyRegression._gp.predict", "numpy.asanyarray", "numpy.zeros", "numpy.ones", "gpy_regression.GPyRegression._cache_RBF_kernel", "gpy_regression.GPyRegression._rbf_woodbury_inv.dot", "numpy.asanyarray().reshape.dot", "numpy.exp", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._cache_RBF_kernel"], ["", "def", "predict", "(", "self", ",", "x", ",", "noiseless", "=", "False", ")", ":", "\n", "        ", "\"\"\"Return the GP model mean and variance at x.\n\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n        noiseless : bool\n            whether to include the noise variance or not to the returned variance\n\n        Returns\n        -------\n        tuple\n            GP (mean, var) at x where\n                mean : np.array\n                    with shape (x.shape[0], 1)\n                var : np.array\n                    with shape (x.shape[0], 1)\n        \"\"\"", "\n", "# Ensure it's 2d for GPy", "\n", "x", "=", "np", ".", "asanyarray", "(", "x", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "\n", "if", "self", ".", "_gp", "is", "None", ":", "\n", "# TODO: return from GP mean function if given", "\n", "            ", "return", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n", "# direct (=faster) implementation for RBF kernel", "\n", "", "if", "self", ".", "is_sampling", "and", "self", ".", "_kernel_is_default", ":", "\n", "            ", "if", "not", "self", ".", "_rbf_is_cached", ":", "\n", "                ", "self", ".", "_cache_RBF_kernel", "(", ")", "\n", "\n", "", "r2", "=", "np", ".", "sum", "(", "x", "**", "2.", ",", "1", ")", "[", ":", ",", "None", "]", "+", "self", ".", "_rbf_x2sum", "-", "2.", "*", "x", ".", "dot", "(", "self", ".", "_gp", ".", "X", ".", "T", ")", "\n", "kx", "=", "self", ".", "_rbf_var", "*", "np", ".", "exp", "(", "r2", "*", "self", ".", "_rbf_factor", ")", "+", "self", ".", "_rbf_bias", "\n", "mu", "=", "kx", ".", "dot", "(", "self", ".", "_rbf_woodbury", ")", "\n", "\n", "var", "=", "self", ".", "_rbf_var", "+", "self", ".", "_rbf_bias", "\n", "var", "-=", "kx", ".", "dot", "(", "self", ".", "_rbf_woodbury_inv", ".", "dot", "(", "kx", ".", "T", ")", ")", "\n", "var", "+=", "self", ".", "_rbf_noisevar", "# likelihood", "\n", "\n", "return", "mu", ",", "var", "\n", "", "else", ":", "\n", "            ", "self", ".", "_rbf_is_cached", "=", "False", "# in case one resumes fitting the GP after sampling", "\n", "\n", "", "if", "noiseless", ":", "\n", "            ", "return", "self", ".", "_gp", ".", "predict_noiseless", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_gp", ".", "predict", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._cache_RBF_kernel": [[150, 160], ["float", "float", "float", "numpy.sum", "float", "gpy_regression.GPyRegression._gp.kern.bias.K"], "methods", ["None"], ["", "", "def", "_cache_RBF_kernel", "(", "self", ")", ":", "\n", "        ", "self", ".", "_rbf_var", "=", "float", "(", "self", ".", "_gp", ".", "kern", ".", "rbf", ".", "variance", ")", "\n", "self", ".", "_rbf_factor", "=", "-", "0.5", "/", "float", "(", "self", ".", "_gp", ".", "kern", ".", "rbf", ".", "lengthscale", ")", "**", "2", "\n", "self", ".", "_rbf_bias", "=", "float", "(", "self", ".", "_gp", ".", "kern", ".", "bias", ".", "K", "(", "self", ".", "_gp", ".", "X", ")", "[", "0", ",", "0", "]", ")", "\n", "self", ".", "_rbf_noisevar", "=", "float", "(", "self", ".", "_gp", ".", "likelihood", ".", "variance", "[", "0", "]", ")", "\n", "self", ".", "_rbf_woodbury", "=", "self", ".", "_gp", ".", "posterior", ".", "woodbury_vector", "\n", "self", ".", "_rbf_woodbury_inv", "=", "self", ".", "_gp", ".", "posterior", ".", "woodbury_inv", "\n", "self", ".", "_rbf_woodbury_chol", "=", "self", ".", "_gp", ".", "posterior", ".", "woodbury_chol", "\n", "self", ".", "_rbf_x2sum", "=", "np", ".", "sum", "(", "self", ".", "_gp", ".", "X", "**", "2.", ",", "1", ")", "[", "None", ",", ":", "]", "\n", "self", ".", "_rbf_is_cached", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict_mean": [[161, 174], ["[].flatten", "gpy_regression.GPyRegression.predict"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict"], ["", "def", "predict_mean", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Return the GP model mean function at x.\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n        Returns\n        -------\n        np.array\n            with shape (x.shape[0], 1)\n        \"\"\"", "\n", "return", "self", ".", "predict", "(", "x", ")", "[", "0", "]", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict_var": [[175, 188], ["[].flatten", "gpy_regression.GPyRegression.predict"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict"], ["", "def", "predict_var", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Return the GP model mean function at x.\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n        Returns\n        -------\n        np.array\n            with shape (x.shape[0], 1)\n        \"\"\"", "\n", "return", "self", ".", "predict", "(", "x", ")", "[", "1", "]", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients": [[189, 231], ["numpy.asanyarray().reshape", "numpy.linalg.solve", "numpy.linalg.solve", "gpy_regression.GPyRegression._gp.predictive_gradients", "numpy.asanyarray", "numpy.zeros", "numpy.zeros", "gpy_regression.GPyRegression._cache_RBF_kernel", "numpy.exp", "dkdx.T.dot", "numpy.asanyarray().reshape.dot", "numpy.linalg.solve.T.dot", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._cache_RBF_kernel"], ["", "def", "predictive_gradients", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Return the gradients of the GP model mean and variance at x.\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n        Returns\n        -------\n        tuple\n            GP (grad_mean, grad_var) at x where\n                grad_mean : np.array\n                    with shape (x.shape[0], input_dim)\n                grad_var : np.array\n                    with shape (x.shape[0], input_dim)\n        \"\"\"", "\n", "# Ensure it's 2d for GPy", "\n", "x", "=", "np", ".", "asanyarray", "(", "x", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "\n", "if", "self", ".", "_gp", "is", "None", ":", "\n", "# TODO: return from GP mean function if given", "\n", "            ", "return", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "input_dim", ")", ")", ",", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "input_dim", ")", ")", "\n", "\n", "# direct (=faster) implementation for RBF kernel", "\n", "", "if", "self", ".", "is_sampling", "and", "self", ".", "_kernel_is_default", ":", "\n", "            ", "if", "not", "self", ".", "_rbf_is_cached", ":", "\n", "                ", "self", ".", "_cache_RBF_kernel", "(", ")", "\n", "\n", "", "r2", "=", "np", ".", "sum", "(", "x", "**", "2.", ",", "1", ")", "[", ":", ",", "None", "]", "+", "self", ".", "_rbf_x2sum", "-", "2.", "*", "x", ".", "dot", "(", "self", ".", "_gp", ".", "X", ".", "T", ")", "\n", "kx", "=", "self", ".", "_rbf_var", "*", "np", ".", "exp", "(", "r2", "*", "self", ".", "_rbf_factor", ")", "\n", "dkdx", "=", "2.", "*", "self", ".", "_rbf_factor", "*", "(", "x", "-", "self", ".", "_gp", ".", "X", ")", "*", "kx", ".", "T", "\n", "grad_mu", "=", "dkdx", ".", "T", ".", "dot", "(", "self", ".", "_rbf_woodbury", ")", ".", "T", "\n", "\n", "v", "=", "np", ".", "linalg", ".", "solve", "(", "self", ".", "_rbf_woodbury_chol", ",", "kx", ".", "T", "+", "self", ".", "_rbf_bias", ")", "\n", "dvdx", "=", "np", ".", "linalg", ".", "solve", "(", "self", ".", "_rbf_woodbury_chol", ",", "dkdx", ")", "\n", "grad_var", "=", "-", "2.", "*", "dvdx", ".", "T", ".", "dot", "(", "v", ")", ".", "T", "\n", "", "else", ":", "\n", "            ", "grad_mu", ",", "grad_var", "=", "self", ".", "_gp", ".", "predictive_gradients", "(", "x", ")", "\n", "grad_mu", "=", "grad_mu", "[", ":", ",", ":", ",", "0", "]", "# Assume 1D output (distance in ABC)", "\n", "\n", "", "return", "grad_mu", ",", "grad_var", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradient_mean": [[232, 245], ["gpy_regression.GPyRegression.predictive_gradients"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients"], ["", "def", "predictive_gradient_mean", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Return the gradient of the GP model mean at x.\n        Parameters\n        ----------\n        x : np.array\n            numpy compatible (n, input_dim) array of points to evaluate\n            if len(x.shape) == 1 will be cast to 2D with x[None, :]\n        Returns\n        -------\n        np.array\n            with shape (x.shape[0], input_dim)\n        \"\"\"", "\n", "return", "self", ".", "predictive_gradients", "(", "x", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._init_gp": [[246, 263], ["gpy_regression.GPyRegression.gp_params.get", "gpy_regression.GPyRegression._make_gpy_instance", "gpy_regression.GPyRegression.gp_params.get", "gpy_regression.GPyRegression._default_kernel", "gpy_regression.GPyRegression.gp_params.get", "gpy_regression.GPyRegression.gp_params.get", "gpy_regression.GPyRegression.gp_params.get", "gpy_regression.GPyRegression.gp_params.get", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._make_gpy_instance", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._default_kernel"], ["", "def", "_init_gp", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "self", ".", "_kernel_is_default", "=", "False", "\n", "\n", "if", "self", ".", "gp_params", ".", "get", "(", "'kernel'", ")", "is", "None", ":", "\n", "            ", "kernel", "=", "self", ".", "_default_kernel", "(", "x", ",", "y", ")", "\n", "\n", "if", "self", ".", "gp_params", ".", "get", "(", "'noise_var'", ")", "is", "None", "and", "self", ".", "gp_params", ".", "get", "(", "\n", "'mean_function'", ")", "is", "None", ":", "\n", "                ", "self", ".", "_kernel_is_default", "=", "True", "\n", "\n", "", "", "else", ":", "\n", "            ", "kernel", "=", "self", ".", "gp_params", ".", "get", "(", "'kernel'", ")", "\n", "\n", "", "noise_var", "=", "self", ".", "gp_params", ".", "get", "(", "'noise_var'", ")", "or", "np", ".", "max", "(", "y", ")", "**", "2.", "/", "100.", "\n", "mean_function", "=", "self", ".", "gp_params", ".", "get", "(", "'mean_function'", ")", "\n", "self", ".", "_gp", "=", "self", ".", "_make_gpy_instance", "(", "\n", "x", ",", "y", ",", "kernel", "=", "kernel", ",", "noise_var", "=", "noise_var", ",", "mean_function", "=", "mean_function", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._default_kernel": [[264, 285], ["GPy.kern.RBF", "GPy.kern.RBF.lengthscale.set_prior", "GPy.kern.RBF.variance.set_prior", "GPy.priors.Gamma.from_EV", "GPy.priors.Gamma.from_EV", "GPy.kern.Bias", "GPy.kern.Bias.set_prior", "numpy.max", "numpy.min", "numpy.max", "GPy.priors.Gamma.from_EV"], "methods", ["None"], ["", "def", "_default_kernel", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "# Some heuristics to choose kernel parameters based on the initial data", "\n", "        ", "length_scale", "=", "(", "np", ".", "max", "(", "self", ".", "bounds", ")", "-", "np", ".", "min", "(", "self", ".", "bounds", ")", ")", "/", "3.", "\n", "kernel_var", "=", "(", "np", ".", "max", "(", "y", ")", "/", "3.", ")", "**", "2.", "\n", "bias_var", "=", "kernel_var", "/", "4.", "\n", "\n", "# Construct a default kernel", "\n", "kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "self", ".", "input_dim", ")", "\n", "\n", "# Set the priors", "\n", "kernel", ".", "lengthscale", ".", "set_prior", "(", "\n", "GPy", ".", "priors", ".", "Gamma", ".", "from_EV", "(", "length_scale", ",", "length_scale", ")", ",", "warning", "=", "False", ")", "\n", "kernel", ".", "variance", ".", "set_prior", "(", "GPy", ".", "priors", ".", "Gamma", ".", "from_EV", "(", "kernel_var", ",", "kernel_var", ")", ",", "warning", "=", "False", ")", "\n", "\n", "# If no mean function is specified, add a bias term to the kernel", "\n", "if", "'mean_function'", "not", "in", "self", ".", "gp_params", ":", "\n", "            ", "bias", "=", "GPy", ".", "kern", ".", "Bias", "(", "input_dim", "=", "self", ".", "input_dim", ")", "\n", "bias", ".", "set_prior", "(", "GPy", ".", "priors", ".", "Gamma", ".", "from_EV", "(", "bias_var", ",", "bias_var", ")", ",", "warning", "=", "False", ")", "\n", "kernel", "+=", "bias", "\n", "\n", "", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._make_gpy_instance": [[286, 289], ["GPy.models.GPRegression"], "methods", ["None"], ["", "def", "_make_gpy_instance", "(", "self", ",", "x", ",", "y", ",", "kernel", ",", "noise_var", ",", "mean_function", ")", ":", "\n", "        ", "return", "GPy", ".", "models", ".", "GPRegression", "(", "\n", "X", "=", "x", ",", "Y", "=", "y", ",", "kernel", "=", "kernel", ",", "noise_var", "=", "noise_var", ",", "mean_function", "=", "mean_function", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update": [[290, 321], ["x.reshape.reshape.reshape", "y.reshape.reshape.reshape", "gpy_regression.GPyRegression.mlls.append", "print", "gpy_regression.GPyRegression._init_gp", "gpy_regression.GPyRegression._make_gpy_instance", "gpy_regression.GPyRegression.optimize", "gpy_regression.GPyRegression._gp.log_likelihood", "gpy_regression.GPyRegression._gp.kern.copy", "gpy_regression.GPyRegression._gp.mean_function.copy", "str"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._init_gp", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression._make_gpy_instance", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.optimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "def", "update", "(", "self", ",", "x", ",", "y", ",", "optimize", "=", "False", ")", ":", "\n", "        ", "\"\"\"Update the GP model with new data.\n        Parameters\n        ----------\n        x : np.array\n        y : np.array\n        optimize : bool, optional\n            Whether to optimize hyperparameters.\n        \"\"\"", "\n", "# Must cast these as 2d for GPy", "\n", "x", "=", "x", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "y", "=", "y", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "if", "self", ".", "_gp", "is", "None", ":", "\n", "            ", "self", ".", "_init_gp", "(", "x", ",", "y", ")", "\n", "", "else", ":", "\n", "# Reconstruct with new data", "\n", "            ", "x", "=", "np", ".", "r_", "[", "self", ".", "_gp", ".", "X", ",", "x", "]", "\n", "y", "=", "np", ".", "r_", "[", "self", ".", "_gp", ".", "Y", ",", "y", "]", "\n", "# It seems that GPy will do some optimization unless you make copies of everything", "\n", "kernel", "=", "self", ".", "_gp", ".", "kern", ".", "copy", "(", ")", "if", "self", ".", "_gp", ".", "kern", "else", "None", "\n", "noise_var", "=", "self", ".", "_gp", ".", "Gaussian_noise", ".", "variance", "[", "0", "]", "\n", "mean_function", "=", "self", ".", "_gp", ".", "mean_function", ".", "copy", "(", ")", "if", "self", ".", "_gp", ".", "mean_function", "else", "None", "\n", "self", ".", "_gp", "=", "self", ".", "_make_gpy_instance", "(", "\n", "x", ",", "y", ",", "kernel", "=", "kernel", ",", "noise_var", "=", "noise_var", ",", "mean_function", "=", "mean_function", ")", "\n", "\n", "", "if", "optimize", ":", "\n", "            ", "self", ".", "optimize", "(", ")", "\n", "\n", "", "self", ".", "mlls", ".", "append", "(", "self", ".", "_gp", ".", "log_likelihood", "(", ")", ")", "\n", "print", "(", "'\\nMLL of the iteration: '", "+", "str", "(", "self", ".", "mlls", "[", "-", "1", "]", ")", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.get_posterior": [[323, 328], ["numpy.asanyarray().reshape", "gpy_regression.GPyRegression._gp.posterior_samples", "numpy.moveaxis", "numpy.asanyarray"], "methods", ["None"], ["", "def", "get_posterior", "(", "self", ",", "x", ",", "size", ")", ":", "\n", "        ", "x", "=", "np", ".", "asanyarray", "(", "x", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "input_dim", ")", ")", "\n", "res", "=", "self", ".", "_gp", ".", "posterior_samples", "(", "x", ",", "size", "=", "size", ")", "\n", "res", "=", "np", ".", "moveaxis", "(", "res", ",", "[", "0", ",", "1", ",", "2", "]", ",", "[", "-", "2", ",", "-", "1", ",", "-", "3", "]", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.optimize": [[330, 337], ["logger.debug", "gpy_regression.GPyRegression._gp.optimize", "logger.warning"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.optimize"], ["", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Optimize GP hyperparameters.\"\"\"", "\n", "logger", ".", "debug", "(", "\"Optimizing GP hyperparameters\"", ")", "\n", "try", ":", "\n", "            ", "self", ".", "_gp", ".", "optimize", "(", "self", ".", "optimizer", ",", "max_iters", "=", "self", ".", "max_opt_iters", ")", "\n", "", "except", "np", ".", "linalg", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "logger", ".", "warning", "(", "\"Numerical error in GP optimization. Stopping optimization\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.plot_mlls": [[338, 347], ["list", "range", "matplotlib.xticks", "matplotlib.grid", "matplotlib.plot", "matplotlib.legend", "len", "list.append", "numpy.arange", "min", "max"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.posteriors.BolfiPosterior.plot", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "", "def", "plot_mlls", "(", "self", ")", ":", "\n", "        ", "x", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "mlls", ")", ")", ":", "\n", "            ", "x", ".", "append", "(", "i", "+", "1", ")", "\n", "", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "min", "(", "x", ")", ",", "max", "(", "x", ")", "+", "1", ")", ")", "\n", "plt", ".", "grid", "(", "color", "=", "'grey'", ",", "linestyle", "=", "'-'", ",", "linewidth", "=", "0.5", ")", "\n", "plt", ".", "plot", "(", "x", ",", "self", ".", "mlls", ",", "color", "=", "'blue'", ",", "label", "=", "'LogLik'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'upper left'", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.n_evidence": [[348, 354], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_evidence", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of observed samples.\"\"\"", "\n", "if", "self", ".", "_gp", "is", "None", ":", "\n", "            ", "return", "0", "\n", "", "return", "self", ".", "_gp", ".", "num_data", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.X": [[355, 359], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return input evidence.\"\"\"", "\n", "return", "self", ".", "_gp", ".", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.Y": [[360, 364], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output evidence.\"\"\"", "\n", "return", "self", ".", "_gp", ".", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.noise": [[365, 369], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "noise", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the noise.\"\"\"", "\n", "return", "self", ".", "_gp", ".", "Gaussian_noise", ".", "variance", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.instance": [[370, 374], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "instance", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the gp instance.\"\"\"", "\n", "return", "self", ".", "_gp", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy": [[375, 388], ["copy.copy", "gpy_regression.GPyRegression._gp.copy", "gpy_regression.GPyRegression.gp_params[].copy", "gpy_regression.GPyRegression.gp_params[].copy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of current instance.\"\"\"", "\n", "kopy", "=", "copy", ".", "copy", "(", "self", ")", "\n", "if", "self", ".", "_gp", ":", "\n", "            ", "kopy", ".", "_gp", "=", "self", ".", "_gp", ".", "copy", "(", ")", "\n", "\n", "", "if", "'kernel'", "in", "self", ".", "gp_params", ":", "\n", "            ", "kopy", ".", "gp_params", "[", "'kernel'", "]", "=", "self", ".", "gp_params", "[", "'kernel'", "]", ".", "copy", "(", ")", "\n", "\n", "", "if", "'mean_function'", "in", "self", ".", "gp_params", ":", "\n", "            ", "kopy", ".", "gp_params", "[", "'mean_function'", "]", "=", "self", ".", "gp_params", "[", "'mean_function'", "]", ".", "copy", "(", ")", "\n", "\n", "", "return", "kopy", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.__copy__": [[389, 392], ["gpy_regression.GPyRegression.copy"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy"], ["", "def", "__copy__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of current instance.\"\"\"", "\n", "return", "self", ".", "copy", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.__init__": [[11, 27], ["tensorflow.placeholder", "tensorflow.placeholder", "min"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "X", ",", "Y", ",", "Us", ",", "minibatch_size", ",", "window_size", ")", ":", "\n", "        ", "self", ".", "X_placeholder", "=", "tf", ".", "placeholder", "(", "tf", ".", "float64", ",", "shape", "=", "[", "None", ",", "X", ".", "shape", "[", "1", "]", "]", ")", "\n", "self", ".", "Y_placeholder", "=", "tf", ".", "placeholder", "(", "tf", ".", "float64", ",", "shape", "=", "[", "None", ",", "Y", ".", "shape", "[", "1", "]", "]", ")", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "Y", "=", "Y", "\n", "self", ".", "N", "=", "X", ".", "shape", "[", "0", "]", "\n", "self", ".", "Us", "=", "Us", "\n", "self", ".", "prev_vals", "=", "None", "\n", "self", ".", "minibatch_size", "=", "min", "(", "minibatch_size", ",", "self", ".", "N", ")", "\n", "self", ".", "data_iter", "=", "0", "\n", "self", ".", "window_size", "=", "window_size", "\n", "self", ".", "all_samples", "=", "[", "]", "\n", "self", ".", "window", "=", "[", "]", "\n", "self", ".", "posterior_samples", "=", "[", "]", "\n", "self", ".", "sample_op", "=", "None", "\n", "self", ".", "burn_in_op", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.generate_update_step": [[29, 93], ["tensorflow.gradients", "zip", "burn_in_updates.append", "burn_in_updates.append", "burn_in_updates.append", "tensorflow.sqrt", "sample_updates.append", "sample_updates.append", "sghmc_dgp.BaseModel.hypers[].append", "sghmc_dgp.BaseModel.hypers[].append", "sghmc_dgp.BaseModel.hypers[].append", "sghmc_dgp.BaseModel.hypers[].append", "tensorflow.assign", "tensorflow.assign", "range", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.sqrt", "tensorflow.maximum", "tensorflow.random_normal", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.zeros_like", "tensorflow.sqrt", "tensorflow.cast", "tensorflow.shape", "tensorflow.abs"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "generate_update_step", "(", "self", ",", "nll", ",", "epsilon", ",", "mdecay", ",", "sghmc_pars", "=", "None", ")", ":", "\n", "        ", "self", ".", "epsilon", "=", "epsilon", "\n", "burn_in_updates", "=", "[", "]", "\n", "sample_updates", "=", "[", "]", "\n", "\n", "if", "sghmc_pars", "is", "not", "None", ":", "\n", "            ", "prev_xi", "=", "sghmc_pars", "[", "0", "]", "\n", "prev_g", "=", "sghmc_pars", "[", "1", "]", "\n", "prev_g2", "=", "sghmc_pars", "[", "2", "]", "\n", "prev_p", "=", "sghmc_pars", "[", "3", "]", "\n", "\n", "", "grads", "=", "tf", ".", "gradients", "(", "nll", ",", "self", ".", "Us", ")", "\n", "self", ".", "temp_vars", "=", "[", "]", "\n", "layer", "=", "0", "\n", "self", ".", "hypers", "=", "[", "[", "]", "for", "i", "in", "range", "(", "4", ")", "]", "\n", "for", "theta", ",", "grad", "in", "zip", "(", "self", ".", "Us", ",", "grads", ")", ":", "\n", "#grad = tf.clip_by_value(grad, -1, 1)", "\n", "            ", "if", "sghmc_pars", "is", "None", ":", "\n", "                ", "xi", "=", "tf", ".", "Variable", "(", "tf", ".", "ones_like", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "g", "=", "tf", ".", "Variable", "(", "tf", ".", "ones_like", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "g2", "=", "tf", ".", "Variable", "(", "tf", ".", "ones_like", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "p", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros_like", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "# print(layer)", "\n", "                ", "xi", "=", "tf", ".", "Variable", "(", "prev_xi", "[", "layer", "]", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "g", "=", "tf", ".", "Variable", "(", "prev_g", "[", "layer", "]", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "g2", "=", "tf", ".", "Variable", "(", "prev_g2", "[", "layer", "]", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "p", "=", "tf", ".", "Variable", "(", "prev_p", "[", "layer", "]", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "\n", "", "r_t", "=", "1.", "/", "(", "xi", "+", "1.", ")", "\n", "g_t", "=", "(", "1.", "-", "r_t", ")", "*", "g", "+", "r_t", "*", "grad", "\n", "g2_t", "=", "(", "1.", "-", "r_t", ")", "*", "g2", "+", "r_t", "*", "grad", "**", "2", "\n", "xi_t", "=", "1.", "+", "xi", "*", "(", "1.", "-", "g", "*", "g", "/", "(", "g2", "+", "1e-16", ")", ")", "\n", "Minv", "=", "1.", "/", "(", "tf", ".", "sqrt", "(", "tf", ".", "abs", "(", "g2", ")", "+", "1e-16", ")", "+", "1e-16", ")", "\n", "\n", "self", ".", "xi", ",", "self", ".", "g", ",", "self", ".", "g2", ",", "self", ".", "r_t", ",", "self", ".", "Minv", "=", "xi", ",", "g", ",", "g2", ",", "r_t", ",", "Minv", "\n", "self", ".", "xi_t", ",", "self", ".", "g_t", ",", "self", ".", "g2_t", "=", "xi_t", ",", "g_t", ",", "g2_t", "\n", "\n", "burn_in_updates", ".", "append", "(", "(", "xi", ",", "xi_t", ")", ")", "\n", "burn_in_updates", ".", "append", "(", "(", "g", ",", "g_t", ")", ")", "\n", "burn_in_updates", ".", "append", "(", "(", "g2", ",", "g2_t", ")", ")", "\n", "\n", "epsilon_scaled", "=", "epsilon", "/", "tf", ".", "sqrt", "(", "tf", ".", "cast", "(", "self", ".", "N", ",", "tf", ".", "float64", ")", ")", "\n", "noise_scale", "=", "2.", "*", "epsilon_scaled", "**", "2", "*", "mdecay", "*", "Minv", "\n", "sigma", "=", "tf", ".", "sqrt", "(", "tf", ".", "maximum", "(", "noise_scale", ",", "1e-16", ")", ")", "\n", "sample_t", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "seed", "=", "self", ".", "seed", ")", "*", "sigma", "\n", "p_t", "=", "p", "-", "epsilon", "**", "2", "*", "Minv", "*", "grad", "-", "mdecay", "*", "p", "+", "sample_t", "\n", "theta_t", "=", "theta", "+", "p_t", "\n", "\n", "self", ".", "epsilon_scaled", ",", "self", ".", "noise_scale", ",", "self", ".", "sigma", "=", "epsilon_scaled", ",", "noise_scale", ",", "sigma", "\n", "self", ".", "sample_t", ",", "self", ".", "theta_t", ",", "self", ".", "theta", ",", "self", ".", "p", ",", "self", ".", "p_t", "=", "sample_t", ",", "theta_t", ",", "theta", ",", "p", ",", "p_t", "\n", "\n", "# self.temp_vars.extend([xi, g, g2, p, r_t, g_t, g2_t, xi_t, Minv])", "\n", "sample_updates", ".", "append", "(", "(", "theta", ",", "theta_t", ")", ")", "\n", "sample_updates", ".", "append", "(", "(", "p", ",", "p_t", ")", ")", "\n", "\n", "self", ".", "hypers", "[", "0", "]", ".", "append", "(", "self", ".", "xi_t", ")", "\n", "self", ".", "hypers", "[", "1", "]", ".", "append", "(", "self", ".", "g_t", ")", "\n", "self", ".", "hypers", "[", "2", "]", ".", "append", "(", "self", ".", "g2_t", ")", "\n", "self", ".", "hypers", "[", "3", "]", ".", "append", "(", "self", ".", "p_t", ")", "\n", "layer", "+=", "1", "\n", "\n", "", "self", ".", "sample_op", "=", "[", "tf", ".", "assign", "(", "U", ",", "U_t", ")", "for", "U", ",", "U_t", "in", "sample_updates", "]", "\n", "self", ".", "burn_in_op", "=", "[", "tf", ".", "assign", "(", "var", ",", "var_t", ")", "for", "var", ",", "var_t", "in", "burn_in_updates", "+", "sample_updates", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.reset": [[95, 116], ["sghmc_dgp.BaseModel.likelihood.variance._read_parameter_tensor", "print", "print", "print", "print", "print", "tensorflow.reset_default_graph", "sghmc_dgp.BaseModel.session.close", "l.lengthscales._read_parameter_tensor", "l.variance._read_parameter_tensor", "sghmc_dgp.BaseModel.session.run", "sghmc_dgp.BaseModel.session.run"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.close", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "reset", "(", "self", ",", "pr", "=", "None", ")", ":", "\n", "        ", "kern", "=", "self", ".", "kernels", "\n", "lik", "=", "self", ".", "likelihood", "\n", "k_lengthscales", "=", "[", "l", ".", "lengthscales", ".", "_read_parameter_tensor", "(", "self", ".", "session", ")", "for", "l", "in", "self", ".", "kernels", "]", "\n", "k_variance", "=", "[", "l", ".", "variance", ".", "_read_parameter_tensor", "(", "self", ".", "session", ")", "for", "l", "in", "self", ".", "kernels", "]", "\n", "\n", "l_var", "=", "self", ".", "likelihood", ".", "variance", ".", "_read_parameter_tensor", "(", "self", ".", "session", ")", "\n", "\n", "print", "(", ")", "\n", "print", "(", "'Lengthscales, variance, noise_variance (sghmc_dgp.py):'", ")", "\n", "print", "(", "k_lengthscales", ")", "\n", "print", "(", "k_variance", ")", "\n", "print", "(", "l_var", ")", "\n", "\n", "Zs", "=", "[", "self", ".", "session", ".", "run", "(", "l", ".", "Z", ")", "for", "l", "in", "self", ".", "layers", "]", "\n", "Us", "=", "[", "self", ".", "session", ".", "run", "(", "l", ".", "U", ")", "for", "l", "in", "self", ".", "layers", "]", "\n", "\n", "tf", ".", "reset_default_graph", "(", ")", "\n", "self", ".", "session", ".", "close", "(", ")", "\n", "\n", "return", "kern", ",", "lik", ",", "Zs", ",", "Us", ",", "k_lengthscales", ",", "k_variance", ",", "l_var", ",", "self", ".", "sghmc_pars", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.get_params": [[118, 127], ["sghmc_dgp.BaseModel.likelihood.variance._read_parameter_tensor", "l.lengthscales._read_parameter_tensor", "l.variance._read_parameter_tensor", "sghmc_dgp.BaseModel.session.run", "sghmc_dgp.BaseModel.session.run"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "k_lengthscales", "=", "[", "l", ".", "lengthscales", ".", "_read_parameter_tensor", "(", "self", ".", "session", ")", "for", "l", "in", "self", ".", "kernels", "]", "\n", "k_variance", "=", "[", "l", ".", "variance", ".", "_read_parameter_tensor", "(", "self", ".", "session", ")", "for", "l", "in", "self", ".", "kernels", "]", "\n", "\n", "l_var", "=", "self", ".", "likelihood", ".", "variance", ".", "_read_parameter_tensor", "(", "self", ".", "session", ")", "\n", "\n", "Zs", "=", "[", "self", ".", "session", ".", "run", "(", "l", ".", "Z", ")", "for", "l", "in", "self", ".", "layers", "]", "\n", "Us", "=", "[", "self", ".", "session", ".", "run", "(", "l", ".", "U", ")", "for", "l", "in", "self", ".", "layers", "]", "\n", "return", "Zs", ",", "Us", ",", "k_lengthscales", ",", "k_variance", ",", "l_var", ",", "self", ".", "sghmc_pars", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.get_minibatch": [[129, 144], ["numpy.random.permutation"], "methods", ["None"], ["", "def", "get_minibatch", "(", "self", ")", ":", "\n", "        ", "assert", "self", ".", "N", ">=", "self", ".", "minibatch_size", "\n", "if", "self", ".", "N", "==", "self", ".", "minibatch_size", ":", "\n", "            ", "return", "self", ".", "X", ",", "self", ".", "Y", "\n", "\n", "", "if", "self", ".", "N", "<", "self", ".", "data_iter", "+", "self", ".", "minibatch_size", ":", "\n", "            ", "shuffle", "=", "np", ".", "random", ".", "permutation", "(", "self", ".", "N", ")", "\n", "self", ".", "X", "=", "self", ".", "X", "[", "shuffle", ",", ":", "]", "\n", "self", ".", "Y", "=", "self", ".", "Y", "[", "shuffle", ",", ":", "]", "\n", "self", ".", "data_iter", "=", "0", "\n", "\n", "", "X_batch", "=", "self", ".", "X", "[", "self", ".", "data_iter", ":", "self", ".", "data_iter", "+", "self", ".", "minibatch_size", ",", ":", "]", "\n", "Y_batch", "=", "self", ".", "Y", "[", "self", ".", "data_iter", ":", "self", ".", "data_iter", "+", "self", ".", "minibatch_size", ",", ":", "]", "\n", "self", ".", "data_iter", "+=", "self", ".", "minibatch_size", "\n", "return", "X_batch", ",", "Y_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.collect_samples": [[146, 184], ["range", "range", "sghmc_dgp.BaseModel.session.run", "zip", "list", "sghmc_dgp.BaseModel.all_samples.append", "sghmc_dgp.BaseModel.posterior_samples.append", "sghmc_dgp.BaseModel.get_minibatch", "sghmc_dgp.BaseModel.session.run", "list.append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.get_minibatch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "collect_samples", "(", "self", ",", "num", ",", "spacing", ")", ":", "\n", "        ", "self", ".", "posterior_samples", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "spacing", ")", ":", "\n", "                ", "X_batch", ",", "Y_batch", "=", "self", ".", "get_minibatch", "(", ")", "\n", "feed_dict", "=", "{", "self", ".", "X_placeholder", ":", "X_batch", ",", "self", ".", "Y_placeholder", ":", "Y_batch", "}", "\n", "_", ",", "xi", ",", "g", ",", "g2", ",", "p", ",", "r_t", ",", "g_t", ",", "g2_t", ",", "xi_t", ",", "Minv", ",", "epsilon_scaled", ",", "noise_scale", ",", "sigma", ",", "sample_t", ",", "p_t", ",", "theta_t", ",", "theta", ",", "self", ".", "sghmc_pars", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "sample_op", ",", "self", ".", "xi", ",", "self", ".", "g", ",", "self", ".", "g2", ",", "self", ".", "p", ",", "self", ".", "r_t", ",", "self", ".", "g_t", ",", "self", ".", "g2_t", ",", "self", ".", "xi_t", ",", "self", ".", "Minv", ",", "self", ".", "epsilon_scaled", ",", "self", ".", "noise_scale", ",", "self", ".", "sigma", ",", "self", ".", "sample_t", ",", "self", ".", "p_t", ",", "self", ".", "theta_t", ",", "self", ".", "theta", ",", "self", ".", "hypers", ")", ",", "feed_dict", "=", "feed_dict", ")", "\n", "\n", "", "values", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "Us", ")", ")", "\n", "\n", "'''if np.isnan(values).any():\n                print(\"Collect samples!\")\n                print('xi')\n                print(self.sghmc_pars[0])\n                print('g')\n                print(self.sghmc_pars[1])\n                print('g2')\n                print(self.sghmc_pars[2])\n                print('p')\n                print(self.sghmc_pars[3])\n                # print([xi, g, g2, r_t, g_t, g2_t, xi_t, Minv, epsilon_scaled, noise_scale, sigma, sample_t, p, p_t, theta, theta_t])\n                # print(self.session.run(self.temp_vars), feed_dict = {self.X_placeholder: X_batch, self.Y_placeholder: Y_batch})\n                #raise ValueError\n\n            self.prev_values = values'''", "\n", "\n", "sample", "=", "{", "}", "\n", "for", "U", ",", "value", "in", "zip", "(", "self", ".", "Us", ",", "values", ")", ":", "\n", "                ", "sample", "[", "U", "]", "=", "value", "\n", "\n", "", "temp", "=", "list", "(", ")", "\n", "for", "U", "in", "self", ".", "Us", ":", "\n", "                ", "temp", ".", "append", "(", "sample", "[", "U", "]", ")", "\n", "", "self", ".", "all_samples", ".", "append", "(", "temp", ")", "\n", "self", ".", "posterior_samples", ".", "append", "(", "sample", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.sghmc_step": [[186, 225], ["sghmc_dgp.BaseModel.get_minibatch", "sghmc_dgp.BaseModel.session.run", "sghmc_dgp.BaseModel.session.run", "zip", "list", "sghmc_dgp.BaseModel.all_samples.append", "sghmc_dgp.BaseModel.window.append", "list.append", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.get_minibatch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "", "def", "sghmc_step", "(", "self", ")", ":", "\n", "        ", "X_batch", ",", "Y_batch", "=", "self", ".", "get_minibatch", "(", ")", "\n", "feed_dict", "=", "{", "self", ".", "X_placeholder", ":", "X_batch", ",", "self", ".", "Y_placeholder", ":", "Y_batch", "}", "\n", "_", ",", "self", ".", "sghmc_pars", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "burn_in_op", ",", "self", ".", "hypers", ")", ",", "feed_dict", "=", "feed_dict", ")", "\n", "\n", "values", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "Us", ")", ")", "\n", "'''if np.isnan(values).any():\n            print(\"SGHMC_STEP!\")\n            print('xi')\n            print(self.sghmc_pars[0])\n            print('g')\n            print(self.sghmc_pars[1])\n            print('g2')\n            print(self.sghmc_pars[2])\n            print('p')\n            print(self.sghmc_pars[3])\n            # print(values)\n            # print('Previous')\n            # print(self.prev_values)\n            #bool_array = np.isnan(values)\n            # print(bool_array)\n            #for l in range(0, len(bool_array)):\n            #    values[l][bool_array[l]] = self.prev_values[l][bool_array[l]]\n            # print('Changed')\n            # print(values)\n\n        self.prev_values = values'''", "\n", "sample", "=", "{", "}", "\n", "for", "U", ",", "value", "in", "zip", "(", "self", ".", "Us", ",", "values", ")", ":", "\n", "            ", "sample", "[", "U", "]", "=", "value", "\n", "\n", "", "temp", "=", "list", "(", ")", "\n", "for", "U", "in", "self", ".", "Us", ":", "\n", "            ", "temp", ".", "append", "(", "sample", "[", "U", "]", ")", "\n", "", "self", ".", "all_samples", ".", "append", "(", "temp", ")", "\n", "\n", "self", ".", "window", ".", "append", "(", "sample", ")", "\n", "if", "len", "(", "self", ".", "window", ")", ">", "self", ".", "window_size", ":", "\n", "            ", "self", ".", "window", "=", "self", ".", "window", "[", "-", "self", ".", "window_size", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.train_hypers": [[227, 234], ["None"], "methods", ["None"], ["", "", "def", "train_hypers", "(", "self", ")", ":", "\n", "        ", "return", "\n", "'''X_batch, Y_batch = self.get_minibatch()\n        feed_dict = {self.X_placeholder: X_batch, self.Y_placeholder: Y_batch}\n        i = np.random.randint(len(self.window))\n        feed_dict.update(self.window[i])\n        self.session.run(self.hyper_train_op, feed_dict=feed_dict)'''", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.get_sample_performance": [[236, 245], ["sghmc_dgp.BaseModel.get_minibatch", "sghmc_dgp.BaseModel.session.run", "numpy.mean", "feed_dict.update", "numpy.random.choice"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.BaseModel.get_minibatch", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update"], ["", "def", "get_sample_performance", "(", "self", ",", "posterior", "=", "False", ")", ":", "\n", "        ", "X_batch", ",", "Y_batch", "=", "self", ".", "get_minibatch", "(", ")", "\n", "feed_dict", "=", "{", "self", ".", "X_placeholder", ":", "X_batch", ",", "self", ".", "Y_placeholder", ":", "Y_batch", "}", "\n", "if", "posterior", ":", "\n", "            ", "feed_dict", ".", "update", "(", "np", ".", "random", ".", "choice", "(", "self", ".", "posterior_samples", ")", ")", "\n", "", "mll", ",", "prior", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "log_likelihood", ",", "self", ".", "prior", ")", ",", "feed_dict", "=", "feed_dict", ")", "\n", "mll", "=", "np", ".", "mean", "(", "mll", ",", "0", ")", "\n", "prior", "=", "prior", "/", "self", ".", "X", ".", "shape", "[", "0", "]", "\n", "return", "mll", ",", "prior", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.Layer.__init__": [[249, 303], ["numpy.abs", "numpy.linspace", "Z.reshape.reshape.reshape", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "numpy.eye", "numpy.concatenate", "numpy.linalg.svd", "numpy.ones", "numpy.eye", "numpy.zeros"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "bounds", ",", "kern", ",", "outputs", ",", "n_inducing", ",", "fixed_mean", ",", "X", ",", "Z", ",", "U", ")", ":", "\n", "        ", "self", ".", "inputs", ",", "self", ".", "outputs", ",", "self", ".", "kernel", "=", "kern", ".", "input_dim", ",", "outputs", ",", "kern", "\n", "self", ".", "M", ",", "self", ".", "fixed_mean", "=", "n_inducing", ",", "fixed_mean", "\n", "\n", "# initialize Zs with data:", "\n", "'''if Z is None:\n            # print(kmeans2(X, self.M, minit='points')[0]) minit = \u2018random\u2019 Gaussian\n            Z = kmeans2(X, self.M, minit='points')[0]\n            self.Z = tf.Variable(Z, trainable=False, dtype=tf.float64, name='Z')\n        else:\n            M_new = self.M - Z.shape[0]\n            old_Z = Z\n            new_Z = X[-M_new:, :]\n            Z = np.vstack((old_Z, new_Z))\n            self.Z = tf.Variable(Z, dtype=tf.float64, trainable=False, name='Z')\n\n        if U is None:\n            self.U = tf.Variable(np.zeros((self.M, self.outputs)), dtype=tf.float64, trainable=False, name='U')\n        else:\n            old_U = U\n            new_U = np.zeros((M_new, self.outputs))\n            U = np.vstack((old_U, new_U))\n            self.U = tf.Variable(U, dtype=tf.float64, trainable=False, name='U')'''", "\n", "\n", "# initialize Zs with a grid:", "\n", "if", "Z", "is", "None", ":", "\n", "# print(kmeans2(X, self.M, minit='points')[0]) minit = \u2018random\u2019 Gaussian", "\n", "            ", "min_x", ",", "max_x", "=", "bounds", "[", "0", "]", "\n", "x_mean", "=", "(", "max_x", "+", "min_x", ")", "/", "2.0", "\n", "x_std", "=", "np", ".", "abs", "(", "max_x", "-", "x_mean", ")", "\n", "min_x", "=", "(", "min_x", "-", "x_mean", ")", "/", "x_std", "\n", "max_x", "=", "(", "max_x", "-", "x_mean", ")", "/", "x_std", "\n", "\n", "# Z = kmeans2(X, self.M, minit='random')[0]", "\n", "# print(Z)", "\n", "Z", "=", "np", ".", "linspace", "(", "min_x", ",", "max_x", ",", "num", "=", "self", ".", "M", "*", "X", ".", "shape", "[", "1", "]", ")", "\n", "Z", "=", "Z", ".", "reshape", "(", "(", "-", "1", ",", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "# print(Z)", "\n", "self", ".", "Z", "=", "tf", ".", "Variable", "(", "Z", ",", "trainable", "=", "False", ",", "dtype", "=", "tf", ".", "float64", ",", "name", "=", "'Z'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "Z", "=", "tf", ".", "Variable", "(", "Z", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ",", "name", "=", "'Z'", ")", "\n", "\n", "", "if", "U", "is", "None", ":", "\n", "            ", "self", ".", "U", "=", "tf", ".", "Variable", "(", "np", ".", "ones", "(", "(", "self", ".", "M", ",", "self", ".", "outputs", ")", ")", "*", "(", "-", "1.0", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ",", "name", "=", "'U'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "U", "=", "tf", ".", "Variable", "(", "U", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ",", "name", "=", "'U'", ")", "\n", "\n", "", "if", "self", ".", "inputs", "==", "outputs", ":", "\n", "            ", "self", ".", "mean", "=", "np", ".", "eye", "(", "self", ".", "inputs", ")", "\n", "", "elif", "self", ".", "inputs", "<", "self", ".", "outputs", ":", "\n", "            ", "self", ".", "mean", "=", "np", ".", "concatenate", "(", "[", "np", ".", "eye", "(", "self", ".", "inputs", ")", ",", "np", ".", "zeros", "(", "(", "self", ".", "inputs", ",", "self", ".", "outputs", "-", "self", ".", "inputs", ")", ")", "]", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "_", ",", "_", ",", "V", "=", "np", ".", "linalg", ".", "svd", "(", "X", ",", "full_matrices", "=", "False", ")", "\n", "self", ".", "mean", "=", "V", "[", ":", "self", ".", "outputs", ",", ":", "]", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.Layer.conditional": [[310, 324], ["gpflow.settings.get_settings", "gpflow.settings.temp_settings", "gpflow.conditionals.conditional", "gpflow.conditionals.conditional", "tensorflow.matmul", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.Layer.conditional", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.Layer.conditional"], ["", "", "def", "conditional", "(", "self", ",", "X", ")", ":", "\n", "# Caching the covariance matrix from the sghmc steps gives a significant speedup. This is not being done here.", "\n", "        ", "custom_config", "=", "gpflow", ".", "settings", ".", "get_settings", "(", ")", "\n", "custom_config", ".", "numerics", ".", "jitter_level", "=", "1e-8", "\n", "\n", "with", "gpflow", ".", "settings", ".", "temp_settings", "(", "custom_config", ")", ":", "\n", "# print(gpflow.settings.jitter)", "\n", "            ", "mean", ",", "var", "=", "gpflow", ".", "conditionals", ".", "conditional", "(", "X", ",", "self", ".", "Z", ",", "self", ".", "kernel", ",", "self", ".", "U", ",", "full_cov", "=", "True", ",", "white", "=", "True", ")", "\n", "mean_uw", ",", "var_uw", "=", "gpflow", ".", "conditionals", ".", "conditional", "(", "X", ",", "self", ".", "Z", ",", "self", ".", "kernel", ",", "self", ".", "U", ",", "full_cov", "=", "True", ",", "white", "=", "False", ")", "\n", "\n", "", "if", "self", ".", "fixed_mean", ":", "\n", "            ", "mean", "+=", "tf", ".", "matmul", "(", "X", ",", "tf", ".", "cast", "(", "self", ".", "mean", ",", "tf", ".", "float64", ")", ")", "\n", "\n", "", "return", "mean", ",", "var", ",", "mean_uw", ",", "var_uw", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.Layer.prior": [[326, 328], ["tensorflow.reduce_sum", "tensorflow.square"], "methods", ["None"], ["", "def", "prior", "(", "self", ")", ":", "\n", "        ", "return", "-", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "self", ".", "U", ")", ")", "/", "2.0", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.DGP.propagate": [[332, 377], ["layer.conditional", "tensorflow.random_normal", "tensorflow.matrix_transpose", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.math.multiply", "tensorflow.math.reduce_sum", "tensorflow.matrix_transpose", "tensorflow.matrix_diag_part", "tensorflow.matrix_transpose", "tensorflow.math.multiply", "tensorflow.math.reduce_sum", "tensorflow.matrix_transpose", "tensorflow.matrix_diag_part", "tensorflow.matrix_transpose", "Fs.append", "Fmeans.append", "Fvars.append", "Fs_uw.append", "Fmeans_uw.append", "Fvars_uw.append", "tensorflow.shape", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.Layer.conditional", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["    ", "def", "propagate", "(", "self", ",", "X", ")", ":", "\n", "        ", "Fs", ",", "Fmeans", ",", "Fvars", "=", "[", "X", ",", "]", ",", "[", "]", ",", "[", "]", "\n", "Fs_uw", ",", "Fmeans_uw", ",", "Fvars_uw", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "mean", ",", "var", ",", "mean_uw", ",", "var_uw", "=", "layer", ".", "conditional", "(", "Fs", "[", "-", "1", "]", ")", "# NxR, RxNxN", "\n", "N", "=", "tf", ".", "shape", "(", "mean", ")", "[", "0", "]", "# number of points in a layer", "\n", "\n", "# std that influences F", "\n", "eps", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "mean", ")", ",", "mean", "=", "0.0", ",", "stddev", "=", "1.0", ",", "dtype", "=", "tf", ".", "float64", ")", "# NxR", "\n", "eps", "=", "tf", ".", "matrix_transpose", "(", "eps", ")", "# RxN", "\n", "eps", "=", "tf", ".", "expand_dims", "(", "eps", ",", "-", "1", ")", "# RxNx1", "\n", "eps", "=", "tf", ".", "tile", "(", "eps", ",", "[", "1", ",", "1", ",", "N", "]", ")", "# RxNxN", "\n", "\n", "# std = tf.sqrt(var) # RxNxN", "\n", "# std = tf.square(var)", "\n", "eps_std", "=", "tf", ".", "math", ".", "multiply", "(", "eps", ",", "var", ")", "# RxNxN", "\n", "eps_std", "=", "tf", ".", "math", ".", "reduce_sum", "(", "eps_std", ",", "axis", "=", "1", ")", "# RxN", "\n", "eps_std", "=", "tf", ".", "matrix_transpose", "(", "eps_std", ")", "# NxR", "\n", "\n", "# var that we will return", "\n", "var", "=", "tf", ".", "matrix_diag_part", "(", "var", ")", "# RxN", "\n", "var", "=", "tf", ".", "matrix_transpose", "(", "var", ")", "# NxR", "\n", "# var = tf.square(std)", "\n", "\n", "F", "=", "mean", "+", "eps_std", "\n", "\n", "eps_std_uw", "=", "tf", ".", "math", ".", "multiply", "(", "eps", ",", "var_uw", ")", "# RxNxN", "\n", "eps_std_uw", "=", "tf", ".", "math", ".", "reduce_sum", "(", "eps_std_uw", ",", "axis", "=", "1", ")", "# RxN", "\n", "eps_std_uw", "=", "tf", ".", "matrix_transpose", "(", "eps_std_uw", ")", "# NxR", "\n", "\n", "var_uw", "=", "tf", ".", "matrix_diag_part", "(", "var_uw", ")", "# RxN", "\n", "var_uw", "=", "tf", ".", "matrix_transpose", "(", "var_uw", ")", "# NxR", "\n", "\n", "F_uw", "=", "mean_uw", "+", "eps_std_uw", "# triangular solve? see -->", "\n", "\n", "Fs", ".", "append", "(", "F", ")", "\n", "Fmeans", ".", "append", "(", "mean", ")", "\n", "Fvars", ".", "append", "(", "var", ")", "\n", "\n", "Fs_uw", ".", "append", "(", "F_uw", ")", "\n", "Fmeans_uw", ".", "append", "(", "mean_uw", ")", "\n", "Fvars_uw", ".", "append", "(", "var_uw", ")", "\n", "\n", "", "return", "Fs", ",", "Fmeans", ",", "Fvars", ",", "Fs_uw", ",", "Fmeans_uw", ",", "Fvars_uw", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.DGP.__init__": [[379, 441], ["tensorflow.ConfigProto", "tensorflow.Session", "len", "X.copy", "range", "sghmc_dgp.DGP.likelihood.compile", "sghmc_dgp.BaseModel.__init__", "sghmc_dgp.DGP.propagate", "sghmc_dgp.DGP.likelihood.predict_mean_and_var", "tensorflow.add_n", "sghmc_dgp.DGP.likelihood.predict_density", "tensorflow.gradients", "tensorflow.gradients", "sghmc_dgp.DGP.generate_update_step", "tensorflow.train.AdamOptimizer", "sghmc_dgp.DGP.adam.minimize", "tensorflow.global_variables_initializer", "sghmc_dgp.DGP.session.run", "tensorflow.set_random_seed", "numpy.random.seed", "sghmc_dgp.DGP.layers.append", "numpy.matmul", "sghmc_dgp.DGP.kernels[].compile", "sghmc_dgp.Layer", "l.prior", "tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.copy", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.generate_update_step", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.parameter_inference.ParameterInference.seed", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.client.ClientBase.compile", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.Layer.prior"], ["", "def", "__init__", "(", "self", ",", "X", ",", "Y", ",", "bounds", ",", "n_inducing", ",", "kernels", ",", "likelihood", ",", "Zs", ",", "Us", ",", "minibatch_size", ",", "window_size", ",", "\n", "adam_lr", "=", "0.01", ",", "epsilon", "=", "0.01", ",", "mdecay", "=", "0.05", ",", "seed", "=", "None", ",", "sghmc_pars", "=", "None", ")", ":", "\n", "        ", "self", ".", "n_inducing", "=", "n_inducing", "\n", "self", ".", "kernels", "=", "kernels", "\n", "self", ".", "likelihood", "=", "likelihood", "\n", "self", ".", "minibatch_size", "=", "minibatch_size", "\n", "self", ".", "window_size", "=", "window_size", "\n", "self", ".", "prev_values", "=", "None", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "self", ".", "seed", "=", "seed", "\n", "tf", ".", "set_random_seed", "(", "self", ".", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n", "", "config", "=", "tf", ".", "ConfigProto", "(", ")", "\n", "config", ".", "gpu_options", ".", "allow_growth", "=", "True", "\n", "self", ".", "session", "=", "tf", ".", "Session", "(", "config", "=", "config", ")", "\n", "\n", "n_layers", "=", "len", "(", "kernels", ")", "\n", "N", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "self", ".", "layers", "=", "[", "]", "\n", "self", ".", "kernels_ins", "=", "{", "}", "\n", "X_running", "=", "X", ".", "copy", "(", ")", "\n", "\n", "if", "Zs", "is", "None", "or", "Us", "is", "None", ":", "\n", "            ", "Zs", "=", "[", "None", "]", "*", "n_layers", "\n", "Us", "=", "[", "None", "]", "*", "n_layers", "\n", "\n", "", "for", "l", "in", "range", "(", "n_layers", ")", ":", "\n", "            ", "outputs", "=", "self", ".", "kernels", "[", "l", "+", "1", "]", ".", "input_dim", "if", "l", "+", "1", "<", "n_layers", "else", "Y", ".", "shape", "[", "1", "]", "\n", "self", ".", "layers", ".", "append", "(", "Layer", "(", "bounds", ",", "self", ".", "kernels", "[", "l", "]", ",", "outputs", ",", "n_inducing", ",", "fixed_mean", "=", "(", "l", "+", "1", "<", "n_layers", ")", ",", "X", "=", "X_running", ",", "Z", "=", "Zs", "[", "l", "]", ",", "U", "=", "Us", "[", "l", "]", ")", ")", "\n", "X_running", "=", "np", ".", "matmul", "(", "X_running", ",", "self", ".", "layers", "[", "-", "1", "]", ".", "mean", ")", "\n", "self", ".", "kernels", "[", "l", "]", ".", "compile", "(", "session", "=", "self", ".", "session", ")", "\n", "self", ".", "kernels_ins", "=", "{", "**", "self", ".", "kernels_ins", ",", "**", "self", ".", "kernels", "[", "l", "]", ".", "initializable_feeds", "}", "\n", "\n", "", "self", ".", "likelihood", ".", "compile", "(", "session", "=", "self", ".", "session", ")", "\n", "self", ".", "kernels_ins", "=", "{", "**", "self", ".", "kernels_ins", ",", "**", "self", ".", "likelihood", ".", "initializable_feeds", "}", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "X", ",", "Y", ",", "[", "l", ".", "U", "for", "l", "in", "self", ".", "layers", "]", ",", "minibatch_size", ",", "window_size", ")", "\n", "\n", "self", ".", "f", ",", "self", ".", "fmeans", ",", "self", ".", "fvars", ",", "self", ".", "f_uw", ",", "self", ".", "fmeans_uw", ",", "self", ".", "fvars_uw", "=", "self", ".", "propagate", "(", "self", ".", "X_placeholder", ")", "\n", "self", ".", "y_mean", ",", "self", ".", "y_var", "=", "self", ".", "likelihood", ".", "predict_mean_and_var", "(", "self", ".", "fmeans", "[", "-", "1", "]", ",", "self", ".", "fvars", "[", "-", "1", "]", ")", "\n", "\n", "self", ".", "prior", "=", "tf", ".", "add_n", "(", "[", "l", ".", "prior", "(", ")", "for", "l", "in", "self", ".", "layers", "]", ")", "\n", "self", ".", "log_likelihood", "=", "self", ".", "likelihood", ".", "predict_density", "(", "self", ".", "fmeans", "[", "-", "1", "]", ",", "self", ".", "fvars", "[", "-", "1", "]", ",", "self", ".", "Y_placeholder", ")", "\n", "\n", "# compute gradients of a mean and a var at a point X", "\n", "self", ".", "grad_means", "=", "tf", ".", "gradients", "(", "self", ".", "y_mean", ",", "self", ".", "X_placeholder", ")", "\n", "self", ".", "grad_vars", "=", "tf", ".", "gradients", "(", "self", ".", "y_var", ",", "self", ".", "X_placeholder", ")", "\n", "\n", "self", ".", "nll", "=", "-", "tf", ".", "reduce_sum", "(", "self", ".", "log_likelihood", ")", "/", "tf", ".", "cast", "(", "tf", ".", "shape", "(", "self", ".", "X_placeholder", ")", "[", "0", "]", ",", "tf", ".", "float64", ")", "-", "(", "self", ".", "prior", "/", "N", ")", "\n", "\n", "self", ".", "generate_update_step", "(", "self", ".", "nll", ",", "epsilon", ",", "mdecay", ",", "sghmc_pars", ")", "\n", "\n", "self", ".", "adam", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "adam_lr", ")", "\n", "self", ".", "hyper_train_op", "=", "self", ".", "adam", ".", "minimize", "(", "self", ".", "nll", ")", "\n", "\n", "init_op", "=", "tf", ".", "global_variables_initializer", "(", ")", "\n", "self", ".", "session", ".", "run", "(", "init_op", ",", "feed_dict", "=", "self", ".", "kernels_ins", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.DGP.predict_y": [[443, 452], ["range", "feed_dict.update", "sghmc_dgp.DGP.session.run", "ms.append", "vs.append", "numpy.stack", "numpy.stack"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "predict_y", "(", "self", ",", "X", ",", "S", ")", ":", "\n", "        ", "ms", ",", "vs", "=", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "range", "(", "S", ")", ":", "\n", "            ", "feed_dict", "=", "{", "self", ".", "X_placeholder", ":", "X", "}", "\n", "feed_dict", ".", "update", "(", "self", ".", "posterior_samples", "[", "i", "]", ")", "\n", "m", ",", "v", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "y_mean", ",", "self", ".", "y_var", ")", ",", "feed_dict", "=", "feed_dict", ")", "\n", "ms", ".", "append", "(", "m", ")", "\n", "vs", ".", "append", "(", "v", ")", "\n", "", "return", "np", ".", "stack", "(", "ms", ",", "0", ")", ",", "np", ".", "stack", "(", "vs", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.DGP.get_gradients": [[454, 460], ["sghmc_dgp.DGP.session.run"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "get_gradients", "(", "self", ",", "X", ")", ":", "\n", "# this returns a list of gradients [(x.shape[0], x.shape[1])], but the acquisition function needs", "\n", "# only one element (the only element in the list)", "\n", "        ", "feed_dict", "=", "{", "self", ".", "X_placeholder", ":", "X", "}", "\n", "grad_mean", ",", "grad_var", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "grad_means", ",", "self", ".", "grad_vars", ")", ",", "feed_dict", "=", "feed_dict", ")", "\n", "return", "grad_mean", "[", "0", "]", ",", "grad_var", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.DGP.get_posterior": [[462, 469], ["feed_dict.update", "sghmc_dgp.DGP.session.run"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "get_posterior", "(", "self", ",", "X", ",", "i", ")", ":", "\n", "# get prediction for exactly one poster sample", "\n", "        ", "feed_dict", "=", "{", "self", ".", "X_placeholder", ":", "X", "}", "\n", "feed_dict", ".", "update", "(", "self", ".", "posterior_samples", "[", "i", "]", ")", "\n", "f", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "f", "[", "-", "1", "]", ")", ",", "feed_dict", "=", "feed_dict", ")", "\n", "# m, v = self.session.run((self.y_mean, self.y_var), feed_dict=feed_dict)", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.DGP.get_posterior_fs_for_layer": [[471, 478], ["feed_dict.update", "sghmc_dgp.DGP.session.run"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "get_posterior_fs_for_layer", "(", "self", ",", "X", ",", "s", ",", "l", ")", ":", "\n", "# given an input, gives the output for the ith layer", "\n", "        ", "feed_dict", "=", "{", "self", ".", "X_placeholder", ":", "X", "}", "\n", "feed_dict", "=", "{", "self", ".", "f", "[", "l", "]", ":", "X", "}", "\n", "feed_dict", ".", "update", "(", "self", ".", "posterior_samples", "[", "s", "]", ")", "\n", "f_uw", ",", "m_uw", ",", "v_uw", ",", "Z", ",", "U", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "f_uw", "[", "l", "]", ",", "self", ".", "fmeans_uw", "[", "l", "]", ",", "self", ".", "fvars_uw", "[", "l", "]", ",", "self", ".", "layers", "[", "l", "]", ".", "Z", ",", "self", ".", "layers", "[", "l", "]", ".", "U", ")", ",", "feed_dict", "=", "feed_dict", ")", "\n", "return", "f_uw", ",", "m_uw", ",", "v_uw", ",", "Z", ",", "U", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.sghmc_dgp.DGP.get_points_posterior": [[480, 498], ["len", "range", "len", "range", "tensorflow.concat().eval", "result.append", "feed_dict.update", "sghmc_dgp.DGP.session.run", "tensorflow.random_normal", "Us.append", "tensorflow.shape", "tensorflow.concat", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "get_points_posterior", "(", "self", ")", ":", "\n", "        ", "S", "=", "len", "(", "self", ".", "posterior_samples", ")", "\n", "Zs", "=", "self", ".", "X", "\n", "# print(self.X)", "\n", "Us", "=", "[", "]", "\n", "result", "=", "[", "Zs", "]", "\n", "for", "l", "in", "range", "(", "len", "(", "self", ".", "layers", ")", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "S", ")", ":", "\n", "                ", "feed_dict", "=", "{", "self", ".", "f", "[", "l", "]", ":", "Zs", "}", "\n", "feed_dict", ".", "update", "(", "self", ".", "posterior_samples", "[", "i", "]", ")", "\n", "m", ",", "v", "=", "self", ".", "session", ".", "run", "(", "(", "self", ".", "fmeans", "[", "l", "]", ",", "self", ".", "fvars", "[", "l", "]", ")", ",", "feed_dict", "=", "feed_dict", ")", "\n", "eps", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "m", ")", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "U", "=", "m", "+", "eps", "*", "tf", ".", "sqrt", "(", "v", ")", "\n", "Us", ".", "append", "(", "U", ")", "\n", "", "Zs", "=", "tf", ".", "concat", "(", "Us", ",", "0", ")", ".", "eval", "(", "session", "=", "self", ".", "session", ")", "\n", "Us", "=", "[", "]", "\n", "result", ".", "append", "(", "Zs", ")", "\n", "", "return", "result", "[", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.AcquisitionBase.__init__": [[23, 69], ["int", "int", "ValueError", "numpy.random.RandomState", "numpy.asanyarray"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "model", ",", "\n", "prior", "=", "None", ",", "\n", "n_inits", "=", "10", ",", "\n", "max_opt_iters", "=", "1000", ",", "\n", "noise_var", "=", "None", ",", "\n", "exploration_rate", "=", "10", ",", "\n", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize AcquisitionBase.\n\n        Parameters\n        ----------\n        model : an object with attributes\n                    input_dim : int\n                    bounds : tuple of length 'input_dim' of tuples (min, max)\n                and methods\n                    evaluate(x) : function that returns model (mean, var, std)\n        prior : scipy-like distribution, optional\n            By default uniform distribution within model bounds.\n        n_inits : int, optional\n            Number of initialization points in internal optimization.\n        max_opt_iters : int, optional\n            Max iterations to optimize when finding the next point.\n        noise_var : float or np.array, optional\n            Acquisition noise variance for adding noise to the points near the optimized\n            location. If array, must be 1d specifying the variance for different dimensions.\n            Default: no added noise.\n        exploration_rate : float, optional\n            Exploration rate of the acquisition function (if supported)\n        seed : int, optional\n            Seed for getting consistent acquisition results. Used in getting random\n            starting locations in acquisition function optimization.\n\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "prior", "=", "prior", "\n", "self", ".", "n_inits", "=", "int", "(", "n_inits", ")", "\n", "self", ".", "max_opt_iters", "=", "int", "(", "max_opt_iters", ")", "\n", "\n", "if", "noise_var", "is", "not", "None", "and", "np", ".", "asanyarray", "(", "noise_var", ")", ".", "ndim", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Noise variance must be a float or 1d vector of variances \"", "\n", "\"for the different input dimensions.\"", ")", "\n", "", "self", ".", "noise_var", "=", "noise_var", "\n", "self", ".", "exploration_rate", "=", "exploration_rate", "\n", "self", ".", "random_state", "=", "np", ".", "random", "if", "seed", "is", "None", "else", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "self", ".", "seed", "=", "0", "if", "seed", "is", "None", "else", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.AcquisitionBase.evaluate": [[70, 81], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "x", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate the acquisition function at 'x'.\n\n        Parameters\n        ----------\n        x : numpy.array\n        t : int\n            current iteration (starting from 0)\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.AcquisitionBase.evaluate_gradient": [[82, 93], ["None"], "methods", ["None"], ["", "def", "evaluate_gradient", "(", "self", ",", "x", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate the gradient of acquisition function at 'x'.\n\n        Parameters\n        ----------\n        x : numpy.array\n        t : int\n            Current iteration (starting from 0).\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.AcquisitionBase.acquire": [[94, 136], ["logger.debug", "elfi.methods.bo.utils.minimize", "numpy.tile", "acquisition.AcquisitionBase._add_noise", "print", "acquisition.AcquisitionBase.evaluate", "acquisition.AcquisitionBase.evaluate_gradient"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.AcquisitionBase._add_noise", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate_gradient"], ["", "def", "acquire", "(", "self", ",", "n", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the next batch of acquisition points.\n\n        Gaussian noise ~N(0, self.noise_var) is added to the acquired points.\n\n        Parameters\n        ----------\n        n : int\n            Number of acquisition points to return.\n        t : int\n            Current acq_batch_index (starting from 0).\n\n        Returns\n        -------\n        x : np.ndarray\n            The shape is (n, input_dim)\n\n        \"\"\"", "\n", "logger", ".", "debug", "(", "'Acquiring the next batch of %d values'", ",", "n", ")", "\n", "\n", "# Optimize the current minimum", "\n", "def", "obj", "(", "x", ")", ":", "\n", "            ", "return", "self", ".", "evaluate", "(", "x", ",", "t", ")", "\n", "\n", "", "def", "grad_obj", "(", "x", ")", ":", "\n", "            ", "return", "self", ".", "evaluate_gradient", "(", "x", ",", "t", ")", "\n", "\n", "", "xhat", ",", "_", "=", "minimize", "(", "\n", "obj", ",", "\n", "self", ".", "model", ".", "bounds", ",", "\n", "grad_obj", ",", "\n", "self", ".", "prior", ",", "\n", "self", ".", "n_inits", ",", "\n", "self", ".", "max_opt_iters", ",", "\n", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n", "# Create n copies of the minimum", "\n", "x", "=", "np", ".", "tile", "(", "xhat", ",", "(", "n", ",", "1", ")", ")", "\n", "# Add noise for more efficient fitting of GP", "\n", "x", "=", "self", ".", "_add_noise", "(", "x", ")", "\n", "print", "(", "\"\\nACQUIRE (acquisition.py):\"", ",", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.AcquisitionBase._add_noise": [[137, 155], ["numpy.asanyarray", "range", "numpy.tile", "numpy.sqrt", "scipy.truncnorm.rvs", "scipy.truncnorm.rvs", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["", "def", "_add_noise", "(", "self", ",", "x", ")", ":", "\n", "# Add noise for more efficient fitting of GP", "\n", "        ", "if", "self", ".", "noise_var", "is", "not", "None", ":", "\n", "            ", "noise_var", "=", "np", ".", "asanyarray", "(", "self", ".", "noise_var", ")", "\n", "if", "noise_var", ".", "ndim", "==", "0", ":", "\n", "                ", "noise_var", "=", "np", ".", "tile", "(", "noise_var", ",", "self", ".", "model", ".", "input_dim", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "model", ".", "input_dim", ")", ":", "\n", "                ", "std", "=", "np", ".", "sqrt", "(", "noise_var", "[", "i", "]", ")", "\n", "if", "std", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "xi", "=", "x", "[", ":", ",", "i", "]", "\n", "a", "=", "(", "self", ".", "model", ".", "bounds", "[", "i", "]", "[", "0", "]", "-", "xi", ")", "/", "std", "\n", "b", "=", "(", "self", ".", "model", ".", "bounds", "[", "i", "]", "[", "1", "]", "-", "xi", ")", "/", "std", "\n", "x", "[", ":", ",", "i", "]", "=", "ss", ".", "truncnorm", ".", "rvs", "(", "\n", "a", ",", "b", ",", "loc", "=", "xi", ",", "scale", "=", "std", ",", "size", "=", "len", "(", "x", ")", ",", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.LCBSC.__init__": [[189, 209], ["acquisition.AcquisitionBase.__init__", "logger.warning"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "delta", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize LCBSC.\n\n        Parameters\n        ----------\n        args\n        delta : float, optional\n            In between (0, 1). Default is 1/exploration_rate. If given, overrides the\n            exploration_rate.\n        kwargs\n\n        \"\"\"", "\n", "if", "delta", "is", "not", "None", ":", "\n", "            ", "if", "delta", "<=", "0", "or", "delta", ">=", "1", ":", "\n", "                ", "logger", ".", "warning", "(", "'Parameter delta should be in the interval (0,1)'", ")", "\n", "", "kwargs", "[", "'exploration_rate'", "]", "=", "1", "/", "delta", "\n", "\n", "", "super", "(", "LCBSC", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "name", "=", "'lcbsc'", "\n", "self", ".", "label_fn", "=", "'Confidence Bound'", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.LCBSC.delta": [[210, 214], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "delta", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the inverse of exploration rate.\"\"\"", "\n", "return", "1", "/", "self", ".", "exploration_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.LCBSC._beta": [[215, 220], ["numpy.log"], "methods", ["None"], ["", "def", "_beta", "(", "self", ",", "t", ")", ":", "\n", "# Start from 0", "\n", "        ", "t", "+=", "1", "\n", "d", "=", "self", ".", "model", ".", "input_dim", "\n", "return", "2", "*", "np", ".", "log", "(", "t", "**", "(", "2", "*", "d", "+", "2", ")", "*", "np", ".", "pi", "**", "2", "/", "(", "3", "*", "self", ".", "delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.LCBSC.evaluate": [[221, 235], ["acquisition.LCBSC.model.predict", "numpy.sqrt", "acquisition.LCBSC._beta"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition._beta"], ["", "def", "evaluate", "(", "self", ",", "x", ",", "t", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Evaluate the Lower confidence bound selection criterion.\n\n        mean - sqrt(\\beta_t) * std\n\n        Parameters\n        ----------\n        x : numpy.array\n        t : int\n            Current iteration (starting from 0).\n\n        \"\"\"", "\n", "mean", ",", "var", "=", "self", ".", "model", ".", "predict", "(", "x", ",", "noiseless", "=", "True", ")", "\n", "return", "mean", "-", "np", ".", "sqrt", "(", "self", ".", "_beta", "(", "t", ")", "*", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.LCBSC.evaluate_gradient": [[236, 250], ["acquisition.LCBSC.model.predict", "acquisition.LCBSC.model.predictive_gradients", "numpy.sqrt", "acquisition.LCBSC._beta"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition._beta"], ["", "def", "evaluate_gradient", "(", "self", ",", "x", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate the gradient of the lower confidence bound selection criterion.\n\n        Parameters\n        ----------\n        x : numpy.array\n        t : int\n            Current iteration (starting from 0).\n\n        \"\"\"", "\n", "mean", ",", "var", "=", "self", ".", "model", ".", "predict", "(", "x", ",", "noiseless", "=", "True", ")", "\n", "grad_mean", ",", "grad_var", "=", "self", ".", "model", ".", "predictive_gradients", "(", "x", ")", "\n", "\n", "return", "grad_mean", "-", "0.5", "*", "grad_var", "*", "np", ".", "sqrt", "(", "self", ".", "_beta", "(", "t", ")", "/", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.MaxVar.__init__": [[278, 293], ["acquisition.AcquisitionBase.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "quantile_eps", "=", ".01", ",", "*", "args", ",", "**", "opts", ")", ":", "\n", "        ", "\"\"\"Initialise MaxVar.\n\n        Parameters\n        ----------\n        quantile_eps : int, optional\n            Quantile of the observed discrepancies used in setting the ABC threshold.\n\n        \"\"\"", "\n", "super", "(", "MaxVar", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "opts", ")", "\n", "self", ".", "name", "=", "'max_var'", "\n", "self", ".", "label_fn", "=", "'Variance of the Unnormalised Approximate Posterior'", "\n", "self", ".", "quantile_eps", "=", "quantile_eps", "\n", "# The ABC threshold is initialised to a pre-set value as the gp is not yet fit.", "\n", "self", ".", "eps", "=", ".1", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.MaxVar.acquire": [[294, 335], ["logger.debug", "numpy.percentile", "elfi.methods.bo.utils.minimize", "numpy.tile", "acquisition.MaxVar.evaluate", "acquisition.MaxVar.evaluate_gradient"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate_gradient"], ["", "def", "acquire", "(", "self", ",", "n", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Acquire a batch of acquisition points.\n\n        Parameters\n        ----------\n        n : int\n            Number of acquisitions.\n        t : int, optional\n            Current iteration, (unused).\n\n        Returns\n        -------\n        array_like\n            Coordinates of the yielded acquisition points.\n\n        \"\"\"", "\n", "logger", ".", "debug", "(", "'Acquiring the next batch of %d values'", ",", "n", ")", "\n", "gp", "=", "self", ".", "model", "\n", "\n", "# Updating the ABC threshold.", "\n", "self", ".", "eps", "=", "np", ".", "percentile", "(", "gp", ".", "Y", ",", "self", ".", "quantile_eps", "*", "100", ")", "\n", "\n", "def", "_negate_eval", "(", "theta", ")", ":", "\n", "            ", "return", "-", "self", ".", "evaluate", "(", "theta", ")", "\n", "\n", "", "def", "_negate_eval_grad", "(", "theta", ")", ":", "\n", "            ", "return", "-", "self", ".", "evaluate_gradient", "(", "theta", ")", "\n", "\n", "# Obtaining the location where the variance is maximised.", "\n", "", "theta_max", ",", "_", "=", "minimize", "(", "_negate_eval", ",", "\n", "gp", ".", "bounds", ",", "\n", "_negate_eval_grad", ",", "\n", "self", ".", "prior", ",", "\n", "self", ".", "n_inits", ",", "\n", "self", ".", "max_opt_iters", ",", "\n", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n", "# Using the same location for all points in theta batch.", "\n", "batch_theta", "=", "np", ".", "tile", "(", "theta_max", ",", "(", "n", ",", "1", ")", ")", "\n", "\n", "return", "batch_theta", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.MaxVar.evaluate": [[336, 366], ["acquisition.MaxVar.model.predict", "numpy.sqrt", "scipy.skewnorm.cdf", "scipy.skewnorm.cdf", "scipy.norm.cdf", "scipy.norm.cdf", "numpy.sqrt", "numpy.sqrt", "acquisition.MaxVar.prior.pdf().ravel", "acquisition.MaxVar.prior.pdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf"], ["", "def", "evaluate", "(", "self", ",", "theta_new", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate the acquisition function at the location theta_new.\n\n        Parameters\n        ----------\n        theta_new : array_like\n            Evaluation coordinates.\n        t : int, optional\n            Current iteration, (unused).\n\n        Returns\n        -------\n        array_like\n            Variance of the approximate posterior.\n\n        \"\"\"", "\n", "mean", ",", "var", "=", "self", ".", "model", ".", "predict", "(", "theta_new", ",", "noiseless", "=", "True", ")", "\n", "sigma2_n", "=", "self", ".", "model", ".", "noise", "\n", "\n", "# Using the cdf of Skewnorm to avoid explicit Owen's T computation.", "\n", "a", "=", "np", ".", "sqrt", "(", "sigma2_n", ")", "/", "np", ".", "sqrt", "(", "sigma2_n", "+", "2.", "*", "var", ")", "# Skewness.", "\n", "scale", "=", "np", ".", "sqrt", "(", "sigma2_n", "+", "var", ")", "\n", "phi_skew", "=", "ss", ".", "skewnorm", ".", "cdf", "(", "self", ".", "eps", ",", "a", ",", "loc", "=", "mean", ",", "scale", "=", "scale", ")", "\n", "phi_norm", "=", "ss", ".", "norm", ".", "cdf", "(", "self", ".", "eps", ",", "loc", "=", "mean", ",", "scale", "=", "scale", ")", "\n", "var_p_a", "=", "phi_skew", "-", "phi_norm", "**", "2", "\n", "\n", "val_prior", "=", "self", ".", "prior", ".", "pdf", "(", "theta_new", ")", ".", "ravel", "(", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "var_approx_posterior", "=", "val_prior", "**", "2", "*", "var_p_a", "\n", "return", "var_approx_posterior", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.MaxVar.evaluate_gradient": [[367, 414], ["acquisition.MaxVar.model.predict", "acquisition.MaxVar.model.predictive_gradients", "numpy.sqrt", "phi", "acquisition.MaxVar.prior.gradient_logpdf", "numpy.sqrt", "numpy.sqrt", "phi", "scipy.skewnorm.cdf", "scipy.skewnorm.cdf", "acquisition.MaxVar.prior.pdf().ravel", "numpy.sqrt", "numpy.exp", "numpy.sqrt", "acquisition.MaxVar.prior.pdf", "numpy.exp", "numpy.sqrt", "numpy.exp", "phi"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.gradient_logpdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf"], ["", "def", "evaluate_gradient", "(", "self", ",", "theta_new", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate the acquisition function's gradient at the location theta_new.\n\n        Parameters\n        ----------\n        theta_new : array_like\n            Evaluation coordinates.\n        t : int, optional\n            Current iteration, (unused).\n\n        Returns\n        -------\n        array_like\n            Gradient of the variance of the approximate posterior\n\n        \"\"\"", "\n", "phi", "=", "ss", ".", "norm", ".", "cdf", "\n", "mean", ",", "var", "=", "self", ".", "model", ".", "predict", "(", "theta_new", ",", "noiseless", "=", "True", ")", "\n", "grad_mean", ",", "grad_var", "=", "self", ".", "model", ".", "predictive_gradients", "(", "theta_new", ")", "\n", "sigma2_n", "=", "self", ".", "model", ".", "noise", "\n", "scale", "=", "np", ".", "sqrt", "(", "sigma2_n", "+", "var", ")", "\n", "\n", "a", "=", "(", "self", ".", "eps", "-", "mean", ")", "/", "scale", "\n", "b", "=", "np", ".", "sqrt", "(", "sigma2_n", ")", "/", "np", ".", "sqrt", "(", "sigma2_n", "+", "2", "*", "var", ")", "\n", "grad_a", "=", "(", "-", "1.", "/", "scale", ")", "*", "grad_mean", "-", "(", "(", "self", ".", "eps", "-", "mean", ")", "/", "(", "2.", "*", "(", "sigma2_n", "+", "var", ")", "**", "(", "1.5", ")", ")", ")", "*", "grad_var", "\n", "grad_b", "=", "(", "-", "np", ".", "sqrt", "(", "sigma2_n", ")", "/", "(", "sigma2_n", "+", "2", "*", "var", ")", "**", "(", "1.5", ")", ")", "*", "grad_var", "\n", "\n", "_phi_a", "=", "phi", "(", "a", ")", "\n", "int_1", "=", "_phi_a", "-", "_phi_a", "**", "2", "\n", "int_2", "=", "phi", "(", "self", ".", "eps", ",", "loc", "=", "mean", ",", "scale", "=", "scale", ")", "-", "ss", ".", "skewnorm", ".", "cdf", "(", "self", ".", "eps", ",", "b", ",", "loc", "=", "mean", ",", "scale", "=", "scale", ")", "\n", "grad_int_1", "=", "(", "1.", "-", "2", "*", "_phi_a", ")", "*", "(", "np", ".", "exp", "(", "-", ".5", "*", "(", "a", "**", "2", ")", ")", "/", "np", ".", "sqrt", "(", "2.", "*", "np", ".", "pi", ")", ")", "*", "grad_a", "\n", "grad_int_2", "=", "(", "1.", "/", "np", ".", "pi", ")", "*", "(", "(", "(", "np", ".", "exp", "(", "-", ".5", "*", "(", "a", "**", "2", ")", "*", "(", "1.", "+", "b", "**", "2", ")", ")", ")", "/", "(", "1.", "+", "b", "**", "2", ")", ")", "*", "grad_b", "+", "\n", "(", "np", ".", "sqrt", "(", "np", ".", "pi", "/", "2.", ")", "*", "np", ".", "exp", "(", "-", ".5", "*", "(", "a", "**", "2", ")", ")", "*", "(", "1.", "-", "2.", "*", "phi", "(", "a", "*", "b", ")", ")", "*", "grad_a", ")", ")", "\n", "\n", "# Obtaining the gradient prior by applying the following rule:", "\n", "# (log f(x))' = f'(x)/f(x) => f'(x) = (log f(x))' * f(x)", "\n", "term_prior", "=", "self", ".", "prior", ".", "pdf", "(", "theta_new", ")", ".", "ravel", "(", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "grad_prior_log", "=", "self", ".", "prior", ".", "gradient_logpdf", "(", "theta_new", ")", "\n", "term_grad_prior", "=", "term_prior", "*", "grad_prior_log", "\n", "\n", "gradient", "=", "2.", "*", "term_prior", "*", "(", "int_1", "-", "int_2", ")", "*", "term_grad_prior", "+", "term_prior", "**", "2", "*", "(", "grad_int_1", "-", "grad_int_2", ")", "\n", "return", "gradient", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.RandMaxVar.__init__": [[441, 467], ["acquisition.MaxVar.__init__"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "quantile_eps", "=", ".01", ",", "sampler", "=", "'nuts'", ",", "n_samples", "=", "50", ",", "\n", "limit_faulty_init", "=", "10", ",", "sigma_proposals_metropolis", "=", "None", ",", "*", "args", ",", "**", "opts", ")", ":", "\n", "        ", "\"\"\"Initialise RandMaxVar.\n\n        Parameters\n        ----------\n        quantile_eps : int, optional\n            Quantile of the observed discrepancies used in setting the ABC threshold.\n        sampler : string, optional\n            Name of the sampler (options: metropolis, nuts).\n        n_samples : int, optional\n            Length of the sampler's chain for obtaining the acquisitions.\n        limit_faulty_init : int, optional\n            Limit for the iterations used to obtain the sampler's initial points.\n        sigma_proposals_metropolis : array_like, optional\n            Standard deviation proposals for tuning the metropolis sampler.\n            For the default settings, the sigmas are set to the 1/10\n            of the parameter intervals' length.\n\n        \"\"\"", "\n", "super", "(", "RandMaxVar", ",", "self", ")", ".", "__init__", "(", "quantile_eps", ",", "*", "args", ",", "**", "opts", ")", "\n", "self", ".", "name", "=", "'rand_max_var'", "\n", "self", ".", "name_sampler", "=", "sampler", "\n", "self", ".", "_n_samples", "=", "n_samples", "\n", "self", ".", "_limit_faulty_init", "=", "limit_faulty_init", "\n", "self", ".", "_sigma_proposals_metropolis", "=", "sigma_proposals_metropolis", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.RandMaxVar.acquire": [[468, 552], ["logger.debug", "numpy.percentile", "range", "ValueError", "acquisition.RandMaxVar.evaluate", "pt_eval.ravel", "acquisition.RandMaxVar.evaluate", "numpy.log", "numpy.zeros", "enumerate", "numpy.isinf", "acquisition.RandMaxVar.evaluate_gradient", "SystemExit", "acquisition.RandMaxVar.random_state.uniform", "acquisition.RandMaxVar.acquire._evaluate_logpdf"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate_gradient"], ["", "def", "acquire", "(", "self", ",", "n", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Acquire a batch of acquisition points.\n\n        Parameters\n        ----------\n        n : int\n            Number of acquisitions.\n        t : int, optional\n            Current iteration, (unused).\n\n        Returns\n        -------\n        array_like\n            Coordinates of the yielded acquisition points.\n\n        \"\"\"", "\n", "if", "n", ">", "self", ".", "_n_samples", ":", "\n", "            ", "raise", "ValueError", "(", "\"The number of acquisitions, n, has to be lower\"", "\n", "\"than the number of the samples (%d).\"", "\n", ".", "format", "(", "self", ".", "_n_samples", ")", ")", "\n", "\n", "", "logger", ".", "debug", "(", "'Acquiring the next batch of %d values'", ",", "n", ")", "\n", "gp", "=", "self", ".", "model", "\n", "\n", "# Updating the ABC threshold.", "\n", "self", ".", "eps", "=", "np", ".", "percentile", "(", "gp", ".", "Y", ",", "self", ".", "quantile_eps", "*", "100", ")", "\n", "\n", "def", "_evaluate_gradient_logpdf", "(", "theta", ")", ":", "\n", "            ", "denominator", "=", "self", ".", "evaluate", "(", "theta", ")", "\n", "if", "denominator", "==", "0", ":", "\n", "                ", "return", "-", "np", ".", "inf", "\n", "", "pt_eval", "=", "self", ".", "evaluate_gradient", "(", "theta", ")", "/", "denominator", "\n", "return", "pt_eval", ".", "ravel", "(", ")", "\n", "\n", "", "def", "_evaluate_logpdf", "(", "theta", ")", ":", "\n", "            ", "val_pdf", "=", "self", ".", "evaluate", "(", "theta", ")", "\n", "if", "val_pdf", "==", "0", ":", "\n", "                ", "return", "-", "np", ".", "inf", "\n", "", "return", "np", ".", "log", "(", "val_pdf", ")", "\n", "\n", "# Obtaining the RandMaxVar acquisition.", "\n", "", "for", "i", "in", "range", "(", "self", ".", "_limit_faulty_init", "+", "1", ")", ":", "\n", "            ", "if", "i", ">", "self", ".", "_limit_faulty_init", ":", "\n", "                ", "raise", "SystemExit", "(", "\"Unable to find a suitable initial point.\"", ")", "\n", "\n", "# Proposing the initial point.", "\n", "", "theta_init", "=", "np", ".", "zeros", "(", "shape", "=", "len", "(", "gp", ".", "bounds", ")", ")", "\n", "for", "idx_param", ",", "range_bound", "in", "enumerate", "(", "gp", ".", "bounds", ")", ":", "\n", "                ", "theta_init", "[", "idx_param", "]", "=", "self", ".", "random_state", ".", "uniform", "(", "range_bound", "[", "0", "]", ",", "range_bound", "[", "1", "]", ")", "\n", "\n", "# Refusing to accept a faulty initial point.", "\n", "", "if", "np", ".", "isinf", "(", "_evaluate_logpdf", "(", "theta_init", ")", ")", ":", "\n", "                ", "continue", "\n", "\n", "# Sampling the acquisition using the chosen sampler.", "\n", "", "if", "self", ".", "name_sampler", "==", "'metropolis'", ":", "\n", "                ", "if", "self", ".", "_sigma_proposals_metropolis", "is", "None", ":", "\n", "# Setting the default values of the sigma proposals to 1/10", "\n", "# of each parameters interval's length.", "\n", "                    ", "sigma_proposals", "=", "[", "]", "\n", "for", "bound", "in", "self", ".", "model", ".", "bounds", ":", "\n", "                        ", "length_interval", "=", "bound", "[", "1", "]", "-", "bound", "[", "0", "]", "\n", "sigma_proposals", ".", "append", "(", "length_interval", "/", "10", ")", "\n", "", "self", ".", "_sigma_proposals_metropolis", "=", "sigma_proposals", "\n", "", "samples", "=", "mcmc", ".", "metropolis", "(", "self", ".", "_n_samples", ",", "\n", "theta_init", ",", "\n", "_evaluate_logpdf", ",", "\n", "sigma_proposals", "=", "self", ".", "_sigma_proposals_metropolis", ",", "\n", "seed", "=", "self", ".", "seed", ")", "\n", "", "elif", "self", ".", "name_sampler", "==", "'nuts'", ":", "\n", "                ", "samples", "=", "mcmc", ".", "nuts", "(", "self", ".", "_n_samples", ",", "\n", "theta_init", ",", "\n", "_evaluate_logpdf", ",", "\n", "_evaluate_gradient_logpdf", ",", "\n", "seed", "=", "self", ".", "seed", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Incompatible sampler. Please check the options in the documentation.\"", ")", "\n", "\n", "# Using the last n points of the MH chain for the acquisition batch.", "\n", "", "batch_theta", "=", "samples", "[", "-", "n", ":", ",", ":", "]", "\n", "break", "\n", "\n", "", "return", "batch_theta", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.ExpIntVar.__init__": [[580, 630], ["acquisition.MaxVar.__init__", "acquisition.RandMaxVar", "slice", "numpy.mgrid[].reshape", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "quantile_eps", "=", ".01", ",", "integration", "=", "'grid'", ",", "d_grid", "=", ".2", ",", "\n", "n_samples_imp", "=", "100", ",", "iter_imp", "=", "2", ",", "sampler", "=", "'nuts'", ",", "n_samples", "=", "2000", ",", "\n", "sigma_proposals_metropolis", "=", "None", ",", "*", "args", ",", "**", "opts", ")", ":", "\n", "        ", "\"\"\"Initialise ExpIntVar.\n\n        Parameters\n        ----------\n        quantile_eps : int, optional\n            Quantile of the observed discrepancies used in setting the discrepancy threshold.\n        integration : str, optional\n            Integration method. Options:\n            - grid (points are taken uniformly): more accurate yet\n            computationally expensive in high dimensions;\n            - importance (points are taken based on the importance weight): less accurate though\n            applicable in high dimensions.\n        d_grid : float, optional\n            Grid tightness.\n        n_samples_imp : int, optional\n            Number of importance samples.\n        iter_imp : int, optional\n            Gap between acquisition iterations in performing importance sampling.\n        sampler : string, optional\n            Sampler for generating random numbers from the proposal distribution for IS.\n            (Options: metropolis, nuts.)\n        n_samples : int, optional\n            Chain length for the sampler that generates the random numbers\n            from the proposal distribution for IS.\n        sigma_proposals_metropolis : array_like, optional\n            Standard deviation proposals for tuning the metropolis sampler.\n\n        \"\"\"", "\n", "super", "(", "ExpIntVar", ",", "self", ")", ".", "__init__", "(", "quantile_eps", ",", "*", "args", ",", "**", "opts", ")", "\n", "self", ".", "name", "=", "'exp_int_var'", "\n", "self", ".", "label_fn", "=", "'Expected Loss'", "\n", "self", ".", "_integration", "=", "integration", "\n", "self", ".", "_n_samples_imp", "=", "n_samples_imp", "\n", "self", ".", "_iter_imp", "=", "iter_imp", "\n", "\n", "if", "self", ".", "_integration", "==", "'importance'", ":", "\n", "            ", "self", ".", "density_is", "=", "RandMaxVar", "(", "model", "=", "self", ".", "model", ",", "\n", "prior", "=", "self", ".", "prior", ",", "\n", "n_inits", "=", "self", ".", "n_inits", ",", "\n", "seed", "=", "self", ".", "seed", ",", "\n", "quantile_eps", "=", "self", ".", "quantile_eps", ",", "\n", "sampler", "=", "sampler", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "sigma_proposals_metropolis", "=", "sigma_proposals_metropolis", ")", "\n", "", "elif", "self", ".", "_integration", "==", "'grid'", ":", "\n", "            ", "grid_param", "=", "[", "slice", "(", "b", "[", "0", "]", ",", "b", "[", "1", "]", ",", "d_grid", ")", "for", "b", "in", "self", ".", "model", ".", "bounds", "]", "\n", "self", ".", "points_int", "=", "np", ".", "mgrid", "[", "grid_param", "]", ".", "reshape", "(", "len", "(", "self", ".", "model", ".", "bounds", ")", ",", "-", "1", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.ExpIntVar.acquire": [[631, 692], ["logger.debug", "numpy.percentile", "gp.predict", "numpy.array", "scipy.norm.cdf", "scipy.norm.cdf", "elfi.methods.bo.utils.minimize", "numpy.tile", "acquisition.ExpIntVar.density_is.acquire", "acquisition.ExpIntVar._K", "acquisition.ExpIntVar._K", "acquisition.ExpIntVar.prior.pdf", "numpy.empty", "acquisition.ExpIntVar.omegas_int.fill", "numpy.identity", "numpy.sqrt", "acquisition.MaxVar.evaluate", "numpy.sum", "len", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.pdf", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm_dgp.bdm_simulator.identity", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate"], ["", "", "def", "acquire", "(", "self", ",", "n", ",", "t", ")", ":", "\n", "        ", "\"\"\"Acquire a batch of acquisition points.\n\n        Parameters\n        ----------\n        n : int\n            Number of acquisitions.\n        t : int\n            Current iteration.\n\n        Returns\n        -------\n        array_like\n            Coordinates of the yielded acquisition points.\n\n        \"\"\"", "\n", "logger", ".", "debug", "(", "'Acquiring the next batch of %d values'", ",", "n", ")", "\n", "gp", "=", "self", ".", "model", "\n", "self", ".", "sigma2_n", "=", "gp", ".", "noise", "\n", "\n", "# Updating the discrepancy threshold.", "\n", "self", ".", "eps", "=", "np", ".", "percentile", "(", "gp", ".", "Y", ",", "self", ".", "quantile_eps", "*", "100", ")", "\n", "\n", "# Performing the importance sampling step every self._iter_imp iterations.", "\n", "if", "self", ".", "_integration", "==", "'importance'", "and", "t", "%", "self", ".", "_iter_imp", "==", "0", ":", "\n", "            ", "self", ".", "points_int", "=", "self", ".", "density_is", ".", "acquire", "(", "self", ".", "_n_samples_imp", ")", "\n", "\n", "# Obtaining the omegas_int and priors_int terms to be used in the evaluate function.", "\n", "", "self", ".", "mean_int", ",", "self", ".", "var_int", "=", "gp", ".", "predict", "(", "self", ".", "points_int", ",", "noiseless", "=", "True", ")", "\n", "self", ".", "priors_int", "=", "(", "self", ".", "prior", ".", "pdf", "(", "self", ".", "points_int", ")", "**", "2", ")", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "if", "self", ".", "_integration", "==", "'importance'", "and", "t", "%", "self", ".", "_iter_imp", "==", "0", ":", "\n", "            ", "omegas_int_unnormalised", "=", "(", "1", "/", "MaxVar", ".", "evaluate", "(", "self", ",", "self", ".", "points_int", ")", ")", ".", "T", "\n", "self", ".", "omegas_int", "=", "omegas_int_unnormalised", "/", "np", ".", "sum", "(", "omegas_int_unnormalised", ",", "axis", "=", "1", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "", "elif", "self", ".", "_integration", "==", "'grid'", ":", "\n", "            ", "self", ".", "omegas_int", "=", "np", ".", "empty", "(", "len", "(", "self", ".", "points_int", ")", ")", "\n", "self", ".", "omegas_int", ".", "fill", "(", "1", "/", "len", "(", "self", ".", "points_int", ")", ")", "\n", "\n", "# Initialising the attributes used in the evaluate function.", "\n", "", "self", ".", "thetas_old", "=", "np", ".", "array", "(", "gp", ".", "X", ")", "\n", "self", ".", "_K", "=", "gp", ".", "_gp", ".", "kern", ".", "K", "\n", "self", ".", "K", "=", "self", ".", "_K", "(", "self", ".", "thetas_old", ",", "self", ".", "thetas_old", ")", "+", "self", ".", "sigma2_n", "*", "np", ".", "identity", "(", "self", ".", "thetas_old", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "k_int_old", "=", "self", ".", "_K", "(", "self", ".", "points_int", ",", "self", ".", "thetas_old", ")", ".", "T", "\n", "self", ".", "phi_int", "=", "ss", ".", "norm", ".", "cdf", "(", "self", ".", "eps", ",", "loc", "=", "self", ".", "mean_int", ".", "T", ",", "\n", "scale", "=", "np", ".", "sqrt", "(", "self", ".", "sigma2_n", "+", "self", ".", "var_int", ".", "T", ")", ")", "\n", "\n", "# Obtaining the location where the expected loss is minimised.", "\n", "# Note: The gradient is computed numerically as GPy currently does not", "\n", "# directly provide the derivative computations used in J\u00e4rvenp\u00e4\u00e4 et al., 2017.", "\n", "theta_min", ",", "_", "=", "minimize", "(", "self", ".", "evaluate", ",", "\n", "gp", ".", "bounds", ",", "\n", "grad", "=", "None", ",", "\n", "prior", "=", "self", ".", "prior", ",", "\n", "n_start_points", "=", "self", ".", "n_inits", ",", "\n", "maxiter", "=", "self", ".", "max_opt_iters", ",", "\n", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n", "# Using the same location for all points in the batch.", "\n", "batch_theta", "=", "np", ".", "tile", "(", "theta_min", ",", "(", "n", ",", "1", ")", ")", "\n", "return", "batch_theta", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.ExpIntVar.evaluate": [[693, 736], ["gp.predict", "acquisition.ExpIntVar._K", "scipy.cho_solve", "scipy.cho_solve", "numpy.sqrt", "scipy.skewnorm.cdf", "scipy.skewnorm.cdf", "acquisition.ExpIntVar._K", "scipy.cho_factor", "scipy.cho_factor", "numpy.sum", "numpy.dot", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict"], ["", "def", "evaluate", "(", "self", ",", "theta_new", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate the acquisition function at the location theta_new.\n\n        Parameters\n        ----------\n        theta_new : array_like\n            Evaluation coordinates.\n        t : int, optional\n            Current iteration, (unused).\n\n        Returns\n        -------\n        array_like\n            Expected loss's term dependent on theta_new.\n\n        \"\"\"", "\n", "gp", "=", "self", ".", "model", "\n", "n_imp", ",", "n_dim", "=", "self", ".", "points_int", ".", "shape", "\n", "# Alter the shape of theta_new.", "\n", "if", "n_dim", "!=", "1", "and", "theta_new", ".", "ndim", "==", "1", ":", "\n", "            ", "theta_new", "=", "theta_new", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "", "elif", "n_dim", "==", "1", "and", "theta_new", ".", "ndim", "==", "1", ":", "\n", "            ", "theta_new", "=", "theta_new", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "# Calculate the integrand term w.", "\n", "# Note: w's second term (given in J\u00e4rvenp\u00e4\u00e4 et al., 2017) is dismissed", "\n", "# because it is constant with respect to theta_new.", "\n", "", "_", ",", "var_new", "=", "gp", ".", "predict", "(", "theta_new", ",", "noiseless", "=", "True", ")", "\n", "k_old_new", "=", "self", ".", "_K", "(", "self", ".", "thetas_old", ",", "theta_new", ")", "\n", "k_int_new", "=", "self", ".", "_K", "(", "self", ".", "points_int", ",", "theta_new", ")", ".", "T", "\n", "# Using the Cholesky factorisation to avoid computing matrix inverse.", "\n", "term_chol", "=", "sl", ".", "cho_solve", "(", "sl", ".", "cho_factor", "(", "self", ".", "K", ")", ",", "k_old_new", ")", "\n", "cov_int", "=", "k_int_new", "-", "np", ".", "dot", "(", "self", ".", "k_int_old", ".", "T", ",", "term_chol", ")", ".", "T", "\n", "delta_var_int", "=", "cov_int", "**", "2", "/", "(", "self", ".", "sigma2_n", "+", "var_new", ")", "\n", "a", "=", "np", ".", "sqrt", "(", "(", "self", ".", "sigma2_n", "+", "self", ".", "var_int", ".", "T", "-", "delta_var_int", ")", "/", "\n", "(", "self", ".", "sigma2_n", "+", "self", ".", "var_int", ".", "T", "+", "delta_var_int", ")", ")", "\n", "# Using the skewnorm's cdf to substitute the Owen's T function.", "\n", "phi_skew_imp", "=", "ss", ".", "skewnorm", ".", "cdf", "(", "self", ".", "eps", ",", "a", ",", "loc", "=", "self", ".", "mean_int", ".", "T", ",", "\n", "scale", "=", "np", ".", "sqrt", "(", "self", ".", "sigma2_n", "+", "self", ".", "var_int", ".", "T", ")", ")", "\n", "w", "=", "(", "(", "self", ".", "phi_int", "-", "phi_skew_imp", ")", "/", "2", ")", "\n", "\n", "loss_theta_new", "=", "2", "*", "np", ".", "sum", "(", "self", ".", "omegas_int", "*", "self", ".", "priors_int", "*", "w", ",", "axis", "=", "1", ")", "\n", "return", "loss_theta_new", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.UniformAcquisition.acquire": [[741, 760], ["numpy.stack", "scipy.uniform().rvs", "scipy.uniform().rvs", "scipy.uniform", "scipy.uniform"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["def", "acquire", "(", "self", ",", "n", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return random points from uniform distribution.\n\n        Parameters\n        ----------\n        n : int\n            Number of acquisition points to return.\n        t : int, optional\n            (unused)\n\n        Returns\n        -------\n        x : np.ndarray\n            The shape is (n, input_dim)\n\n        \"\"\"", "\n", "bounds", "=", "np", ".", "stack", "(", "self", ".", "model", ".", "bounds", ")", "\n", "return", "ss", ".", "uniform", "(", "bounds", "[", ":", ",", "0", "]", ",", "bounds", "[", ":", ",", "1", "]", "-", "bounds", "[", ":", ",", "0", "]", ")", ".", "rvs", "(", "size", "=", "(", "n", ",", "self", ".", "model", ".", "input_dim", ")", ",", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.OneRandomXPerBatch.acquire": [[765, 785], ["numpy.stack", "scipy.uniform().rvs", "scipy.uniform().rvs", "numpy.repeat", "scipy.uniform", "scipy.uniform"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs"], ["def", "acquire", "(", "self", ",", "n", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return random points from uniform distribution.\n\n        Parameters\n        ----------\n        n : int\n            Number of acquisition points to return.\n        t : int, optional\n            (unused)\n\n        Returns\n        -------\n        x : np.ndarray\n            The shape is (n, input_dim)\n\n        \"\"\"", "\n", "bounds", "=", "np", ".", "stack", "(", "self", ".", "model", ".", "bounds", ")", "\n", "x", "=", "ss", ".", "uniform", "(", "bounds", "[", ":", ",", "0", "]", ",", "bounds", "[", ":", ",", "1", "]", "-", "bounds", "[", ":", ",", "0", "]", ")", ".", "rvs", "(", "size", "=", "(", "1", ",", "self", ".", "model", ".", "input_dim", ")", ",", "random_state", "=", "self", ".", "random_state", ")", "\n", "return", "np", ".", "repeat", "(", "x", ",", "n", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.delta": [[788, 792], ["None"], "methods", ["None"], ["    ", "@", "property", "\n", "def", "delta", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the inverse of exploration rate.\"\"\"", "\n", "return", "1", "/", "self", ".", "exploration_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition._beta": [[793, 798], ["numpy.log"], "methods", ["None"], ["", "def", "_beta", "(", "self", ",", "t", ")", ":", "\n", "# Start from 0", "\n", "        ", "t", "+=", "1", "\n", "d", "=", "self", ".", "model", ".", "input_dim", "\n", "return", "2", "*", "np", ".", "log", "(", "t", "**", "(", "2", "*", "d", "+", "2", ")", "*", "np", ".", "pi", "**", "2", "/", "(", "3", "*", "self", ".", "delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate": [[799, 811], ["acquisition.QuantileAcquisition.model.predict", "numpy.sqrt", "acquisition.QuantileAcquisition._beta"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predict", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition._beta"], ["", "def", "evaluate", "(", "self", ",", "x", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        x : numpy.array\n        t : int\n            Current iteration (starting from 0).\n\n        \"\"\"", "\n", "# sampled_fs = self.model.sample_fs(x)", "\n", "mean", ",", "var", "=", "self", ".", "model", ".", "predict", "(", "x", ",", "noiseless", "=", "True", ")", "\n", "return", "mean", "-", "np", ".", "sqrt", "(", "self", ".", "_beta", "(", "t", ")", "*", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.acquisition.QuantileAcquisition.evaluate_gradient": [[815, 830], ["acquisition.QuantileAcquisition.model.predictive_gradients"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.predictive_gradients"], ["", "def", "evaluate_gradient", "(", "self", ",", "x", ",", "t", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        x : numpy.array\n        t : int\n            Current iteration (starting from 0).\n\n        \"\"\"", "\n", "# mean, var = self.model.predict(x, noiseless=True)", "\n", "grad_mean", "=", "self", ".", "model", ".", "predictive_gradients", "(", "x", ")", "\n", "# print(x)", "\n", "# print(self.model.predict(x))", "\n", "# print(np.gradient(self.model.predict(x)))", "\n", "return", "grad_mean", "#None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.stochastic_optimization": [[9, 34], ["scipy.optimize.differential_evolution"], "function", ["None"], ["\n", "import", "numpy", "as", "np", "\n", "import", "pandas", "as", "pd", "\n", "from", "os", "import", "path", "\n", "from", "pathlib", "import", "Path", "\n", "\n", "from", "kelfi", ".", "kernel_means_inference", "import", "kernel_means_weights", ",", "approximate_marginal_kernel_means_likelihood", "\n", "from", "kelfi", ".", "kernel_means_inference", "import", "approximate_kernel_means_posterior_embedding", ",", "kernel_herding", "\n", "from", "kelfi", ".", "kernel_means_learning", "import", "kernel_means_hyperparameter_learning", "\n", "from", "kelfi", ".", "kernels", "import", "gaussian_kernel_gramix", "\n", "\n", "\n", "import", "warnings", "\n", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ")", "\n", "\n", "\n", "# =====================", "\n", "# PLOTTING FUNCTIONS:", "\n", "# =====================", "\n", "\n", "mpl", ".", "rcParams", "[", "'figure.dpi'", "]", "=", "300", "\n", "\n", "\n", "# sample posterior of the trained surrogate model", "\n", "def", "get_weighted_samples", "(", "post", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "post", ".", "prior", ".", "rvs", "(", "size", "=", "N", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize": [[37, 101], ["len", "numpy.empty", "numpy.empty", "range", "numpy.argmin", "range", "range", "prior.rvs", "range", "scipy.optimize.minimize", "locs.append", "numpy.clip", "random_state.uniform", "len", "numpy.clip"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.utils.ModelPrior.rvs", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["        ", "theta", "=", "theta", ".", "reshape", "(", "theta", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "\n", "", "weights", "=", "post", ".", "_unnormalized_likelihood", "(", "theta", ")", "\n", "return", "theta", ",", "weights", "\n", "\n", "\n", "\n", "", "def", "sample_posterior", "(", "samples", ",", "weights", ",", "cols", ",", "N", "=", "100000", ")", ":", "\n", "    ", "theta", "=", "samples", "\n", "n_weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "\n", "\n", "# importance weighted resampling", "\n", "resample_index", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "samples", ")", ",", "size", "=", "N", ",", "replace", "=", "True", ",", "p", "=", "n_weights", ")", "\n", "theta_resampled", "=", "theta", "[", "resample_index", ",", ":", "]", "\n", "theta_df", "=", "pd", ".", "DataFrame", ".", "from_records", "(", "theta_resampled", ",", "columns", "=", "cols", ")", "\n", "return", "theta_df", "\n", "\n", "\n", "\n", "# plot the grid plot of the surrogate posterior", "\n", "", "def", "plot_grid", "(", "theta_df", ",", "lims", ")", ":", "\n", "    ", "g", "=", "sns", ".", "PairGrid", "(", "theta_df", ")", "\n", "for", "x_ind", "in", "range", "(", "0", ",", "len", "(", "lims", ")", ")", ":", "\n", "        ", "for", "y_ind", "in", "range", "(", "0", ",", "len", "(", "lims", ")", ")", ":", "\n", "            ", "g", ".", "axes", "[", "y_ind", ",", "x_ind", "]", ".", "set_xlim", "(", "lims", "[", "x_ind", "]", ")", "\n", "g", ".", "axes", "[", "y_ind", ",", "x_ind", "]", ".", "set_ylim", "(", "lims", "[", "y_ind", "]", ")", "\n", "\n", "", "", "g", "=", "g", ".", "map_lower", "(", "plt", ".", "scatter", ",", "s", "=", "1", ")", "\n", "g", "=", "g", ".", "map_diag", "(", "plt", ".", "hist", ")", "\n", "\n", "\n", "", "def", "plot_thresholds", "(", "thrs", ",", "legend", ")", ":", "\n", "    ", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "ax", ".", "plot", "(", "thrs", ")", "\n", "ax", ".", "set_ylabel", "(", "'threshold'", ")", "\n", "ax", ".", "set_xlabel", "(", "'num of batches'", ")", "\n", "ax", ".", "legend", "(", "legend", ")", "\n", "return", "\n", "\n", "\n", "\n", "", "def", "plot_marginals", "(", "sim", ",", "bounds", ",", "true_samples_df", ",", "true_pars", ")", ":", "\n", "    ", "plot_methods", "=", "[", "'BO-GP(200)'", ",", "'BO-LV-2GP-0.3(200)'", "]", "\n", "par_names", "=", "list", "(", "bounds", ".", "keys", "(", ")", ")", "\n", "sns", ".", "set", "(", "style", "=", "\"ticks\"", ",", "rc", "=", "{", "\"lines.linewidth\"", ":", "0.7", "}", ")", "\n", "\n", "maps", "=", "{", "'t1'", ":", "r'$\\theta_{t1}$'", ",", "'R1'", ":", "r'$\\theta_{R1}$'", ",", "'R2'", ":", "r'$\\theta_{R2}$'", ",", "\n", "'burden'", ":", "r'$\\theta_{burden}$'", ",", "'white'", ":", "r'$\\theta_{white}$'", ",", "\n", "'yellow'", ":", "r'$\\theta_{yellow}$'", ",", "'red'", ":", "r'$\\theta_{red}$'", ",", "\n", "'green'", ":", "r'$\\theta_{green}$'", ",", "'purple'", ":", "r'$\\theta_{purple}$'", ",", "\n", "'x'", ":", "r'$\\theta_{x}$'", ",", "'y'", ":", "r'$\\theta_{y}$'", ",", "\n", "'ns'", ":", "r'$\\theta_{n_s}$'", ",", "'kc'", ":", "r'$\\theta_{k_c}$'", ",", "'alpha'", ":", "r'$\\theta_{\\alpha}$'", ",", "\n", "'r_star'", ":", "r'$\\theta_{R^*}$'", ",", "'As'", ":", "r'$\\theta_{A_s}$'", "}", "\n", "\n", "for", "plot_method", "in", "plot_methods", ":", "\n", "        ", "for", "cur_par_name", ",", "i", "in", "zip", "(", "par_names", ",", "range", "(", "len", "(", "par_names", ")", ")", ")", ":", "\n", "            ", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "for", "filename", "in", "Path", "(", "'./results/'", "+", "sim", "+", "'/'", "+", "plot_method", ")", ".", "glob", "(", "'*.samples'", ")", ":", "\n", "                ", "temp_dict", "=", "scipy", ".", "io", ".", "loadmat", "(", "filename", ")", "\n", "sur_theta", "=", "temp_dict", "[", "cur_par_name", "]", "\n", "# sns.distplot(sur_theta, color=(0.879, 0.929, 0.969), hist=False, kde_kws={'alpha':0.1}) #, scatter_kws={'alpha':0.3})", "\n", "# sns.distplot(sur_theta, color=(0.711, 0.832, 0.91), hist=False, kde_kws={'alpha':0.05}) # DGP almost good", "\n", "# sns.distplot(sur_theta, color=(0.554, 0.734, 0.855), hist=False, kde_kws={'alpha':0.05}) #GP gppd", "\n", "try", ":", "\n", "                    ", "sns", ".", "distplot", "(", "sur_theta", ",", "color", "=", "(", "0.516", ",", "0.707", ",", "0.839", ")", ",", "hist", "=", "False", ",", "kde_kws", "=", "{", "'alpha'", ":", "0.1", "}", ")", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI.__init__": [[10, 29], ["gpflow.Parameterized.__init__", "gpflow.params.ParamList", "gpflow.params.DataHolder", "gpflow.params.DataHolder", "gpflow.params.Minibatch", "gpflow.params.Minibatch"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["    ", "def", "__init__", "(", "self", ",", "X", ",", "Y", ",", "layers", ",", "likelihood", ",", "\n", "num_samples", "=", "1", ",", "\n", "minibatch_size", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "        ", "gpflow", ".", "Parameterized", ".", "__init__", "(", "self", ",", "name", "=", "name", ")", "\n", "\n", "self", ".", "likelihood", "=", "likelihood", "\n", "\n", "self", ".", "num_data", "=", "X", ".", "shape", "[", "0", "]", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "\n", "if", "minibatch_size", "is", "None", ":", "\n", "            ", "self", ".", "X", "=", "gpflow", ".", "params", ".", "DataHolder", "(", "X", ")", "\n", "self", ".", "Y", "=", "gpflow", ".", "params", ".", "DataHolder", "(", "Y", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "X", "=", "gpflow", ".", "params", ".", "Minibatch", "(", "X", ",", "batch_size", "=", "minibatch_size", ",", "seed", "=", "0", ")", "\n", "self", ".", "Y", "=", "gpflow", ".", "params", ".", "Minibatch", "(", "Y", ",", "batch_size", "=", "minibatch_size", ",", "seed", "=", "0", ")", "\n", "\n", "", "self", ".", "layers", "=", "gpflow", ".", "params", ".", "ParamList", "(", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI.propagate": [[30, 47], ["layer.propagate", "samples.append", "means.append", "covs.append", "kls.append", "kl_types.append"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "def", "propagate", "(", "self", ",", "X", ",", "full_cov", "=", "False", ",", "inference_amorization_inputs", "=", "None", ",", "is_sampled_local_regularizer", "=", "False", ")", ":", "\n", "\n", "        ", "samples", ",", "means", ",", "covs", ",", "kls", ",", "kl_types", "=", "[", "X", ",", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "sample", ",", "mean", ",", "cov", ",", "kl", "=", "layer", ".", "propagate", "(", "samples", "[", "-", "1", "]", ",", "\n", "full_cov", "=", "full_cov", ",", "\n", "inference_amorization_inputs", "=", "inference_amorization_inputs", ",", "\n", "is_sampled_local_regularizer", "=", "is_sampled_local_regularizer", ")", "\n", "samples", ".", "append", "(", "sample", ")", "\n", "means", ".", "append", "(", "mean", ")", "\n", "covs", ".", "append", "(", "cov", ")", "\n", "kls", ".", "append", "(", "kl", ")", "\n", "kl_types", ".", "append", "(", "layer", ".", "regularizer_type", ")", "\n", "\n", "", "return", "samples", "[", "1", ":", "]", ",", "means", ",", "covs", ",", "kls", ",", "kl_types", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI._build_likelihood": [[48, 87], ["tensorflow.tile", "tensorflow.tile", "tensorflow.concat", "models.DGP_VI.propagate", "models.DGP_VI.likelihood.variational_expectations", "tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.reduce_mean", "len", "tensorflow.concat", "tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.cast", "tensorflow.cast", "tensorflow.reduce_sum", "zip", "zip", "tensorflow.shape", "tensorflow.reduce_sum", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "def", "_build_likelihood", "(", "self", ")", ":", "\n", "        ", "X_tiled", "=", "tf", ".", "tile", "(", "self", ".", "X", ",", "[", "self", ".", "num_samples", ",", "1", "]", ")", "# SN, Dx", "\n", "Y_tiled", "=", "tf", ".", "tile", "(", "self", ".", "Y", ",", "[", "self", ".", "num_samples", ",", "1", "]", ")", "# SN, Dy", "\n", "\n", "XY", "=", "tf", ".", "concat", "(", "[", "X_tiled", ",", "Y_tiled", "]", ",", "-", "1", ")", "# SN, Dx+Dy", "\n", "\n", "# Following Salimbeni 2017, the sampling is independent over N", "\n", "# The flag is_sampled_local_regularizer=False means that the KL is returned for the regularizer", "\n", "\n", "samples", ",", "means", ",", "covs", ",", "kls", ",", "kl_types", "=", "self", ".", "propagate", "(", "X_tiled", ",", "\n", "full_cov", "=", "False", ",", "\n", "inference_amorization_inputs", "=", "XY", ",", "\n", "is_sampled_local_regularizer", "=", "False", ")", "\n", "\n", "local_kls", "=", "[", "kl", "for", "kl", ",", "t", "in", "zip", "(", "kls", ",", "kl_types", ")", "if", "t", "is", "RegularizerType", ".", "LOCAL", "]", "\n", "global_kls", "=", "[", "kl", "for", "kl", ",", "t", "in", "zip", "(", "kls", ",", "kl_types", ")", "if", "t", "is", "RegularizerType", ".", "GLOBAL", "]", "\n", "\n", "var_exp", "=", "self", ".", "likelihood", ".", "variational_expectations", "(", "means", "[", "-", "1", "]", ",", "covs", "[", "-", "1", "]", ",", "Y_tiled", ")", "# SN, Dy", "\n", "\n", "# Product over the columns of Y", "\n", "L_SN", "=", "tf", ".", "reduce_sum", "(", "var_exp", ",", "-", "1", ")", "# SN, Dy -> SN", "\n", "\n", "shape_S_N", "=", "[", "self", ".", "num_samples", ",", "tf", ".", "shape", "(", "self", ".", "X", ")", "[", "0", "]", "]", "\n", "L_S_N", "=", "tf", ".", "reshape", "(", "L_SN", ",", "shape_S_N", ")", "\n", "\n", "if", "len", "(", "local_kls", ")", ">", "0", ":", "\n", "            ", "local_kls_SN_D", "=", "tf", ".", "concat", "(", "local_kls", ",", "-", "1", ")", "# SN, sum(W_dims)", "\n", "local_kls_SN", "=", "tf", ".", "reduce_sum", "(", "local_kls_SN_D", ",", "-", "1", ")", "\n", "local_kls_S_N", "=", "tf", ".", "reshape", "(", "local_kls_SN", ",", "shape_S_N", ")", "\n", "L_S_N", "-=", "local_kls_S_N", "# SN", "\n", "\n", "", "scale", "=", "tf", ".", "cast", "(", "self", ".", "num_data", ",", "gpflow", ".", "settings", ".", "float_type", ")", "/", "tf", ".", "cast", "(", "tf", ".", "shape", "(", "self", ".", "X", ")", "[", "0", "]", ",", "gpflow", ".", "settings", ".", "float_type", ")", "\n", "\n", "# This line is replaced with tf.reduce_logsumexp in the IW case", "\n", "logp", "=", "tf", ".", "reduce_mean", "(", "L_S_N", ",", "0", ")", "\n", "\n", "return", "tf", ".", "reduce_sum", "(", "logp", ")", "*", "scale", "-", "tf", ".", "reduce_sum", "(", "global_kls", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI._build_predict": [[88, 92], ["models.DGP_VI.propagate"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "def", "_build_predict", "(", "self", ",", "X", ",", "full_cov", "=", "False", ")", ":", "\n", "        ", "fs", ",", "means", ",", "covs", ",", "_", ",", "_", "=", "self", ".", "propagate", "(", "X", ",", "full_cov", "=", "full_cov", ")", "\n", "return", "fs", "[", "-", "1", "]", ",", "means", "[", "-", "1", "]", ",", "covs", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI._build_predict_decomp": [[93, 97], ["models.DGP_VI.propagate"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "def", "_build_predict_decomp", "(", "self", ",", "X", ",", "full_cov", "=", "False", ")", ":", "\n", "        ", "fs", ",", "means", ",", "covs", ",", "_", ",", "_", "=", "self", ".", "propagate", "(", "X", ",", "full_cov", "=", "full_cov", ")", "\n", "return", "fs", "[", "-", "1", "]", ",", "means", "[", "-", "1", "]", ",", "covs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI.predict_f_multisample": [[98, 104], ["gpflow.autoflow", "tensorflow.tile", "models.DGP_VI.propagate"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "@", "gpflow", ".", "autoflow", "(", "(", "gpflow", ".", "settings", ".", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "gpflow", ".", "settings", ".", "int_type", ",", "(", ")", ")", ")", "\n", "def", "predict_f_multisample", "(", "self", ",", "X", ",", "S", ")", ":", "\n", "        ", "X_tiled", "=", "tf", ".", "tile", "(", "X", "[", "None", ",", ":", ",", ":", "]", ",", "[", "S", ",", "1", ",", "1", "]", ")", "\n", "_", ",", "means", ",", "covs", ",", "_", ",", "_", "=", "self", ".", "propagate", "(", "X_tiled", ")", "\n", "return", "means", "[", "-", "1", "]", ",", "covs", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_VI.predict_y_samples": [[105, 121], ["gpflow.autoflow", "tensorflow.tile", "models.DGP_VI.propagate", "models.DGP_VI.likelihood.predict_mean_and_var", "tensorflow.random_normal", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "@", "gpflow", ".", "autoflow", "(", "(", "gpflow", ".", "settings", ".", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "gpflow", ".", "settings", ".", "int_type", ",", "(", ")", ")", ")", "\n", "def", "predict_y_samples", "(", "self", ",", "X", ",", "S", ")", ":", "\n", "        ", "X_tiled", "=", "tf", ".", "tile", "(", "X", "[", "None", ",", ":", ",", ":", "]", ",", "[", "S", ",", "1", ",", "1", "]", ")", "\n", "_", ",", "means", ",", "covs", ",", "_", ",", "_", "=", "self", ".", "propagate", "(", "X_tiled", ")", "\n", "m", ",", "v", "=", "self", ".", "likelihood", ".", "predict_mean_and_var", "(", "means", "[", "-", "1", "]", ",", "covs", "[", "-", "1", "]", ")", "\n", "z", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "means", "[", "-", "1", "]", ")", ",", "dtype", "=", "gpflow", ".", "settings", ".", "float_type", ")", "\n", "\n", "'''res_mean = list()\n        res_var = list()\n        for i in range(0, len(covs)):\n            m1, v1 = self.likelihood.predict_mean_and_var(means[i], covs[i])\n            res_mean.append(m1)\n            res_var.append(v1)'''", "\n", "\n", "return", "m", "+", "z", "*", "v", "**", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.models.DGP_IWVI._build_likelihood": [[124, 164], ["tensorflow.tile", "tensorflow.tile", "tensorflow.concat", "models.DGP_IWVI.propagate", "tensorflow.transpose", "models.DGP_IWVI.likelihood.variational_expectations", "tensorflow.reduce_sum", "tensorflow.matrix_diag_part", "len", "tensorflow.concat", "tensorflow.reduce_sum", "tensorflow.cast", "tensorflow.cast", "tensorflow.reduce_logsumexp", "numpy.log", "tensorflow.reduce_sum", "zip", "zip", "tensorflow.reduce_sum", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate"], ["    ", "@", "gpflow", ".", "params_as_tensors", "\n", "def", "_build_likelihood", "(", "self", ")", ":", "\n", "        ", "X_tiled", "=", "tf", ".", "tile", "(", "self", ".", "X", "[", ":", ",", "None", ",", ":", "]", ",", "[", "1", ",", "self", ".", "num_samples", ",", "1", "]", ")", "# N, S, Dx", "\n", "Y_tiled", "=", "tf", ".", "tile", "(", "self", ".", "Y", "[", ":", ",", "None", ",", ":", "]", ",", "[", "1", ",", "self", ".", "num_samples", ",", "1", "]", ")", "# N, S, Dy", "\n", "\n", "XY", "=", "tf", ".", "concat", "(", "[", "X_tiled", ",", "Y_tiled", "]", ",", "-", "1", ")", "# N, S, Dx+Dy", "\n", "\n", "# While the sampling independent over N follows just as in Salimbeni 2017, in this", "\n", "# case we need to take full cov samples over the multisample dim S.", "\n", "# The flag is_sampled_local_regularizer=True means that the log p/q is returned", "\n", "# for the regularizer, rather than the KL", "\n", "samples", ",", "means", ",", "covs", ",", "kls", ",", "kl_types", "=", "self", ".", "propagate", "(", "X_tiled", ",", "\n", "full_cov", "=", "True", ",", "# NB the full_cov is over the S dim", "\n", "inference_amorization_inputs", "=", "XY", ",", "\n", "is_sampled_local_regularizer", "=", "True", ")", "\n", "\n", "local_kls", "=", "[", "kl", "for", "kl", ",", "t", "in", "zip", "(", "kls", ",", "kl_types", ")", "if", "t", "is", "RegularizerType", ".", "LOCAL", "]", "\n", "global_kls", "=", "[", "kl", "for", "kl", ",", "t", "in", "zip", "(", "kls", ",", "kl_types", ")", "if", "t", "is", "RegularizerType", ".", "GLOBAL", "]", "\n", "\n", "# This could be made slightly more efficient by making the last layer full_cov=False,", "\n", "# but this seems a small price to pay for cleaner code. NB this is only a SxS matrix, not", "\n", "# an NxN matrix.", "\n", "cov_diag", "=", "tf", ".", "transpose", "(", "tf", ".", "matrix_diag_part", "(", "covs", "[", "-", "1", "]", ")", ",", "[", "0", ",", "2", ",", "1", "]", ")", "# N,Dy,K,K -> N,K,Dy", "\n", "var_exp", "=", "self", ".", "likelihood", ".", "variational_expectations", "(", "means", "[", "-", "1", "]", ",", "cov_diag", ",", "Y_tiled", ")", "# N, K, Dy", "\n", "\n", "\n", "# Product over the columns of Y", "\n", "L_NK", "=", "tf", ".", "reduce_sum", "(", "var_exp", ",", "2", ")", "# N, K, Dy -> N, K", "\n", "\n", "if", "len", "(", "local_kls", ")", ">", "0", ":", "\n", "            ", "local_kls_NKD", "=", "tf", ".", "concat", "(", "local_kls", ",", "-", "1", ")", "# N, K, sum(W_dims)", "\n", "L_NK", "-=", "tf", ".", "reduce_sum", "(", "local_kls_NKD", ",", "2", ")", "# N, K", "\n", "\n", "", "scale", "=", "tf", ".", "cast", "(", "self", ".", "num_data", ",", "gpflow", ".", "settings", ".", "float_type", ")", "/", "tf", ".", "cast", "(", "tf", ".", "shape", "(", "self", ".", "X", ")", "[", "0", "]", ",", "gpflow", ".", "settings", ".", "float_type", ")", "\n", "\n", "# This is reduce_mean in the VI case.", "\n", "logp", "=", "tf", ".", "reduce_logsumexp", "(", "L_NK", ",", "1", ")", "-", "np", ".", "log", "(", "self", ".", "num_samples", ")", "\n", "\n", "return", "tf", ".", "reduce_sum", "(", "logp", ")", "*", "scale", "-", "tf", ".", "reduce_sum", "(", "global_kls", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.SharedMixedMok.__init__": [[112, 117], ["gpflow.params.Parameterized.__init__", "gpflow.params.Parameter"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "kernel", ",", "W", ",", "name", "=", "None", ")", ":", "\n", "        ", "Parameterized", ".", "__init__", "(", "self", ",", "name", "=", "name", ")", "\n", "\n", "self", ".", "kernel", "=", "kernel", "\n", "self", ".", "W", "=", "Parameter", "(", "W", ")", "# P x L", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.independent_multisample_sample_conditional": [[12, 100], ["gpflow.features.Kuu", "gpflow.features.Kuf", "tensorflow.cholesky", "tensorflow.matrix_triangular_solve", "tensorflow.transpose", "tensorflow.matmul", "tensorflow.shape", "tensorflow.reshape", "kern.K", "kern.Kdiag", "tensorflow.shape", "tensorflow.reshape", "tensorflow.tile", "tensorflow.tile", "tensorflow.matrix_triangular_solve", "tensorflow.transpose", "tensorflow.tile", "tensorflow.random_normal", "tensorflow.matrix_transpose", "tensorflow.random_normal", "tensorflow.transpose", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.matmul", "tensorflow.reduce_sum", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.shape", "tensorflow.transpose", "tensorflow.shape", "tensorflow.matmul", "tensorflow.square", "q_sqrt.get_shape", "tensorflow.einsum", "ValueError", "tensorflow.matmul", "tensorflow.reduce_sum", "tensorflow.cholesky", "tensorflow.transpose", "q_sqrt.get_shape", "tensorflow.matrix_band_part", "tensorflow.square", "str", "q_sqrt.get_shape"], "function", ["None"], ["def", "independent_multisample_sample_conditional", "(", "Xnew", ":", "tf", ".", "Tensor", ",", "feat", ":", "InducingPoints", ",", "kern", ":", "Kernel", ",", "f", ":", "tf", ".", "Tensor", ",", "*", ",", "\n", "full_cov", "=", "False", ",", "full_output_cov", "=", "False", ",", "q_sqrt", "=", "None", ",", "white", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Multisample, single-output GP conditional.\n\n    NB if full_cov=False is required, this functionality can be achieved by reshaping Xnew to SN x D\n    nd using conditional. The purpose of this function is to compute full covariances in batch over S samples.\n\n    The covariance matrices used to calculate the conditional have the following shape:\n    - Kuu: M x M\n    - Kuf: S x M x N\n    - Kff: S x N or S x N x N\n    ----------\n    :param Xnew: data matrix, size S x N x D.\n    :param f: data matrix, M x R\n    :param full_cov: return the covariance between the datapoints\n    :param full_output_cov: return the covariance between the outputs. Must be False\n    :param q_sqrt: matrix of standard-deviations or Cholesky matrices,\n        size M x R or R x M x M.\n    :param white: boolean of whether to use the whitened representation\n    :return:\n        - mean:     S x N x R\n        - variance: S x N x R, S x R x N x N\n    \"\"\"", "\n", "if", "full_output_cov", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "Kmm", "=", "Kuu", "(", "feat", ",", "kern", ",", "jitter", "=", "settings", ".", "numerics", ".", "jitter_level", ")", "# M x M", "\n", "\n", "S", ",", "N", ",", "D", "=", "tf", ".", "shape", "(", "Xnew", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "Xnew", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "Xnew", ")", "[", "2", "]", "\n", "M", "=", "tf", ".", "shape", "(", "Kmm", ")", "[", "0", "]", "\n", "\n", "Kmn_M_SN", "=", "Kuf", "(", "feat", ",", "kern", ",", "tf", ".", "reshape", "(", "Xnew", ",", "[", "S", "*", "N", ",", "D", "]", ")", ")", "# M x SN", "\n", "Knn", "=", "kern", ".", "K", "(", "Xnew", ")", "if", "full_cov", "else", "kern", ".", "Kdiag", "(", "Xnew", ")", "# S x N or S x N x N", "\n", "\n", "num_func", "=", "tf", ".", "shape", "(", "f", ")", "[", "1", "]", "# (=R)", "\n", "Lm", "=", "tf", ".", "cholesky", "(", "Kmm", ")", "# M x M", "\n", "\n", "# Compute the projection matrix A", "\n", "A_M_SN", "=", "tf", ".", "matrix_triangular_solve", "(", "Lm", ",", "Kmn_M_SN", ",", "lower", "=", "True", ")", "\n", "A", "=", "tf", ".", "transpose", "(", "tf", ".", "reshape", "(", "A_M_SN", ",", "[", "M", ",", "S", ",", "N", "]", ")", ",", "[", "1", ",", "0", ",", "2", "]", ")", "# S x M x N", "\n", "\n", "# compute the covariance due to the conditioning", "\n", "if", "full_cov", ":", "\n", "        ", "fvar", "=", "Knn", "-", "tf", ".", "matmul", "(", "A", ",", "A", ",", "transpose_a", "=", "True", ")", "# S x N x N", "\n", "fvar", "=", "tf", ".", "tile", "(", "fvar", "[", ":", ",", "None", ",", ":", ",", ":", "]", ",", "[", "1", ",", "num_func", ",", "1", ",", "1", "]", ")", "# S x R x N x N", "\n", "", "else", ":", "\n", "        ", "fvar", "=", "Knn", "-", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "A", ")", ",", "-", "2", ")", "# S x N", "\n", "fvar", "=", "tf", ".", "tile", "(", "fvar", "[", ":", ",", "None", ",", ":", "]", ",", "[", "1", ",", "num_func", ",", "1", "]", ")", "# S x R x N", "\n", "\n", "# another backsubstitution in the unwhitened case", "\n", "", "if", "not", "white", ":", "\n", "        ", "A_M_SN", "=", "tf", ".", "matrix_triangular_solve", "(", "tf", ".", "transpose", "(", "Lm", ")", ",", "A_M_SN", ",", "lower", "=", "False", ")", "\n", "A", "=", "tf", ".", "transpose", "(", "tf", ".", "reshape", "(", "A_M_SN", ",", "[", "M", ",", "S", ",", "N", "]", ")", ",", "[", "1", ",", "0", ",", "2", "]", ")", "# S x M x N", "\n", "\n", "# construct the conditional mean", "\n", "", "fmean", "=", "tf", ".", "matmul", "(", "A", ",", "tf", ".", "tile", "(", "f", "[", "None", ",", ":", ",", ":", "]", ",", "[", "S", ",", "1", ",", "1", "]", ")", ",", "transpose_a", "=", "True", ")", "# S x N x R", "\n", "# fmean = tf.einsum('snm,nr->smr', A, f)  # S x N x R", "\n", "\n", "if", "q_sqrt", "is", "not", "None", ":", "\n", "        ", "if", "q_sqrt", ".", "get_shape", "(", ")", ".", "ndims", "==", "2", ":", "\n", "            ", "LTA", "=", "A", "[", ":", ",", "None", ",", ":", ",", ":", "]", "*", "tf", ".", "transpose", "(", "q_sqrt", ")", "[", "None", ",", ":", ",", ":", ",", "None", "]", "# S x R x M x N", "\n", "", "elif", "q_sqrt", ".", "get_shape", "(", ")", ".", "ndims", "==", "3", ":", "\n", "# L = tf.tile(tf.matrix_band_part(q_sqrt, -1, 0)[None, :, :, :], [S, 1, 1, 1])  # S x R x M x M", "\n", "# A_tiled = tf.tile(tf.expand_dims(A, 1), tf.stack([1, num_func, 1, 1]))  # S x R x M x N", "\n", "# LTA = tf.matmul(L, A_tiled, transpose_a=True)  # S x R x M x N", "\n", "\n", "            ", "LTA", "=", "tf", ".", "einsum", "(", "'rMm,sMn->srmn'", ",", "tf", ".", "matrix_band_part", "(", "q_sqrt", ",", "-", "1", ",", "0", ")", ",", "A", ")", "\n", "", "else", ":", "# pragma: no cover", "\n", "            ", "raise", "ValueError", "(", "\"Bad dimension for q_sqrt: %s\"", "%", "\n", "str", "(", "q_sqrt", ".", "get_shape", "(", ")", ".", "ndims", ")", ")", "\n", "", "if", "full_cov", ":", "\n", "            ", "fvar", "=", "fvar", "+", "tf", ".", "matmul", "(", "LTA", ",", "LTA", ",", "transpose_a", "=", "True", ")", "# S x R x N x N", "\n", "", "else", ":", "\n", "            ", "fvar", "=", "fvar", "+", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "LTA", ")", ",", "2", ")", "# S x R x N", "\n", "\n", "\n", "", "", "if", "not", "full_cov", ":", "\n", "        ", "z", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "fmean", ")", ",", "dtype", "=", "settings", ".", "float_type", ")", "\n", "fvar", "=", "tf", ".", "matrix_transpose", "(", "fvar", ")", "# S x N x R", "\n", "sample", "=", "fmean", "+", "z", "*", "fvar", "**", "0.5", "\n", "", "else", ":", "\n", "        ", "fmean_SRN1", "=", "tf", ".", "transpose", "(", "fmean", ",", "[", "0", ",", "2", ",", "1", "]", ")", "[", ":", ",", ":", ",", ":", ",", "None", "]", "\n", "z", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "fmean_SRN1", ")", ",", "dtype", "=", "settings", ".", "float_type", ")", "\n", "sample_SRN1", "=", "fmean", "+", "tf", ".", "matmul", "(", "tf", ".", "cholesky", "(", "fvar", ")", ",", "z", ")", "\n", "sample", "=", "tf", ".", "transpose", "(", "sample_SRN1", "[", ":", ",", ":", ",", ":", ",", "0", "]", ",", "[", "0", ",", "2", ",", "1", "]", ")", "\n", "\n", "", "return", "sample", ",", "fmean", ",", "fvar", "# fmean is S x N x R, fvar is S x R x N x N or S x N x R", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.multisample_sample_conditional": [[119, 163], ["isinstance", "isinstance", "temp_workaround.independent_multisample_sample_conditional", "tensorflow.ones", "gpflow.conditionals.sample_conditional", "gpflow.params_as_tensors_for", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "isinstance", "temp_workaround.independent_multisample_sample_conditional", "gpflow.conditionals.sample_conditional", "Xnew.get_shape", "Xnew.get_shape", "tensorflow.shape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.independent_multisample_sample_conditional", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.independent_multisample_sample_conditional"], ["", "", "def", "multisample_sample_conditional", "(", "Xnew", ":", "tf", ".", "Tensor", ",", "feat", ":", "InducingPoints", ",", "kern", ":", "Kernel", ",", "f", ":", "tf", ".", "Tensor", ",", "*", ",", "\n", "full_cov", "=", "False", ",", "\n", "full_output_cov", "=", "False", ",", "\n", "q_sqrt", "=", "None", ",", "\n", "white", "=", "False", ")", ":", "\n", "    ", "if", "isinstance", "(", "kern", ",", "SharedMixedMok", ")", "and", "isinstance", "(", "feat", ",", "MixedKernelSharedMof", ")", ":", "\n", "        ", "if", "Xnew", ".", "get_shape", "(", ")", ".", "ndims", "==", "3", ":", "\n", "            ", "sample", ",", "gmean", ",", "gvar", "=", "independent_multisample_sample_conditional", "(", "Xnew", ",", "feat", ".", "feat", ",", "kern", ".", "kernel", ",", "f", ",", "\n", "white", "=", "white", ",", "\n", "q_sqrt", "=", "q_sqrt", ",", "\n", "full_output_cov", "=", "False", ",", "\n", "full_cov", "=", "False", ")", "# N x L, N x L", "\n", "\n", "o", "=", "tf", ".", "ones", "(", "(", "[", "tf", ".", "shape", "(", "Xnew", ")", "[", "0", "]", ",", "1", ",", "1", "]", ")", ",", "dtype", "=", "settings", ".", "float_type", ")", "\n", "\n", "", "else", ":", "\n", "            ", "sample", ",", "gmean", ",", "gvar", "=", "sample_conditional", "(", "Xnew", ",", "feat", ".", "feat", ",", "kern", ".", "kernel", ",", "f", ",", "\n", "white", "=", "white", ",", "\n", "q_sqrt", "=", "q_sqrt", ",", "\n", "full_output_cov", "=", "False", ",", "\n", "full_cov", "=", "False", ")", "# N x L, N x L", "\n", "\n", "o", "=", "1.", "\n", "\n", "", "with", "params_as_tensors_for", "(", "kern", ")", ":", "\n", "            ", "f_sample", "=", "tf", ".", "matmul", "(", "sample", ",", "o", "*", "kern", ".", "W", ",", "transpose_b", "=", "True", ")", "\n", "f_mu", "=", "tf", ".", "matmul", "(", "gmean", ",", "o", "*", "kern", ".", "W", ",", "transpose_b", "=", "True", ")", "\n", "f_var", "=", "tf", ".", "matmul", "(", "gvar", ",", "o", "*", "kern", ".", "W", "**", "2", ",", "transpose_b", "=", "True", ")", "\n", "\n", "", "return", "f_sample", ",", "f_mu", ",", "f_var", "\n", "", "else", ":", "\n", "        ", "assert", "not", "isinstance", "(", "kern", ",", "Mok", ")", "\n", "if", "Xnew", ".", "get_shape", "(", ")", ".", "ndims", "==", "3", ":", "\n", "            ", "return", "independent_multisample_sample_conditional", "(", "Xnew", ",", "feat", ",", "kern", ",", "f", ",", "\n", "full_cov", "=", "full_cov", ",", "\n", "full_output_cov", "=", "full_output_cov", ",", "\n", "q_sqrt", "=", "q_sqrt", ",", "\n", "white", "=", "white", ")", "\n", "", "else", ":", "\n", "            ", "return", "sample_conditional", "(", "Xnew", ",", "feat", ",", "kern", ",", "f", ",", "\n", "full_cov", "=", "full_cov", ",", "\n", "full_output_cov", "=", "full_output_cov", ",", "\n", "q_sqrt", "=", "q_sqrt", ",", "\n", "white", "=", "white", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.gauss_kl": [[168, 190], ["tensorflow.eye", "gpflow.kullback_leiblers.gauss_kl", "tensorflow.cholesky", "tensorflow.reduce_sum", "tensorflow.shape", "tensorflow.shape", "gpflow.logdensities.multivariate_normal", "tensorflow.zeros_like"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.gauss_kl"], ["def", "gauss_kl", "(", "q_mu", ",", "q_sqrt", ",", "K", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Wrapper for gauss_kl from gpflow that returns the negative log prob if q_sqrt is None. This can be  \n    for use in HMC: all that is required is to set q_sqrt to None and this function substitues the\n    negative log prob instead of the KL (so no need to set q_mu.prior = gpflow.priors.Gaussian(0, 1)). \n    Also, this allows the use of HMC in the unwhitened case. \n    \"\"\"", "\n", "if", "q_sqrt", "is", "None", ":", "\n", "# return negative log prob with q_mu as 'x', with mean 0 and cov K (or I, if None)", "\n", "        ", "M", ",", "D", "=", "tf", ".", "shape", "(", "q_mu", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "q_mu", ")", "[", "1", "]", "\n", "I", "=", "tf", ".", "eye", "(", "M", ",", "dtype", "=", "settings", ".", "float_type", ")", "\n", "\n", "if", "K", "is", "None", ":", "\n", "            ", "L", "=", "I", "\n", "", "else", ":", "\n", "            ", "L", "=", "tf", ".", "cholesky", "(", "K", "+", "I", "*", "settings", ".", "jitter", ")", "\n", "\n", "", "return", "-", "tf", ".", "reduce_sum", "(", "multivariate_normal", "(", "q_mu", ",", "tf", ".", "zeros_like", "(", "q_mu", ")", ",", "L", ")", ")", "\n", "\n", "", "else", ":", "\n", "# return kl", "\n", "        ", "return", "gauss_kl_gpflow", "(", "q_mu", ",", "q_sqrt", ",", "K", "=", "K", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.__init__": [[10, 18], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "vars", ",", "hyper_train_op", ",", "window_size", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "hyper_train_op", "=", "hyper_train_op", "\n", "self", ".", "vars", "=", "vars", "\n", "self", ".", "window_size", "=", "window_size", "\n", "self", ".", "window", "=", "[", "]", "\n", "self", ".", "sample_op", "=", "None", "\n", "self", ".", "burn_in_op", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.generate_update_step": [[19, 56], ["tensorflow.gradients", "zip", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "burn_in_updates.append", "burn_in_updates.append", "burn_in_updates.append", "tensorflow.sqrt", "sample_updates.append", "sample_updates.append", "tensorflow.assign", "tensorflow.assign", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.zeros_like", "tensorflow.sqrt", "tensorflow.maximum", "tensorflow.random_normal", "tensorflow.sqrt", "tensorflow.cast", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "generate_update_step", "(", "self", ",", "epsilon", ",", "mdecay", ")", ":", "\n", "        ", "nll", "=", "-", "self", ".", "model", ".", "likelihood_tensor", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "burn_in_updates", "=", "[", "]", "\n", "sample_updates", "=", "[", "]", "\n", "\n", "grads", "=", "tf", ".", "gradients", "(", "nll", ",", "self", ".", "vars", ")", "\n", "\n", "for", "theta", ",", "grad", "in", "zip", "(", "self", ".", "vars", ",", "grads", ")", ":", "\n", "            ", "xi", "=", "tf", ".", "Variable", "(", "tf", ".", "ones_like", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "g", "=", "tf", ".", "Variable", "(", "tf", ".", "ones_like", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "g2", "=", "tf", ".", "Variable", "(", "tf", ".", "ones_like", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "p", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros_like", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ")", "\n", "\n", "r_t", "=", "1.", "/", "(", "xi", "+", "1.", ")", "\n", "g_t", "=", "(", "1.", "-", "r_t", ")", "*", "g", "+", "r_t", "*", "grad", "\n", "g2_t", "=", "(", "1.", "-", "r_t", ")", "*", "g2", "+", "r_t", "*", "grad", "**", "2", "\n", "xi_t", "=", "1.", "+", "xi", "*", "(", "1.", "-", "g", "*", "g", "/", "(", "g2", "+", "1e-16", ")", ")", "\n", "Minv", "=", "1.", "/", "(", "tf", ".", "sqrt", "(", "g2", "+", "1e-16", ")", "+", "1e-16", ")", "\n", "\n", "burn_in_updates", ".", "append", "(", "(", "xi", ",", "xi_t", ")", ")", "\n", "burn_in_updates", ".", "append", "(", "(", "g", ",", "g_t", ")", ")", "\n", "burn_in_updates", ".", "append", "(", "(", "g2", ",", "g2_t", ")", ")", "\n", "\n", "epsilon_scaled", "=", "epsilon", "/", "tf", ".", "sqrt", "(", "tf", ".", "cast", "(", "self", ".", "model", ".", "num_data", ",", "tf", ".", "float64", ")", ")", "\n", "noise_scale", "=", "2.", "*", "epsilon_scaled", "**", "2", "*", "mdecay", "*", "Minv", "\n", "sigma", "=", "tf", ".", "sqrt", "(", "tf", ".", "maximum", "(", "noise_scale", ",", "1e-16", ")", ")", "\n", "sample_t", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "theta", ")", ",", "dtype", "=", "tf", ".", "float64", ")", "*", "sigma", "\n", "p_t", "=", "p", "-", "epsilon", "**", "2", "*", "grad", "-", "mdecay", "*", "p", "+", "sample_t", "\n", "theta_t", "=", "theta", "+", "p_t", "\n", "# h = ", "\n", "\n", "sample_updates", ".", "append", "(", "(", "theta", ",", "theta_t", ")", ")", "\n", "sample_updates", ".", "append", "(", "(", "p", ",", "p_t", ")", ")", "\n", "\n", "", "self", ".", "sample_op", "=", "[", "tf", ".", "assign", "(", "var", ",", "var_t", ")", "for", "var", ",", "var_t", "in", "sample_updates", "]", "\n", "self", ".", "burn_in_op", "=", "[", "tf", ".", "assign", "(", "var", ",", "var_t", ")", "for", "var", ",", "var_t", "in", "burn_in_updates", "+", "sample_updates", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.collect_samples": [[57, 69], ["range", "range", "session.run", "zip", "posterior_samples.append", "session.run"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "collect_samples", "(", "self", ",", "session", ",", "num", ",", "spacing", "=", "50", ")", ":", "\n", "        ", "posterior_samples", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "spacing", ")", ":", "\n", "                ", "session", ".", "run", "(", "(", "self", ".", "sample_op", ")", ")", "\n", "\n", "", "values", "=", "session", ".", "run", "(", "(", "self", ".", "vars", ")", ")", "\n", "sample", "=", "{", "}", "\n", "for", "var", ",", "value", "in", "zip", "(", "self", ".", "vars", ",", "values", ")", ":", "\n", "                ", "sample", "[", "var", "]", "=", "value", "\n", "", "posterior_samples", ".", "append", "(", "sample", ")", "\n", "", "return", "posterior_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.sghmc_step": [[70, 79], ["session.run", "session.run", "zip", "sghmc.SGHMC.window.append", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["", "def", "sghmc_step", "(", "self", ",", "session", ")", ":", "\n", "        ", "session", ".", "run", "(", "self", ".", "burn_in_op", ")", "\n", "values", "=", "session", ".", "run", "(", "(", "self", ".", "vars", ")", ")", "\n", "sample", "=", "{", "}", "\n", "for", "var", ",", "value", "in", "zip", "(", "self", ".", "vars", ",", "values", ")", ":", "\n", "            ", "sample", "[", "var", "]", "=", "value", "\n", "", "self", ".", "window", ".", "append", "(", "sample", ")", "\n", "if", "len", "(", "self", ".", "window", ")", ">", "self", ".", "window_size", ":", "\n", "            ", "self", ".", "window", "=", "self", ".", "window", "[", "-", "self", ".", "window_size", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.sghmc.SGHMC.train_hypers": [[80, 85], ["numpy.random.randint", "feed_dict.update", "session.run", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.gpy_regression.GPyRegression.update", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "", "def", "train_hypers", "(", "self", ",", "session", ")", ":", "\n", "        ", "feed_dict", "=", "{", "}", "\n", "i", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "self", ".", "window", ")", ")", "\n", "feed_dict", ".", "update", "(", "self", ".", "window", "[", "i", "]", ")", "\n", "session", ".", "run", "(", "self", ".", "hyper_train_op", ",", "feed_dict", "=", "feed_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.GPLayer.__init__": [[16, 33], ["gpflow.Parameterized.__init__", "len", "numpy.zeros", "gpflow.params.Parameter", "numpy.tile", "gpflow.transforms.LowerTriangular", "gpflow.params.Parameter", "isinstance", "gpflow.features.InducingPoints", "gpflow.mean_functions.Zero", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "kern", ",", "Z", ",", "num_outputs", ",", "mean_function", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "gpflow", ".", "Parameterized", ".", "__init__", "(", "self", ",", "name", "=", "name", ")", "\n", "\n", "self", ".", "num_inducing", "=", "len", "(", "Z", ")", "\n", "\n", "q_mu", "=", "np", ".", "zeros", "(", "(", "self", ".", "num_inducing", ",", "num_outputs", ")", ")", "\n", "self", ".", "q_mu", "=", "gpflow", ".", "params", ".", "Parameter", "(", "q_mu", ")", "\n", "\n", "q_sqrt", "=", "np", ".", "tile", "(", "np", ".", "eye", "(", "self", ".", "num_inducing", ")", "[", "None", ",", ":", ",", ":", "]", ",", "[", "num_outputs", ",", "1", ",", "1", "]", ")", "\n", "transform", "=", "gpflow", ".", "transforms", ".", "LowerTriangular", "(", "self", ".", "num_inducing", ",", "num_matrices", "=", "num_outputs", ")", "\n", "self", ".", "q_sqrt", "=", "gpflow", ".", "params", ".", "Parameter", "(", "q_sqrt", ",", "transform", "=", "transform", ")", "\n", "\n", "self", ".", "feature", "=", "Z", "if", "isinstance", "(", "Z", ",", "gpflow", ".", "features", ".", "InducingFeature", ")", "else", "gpflow", ".", "features", ".", "InducingPoints", "(", "Z", ")", "\n", "self", ".", "kern", "=", "kern", "\n", "self", ".", "mean_function", "=", "mean_function", "or", "gpflow", ".", "mean_functions", ".", "Zero", "(", ")", "\n", "\n", "self", ".", "num_outputs", "=", "num_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.GPLayer.propagate": [[34, 51], ["elfi.methods.bo.iwvi.temp_workaround.multisample_sample_conditional", "elfi.methods.bo.iwvi.temp_workaround.gauss_kl", "layers.GPLayer.mean_function"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.multisample_sample_conditional", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.temp_workaround.gauss_kl"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "def", "propagate", "(", "self", ",", "F", ",", "full_cov", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "samples", ",", "mean", ",", "cov", "=", "multisample_sample_conditional", "(", "F", ",", "\n", "self", ".", "feature", ",", "\n", "self", ".", "kern", ",", "\n", "self", ".", "q_mu", ",", "\n", "full_cov", "=", "full_cov", ",", "\n", "q_sqrt", "=", "self", ".", "q_sqrt", ",", "\n", "white", "=", "True", ")", "\n", "\n", "kl", "=", "gauss_kl", "(", "self", ".", "q_mu", ",", "self", ".", "q_sqrt", ")", "\n", "\n", "mf", "=", "self", ".", "mean_function", "(", "F", ")", "\n", "samples", "+=", "mf", "\n", "mean", "+=", "mf", "\n", "\n", "return", "samples", ",", "mean", ",", "cov", ",", "kl", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.__init__": [[55, 70], ["gpflow.Parameterized.__init__", "tensorflow.ones", "tensorflow.zeros", "tensorflow.placeholder_with_default", "tensorflow.placeholder_with_default", "layers.Encoder"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__"], ["def", "__init__", "(", "self", ",", "latent_dim", ",", "XY_dim", "=", "None", ",", "encoder", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "gpflow", ".", "Parameterized", ".", "__init__", "(", "self", ",", "name", "=", "name", ")", "\n", "\n", "self", ".", "latent_dim", "=", "latent_dim", "\n", "\n", "# placeholders with default, where the default is the prior", "\n", "ones", "=", "tf", ".", "ones", "(", "[", "1", ",", "1", "]", ",", "dtype", "=", "gpflow", ".", "settings", ".", "float_type", ")", "\n", "zeros", "=", "tf", ".", "zeros", "(", "[", "1", ",", "1", "]", ",", "dtype", "=", "gpflow", ".", "settings", ".", "float_type", ")", "\n", "self", ".", "q_mu_placeholder", "=", "tf", ".", "placeholder_with_default", "(", "zeros", ",", "[", "None", ",", "None", "]", ")", "\n", "self", ".", "q_sqrt_placeholder", "=", "tf", ".", "placeholder_with_default", "(", "ones", ",", "[", "None", ",", "None", "]", ")", "\n", "\n", "if", "encoder", "is", "None", ":", "\n", "            ", "assert", "XY_dim", ",", "'must pass XY_dim or else an encoder'", "\n", "encoder", "=", "Encoder", "(", "latent_dim", ",", "XY_dim", ",", "[", "20", ",", "20", "]", ")", "\n", "", "self", ".", "encoder", "=", "encoder", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.LatentVariableLayer.propagate": [[71, 106], ["tensorflow.random_normal", "tensorflow.concat", "tensorflow.concat", "tensorflow.concat", "tensorflow.contrib.distributions.Normal", "tensorflow.contrib.distributions.Normal", "tensorflow.concat", "tensorflow.ones", "layers.LatentVariableLayer.encoder", "tensorflow.shape", "tensorflow.cast", "tensorflow.contrib.distributions.kl_divergence", "tensorflow.zeros_like", "tensorflow.contrib.distributions.Normal.log_prob", "tensorflow.contrib.distributions.Normal.log_prob", "tensorflow.shape"], "methods", ["None"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "def", "propagate", "(", "self", ",", "F", ",", "inference_amorization_inputs", "=", "None", ",", "is_sampled_local_regularizer", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "inference_amorization_inputs", "is", "None", ":", "\n", "            ", "\"\"\"\n            If there isn't an X and Y passed for the recognition model, this samples from the prior.\n            Optionally, q_mu and q_sqrt can be fed via a placeholder (e.g. for plotting purposes)\n            \"\"\"", "\n", "shape", "=", "tf", ".", "concat", "(", "[", "tf", ".", "shape", "(", "F", ")", "[", ":", "-", "1", "]", ",", "[", "self", ".", "latent_dim", "]", "]", ",", "0", ")", "\n", "ones", "=", "tf", ".", "ones", "(", "shape", ",", "dtype", "=", "gpflow", ".", "settings", ".", "float_type", ")", "\n", "q_mu", "=", "self", ".", "q_mu_placeholder", "*", "ones", "# TODO tf.broadcast_to", "\n", "q_sqrt", "=", "self", ".", "q_sqrt_placeholder", "*", "ones", "# TODO tf.broadcast_to", "\n", "", "else", ":", "\n", "            ", "q_mu", ",", "q_sqrt", "=", "self", ".", "encoder", "(", "inference_amorization_inputs", ")", "\n", "\n", "# reparameterization trick to take a sample for W", "\n", "", "z", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "q_mu", ")", ",", "dtype", "=", "gpflow", ".", "settings", ".", "float_type", ")", "\n", "W", "=", "q_mu", "+", "z", "*", "q_sqrt", "\n", "\n", "samples", "=", "tf", ".", "concat", "(", "[", "F", ",", "W", "]", ",", "-", "1", ")", "\n", "mean", "=", "tf", ".", "concat", "(", "[", "F", ",", "q_mu", "]", ",", "-", "1", ")", "\n", "cov", "=", "tf", ".", "concat", "(", "[", "tf", ".", "zeros_like", "(", "F", ")", ",", "q_sqrt", "**", "2", "]", ",", "-", "1", ")", "\n", "\n", "# the prior regularization", "\n", "zero", ",", "one", "=", "[", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "gpflow", ".", "settings", ".", "float_type", ")", "for", "x", "in", "[", "0", ",", "1", "]", "]", "\n", "p", "=", "tf", ".", "contrib", ".", "distributions", ".", "Normal", "(", "zero", ",", "one", ")", "\n", "q", "=", "tf", ".", "contrib", ".", "distributions", ".", "Normal", "(", "q_mu", ",", "q_sqrt", ")", "\n", "\n", "if", "is_sampled_local_regularizer", ":", "\n", "# for the IW models, we need to return a log q/p for each sample W", "\n", "            ", "kl", "=", "q", ".", "log_prob", "(", "W", ")", "-", "p", ".", "log_prob", "(", "W", ")", "\n", "", "else", ":", "\n", "# for the VI models, we want E_q log q/p, which is closed form for Gaussians", "\n", "            ", "kl", "=", "tf", ".", "contrib", ".", "distributions", ".", "kl_divergence", "(", "q", ",", "p", ")", "\n", "\n", "", "return", "samples", ",", "mean", ",", "cov", ",", "kl", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__": [[109, 135], ["gpflow.Parameterized.__init__", "zip", "Ws.append", "bs.append", "gpflow.params.ParamList", "gpflow.params.ParamList", "numpy.random.randn", "gpflow.Param", "gpflow.Param", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__init__", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.elfi.store.NpyArray.append"], ["    ", "def", "__init__", "(", "self", ",", "latent_dim", ",", "input_dim", ",", "network_dims", ",", "activation_func", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Encoder that uses GPflow params to encode the features.\n        Creates an MLP with input dimensions `input_dim` and produces\n        2 * `latent_dim` outputs.\n        :param latent_dim: dimension of the latent variable\n        :param input_dim: the MLP acts on data of `input_dim` dimensions\n        :param network_dims: dimensions of inner MLPs, e.g. [10, 20, 10]\n        :param activation_func: TensorFlow operation that can be used\n            as non-linearity between the layers (default: tanh).\n        \"\"\"", "\n", "gpflow", ".", "Parameterized", ".", "__init__", "(", "self", ",", "name", "=", "name", ")", "\n", "self", ".", "latent_dim", "=", "latent_dim", "\n", "self", ".", "activation_func", "=", "activation_func", "or", "tf", ".", "nn", ".", "tanh", "\n", "\n", "self", ".", "layer_dims", "=", "[", "input_dim", ",", "*", "network_dims", ",", "latent_dim", "*", "2", "]", "\n", "\n", "Ws", ",", "bs", "=", "[", "]", ",", "[", "]", "\n", "\n", "for", "input_dim", ",", "output_dim", "in", "zip", "(", "self", ".", "layer_dims", "[", ":", "-", "1", "]", ",", "self", ".", "layer_dims", "[", "1", ":", "]", ")", ":", "\n", "            ", "xavier_std", "=", "(", "2.", "/", "(", "input_dim", "+", "output_dim", ")", ")", "**", "0.5", "\n", "W", "=", "np", ".", "random", ".", "randn", "(", "input_dim", ",", "output_dim", ")", "*", "xavier_std", "\n", "Ws", ".", "append", "(", "gpflow", ".", "Param", "(", "W", ")", ")", "\n", "bs", ".", "append", "(", "gpflow", ".", "Param", "(", "np", ".", "zeros", "(", "output_dim", ")", ")", ")", "\n", "\n", "", "self", ".", "Ws", ",", "self", ".", "bs", "=", "gpflow", ".", "params", ".", "ParamList", "(", "Ws", ")", ",", "gpflow", ".", "params", ".", "ParamList", "(", "bs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.iwvi.layers.Encoder.__call__": [[136, 153], ["enumerate", "tensorflow.split", "tensorflow.nn.softplus", "tensorflow.ones_like", "zip", "tensorflow.identity", "tensorflow.matmul", "layers.Encoder.activation_func", "len"], "methods", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.bdm_dgp.bdm_simulator.identity"], ["", "@", "gpflow", ".", "params_as_tensors", "\n", "def", "__call__", "(", "self", ",", "Z", ")", ":", "\n", "        ", "o", "=", "tf", ".", "ones_like", "(", "Z", ")", "[", "...", ",", ":", "1", ",", ":", "1", "]", "# for correct broadcasting", "\n", "for", "i", ",", "(", "W", ",", "b", ",", "dim_in", ",", "dim_out", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "Ws", ",", "self", ".", "bs", ",", "self", ".", "layer_dims", "[", ":", "-", "1", "]", ",", "self", ".", "layer_dims", "[", "1", ":", "]", ")", ")", ":", "\n", "            ", "Z0", "=", "tf", ".", "identity", "(", "Z", ")", "\n", "Z", "=", "tf", ".", "matmul", "(", "Z", ",", "o", "*", "W", ")", "+", "o", "*", "b", "\n", "\n", "if", "i", "<", "len", "(", "self", ".", "bs", ")", "-", "1", ":", "\n", "                ", "Z", "=", "self", ".", "activation_func", "(", "Z", ")", "\n", "\n", "", "if", "dim_out", "==", "dim_in", ":", "# skip connection", "\n", "                ", "Z", "+=", "Z0", "\n", "\n", "", "", "means", ",", "log_chol_diag", "=", "tf", ".", "split", "(", "Z", ",", "2", ",", "axis", "=", "-", "1", ")", "\n", "q_sqrt", "=", "tf", ".", "nn", ".", "softplus", "(", "log_chol_diag", "-", "3.", ")", "# bias it towards small vals at first", "\n", "q_mu", "=", "means", "\n", "return", "q_mu", ",", "q_sqrt", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernels.sqdist_gramix": [[11, 41], ["numpy.dot", "numpy.sum", "numpy.sum", "numpy.atleast_2d", "numpy.atleast_2d", "z_q.transpose"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["def", "sqdist_gramix", "(", "x_p", ",", "x_q", ",", "length_scale", ")", ":", "\n", "    ", "\"\"\"\n    Compute a gram matrix of euclidean distances between two datasets under an isotropic or anisotropic length scale.\n    \n    Parameters\n    ----------\n    x_p : np.ndarray [Size: (n_p, d)]\n        A dataset\n    x_q : np.ndarray [Size: (n_q, d)]\n        A dataset\n    length_scale : float or np.ndarray [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The length scale(s)\n        \n    Returns\n    -------\n    np.ndarray [Size: (n_p, n_q)]\n        The resulting gram matrix\n    \"\"\"", "\n", "# Size: (n_p, d)", "\n", "z_p", "=", "np", ".", "atleast_2d", "(", "x_p", ")", "/", "length_scale", "\n", "# Size: (n_q, d)", "\n", "z_q", "=", "np", ".", "atleast_2d", "(", "x_q", ")", "/", "length_scale", "\n", "# Size: (n_p, n_q)", "\n", "d_pq", "=", "np", ".", "dot", "(", "z_p", ",", "z_q", ".", "transpose", "(", ")", ")", "\n", "# Size: (n_p,)", "\n", "d_p", "=", "np", ".", "sum", "(", "z_p", "**", "2", ",", "axis", "=", "1", ")", "\n", "# Size: (n_q,)", "\n", "d_q", "=", "np", ".", "sum", "(", "z_q", "**", "2", ",", "axis", "=", "1", ")", "\n", "# Size: (n_p, n_q)", "\n", "return", "d_p", "[", ":", ",", "np", ".", "newaxis", "]", "-", "2", "*", "d_pq", "+", "d_q", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernels.gaussian_kernel_gramix": [[43, 63], ["numpy.exp", "kernels.sqdist_gramix"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.sqdist_gramix"], ["", "def", "gaussian_kernel_gramix", "(", "x_p", ",", "x_q", ",", "length_scale", ")", ":", "\n", "    ", "\"\"\"\n    Compute a gram matrix of Gaussian kernel values between two datasets under an isotropic or anisotropic length scale.\n    \n    Parameters\n    ----------\n    x_p : np.ndarray [Size: (n_p, d)]\n        A dataset\n    x_q : np.ndarray [Size: (n_q, d)]\n        A dataset\n    length_scale : float or np.ndarray [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The length scale(s)\n        \n    Returns\n    -------\n    np.ndarray [Size: (n_p, n_q)]\n        The resulting gram matrix\n    \"\"\"", "\n", "# Size: (n_p, n_q)", "\n", "return", "np", ".", "exp", "(", "-", "0.5", "*", "sqdist_gramix", "(", "x_p", ",", "x_q", ",", "length_scale", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernels.convert_anisotropic": [[65, 92], ["numpy.atleast_1d", "numpy.repeat"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_1d"], ["", "def", "convert_anisotropic", "(", "length_scale", ",", "d", ")", ":", "\n", "    ", "\"\"\"\n    Convert isotropic length scale format to anisotropic length scale format.\n    \n    Parameters\n    ----------\n    length_scale : float or np.ndarray [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The length scale(s)\n    d : int\n        The dimensionality of the anisotropic kernel\n    \n    Returns\n    -------\n    np.ndarray [Size: (d,)]\n        The anisotropic length scale(s)\n    \"\"\"", "\n", "# Size: (1,) or (d,)", "\n", "length_scale_array", "=", "np", ".", "atleast_1d", "(", "length_scale", ")", "\n", "# Make sure it is not more than 1 dimensional", "\n", "assert", "length_scale_array", ".", "ndim", "==", "1", "\n", "# Make sure it is either isotropic or anisotropic", "\n", "assert", "length_scale_array", ".", "shape", "[", "0", "]", "in", "[", "1", ",", "d", "]", "\n", "# Convert it to anistropic only if it is isotropic or keep it the same", "\n", "if", "length_scale_array", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "        ", "return", "np", ".", "repeat", "(", "length_scale_array", ",", "d", ")", "\n", "", "else", ":", "\n", "        ", "return", "length_scale_array", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernels.gaussian_density_gramix": [[94, 116], ["numpy.prod", "kernels.gaussian_kernel_gramix", "numpy.sqrt", "kernels.convert_anisotropic"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.convert_anisotropic"], ["", "", "def", "gaussian_density_gramix", "(", "x", ",", "mu", ",", "sigma", ")", ":", "\n", "    ", "\"\"\"\n    Compute a gram matrix of Gaussian density values of a dataset for multiple means.\n    Parameters\n    ----------\n    x : np.ndarray [Size: (n, d)]\n        A dataset\n    mu : np.ndarray [Size: (m, d)]\n        A dataset\n    sigma : float or np.ndarray [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The standard deviations(s)\n        \n    Returns\n    -------\n    np.ndarray [Size: (n, m)]\n        The resulting gram matrix\n    \"\"\"", "\n", "# Compute the scaling factor of a diagonal multivariate Gaussian distribution", "\n", "d", "=", "x", ".", "shape", "[", "-", "1", "]", "\n", "const", "=", "(", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", "**", "d", ")", "*", "np", ".", "prod", "(", "convert_anisotropic", "(", "sigma", ",", "d", ")", ")", "\n", "# Size: (n, m)", "\n", "return", "gaussian_kernel_gramix", "(", "x", ",", "mu", ",", "sigma", ")", "/", "const", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernels.gaussian_density_gramix_multiple": [[118, 153], ["numpy.atleast_2d", "numpy.reshape", "numpy.reshape", "kernels.gaussian_density_gramix", "numpy.reshape", "numpy.prod", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_density_gramix", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean"], ["", "def", "gaussian_density_gramix_multiple", "(", "x", ",", "mu", ",", "sigma", ")", ":", "\n", "    ", "\"\"\"\n    Compute the average gram matrix of Gaussian density values of a dataset for multiple arrays of means.\n    \n    Parameters\n    ----------\n    x : np.ndarray [Size: (r, n, d)]\n        A dataset\n    mu : np.ndarray [Size: (m, s, d)]\n        A dataset where the average is to be taken over the middle dimension (s)\n    sigma : float or np.ndarray [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The standard deviations(s)\n        \n    Returns\n    -------\n    np.ndarray [Size: (n, m)]\n        The resulting gram matrix\n    \"\"\"", "\n", "# Obtain and ensure the shape matches", "\n", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "r", ",", "n", ",", "d", "=", "x", ".", "shape", "\n", "m", ",", "s", ",", "d", "=", "mu", ".", "shape", "\n", "assert", "d", "==", "x", ".", "shape", "[", "-", "1", "]", "\n", "assert", "d", "==", "mu", ".", "shape", "[", "-", "1", "]", "\n", "# Size: (r * n, d)", "\n", "x_2d", "=", "np", ".", "reshape", "(", "x", ",", "(", "r", "*", "n", ",", "d", ")", ")", "\n", "# Size: (m * s, d)", "\n", "mu_2d", "=", "np", ".", "reshape", "(", "mu", ",", "(", "m", "*", "s", ",", "d", ")", ")", "\n", "# Size: (r * n, m * s)", "\n", "gramix_2d", "=", "gaussian_density_gramix", "(", "x_2d", ",", "mu_2d", ",", "sigma", ")", "\n", "# Size: (r, n, m, s)", "\n", "gramix_4d", "=", "np", ".", "reshape", "(", "gramix_2d", ",", "(", "r", ",", "n", ",", "m", ",", "s", ")", ")", "\n", "# Size: (n, m)", "\n", "# return np.mean(np.prod(gramix_4d, axis=1), axis=-1)", "\n", "return", "np", ".", "prod", "(", "np", ".", "mean", "(", "gramix_4d", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "1", ")", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.kernel_means_weights": [[11, 58], ["kelfi.kernels.gaussian_kernel_gramix", "scipy.cholesky", "scipy.cho_solve", "kelfi.kernels.gaussian_density_gramix_multiple().transpose", "kelfi.kernels.gaussian_density_gramix().transpose", "ValueError", "numpy.min", "kelfi.kernels.gaussian_density_gramix_multiple", "numpy.eye", "kelfi.kernels.gaussian_density_gramix"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_density_gramix_multiple", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_density_gramix"], ["def", "kernel_means_weights", "(", "y", ",", "x_sim", ",", "theta_sim", ",", "eps", ",", "beta", ",", "reg", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute the weights of the kernel means likelihood.\n    \n    Parameters\n    ----------\n    y : np.ndarray [size: (1, d)]\n        Observed data or summary statistics\n    x_sim : np.ndarray [size: (m, s, d)]\n        Simulated data or summary statistics\n    theta_sim : np.ndarray [size: (m, p)]\n        Parameter values corresponding to the simulations\n    eps : float or np.ndarray [size: () or (1,) for isotropic; (d,) for anistropic]\n        The simulator noise level(s) for the epsilon-kernel or epsilon-likelihood\n    beta : float or np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n    reg : float, optional\n        The regularization parameter for the conditional kernel mean\n        \n    Returns\n    -------\n    np.ndarray [size: (m, 1)]\n        The weights of the kernel means likelihood\n    \"\"\"", "\n", "# size: (m, 1)", "\n", "if", "x_sim", ".", "ndim", "==", "3", ":", "\n", "        ", "data_epsilon_likelihood", "=", "gaussian_density_gramix_multiple", "(", "y", ",", "x_sim", ",", "eps", ")", ".", "transpose", "(", ")", "\n", "", "elif", "x_sim", ".", "ndim", "==", "2", ":", "\n", "        ", "data_epsilon_likelihood", "=", "gaussian_density_gramix", "(", "y", ",", "x_sim", ",", "eps", ")", ".", "transpose", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Simulated dataset is neither 2D or 3D.'", ")", "\n", "\n", "# The number of simulations", "\n", "", "m", "=", "theta_sim", ".", "shape", "[", "0", "]", "\n", "\n", "# Set the regularization hyperparameter to some default value if not specified", "\n", "if", "reg", "is", "None", ":", "\n", "        ", "reg", "=", "1e-3", "*", "np", ".", "min", "(", "beta", ")", "\n", "\n", "# Compute the weights at O(m^3)", "\n", "", "theta_sim_gramix", "=", "gaussian_kernel_gramix", "(", "theta_sim", ",", "theta_sim", ",", "beta", ")", "\n", "lower", "=", "True", "\n", "theta_sim_gramix_cholesky", "=", "la", ".", "cholesky", "(", "theta_sim_gramix", "+", "m", "*", "reg", "*", "np", ".", "eye", "(", "m", ")", ",", "lower", "=", "lower", ")", "\n", "weights", "=", "la", ".", "cho_solve", "(", "(", "theta_sim_gramix_cholesky", ",", "lower", ")", ",", "data_epsilon_likelihood", ")", "\n", "\n", "# size: (m, 1)", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.kernel_means_likelihood": [[60, 85], ["kelfi.kernels.gaussian_kernel_gramix", "numpy.dot().ravel", "numpy.dot", "kelfi.kernels.gaussian_kernel_gramix.transpose"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix"], ["", "def", "kernel_means_likelihood", "(", "theta_query", ",", "theta_sim", ",", "weights", ",", "beta", ")", ":", "\n", "    ", "\"\"\"\n    Query the kernel means likelihood.\n    \n    Parameters\n    ----------\n    theta_query : np.ndarray [size: (n_query, p)]\n        The parameters to query the likelihood at\n    theta_sim : np.ndarray [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : np.ndarray [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n        \n    Returns\n    -------\n    np.ndarray [size: (n_query,)]\n        The kernel means likelihood values at the query points\n    \"\"\"", "\n", "# size: (m, n_query)", "\n", "theta_evaluation_gramix", "=", "gaussian_kernel_gramix", "(", "theta_sim", ",", "theta_query", ",", "beta", ")", "\n", "\n", "# size: (n_query,)", "\n", "return", "np", ".", "dot", "(", "theta_evaluation_gramix", ".", "transpose", "(", ")", ",", "weights", ")", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.marginal_kernel_means_likelihood": [[87, 126], ["numpy.sqrt", "numpy.prod", "numpy.dot", "numpy.zeros", "kelfi.kernels.convert_anisotropic", "kelfi.kernels.gaussian_kernel_gramix", "prior_mean_embedding.ravel", "weights.ravel", "numpy.atleast_2d"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.convert_anisotropic", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["", "def", "marginal_kernel_means_likelihood", "(", "theta_sim", ",", "weights", ",", "beta", ",", "prior_mean", "=", "None", ",", "prior_std", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute the marginal kernel means likelihood under a diagonal Gaussian prior.\n    \n    Parameters\n    ----------\n    theta_sim : np.ndarray [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : np.ndarray [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n    prior_mean : np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The mean(s) of the diagonal Gaussian prior\n    prior_std : np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The standard deviation(s) of the diagonal Gaussian prior\n        \n    Returns\n    -------\n    float\n        The marginal kernel means likelihood\n    \"\"\"", "\n", "# By defaut, the prior has zero mean", "\n", "if", "prior_mean", "is", "None", ":", "\n", "        ", "prior_mean", "=", "np", ".", "zeros", "(", "(", "1", ",", "theta_sim", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "\n", "# By default, the prior standard deviation is set to the same as the length scale of the parameter kernel", "\n", "", "if", "prior_std", "is", "None", ":", "\n", "        ", "prior_std", "=", "beta", "\n", "\n", "# Compute the final length scale and the ratio scalar coefficient of the resulting prior mean embedding ", "\n", "", "prior_embedding_length_scale", "=", "np", ".", "sqrt", "(", "beta", "**", "2", "+", "prior_std", "**", "2", ")", "\n", "ratio", "=", "np", ".", "prod", "(", "convert_anisotropic", "(", "beta", "/", "prior_embedding_length_scale", ",", "theta_sim", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "# Compute the prior mean embedding [size: (m, 1)]", "\n", "prior_mean_embedding", "=", "ratio", "*", "gaussian_kernel_gramix", "(", "theta_sim", ",", "np", ".", "atleast_2d", "(", "prior_mean", ")", ",", "prior_embedding_length_scale", ")", "\n", "\n", "# Compute the kernel means marginal likelihood", "\n", "return", "np", ".", "dot", "(", "prior_mean_embedding", ".", "ravel", "(", ")", ",", "weights", ".", "ravel", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.approximate_marginal_kernel_means_likelihood": [[128, 149], ["numpy.mean", "kernel_means_inference.kernel_means_likelihood"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.examples.lorenz.mean", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_likelihood"], ["", "def", "approximate_marginal_kernel_means_likelihood", "(", "theta_samples", ",", "theta_sim", ",", "weights", ",", "beta", ")", ":", "\n", "    ", "\"\"\"\n    Compute the approximate marginal kernel means likelihood using prior samples.\n    \n    Parameters\n    ----------\n    theta_samples : np.ndarray [size: (n_samples, p)]\n        The parameters samples to marginalize over\n    theta_sim : np.ndarray [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : np.ndarray [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n        \n    Returns\n    -------\n    float\n        The approximate marginal kernel means likelihood\n    \"\"\"", "\n", "return", "np", ".", "mean", "(", "kernel_means_likelihood", "(", "theta_samples", ",", "theta_sim", ",", "weights", ",", "beta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.kernel_means_posterior": [[151, 176], ["kernel_means_inference.kernel_means_likelihood", "prior_pdf().ravel", "prior_pdf"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_likelihood"], ["", "def", "kernel_means_posterior", "(", "theta_query", ",", "theta_sim", ",", "weights", ",", "beta", ",", "prior_pdf", ",", "marginal_likelihood", ")", ":", "\n", "    ", "\"\"\"\n    Query the kernel means posterior.\n    \n    Parameters\n    ----------\n    theta_query : np.ndarray [size: (n_query, p)]\n        The parameters to query the likelihood at\n    theta_sim : np.ndarray [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : np.ndarray [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n    prior_pdf : callable\n        The prior probability density function\n    marginal_likelihood: float\n        The pre-computed marginal kernel means likelihood\n        \n    Returns\n    -------\n    np.ndarray [size: (n_query,)]\n        The kernel means likelihood values at the query points\n    \"\"\"", "\n", "return", "kernel_means_likelihood", "(", "theta_query", ",", "theta_sim", ",", "weights", ",", "beta", ")", "*", "prior_pdf", "(", "theta_query", ")", ".", "ravel", "(", ")", "/", "marginal_likelihood", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.kernel_means_posterior_embedding": [[178, 234], ["kelfi.kernels.convert_anisotropic", "kelfi.kernels.convert_anisotropic", "numpy.prod", "numpy.zeros", "numpy.sqrt", "kernel_means_marginal_likelihood", "numpy.dot().ravel", "numpy.exp", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.convert_anisotropic", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.convert_anisotropic"], ["", "def", "kernel_means_posterior_embedding", "(", "theta_query", ",", "theta_sim", ",", "weights", ",", "beta", ",", "prior_mean", "=", "None", ",", "prior_std", "=", "None", ",", "marginal_likelihood", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute the kernel means posterior embedding.\n    \n    Parameters\n    ----------\n    theta_query : np.ndarray [size: (n_query, p)]\n        The parameters to query the likelihood at\n    theta_sim : np.ndarray [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : np.ndarray [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n    prior_mean : np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The mean(s) of the diagonal Gaussian prior\n    prior_std : np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The standard deviation(s) of the diagonal Gaussian prior\n    marginal_likelihood : float, optional\n        The marginal likelihood value if it was precomputed\n    \"\"\"", "\n", "# By defaut, the prior has zero mean", "\n", "if", "prior_mean", "is", "None", ":", "\n", "        ", "prior_mean", "=", "np", ".", "zeros", "(", "(", "1", ",", "theta_sim", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "\n", "# By default, the prior standard deviation is set to the same as the length scale of the parameter kernel", "\n", "# Compute the final length scale of the resulting prior mean embedding", "\n", "", "if", "prior_std", "is", "None", ":", "\n", "        ", "prior_std", "=", "beta", "\n", "\n", "# Anisotropic constants", "\n", "", "sigma", "=", "convert_anisotropic", "(", "prior_std", ",", "theta_sim", ".", "shape", "[", "1", "]", ")", "\n", "s", "=", "1", "/", "np", ".", "sqrt", "(", "2", "/", "(", "beta", "**", "2", ")", "+", "1", "/", "(", "sigma", "**", "2", ")", ")", "\n", "gamma", "=", "convert_anisotropic", "(", "beta", "/", "sigma", ",", "theta_sim", ".", "shape", "[", "1", "]", ")", "\n", "denom", "=", "2", "+", "(", "gamma", "**", "2", ")", "\n", "\n", "# Broadcast: (m, d) -> (1, m, d)", "\n", "theta_sim_broad", "=", "theta_sim", "[", "np", ".", "newaxis", ",", ":", ",", ":", "]", "\n", "\n", "# Broadcast: (q, d) -> (q, 1, d)", "\n", "theta_query_broad", "=", "theta_query", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", "\n", "\n", "# Compute the quadratic term in the exponent with size: (q, m, d)", "\n", "first", "=", "theta_query_broad", "**", "2", "+", "theta_sim_broad", "**", "2", "+", "(", "gamma", "*", "prior_mean", ")", "**", "2", "\n", "second", "=", "theta_query_broad", "+", "theta_sim", "+", "gamma", "**", "2", "*", "prior_mean", "\n", "c", "=", "first", "/", "denom", "-", "(", "second", "/", "denom", ")", "**", "2", "\n", "\n", "# Perform the integral and multiple each dimension to get size: (q, m)", "\n", "h", "=", "np", ".", "prod", "(", "(", "s", "/", "sigma", ")", "*", "np", ".", "exp", "(", "-", "0.5", "*", "c", "/", "(", "s", "**", "2", ")", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "# Compute the marginal likelihood if it has not been computed already", "\n", "if", "marginal_likelihood", "is", "None", ":", "\n", "        ", "marginal_likelihood", "=", "kernel_means_marginal_likelihood", "(", "theta_sim", ",", "weights", ",", "beta", ",", "prior_mean", "=", "prior_mean", ",", "prior_std", "=", "prior_std", ")", "\n", "\n", "# size: (q,)", "\n", "", "return", "np", ".", "dot", "(", "h", ",", "weights", ")", ".", "ravel", "(", ")", "/", "marginal_likelihood", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.approximate_kernel_means_posterior_embedding": [[236, 266], ["numpy.dot", "kernel_means_inference.approximate_marginal_kernel_means_likelihood", "numpy.dot().ravel", "kelfi.kernels.gaussian_kernel_gramix", "kelfi.kernels.gaussian_kernel_gramix", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.approximate_marginal_kernel_means_likelihood", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix"], ["", "def", "approximate_kernel_means_posterior_embedding", "(", "theta_query", ",", "theta_sim", ",", "weights", ",", "beta", ",", "theta_samples", ",", "marginal_likelihood", "=", "None", ",", "beta_query", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute the approximate kernel means posterior embedding.\n    \n    Parameters\n    ----------\n    theta_query : np.ndarray [size: (n_query, p)]\n        The parameters to query the likelihood at\n    theta_sim : np.ndarray [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : np.ndarray [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n    theta_samples : np.ndarray [size: (n_samples, p)]\n        The parameters samples to marginalize over\n    marginal_likelihood : float, optional\n        The marginal likelihood value if it was precomputed\n    \"\"\"", "\n", "# Approximate the integral empirically with size: (q, m)", "\n", "if", "beta_query", "is", "None", ":", "\n", "        ", "beta_query", "=", "beta", "\n", "", "h", "=", "np", ".", "dot", "(", "gaussian_kernel_gramix", "(", "theta_query", ",", "theta_samples", ",", "beta_query", ")", ",", "gaussian_kernel_gramix", "(", "theta_samples", ",", "theta_sim", ",", "beta", ")", ")", "/", "theta_samples", ".", "shape", "[", "0", "]", "\n", "\n", "# Compute the marginal likelihood if it has not been computed already", "\n", "if", "marginal_likelihood", "is", "None", ":", "\n", "        ", "marginal_likelihood", "=", "approximate_marginal_kernel_means_likelihood", "(", "theta_samples", ",", "theta_sim", ",", "weights", ",", "beta", ")", "\n", "\n", "# size: (q,)", "\n", "", "return", "np", ".", "dot", "(", "h", ",", "weights", ")", ".", "ravel", "(", ")", "/", "marginal_likelihood", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_inference.kernel_herding": [[268, 310], ["range", "numpy.zeros", "type", "embedding_values_or_function", "kernel_function().ravel", "numpy.argmax", "kernel_function"], "function", ["None"], ["", "def", "kernel_herding", "(", "mean_embedding_values_or_function", ",", "kernel_function", ",", "samples", ",", "n_super_samples", ",", "init_super_samples", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Obtain super samples via kernel herding.\n    \n    Parameters\n    ----------\n    mean_embedding_values_or_function : callable or np.ndarray [size: (n_samples,)]\n        An mean embedding function of one argument or the mean embedding values queried at the samples\n    kernel_function : callable\n        A kernel function of two arguments on samples\n    samples : np.ndarray (n_samples, n_dim)\n        The original samples to samples from\n    n_super_samples : int\n        The number of super samples to obtain\n    init_super_samples : np.ndarray [size: (n_init_super_samples, n_dim)], optional\n        The super samples already obtained if one wants to continue sampling instead of restarting the herd\n    \"\"\"", "\n", "# Initialize the super samples", "\n", "if", "init_super_samples", "is", "None", ":", "\n", "        ", "n_init_super_samples", "=", "0", "\n", "super_samples", "=", "np", ".", "zeros", "(", "(", "n_super_samples", ",", "samples", ".", "shape", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "n_init_super_samples", "=", "init_super_samples", ".", "shape", "[", "0", "]", "\n", "super_samples", "[", ":", "n_init_super_samples", "]", "=", "init_super_samples", "\n", "\n", "# Obtain the mean embedding quried at the samples", "\n", "", "if", "type", "(", "mean_embedding_values_or_function", ")", "is", "callable", ":", "\n", "        ", "mu", "=", "embedding_values_or_function", "(", "samples", ")", "\n", "", "else", ":", "\n", "        ", "mu", "=", "mean_embedding_values_or_function", "\n", "assert", "mu", ".", "shape", "[", "0", "]", "==", "samples", ".", "shape", "[", "0", "]", "\n", "\n", "# Perform standard kernel herding", "\n", "", "mu_hat_sum", "=", "0", "\n", "for", "i", "in", "range", "(", "n_init_super_samples", ",", "n_super_samples", ")", ":", "\n", "        ", "mu_hat", "=", "mu_hat_sum", "/", "(", "i", "+", "1", ")", "\n", "objective", "=", "mu", "-", "mu_hat", "\n", "super_samples", "[", "i", "]", "=", "samples", "[", "np", ".", "argmax", "(", "objective", ")", "]", "\n", "mu_hat_sum", "+=", "kernel_function", "(", "super_samples", "[", "[", "i", "]", "]", ",", "samples", ")", ".", "ravel", "(", ")", "\n", "\n", "# size : (n_super_samples, n_dim)", "\n", "", "return", "super_samples", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.sqdist_gramix": [[12, 42], ["tensorflow.matmul", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.transpose"], "function", ["None"], ["def", "sqdist_gramix", "(", "x_p", ",", "x_q", ",", "length_scale", ")", ":", "\n", "    ", "\"\"\"\n    Compute a gram matrix of euclidean distances between two datasets under an isotropic or anisotropic length scale.\n    \n    Parameters\n    ----------\n    x_p : tf.Tensor [Size: (n_p, d)]\n        A dataset\n    x_q : tf.Tensor [Size: (n_q, d)]\n        A dataset\n    length_scale : float or tf.Tensor [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The length scale(s)\n        \n    Returns\n    -------\n    tf.Tensor [Size: (n_p, n_q)]\n        The resulting gram matrix\n    \"\"\"", "\n", "# Size: (n_p, d)", "\n", "z_p", "=", "x_p", "/", "length_scale", "\n", "# Size: (n_q, d)", "\n", "z_q", "=", "x_q", "/", "length_scale", "\n", "# Size: (n_p, n_q)", "\n", "d_pq", "=", "tf", ".", "matmul", "(", "z_p", ",", "tf", ".", "transpose", "(", "z_q", ")", ")", "\n", "# Size: (n_p,)", "\n", "d_p", "=", "tf", ".", "reduce_sum", "(", "z_p", "**", "2", ",", "axis", "=", "1", ")", "\n", "# Size: (n_q,)", "\n", "d_q", "=", "tf", ".", "reduce_sum", "(", "z_q", "**", "2", ",", "axis", "=", "1", ")", "\n", "# Size: (n_p, n_q)", "\n", "return", "d_p", "[", ":", ",", "tf", ".", "newaxis", "]", "-", "2", "*", "d_pq", "+", "d_q", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix": [[44, 64], ["tensorflow.exp", "tensorflow_kernels.sqdist_gramix"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.sqdist_gramix"], ["", "def", "gaussian_kernel_gramix", "(", "x_p", ",", "x_q", ",", "length_scale", ")", ":", "\n", "    ", "\"\"\"\n    Compute a gram matrix of Gaussian kernel values between two datasets under an isotropic or anisotropic length scale.\n    \n    Parameters\n    ----------\n    x_p : tf.Tensor [Size: (n_p, d)]\n        A dataset\n    x_q : tf.Tensor [Size: (n_q, d)]\n        A dataset\n    length_scale : float or tf.Tensor [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The length scale(s)\n        \n    Returns\n    -------\n    tf.Tensor [Size: (n_p, n_q)]\n        The resulting gram matrix\n    \"\"\"", "\n", "# Size: (n_p, n_q)", "\n", "return", "tf", ".", "exp", "(", "-", "0.5", "*", "sqdist_gramix", "(", "x_p", ",", "x_q", ",", "length_scale", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_1d": [[66, 81], ["tensorflow.reshape", "len", "tensor.get_shape"], "function", ["None"], ["", "def", "atleast_1d", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"\n    Convert a tensor to at least 1 dimensional (equivalent to np.atleast_1d).\n    \n    Parameters\n    ----------\n    tensor : tf.Tensor\n        A tensor\n    \n    Returns\n    -------\n    tf.Tensor\n        A tensor of at least 1 dimension\n    \"\"\"", "\n", "return", "tf", ".", "reshape", "(", "tensor", ",", "[", "1", "]", ")", "if", "len", "(", "tensor", ".", "get_shape", "(", ")", ")", "==", "0", "else", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d": [[83, 98], ["tensorflow.reshape", "tensorflow.reshape", "len", "tensor.get_shape", "tensor.get_shape().as_list", "tensor.get_shape"], "function", ["None"], ["", "def", "atleast_2d", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"\n    Convert a tensor to at least 2 dimensional (equivalent to np.atleast_2d).\n    \n    Parameters\n    ----------\n    tensor : tf.Tensor\n        A tensor\n    \n    Returns\n    -------\n    tf.Tensor\n        A tensor of at least 2 dimension\n    \"\"\"", "\n", "return", "tf", ".", "reshape", "(", "tensor", ",", "[", "1", ",", "1", "]", ")", "if", "len", "(", "tensor", ".", "get_shape", "(", ")", ")", "==", "0", "else", "tf", ".", "reshape", "(", "tensor", ",", "[", "1", ",", "tensor", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.convert_anisotropic": [[100, 127], ["tensorflow_kernels.atleast_1d", "len", "tensorflow.tile", "atleast_1d.get_shape", "atleast_1d.get_shape().as_list", "atleast_1d.get_shape().as_list", "atleast_1d.get_shape", "atleast_1d.get_shape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_1d"], ["", "def", "convert_anisotropic", "(", "length_scale", ",", "d", ")", ":", "\n", "    ", "\"\"\"\n    Convert isotropic length scale format to anisotropic length scale format.\n    \n    Parameters\n    ----------\n    length_scale : tf.Tensor [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The length scale(s)\n    d : int\n        The dimensionality of the anisotropic kernel\n    \n    Returns\n    -------\n    tf.Tensor [Size: (d,)]\n        The anisotropic length scale(s)\n    \"\"\"", "\n", "# Size: (1,) or (d,)", "\n", "length_scale_array", "=", "atleast_1d", "(", "length_scale", ")", "\n", "# Make sure it is not more than 1 dimensional", "\n", "assert", "len", "(", "length_scale_array", ".", "get_shape", "(", ")", ")", "==", "1", "\n", "# Make sure it is either isotropic or anisotropic", "\n", "assert", "length_scale_array", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "in", "[", "1", ",", "d", "]", "\n", "# Convert it to anistropic only if it is isotropic or keep it the same", "\n", "if", "length_scale_array", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "==", "1", ":", "\n", "        ", "return", "tf", ".", "tile", "(", "length_scale_array", ",", "[", "d", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "length_scale_array", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_density_gramix": [[129, 151], ["mu.get_shape().as_list", "tensorflow.reduce_prod", "tensorflow_kernels.gaussian_kernel_gramix", "tensorflow.sqrt", "tensorflow_kernels.convert_anisotropic", "mu.get_shape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.convert_anisotropic"], ["", "", "def", "gaussian_density_gramix", "(", "x", ",", "mu", ",", "sigma", ")", ":", "\n", "    ", "\"\"\"\n    Compute a gram matrix of Gaussian density values of a dataset for multiple means.\n    Parameters\n    ----------\n    x : tf.Tensor [Size: (n, d)]\n        A dataset\n    mu : tf.Tensor [Size: (m, d)]\n        A dataset\n    sigma : float or tf.Tensor [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The standard deviations(s)\n        \n    Returns\n    -------\n    tf.Tensor [Size: (n, m)]\n        The resulting gram matrix\n    \"\"\"", "\n", "# Compute the scaling factor of a diagonal multivariate Gaussian distribution", "\n", "d", "=", "mu", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "\n", "const", "=", "(", "tf", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", "**", "d", ")", "*", "tf", ".", "reduce_prod", "(", "convert_anisotropic", "(", "sigma", ",", "d", ")", ")", "\n", "# Size: (n, m)", "\n", "return", "gaussian_kernel_gramix", "(", "x", ",", "mu", ",", "sigma", ")", "/", "const", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_density_gramix_multiple": [[153, 187], ["tuple", "tuple", "tensorflow.reshape", "tensorflow.reshape", "tensorflow_kernels.gaussian_density_gramix", "tensorflow.reshape", "tensorflow.reduce_prod", "x.get_shape().as_list", "mu.get_shape().as_list", "tensorflow.reduce_mean", "x.get_shape().as_list", "mu.get_shape().as_list", "x.get_shape", "mu.get_shape", "x.get_shape", "mu.get_shape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_density_gramix"], ["", "def", "gaussian_density_gramix_multiple", "(", "x", ",", "mu", ",", "sigma", ")", ":", "\n", "    ", "\"\"\"\n    Compute the average gram matrix of Gaussian density values of a dataset for multiple arrays of means.\n    \n    Parameters\n    ----------\n    x : tf.Tensor [Size: (r, n, d)]\n        A dataset\n    mu : tf.Tensor [Size: (m, s, d)]\n        A dataset where the average is to be taken over the middle dimension (s)\n    sigma : float or tf.Tensor [Size: () or (1,) for isotropic; (d,) for anistropic]\n        The standard deviations(s)\n        \n    Returns\n    -------\n    tf.Tensor [Size: (n, m)]\n        The resulting gram matrix\n    \"\"\"", "\n", "# Obtain and ensure the shape matches", "\n", "r", ",", "n", ",", "d", "=", "tuple", "(", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "\n", "m", ",", "s", ",", "d", "=", "tuple", "(", "mu", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "\n", "assert", "d", "==", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "\n", "assert", "d", "==", "mu", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "\n", "# Size: (r * n, d)", "\n", "x_2d", "=", "tf", ".", "reshape", "(", "x", ",", "[", "r", "*", "n", ",", "d", "]", ")", "\n", "# Size: (m * s, d)", "\n", "mu_2d", "=", "tf", ".", "reshape", "(", "mu", ",", "[", "m", "*", "s", ",", "d", "]", ")", "\n", "# Size: (r * n, m * s)", "\n", "gramix_2d", "=", "gaussian_density_gramix", "(", "x_2d", ",", "mu_2d", ",", "sigma", ")", "\n", "# Size: (r, n, m, s)", "\n", "gramix_4d", "=", "tf", ".", "reshape", "(", "gramix_2d", ",", "[", "r", ",", "n", ",", "m", ",", "s", "]", ")", "\n", "# Size: (n, m)", "\n", "# return tf.reduce_mean(tf.reduce_prod(gramix_4d, axis=1), axis=-1)", "\n", "return", "tf", ".", "reduce_prod", "(", "tf", ".", "reduce_mean", "(", "gramix_4d", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "1", ")", "", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_weights": [[11, 57], ["kelfi.tensorflow_kernels.gaussian_kernel_gramix", "tensorflow.linalg.cholesky", "tensorflow.cholesky_solve", "len", "tensorflow.transpose", "theta_sim.get_shape().as_list", "x_sim.get_shape().as_list", "kelfi.tensorflow_kernels.gaussian_density_gramix_multiple", "len", "tensorflow.transpose", "ValueError", "tensorflow.reduce_min", "x_sim.get_shape().as_list", "kelfi.tensorflow_kernels.gaussian_density_gramix", "theta_sim.get_shape", "tensorflow.eye", "x_sim.get_shape", "x_sim.get_shape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_density_gramix_multiple", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_density_gramix"], ["def", "kernel_means_weights", "(", "y", ",", "x_sim", ",", "theta_sim", ",", "eps", ",", "beta", ",", "reg", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute the weights of the kernel means likelihood.\n    \n    Parameters\n    ----------\n    y : tf.Tensor [size: (1, d)]\n        Observed data or summary statistics\n    x_sim : tf.Tensor [size: (m, s, d)]\n        Simulated data or summary statistics\n    theta_sim : tf.Tensor [size: (m, p)]\n        Parameter values corresponding to the simulations\n    eps : float or tf.Tensor [size: () or (1,) for isotropic; (d,) for anistropic]\n        The simulator noise level(s) for the epsilon-kernel or epsilon-likelihood\n    beta : float or tf.Tensor [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n    reg : float, optional\n        The regularization parameter for the conditional kernel mean\n        \n    Returns\n    -------\n    tf.Tensor [size: (m, 1)]\n        The weights of the kernel means likelihood\n    \"\"\"", "\n", "# size: (m, 1)", "\n", "if", "len", "(", "x_sim", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "==", "3", ":", "\n", "        ", "data_epsilon_likelihood", "=", "tf", ".", "transpose", "(", "gaussian_density_gramix_multiple", "(", "y", ",", "x_sim", ",", "eps", ")", ")", "\n", "", "elif", "len", "(", "x_sim", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "==", "2", ":", "\n", "        ", "data_epsilon_likelihood", "=", "tf", ".", "transpose", "(", "gaussian_density_gramix", "(", "y", ",", "x_sim", ",", "eps", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Simulated dataset is neither 2D or 3D.'", ")", "\n", "\n", "# The number of simulations", "\n", "", "m", "=", "theta_sim", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "\n", "\n", "# Set the regularization hyperparameter to some default value if not specified", "\n", "if", "reg", "is", "None", ":", "\n", "        ", "reg", "=", "1e-3", "*", "tf", ".", "reduce_min", "(", "beta", ")", "\n", "\n", "# Compute the weights at O(m^3)", "\n", "", "theta_sim_gramix", "=", "gaussian_kernel_gramix", "(", "theta_sim", ",", "theta_sim", ",", "beta", ")", "\n", "theta_sim_gramix_cholesky", "=", "tf", ".", "linalg", ".", "cholesky", "(", "theta_sim_gramix", "+", "m", "*", "reg", "*", "tf", ".", "eye", "(", "m", ")", ")", "\n", "weights", "=", "tf", ".", "cholesky_solve", "(", "theta_sim_gramix_cholesky", ",", "data_epsilon_likelihood", ")", "\n", "\n", "# size: (m, 1)", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_likelihood": [[59, 84], ["kelfi.tensorflow_kernels.gaussian_kernel_gramix", "tensorflow.squeeze", "tensorflow.matmul", "tensorflow.transpose"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix"], ["", "def", "kernel_means_likelihood", "(", "theta_query", ",", "theta_sim", ",", "weights", ",", "beta", ")", ":", "\n", "    ", "\"\"\"\n    Query the kernel means likelihood.\n    \n    Parameters\n    ----------\n    theta_query : tf.Tensor [size: (n_query, p)]\n        The parameters to query the likelihood at\n    theta_sim : tf.Tensor [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : tf.Tensor [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or tf.Tensor [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n        \n    Returns\n    -------\n    tf.Tensor [size: (n_query,)]\n        The kernel means likelihood values at the query points\n    \"\"\"", "\n", "# size: (m, n_query)", "\n", "theta_evaluation_gramix", "=", "gaussian_kernel_gramix", "(", "theta_sim", ",", "theta_query", ",", "beta", ")", "\n", "\n", "# size: (n_query,)", "\n", "return", "tf", ".", "squeeze", "(", "tf", ".", "matmul", "(", "tf", ".", "transpose", "(", "theta_evaluation_gramix", ")", ",", "weights", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.marginal_kernel_means_likelihood": [[86, 125], ["tensorflow.sqrt", "tensorflow.reduce_prod", "tensorflow.reduce_sum", "tensorflow.zeros", "kelfi.tensorflow_kernels.convert_anisotropic", "kelfi.tensorflow_kernels.gaussian_kernel_gramix", "tensorflow.multiply", "kelfi.tensorflow_kernels.atleast_2d", "theta_sim.get_shape().as_list", "theta_sim.get_shape().as_list", "theta_sim.get_shape", "theta_sim.get_shape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.convert_anisotropic", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.gaussian_kernel_gramix", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.tensorflow_kernels.atleast_2d"], ["", "def", "marginal_kernel_means_likelihood", "(", "theta_sim", ",", "weights", ",", "beta", ",", "prior_mean", "=", "None", ",", "prior_std", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute the marginal kernel means likelihood under a diagonal Gaussian prior.\n    \n    Parameters\n    ----------\n    theta_sim : tf.Tensor [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : tf.Tensor [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or tf.Tensor [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n    prior_mean : tf.Tensor [size: () or (1,) for isotropic; (p,) for anistropic]\n        The mean(s) of the diagonal Gaussian prior\n    prior_std : tf.Tensor [size: () or (1,) for isotropic; (p,) for anistropic]\n        The standard deviation(s) of the diagonal Gaussian prior\n        \n    Returns\n    -------\n    float\n        The marginal kernel means likelihood\n    \"\"\"", "\n", "# By defaut, the prior has zero mean", "\n", "if", "prior_mean", "is", "None", ":", "\n", "        ", "prior_mean", "=", "tf", ".", "zeros", "(", "(", "1", ",", "theta_sim", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", ")", ")", "\n", "\n", "# By default, the prior standard deviation is set to the same as the length scale of the parameter kernel", "\n", "", "if", "prior_std", "is", "None", ":", "\n", "        ", "prior_std", "=", "beta", "\n", "\n", "# Compute the final length scale and the ratio scalar coefficient of the resulting prior mean embedding ", "\n", "", "prior_embedding_length_scale", "=", "tf", ".", "sqrt", "(", "beta", "**", "2", "+", "prior_std", "**", "2", ")", "\n", "ratio", "=", "tf", ".", "reduce_prod", "(", "convert_anisotropic", "(", "beta", "/", "prior_embedding_length_scale", ",", "theta_sim", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", "]", ")", ")", "\n", "\n", "# Compute the prior mean embedding [size: (m, 1)]", "\n", "prior_mean_embedding", "=", "ratio", "*", "gaussian_kernel_gramix", "(", "theta_sim", ",", "atleast_2d", "(", "prior_mean", ")", ",", "prior_embedding_length_scale", ")", "\n", "\n", "# Compute the kernel means marginal likelihood", "\n", "return", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "prior_mean_embedding", ",", "weights", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.approximate_marginal_kernel_means_likelihood": [[127, 148], ["tensorflow.reduce_mean", "kernel_means_learning.kernel_means_likelihood"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_likelihood"], ["", "def", "approximate_marginal_kernel_means_likelihood", "(", "theta_samples", ",", "theta_sim", ",", "weights", ",", "beta", ")", ":", "\n", "    ", "\"\"\"\n    Compute the approximate marginal kernel means likelihood using prior samples.\n    \n    Parameters\n    ----------\n    theta_samples : tf.Tensor [size: (n_samples, p)]\n        The prior parameter samples to marginalize over\n    theta_sim : tf.Tensor [size: (m, p)]\n        Parameter values corresponding to the simulations\n    weights : tf.Tensor [size: (m, 1)]\n        The weights of the kernel means likelihood\n    beta : float or tf.Tensor [size: () or (1,) for isotropic; (p,) for anistropic]\n        The length scale(s) for the parameter kernel\n        \n    Returns\n    -------\n    float\n        The approximate marginal kernel means likelihood   \n    \"\"\"", "\n", "return", "tf", ".", "reduce_mean", "(", "kernel_means_likelihood", "(", "theta_samples", ",", "theta_sim", ",", "weights", ",", "beta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_hyperparameter_learning": [[150, 257], ["tensorflow.exp", "kernel_means_learning.kernel_means_weights", "tensorflow.train.GradientDescentOptimizer", "tf.train.GradientDescentOptimizer.minimize", "tensorflow.Session", "tf.Session.run", "range", "tensorflow.constant", "tensorflow.Variable", "tfv", "tfc", "tfv", "tfc", "tfv", "tfc", "tensorflow.exp", "tensorflow.exp", "tfc", "tfc", "tfc", "kernel_means_learning.marginal_kernel_means_likelihood", "tfc", "kernel_means_learning.approximate_marginal_kernel_means_likelihood", "tensorflow.log", "tensorflow.global_variables_initializer", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "tensorflow.zeros", "tfc", "tfc", "tf.Session.run", "print", "tf.Session.run", "theta_sim.get_shape().as_list", "theta_sim.get_shape"], "function", ["home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.kernel_means_weights", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.bo.utils.minimize", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.marginal_kernel_means_likelihood", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.kernel_means_learning.approximate_marginal_kernel_means_likelihood", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run", "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.methods.diagnostics.TwoStageSelection.run"], ["", "def", "kernel_means_hyperparameter_learning", "(", "y", ",", "x_sim", ",", "theta_sim", ",", "eps_tuple", ",", "beta_tuple", ",", "reg_tuple", ",", "\n", "eps_ratios", "=", "1.", ",", "beta_ratios", "=", "1.", ",", "offset", "=", "0.", ",", "\n", "prior_samples", "=", "None", ",", "prior_mean", "=", "None", ",", "prior_std", "=", "None", ",", "\n", "learning_rate", "=", "0.01", ",", "n_iter", "=", "1000", ",", "display_steps", "=", "10", ")", ":", "\n", "    ", "\"\"\"\n    Bayesian hyperparameter learning for KELFI by maximizing the MKML.\n    \n    The API is written to take in numpy arrays. There is no need to pass in tensorflow tensors directly.\n    If the prior is Gaussian, analytical forms exist. Specify its mean and standard deviation in 'prior_mean' and 'prior_std'.\n    Otherwise, approximate forms exist by using prior samples. Provide the samples via 'prior_samples'.\n    If neither is provided, the prior is assumed to be Gaussian with zero mean \n    and standard deviation equal to the length scale of the parameter kernel.\n    For anisotropic cases, it could be convenient to learn the multiplier on fixed length scale ratios. This is \n    especially true for the parameter kernel, where the length scales can be set to a scaled multiple of the prior\n    standard deviations. Provide these ratios in 'eps_ratios' and 'beta_ratios'.\n    \n    Parameters\n    ----------\n    y : np.ndarray [size: (1, d)]\n        Observed data or summary statistics\n    x_sim : np.ndarray [size: (m, s, d)]\n        Simulated data or summary statistics\n    theta_sim : np.ndarray [size: (m, p)]\n        Parameter values corresponding to the simulations\n    eps_tuple : tuple (eps_init, learn_flag)\n        eps_init: float or np.ndarray [size: () or (1,) for isotropic; (d,) for anistropic]\n            The initial simulator noise level(s) for the epsilon-kernel or epsilon-likelihood\n        learn_flag: str\n            Indicate learning for this hyperparameter with 'learn' and use 'fix' otherwise\n    beta_tuple : tuple (beta_init, learn_flag)\n        beta_init: float or np.ndarray [size: () or (1,) for isotropic; (d,) for anistropic]\n            The initial length scale(s) for the parameter kernel\n        learn_flag: str\n            Indicate learning for this hyperparameter with 'learn' and use 'fix' otherwise\n    reg_tuple : tuple (reg_init, learn_flag)\n        reg_init: float\n            The initial regularization parameter for the conditional kernel mean\n        learn_flag: str\n            Indicate learning for this hyperparameter with 'learn' and use 'fix' otherwise\n    eps_ratios: float or np.ndarray [size: () or (1,) for isotropic; (d,) for anistropic]\n        Fixed ratios for the simulator noise level(s) for the epsilon-kernel or epsilon-likelihood\n    beta_ratios: float or np.ndarray [size: () or (1,) for isotropic; (d,) for anistropic]\n        Fixed ratios for the length scale(s) for the parameter kernel\n    offset : float\n        A positive offset in case approximate marginal kernel means likelihood values are slightly negative.\n    prior_samples : np.ndarray [size: (n_samples, p)]\n        The parameters samples to marginalize over\n    prior_mean : np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The mean(s) of the diagonal Gaussian prior\n    prior_std : np.ndarray [size: () or (1,) for isotropic; (p,) for anistropic]\n        The standard deviation(s) of the diagonal Gaussian prior\n    learning_rate : float\n        The learning rate for the gradient update\n    n_iter : int\n        Number of iterations\n    display_steps : int\n        Number of iterations before displaying the current optimization status\n    \"\"\"", "\n", "# Short notation for converting into tensorflow constants or variables", "\n", "tfc", "=", "lambda", "array", ":", "tf", ".", "constant", "(", "array", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "tfv", "=", "lambda", "array", ":", "tf", ".", "Variable", "(", "array", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "# Convert hyperparameters to variable for learning or constants otherwise", "\n", "log_eps", "=", "tfv", "(", "np", ".", "log", "(", "eps_tuple", "[", "0", "]", ")", ")", "if", "eps_tuple", "[", "1", "]", "==", "'learn'", "else", "tfc", "(", "np", ".", "log", "(", "eps_tuple", "[", "0", "]", ")", ")", "\n", "log_beta", "=", "tfv", "(", "np", ".", "log", "(", "beta_tuple", "[", "0", "]", ")", ")", "if", "beta_tuple", "[", "1", "]", "==", "'learn'", "else", "tfc", "(", "np", ".", "log", "(", "beta_tuple", "[", "0", "]", ")", ")", "\n", "log_reg", "=", "tfv", "(", "np", ".", "log", "(", "reg_tuple", "[", "0", "]", ")", ")", "if", "reg_tuple", "[", "1", "]", "==", "'learn'", "else", "tfc", "(", "np", ".", "log", "(", "reg_tuple", "[", "0", "]", ")", ")", "\n", "\n", "# Transform the hyperparameters into the actual hyperparameters if not already", "\n", "eps_", "=", "tf", ".", "exp", "(", "log_eps", ")", "*", "eps_ratios", "\n", "beta_", "=", "tf", ".", "exp", "(", "log_beta", ")", "*", "beta_ratios", "\n", "reg_", "=", "tf", ".", "exp", "(", "log_reg", ")", "\n", "\n", "# Convert all data into constants", "\n", "y_", ",", "x_sim_", ",", "theta_sim_", "=", "tfc", "(", "y", ")", ",", "tfc", "(", "x_sim", ")", ",", "tfc", "(", "theta_sim", ")", "\n", "\n", "# Compute the weights", "\n", "weights_", "=", "kernel_means_weights", "(", "y_", ",", "x_sim_", ",", "theta_sim_", ",", "eps_", ",", "beta_", ",", "reg", "=", "reg_", ")", "\n", "\n", "# Compute the objective using either the analytical or empirical form", "\n", "if", "prior_samples", "is", "None", ":", "\n", "# By defaut, the prior has zero mean", "\n", "        ", "prior_mean_", "=", "tf", ".", "zeros", "(", "(", "1", ",", "theta_sim", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", ")", ")", "if", "prior_mean", "is", "None", "else", "tfc", "(", "prior_mean", ")", "\n", "# By default, the prior standard deviation is set to the same as the length scale of the parameter kernel", "\n", "prior_std_", "=", "beta", "if", "prior_std", "is", "None", "else", "tfc", "(", "prior_std", ")", "\n", "# Objective", "\n", "ml", "=", "marginal_kernel_means_likelihood", "(", "theta_sim_", ",", "weights_", ",", "beta_", ",", "prior_mean", "=", "prior_mean_", ",", "prior_std", "=", "prior_std_", ")", "\n", "", "else", ":", "\n", "# Use prior samples if the prior was not transformed into Gaussians beforehand", "\n", "        ", "theta_samples_", "=", "tfc", "(", "prior_samples", ")", "\n", "# Objective", "\n", "ml", "=", "approximate_marginal_kernel_means_likelihood", "(", "theta_samples_", ",", "theta_sim_", ",", "weights_", ",", "beta_", ")", "\n", "", "objective", "=", "-", "tf", ".", "log", "(", "ml", "+", "offset", ")", "\n", "\n", "# Minimize the negative marginal likelihood", "\n", "opt", "=", "tf", ".", "train", ".", "GradientDescentOptimizer", "(", "learning_rate", "=", "learning_rate", ")", "\n", "learn_step", "=", "opt", ".", "minimize", "(", "objective", ")", "\n", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "for", "i", "in", "range", "(", "n_iter", ")", ":", "\n", "        ", "if", "i", "%", "display_steps", "==", "0", ":", "\n", "            ", "_", ",", "eps", ",", "beta", ",", "reg", ",", "marginal_likelihood", "=", "sess", ".", "run", "(", "[", "learn_step", ",", "eps_", ",", "beta_", ",", "reg_", ",", "ml", "]", ")", "\n", "print", "(", "'i: '", ",", "i", ",", "' | eps: '", ",", "eps", ",", "' | beta: '", ",", "beta", ",", "' | reg: '", ",", "reg", ",", "' | ml: '", ",", "marginal_likelihood", ")", "\n", "", "else", ":", "\n", "            ", "sess", ".", "run", "(", "learn_step", ")", "\n", "\n", "# Return the learned hyperparameters", "\n", "", "", "return", "eps", ",", "beta", ",", "reg", "\n", "", ""]], "home.repos.pwc.inspect_result.alexaushev_LFIwithDGPs.kelfi.utils.halton_sequence": [[9, 28], ["ghalton.Halton", "numpy.array", "gh.Halton.get"], "function", ["None"], ["\n", "import", "numpy", "as", "np", "\n", "import", "pandas", "as", "pd", "\n", "from", "os", "import", "path", "\n", "from", "pathlib", "import", "Path", "\n", "\n", "from", "kelfi", ".", "kernel_means_inference", "import", "kernel_means_weights", ",", "approximate_marginal_kernel_means_likelihood", "\n", "from", "kelfi", ".", "kernel_means_inference", "import", "approximate_kernel_means_posterior_embedding", ",", "kernel_herding", "\n", "from", "kelfi", ".", "kernel_means_learning", "import", "kernel_means_hyperparameter_learning", "\n", "from", "kelfi", ".", "kernels", "import", "gaussian_kernel_gramix", "\n", "\n", "\n", "import", "warnings", "\n", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ")", "\n", "\n", "\n", "# =====================", "\n", "# PLOTTING FUNCTIONS:", "\n", "# =====================", "\n", "\n"]]}