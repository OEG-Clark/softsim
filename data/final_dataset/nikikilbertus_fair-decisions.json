{"home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy.__init__": [[20, 49], ["copy.deepcopy", "featuremaps.FeatureMapIdentity", "isinstance", "policies.BasePolicy.init.copy", "isinstance", "policies.BasePolicy.init.theta.copy", "copy.deepcopy", "policies.BasePolicy._init_theta"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.copy", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.copy", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy._init_theta"], ["def", "__init__", "(", "self", ",", "init", "=", "None", ",", "cost", "=", "None", ",", "featuremap", "=", "None", ",", "config", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize a policy.\n\n        Args:\n            init: Indicator how to initialize the policy.\n            cost: The cost factor of the utility.\n            featuremap: A featuremap to apply to the inputs (not needed if init\n                is an instance of a BasePolicy.\n            config: Configuration dictionary.\n        \"\"\"", "\n", "self", ".", "theta", "=", "None", "\n", "self", ".", "cost", "=", "cost", "\n", "self", ".", "fm", "=", "featuremap", "\n", "self", ".", "config", "=", "deepcopy", "(", "config", ")", "\n", "self", ".", "init", "=", "init", "\n", "\n", "if", "self", ".", "fm", "is", "None", ":", "\n", "            ", "self", ".", "fm", "=", "featuremaps", ".", "FeatureMapIdentity", "(", ")", "\n", "\n", "", "if", "init", "is", "not", "None", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "init", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "self", ".", "theta", "=", "self", ".", "init", ".", "copy", "(", ")", "\n", "", "elif", "isinstance", "(", "self", ".", "init", ",", "BasePolicy", ")", ":", "\n", "                ", "self", ".", "theta", "=", "self", ".", "init", ".", "theta", ".", "copy", "(", ")", "\n", "self", ".", "cost", "=", "self", ".", "init", ".", "cost", "\n", "self", ".", "fm", "=", "self", ".", "init", ".", "fm", "\n", "self", ".", "config", "=", "deepcopy", "(", "self", ".", "init", ".", "config", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_init_theta", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy._init_theta": [[50, 60], ["numpy.random.randn", "numpy.random.rand", "numpy.zeros", "RuntimeError"], "methods", ["None"], ["", "", "", "def", "_init_theta", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize theta.\"\"\"", "\n", "if", "self", ".", "init", "==", "\"normal\"", ":", "\n", "            ", "self", ".", "theta", "=", "np", ".", "random", ".", "randn", "(", "self", ".", "fm", ".", "n_components", ")", "\n", "", "elif", "self", ".", "init", "==", "\"uniform\"", ":", "\n", "            ", "self", ".", "theta", "=", "np", ".", "random", ".", "rand", "(", "self", ".", "fm", ".", "n_components", ")", "\n", "", "elif", "self", ".", "init", "in", "\"zeros\"", ":", "\n", "            ", "self", ".", "theta", "=", "np", ".", "zeros", "(", "self", ".", "fm", ".", "n_components", ")", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"Unknown initialization {self.init}.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy.set_theta": [[61, 70], ["len"], "methods", ["None"], ["", "", "def", "set_theta", "(", "self", ",", "theta", ")", ":", "\n", "        ", "\"\"\"\n        Set the weight vector theta.\n\n        Args:\n            theta: np.ndarray, the weight vector theta\n        \"\"\"", "\n", "self", ".", "theta", "=", "theta", "\n", "self", ".", "fm", ".", "n_components", "=", "len", "(", "theta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy.sample": [[71, 82], ["NotImplementedError"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Sample decisions for given inputs.\n\n        Args:\n            x: The inputs for which to sample (binary) decisions (np.ndarray).\n\n        Returns:\n            d: A binary (0/1) vector np.ndarray of length x.shape[0]\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Subclass must override sample(x).\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy.copy": [[83, 86], ["NotImplementedError"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Create and return a copy.\"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Subclass must override copy().\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.LogisticPolicy.__init__": [[97, 102], ["policies.BasePolicy.__init__"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__"], ["def", "__init__", "(", "self", ",", "init", ",", "cost", "=", "None", ",", "featuremap", "=", "None", ",", "config", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize a logistic policy.\"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "init", ",", "cost", ",", "featuremap", ",", "config", ")", "\n", "self", ".", "keep_positive", "=", "self", ".", "config", "[", "\"keep_positive\"", "]", "\n", "self", ".", "type", "=", "\"semi_logistic\"", "if", "self", ".", "keep_positive", "else", "\"logistic\"", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.LogisticPolicy.sample": [[103, 123], ["utils.sigmoid", "numpy.round", "numpy.ones().astype", "numpy.random.binomial", "numpy.round.astype", "policies.LogisticPolicy.fm.fit", "policies.LogisticPolicy._init_theta", "numpy.matmul", "policies.LogisticPolicy.fm", "numpy.ones", "len"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.sigmoid", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.fit", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy._init_theta"], ["", "def", "sample", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Sample decisions for given inputs.\n\n        Args:\n            x: The inputs for which to sample (binary) decisions (np.ndarray).\n\n        Returns:\n            d: A binary (0/1) vector np.ndarray of length x.shape[0]\n        \"\"\"", "\n", "if", "self", ".", "theta", "is", "None", ":", "\n", "            ", "self", ".", "fm", ".", "fit", "(", "x", ")", "\n", "self", ".", "_init_theta", "(", ")", "\n", "", "yprob", "=", "utils", ".", "sigmoid", "(", "np", ".", "matmul", "(", "self", ".", "fm", "(", "x", ")", ",", "self", ".", "theta", ")", ")", "\n", "d", "=", "np", ".", "round", "(", "yprob", ")", "\n", "explore", "=", "np", ".", "ones", "(", "len", "(", "yprob", ")", ")", ".", "astype", "(", "bool", ")", "\n", "if", "self", ".", "keep_positive", ":", "\n", "            ", "explore", "&=", "yprob", "<", "0.5", "\n", "", "d", "[", "explore", "]", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "yprob", "[", "explore", "]", ")", "\n", "return", "d", ".", "astype", "(", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.LogisticPolicy.copy": [[124, 126], ["policies.LogisticPolicy"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "return", "LogisticPolicy", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.DeterministicThreshold.__init__": [[137, 141], ["policies.BasePolicy.__init__"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__"], ["def", "__init__", "(", "self", ",", "init", ",", "cost", ",", "featuremap", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize a logistic policy.\"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "init", ",", "cost", ",", "featuremap", ")", "\n", "self", ".", "type", "=", "\"deterministic_threshold\"", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.DeterministicThreshold.sample": [[142, 158], ["policies.DeterministicThreshold.fm.fit", "policies.DeterministicThreshold._init_theta", "utils.sigmoid", "numpy.matmul", "policies.DeterministicThreshold.fm"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.fit", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy._init_theta", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.sigmoid"], ["", "def", "sample", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Compute decisions for given inputs.\n\n        Args:\n            x: The inputs for which to sample (binary) decisions (np.ndarray).\n\n        Returns:\n            d: A binary (0/1) vector np.ndarray of length x.shape[0]\n        \"\"\"", "\n", "if", "self", ".", "theta", "is", "None", ":", "\n", "            ", "self", ".", "fm", ".", "fit", "(", "x", ")", "\n", "self", ".", "_init_theta", "(", ")", "\n", "", "return", "(", "\n", "utils", ".", "sigmoid", "(", "np", ".", "matmul", "(", "self", ".", "fm", "(", "x", ")", ",", "self", ".", "theta", ")", ")", ">", "self", ".", "cost", "\n", ")", ".", "astype", "(", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.DeterministicThreshold.set_rule": [[159, 163], ["None"], "methods", ["None"], ["", "def", "set_rule", "(", "self", ",", "func", ")", ":", "\n", "        ", "\"\"\"Override the sample function.\"\"\"", "\n", "self", ".", "sample", "=", "func", "\n", "self", ".", "theta", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.DeterministicThreshold.set_threshold": [[164, 168], ["None"], "methods", ["None"], ["", "def", "set_threshold", "(", "self", ",", "thresh", ")", ":", "\n", "        ", "\"\"\"Override the sample function by a threshold.\"\"\"", "\n", "self", ".", "sample", "=", "lambda", "x", ":", "(", "x", "[", ":", ",", "1", "]", ">", "thresh", ")", ".", "astype", "(", "float", ")", "\n", "self", ".", "theta", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.DeterministicThreshold.copy": [[169, 171], ["policies.DeterministicThreshold"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "return", "DeterministicThreshold", "(", "self", ",", "self", ".", "cost", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.__init__": [[182, 187], ["policies.BasePolicy.__init__"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize a logistic policy.\"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "type", "=", "\"bernoulli\"", "\n", "self", ".", "theta", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.sample": [[188, 199], ["numpy.random.randint"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Compute decisions for given inputs.\n\n        Args:\n            x: The inputs for which to sample (binary) decisions (np.ndarray).\n\n        Returns:\n            d: A binary (0/1) vector np.ndarray of length x.shape[0]\n        \"\"\"", "\n", "return", "np", ".", "random", ".", "randint", "(", "0", ",", "2", ",", "x", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.copy": [[200, 202], ["None"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.get_optimal_policy": [[210, 249], ["policies.DeterministicThreshold", "isinstance", "get_optimal_policy.set_threshold", "isinstance", "hasattr", "policies.get_optimal_policy", "opt.threshold", "get_optimal_policy.set_rule", "opt.sample_labels"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.DeterministicThreshold.set_threshold", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.get_optimal_policy", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.threshold", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.DeterministicThreshold.set_rule", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_labels"], ["", "", "def", "get_optimal_policy", "(", "opt", ",", "cost", ",", "featuremap", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute the optimal policy either from a threshold, a weight vector,\n    or examples.\n\n    This is a bit dirty. Basically we need to figure out whether we can compute\n    the optimal deterministic policy for the given distribution analytically.\n    Therefore we do a whole lot of checks for the distribution to figure this\n    out. Could be done better.\n\n    Args:\n        opt: Can be a single float (threshold) an np.ndarray of 2 elements\n            (given theta) or a tuple (x,y) with datapoints x, y.\n        cost: The cost factor in the utility.\n        featuremap: The featuremap to be used.\n\n    Returns:\n        The optimal `DeterministicThreshold` policy.\n    \"\"\"", "\n", "# if we can find the optimal one it is going to be deterministic", "\n", "pi", "=", "DeterministicThreshold", "(", "\"zeros\"", ",", "cost", ",", "featuremap", ")", "\n", "# threshold", "\n", "if", "isinstance", "(", "opt", ",", "float", ")", ":", "\n", "        ", "pi", ".", "set_threshold", "(", "opt", ")", "\n", "", "elif", "isinstance", "(", "opt", ",", "truedistribution", ".", "BaseDistribution", ")", ":", "\n", "        ", "if", "hasattr", "(", "opt", ",", "\"threshold\"", ")", ":", "\n", "            ", "pi", "=", "get_optimal_policy", "(", "opt", ".", "threshold", "(", "cost", ")", ",", "cost", ",", "featuremap", "=", "None", ")", "\n", "", "else", ":", "\n", "            ", "if", "opt", ".", "is_1d", ":", "\n", "                ", "pi", ".", "set_rule", "(", "\n", "lambda", "x", ":", "(", "\n", "opt", ".", "sample_labels", "(", "x", ",", "None", ",", "yproba", "=", "True", ")", "[", "1", "]", ">", "cost", "\n", ")", ".", "astype", "(", "float", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "pi", "=", "None", "\n", "", "", "", "else", ":", "\n", "        ", "pi", "=", "None", "\n", "", "return", "pi", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.FairnessHistory.__init__": [[22, 60], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "quantities", ":", "Sequence", "[", "Text", "]", ")", ":", "\n", "        ", "\"\"\"Initialize a fairness history.\n\n        Possible quantities to record are:\n          Stored as 3-tuples for the two groups and the entire dataset:\n            \"A\": num_individuals,\n            \"N\": num_negatives,\n            \"P\": num_positives,\n            \"TP\": true_positives\n            \"TN\": true_negatives\n            \"FP\": false_positives\n            \"FN\": false_negatives\n            \"TPR\": true_positive_rate\n            \"FPR\": false_positive_rate\n            \"TNR\": true_negative_rate\n            \"FNR\": false_negative_rate\n            \"PPV\": positive_predictive_value\n            \"NPV\": negative_predictive_value\n            \"FDR\": false_discovery_rate\n            \"FOR\": false_omission_rate\n            \"ACC\": accuracy\n            \"ERR\": error_rate\n            \"SEL\": selection_rate\n            \"F1\": f1_score\n          Stored as single numbers:\n            \"AVG_ODDS_DIFF\": average of the difference of FPR and TPR\n            \"AVG_ABS_ODDS_DIFF\": average of the absolute difference of FPR and\n                TPR\n            \"ERR_DIFF\": average of the absolute difference of FPR and TPR\n            \"DI\": disparate impact: ratio of the fraction of positive outcomes\n            \"DP\": demographic parity: diff between fractions of positive\n                outcomes\n            \"EOP\": equal opportunity: diff in true positive rates\n\n        Args:\n          quantities: A list of strings indicating which measures to record.\n        \"\"\"", "\n", "self", ".", "_history", "=", "{", "quantity", ":", "[", "]", "for", "quantity", "in", "quantities", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.FairnessHistory.history": [[61, 70], ["numpy.array", "metrics.FairnessHistory._history.items"], "methods", ["None"], ["", "@", "property", "\n", "def", "history", "(", "self", ")", "->", "Dict", "[", "Text", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"The history of values recorded so far.\n\n        Returns:\n          A dictionary with the requested quantities as keys and arrays as\n          values.\n        \"\"\"", "\n", "return", "{", "key", ":", "np", ".", "array", "(", "val", ")", "for", "key", ",", "val", "in", "self", ".", "_history", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.FairnessHistory.snapshot": [[71, 89], ["ClassificationMetrics.ClassificationMetrics", "ClassificationMetrics.FairnessHistory._history.items", "history.append", "ClassificationMetrics.ClassificationMetrics.all_groups", "history.append", "ValueError"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.all_groups"], ["", "def", "snapshot", "(", "self", ",", "y", ":", "np", ".", "ndarray", ",", "yhat", ":", "np", ".", "ndarray", ",", "protected", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "\"\"\"Add a snapshot.\n\n        Args:\n          y: An array of binary (0/1) true outcomes.\n          yhat: An array of binary (0/1) predictions/decisions.\n          protected: A binary (0/1) array of for the protected attribute.\n        \"\"\"", "\n", "metrics", "=", "ClassificationMetrics", "(", "y", ",", "yhat", ",", "protected", ")", "\n", "for", "quantity", ",", "history", "in", "self", ".", "_history", ".", "items", "(", ")", ":", "\n", "            ", "if", "quantity", "in", "metrics", ".", "label_to_fun", ":", "\n", "                ", "history", ".", "append", "(", "\n", "metrics", ".", "all_groups", "(", "metrics", ".", "label_to_fun", "[", "quantity", "]", ")", "\n", ")", "\n", "", "elif", "quantity", "in", "metrics", ".", "label_to_fair", ":", "\n", "                ", "history", ".", "append", "(", "metrics", ".", "label_to_fair", "[", "quantity", "]", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Unknown metric {}\"", ".", "format", "(", "quantity", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.__init__": [[99, 142], ["protected.astype", "numpy.logical_not", "metrics.ClassificationMetrics._check_validity"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._check_validity"], ["def", "__init__", "(", "self", ",", "y", ":", "np", ".", "ndarray", ",", "yhat", ":", "np", ".", "ndarray", ",", "protected", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "\"\"\"Initialize fairness metrics.\n\n        Args:\n          y: An array of binary (0/1) true outcomes.\n          yhat: An array of binary (0/1) predictions/decisions.\n          protected: A binary (0/1) array for the protected attribute.\n        \"\"\"", "\n", "self", ".", "_y", "=", "y", "\n", "self", ".", "_yhat", "=", "yhat", "\n", "self", ".", "_protected", "=", "protected", ".", "astype", "(", "bool", ")", "\n", "self", ".", "_unprotected", "=", "np", ".", "logical_not", "(", "self", ".", "_protected", ")", "\n", "self", ".", "_results", "=", "{", "\"all\"", ":", "{", "}", ",", "\"protected\"", ":", "{", "}", ",", "\"unprotected\"", ":", "{", "}", "}", "\n", "self", ".", "_check_validity", "(", ")", "\n", "\n", "self", ".", "label_to_fun", "=", "{", "\n", "\"A\"", ":", "self", ".", "num_individuals", ",", "\n", "\"N\"", ":", "self", ".", "num_negatives", ",", "\n", "\"P\"", ":", "self", ".", "num_positives", ",", "\n", "\"TP\"", ":", "self", ".", "num_true_positives", ",", "\n", "\"TN\"", ":", "self", ".", "num_true_negatives", ",", "\n", "\"FP\"", ":", "self", ".", "num_false_positives", ",", "\n", "\"FN\"", ":", "self", ".", "num_false_negatives", ",", "\n", "\"TPR\"", ":", "self", ".", "true_positive_rate", ",", "\n", "\"FPR\"", ":", "self", ".", "false_positive_rate", ",", "\n", "\"TNR\"", ":", "self", ".", "true_negative_rate", ",", "\n", "\"FNR\"", ":", "self", ".", "false_negative_rate", ",", "\n", "\"PPV\"", ":", "self", ".", "positive_predictive_value", ",", "\n", "\"NPV\"", ":", "self", ".", "negative_predictive_value", ",", "\n", "\"FDR\"", ":", "self", ".", "false_discovery_rate", ",", "\n", "\"FOR\"", ":", "self", ".", "false_omission_rate", ",", "\n", "\"ACC\"", ":", "self", ".", "accuracy", ",", "\n", "\"ERR\"", ":", "self", ".", "error_rate", ",", "\n", "\"SEL\"", ":", "self", ".", "selection_rate", ",", "\n", "\"F1\"", ":", "self", ".", "f1_score", ",", "\n", "}", "\n", "self", ".", "label_to_fair", "=", "{", "\n", "\"AVG_ODDS_DIFF\"", ":", "self", ".", "average_odds_difference", ",", "\n", "\"AVG_ABS_ODDS_DIFF\"", ":", "self", ".", "average_abs_odds_difference", ",", "\n", "\"ERR_DIFF\"", ":", "self", ".", "error_rate_difference", ",", "\n", "\"DI\"", ":", "self", ".", "disparate_impact", ",", "\n", "\"DP\"", ":", "self", ".", "demographic_parity_difference", ",", "\n", "\"EOP\"", ":", "self", ".", "equal_opportunity_difference", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._check_validity": [[148, 160], ["len", "len", "ValueError", "ValueError", "len", "len"], "methods", ["None"], ["", "def", "_check_validity", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check whether the length of the inputs match.\n\n        Raises:\n          ValueError: Wrong input dimensions.\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "_y", ")", "!=", "len", "(", "self", ".", "_yhat", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"y and yhat must be same length.\"", ")", "\n", "", "if", "self", ".", "_protected", "is", "not", "None", "and", "len", "(", "self", ".", "_y", ")", "!=", "len", "(", "\n", "self", ".", "_protected", "\n", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"y and protected must be same length.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_condition": [[161, 177], ["numpy.full", "len"], "methods", ["None"], ["", "", "def", "_get_condition", "(", "self", ",", "protected", ":", "Union", "[", "bool", ",", "None", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Get the indices for the individuals in the specified group.\n\n        Args:\n          protected: Whether to get the indices of the protected group (True),\n              the unprotected group (False), or the entire dataset (None).\n\n        Returns:\n          An index array of the same length as the input data.\n        \"\"\"", "\n", "if", "protected", "is", "None", ":", "\n", "            ", "return", "np", ".", "full", "(", "len", "(", "self", ".", "_y", ")", ",", "True", ")", "\n", "", "elif", "protected", ":", "\n", "            ", "return", "self", ".", "_protected", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_unprotected", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key": [[178, 194], ["None"], "methods", ["None"], ["", "", "def", "_get_key", "(", "self", ",", "protected", ":", "Union", "[", "bool", ",", "None", "]", ")", "->", "Text", ":", "\n", "        ", "\"\"\"Convert bool or None into hashable key for dictionary indexing.\n\n        Args:\n          protected: Whether to address the protected group (True), the\n              unprotected group (False), or the entire dataset (None).\n\n        Returns:\n          String, the key for a dictionary.\n        \"\"\"", "\n", "if", "protected", "is", "None", ":", "\n", "            ", "return", "\"all\"", "\n", "", "elif", "protected", ":", "\n", "            ", "return", "\"protected\"", "\n", "", "else", ":", "\n", "            ", "return", "\"unprotected\"", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._num_confusionquadrant": [[195, 217], ["metrics.ClassificationMetrics._get_condition", "int", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_condition"], ["", "", "def", "_num_confusionquadrant", "(", "\n", "self", ",", "\n", "true_val", ":", "int", ",", "\n", "predicted_val", ":", "int", ",", "\n", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", ")", "->", "int", ":", "\n", "        ", "\"\"\"Compute the number of instances in a quadrant of the confusion table.\n\n        Args:\n          true_val: The value for the true outcomes (0/1).\n          predicted_val: the value for the predicted outcomes (0/1).\n          protected: Boolean whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          Integer, the number of instances satisfying the selection criterium.\n        \"\"\"", "\n", "idx", "=", "self", ".", "_get_condition", "(", "protected", ")", "\n", "return", "int", "(", "\n", "np", ".", "sum", "(", "\n", "(", "(", "self", ".", "_y", "==", "true_val", ")", "&", "(", "self", ".", "_yhat", "==", "predicted_val", ")", ")", "[", "idx", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._difference": [[220, 233], ["metric_function", "metric_function"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_difference", "(", "metric_function", ")", "->", "float", ":", "\n", "        ", "\"\"\"Compute the difference of the given metric between the two groups.\n\n        Args:\n          metric_function: The metric to be computed on the groups.\n\n        Returns:\n          float, the `metric_function` for the protected group minus the\n          `metric_function` for the unprotected group.\n        \"\"\"", "\n", "return", "metric_function", "(", "protected", "=", "True", ")", "-", "metric_function", "(", "\n", "protected", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._ratio": [[235, 250], ["metric_function", "numpy.isclose", "metric_function"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_ratio", "(", "metric_function", ")", "->", "float", ":", "\n", "        ", "\"\"\"Compute the ratio of the given metric between the two groups.\n\n        Args:\n          metric_function: The metric to be computed on the groups.\n\n        Returns:\n          float, the `metric_function` for the protected group divided by the\n          `metric_function` for the unprotected group.\n        \"\"\"", "\n", "denominator", "=", "metric_function", "(", "protected", "=", "False", ")", "\n", "if", "np", ".", "isclose", "(", "denominator", ",", "0.0", ")", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "", "return", "metric_function", "(", "protected", "=", "True", ")", "/", "denominator", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.metrics": [[255, 274], ["metrics.ClassificationMetrics.label_to_fair.items", "metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics.label_to_fun.items", "function", "function"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key"], ["", "def", "metrics", "(", "self", ")", "->", "Any", ":", "\n", "        ", "\"\"\"Compute all available metrics for all groups.\n\n        Returns:\n          A tuple of dictionaries:\n              performance: Keys are \"all\", \"protected\", \"unprotected\" and the\n                  values are dictionaries containing all available metrics.\n              fairness: Keys are fairness measure labels and keys are numbers.\n        \"\"\"", "\n", "performance", "=", "{", "}", "\n", "for", "protected", "in", "[", "True", ",", "False", ",", "None", "]", ":", "\n", "            ", "group_label", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "performance", "[", "group_label", "]", "=", "{", "}", "\n", "for", "label", ",", "function", "in", "self", ".", "label_to_fun", ".", "items", "(", ")", ":", "\n", "                ", "performance", "[", "group_label", "]", "[", "label", "]", "=", "function", "(", "protected", ")", "\n", "", "", "fairness", "=", "{", "}", "\n", "for", "label", ",", "function", "in", "self", ".", "label_to_fair", ".", "items", "(", ")", ":", "\n", "            ", "fairness", "[", "label", "]", "=", "function", "(", ")", "\n", "", "return", "performance", ",", "fairness", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.all_groups": [[275, 294], ["metric_function", "metric_function", "metric_function"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "all_groups", "(", "\n", "metric_function", ":", "Callable", "[", "...", ",", "Union", "[", "float", ",", "int", "]", "]", "\n", ")", "->", "Tuple", "[", "Union", "[", "float", ",", "int", "]", ",", "Union", "[", "float", ",", "int", "]", ",", "Union", "[", "float", ",", "int", "]", "]", ":", "\n", "        ", "\"\"\"Compute given metric for all possible groups (including all data).\n\n        Args:\n          metric_function: The metric to be computed on the groups.\n\n        Returns:\n          3-tuple: the `metric_function` for\n            [0] the entire dataset\n            [1] the protected group\n            [2] the unprotected group.\n        \"\"\"", "\n", "return", "(", "\n", "metric_function", "(", "protected", "=", "None", ")", ",", "\n", "metric_function", "(", "protected", "=", "True", ")", ",", "\n", "metric_function", "(", "protected", "=", "False", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_individuals": [[300, 311], ["int", "numpy.sum", "metrics.ClassificationMetrics._get_condition"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_condition"], ["", "def", "num_individuals", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Get the number of individuals in a given class or the entire dataset.\n\n        Args:\n          protected: Whether to count the protected group (True), the\n              unprotected group (False), or the entire dataset (None).\n\n        Returns:\n          integer, the number of individuals in the specified group.\n        \"\"\"", "\n", "return", "int", "(", "np", ".", "sum", "(", "self", ".", "_get_condition", "(", "protected", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_positives": [[312, 327], ["metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics._get_condition", "int", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_condition"], ["", "def", "num_positives", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Number of real positive cases in the data.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n        Returns:\n          Integer, the number of real positive cases in the data.\n        \"\"\"", "\n", "key", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "if", "\"P\"", "not", "in", "self", ".", "_results", "[", "key", "]", ":", "\n", "            ", "idx", "=", "self", ".", "_get_condition", "(", "protected", ")", "\n", "self", ".", "_results", "[", "key", "]", "[", "\"P\"", "]", "=", "int", "(", "np", ".", "sum", "(", "self", ".", "_y", "[", "idx", "]", ")", ")", "\n", "", "return", "self", ".", "_results", "[", "key", "]", "[", "\"P\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_negatives": [[328, 343], ["metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics._get_condition", "int", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_condition"], ["", "def", "num_negatives", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Number of real negative cases in the data.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n        Returns:\n          Integer, the number of real negative cases in the data.\n        \"\"\"", "\n", "key", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "if", "\"N\"", "not", "in", "self", ".", "_results", "[", "key", "]", ":", "\n", "            ", "idx", "=", "self", ".", "_get_condition", "(", "protected", ")", "\n", "self", ".", "_results", "[", "key", "]", "[", "\"N\"", "]", "=", "int", "(", "np", ".", "sum", "(", "1", "-", "self", ".", "_y", "[", "idx", "]", ")", ")", "\n", "", "return", "self", ".", "_results", "[", "key", "]", "[", "\"N\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_predicted_positives": [[344, 359], ["metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics._get_condition", "int", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_condition"], ["", "def", "num_predicted_positives", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Number of positive predictions.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n        Returns:\n          Integer, the number of positive predictions.\n        \"\"\"", "\n", "key", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "if", "\"PPRED\"", "not", "in", "self", ".", "_results", "[", "key", "]", ":", "\n", "            ", "idx", "=", "self", ".", "_get_condition", "(", "protected", ")", "\n", "self", ".", "_results", "[", "key", "]", "[", "\"PPRED\"", "]", "=", "int", "(", "np", ".", "sum", "(", "self", ".", "_yhat", "[", "idx", "]", ")", ")", "\n", "", "return", "self", ".", "_results", "[", "key", "]", "[", "\"PPRED\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_predicted_negatives": [[360, 375], ["metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics._get_condition", "int", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_condition"], ["", "def", "num_predicted_negatives", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Number of negative predictions.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n        Returns:\n          Integer, the number of negative predictions.\n        \"\"\"", "\n", "key", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "if", "\"NPRED\"", "not", "in", "self", ".", "_results", "[", "key", "]", ":", "\n", "            ", "idx", "=", "self", ".", "_get_condition", "(", "protected", ")", "\n", "self", ".", "_results", "[", "key", "]", "[", "\"NPRED\"", "]", "=", "int", "(", "np", ".", "sum", "(", "1", "-", "self", ".", "_yhat", "[", "idx", "]", ")", ")", "\n", "", "return", "self", ".", "_results", "[", "key", "]", "[", "\"NPRED\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_positives": [[376, 393], ["metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics._num_confusionquadrant"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._num_confusionquadrant"], ["", "def", "num_true_positives", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Number of true positives.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          Integer, the number of true positives.\n        \"\"\"", "\n", "key", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "if", "\"TP\"", "not", "in", "self", ".", "_results", "[", "key", "]", ":", "\n", "            ", "self", ".", "_results", "[", "key", "]", "[", "\"TP\"", "]", "=", "self", ".", "_num_confusionquadrant", "(", "\n", "1", ",", "1", ",", "protected", "\n", ")", "\n", "", "return", "self", ".", "_results", "[", "key", "]", "[", "\"TP\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_negatives": [[394, 411], ["metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics._num_confusionquadrant"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._num_confusionquadrant"], ["", "def", "num_true_negatives", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Number of true negatives.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          Integer, the number of true negatives.\n        \"\"\"", "\n", "key", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "if", "\"TN\"", "not", "in", "self", ".", "_results", "[", "key", "]", ":", "\n", "            ", "self", ".", "_results", "[", "key", "]", "[", "\"TN\"", "]", "=", "self", ".", "_num_confusionquadrant", "(", "\n", "0", ",", "0", ",", "protected", "\n", ")", "\n", "", "return", "self", ".", "_results", "[", "key", "]", "[", "\"TN\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_positives": [[412, 429], ["metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics._num_confusionquadrant"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._num_confusionquadrant"], ["", "def", "num_false_positives", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Number of false positives.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          Integer, the number of false positives.\n        \"\"\"", "\n", "key", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "if", "\"FP\"", "not", "in", "self", ".", "_results", "[", "key", "]", ":", "\n", "            ", "self", ".", "_results", "[", "key", "]", "[", "\"FP\"", "]", "=", "self", ".", "_num_confusionquadrant", "(", "\n", "0", ",", "1", ",", "protected", "\n", ")", "\n", "", "return", "self", ".", "_results", "[", "key", "]", "[", "\"FP\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_negatives": [[430, 447], ["metrics.ClassificationMetrics._get_key", "metrics.ClassificationMetrics._num_confusionquadrant"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._get_key", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._num_confusionquadrant"], ["", "def", "num_false_negatives", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Number of false negatives.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          Integer, the number of false negatives.\n        \"\"\"", "\n", "key", "=", "self", ".", "_get_key", "(", "protected", ")", "\n", "if", "\"FN\"", "not", "in", "self", ".", "_results", "[", "key", "]", ":", "\n", "            ", "self", ".", "_results", "[", "key", "]", "[", "\"FN\"", "]", "=", "self", ".", "_num_confusionquadrant", "(", "\n", "1", ",", "0", ",", "protected", "\n", ")", "\n", "", "return", "self", ".", "_results", "[", "key", "]", "[", "\"FN\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.true_positive_rate": [[448, 464], ["metrics.ClassificationMetrics.num_positives", "metrics.ClassificationMetrics.num_true_positives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_positives"], ["", "def", "true_positive_rate", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"True positive rate.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the true positive rate.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_positives", "(", "protected", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_true_positives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.true_negative_rate": [[465, 481], ["metrics.ClassificationMetrics.num_negatives", "metrics.ClassificationMetrics.num_true_negatives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_negatives"], ["", "", "def", "true_negative_rate", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"True negative rate.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the true negative rate.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_negatives", "(", "protected", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_true_negatives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.false_positive_rate": [[482, 498], ["metrics.ClassificationMetrics.num_negatives", "metrics.ClassificationMetrics.num_false_positives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_positives"], ["", "", "def", "false_positive_rate", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"False positive rate.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the false positive rate.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_negatives", "(", "protected", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_false_positives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.false_negative_rate": [[499, 515], ["metrics.ClassificationMetrics.num_negatives", "metrics.ClassificationMetrics.num_false_negatives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_negatives"], ["", "", "def", "false_negative_rate", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"false negative rate.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the false negative rate.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_negatives", "(", "protected", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_false_negatives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.positive_predictive_value": [[516, 536], ["metrics.ClassificationMetrics.num_true_positives", "metrics.ClassificationMetrics.num_false_positives", "metrics.ClassificationMetrics.num_true_positives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_positives"], ["", "", "def", "positive_predictive_value", "(", "\n", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", "\n", ")", "->", "float", ":", "\n", "        ", "\"\"\"Positive predictive value.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the positive predictive value.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_true_positives", "(", "protected", ")", "+", "self", ".", "num_false_positives", "(", "\n", "protected", "\n", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_true_positives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.negative_predictive_value": [[537, 557], ["metrics.ClassificationMetrics.num_true_negatives", "metrics.ClassificationMetrics.num_false_negatives", "metrics.ClassificationMetrics.num_true_negatives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_negatives"], ["", "", "def", "negative_predictive_value", "(", "\n", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", "\n", ")", "->", "float", ":", "\n", "        ", "\"\"\"Negative predictive value.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the negative predictive value.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_true_negatives", "(", "protected", ")", "+", "self", ".", "num_false_negatives", "(", "\n", "protected", "\n", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_true_negatives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.false_discovery_rate": [[558, 576], ["metrics.ClassificationMetrics.num_false_positives", "metrics.ClassificationMetrics.num_true_positives", "metrics.ClassificationMetrics.num_false_positives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_positives"], ["", "", "def", "false_discovery_rate", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"False discovery rate.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the false discovery rate.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_false_positives", "(", "protected", ")", "+", "self", ".", "num_true_positives", "(", "\n", "protected", "\n", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_false_positives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.false_omission_rate": [[577, 595], ["metrics.ClassificationMetrics.num_false_negatives", "metrics.ClassificationMetrics.num_true_negatives", "metrics.ClassificationMetrics.num_false_negatives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_negatives"], ["", "", "def", "false_omission_rate", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"False omission rate.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the false omission rate.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_false_negatives", "(", "protected", ")", "+", "self", ".", "num_true_negatives", "(", "\n", "protected", "\n", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_false_negatives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.accuracy": [[596, 615], ["metrics.ClassificationMetrics.num_positives", "metrics.ClassificationMetrics.num_negatives", "metrics.ClassificationMetrics.num_true_positives", "metrics.ClassificationMetrics.num_true_negatives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_negatives"], ["", "", "def", "accuracy", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Accuracy.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the accuracy.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_positives", "(", "protected", ")", "+", "self", ".", "num_negatives", "(", "protected", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "(", "\n", "self", ".", "num_true_positives", "(", "protected", ")", "\n", "+", "self", ".", "num_true_negatives", "(", "protected", ")", "\n", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.error_rate": [[616, 628], ["metrics.ClassificationMetrics.accuracy"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.accuracy"], ["", "", "def", "error_rate", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Error rate.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the error rate.\n        \"\"\"", "\n", "return", "1.0", "-", "self", ".", "accuracy", "(", "protected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.selection_rate": [[629, 645], ["metrics.ClassificationMetrics.num_individuals", "metrics.ClassificationMetrics.num_predicted_positives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_individuals", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_predicted_positives"], ["", "def", "selection_rate", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Selection rate.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the selection rate.\n        \"\"\"", "\n", "denom", "=", "self", ".", "num_individuals", "(", "protected", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "self", ".", "num_predicted_positives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.f1_score": [[646, 666], ["metrics.ClassificationMetrics.num_false_negatives", "metrics.ClassificationMetrics.num_false_positives", "metrics.ClassificationMetrics.num_true_positives", "metrics.ClassificationMetrics.num_true_positives"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_negatives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_false_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_positives", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.num_true_positives"], ["", "", "def", "f1_score", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"F1 score.\n\n        Args:\n          protected: Whether to condition on the protected group (True),\n              the unprotected group (False) or compute on the entire dataset\n              (None).\n\n        Returns:\n          float in [0, 1], the F1 score.\n        \"\"\"", "\n", "denom", "=", "(", "\n", "2", "*", "self", ".", "num_true_positives", "(", "protected", ")", "\n", "+", "self", ".", "num_false_positives", "(", "protected", ")", "\n", "+", "self", ".", "num_false_negatives", "(", "protected", ")", "\n", ")", "\n", "if", "denom", ">", "0", ":", "\n", "            ", "return", "2", "*", "self", ".", "num_true_positives", "(", "protected", ")", "/", "denom", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.precision": [[671, 674], ["metrics.ClassificationMetrics.positive_predictive_value"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.positive_predictive_value"], ["", "", "def", "precision", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Alias of `positive_predictive_value`.\"\"\"", "\n", "return", "self", ".", "positive_predictive_value", "(", "protected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.recall": [[675, 678], ["metrics.ClassificationMetrics.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.true_positive_rate"], ["", "def", "recall", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Alias of `true_positive_rate`.\"\"\"", "\n", "return", "self", ".", "true_positive_rate", "(", "protected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.fallout": [[679, 682], ["metrics.ClassificationMetrics.false_positive_rate"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.false_positive_rate"], ["", "def", "fallout", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Alias of `false_positive_rate`.\"\"\"", "\n", "return", "self", ".", "false_positive_rate", "(", "protected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.sensitivity": [[683, 686], ["metrics.ClassificationMetrics.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.true_positive_rate"], ["", "def", "sensitivity", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Alias of `true_positive_rate`.\"\"\"", "\n", "return", "self", ".", "true_positive_rate", "(", "protected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.specificity": [[687, 690], ["metrics.ClassificationMetrics.true_negative_rate"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.true_negative_rate"], ["", "def", "specificity", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Alias of `true_negative_rate`.\"\"\"", "\n", "return", "self", ".", "true_negative_rate", "(", "protected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.selectivity": [[691, 694], ["metrics.ClassificationMetrics.true_negative_rate"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.true_negative_rate"], ["", "def", "selectivity", "(", "self", ",", "protected", ":", "Optional", "[", "bool", "]", "=", "None", ")", "->", "float", ":", "\n", "        ", "\"\"\"Alias of `true_negative_rate`.\"\"\"", "\n", "return", "self", ".", "true_negative_rate", "(", "protected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.average_odds_difference": [[699, 704], ["metrics.ClassificationMetrics._difference", "metrics.ClassificationMetrics._difference"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._difference", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._difference"], ["", "def", "average_odds_difference", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"Average of the difference in FPR and TPR.\"\"\"", "\n", "return", "0.5", "*", "(", "\n", "self", ".", "_difference", "(", "self", ".", "false_positive_rate", ")", "\n", "+", "self", ".", "_difference", "(", "self", ".", "true_positive_rate", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.average_abs_odds_difference": [[706, 711], ["numpy.abs", "numpy.abs", "metrics.ClassificationMetrics._difference", "metrics.ClassificationMetrics._difference"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._difference", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._difference"], ["", "def", "average_abs_odds_difference", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"Average of the difference in FPR and TPR.\"\"\"", "\n", "return", "0.5", "*", "(", "\n", "np", ".", "abs", "(", "self", ".", "_difference", "(", "self", ".", "false_positive_rate", ")", ")", "\n", "+", "np", ".", "abs", "(", "self", ".", "_difference", "(", "self", ".", "true_positive_rate", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.error_rate_difference": [[713, 716], ["metrics.ClassificationMetrics._difference"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._difference"], ["", "def", "error_rate_difference", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"Difference in the error rate.\"\"\"", "\n", "return", "self", ".", "_difference", "(", "self", ".", "error_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.disparate_impact": [[717, 720], ["metrics.ClassificationMetrics._ratio"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._ratio"], ["", "def", "disparate_impact", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"Disparate impact: ratio of the fraciton of positive outcomes.\"\"\"", "\n", "return", "self", ".", "_ratio", "(", "self", ".", "selection_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.demographic_parity_difference": [[721, 724], ["metrics.ClassificationMetrics._difference"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._difference"], ["", "def", "demographic_parity_difference", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"Demographic parity: difference of fractions of positive outcomes.\"\"\"", "\n", "return", "self", ".", "_difference", "(", "self", ".", "selection_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics.equal_opportunity_difference": [[725, 728], ["metrics.ClassificationMetrics._difference"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.ClassificationMetrics._difference"], ["", "def", "equal_opportunity_difference", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"Difference in true positive rates.\"\"\"", "\n", "return", "self", ".", "_difference", "(", "self", ".", "true_positive_rate", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.get_data": [[10, 34], ["os.path.join", "data.whiten", "os.path.abspath", "data.format_compas_data", "RuntimeError", "numpy.concatenate", "s.astype", "s.reshape"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.whiten", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.format_compas_data"], ["def", "get_data", "(", "config", ")", ":", "\n", "    ", "\"\"\"\n    Retrieve a dataset.\n\n    Args:\n        config: Configuration dictionary.\n\n    Returns:\n        x, y, s\n    \"\"\"", "\n", "\n", "dataset", "=", "config", "[", "\"type\"", "]", "\n", "data_path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "config", "[", "\"path\"", "]", ")", ",", "dataset", ")", "\n", "protected", "=", "config", "[", "\"protected\"", "]", "\n", "\n", "if", "dataset", "==", "\"compas\"", ":", "\n", "        ", "x", ",", "y", ",", "s", "=", "format_compas_data", "(", "data_path", ")", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", "f\"Unknown dataset {dataset}.\"", ")", "\n", "\n", "", "if", "config", "[", "\"protected_as_feature\"", "]", ":", "\n", "        ", "x", "=", "np", ".", "concatenate", "(", "(", "x", ",", "s", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "", "x", "=", "whiten", "(", "x", ")", "\n", "return", "x", ",", "y", ",", "s", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.format_compas_data": [[36, 53], ["numpy.load", "data.to_zero_one", "data.to_zero_one"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.to_zero_one", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.to_zero_one"], ["", "def", "format_compas_data", "(", "data_path", ")", ":", "\n", "    ", "\"\"\"\n    Load and preprocess the compas dataset.\n\n    Args:\n        data_path: The path to the data set without extension.\n\n    Returns:\n        x, y, s\n    \"\"\"", "\n", "raw_data", "=", "np", ".", "load", "(", "data_path", "+", "\".npz\"", ")", "\n", "x", "=", "raw_data", "[", "\"X\"", "]", "\n", "y", "=", "raw_data", "[", "\"y\"", "]", "\n", "s", "=", "raw_data", "[", "\"Z\"", "]", "[", ":", ",", "0", "]", "\n", "y", "=", "to_zero_one", "(", "y", ")", "\n", "s", "=", "to_zero_one", "(", "s", ")", "\n", "return", "x", ",", "y", ",", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.whiten": [[58, 73], ["numpy.mean", "numpy.std", "numpy.arange"], "function", ["None"], ["", "def", "whiten", "(", "data", ",", "columns", "=", "None", ",", "conditioning", "=", "1e-8", ")", ":", "\n", "    ", "\"\"\"\n    Whiten various datasets in data dictionary.\n\n    Args:\n        data: Data array.\n        columns: The columns to whiten. If `None`, whiten all.\n        conditioning: Added to the denominator to avoid divison by zero.\n    \"\"\"", "\n", "if", "columns", "is", "None", ":", "\n", "        ", "columns", "=", "np", ".", "arange", "(", "data", ".", "shape", "[", "1", "]", ")", "\n", "", "mu", "=", "np", ".", "mean", "(", "data", "[", ":", ",", "columns", "]", ",", "0", ")", "\n", "std", "=", "np", ".", "std", "(", "data", "[", ":", ",", "columns", "]", ",", "0", ")", "\n", "data", "[", ":", ",", "columns", "]", "=", "(", "data", "[", ":", ",", "columns", "]", "-", "mu", ")", "/", "(", "std", "+", "conditioning", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.to_zero_one": [[75, 88], ["range", "len", "data.reshape.reshape", "numpy.unique", "data.reshape.squeeze", "len", "sorted"], "function", ["None"], ["", "def", "to_zero_one", "(", "data", ")", ":", "\n", "    ", "\"\"\"Transform all binary columns with +/- 1 values to 0/1.\"\"\"", "\n", "is_1d", "=", "False", "\n", "if", "len", "(", "data", ".", "shape", ")", "==", "1", ":", "\n", "        ", "data", "=", "data", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "is_1d", "=", "True", "\n", "", "for", "j", "in", "range", "(", "data", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "vals", "=", "np", ".", "unique", "(", "data", "[", ":", ",", "j", "]", ")", "\n", "if", "len", "(", "vals", ")", "==", "2", ":", "\n", "            ", "vals", "=", "sorted", "(", "vals", ")", "\n", "if", "vals", "[", "0", "]", "==", "-", "1", "and", "vals", "[", "1", "]", "==", "1", ":", "\n", "                ", "data", "[", ":", ",", "j", "]", "=", "(", "data", "[", ":", ",", "j", "]", "+", "1", "/", "2", ")", ".", "astype", "(", "int", ")", "\n", "", "", "", "return", "data", ".", "squeeze", "(", ")", "if", "is_1d", "else", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.__init__": [[9, 14], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the feature map.\n        \"\"\"", "\n", "self", ".", "n_components", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.__call__": [[15, 18], ["featuremaps.FeatureMapIdentity.transform"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.transform"], ["", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Apply the feature map.\"\"\"", "\n", "return", "self", ".", "transform", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.fit": [[19, 22], ["None"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "x", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\"Fit the feature map.\"\"\"", "\n", "self", ".", "n_components", "=", "x", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.transform": [[23, 26], ["None"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Transform the input.\"\"\"", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapRBF.__init__": [[29, 32], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "# TODO: could use random fourier features instead", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy.__init__": [[23, 40], ["strategies.BaseStrategy._init_parameters", "metrics.FairnessHistory", "metrics.FairnessHistory"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._init_parameters"], ["def", "__init__", "(", "self", ",", "td", ",", "config", ")", ":", "\n", "        ", "\"\"\"Instantiate a strategy.\"\"\"", "\n", "self", ".", "config", "=", "config", "\n", "self", ".", "td", "=", "td", "\n", "self", ".", "utility_opt", "=", "None", "\n", "self", ".", "_init_parameters", "(", ")", "\n", "self", ".", "deployed", "=", "{", "\n", "\"pis\"", ":", "[", "]", ",", "\n", "\"thresholds\"", ":", "[", "]", ",", "\n", "\"utilities\"", ":", "[", "]", ",", "\n", "\"reaped_utilities\"", ":", "[", "]", ",", "\n", "}", "\n", "monitored", "=", "self", ".", "config", "[", "\"results\"", "]", "[", "\"monitored\"", "]", "\n", "self", ".", "test_history", "=", "FairnessHistory", "(", "monitored", ")", "\n", "self", ".", "reaped_history", "=", "FairnessHistory", "(", "monitored", ")", "\n", "self", ".", "data_type", "=", "None", "\n", "self", ".", "policy_type", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._init_parameters": [[41, 58], ["float"], "methods", ["None"], ["", "def", "_init_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize shortcuts for often used parameters from the config.\"\"\"", "\n", "# Optimization parameters", "\n", "config_opt", "=", "self", ".", "config", "[", "\"optimization\"", "]", "\n", "self", ".", "config_opt", "=", "config_opt", "\n", "self", ".", "minibatches", "=", "config_opt", "[", "\"minibatches\"", "]", "\n", "self", ".", "batchsize", "=", "config_opt", "[", "\"batchsize\"", "]", "\n", "self", ".", "n_samples", "=", "self", ".", "minibatches", "*", "self", ".", "batchsize", "\n", "self", ".", "time_steps", "=", "config_opt", "[", "\"time_steps\"", "]", "\n", "self", ".", "epochs", "=", "config_opt", "[", "\"epochs\"", "]", "\n", "self", ".", "lr_init", "=", "float", "(", "config_opt", "[", "\"learning_rate\"", "]", ")", "\n", "self", ".", "fix_prop", "=", "config_opt", "[", "\"fix_proposed\"", "]", "\n", "# Misc parameters", "\n", "self", ".", "cost", "=", "self", ".", "config", "[", "\"utility\"", "]", "[", "\"cost\"", "]", "\n", "self", ".", "n_util_estim", "=", "self", ".", "config", "[", "\"utility\"", "]", "[", "\"n_samples_estimate\"", "]", "\n", "self", ".", "data_seeds", "=", "config_opt", "[", "\"data_seeds\"", "]", "\n", "self", ".", "max_data", "=", "config_opt", "[", "\"max_data\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._next_learning_rate_timestep": [[59, 65], ["float"], "methods", ["None"], ["", "def", "_next_learning_rate_timestep", "(", "self", ",", "lr", ",", "t", ")", ":", "\n", "        ", "\"\"\"Return new learning rate for time steps.\"\"\"", "\n", "if", "(", "t", "+", "1", ")", "%", "self", ".", "config_opt", "[", "\"lr_frequency\"", "]", "==", "0", ":", "\n", "            ", "return", "lr", "*", "float", "(", "self", ".", "config_opt", "[", "\"lr_factor\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._next_learning_rate_epoch": [[66, 72], ["float"], "methods", ["None"], ["", "", "def", "_next_learning_rate_epoch", "(", "self", ",", "lr", ",", "t", ")", ":", "\n", "        ", "\"\"\"Return new learning rate for epoch.\"\"\"", "\n", "if", "(", "t", "+", "1", ")", "%", "self", ".", "config_opt", "[", "\"e_lr_frequency\"", "]", "==", "0", ":", "\n", "            ", "return", "lr", "*", "float", "(", "self", ".", "config_opt", "[", "\"e_lr_factor\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._record_snapshot": [[73, 115], ["strategies.BaseStrategy.deployed[].append", "strategies.BaseStrategy.td.sample_all", "strategies.BaseStrategy.test_history.snapshot", "strategies.BaseStrategy.deployed[].append", "utils.utility", "utils.get_threshold", "pi.sample", "ytest.copy", "strategies.BaseStrategy.deployed[].append", "strategies.BaseStrategy.reaped_history.snapshot", "policies.LogisticPolicy", "strategies.BaseStrategy.deployed[].append", "strategies.BaseStrategy.deployed[].append", "numpy.sum", "policies.DeterministicThreshold", "strategies.BaseStrategy.deployed[].append", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.FairnessHistory.snapshot", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.utility", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.get_threshold", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.sample", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.copy", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.metrics.FairnessHistory.snapshot"], ["", "", "def", "_record_snapshot", "(", "self", ",", "pi", ",", "yprop", ",", "sprop", ",", "d", ")", ":", "\n", "        ", "\"\"\"Compute snapshot of policy and append to current history.\"\"\"", "\n", "# policy", "\n", "if", "self", ".", "policy_type", "==", "\"logistic\"", ":", "\n", "            ", "self", ".", "deployed", "[", "\"pis\"", "]", ".", "append", "(", "LogisticPolicy", "(", "pi", ",", "self", ".", "cost", ")", ")", "\n", "", "elif", "self", ".", "policy_type", "==", "\"deterministic\"", ":", "\n", "            ", "self", ".", "deployed", "[", "\"pis\"", "]", ".", "append", "(", "DeterministicThreshold", "(", "pi", ",", "self", ".", "cost", ")", ")", "\n", "", "elif", "self", ".", "policy_type", "==", "\"fixed\"", ":", "\n", "            ", "self", ".", "deployed", "[", "\"pis\"", "]", ".", "append", "(", "pi", ")", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "f\"Cannot record full snapshot for policy {self.policy_type}\"", "\n", ")", "\n", "# utility", "\n", "", "if", "pi", "is", "not", "None", ":", "\n", "            ", "utility", "=", "utils", ".", "utility", "(", "self", ".", "td", ",", "pi", ",", "self", ".", "cost", ",", "self", ".", "n_util_estim", ")", "\n", "", "else", ":", "\n", "            ", "utility", "=", "np", ".", "nan", "\n", "", "self", ".", "deployed", "[", "\"utilities\"", "]", ".", "append", "(", "utility", ")", "\n", "# threshold", "\n", "if", "pi", "is", "not", "None", ":", "\n", "            ", "if", "\"deterministic\"", "in", "pi", ".", "type", ":", "\n", "                ", "tmp_cost", "=", "self", ".", "cost", "\n", "", "else", ":", "\n", "                ", "tmp_cost", "=", "None", "\n", "", "threshold", "=", "utils", ".", "get_threshold", "(", "pi", ".", "theta", ",", "tmp_cost", ")", "\n", "if", "threshold", "is", "not", "None", ":", "\n", "                ", "self", ".", "deployed", "[", "\"thresholds\"", "]", ".", "append", "(", "threshold", ")", "\n", "# test metrics", "\n", "", "", "xtest", ",", "ytest", ",", "stest", "=", "self", ".", "td", ".", "sample_all", "(", "self", ".", "n_util_estim", ")", "\n", "if", "pi", "is", "not", "None", ":", "\n", "            ", "dtest", "=", "pi", ".", "sample", "(", "xtest", ")", "\n", "", "else", ":", "\n", "            ", "dtest", "=", "ytest", ".", "copy", "(", ")", "\n", "", "self", ".", "test_history", ".", "snapshot", "(", "ytest", ",", "dtest", ",", "stest", ")", "\n", "# reaped utility and metrics", "\n", "if", "yprop", "is", "not", "None", "and", "sprop", "is", "not", "None", "and", "d", "is", "not", "None", ":", "\n", "# reaped utility", "\n", "            ", "reaped_utility", "=", "np", ".", "sum", "(", "yprop", "[", "d", "]", "-", "self", ".", "cost", ")", "/", "self", ".", "n_samples", "\n", "self", ".", "deployed", "[", "\"reaped_utilities\"", "]", ".", "append", "(", "reaped_utility", ")", "\n", "# reaped metrics", "\n", "self", ".", "reaped_history", ".", "snapshot", "(", "yprop", ",", "d", ",", "sprop", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._initialize_data_buffers": [[116, 142], ["numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "RuntimeError"], "methods", ["None"], ["", "", "def", "_initialize_data_buffers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Allocate memory buffers to keep data when training on all data.\"\"\"", "\n", "if", "self", ".", "data_type", "==", "\"all\"", ":", "\n", "            ", "if", "self", ".", "fix_prop", ":", "\n", "                ", "self", ".", "x_buf", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "td", ".", "feature_dim", ")", ",", "dtype", "=", "float", ")", "\n", "self", ".", "y_buf", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "float", ")", "\n", "self", ".", "s_buf", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "int", ")", "\n", "self", ".", "w_buf", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "float", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "x_buf", "=", "np", ".", "zeros", "(", "\n", "(", "self", ".", "n_samples", "*", "self", ".", "time_steps", ",", "self", ".", "td", ".", "feature_dim", ")", ",", "\n", "dtype", "=", "float", ",", "\n", ")", "\n", "self", ".", "y_buf", "=", "np", ".", "zeros", "(", "\n", "self", ".", "n_samples", "*", "self", ".", "time_steps", ",", "dtype", "=", "float", "\n", ")", "\n", "self", ".", "s_buf", "=", "np", ".", "zeros", "(", "\n", "self", ".", "n_samples", "*", "self", ".", "time_steps", ",", "dtype", "=", "int", "\n", ")", "\n", "self", ".", "w_buf", "=", "np", ".", "zeros", "(", "\n", "self", ".", "n_samples", "*", "self", ".", "time_steps", ",", "dtype", "=", "float", "\n", ")", "\n", "", "", "elif", "self", ".", "data_type", "==", "\"recent\"", ":", "\n", "            ", "self", ".", "x_buf", ",", "self", ".", "y_buf", ",", "self", ".", "s_buf", "=", "None", ",", "None", ",", "None", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"Invalid data_type {self.data_type}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._update_data_buffers": [[143, 175], ["numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "strategies.BaseStrategy._warn_if_few_minibatches", "RuntimeError", "numpy.concatenate", "strategies.BaseStrategy._warn_if_few_minibatches"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._warn_if_few_minibatches", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._warn_if_few_minibatches"], ["", "", "def", "_update_data_buffers", "(", "self", ",", "x", ",", "y", ",", "s", ",", "weights", ",", "t", ",", "accepted", ")", ":", "\n", "        ", "\"\"\"Update the internal databuffers with data to be used next.\"\"\"", "\n", "if", "self", ".", "data_type", "==", "\"all\"", ":", "\n", "            ", "if", "self", ".", "fix_prop", ":", "\n", "                ", "self", ".", "x_buf", "=", "np", ".", "concatenate", "(", "(", "self", ".", "x_buf", ",", "x", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "y_buf", "=", "np", ".", "concatenate", "(", "(", "self", ".", "y_buf", ",", "y", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "s_buf", "=", "np", ".", "concatenate", "(", "(", "self", ".", "s_buf", ",", "s", ")", ",", "axis", "=", "0", ")", "\n", "if", "weights", "is", "not", "None", ":", "\n", "                    ", "self", ".", "w_buf", "=", "np", ".", "concatenate", "(", "(", "self", ".", "w_buf", ",", "weights", ")", ",", "axis", "=", "0", ")", "\n", "", "if", "self", ".", "x_buf", ".", "shape", "[", "0", "]", ">", "self", ".", "max_data", ":", "\n", "                    ", "self", ".", "x_buf", "=", "self", ".", "x_buf", "[", "-", "self", ".", "max_data", ":", "]", "\n", "self", ".", "y_buf", "=", "self", ".", "y_buf", "[", "-", "self", ".", "max_data", ":", "]", "\n", "self", ".", "s_buf", "=", "self", ".", "s_buf", "[", "-", "self", ".", "max_data", ":", "]", "\n", "if", "weights", "is", "not", "None", ":", "\n", "                        ", "self", ".", "w_buf", "=", "self", ".", "w_buf", "[", "-", "self", ".", "max_data", ":", "]", "\n", "", "", "n_total", "=", "self", ".", "x_buf", ".", "shape", "[", "0", "]", "\n", "\n", "", "else", ":", "\n", "                ", "self", ".", "x_buf", "[", "t", "*", "accepted", ":", "(", "t", "+", "1", ")", "*", "accepted", ",", ":", "]", "=", "x", "\n", "self", ".", "y_buf", "[", "t", "*", "accepted", ":", "(", "t", "+", "1", ")", "*", "accepted", "]", "=", "y", "\n", "self", ".", "s_buf", "[", "t", "*", "accepted", ":", "(", "t", "+", "1", ")", "*", "accepted", "]", "=", "s", "\n", "if", "weights", "is", "not", "None", ":", "\n", "                    ", "self", ".", "w_buf", "[", "t", "*", "accepted", ":", "(", "t", "+", "1", ")", "*", "accepted", "]", "=", "weights", "\n", "", "n_total", "=", "(", "t", "+", "1", ")", "*", "accepted", "\n", "", "if", "self", ".", "policy_type", "==", "\"logistic\"", ":", "\n", "                ", "self", ".", "_warn_if_few_minibatches", "(", "n_total", ")", "\n", "", "", "elif", "self", ".", "data_type", "==", "\"recent\"", ":", "\n", "            ", "self", ".", "x_buf", ",", "self", ".", "y_buf", ",", "self", ".", "s_buf", "=", "x", ",", "y", ",", "s", "\n", "if", "self", ".", "policy_type", "==", "\"logistic\"", ":", "\n", "                ", "self", ".", "_warn_if_few_minibatches", "(", "accepted", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"Invalid data_type {self.data_type}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._warn_if_few_minibatches": [[176, 181], ["float", "logzero.logger.warning"], "methods", ["None"], ["", "", "def", "_warn_if_few_minibatches", "(", "self", ",", "n_data", ")", ":", "\n", "        ", "\"\"\"Log a warning message if we are working with little data.\"\"\"", "\n", "minibatches", "=", "float", "(", "n_data", ")", "/", "self", ".", "batchsize", "\n", "if", "minibatches", "<", "1", ":", "\n", "            ", "logger", ".", "warning", "(", "\"single minibatch:\"", "f\"{n_data} / {self.batchsize}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._merge_and_convert_results": [[182, 192], ["strategies.BaseStrategy.deployed.items", "strategies.BaseStrategy.test_history.history.items", "strategies.BaseStrategy.reaped_history.history.items", "numpy.array"], "methods", ["None"], ["", "", "def", "_merge_and_convert_results", "(", "self", ")", ":", "\n", "        ", "\"\"\"Convert the stored list of snapshot to data into numpy arrays.\"\"\"", "\n", "for", "k", ",", "v", "in", "self", ".", "deployed", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "!=", "\"pis\"", ":", "\n", "                ", "self", ".", "deployed", "[", "k", "]", "=", "np", ".", "array", "(", "v", ")", "\n", "", "", "for", "k", ",", "v", "in", "self", ".", "test_history", ".", "history", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "deployed", "[", "\"test_\"", "+", "k", "]", "=", "v", "\n", "", "for", "k", ",", "v", "in", "self", ".", "reaped_history", ".", "history", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "deployed", "[", "\"reaped_\"", "+", "k", "]", "=", "v", "\n", "", "return", "self", ".", "deployed", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy.train": [[193, 196], ["NotImplementedError"], "methods", ["None"], ["", "def", "train", "(", "self", ",", "pi", ")", ":", "\n", "        ", "\"\"\"Train the given policy according to the strategy.\"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Subclass must override `train`.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.UnrollStaticPolicy.__init__": [[205, 221], ["strategies.BaseStrategy.__init__"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "td", ",", "config", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a strategy that just rolls out a non-learning policy.\n\n        If there the policy fed into the train function is None, the labels\n        from the ground truth distribution will be used, i.e., the\n        UnrollStaticPolicy unrolls a ground truth oracle that knows the outcome\n        ahead of the decision.\n\n        Args:\n            td: Ground truth distribution.\n            config: The configuration dictionary.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "td", ",", "config", ")", "\n", "self", ".", "policy_type", "=", "\"fixed\"", "\n", "self", ".", "data_type", "=", "\"recent\"", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.UnrollStaticPolicy.train": [[222, 247], ["strategies.UnrollStaticPolicy._record_snapshot", "tqdm.tqdm.tqdm", "strategies.UnrollStaticPolicy._merge_and_convert_results", "range", "utils.collect_data", "len", "strategies.UnrollStaticPolicy._record_snapshot", "logzero.logger.warning"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._record_snapshot", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._merge_and_convert_results", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.collect_data", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._record_snapshot"], ["", "def", "train", "(", "self", ",", "pi", ")", ":", "\n", "        ", "self", ".", "_record_snapshot", "(", "pi", ",", "None", ",", "None", ",", "None", ")", "\n", "\n", "for", "t", "in", "tqdm", "(", "range", "(", "self", ".", "time_steps", ")", ")", ":", "\n", "\n", "            ", "xprop", ",", "yprop", ",", "sprop", ",", "d", "=", "utils", ".", "collect_data", "(", "\n", "self", ".", "td", ",", "\n", "self", ".", "n_samples", ",", "\n", "policy", "=", "pi", ",", "\n", "fix_proposed", "=", "self", ".", "fix_prop", ",", "\n", "random_state", "=", "self", ".", "data_seeds", "[", "t", "]", ",", "\n", ")", "\n", "_", ",", "y", ",", "_", "=", "xprop", "[", "d", "]", ",", "yprop", "[", "d", "]", ",", "sprop", "[", "d", "]", "\n", "\n", "# the oracle", "\n", "if", "pi", "is", "None", ":", "\n", "                ", "d", "=", "y", "==", "1", "\n", "y", "=", "y", "[", "d", "]", "\n", "\n", "", "accepted", "=", "len", "(", "y", ")", "\n", "if", "accepted", "<", "1", ":", "\n", "                ", "logger", ".", "warning", "(", "f\"0 accepted; continue\"", ")", "\n", "\n", "", "self", ".", "_record_snapshot", "(", "pi", ",", "yprop", ",", "sprop", ",", "d", ")", "\n", "", "return", "self", ".", "_merge_and_convert_results", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy.__init__": [[260, 265], ["strategies.BaseStrategy.__init__"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__"], ["def", "__init__", "(", "self", ",", "td", ",", "config", ",", "data_type", ")", ":", "\n", "        ", "\"\"\"Initialize the strategy.\"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "td", ",", "config", ")", "\n", "self", ".", "data_type", "=", "data_type", "\n", "self", ".", "policy_type", "=", "\"logistic\"", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy.train": [[266, 323], ["strategies.IPSStrategy._initialize_data_buffers", "strategies.IPSStrategy._record_snapshot", "tqdm.tqdm.tqdm", "strategies.IPSStrategy._merge_and_convert_results", "range", "strategies.IPSStrategy._next_learning_rate_timestep", "utils.collect_data", "len", "strategies.IPSStrategy._record_snapshot", "strategies.IPSStrategy._get_weights", "logzero.logger.warning", "strategies.IPSStrategy._update_data_buffers", "len", "min", "range", "strategies.IPSStrategy._next_learning_rate_epoch", "range", "numpy.random.permutation", "min", "strategies.IPSStrategy._grad_utility"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._initialize_data_buffers", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._record_snapshot", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._merge_and_convert_results", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._next_learning_rate_timestep", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.collect_data", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._record_snapshot", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy._get_weights", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._update_data_buffers", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._next_learning_rate_epoch", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy._grad_utility"], ["", "def", "train", "(", "self", ",", "pi", ")", ":", "\n", "        ", "lr_timestep", "=", "self", ".", "lr_init", "\n", "self", ".", "_initialize_data_buffers", "(", ")", "\n", "self", ".", "_record_snapshot", "(", "pi", ",", "None", ",", "None", ",", "None", ")", "\n", "\n", "for", "t", "in", "tqdm", "(", "range", "(", "self", ".", "time_steps", ")", ")", ":", "\n", "            ", "lr_timestep", "=", "self", ".", "_next_learning_rate_timestep", "(", "lr_timestep", ",", "t", ")", "\n", "\n", "# collect new data", "\n", "xprop", ",", "yprop", ",", "sprop", ",", "d", "=", "utils", ".", "collect_data", "(", "\n", "self", ".", "td", ",", "\n", "self", ".", "n_samples", ",", "\n", "policy", "=", "self", ".", "deployed", "[", "\"pis\"", "]", "[", "t", "]", ",", "\n", "fix_proposed", "=", "self", ".", "fix_prop", ",", "\n", "random_state", "=", "self", ".", "data_seeds", "[", "t", "]", ",", "\n", ")", "\n", "x", ",", "y", ",", "s", "=", "xprop", "[", "d", "]", ",", "yprop", "[", "d", "]", ",", "sprop", "[", "d", "]", "\n", "\n", "if", "self", ".", "data_type", "==", "\"all\"", ":", "\n", "                ", "w", "=", "self", ".", "_get_weights", "(", "x", ",", "self", ".", "deployed", "[", "\"pis\"", "]", "[", "t", "]", ")", "\n", "", "else", ":", "\n", "                ", "w", "=", "None", "\n", "", "accepted", "=", "len", "(", "y", ")", "\n", "\n", "if", "accepted", "<", "1", ":", "\n", "# didn't get any data, continue", "\n", "                ", "logger", ".", "warning", "(", "f\"0 accepted; continue\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_update_data_buffers", "(", "x", ",", "y", ",", "s", ",", "w", ",", "t", ",", "accepted", ")", "\n", "train_size", "=", "len", "(", "self", ".", "y_buf", ")", "\n", "use_data", "=", "min", "(", "train_size", ",", "self", ".", "batchsize", "*", "self", ".", "minibatches", ")", "\n", "\n", "# epochs", "\n", "lr_epoch", "=", "lr_timestep", "\n", "for", "e", "in", "range", "(", "self", ".", "epochs", ")", ":", "\n", "                    ", "lr_epoch", "=", "self", ".", "_next_learning_rate_epoch", "(", "lr_epoch", ",", "e", ")", "\n", "perm", "=", "np", ".", "random", ".", "permutation", "(", "train_size", ")", "[", ":", "use_data", "]", "\n", "xp", "=", "self", ".", "x_buf", "[", "perm", "]", "\n", "yp", "=", "self", ".", "y_buf", "[", "perm", "]", "\n", "sp", "=", "self", ".", "s_buf", "[", "perm", "]", "\n", "if", "self", ".", "data_type", "==", "\"all\"", ":", "\n", "                        ", "wp", "=", "self", ".", "w_buf", "[", "perm", "]", "\n", "# minibatches", "\n", "", "for", "i1", "in", "range", "(", "0", ",", "use_data", ",", "self", ".", "batchsize", ")", ":", "\n", "                        ", "i2", "=", "min", "(", "i1", "+", "self", ".", "batchsize", ",", "use_data", ")", "\n", "xb", ",", "yb", ",", "sb", "=", "xp", "[", "i1", ":", "i2", "]", ",", "yp", "[", "i1", ":", "i2", "]", ",", "sp", "[", "i1", ":", "i2", "]", "\n", "wb", "=", "None", "if", "self", ".", "data_type", "!=", "\"all\"", "else", "wp", "[", "i1", ":", "i2", "]", "\n", "# gradient step", "\n", "grad", "=", "self", ".", "_grad_utility", "(", "\n", "(", "xb", ",", "yb", ",", "sb", ")", ",", "\n", "pi", ",", "\n", "self", ".", "deployed", "[", "\"pis\"", "]", "[", "t", "]", ",", "\n", "weights", "=", "wb", ",", "\n", ")", "\n", "pi", ".", "theta", "+=", "lr_epoch", "*", "grad", "\n", "", "", "", "self", ".", "_record_snapshot", "(", "pi", ",", "yprop", ",", "sprop", ",", "d", ")", "\n", "", "return", "self", ".", "_merge_and_convert_results", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy._grad_utility": [[324, 387], ["cur_policy.fm", "cur_policy.sample", "strategies.IPSStrategy._mean_difference", "numpy.exp", "numpy.ones_like", "numpy.exp", "numpy.sum", "strategies.IPSStrategy._mean_difference", "numpy.matmul", "ValueError", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.sample", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy._mean_difference", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy._mean_difference"], ["", "def", "_grad_utility", "(", "self", ",", "sample", ",", "cur_policy", ",", "sample_policy", ",", "weights", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Estimate the gradient of the objective (i.e., utility plus fairness term\n        if present) wrt the parameters of a logistic or semi_logistic policy\n        from a given sample.\n\n        Args:\n            sample: A data sample tuple (x, y, s) consisting of features, labels,\n                and protected attribute\n            cur_policy: The current policy with respect to which the gradient of the\n                utility is computed.\n            sample_policy: The policy under which the data `sample` was collected.\n            weights: Either None or weights from sampling policy are provided.\n\n        Returns:\n            The gradient (np.ndarray)\n        \"\"\"", "\n", "x", ",", "y", ",", "s", "=", "sample", "\n", "phi", "=", "cur_policy", ".", "fm", "(", "x", ")", "\n", "d", "=", "cur_policy", ".", "sample", "(", "x", ")", "\n", "\n", "# Common denominator from the score function of the current policy", "\n", "denom", "=", "1.0", "+", "np", ".", "exp", "(", "np", ".", "matmul", "(", "phi", ",", "cur_policy", ".", "theta", ")", ")", "\n", "\n", "# If recent: numerator from reweighting by previous induced policy", "\n", "if", "weights", "is", "None", ":", "\n", "            ", "weights", "=", "np", ".", "ones_like", "(", "denom", ")", "\n", "sample_exp", "=", "np", ".", "exp", "(", "-", "np", ".", "matmul", "(", "phi", ",", "sample_policy", ".", "theta", ")", ")", "\n", "if", "cur_policy", ".", "type", "==", "\"semi_logistic\"", ":", "\n", "                ", "weights", "[", "sample_exp", ">=", "1", "]", "*=", "1.0", "+", "sample_exp", "[", "sample_exp", ">=", "1", "]", "\n", "", "else", ":", "\n", "                ", "weights", "=", "1.0", "+", "sample_exp", "\n", "\n", "# Each gradient term has d / denom in it", "\n", "", "", "tmp", "=", "d", "/", "denom", "\n", "if", "cur_policy", ".", "type", "==", "\"semi_logistic\"", ":", "\n", "# Checking whether p >= 0.5 is same as x >= 0 is same as 1 + exp >= 2", "\n", "            ", "tmp", "[", "denom", ">=", "2", "]", "=", "0.0", "\n", "\n", "# Gradient of utility", "\n", "", "grad_util", "=", "(", "y", "-", "self", ".", "cost", ")", "*", "tmp", "\n", "grad_util", "*=", "weights", "\n", "grad_util", "=", "np", ".", "sum", "(", "phi", "*", "grad_util", "[", ":", ",", "np", ".", "newaxis", "]", ",", "axis", "=", "0", ")", "/", "x", ".", "shape", "[", "0", "]", "\n", "\n", "if", "self", ".", "config", "[", "\"fairness\"", "]", "is", "None", ":", "\n", "            ", "return", "grad_util", "\n", "\n", "# Difference of benefit terms themselves (with weights, no denom)", "\n", "", "benefit_difference", "=", "self", ".", "_mean_difference", "(", "d", "*", "weights", ",", "s", ")", "\n", "\n", "# Gradient of benefit term", "\n", "if", "self", ".", "config", "[", "\"fairness\"", "]", "==", "\"demographic_parity\"", ":", "\n", "            ", "tmp_ben", "=", "tmp", "\n", "", "elif", "self", ".", "config", "[", "\"fairness\"", "]", "==", "\"equal_opportunity\"", ":", "\n", "            ", "tmp_ben", "=", "y", "*", "tmp", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Unknown fairness: {self.config['fairness']}.\"", ")", "\n", "# The difference of the gradients", "\n", "", "grad_ben", "=", "tmp_ben", "*", "weights", "\n", "grad_ben", "=", "phi", "*", "grad_ben", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "grad_ben", "=", "benefit_difference", "*", "self", ".", "_mean_difference", "(", "grad_ben", ",", "s", ")", "\n", "\n", "return", "grad_util", "-", "self", ".", "config", "[", "\"lambda\"", "]", "*", "grad_ben", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy._mean_difference": [[388, 396], ["numpy.sum", "numpy.sum", "numpy.zeros", "numpy.sum", "numpy.sum"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_mean_difference", "(", "val", ",", "s", ")", ":", "\n", "        ", "mask0", ",", "mask1", "=", "s", "==", "0", ",", "s", "==", "1", "\n", "n0", ",", "n1", "=", "np", ".", "sum", "(", "mask0", ")", ",", "np", ".", "sum", "(", "mask1", ")", "\n", "if", "n0", "==", "0", "or", "n1", "==", "0", ":", "\n", "            ", "return", "0.0", "if", "val", ".", "ndim", "==", "1", "else", "np", ".", "zeros", "(", "val", ".", "shape", "[", "-", "1", "]", ")", "\n", "", "return", "(", "\n", "np", ".", "sum", "(", "val", "[", "mask0", "]", ",", "axis", "=", "0", ")", "/", "n0", "-", "np", ".", "sum", "(", "val", "[", "mask1", "]", ",", "axis", "=", "0", ")", "/", "n1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.IPSStrategy._get_weights": [[398, 409], ["sample_policy.fm", "numpy.exp", "numpy.ones_like", "numpy.matmul"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_weights", "(", "x", ",", "sample_policy", ")", ":", "\n", "        ", "\"\"\"Get the weight factors for some examples under a given policy.\"\"\"", "\n", "phi", "=", "sample_policy", ".", "fm", "(", "x", ")", "\n", "sample_exp", "=", "np", ".", "exp", "(", "-", "np", ".", "matmul", "(", "phi", ",", "sample_policy", ".", "theta", ")", ")", "\n", "weights", "=", "np", ".", "ones_like", "(", "sample_exp", ")", "\n", "if", "sample_policy", ".", "type", "==", "\"semi_logistic\"", ":", "\n", "            ", "weights", "[", "sample_exp", ">=", "1", "]", "*=", "1.0", "+", "sample_exp", "[", "sample_exp", ">=", "1", "]", "\n", "", "else", ":", "\n", "            ", "weights", "=", "1.0", "+", "sample_exp", "\n", "", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.PredictiveStrategy.__init__": [[423, 428], ["strategies.BaseStrategy.__init__"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__"], ["def", "__init__", "(", "self", ",", "td", ",", "config", ",", "data_type", ")", ":", "\n", "        ", "\"\"\"Initialize the strategy.\"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "td", ",", "config", ")", "\n", "self", ".", "data_type", "=", "data_type", "\n", "self", ".", "policy_type", "=", "\"deterministic\"", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.PredictiveStrategy.train": [[429, 465], ["strategies.PredictiveStrategy._initialize_data_buffers", "strategies.PredictiveStrategy._record_snapshot", "tqdm.tqdm.tqdm", "strategies.PredictiveStrategy._merge_and_convert_results", "range", "utils.collect_data", "len", "strategies.PredictiveStrategy._record_snapshot", "logzero.logger.warning", "strategies.PredictiveStrategy._update_data_buffers", "len", "min", "numpy.random.choice", "pi.set_theta", "numpy.array", "logzero.logger.info", "utils.fit_logit"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._initialize_data_buffers", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._record_snapshot", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._merge_and_convert_results", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.collect_data", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._record_snapshot", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.strategies.BaseStrategy._update_data_buffers", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.BasePolicy.set_theta", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.fit_logit"], ["", "def", "train", "(", "self", ",", "pi", ")", ":", "\n", "        ", "self", ".", "_initialize_data_buffers", "(", ")", "\n", "self", ".", "_record_snapshot", "(", "pi", ",", "None", ",", "None", ",", "None", ")", "\n", "\n", "for", "t", "in", "tqdm", "(", "range", "(", "self", ".", "time_steps", ")", ")", ":", "\n", "# collect new data", "\n", "            ", "xprop", ",", "yprop", ",", "sprop", ",", "d", "=", "utils", ".", "collect_data", "(", "\n", "self", ".", "td", ",", "\n", "self", ".", "n_samples", ",", "\n", "policy", "=", "self", ".", "deployed", "[", "\"pis\"", "]", "[", "t", "]", ",", "\n", "fix_proposed", "=", "self", ".", "fix_prop", ",", "\n", "random_state", "=", "self", ".", "data_seeds", "[", "t", "]", ",", "\n", ")", "\n", "x", ",", "y", ",", "s", "=", "xprop", "[", "d", "]", ",", "yprop", "[", "d", "]", ",", "sprop", "[", "d", "]", "\n", "\n", "accepted", "=", "len", "(", "y", ")", "\n", "if", "accepted", "<", "1", ":", "\n", "# didn't get any data, continue", "\n", "                ", "logger", ".", "warning", "(", "f\"0 accepted; continue\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_update_data_buffers", "(", "x", ",", "y", ",", "s", ",", "None", ",", "t", ",", "accepted", ")", "\n", "train_size", "=", "len", "(", "self", ".", "y_buf", ")", "\n", "use_data", "=", "min", "(", "train_size", ",", "self", ".", "batchsize", "*", "self", ".", "minibatches", ")", "\n", "perm", "=", "np", ".", "random", ".", "choice", "(", "train_size", ",", "use_data", ",", "replace", "=", "False", ")", "\n", "# update logistic model in pi", "\n", "try", ":", "\n", "                    ", "pi", ".", "set_theta", "(", "\n", "np", ".", "array", "(", "\n", "utils", ".", "fit_logit", "(", "self", ".", "x_buf", "[", "perm", "]", ",", "self", ".", "y_buf", "[", "perm", "]", ")", "\n", ")", "\n", ")", "\n", "", "except", "(", "PerfectSeparationError", ",", "LinAlgError", ")", "as", "err", ":", "\n", "                    ", "logger", ".", "info", "(", "f\"Error in LogReg: {err}\"", ")", "\n", "\n", "", "", "self", ".", "_record_snapshot", "(", "pi", ",", "yprop", ",", "sprop", ",", "d", ")", "\n", "", "return", "self", ".", "_merge_and_convert_results", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.plotters.plot_models": [[51, 111], ["matplotlib.pyplot.figure", "int", "matplotlib.pyplot.cm.viridis", "td.sample_all", "numpy.argsort", "range", "hasattr", "matplotlib.pyplot.legend", "matplotlib.pyplot.tight_layout", "RuntimeError", "RuntimeError", "numpy.linspace", "matplotlib.pyplot.plot", "td.threshold", "matplotlib.pyplot.axvline", "os.path.abspath", "matplotlib.pyplot.savefig", "matplotlib.pyplot.show", "utils.sigmoid", "matplotlib.pyplot.axvline", "os.path.join", "utils.get_threshold"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.threshold", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.sigmoid", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.get_threshold"], ["def", "plot_models", "(", "\n", "thetas", ",", "td", ",", "cost", "=", "None", ",", "save", "=", "True", ",", "path", "=", "None", ",", "suff", "=", "\"\"", ",", "points", "=", "100", "\n", ")", ":", "\n", "    ", "\"\"\"Plot the decision functions of various logistic models in 1D.\n\n    Args:\n        thetas: List of parameters of various models.\n        td: The true distribution.\n        cost: Cost factor (if deterministic policy).\n        save: Whether to store the figure to disk.\n        path: The path where to save the figure (only if `save=True`).\n        suff: Optional suffix for the file name.\n        points: How many points to use for the plot.\n    \"\"\"", "\n", "if", "save", "and", "path", "is", "None", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Need path to save figure.\"", ")", "\n", "", "if", "thetas", ".", "shape", "[", "1", "]", "!=", "2", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Can only plot decision functions in 1D.\"", ")", "\n", "", "if", "cost", "is", "None", ":", "\n", "        ", "cost", "=", "0.5", "\n", "\n", "", "plt", ".", "figure", "(", ")", "\n", "\n", "n_models", "=", "thetas", ".", "shape", "[", "0", "]", "\n", "skip", "=", "int", "(", "n_models", "//", "20", ")", "\n", "if", "skip", "==", "0", ":", "\n", "        ", "skip", "=", "1", "\n", "", "colors", "=", "plt", ".", "cm", ".", "viridis", "(", "np", ".", "linspace", "(", "0", ",", "1", ",", "n_models", ")", ")", "\n", "x", ",", "_", ",", "_", "=", "td", ".", "sample_all", "(", "points", ")", "\n", "perm", "=", "np", ".", "argsort", "(", "x", "[", ":", ",", "1", "]", ")", "\n", "x", "=", "x", "[", "perm", "]", "\n", "for", "i", "in", "range", "(", "n_models", ")", ":", "\n", "        ", "plt", ".", "plot", "(", "\n", "x", "[", ":", ",", "1", "]", ",", "\n", "sigmoid", "(", "thetas", "[", "i", ",", ":", "]", "@", "x", ".", "T", ")", ",", "\n", "color", "=", "colors", "[", "i", "]", ",", "\n", "lw", "=", "0.7", ",", "\n", "label", "=", "(", "f\"t={i}\"", "if", "i", "in", "[", "0", ",", "n_models", "-", "1", "]", "else", "None", ")", ",", "\n", ")", "\n", "if", "i", "%", "skip", "==", "0", "or", "i", "in", "[", "0", ",", "n_models", "-", "1", "]", ":", "\n", "            ", "plt", ".", "axvline", "(", "\n", "x", "=", "get_threshold", "(", "thetas", "[", "i", "]", ",", "cost", ")", ",", "\n", "ls", "=", "\"dashed\"", ",", "\n", "alpha", "=", "0.5", ",", "\n", "c", "=", "colors", "[", "i", "]", ",", "\n", "lw", "=", "0.7", ",", "\n", ")", "\n", "", "", "if", "hasattr", "(", "td", ",", "\"threshold\"", ")", ":", "\n", "        ", "opt_thresh", "=", "td", ".", "threshold", "(", "cost", ")", "\n", "plt", ".", "axvline", "(", "x", "=", "opt_thresh", ",", "ls", "=", "\"dashed\"", ",", "c", "=", "\"crimson\"", ",", "label", "=", "\"optimal\"", ")", "\n", "", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "if", "save", ":", "\n", "        ", "if", "suff", ":", "\n", "            ", "suff", "=", "\"_\"", "+", "suff", "\n", "", "figname", "=", "\"func\"", "+", "suff", "+", "\".pdf\"", "\n", "figname", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "path", ",", "figname", ")", ")", "\n", "plt", ".", "savefig", "(", "figname", ",", "bbox_inches", "=", "\"tight\"", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.plotters.plot_td_samples_1d": [[113, 148], ["matplotlib.pyplot.figure", "td.sample_all", "numpy.argsort", "matplotlib.pyplot.plot", "matplotlib.pyplot.axhline", "matplotlib.pyplot.legend", "matplotlib.pyplot.tight_layout", "matplotlib.pyplot.title", "RuntimeError", "matplotlib.pyplot.plot", "matplotlib.pyplot.plot", "matplotlib.pyplot.plot", "os.path.abspath", "matplotlib.pyplot.savefig", "matplotlib.pyplot.show", "os.path.join"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all"], ["", "", "def", "plot_td_samples_1d", "(", "\n", "td", ",", "cost", "=", "None", ",", "save", "=", "True", ",", "path", "=", "None", ",", "suff", "=", "\"\"", ",", "samples", "=", "300", "\n", ")", ":", "\n", "    ", "\"\"\"Plot some samples from the true distribution and their probabilities.\"\"\"", "\n", "if", "save", "and", "path", "is", "None", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Need path to save figure.\"", ")", "\n", "", "plt", ".", "figure", "(", ")", "\n", "x0", ",", "y0", ",", "s0", ",", "yprob0", "=", "td", ".", "sample_all", "(", "samples", ",", "yproba", "=", "True", ")", "\n", "perm", "=", "np", ".", "argsort", "(", "x0", "[", ":", ",", "1", "]", ")", "\n", "xs", "=", "x0", "[", "perm", "]", "\n", "ys", "=", "y0", "[", "perm", "]", "\n", "yprobs", "=", "yprob0", "[", "perm", "]", "\n", "if", "s0", "is", "not", "None", ":", "\n", "        ", "ss", "=", "s0", "[", "perm", "]", "\n", "plt", ".", "plot", "(", "\n", "xs", "[", "ss", "==", "0", ",", "1", "]", ",", "ys", "[", "ss", "==", "0", "]", ",", "\".\"", ",", "label", "=", "\"samples, s=0\"", ",", "alpha", "=", "0.5", "\n", ")", "\n", "plt", ".", "plot", "(", "\n", "xs", "[", "ss", "==", "1", ",", "1", "]", ",", "ys", "[", "ss", "==", "1", "]", ",", "\".\"", ",", "label", "=", "\"samples, s=1\"", ",", "alpha", "=", "0.5", "\n", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "plot", "(", "xs", "[", ":", ",", "1", "]", ",", "ys", ",", "\".\"", ",", "xs", "[", ":", ",", "1", "]", ",", "yprobs", ",", "\".\"", ",", "label", "=", "\"samples\"", ")", "\n", "", "plt", ".", "plot", "(", "xs", "[", ":", ",", "1", "]", ",", "yprobs", ",", "label", "=", "\"true probabilities\"", ")", "\n", "plt", ".", "axhline", "(", "y", "=", "cost", ",", "ls", "=", "\"dashed\"", ",", "c", "=", "\"k\"", ",", "label", "=", "f\"c = {cost:.2f}\"", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "title", "(", "\"Samples from the ground truth distribution\"", ")", "\n", "if", "save", ":", "\n", "        ", "if", "suff", ":", "\n", "            ", "suff", "=", "\"_\"", "+", "suff", "\n", "", "figname", "=", "\"td_data\"", "+", "suff", "+", "\".pdf\"", "\n", "figname", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "path", ",", "figname", ")", ")", "\n", "plt", ".", "savefig", "(", "figname", ",", "bbox_inches", "=", "\"tight\"", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.plotters.plot_td_samples": [[150, 171], ["matplotlib.pyplot.figure", "td.sample_all", "pandas.DataFrame", "pandas.plotting.scatter_matrix", "matplotlib.pyplot.tight_layout", "RuntimeError", "numpy.hstack", "os.path.abspath", "matplotlib.pyplot.savefig", "matplotlib.pyplot.show", "os.path.join"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all"], ["", "", "def", "plot_td_samples", "(", "\n", "td", ",", "names", "=", "None", ",", "save", "=", "True", ",", "path", "=", "None", ",", "suff", "=", "\"\"", ",", "samples", "=", "300", "\n", ")", ":", "\n", "    ", "\"\"\"Plot some samples from the true distribution and their probabilities.\"\"\"", "\n", "if", "save", "and", "path", "is", "None", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Need path to save figure.\"", ")", "\n", "", "plt", ".", "figure", "(", ")", "\n", "x", ",", "y", ",", "_", ",", "yprob", "=", "td", ".", "sample_all", "(", "samples", ",", "yproba", "=", "True", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "\n", "np", ".", "hstack", "(", "(", "x", ",", "yprob", "[", ":", ",", "np", ".", "newaxis", "]", ")", ")", ",", "columns", "=", "names", ",", "figsize", "=", "(", "20", ",", "20", ")", "\n", ")", "\n", "pd", ".", "plotting", ".", "scatter_matrix", "(", "df", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "if", "save", ":", "\n", "        ", "if", "suff", ":", "\n", "            ", "suff", "=", "\"_\"", "+", "suff", "\n", "", "figname", "=", "\"td_data\"", "+", "suff", "+", "\".pdf\"", "\n", "figname", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "path", ",", "figname", ")", ")", "\n", "plt", ".", "savefig", "(", "figname", ",", "bbox_inches", "=", "\"tight\"", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.plotters.plot_results": [[173, 368], ["matplotlib.pyplot.figure", "matplotlib.pyplot.subplots", "fixed.items", "learned.items", "range", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].set_ylabel", "axs[].get_legend_handles_labels", "fig.legend", "matplotlib.pyplot.tight_layout", "axs[].plot", "numpy.arange", "axs[].plot", "axs[].plot", "numpy.arange", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "numpy.arange", "axs[].plot", "axs[].plot", "numpy.arange", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].plot", "axs[].set_xlabel", "axs[].set_xlabel", "os.path.abspath", "matplotlib.pyplot.savefig", "matplotlib.pyplot.show", "axs[].plot", "len", "axs[].plot", "os.path.join", "len", "numpy.cumsum", "len", "numpy.cumsum", "len", "len", "numpy.cumsum", "len", "numpy.cumsum"], "function", ["None"], ["", "", "def", "plot_results", "(", "learned", ",", "fixed", ",", "save", "=", "True", ",", "path", "=", "None", ",", "suff", "=", "\"\"", ")", ":", "\n", "    ", "\"\"\"Plot various characteristics over the training for various settings.\n\n    Args:\n        learned: A dictionary containing the results (dict values: arrays)\n            for various settings (dict keys: (str, str)).\n        fixed: A dictionary containing fixed result values.\n        save: Whether to save the figure.\n        path: Where to save the figure (only if `save=True`.\n        suff: Optional suffix for the file name.\n    \"\"\"", "\n", "plt", ".", "figure", "(", ")", "\n", "\n", "rows", "=", "7", "\n", "fig", ",", "axs", "=", "plt", ".", "subplots", "(", "rows", ",", "2", ",", "figsize", "=", "(", "20", ",", "rows", "*", "4", ")", ")", "\n", "\n", "# -------------------------------------------------------------------------", "\n", "# fixed policies", "\n", "for", "policy", ",", "results", "in", "fixed", ".", "items", "(", ")", ":", "\n", "        ", "tmp_label", "=", "LABELNAMES", "[", "policy", "]", "\n", "# utility (test)", "\n", "axs", "[", "0", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"utilities\"", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", "\n", ")", "\n", "timesteps", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "results", "[", "\"utilities\"", "]", ")", "+", "1", ")", "\n", "axs", "[", "0", ",", "1", "]", ".", "plot", "(", "\n", "np", ".", "cumsum", "(", "results", "[", "\"utilities\"", "]", ")", "/", "timesteps", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", ")", "\n", "# utility (reaped)", "\n", "axs", "[", "1", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_utilities\"", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", "\n", ")", "\n", "timesteps", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "results", "[", "\"reaped_utilities\"", "]", ")", "+", "1", ")", "\n", "axs", "[", "1", ",", "1", "]", ".", "plot", "(", "\n", "np", ".", "cumsum", "(", "results", "[", "\"reaped_utilities\"", "]", ")", "/", "timesteps", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", ")", "\n", "# selection rate (test)", "\n", "axs", "[", "2", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"test_SEL\"", "]", "[", ":", ",", "0", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", "\n", ")", "\n", "# selection rate (reaped)", "\n", "axs", "[", "2", ",", "1", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_SEL\"", "]", "[", ":", ",", "0", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", "\n", ")", "\n", "# disparate impact (test)", "\n", "axs", "[", "3", ",", "0", "]", ".", "plot", "(", "results", "[", "\"test_DI\"", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", ")", "\n", "# disparate impact (reaped)", "\n", "axs", "[", "3", ",", "1", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_DI\"", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", "\n", ")", "\n", "# demogrpahic parity (test)", "\n", "axs", "[", "4", ",", "0", "]", ".", "plot", "(", "results", "[", "\"test_DP\"", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", ")", "\n", "# demographic parity (reaped)", "\n", "axs", "[", "4", ",", "1", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_DP\"", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", "\n", ")", "\n", "# equal opportunity (test)", "\n", "axs", "[", "5", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"test_EOP\"", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", "\n", ")", "\n", "# equal opportunity (reaped)", "\n", "axs", "[", "5", ",", "1", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_EOP\"", "]", ",", "label", "=", "tmp_label", ",", "**", "STYLEMAP", "[", "policy", "]", "\n", ")", "\n", "\n", "if", "results", "[", "\"thresholds\"", "]", "and", "len", "(", "results", "[", "\"thresholds\"", "]", ")", ">", "0", ":", "\n", "            ", "ls_stoch", "=", "\"dotted\"", "if", "\"logistic\"", "in", "policy", "else", "None", "\n", "axs", "[", "6", ",", "0", "]", ".", "plot", "(", "results", "[", "\"thresholds\"", "]", ",", "ls", "=", "ls_stoch", ",", "label", "=", "tmp_label", ")", "\n", "\n", "# -------------------------------------------------------------------------", "\n", "# learned policies", "\n", "", "", "for", "(", "policy", ",", "strategy", ")", ",", "results", "in", "learned", ".", "items", "(", ")", ":", "\n", "        ", "tmp_label", "=", "f\"{LABELNAMES[policy]} {LABELNAMES[strategy]}\"", "\n", "# utility (test)", "\n", "axs", "[", "0", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"utilities\"", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "timesteps", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "results", "[", "\"utilities\"", "]", ")", "+", "1", ")", "\n", "axs", "[", "0", ",", "1", "]", ".", "plot", "(", "\n", "np", ".", "cumsum", "(", "results", "[", "\"utilities\"", "]", ")", "/", "timesteps", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# utility (reaped)", "\n", "axs", "[", "1", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_utilities\"", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "timesteps", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "results", "[", "\"reaped_utilities\"", "]", ")", "+", "1", ")", "\n", "axs", "[", "1", ",", "1", "]", ".", "plot", "(", "\n", "np", ".", "cumsum", "(", "results", "[", "\"reaped_utilities\"", "]", ")", "/", "timesteps", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# selection rate (test)", "\n", "axs", "[", "2", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"test_SEL\"", "]", "[", ":", ",", "0", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# selection rate (reaped)", "\n", "axs", "[", "2", ",", "1", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_SEL\"", "]", "[", ":", ",", "0", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# disparate impact (test)", "\n", "axs", "[", "3", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"test_DI\"", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# disparate impact (reaped)", "\n", "axs", "[", "3", ",", "1", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_DI\"", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# demogrpahic parity (test)", "\n", "axs", "[", "4", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"test_DP\"", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# demographic parity (reaped)", "\n", "axs", "[", "4", ",", "1", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_DP\"", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# equal opportunity (test)", "\n", "axs", "[", "5", ",", "0", "]", ".", "plot", "(", "\n", "results", "[", "\"test_EOP\"", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "# equal opportunity (reaped)", "\n", "axs", "[", "5", ",", "1", "]", ".", "plot", "(", "\n", "results", "[", "\"reaped_EOP\"", "]", ",", "\n", "label", "=", "tmp_label", ",", "\n", "**", "STYLEMAP", "[", "policy", "]", ",", "\n", "**", "STYLEMAP", "[", "strategy", "]", ",", "\n", ")", "\n", "\n", "if", "len", "(", "results", "[", "\"thresholds\"", "]", ")", ">", "0", ":", "\n", "            ", "ls_stoch", "=", "\"dotted\"", "if", "\"logistic\"", "in", "policy", "else", "None", "\n", "axs", "[", "6", ",", "0", "]", ".", "plot", "(", "results", "[", "\"thresholds\"", "]", ",", "ls", "=", "ls_stoch", ",", "label", "=", "tmp_label", ")", "\n", "\n", "", "", "for", "i", "in", "range", "(", "rows", ")", ":", "\n", "        ", "axs", "[", "i", ",", "0", "]", ".", "set_xlabel", "(", "r\"time step $t$\"", ")", "\n", "axs", "[", "i", ",", "1", "]", ".", "set_xlabel", "(", "r\"time step $t$\"", ")", "\n", "", "axs", "[", "0", ",", "0", "]", ".", "set_ylabel", "(", "r\"utility $u(\\pi_{\\theta_t}, c)$\"", ")", "\n", "axs", "[", "0", ",", "1", "]", ".", "set_ylabel", "(", "r\"cumulative utility\"", ")", "\n", "axs", "[", "1", ",", "0", "]", ".", "set_ylabel", "(", "\n", "r\"reaped utility $\\sum_{y \\in \\mathcal{D}_t} (y - c)$\"", "\n", ")", "\n", "axs", "[", "1", ",", "1", "]", ".", "set_ylabel", "(", "r\"cumulative reaped utility\"", ")", "\n", "axs", "[", "2", ",", "0", "]", ".", "set_ylabel", "(", "r\"selection rate\"", ")", "\n", "axs", "[", "2", ",", "1", "]", ".", "set_ylabel", "(", "r\"reaped selection rate\"", ")", "\n", "axs", "[", "3", ",", "0", "]", ".", "set_ylabel", "(", "r\"disparate impact\"", ")", "\n", "axs", "[", "3", ",", "1", "]", ".", "set_ylabel", "(", "r\"reaped disparate impact\"", ")", "\n", "axs", "[", "4", ",", "0", "]", ".", "set_ylabel", "(", "r\"demographic parity\"", ")", "\n", "axs", "[", "4", ",", "1", "]", ".", "set_ylabel", "(", "r\"reaped demographic parity\"", ")", "\n", "axs", "[", "5", ",", "0", "]", ".", "set_ylabel", "(", "r\"equal opportunity\"", ")", "\n", "axs", "[", "5", ",", "1", "]", ".", "set_ylabel", "(", "r\"reaped equal opportunity\"", ")", "\n", "axs", "[", "6", ",", "0", "]", ".", "set_ylabel", "(", "r\"decision boundary in input space\"", ")", "\n", "handles", ",", "labels", "=", "axs", "[", "1", ",", "0", "]", ".", "get_legend_handles_labels", "(", ")", "\n", "fig", ".", "legend", "(", "handles", ",", "labels", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "if", "save", ":", "\n", "        ", "if", "suff", ":", "\n", "            ", "suff", "=", "\"_\"", "+", "suff", "\n", "", "figname", "=", "\"utilities\"", "+", "suff", "+", "\".pdf\"", "\n", "figname", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "path", ",", "figname", ")", ")", "\n", "plt", ".", "savefig", "(", "figname", ",", "bbox_inches", "=", "\"tight\"", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.BaseDistribution.__init__": [[22, 33], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the true distribution.\n\n        Args:\n            config: The configuration dictionary.\n        \"\"\"", "\n", "self", ".", "config", "=", "config", "\n", "self", ".", "feature_dim", "=", "None", "\n", "self", ".", "is_1d", "=", "False", "\n", "self", ".", "_test_set", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.BaseDistribution.sample_features": [[34, 47], ["NotImplementedError"], "methods", ["None"], ["", "def", "sample_features", "(", "self", ",", "n", ")", ":", "\n", "        ", "\"\"\"\n        Sample feature variables.\n\n        Args:\n            n: Number of examples.\n\n        Returns:\n            2-tuple of np.ndarrays:\n                [0]: x, an iid sample of features from the true distribution\n                [1]: s, an iid sample of protected from the true distribution\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Subclass must override `sample_features`.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.BaseDistribution.sample_labels": [[48, 62], ["NotImplementedError"], "methods", ["None"], ["", "def", "sample_labels", "(", "self", ",", "x", ",", "s", ",", "yproba", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Sample labels given feature variables.\n\n        Args:\n            x: Feature examples.\n            s: Protected attributes.\n            yproba: Whether to return the probabilities of the binary labels.\n\n        Returns:\n            An iid sample of labels from the true distribution given the\n            features x and protected attribute s (np.ndarray).\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Subclass must override `sample_labels`.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.BaseDistribution.sample_all": [[63, 83], ["truedistribution.BaseDistribution.sample_features", "truedistribution.BaseDistribution.sample_labels", "truedistribution.BaseDistribution.sample_labels"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_features", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_labels", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_labels"], ["", "def", "sample_all", "(", "self", ",", "n", ",", "yproba", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Draw a full sample of features and labels.\n\n        Args:\n            n: The number of exmaples to draw.\n            yproba: Whether to return the probabilities of the binary labels.\n\n        Returns:\n            x, s, y, (yproba): np.ndarrays of features, binary labels, and the\n                corresponding probabilities for the labels. The latter only if\n                `yproba=True`.\n        \"\"\"", "\n", "x", ",", "s", "=", "self", ".", "sample_features", "(", "n", "=", "n", ")", "\n", "if", "yproba", ":", "\n", "            ", "y", ",", "yproba", "=", "self", ".", "sample_labels", "(", "x", ",", "s", ",", "yproba", "=", "yproba", ")", "\n", "return", "x", ",", "y", ",", "s", ",", "yproba", "\n", "", "else", ":", "\n", "            ", "y", "=", "self", ".", "sample_labels", "(", "x", ",", "s", ",", "yproba", "=", "yproba", ")", "\n", "return", "x", ",", "y", ",", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.BaseDistribution.get_test": [[84, 103], ["truedistribution.BaseDistribution.sample_all"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all"], ["", "", "def", "get_test", "(", "self", ",", "n", "=", "1000000", ")", ":", "\n", "        ", "\"\"\"Get a test set for this distribution.\n\n        A testset of the given size is sampled and stored. If the test set\n        function is called multiple times, with the same `n`, the cached data\n        is returned. If `n` changes, a new test set is sampled and returned.\n\n        Args:\n            n: The number of examples to use for the test set.\n\n        Returns:\n            3-tuple of np.ndarrays\n                [0]: x, the features\n                [1]: y, the labels\n                [2]: s, the protected attributes\n        \"\"\"", "\n", "if", "self", ".", "_test_set", "is", "None", "or", "self", ".", "_test_set", "[", "0", "]", ".", "shape", "[", "0", "]", "!=", "n", ":", "\n", "            ", "self", ".", "_test_set", "=", "self", ".", "sample_all", "(", "n", ")", "\n", "", "return", "self", ".", "_test_set", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.DummyDistribution1D.__init__": [[114, 128], ["truedistribution.BaseDistribution.__init__", "numpy.array", "len"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__"], ["def", "__init__", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the true distribution.\n\n        Args:\n            config: The configuration dictionary.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "config", ")", "\n", "self", ".", "type", "=", "\"custom1d\"", "\n", "self", ".", "theta", "=", "np", ".", "array", "(", "config", "[", "\"theta\"", "]", ")", "\n", "self", ".", "feature_dim", "=", "len", "(", "self", ".", "theta", ")", "\n", "if", "\"split_support\"", "not", "in", "config", "[", "\"custom_tweaks\"", "]", ":", "\n", "            ", "self", ".", "threshold", "=", "self", ".", "_threshold", "\n", "", "self", ".", "is_1d", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.DummyDistribution1D.sample_features": [[129, 154], ["numpy.full", "numpy.concatenate", "numpy.hstack", "numpy.full.ravel", "numpy.random.randn", "numpy.random.randn", "numpy.full.reshape", "numpy.ones", "numpy.random.rand"], "methods", ["None"], ["", "def", "sample_features", "(", "self", ",", "n", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Draw examples only for the features of the true distribution.\n\n        Args:\n            n: The number of examples to draw.\n\n        Returns:\n            x: np.ndarray with the features of dimension (n, k), where k is\n                either 1 or 2 depending on whether a constant is added\n        \"\"\"", "\n", "if", "self", ".", "config", "[", "\"protected_fraction\"", "]", "is", "not", "None", ":", "\n", "            ", "s", "=", "(", "\n", "np", ".", "random", ".", "rand", "(", "n", ",", "1", ")", "<", "self", ".", "config", "[", "\"protected_fraction\"", "]", "\n", ")", ".", "astype", "(", "int", ")", "\n", "x", "=", "3.5", "*", "np", ".", "random", ".", "randn", "(", "n", ",", "1", ")", "+", "3", "*", "(", "0.5", "-", "s", ")", "\n", "", "else", ":", "\n", "            ", "s", "=", "np", ".", "full", "(", "n", ",", "np", ".", "nan", ")", "\n", "x", "=", "3.5", "*", "np", ".", "random", ".", "randn", "(", "n", ",", "1", ")", "\n", "\n", "", "if", "self", ".", "config", "[", "\"protected_as_feature\"", "]", ":", "\n", "            ", "x", "=", "np", ".", "concatenate", "(", "(", "x", ",", "s", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "", "if", "self", ".", "config", "[", "\"add_constant\"", "]", ":", "\n", "            ", "x", "=", "np", ".", "hstack", "(", "[", "np", ".", "ones", "(", "[", "n", ",", "1", "]", ")", ",", "x", "]", ")", "\n", "", "return", "x", ",", "s", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.DummyDistribution1D.sample_labels": [[155, 186], ["utils.sigmoid", "numpy.random.binomial", "x.dot", "numpy.maximum", "numpy.maximum", "numpy.exp", "numpy.minimum", "numpy.exp", "numpy.minimum", "utils.sigmoid", "utils.sigmoid", "utils.sigmoid"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.sigmoid", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.sigmoid", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.sigmoid", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.sigmoid"], ["", "def", "sample_labels", "(", "self", ",", "x", ",", "s", ",", "yproba", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Draw examples of labels for given features.\n\n        Args:\n            x: Given features (usually obtained by calling `sample_features`).\n            s: Sensitive attribute.\n            yproba: Whether to return the probabilities of the binary labels.\n\n        Returns:\n            y: np.ndarray of binary (0/1) labels (if `yproba=False`)\n            y, yproba: np.ndarrays of binary (0/1) labels as well as the\n                original probabilities of the labels (if `yproba=False`)\n        \"\"\"", "\n", "yprob", "=", "utils", ".", "sigmoid", "(", "x", ".", "dot", "(", "self", ".", "theta", ")", ")", "\n", "\n", "if", "\"bump_left\"", "in", "self", ".", "config", "[", "\"custom_tweaks\"", "]", ":", "\n", "            ", "yprob", "+=", "np", ".", "exp", "(", "-", "(", "x", "[", ":", ",", "1", "]", "+", "6", ")", "**", "2", "*", "2", ")", "*", "0.5", "\n", "yprob", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "yprob", ",", "1", ")", ",", "0", ")", "\n", "", "if", "\"bump_right\"", "in", "self", ".", "config", "[", "\"custom_tweaks\"", "]", ":", "\n", "            ", "yprob", "-=", "np", ".", "exp", "(", "-", "(", "x", "[", ":", ",", "1", "]", "-", "5", ")", "**", "2", "*", "0.8", ")", "*", "0.35", "\n", "yprob", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "yprob", ",", "1", ")", ",", "0", ")", "\n", "", "if", "\"split_support\"", "in", "self", ".", "config", "[", "\"custom_tweaks\"", "]", ":", "\n", "            ", "yprob", "=", "0.8", "*", "utils", ".", "sigmoid", "(", "0.6", "*", "(", "x", "[", ":", ",", "1", "]", "+", "3", ")", ")", "*", "utils", ".", "sigmoid", "(", "\n", "-", "5", "*", "(", "x", "[", ":", ",", "1", "]", "-", "3", ")", "\n", ")", "+", "utils", ".", "sigmoid", "(", "x", "[", ":", ",", "1", "]", "-", "5", ")", "\n", "\n", "", "y", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "yprob", ")", "\n", "if", "yproba", ":", "\n", "            ", "return", "y", ",", "yprob", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.DummyDistribution1D._threshold": [[187, 195], ["len", "len", "utils.get_threshold", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.get_threshold"], ["", "def", "_threshold", "(", "self", ",", "cost", ")", ":", "\n", "        ", "\"\"\"The threshold for this policy.\"\"\"", "\n", "if", "len", "(", "self", ".", "theta", ")", "==", "1", ":", "\n", "            ", "return", "0.0", "\n", "", "if", "len", "(", "self", ".", "theta", ")", "==", "2", ":", "\n", "            ", "return", "utils", ".", "get_threshold", "(", "self", ".", "theta", ",", "cost", ")", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Scalar threshold exists only for 1D.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF.__init__": [[211, 236], ["truedistribution.BaseDistribution.__init__", "truedistribution.InverseCDF._set_inverse_cdf", "sum", "ValueError", "truedistribution.InverseCDF.weights.values"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF._set_inverse_cdf"], ["def", "__init__", "(", "self", ",", "config", ",", "group_weights", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the true distribution.\n\n        Args:\n            config: The configuration dictionary.\n            group_weights: How to weight the possible groups in the mixture.\n                Dictionary with keys in 'black', 'white', 'asian', 'hispanic'.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "config", ")", "\n", "self", ".", "type", "=", "\"inv_cdf\"", "\n", "self", ".", "feature_dim", "=", "2", "if", "self", ".", "config", "[", "\"add_constant\"", "]", "else", "1", "\n", "self", ".", "thresh", "=", "None", "\n", "self", ".", "inv_cdfs", "=", "None", "\n", "self", ".", "pdfs", "=", "None", "\n", "self", ".", "prob_bnds", "=", "None", "\n", "self", ".", "score_bnds", "=", "None", "\n", "self", ".", "is_1d", "=", "True", "\n", "if", "group_weights", "is", "None", ":", "\n", "            ", "self", ".", "weights", "=", "{", "\"white\"", ":", "0.0", ",", "\"black\"", ":", "1.0", "}", "\n", "", "else", ":", "\n", "            ", "self", ".", "weights", "=", "group_weights", "\n", "", "if", "sum", "(", "self", ".", "weights", ".", "values", "(", ")", ")", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Weights must sum to 1.\"", ")", "\n", "", "self", ".", "_set_inverse_cdf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF._set_inverse_cdf": [[237, 262], ["os.path.abspath", "os.path.join", "os.path.join", "numpy.load", "scipy.interpolate.interp1d", "scipy.interpolate.interp1d", "max", "min", "max", "min", "min", "max", "min", "max"], "methods", ["None"], ["", "def", "_set_inverse_cdf", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compute the inverse CDF from data.\"\"\"", "\n", "data_dir", "=", "os", ".", "path", ".", "abspath", "(", "self", ".", "config", "[", "\"path\"", "]", ")", "\n", "data_dir", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "self", ".", "config", "[", "\"type\"", "]", ")", "\n", "self", ".", "inv_cdfs", "=", "{", "}", "\n", "self", ".", "pdfs", "=", "{", "}", "\n", "lo_prob", ",", "hi_prob", "=", "0", ",", "1000", "\n", "lo_score", ",", "hi_score", "=", "0", ",", "1000", "\n", "for", "group", "in", "self", ".", "weights", ":", "\n", "            ", "data_path", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "\"marginals_\"", "+", "group", "+", "\".npz\"", ")", "\n", "data", "=", "np", ".", "load", "(", "data_path", ")", "\n", "score", ",", "proba", ",", "cdf", "=", "data", "[", "\"fico\"", "]", ",", "data", "[", "\"proba\"", "]", ",", "data", "[", "\"cdf\"", "]", "\n", "# score = (score - 300.0) / 550.0", "\n", "self", ".", "inv_cdfs", "[", "group", "]", "=", "interp1d", "(", "\n", "cdf", ",", "score", ",", "kind", "=", "\"linear\"", ",", "assume_sorted", "=", "False", "\n", ")", "\n", "self", ".", "pdfs", "[", "group", "]", "=", "interp1d", "(", "\n", "score", ",", "proba", ",", "kind", "=", "\"linear\"", ",", "assume_sorted", "=", "False", "\n", ")", "\n", "lo_prob", "=", "max", "(", "lo_prob", ",", "min", "(", "proba", ")", ")", "\n", "hi_prob", "=", "min", "(", "hi_prob", ",", "max", "(", "proba", ")", ")", "\n", "lo_score", "=", "max", "(", "lo_score", ",", "min", "(", "score", ")", ")", "\n", "hi_score", "=", "min", "(", "hi_score", ",", "max", "(", "score", ")", ")", "\n", "", "self", ".", "prob_bnds", "=", "(", "1.001", "*", "lo_prob", ",", "0.999", "*", "hi_prob", ")", "\n", "self", ".", "score_bnds", "=", "(", "lo_score", ",", "hi_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF.set_threshold_get_cost": [[263, 268], ["float", "numpy.linspace", "utils.find_x_for_y", "truedistribution.InverseCDF.pdf"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.find_x_for_y", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.pdf"], ["", "def", "set_threshold_get_cost", "(", "self", ",", "threshold", ")", ":", "\n", "        ", "\"\"\"Find the cost corresponding to a given score threshold.\"\"\"", "\n", "self", ".", "thresh", "=", "float", "(", "threshold", ")", "\n", "scores", "=", "np", ".", "linspace", "(", "*", "self", ".", "score_bnds", ",", "300", ")", "\n", "return", "utils", ".", "find_x_for_y", "(", "self", ".", "pdf", "(", "scores", ")", ",", "scores", ",", "threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF.inv_cdf": [[269, 275], ["numpy.zeros_like", "truedistribution.InverseCDF.weights.items"], "methods", ["None"], ["", "def", "inv_cdf", "(", "self", ",", "prob", ")", ":", "\n", "        ", "\"\"\"Get the inverse CDF value.\"\"\"", "\n", "x", "=", "np", ".", "zeros_like", "(", "prob", ",", "dtype", "=", "\"float64\"", ")", "\n", "for", "group", ",", "w", "in", "self", ".", "weights", ".", "items", "(", ")", ":", "\n", "            ", "x", "+=", "self", ".", "weights", "[", "group", "]", "*", "self", ".", "inv_cdfs", "[", "group", "]", "(", "prob", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF.pdf": [[276, 282], ["numpy.zeros_like", "truedistribution.InverseCDF.weights.items"], "methods", ["None"], ["", "def", "pdf", "(", "self", ",", "score", ")", ":", "\n", "        ", "\"\"\"Get the probability of repayment.\"\"\"", "\n", "x", "=", "np", ".", "zeros_like", "(", "score", ",", "dtype", "=", "\"float64\"", ")", "\n", "for", "group", ",", "w", "in", "self", ".", "weights", ".", "items", "(", ")", ":", "\n", "            ", "x", "+=", "self", ".", "weights", "[", "group", "]", "*", "self", ".", "pdfs", "[", "group", "]", "(", "score", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF.sample_features": [[283, 312], ["sorted", "numpy.random.binomial().astype", "numpy.zeros_like", "len", "RuntimeError", "list", "numpy.hstack", "truedistribution.InverseCDF.weights.keys", "numpy.random.binomial", "numpy.random.rand", "numpy.ones", "numpy.diff"], "methods", ["None"], ["", "def", "sample_features", "(", "self", ",", "n", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Draw examples only for the features of the true distribution.\n\n        Args:\n            n: The number of examples to draw.\n\n        Returns:\n            x: np.ndarray with the features of dimension (n, 2)\n        \"\"\"", "\n", "# Assume there are only two groups", "\n", "if", "len", "(", "self", ".", "weights", ".", "keys", "(", ")", ")", "!=", "2", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Can only sample for two groups.\"", ")", "\n", "", "group_names", "=", "sorted", "(", "list", "(", "self", ".", "weights", ")", ")", "\n", "s", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "self", ".", "weights", "[", "group_names", "[", "0", "]", "]", ",", "(", "n", ",", "1", ")", ")", ".", "astype", "(", "\n", "int", "\n", ")", "\n", "x", "=", "np", ".", "zeros_like", "(", "s", ",", "dtype", "=", "\"float64\"", ")", "\n", "for", "group", "in", "group_names", ":", "\n", "            ", "probs", "=", "(", "\n", "np", ".", "random", ".", "rand", "(", "n", ",", "1", ")", "*", "np", ".", "diff", "(", "self", ".", "prob_bnds", ")", "[", "0", "]", "\n", "+", "self", ".", "prob_bnds", "[", "0", "]", "\n", ")", "\n", "x", "+=", "s", "*", "self", ".", "inv_cdfs", "[", "group", "]", "(", "probs", ")", "\n", "s", "=", "1", "-", "s", "\n", "\n", "", "if", "self", ".", "config", "[", "\"add_constant\"", "]", ":", "\n", "            ", "x", "=", "np", ".", "hstack", "(", "[", "np", ".", "ones", "(", "[", "n", ",", "1", "]", ")", ",", "x", "]", ")", "\n", "", "return", "x", ",", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF.sample_labels": [[313, 335], ["numpy.random.binomial", "truedistribution.InverseCDF.pdf", "truedistribution.InverseCDF.pdf"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.pdf", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.pdf"], ["", "def", "sample_labels", "(", "self", ",", "x", ",", "s", ",", "yproba", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Draw examples of labels for given features.\n\n        Args:\n            x: Given features (usually obtained by calling `sample_features`).\n            s: Sensitive attribute.\n            yproba: Whether to return the probabilities of the binary labels.\n\n        Returns:\n            y: np.ndarray of binary (0/1) labels (if `yproba=False`)\n            y, yproba: np.ndarrays of binary (0/1) labels as well as the\n                original probabilities of the labels (if `yproba=False`)\n        \"\"\"", "\n", "if", "x", ".", "shape", "[", "1", "]", "==", "2", ":", "\n", "            ", "yprob", "=", "self", ".", "pdf", "(", "x", "[", ":", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "yprob", "=", "self", ".", "pdf", "(", "x", ")", "\n", "", "y", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "yprob", ")", "\n", "if", "yproba", ":", "\n", "            ", "return", "y", ",", "yprob", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.InverseCDF.threshold": [[336, 340], ["None"], "methods", ["None"], ["", "def", "threshold", "(", "self", ",", "cost", ")", ":", "\n", "        ", "\"\"\"The threshold for this policy.\"\"\"", "\n", "assert", "self", ".", "thresh", "is", "not", "None", ",", "\"Need to set threshold first\"", "\n", "return", "self", ".", "thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.__init__": [[351, 362], ["truedistribution.BaseDistribution.__init__"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__"], ["def", "__init__", "(", "self", ",", "config", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "config", ")", "\n", "self", ".", "feature_dim", "=", "2", "if", "self", ".", "config", "[", "\"add_constant\"", "]", "else", "1", "\n", "self", ".", "type", "=", "\"uncalibratedscore\"", "\n", "params", "=", "config", "[", "\"uncalibrated_params\"", "]", "\n", "self", ".", "bound", "=", "params", "[", "\"bound\"", "]", "\n", "self", ".", "width", "=", "params", "[", "\"width\"", "]", "\n", "self", ".", "height", "=", "params", "[", "\"height\"", "]", "\n", "self", ".", "shift", "=", "params", "[", "\"shift\"", "]", "\n", "self", ".", "thresh", "=", "None", "\n", "self", ".", "is_1d", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.set_threshold_get_cost": [[363, 368], ["float", "numpy.linspace", "utils.find_x_for_y", "truedistribution.UncalibratedScore.pdf"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.find_x_for_y", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.pdf"], ["", "def", "set_threshold_get_cost", "(", "self", ",", "threshold", ")", ":", "\n", "        ", "\"\"\"Find the cost corresponding to a given score threshold.\"\"\"", "\n", "self", ".", "thresh", "=", "float", "(", "threshold", ")", "\n", "x", "=", "np", ".", "linspace", "(", "-", "self", ".", "bound", ",", "self", ".", "bound", ",", "300", ")", "\n", "return", "utils", ".", "find_x_for_y", "(", "self", ".", "pdf", "(", "x", ")", ",", "x", ",", "threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.pdf": [[369, 379], ["numpy.tan", "numpy.tan", "numpy.exp", "numpy.tan"], "methods", ["None"], ["", "def", "pdf", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Get the probability of repayment.\"\"\"", "\n", "num", "=", "(", "\n", "np", ".", "tan", "(", "x", ")", "\n", "+", "np", ".", "tan", "(", "self", ".", "bound", ")", "\n", "+", "self", ".", "height", "\n", "*", "np", ".", "exp", "(", "-", "self", ".", "width", "*", "(", "x", "-", "self", ".", "bound", "-", "self", ".", "shift", ")", "**", "4", ")", "\n", ")", "\n", "den", "=", "2", "*", "np", ".", "tan", "(", "self", ".", "bound", ")", "+", "self", ".", "height", "\n", "return", "num", "/", "den", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.sample_features": [[380, 399], ["scipy.stats.distributions.truncnorm.rvs().reshape", "numpy.full", "scipy.stats.distributions.truncnorm.rvs().reshape", "numpy.concatenate", "numpy.hstack", "numpy.full.ravel", "scipy.stats.distributions.truncnorm.rvs", "scipy.stats.distributions.truncnorm.rvs", "numpy.full.reshape", "numpy.ones", "numpy.random.rand"], "methods", ["None"], ["", "def", "sample_features", "(", "self", ",", "n", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "if", "self", ".", "config", "[", "\"protected_fraction\"", "]", "is", "not", "None", ":", "\n", "            ", "s", "=", "(", "\n", "np", ".", "random", ".", "rand", "(", "n", ",", "1", ")", "<", "self", ".", "config", "[", "\"protected_fraction\"", "]", "\n", ")", ".", "astype", "(", "int", ")", "\n", "shifts", "=", "s", "-", "0.5", "\n", "x", "=", "truncnorm", ".", "rvs", "(", "\n", "-", "self", ".", "bound", "+", "shifts", ",", "self", ".", "bound", "+", "shifts", ",", "loc", "=", "-", "shifts", "\n", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "s", "=", "np", ".", "full", "(", "n", ",", "np", ".", "nan", ")", "\n", "x", "=", "truncnorm", ".", "rvs", "(", "-", "self", ".", "bound", ",", "self", ".", "bound", ",", "size", "=", "n", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "", "if", "self", ".", "config", "[", "\"protected_as_feature\"", "]", ":", "\n", "            ", "x", "=", "np", ".", "concatenate", "(", "(", "x", ",", "s", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "", "if", "self", ".", "config", "[", "\"add_constant\"", "]", ":", "\n", "            ", "x", "=", "np", ".", "hstack", "(", "[", "np", ".", "ones", "(", "[", "n", ",", "1", "]", ")", ",", "x", "]", ")", "\n", "", "return", "x", ",", "s", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.sample_labels": [[400, 409], ["numpy.random.binomial", "truedistribution.UncalibratedScore.pdf", "truedistribution.UncalibratedScore.pdf"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.pdf", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.pdf"], ["", "def", "sample_labels", "(", "self", ",", "x", ",", "s", ",", "yproba", "=", "False", ")", ":", "\n", "        ", "if", "x", ".", "shape", "[", "1", "]", "==", "2", ":", "\n", "            ", "yprob", "=", "self", ".", "pdf", "(", "x", "[", ":", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "yprob", "=", "self", ".", "pdf", "(", "x", ")", "\n", "", "y", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "yprob", ")", "\n", "if", "yproba", ":", "\n", "            ", "return", "y", ",", "yprob", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.threshold": [[410, 414], ["None"], "methods", ["None"], ["", "def", "threshold", "(", "self", ",", "cost", ")", ":", "\n", "        ", "\"\"\"The threshold for this policy.\"\"\"", "\n", "assert", "self", ".", "thresh", "is", "not", "None", ",", "\"Need to set threshold first\"", "\n", "return", "self", ".", "thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__": [[425, 430], ["truedistribution.BaseDistribution.__init__", "truedistribution.ResamplingDistribution._load_data"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.__init__", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution._load_data"], ["def", "__init__", "(", "self", ",", "config", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "config", ")", "\n", "self", ".", "type", "=", "\"resampling\"", "\n", "self", ".", "feature_dim", "=", "None", "\n", "self", ".", "_load_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution._load_data": [[431, 450], ["data.get_data", "sklearn.model_selection.train_test_split", "numpy.arange", "numpy.hstack", "numpy.hstack", "numpy.ones", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.data.get_data"], ["", "def", "_load_data", "(", "self", ")", ":", "\n", "        ", "\"\"\"Load the specified dataset.\"\"\"", "\n", "test_size", "=", "self", ".", "config", "[", "\"test_size\"", "]", "\n", "x", ",", "y", ",", "s", "=", "get_data", "(", "self", ".", "config", ")", "\n", "x", ",", "xte", ",", "y", ",", "yte", ",", "s", ",", "ste", "=", "train_test_split", "(", "x", ",", "y", ",", "s", ",", "test_size", "=", "test_size", ")", "\n", "\n", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "s", "=", "x", ",", "y", ",", "s", "\n", "self", ".", "xtest", ",", "self", ".", "ytest", ",", "self", ".", "stest", "=", "xte", ",", "yte", ",", "ste", "\n", "\n", "self", ".", "n_examples", "=", "self", ".", "x", ".", "shape", "[", "0", "]", "\n", "self", ".", "allindices", "=", "np", ".", "arange", "(", "self", ".", "n_examples", ")", "\n", "self", ".", "n_group", "=", "{", "}", "\n", "self", ".", "indices_group", "=", "{", "}", "\n", "if", "self", ".", "config", "[", "\"add_constant\"", "]", ":", "\n", "            ", "self", ".", "x", "=", "np", ".", "hstack", "(", "[", "np", ".", "ones", "(", "[", "self", ".", "n_examples", ",", "1", "]", ")", ",", "self", ".", "x", "]", ")", "\n", "self", ".", "xtest", "=", "np", ".", "hstack", "(", "\n", "[", "np", ".", "ones", "(", "[", "self", ".", "xtest", ".", "shape", "[", "0", "]", ",", "1", "]", ")", ",", "self", ".", "xtest", "]", "\n", ")", "\n", "", "self", ".", "feature_dim", "=", "self", ".", "x", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_features": [[451, 453], ["NotImplementedError"], "methods", ["None"], ["", "def", "sample_features", "(", "self", ",", "n", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Only use `sample_all` for Resampling.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_labels": [[454, 456], ["NotImplementedError"], "methods", ["None"], ["", "def", "sample_labels", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Only use `sample_all` for Resampling.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all": [[457, 462], ["min", "numpy.random.choice"], "methods", ["None"], ["", "def", "sample_all", "(", "self", ",", "n", ",", "yproba", "=", "False", ")", ":", "\n", "        ", "assert", "not", "yproba", ",", "\"Cannot compute probabilities for real data.\"", "\n", "n", "=", "min", "(", "self", ".", "n_examples", ",", "n", ")", "\n", "indices", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "allindices", ",", "n", ",", "replace", "=", "True", ")", "\n", "return", "self", ".", "x", "[", "indices", "]", ",", "self", ".", "y", "[", "indices", "]", ",", "self", ".", "s", "[", "indices", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_by_group": [[463, 471], ["int", "min", "numpy.random.choice", "len"], "methods", ["None"], ["", "def", "sample_by_group", "(", "self", ",", "n", ",", "group", "=", "None", ")", ":", "\n", "        ", "group", "=", "int", "(", "group", ")", "\n", "if", "group", "not", "in", "self", ".", "indices_group", ":", "\n", "            ", "self", ".", "indices_group", "[", "group", "]", "=", "self", ".", "allindices", "[", "self", ".", "s", "==", "group", "]", "\n", "self", ".", "n_group", "[", "group", "]", "=", "len", "(", "self", ".", "indices_group", "[", "group", "]", ")", "\n", "", "n", "=", "min", "(", "self", ".", "n_group", "[", "group", "]", ",", "n", ")", "\n", "indices", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "indices_group", "[", "group", "]", ",", "n", ",", "replace", "=", "True", ")", "\n", "return", "self", ".", "x", "[", "indices", "]", ",", "self", ".", "y", "[", "indices", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.get_test": [[472, 474], ["None"], "methods", ["None"], ["", "def", "get_test", "(", "self", ",", "n", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "xtest", ",", "self", ".", "ytest", ",", "self", ".", "stest", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.setup_directories": [[19, 43], ["logzero.logger.info", "os.path.abspath", "os.path.join", "os.path.join", "os.path.join", "os.path.exists", "os.makedirs", "os.path.exists", "os.makedirs", "datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["None"], ["def", "setup_directories", "(", "config", ")", ":", "\n", "    ", "\"\"\"Create the directory structure needed to collect results and output.\"\"\"", "\n", "logger", ".", "info", "(", "\"Setup directories for results...\"", ")", "\n", "result_dir", "=", "os", ".", "path", ".", "abspath", "(", "config", "[", "\"results\"", "]", "[", "\"result_dir\"", "]", ")", "\n", "if", "config", "[", "\"results\"", "]", "[", "\"name\"", "]", "is", "None", ":", "\n", "        ", "dir_name", "=", "(", "\n", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%Y-%m-%d_%H-%M-%S\"", ")", "\n", "+", "\"_\"", "\n", "+", "config", "[", "\"true_distribution\"", "]", "[", "\"type\"", "]", "\n", ")", "\n", "", "else", ":", "\n", "        ", "dir_name", "=", "config", "[", "\"results\"", "]", "[", "\"name\"", "]", "\n", "", "result_dir", "=", "os", ".", "path", ".", "join", "(", "result_dir", ",", "dir_name", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "result_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "result_dir", ")", "\n", "", "config", "[", "\"results\"", "]", "[", "\"resolved\"", "]", "=", "result_dir", "\n", "\n", "fig_dir", "=", "os", ".", "path", ".", "join", "(", "result_dir", ",", "\"figures\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "fig_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "fig_dir", ")", "\n", "", "config", "[", "\"results\"", "]", "[", "\"figure_resolved\"", "]", "=", "fig_dir", "\n", "\n", "result_data_prefix", "=", "os", ".", "path", ".", "join", "(", "result_dir", ",", "\"data_\"", ")", "\n", "return", "result_data_prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.get_list_of_seeds": [[45, 52], ["numpy.random.randint", "numpy.dtype"], "function", ["None"], ["", "def", "get_list_of_seeds", "(", "num", ")", ":", "\n", "    ", "\"\"\"Create a random list of integer seeds.\"\"\"", "\n", "max_value", "=", "2", "**", "32", "-", "1", "\n", "data_seeds", "=", "np", ".", "random", ".", "randint", "(", "\n", "0", ",", "max_value", ",", "size", "=", "num", ",", "dtype", "=", "np", ".", "dtype", "(", "\"int64\"", ")", "\n", ")", "\n", "return", "data_seeds", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.initialize_true_distribution": [[54, 77], ["logzero.logger.info", "truedistribution.DummyDistribution1D", "truedistribution.InverseCDF", "logzero.logger.info", "truedistribution.ResamplingDistribution.set_threshold_get_cost", "logzero.logger.info", "truedistribution.UncalibratedScore", "logzero.logger.info", "truedistribution.ResamplingDistribution.set_threshold_get_cost", "logzero.logger.info", "truedistribution.ResamplingDistribution"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.set_threshold_get_cost", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.UncalibratedScore.set_threshold_get_cost"], ["", "def", "initialize_true_distribution", "(", "config", ")", ":", "\n", "    ", "\"\"\"Initialize the ground truth distribution to be used.\"\"\"", "\n", "logger", ".", "info", "(", "\"Setup the true distribution...\"", ")", "\n", "td_config", "=", "config", "[", "\"true_distribution\"", "]", "\n", "td_type", "=", "td_config", "[", "\"type\"", "]", "\n", "cost", "=", "None", "\n", "if", "td_type", "==", "\"1d\"", ":", "\n", "        ", "td", "=", "truedistribution", ".", "DummyDistribution1D", "(", "td_config", ")", "\n", "", "elif", "td_type", "==", "\"fico\"", ":", "\n", "        ", "td", "=", "truedistribution", ".", "InverseCDF", "(", "td_config", ")", "\n", "logger", ".", "info", "(", "f\"Setting threshold {td_config['threshold']}...\"", ")", "\n", "cost", "=", "td", ".", "set_threshold_get_cost", "(", "td_config", "[", "\"threshold\"", "]", ")", "\n", "logger", ".", "info", "(", "f\"Resetting corresponding cost: {cost}...\"", ")", "\n", "config", "[", "\"utility\"", "]", "[", "\"cost\"", "]", "=", "cost", "\n", "", "elif", "td_type", "==", "\"uncalibrated\"", ":", "\n", "        ", "td", "=", "truedistribution", ".", "UncalibratedScore", "(", "td_config", ")", "\n", "logger", ".", "info", "(", "f\"Setting threshold {td_config['threshold']}...\"", ")", "\n", "cost", "=", "td", ".", "set_threshold_get_cost", "(", "td_config", "[", "\"threshold\"", "]", ")", "\n", "logger", ".", "info", "(", "f\"Resetting corresponding cost: {cost}...\"", ")", "\n", "config", "[", "\"utility\"", "]", "[", "\"cost\"", "]", "=", "cost", "\n", "", "else", ":", "\n", "        ", "td", "=", "truedistribution", ".", "ResamplingDistribution", "(", "td_config", ")", "\n", "", "return", "td", ",", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.initialize_featuremap": [[79, 103], ["logzero.logger.info", "logzero.logger.info", "td.sample_all", "featuremaps.FeatureMapRBF.fit", "featuremaps.FeatureMapIdentity", "featuremaps.FeatureMapRBF", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.fit"], ["", "def", "initialize_featuremap", "(", "config", ",", "td", ")", ":", "\n", "    ", "\"\"\"\n    Initialize the feature map to be used.\n\n    Args:\n        config: configuration dictionary\n        td: Ground truth distribution.\n\n    Returns:\n        featuremap\n    \"\"\"", "\n", "fm_type", "=", "config", "[", "\"feature_map\"", "]", "[", "\"type\"", "]", "\n", "logger", ".", "info", "(", "f\"Setup the feature map using {fm_type}...\"", ")", "\n", "if", "fm_type", "==", "\"identity\"", ":", "\n", "        ", "fm", "=", "featuremaps", ".", "FeatureMapIdentity", "(", ")", "\n", "", "elif", "fm_type", "==", "\"rbf\"", ":", "\n", "        ", "fm", "=", "featuremaps", ".", "FeatureMapRBF", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", "f\"Unknown feature map type {fm_type}\"", ")", "\n", "\n", "", "logger", ".", "info", "(", "\"Fit feature map from data...\"", ")", "\n", "x0", ",", "y0", ",", "_", "=", "td", ".", "sample_all", "(", "config", "[", "\"feature_map\"", "]", "[", "\"n_fit\"", "]", ")", "\n", "fm", ".", "fit", "(", "x0", ",", "y0", ")", "\n", "return", "fm", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.get_initial_parameters": [[105, 158], ["logzero.logger.info", "logzero.logger.info", "td.sample_all", "utils.fit_logit", "logzero.logger.info", "utils.theta_y_to_d", "logzero.logger.info", "isinstance", "isinstance", "numpy.array().astype", "logzero.logger.info", "utils.theta_y_to_d", "logzero.logger.info", "RuntimeError", "numpy.array"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.fit_logit", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.theta_y_to_d", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.theta_y_to_d"], ["", "def", "get_initial_parameters", "(", "config", ",", "td", ",", "cost", ")", ":", "\n", "    ", "\"\"\"\n    Get the initial parameters for a predicitve model and the policy.\n\n    The issue here is that for the predictive model, we use the cost parameter\n    as a threshold to get binary decisions: P(y|x,s) > c or not.\n    However, the policy directly outputs binary decisions.\n    In practice we use a logistic model for both, i.e., P(y|x,s) is the output\n    of a logistic regression in [0,1] and we compare it to the cost for the\n    predictive model.\n    However, for the policy, we always just use 0.5 as a threshold as we want\n    to learn binary outputs directly.\n\n    For the predictive model, we may obtain initial weights by pre-training\n    a logistic model on a small subset of the data.\n    However, initializing the policy with the same parameters is a bit unfair,\n    because depending on the cost parameter, either the predictive model or the\n    policy will have different acceptance thresholds.\n\n    This function calls `theta_y_to_d` that accounts for this difference.\n\n    Args:\n        config: configuration dictionary\n        td: true distribution\n        cost: cost parameters\n\n    Returns:\n        (init_y, init_d): arrays, the initial parameters for the predictive\n        model and the policy\n    \"\"\"", "\n", "policy_init", "=", "config", "[", "\"policy\"", "]", "[", "\"initialization\"", "]", "\n", "logger", ".", "info", "(", "f\"Setup parameter initialization: {policy_init}...\"", ")", "\n", "if", "policy_init", "==", "\"pre_trained\"", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "f\"Pretrain on {config['policy']['n_pre_training']} iid \"", "\n", "\"samples form ground truth distribution...\"", "\n", ")", "\n", "x0", ",", "y0", ",", "_", "=", "td", ".", "sample_all", "(", "config", "[", "\"policy\"", "]", "[", "\"n_pre_training\"", "]", ")", "\n", "init_y", "=", "fit_logit", "(", "x0", ",", "y0", ")", "\n", "logger", ".", "info", "(", "f\"Initial parameter values for predictive {init_y}\"", ")", "\n", "init_d", "=", "theta_y_to_d", "(", "init_y", ",", "cost", ")", "\n", "logger", ".", "info", "(", "f\"Initial parameter values for decisions {init_d}\"", ")", "\n", "", "elif", "isinstance", "(", "policy_init", ",", "str", ")", ":", "\n", "        ", "init_y", "=", "policy_init", "\n", "init_d", "=", "policy_init", "\n", "", "elif", "isinstance", "(", "policy_init", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "init_y", "=", "np", ".", "array", "(", "policy_init", ")", ".", "astype", "(", "float", ")", "\n", "logger", ".", "info", "(", "f\"Initial parameter values for predictive {init_y}\"", ")", "\n", "init_d", "=", "theta_y_to_d", "(", "init_y", ",", "cost", ")", "\n", "logger", ".", "info", "(", "f\"Initial parameter values for decisions {init_d}\"", ")", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", "f\"Unknown initialization {policy_init}\"", ")", "\n", "", "return", "init_y", ",", "init_d", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.sigmoid": [[166, 177], ["numpy.where", "numpy.exp", "numpy.exp", "numpy.exp"], "function", ["None"], ["", "def", "sigmoid", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Stable (vectorized) implementation of the sigmoid function.\n\n    Args:\n        x: Inputs.\n\n    Returns:\n        sigmoid(x).\n    \"\"\"", "\n", "return", "np", ".", "where", "(", "x", ">=", "0", ",", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "x", ")", ")", ",", "np", ".", "exp", "(", "x", ")", "/", "(", "1", "+", "np", ".", "exp", "(", "x", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.fit_logit": [[179, 192], ["statsmodels.Logit", "sm.Logit.fit"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.featuremaps.FeatureMapIdentity.fit"], ["", "def", "fit_logit", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"\n    Fit a logistic regression classifier.\n\n    Args:\n        x: Input features.\n        y: Binary labels.\n\n    Returns:\n        Fitted model (using statsmodels).\n    \"\"\"", "\n", "model", "=", "sm", ".", "Logit", "(", "y", ",", "x", ")", "\n", "return", "model", ".", "fit", "(", "disp", "=", "0", ")", ".", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.collect_data": [[200, 237], ["distribution.sample_all", "numpy.random.seed", "numpy.full", "len", "ValueError", "policy.sample"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.sample_all", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.sample"], ["", "def", "collect_data", "(", "\n", "distribution", ",", "n", ",", "policy", "=", "None", ",", "fix_proposed", "=", "True", ",", "random_state", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Collect data from a given distribution under a given policy.\n\n    Args:\n        distribution: The true underlying distribution (TrueDistribution).\n        n: The number of examples to draw.\n        policy: A policy for making decisions (see policies). If the policy is\n            `None`, return unfiltered examples from the true distribution.\n        fix_proposed: Whether n is the number of proposed examples, or the\n            number of accepted examples.\n        random_state: Random state for sample collection.\n\n    Returns:\n        4-tuple:\n            [0] xprop: features of proposed examples\n            [1] yprop: labels of proposed examples\n            [2] sprop: protected attributes of proposed examples\n            [4]: d: decisions made by the policy on the existing examples\n    \"\"\"", "\n", "if", "random_state", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "random_state", ")", "\n", "\n", "", "xprop", ",", "yprop", ",", "sprop", "=", "distribution", ".", "sample_all", "(", "n", ",", "yproba", "=", "False", ")", "\n", "if", "policy", "is", "None", ":", "\n", "        ", "d", "=", "np", ".", "full", "(", "len", "(", "yprop", ")", ",", "True", ")", "\n", "", "elif", "fix_proposed", ":", "\n", "        ", "d", "=", "policy", ".", "sample", "(", "xprop", ")", "==", "1", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Fixing the number of accepted (instead of the \"", "\n", "\"number of proposed is not supported anymore at this \"", "\n", "\"point. Please set `fix_proposed` to True.\"", "\n", ")", "\n", "", "return", "xprop", ",", "yprop", ",", "sprop", ",", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.utility": [[245, 266], ["distribution.get_test", "policy.sample", "numpy.sum", "len", "float", "len", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.truedistribution.ResamplingDistribution.get_test", "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.sample"], ["", "def", "utility", "(", "distribution", ",", "policy", ",", "cost", ",", "n", "=", "1000", ",", "acceptance_rate", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Estimate the utility of a policy under a given true distribution.\n\n    Args:\n        distribution: The true underlying distribution (TrueDistribution).\n        policy: A decision making policy (see policies).\n        cost: The cost parameter of the utility in [0,1].\n        n: The number of monte carlo samples used to estimate the utility.\n        acceptance_rate: Whether to also return the acceptance rate.\n\n    Returns:\n        The utility estimate (float).\n    \"\"\"", "\n", "x", ",", "y", ",", "_", "=", "distribution", ".", "get_test", "(", "n", ")", "\n", "d", "=", "policy", ".", "sample", "(", "x", ")", "\n", "util", "=", "np", ".", "sum", "(", "d", "*", "(", "y", "-", "cost", ")", ")", "/", "len", "(", "d", ")", "\n", "if", "acceptance_rate", ":", "\n", "        ", "return", "util", ",", "float", "(", "np", ".", "sum", "(", "d", ")", ")", "/", "len", "(", "d", ")", "\n", "", "else", ":", "\n", "        ", "return", "util", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.extract_parameters": [[268, 285], ["len", "len", "numpy.zeros", "enumerate", "policies[].theta.squeeze", "pi.theta.squeeze"], "function", ["None"], ["", "", "def", "extract_parameters", "(", "policies", ")", ":", "\n", "    ", "\"\"\"\n    Extract the parameters from a collection of policies.\n\n    Args:\n        policies: An iterable collection of policies.\n\n    Returns:\n        np.ndarray of dimension (n, d) where n is the number of policies in the\n            input and d is the dimension of the parameters of all policies.\n    \"\"\"", "\n", "n", "=", "len", "(", "policies", ")", "\n", "d", "=", "len", "(", "policies", "[", "0", "]", ".", "theta", ".", "squeeze", "(", ")", ")", "\n", "thetas", "=", "np", ".", "zeros", "(", "(", "n", ",", "d", ")", ")", "\n", "for", "i", ",", "pi", "in", "enumerate", "(", "policies", ")", ":", "\n", "        ", "thetas", "[", "i", ",", ":", "]", "=", "pi", ".", "theta", ".", "squeeze", "(", ")", "\n", "", "return", "thetas", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.find_x_for_y": [[293, 304], ["numpy.array", "numpy.array", "range", "len"], "function", ["None"], ["", "def", "find_x_for_y", "(", "xs", ",", "ys", ",", "y", ")", ":", "\n", "    ", "\"\"\"Find the x value for a given y value.\"\"\"", "\n", "xs", "=", "np", ".", "array", "(", "xs", ")", "\n", "ys", "=", "np", ".", "array", "(", "ys", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "xs", ")", "-", "1", ")", ":", "\n", "        ", "(", "xold", ",", "yold", ")", "=", "xs", "[", "i", "]", ",", "ys", "[", "i", "]", "\n", "(", "xnew", ",", "ynew", ")", "=", "xs", "[", "i", "+", "1", "]", ",", "ys", "[", "i", "+", "1", "]", "\n", "if", "(", "yold", "-", "y", ")", "*", "(", "ynew", "-", "y", ")", "<", "0", ":", "\n", "            ", "x", "=", "xold", "+", "(", "(", "y", "-", "yold", ")", "/", "(", "ynew", "-", "yold", ")", ")", "*", "(", "xnew", "-", "xold", ")", "\n", "return", "x", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.get_threshold": [[306, 315], ["theta.squeeze.squeeze", "len", "numpy.log"], "function", ["None"], ["", "def", "get_threshold", "(", "theta", ",", "cost", ")", ":", "\n", "    ", "\"\"\"Get the x threshold for a given theta and cost.\"\"\"", "\n", "if", "theta", "is", "None", "or", "len", "(", "theta", ")", ">", "2", ":", "\n", "        ", "return", "\n", "", "theta", "=", "theta", ".", "squeeze", "(", ")", "\n", "if", "cost", "is", "not", "None", ":", "\n", "        ", "return", "(", "-", "theta", "[", "0", "]", "+", "np", ".", "log", "(", "cost", "/", "(", "1", "-", "cost", ")", ")", ")", "/", "theta", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "return", "-", "theta", "[", "0", "]", "/", "theta", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.utils.theta_y_to_d": [[317, 322], ["init_y.copy", "numpy.log"], "function", ["home.repos.pwc.inspect_result.nikikilbertus_fair-decisions.None.policies.Bernoulli.copy"], ["", "", "def", "theta_y_to_d", "(", "init_y", ",", "cost", ")", ":", "\n", "    ", "\"\"\"Convert an predictive model to an euqivlant decision model.\"\"\"", "\n", "init_d", "=", "init_y", ".", "copy", "(", ")", "\n", "init_d", "[", "0", "]", "+=", "np", ".", "log", "(", "(", "1.0", "-", "cost", ")", "/", "cost", ")", "\n", "return", "init_d", "\n", "\n"]]}