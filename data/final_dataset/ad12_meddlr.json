{"home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.status": [[19, 23], ["print"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "status", "(", "s", ")", ":", "\n", "        ", "\"\"\"Prints things in bold.\"\"\"", "\n", "print", "(", "\"\\033[1m{0}\\033[0m\"", ".", "format", "(", "s", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.initialize_options": [[24, 26], ["None"], "methods", ["None"], ["", "def", "initialize_options", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.finalize_options": [[27, 29], ["None"], "methods", ["None"], ["", "def", "finalize_options", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run": [[30, 48], ["setuptools.setup.UploadCommand.status", "os.system", "setuptools.setup.UploadCommand.status", "os.system", "setuptools.setup.UploadCommand.status", "os.system", "os.system", "sys.exit", "setuptools.setup.UploadCommand.status", "shutil.rmtree", "os.path.join", "setup.get_version"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.status", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.status", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.status", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.status", "home.repos.pwc.inspect_result.ad12_meddlr.source.conf.get_version"], ["", "def", "run", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "self", ".", "status", "(", "\"Removing previous builds\u2026\"", ")", "\n", "rmtree", "(", "os", ".", "path", ".", "join", "(", "here", ",", "\"dist\"", ")", ")", "\n", "", "except", "OSError", ":", "\n", "            ", "pass", "\n", "\n", "", "self", ".", "status", "(", "\"Building Source and Wheel (universal) distribution\u2026\"", ")", "\n", "os", ".", "system", "(", "\"{0} setup.py sdist bdist_wheel --universal\"", ".", "format", "(", "sys", ".", "executable", ")", ")", "\n", "\n", "self", ".", "status", "(", "\"Uploading the package to PyPI via Twine\u2026\"", ")", "\n", "os", ".", "system", "(", "\"twine upload dist/*\"", ")", "\n", "\n", "self", ".", "status", "(", "\"Pushing git tags\u2026\"", ")", "\n", "os", ".", "system", "(", "\"git tag v{0}\"", ".", "format", "(", "get_version", "(", ")", ")", ")", "\n", "os", ".", "system", "(", "\"git push --tags\"", ")", "\n", "\n", "sys", ".", "exit", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.get_version": [[50, 56], ["os.path.join", "open().readlines", "[].strip().strip", "os.path.abspath", "os.path.dirname", "open", "l.strip", "[].strip", "l.startswith", "version_line.split"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["", "", "def", "get_version", "(", ")", ":", "\n", "    ", "init_py_path", "=", "path", ".", "join", "(", "path", ".", "abspath", "(", "path", ".", "dirname", "(", "__file__", ")", ")", ",", "\"meddlr\"", ",", "\"__init__.py\"", ")", "\n", "init_py", "=", "open", "(", "init_py_path", ",", "\"r\"", ")", ".", "readlines", "(", ")", "\n", "version_line", "=", "[", "l", ".", "strip", "(", ")", "for", "l", "in", "init_py", "if", "l", ".", "startswith", "(", "\"__version__\"", ")", "]", "[", "0", "]", "# noqa: E741", "\n", "version", "=", "version_line", ".", "split", "(", "\"=\"", ")", "[", "-", "1", "]", ".", "strip", "(", ")", ".", "strip", "(", "\"'\\\"\"", ")", "\n", "return", "version", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.SenseModel.__init__": [[34, 48], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "maps", ":", "torch", ".", "Tensor", ",", "weights", ":", "torch", ".", "Tensor", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            maps (torch.Tensor): Sensitivity maps.\n            weights (torch.Tensor): Undersampling masks.\n                If ``None``, it is assumed that inputs are fully-sampled.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "maps", "=", "maps", "\n", "if", "weights", "is", "None", ":", "\n", "            ", "self", ".", "weights", "=", "1.0", "\n", "", "else", ":", "\n", "            ", "self", ".", "weights", "=", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.SenseModel._adjoint_op": [[49, 63], ["transforms.ifft2", "meddlr.ops.complex.is_complex_as_real", "meddlr.ops.complex.mul", "meddlr.ops.complex.mul.sum", "meddlr.ops.complex.mul", "meddlr.ops.complex.mul.sum", "meddlr.ops.complex.mul.unsqueeze", "meddlr.ops.complex.conj", "meddlr.ops.complex.mul.unsqueeze", "meddlr.ops.complex.conj"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj"], ["", "", "def", "_adjoint_op", "(", "self", ",", "kspace", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            kspace: Shape (B,H,W,#coils,[2])\n        Returns:\n            image: Shape (B,H,W,#maps,[2])\n        \"\"\"", "\n", "image", "=", "ifft2", "(", "self", ".", "weights", "*", "kspace", ")", "\n", "if", "cplx", ".", "is_complex_as_real", "(", "kspace", ")", ":", "\n", "            ", "image", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "2", ")", ",", "cplx", ".", "conj", "(", "self", ".", "maps", ")", ")", "# [B,...,#coils,#maps,2]", "\n", "return", "image", ".", "sum", "(", "-", "3", ")", "\n", "", "else", ":", "\n", "            ", "image", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "1", ")", ",", "cplx", ".", "conj", "(", "self", ".", "maps", ")", ")", "# [B,...,#coils,#maps,1]", "\n", "return", "image", ".", "sum", "(", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.SenseModel._forward_op": [[64, 78], ["meddlr.ops.complex.is_complex_as_real", "meddlr.ops.complex.mul", "meddlr.ops.complex.mul", "image.unsqueeze", "transforms.fft2", "image.unsqueeze", "transforms.fft2", "meddlr.ops.complex.mul.sum", "meddlr.ops.complex.mul.sum"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2"], ["", "", "def", "_forward_op", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image: Shape (B,H,W,#maps,[2])\n        Returns:\n            kspace: Shape (B,H,W,#coils,[2])\n        \"\"\"", "\n", "if", "cplx", ".", "is_complex_as_real", "(", "image", ")", ":", "\n", "            ", "kspace", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "3", ")", ",", "self", ".", "maps", ")", "# [B,...,1,#maps,2]", "\n", "kspace", "=", "self", ".", "weights", "*", "fft2", "(", "kspace", ".", "sum", "(", "-", "2", ")", ")", "# [B,...,#coils,2]", "\n", "", "else", ":", "\n", "            ", "kspace", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "2", ")", ",", "self", ".", "maps", ")", "\n", "kspace", "=", "self", ".", "weights", "*", "fft2", "(", "kspace", ".", "sum", "(", "-", "1", ")", ")", "\n", "", "return", "kspace", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.SenseModel.forward": [[79, 100], ["transforms.SenseModel._adjoint_op", "transforms.SenseModel._forward_op"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.forward.mri.SenseModel._adjoint_op", "home.repos.pwc.inspect_result.ad12_meddlr.forward.mri.SenseModel._forward_op"], ["", "def", "forward", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ",", "adjoint", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Run forward or adjoint SENSE operation on the input.\n\n        Depending on if ``adjoint=True``, the input should either be the\n        k-space or the complex image. The shapes for these are as follows:\n            - kspace: ``(B, H, W, #coils, [2])\n            - image: ``(B, H, W, #maps, [2])``\n\n        Args:\n            input (torch.Tensor): If ``adjoint=True``, this is the multi-coil k-space,\n                else it is the image.\n            adjoint (bool, optional): If ``True``, use adjoint operation.\n\n        Returns:\n            torch.Tensor: If ``adjoint=True``, the image, else multi-coil k-space.\n        \"\"\"", "\n", "if", "adjoint", ":", "\n", "            ", "output", "=", "self", ".", "_adjoint_op", "(", "input", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "self", ".", "_forward_op", "(", "input", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2": [[102, 147], ["meddlr.utils.deprecated.deprecated", "len", "transforms.ifftshift", "torch.Tensor.fft", "transforms.fftshift", "meddlr.utils.env.supports_cplx_tensor", "data.permute.size", "meddlr.utils.env.supports_cplx_tensor", "len", "transforms.ifftshift", "torch.fft.fftn", "transforms.fftshift", "list", "data.permute.permute", "data.permute.permute", "data.permute.size", "list", "data.permute.size", "data.permute.permute", "ValueError", "data.permute.permute", "ValueError", "data.permute.size"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.fft2c\"", ")", "\n", "def", "fft2", "(", "data", ")", ":", "\n", "    ", "\"\"\"\n    Apply centered 2 dimensional Fast Fourier Transform.\n    Args:\n        data (torch.Tensor): Complex valued input data with the last dimension\n            containing real and imaginary components.\n        dims (2-tuple): Containing spatial dimension indices.\n    Returns:\n        torch.Tensor: The FFT of the input.\n    \"\"\"", "\n", "\n", "assert", "data", ".", "size", "(", "-", "1", ")", "==", "2", "or", "env", ".", "supports_cplx_tensor", "(", ")", "\n", "if", "data", ".", "size", "(", "-", "1", ")", "!=", "2", ":", "\n", "# Complex tensors supported", "\n", "        ", "assert", "env", ".", "supports_cplx_tensor", "(", ")", ",", "torch", ".", "__version__", "# torch.__version__ >= 1.7", "\n", "ndims", "=", "len", "(", "list", "(", "data", ".", "size", "(", ")", ")", ")", "\n", "dims", "=", "(", "1", ",", "2", ")", "\n", "\n", "data", "=", "ifftshift", "(", "data", ",", "dim", "=", "dims", ")", "\n", "data", "=", "torch", ".", "fft", ".", "fftn", "(", "data", ",", "dim", "=", "dims", ",", "norm", "=", "\"ortho\"", ")", "\n", "data", "=", "fftshift", "(", "data", ",", "dim", "=", "dims", ")", "\n", "return", "data", "\n", "\n", "", "ndims", "=", "len", "(", "list", "(", "data", ".", "size", "(", ")", ")", ")", "\n", "\n", "if", "ndims", "==", "5", ":", "\n", "        ", "data", "=", "data", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ",", "4", ")", "\n", "", "elif", "ndims", "==", "6", ":", "\n", "        ", "data", "=", "data", ".", "permute", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ",", "5", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"fft2: ndims > 6 not supported!\"", ")", "\n", "\n", "", "data", "=", "ifftshift", "(", "data", ",", "dim", "=", "(", "-", "3", ",", "-", "2", ")", ")", "\n", "data", "=", "torch", ".", "Tensor", ".", "fft", "(", "data", ",", "2", ",", "normalized", "=", "True", ")", "\n", "data", "=", "fftshift", "(", "data", ",", "dim", "=", "(", "-", "3", ",", "-", "2", ")", ")", "\n", "\n", "if", "ndims", "==", "5", ":", "\n", "        ", "data", "=", "data", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ",", "4", ")", "\n", "", "elif", "ndims", "==", "6", ":", "\n", "        ", "data", "=", "data", ".", "permute", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ",", "5", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"fft2: ndims > 6 not supported!\"", ")", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2": [[149, 193], ["meddlr.utils.deprecated.deprecated", "len", "transforms.ifftshift", "torch.ifft", "transforms.fftshift", "meddlr.utils.env.supports_cplx_tensor", "data.permute.size", "meddlr.utils.env.supports_cplx_tensor", "len", "transforms.ifftshift", "torch.fft.ifftn", "transforms.fftshift", "list", "data.permute.permute", "data.permute.permute", "data.permute.size", "list", "data.permute.size", "data.permute.permute", "ValueError", "data.permute.permute", "ValueError", "data.permute.size"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.ifft2c\"", ")", "\n", "def", "ifft2", "(", "data", ")", ":", "\n", "    ", "\"\"\"\n    Apply centered 2-dimensional Inverse Fast Fourier Transform.\n    Args:\n        data (torch.Tensor): Complex valued input data with the last dimension\n            containing real and imaginary components.\n        dims (2-tuple): Containing spatial dimension indices.\n    Returns:\n        torch.Tensor: The IFFT of the input.\n    \"\"\"", "\n", "assert", "data", ".", "size", "(", "-", "1", ")", "==", "2", "or", "env", ".", "supports_cplx_tensor", "(", ")", "\n", "if", "data", ".", "size", "(", "-", "1", ")", "!=", "2", ":", "\n", "# Complex tensors supported", "\n", "        ", "assert", "env", ".", "supports_cplx_tensor", "(", ")", ",", "torch", ".", "__version__", "# torch.__version__ >= 1.7", "\n", "ndims", "=", "len", "(", "list", "(", "data", ".", "size", "(", ")", ")", ")", "\n", "dims", "=", "(", "1", ",", "2", ")", "\n", "\n", "data", "=", "ifftshift", "(", "data", ",", "dim", "=", "dims", ")", "\n", "data", "=", "torch", ".", "fft", ".", "ifftn", "(", "data", ",", "dim", "=", "dims", ",", "norm", "=", "\"ortho\"", ")", "\n", "data", "=", "fftshift", "(", "data", ",", "dim", "=", "dims", ")", "\n", "return", "data", "\n", "\n", "", "ndims", "=", "len", "(", "list", "(", "data", ".", "size", "(", ")", ")", ")", "\n", "\n", "if", "ndims", "==", "5", ":", "\n", "        ", "data", "=", "data", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ",", "4", ")", "\n", "", "elif", "ndims", "==", "6", ":", "\n", "        ", "data", "=", "data", ".", "permute", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ",", "5", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"ifft2: ndims > 6 not supported!\"", ")", "\n", "\n", "", "data", "=", "ifftshift", "(", "data", ",", "dim", "=", "(", "-", "3", ",", "-", "2", ")", ")", "\n", "data", "=", "torch", ".", "ifft", "(", "data", ",", "2", ",", "normalized", "=", "True", ")", "\n", "data", "=", "fftshift", "(", "data", ",", "dim", "=", "(", "-", "3", ",", "-", "2", ")", ")", "\n", "\n", "if", "ndims", "==", "5", ":", "\n", "        ", "data", "=", "data", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ",", "4", ")", "\n", "", "elif", "ndims", "==", "6", ":", "\n", "        ", "data", "=", "data", ".", "permute", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ",", "5", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"ifft2: ndims > 6 not supported!\"", ")", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.root_sum_of_squares": [[195, 203], ["meddlr.utils.deprecated.deprecated", "torch.sqrt", "x.size"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.complex.rss\"", ")", "\n", "def", "root_sum_of_squares", "(", "x", ",", "dim", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Compute the root sum-of-squares (RSS) transform along a given dimension of\n    a complex-valued tensor.\n    \"\"\"", "\n", "assert", "x", ".", "size", "(", "-", "1", ")", "==", "2", "\n", "return", "torch", ".", "sqrt", "(", "(", "x", "**", "2", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", ".", "sum", "(", "dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.time_average": [[205, 211], ["meddlr.utils.deprecated.deprecated", "meddlr.time_average"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.time_average"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.time_average\"", ")", "\n", "def", "time_average", "(", "data", ",", "dim", ",", "eps", "=", "1e-6", ",", "keepdim", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Computes time average across a specified axis.\n    \"\"\"", "\n", "return", "oF", ".", "time_average", "(", "data", ",", "dim", ",", "eps", "=", "eps", ",", "keepdim", "=", "keepdim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.sliding_window": [[213, 220], ["meddlr.utils.deprecated.deprecated", "meddlr.sliding_window"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.sliding_window"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.sliding_window\"", ")", "\n", "def", "sliding_window", "(", "data", ",", "dim", ",", "window_size", ")", ":", "\n", "    ", "\"\"\"\n    Computes sliding window with circular boundary conditions across a specified\n    axis.\n    \"\"\"", "\n", "return", "oF", ".", "sliding_window", "(", "data", ",", "dim", ",", "window_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.center_crop": [[222, 232], ["meddlr.utils.deprecated.deprecated", "meddlr.center_crop"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.center_crop"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.center_crop\"", ")", "\n", "def", "center_crop", "(", "data", ",", "shape", ")", ":", "\n", "    ", "\"\"\"\n    Apply a center crop to a batch of images.\n    Args:\n        data (torch.Tensor): The input tensor to be center cropped.\n        shape (list of ints): The output shape. If shape[dim] = -1, then no crop\n            will be applied in that dimension.\n    \"\"\"", "\n", "return", "oF", ".", "center_crop", "(", "data", ",", "shape", ",", "include_batch", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.complex_center_crop_2d": [[234, 254], ["meddlr.utils.deprecated.deprecated"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.complex.complex_center_crop_2d\"", ")", "\n", "def", "complex_center_crop_2d", "(", "data", ",", "shape", ")", ":", "\n", "    ", "\"\"\"\n    Apply a center crop to the input image or batch of complex images.\n    Args:\n        data (torch.Tensor): The complex input tensor to be center cropped. It should\n            have at least 3 dimensions and the cropping is applied along dimensions\n            -3 and -2 and the last dimensions should have a size of 2.\n        shape (int, int): The output shape. The shape should be smaller than the\n            corresponding dimensions of data.\n    Returns:\n        torch.Tensor: The center cropped image\n    \"\"\"", "\n", "assert", "0", "<", "shape", "[", "0", "]", "<=", "data", ".", "shape", "[", "-", "3", "]", "\n", "assert", "0", "<", "shape", "[", "1", "]", "<=", "data", ".", "shape", "[", "-", "2", "]", "\n", "w_from", "=", "(", "data", ".", "shape", "[", "-", "3", "]", "-", "shape", "[", "0", "]", ")", "//", "2", "\n", "h_from", "=", "(", "data", ".", "shape", "[", "-", "2", "]", "-", "shape", "[", "1", "]", ")", "//", "2", "\n", "w_to", "=", "w_from", "+", "shape", "[", "0", "]", "\n", "h_to", "=", "h_from", "+", "shape", "[", "1", "]", "\n", "return", "data", "[", "...", ",", "w_from", ":", "w_to", ",", "h_from", ":", "h_to", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.normalize": [[256, 270], ["meddlr.utils.deprecated.deprecated"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.normalize\"", ")", "\n", "def", "normalize", "(", "data", ",", "mean", ",", "stddev", ",", "eps", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"\n    Normalize the given tensor using:\n        (data - mean) / (stddev + eps)\n    Args:\n        data (torch.Tensor): Input data to be normalized\n        mean (float): Mean value\n        stddev (float): Standard deviation\n        eps (float): Added to stddev to prevent dividing by zero\n    Returns:\n        torch.Tensor: Normalized tensor\n    \"\"\"", "\n", "return", "(", "data", "-", "mean", ")", "/", "(", "stddev", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.normalize_instance": [[272, 287], ["meddlr.utils.deprecated.deprecated", "data.mean", "data.std", "transforms.normalize"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TopMagnitudeNormalizer.normalize"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.normalize_instance\"", ")", "\n", "def", "normalize_instance", "(", "data", ",", "eps", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"\n    Normalize the given tensor using:\n        (data - mean) / (stddev + eps)\n    where mean and stddev are computed from the data itself.\n    Args:\n        data (torch.Tensor): Input data to be normalized\n        eps (float): Added to stddev to prevent dividing by zero\n    Returns:\n        torch.Tensor: Normalized tensor\n    \"\"\"", "\n", "mean", "=", "data", ".", "mean", "(", ")", "\n", "std", "=", "data", ".", "std", "(", ")", "\n", "return", "normalize", "(", "data", ",", "mean", ",", "std", ",", "eps", ")", ",", "mean", ",", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.roll": [[292, 298], ["meddlr.utils.deprecated.deprecated", "meddlr.roll"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.roll"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.complex.center_crop\"", ")", "\n", "def", "roll", "(", "x", ",", "shift", ",", "dim", ")", ":", "\n", "    ", "\"\"\"\n    Similar to np.roll but applies to PyTorch Tensors\n    \"\"\"", "\n", "return", "oF", ".", "roll", "(", "x", ",", "shift", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fftshift": [[300, 306], ["meddlr.utils.deprecated.deprecated", "meddlr.fftshift"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.fftshift\"", ")", "\n", "def", "fftshift", "(", "x", ",", "dim", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Similar to np.fft.fftshift but applies to PyTorch Tensors\n    \"\"\"", "\n", "return", "oF", ".", "fftshift", "(", "x", ",", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifftshift": [[308, 314], ["meddlr.utils.deprecated.deprecated", "meddlr.ifftshift"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.ifftshift\"", ")", "\n", "def", "ifftshift", "(", "x", ",", "dim", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Similar to np.fft.ifftshift but applies to PyTorch Tensors\n    \"\"\"", "\n", "return", "oF", ".", "ifftshift", "(", "x", ",", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.pad": [[316, 325], ["meddlr.utils.deprecated.deprecated", "meddlr.pad"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.pad\"", ")", "\n", "def", "pad", "(", "x", ":", "torch", ".", "Tensor", ",", "shape", ":", "Sequence", "[", "int", "]", ",", "mode", "=", "\"constant\"", ",", "value", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        x: Input tensor of shape (B, ...)\n        shape: Shape to zero pad to. Use `None` to skip padding certain dimensions.\n    Returns:\n    \"\"\"", "\n", "return", "oF", ".", "pad", "(", "x", ",", "shape", ",", "mode", "=", "mode", ",", "value", "=", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.zero_pad": [[327, 330], ["meddlr.utils.deprecated.deprecated", "meddlr.zero_pad"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.zero_pad"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"ops.zero_pad\"", ")", "\n", "def", "zero_pad", "(", "x", ":", "torch", ".", "Tensor", ",", "shape", ":", "Sequence", "[", "int", "]", ")", ":", "\n", "    ", "return", "oF", ".", "zero_pad", "(", "x", ",", "shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.read_hdr": [[12, 23], ["open", "open.readline", "open.readline", "open.close", "int", "dims.reverse", "h.readline.split"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["def", "read_hdr", "(", "name", ",", "order", "=", "\"C\"", ")", ":", "\n", "    ", "\"\"\"Read hdr file.\"\"\"", "\n", "# get dims from .hdr", "\n", "h", "=", "open", "(", "name", "+", "\".hdr\"", ",", "\"r\"", ")", "\n", "h", ".", "readline", "(", ")", "# skip line", "\n", "l", "=", "h", ".", "readline", "(", ")", "# noqa: E741", "\n", "h", ".", "close", "(", ")", "\n", "dims", "=", "[", "int", "(", "i", ")", "for", "i", "in", "l", ".", "split", "(", ")", "]", "\n", "if", "order", "==", "\"C\"", ":", "\n", "        ", "dims", ".", "reverse", "(", ")", "\n", "", "return", "dims", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.read": [[25, 39], ["cfl.read_hdr", "numpy.prod", "open", "numpy.fromfile", "open.close", "np.fromfile.reshape"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.read_hdr", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["", "def", "read", "(", "name", ",", "order", "=", "\"C\"", ")", ":", "\n", "    ", "dims", "=", "read_hdr", "(", "name", ",", "order", ")", "\n", "\n", "# remove singleton dimensions from the end", "\n", "n", "=", "np", ".", "prod", "(", "dims", ")", "\n", "# dims_prod = np.cumprod(dims)", "\n", "# dims = dims[:np.searchsorted(dims_prod, n)+1]", "\n", "\n", "# load data and reshape into dims", "\n", "d", "=", "open", "(", "name", "+", "\".cfl\"", ",", "\"r\"", ")", "\n", "a", "=", "np", ".", "fromfile", "(", "d", ",", "dtype", "=", "np", ".", "complex64", ",", "count", "=", "n", ")", "\n", "d", ".", "close", "(", ")", "\n", "\n", "return", "a", ".", "reshape", "(", "dims", ",", "order", "=", "order", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.readcfl": [[41, 43], ["cfl.read"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.read"], ["", "def", "readcfl", "(", "name", ")", ":", "\n", "    ", "return", "read", "(", "name", ",", "order", "=", "\"F\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.write": [[45, 64], ["open", "open.write", "open.write", "open.close", "open", "open.close", "array.astype().tofile", "array.T.astype().tofile", "open.write", "open.write", "array.astype", "array.T.astype"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write"], ["", "def", "write", "(", "name", ",", "array", ",", "order", "=", "\"C\"", ")", ":", "\n", "    ", "h", "=", "open", "(", "name", "+", "\".hdr\"", ",", "\"w\"", ")", "\n", "h", ".", "write", "(", "\"# Dimensions\\n\"", ")", "\n", "if", "order", "==", "\"C\"", ":", "\n", "        ", "for", "i", "in", "array", ".", "shape", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "h", ".", "write", "(", "\"%d \"", "%", "i", ")", "\n", "", "", "else", ":", "\n", "        ", "for", "i", "in", "array", ".", "shape", ":", "\n", "            ", "h", ".", "write", "(", "\"%d \"", "%", "i", ")", "\n", "", "", "h", ".", "write", "(", "\"\\n\"", ")", "\n", "h", ".", "close", "(", ")", "\n", "\n", "d", "=", "open", "(", "name", "+", "\".cfl\"", ",", "\"w\"", ")", "\n", "if", "order", "==", "\"C\"", ":", "\n", "        ", "array", ".", "astype", "(", "np", ".", "complex64", ")", ".", "tofile", "(", "d", ")", "\n", "", "else", ":", "\n", "# tranpose for column-major order", "\n", "        ", "array", ".", "T", ".", "astype", "(", "np", ".", "complex64", ")", ".", "tofile", "(", "d", ")", "\n", "", "d", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.writecfl": [[66, 68], ["cfl.write"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write"], ["", "def", "writecfl", "(", "name", ",", "array", ")", ":", "\n", "    ", "write", "(", "name", ",", "array", ",", "order", "=", "\"F\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventWriter.write": [[46, 48], ["None"], "methods", ["None"], ["def", "write", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventWriter.close": [[49, 51], ["None"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.JSONWriter.__init__": [[100, 110], ["_PATH_MANAGER.open"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["def", "__init__", "(", "self", ",", "json_file", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            json_file (str): path to the json file. New data will be appended\n                if the file exists.\n            window_size (int): the window size of median smoothing for the\n                scalars whose `smoothing_hint` are True.\n        \"\"\"", "\n", "self", ".", "_file_handle", "=", "_PATH_MANAGER", ".", "open", "(", "json_file", ",", "\"a\"", ")", "\n", "self", ".", "_window_size", "=", "window_size", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.JSONWriter.write": [[111, 121], ["events.get_event_storage", "to_save.update", "events.JSONWriter._file_handle.write", "events.JSONWriter._file_handle.flush", "get_event_storage.latest_with_smoothing_hint", "os.fsync", "json.dumps", "events.JSONWriter._file_handle.fileno"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "to_save", "=", "{", "\"iteration\"", ":", "storage", ".", "iter", "}", "\n", "to_save", ".", "update", "(", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", ")", "\n", "self", ".", "_file_handle", ".", "write", "(", "json", ".", "dumps", "(", "to_save", ",", "sort_keys", "=", "True", ")", "+", "\"\\n\"", ")", "\n", "self", ".", "_file_handle", ".", "flush", "(", ")", "\n", "try", ":", "\n", "            ", "os", ".", "fsync", "(", "self", ".", "_file_handle", ".", "fileno", "(", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.JSONWriter.close": [[122, 124], ["events.JSONWriter._file_handle.close"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "_file_handle", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.TensorboardXWriter.__init__": [[131, 145], ["SummaryWriter"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log_dir", ":", "str", ",", "window_size", ":", "int", "=", "20", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            log_dir (str): the directory to save the output events\n            window_size (int): the scalars will be median-smoothed by this\n                window size\n\n            kwargs: other arguments passed to\n                `torch.utils.tensorboard.SummaryWriter(...)`\n        \"\"\"", "\n", "self", ".", "_window_size", "=", "window_size", "\n", "from", "torch", ".", "utils", ".", "tensorboard", "import", "SummaryWriter", "\n", "\n", "self", ".", "_writer", "=", "SummaryWriter", "(", "log_dir", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.TensorboardXWriter.write": [[146, 155], ["events.get_event_storage", "get_event_storage.latest_with_smoothing_hint().items", "events.TensorboardXWriter._writer.add_scalar", "len", "get_event_storage.clear_images", "get_event_storage.latest_with_smoothing_hint", "events.TensorboardXWriter._writer.add_image"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.clear_images", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "for", "k", ",", "v", "in", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "_writer", ".", "add_scalar", "(", "k", ",", "v", ",", "storage", ".", "iter", ")", "\n", "\n", "", "if", "len", "(", "storage", ".", "vis_data", ")", ">=", "1", ":", "\n", "            ", "for", "img_name", ",", "img", ",", "step_num", ",", "data_format", "in", "storage", ".", "vis_data", ":", "\n", "                ", "self", ".", "_writer", ".", "add_image", "(", "img_name", ",", "img", ",", "step_num", ",", "dataformats", "=", "data_format", ")", "\n", "", "storage", ".", "clear_images", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.TensorboardXWriter.close": [[156, 159], ["hasattr", "events.TensorboardXWriter._writer.close"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "\"_writer\"", ")", ":", "# doesn't exist when the code fails at import", "\n", "            ", "self", ".", "_writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.CommonMetricPrinter.__init__": [[170, 183], ["logging.getLogger"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "max_iter", ",", "eval_period", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            max_iter (int): the maximum number of iterations to train.\n                Used to compute ETA.\n            eval_period (int): the period for performing evaluation.\n                Specifying this will result in a better ETA estimate.\n                Assumes evaluation will be done at least once when training ends\n                and key \"eval_time\" recorded in `storage.history`.\n        \"\"\"", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "self", ".", "_max_iter", "=", "max_iter", "\n", "self", ".", "_eval_period", "=", "eval_period", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.CommonMetricPrinter.write": [[184, 243], ["events.get_event_storage", "torch.cuda.is_available", "events.CommonMetricPrinter.logger.info", "get_event_storage.history().avg", "get_event_storage.history().global_avg", "get_event_storage.put_scalar", "str", "get_event_storage.histories", "get_event_storage.history().latest", "get_event_storage.history().median", "datetime.timedelta", "get_event_storage.history().latest", "get_event_storage.history", "get_event_storage.history", "get_event_storage.histories", "math.ceil", "get_event_storage.history().avg", "torch.cuda.max_memory_allocated", "get_event_storage.history", "get_event_storage.history", "int", "get_event_storage.history", "get_event_storage.history", "v.median", "get_event_storage.histories().items", "get_event_storage.histories", "v.median"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.histories", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.latest", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.latest", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.histories", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.histories"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "iteration", "=", "storage", ".", "iter", "\n", "\n", "data_time", ",", "time", "=", "None", ",", "None", "\n", "eta_string", "=", "\"N/A\"", "\n", "try", ":", "\n", "            ", "data_time", "=", "storage", ".", "history", "(", "\"data_time\"", ")", ".", "avg", "(", "20", ")", "\n", "time", "=", "storage", ".", "history", "(", "\"time\"", ")", ".", "global_avg", "(", ")", "\n", "eta_seconds", "=", "storage", ".", "history", "(", "\"time\"", ")", ".", "median", "(", "1000", ")", "*", "(", "self", ".", "_max_iter", "-", "iteration", ")", "\n", "if", "self", ".", "_eval_period", "and", "\"eval_time\"", "in", "storage", ".", "histories", "(", ")", ":", "\n", "                ", "num_eval_done", "=", "(", "iteration", "+", "1", ")", "//", "self", ".", "_eval_period", "\n", "num_eval_remaining", "=", "math", ".", "ceil", "(", "self", ".", "_max_iter", "/", "self", ".", "_eval_period", ")", "-", "num_eval_done", "\n", "eta_seconds", "+=", "storage", ".", "history", "(", "\"eval_time\"", ")", ".", "avg", "(", "2", ")", "*", "num_eval_remaining", "\n", "\n", "", "storage", ".", "put_scalar", "(", "\"eta_seconds\"", ",", "eta_seconds", ",", "smoothing_hint", "=", "False", ")", "\n", "eta_string", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "eta_seconds", ")", ")", ")", "\n", "", "except", "KeyError", ":", "# they may not exist in the first few iterations (due to warmup)  # noqa: E501", "\n", "            ", "pass", "\n", "\n", "", "try", ":", "\n", "            ", "lr", "=", "\"{:.6f}\"", ".", "format", "(", "storage", ".", "history", "(", "\"lr\"", ")", ".", "latest", "(", ")", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "lr", "=", "\"N/A\"", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "max_mem_mb", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "/", "1024.0", "/", "1024.0", "\n", "", "else", ":", "\n", "            ", "max_mem_mb", "=", "None", "\n", "\n", "", "ram_key", "=", "\"guppy/total_RAM\"", "\n", "if", "ram_key", "in", "storage", ".", "histories", "(", ")", ":", "\n", "            ", "total_ram", "=", "storage", ".", "history", "(", "ram_key", ")", ".", "latest", "(", ")", "# this value is already in MB", "\n", "", "else", ":", "\n", "            ", "total_ram", "=", "None", "\n", "\n", "# NOTE: max_mem is parsed by grep in \"dev/parse_results.sh\"", "\n", "", "self", ".", "logger", ".", "info", "(", "\n", "\"\"\"\\\neta: {eta}  iter: {iter}  {losses}  \\\n{time}  {data_time}  \\\nlr: {lr}  {memory}  {ram}\\\n\"\"\"", ".", "format", "(", "\n", "eta", "=", "eta_string", ",", "\n", "iter", "=", "iteration", ",", "\n", "losses", "=", "\"  \"", ".", "join", "(", "\n", "[", "\n", "(", "\"{}: {:.3%s}\"", "%", "(", "\"f\"", "if", "v", ".", "median", "(", "20", ")", ">=", "0.0005", "else", "\"e\"", ")", ")", ".", "format", "(", "\n", "k", ",", "v", ".", "median", "(", "20", ")", "\n", ")", "\n", "for", "k", ",", "v", "in", "storage", ".", "histories", "(", ")", ".", "items", "(", ")", "\n", "if", "\"loss\"", "in", "k", "\n", "]", "\n", ")", ",", "\n", "time", "=", "\"time: {:.4f}\"", ".", "format", "(", "time", ")", "if", "time", "is", "not", "None", "else", "\"\"", ",", "\n", "data_time", "=", "\"data_time: {:.4f}\"", ".", "format", "(", "data_time", ")", "if", "data_time", "is", "not", "None", "else", "\"\"", ",", "\n", "lr", "=", "lr", ",", "\n", "memory", "=", "\"max_mem: {:.0f}M\"", ".", "format", "(", "max_mem_mb", ")", "if", "max_mem_mb", "is", "not", "None", "else", "\"\"", ",", "\n", "ram", "=", "\"total_RAM: {:.0f}M\"", ".", "format", "(", "total_ram", ")", "if", "total_ram", "is", "not", "None", "else", "\"\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.__init__": [[258, 269], ["meddlr.utils.env.supports_wandb", "ModuleNotFoundError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_wandb"], ["def", "__init__", "(", "self", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            window_size (int): the window size of median smoothing for the\n                scalars whose `smoothing_hint` are True.\n        \"\"\"", "\n", "if", "not", "supports_wandb", "(", ")", ":", "\n", "            ", "raise", "ModuleNotFoundError", "(", "\"Module `wandb` not found or running in debug mode.\"", ")", "\n", "", "if", "wandb", ".", "run", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"wand.run not found. Call `wand.init` before creating writer.\"", ")", "\n", "", "self", ".", "_window_size", "=", "window_size", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write": [[270, 274], ["events.get_event_storage", "get_event_storage.latest_with_smoothing_hint", "wandb.log"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "to_save", "=", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", "\n", "wandb", ".", "log", "(", "to_save", ",", "step", "=", "storage", ".", "iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.__init__": [[286, 297], ["collections.defaultdict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "start_iter", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            start_iter (int): the iteration number to start with\n        \"\"\"", "\n", "self", ".", "_history", "=", "defaultdict", "(", "HistoryBuffer", ")", "\n", "self", ".", "_smoothing_hints", "=", "{", "}", "\n", "self", ".", "_latest_scalars", "=", "{", "}", "\n", "self", ".", "_iter", "=", "start_iter", "\n", "self", ".", "_current_prefix", "=", "\"\"", "\n", "self", ".", "_vis_data", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image": [[298, 312], ["events.EventStorage._vis_data.append"], "methods", ["None"], ["", "def", "put_image", "(", "self", ",", "img_name", ",", "img_tensor", ",", "data_format", "=", "\"HWC\"", ")", ":", "\n", "        ", "\"\"\"\n        Add an `img_tensor` to the `_vis_data` associated with `img_name`.\n\n        Args:\n            img_name (str): The name of the image to put into tensorboard.\n            img_tensor (torch.Tensor or numpy.array): An `uint8` or `float`\n                Tensor of shape `[channel, height, width]` where `channel` is\n                3. The image format should be RGB. The elements in img_tensor\n                can either have values in [0, 1] (float32) or [0, 255] (uint8).\n                The `img_tensor` will be visualized in tensorboard.\n            data_format (str): Either \"CHW\", \"HW\", or \"HWC\"\n        \"\"\"", "\n", "self", ".", "_vis_data", ".", "append", "(", "(", "img_name", ",", "img_tensor", ",", "self", ".", "_iter", ",", "data_format", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.clear_images": [[313, 319], ["None"], "methods", ["None"], ["", "def", "clear_images", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Delete all the stored images for visualization. This should be called\n        after images are written to tensorboard.\n        \"\"\"", "\n", "self", ".", "_vis_data", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalar": [[320, 348], ["float", "history.update", "events.EventStorage._smoothing_hints.get"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "put_scalar", "(", "self", ",", "name", ",", "value", ",", "smoothing_hint", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Add a scalar `value` to the `HistoryBuffer` associated with `name`.\n\n        Args:\n            smoothing_hint (bool): a 'hint' on whether this scalar is noisy and\n                should be\n                smoothed when logged. The hint will be accessible through\n                :meth:`EventStorage.smoothing_hints`.  A writer may ignore the\n                hint and apply custom smoothing rule.\n\n                It defaults to True because most scalars we save need to be\n                smoothed to\n                provide any useful signal.\n        \"\"\"", "\n", "name", "=", "self", ".", "_current_prefix", "+", "name", "\n", "history", "=", "self", ".", "_history", "[", "name", "]", "\n", "value", "=", "float", "(", "value", ")", "\n", "history", ".", "update", "(", "value", ",", "self", ".", "_iter", ")", "\n", "self", ".", "_latest_scalars", "[", "name", "]", "=", "value", "\n", "\n", "existing_hint", "=", "self", ".", "_smoothing_hints", ".", "get", "(", "name", ")", "\n", "if", "existing_hint", "is", "not", "None", ":", "\n", "            ", "assert", "(", "\n", "existing_hint", "==", "smoothing_hint", "\n", ")", ",", "\"Scalar {} was put with a different smoothing_hint!\"", ".", "format", "(", "name", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_smoothing_hints", "[", "name", "]", "=", "smoothing_hint", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalars": [[349, 361], ["kwargs.items", "events.EventStorage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalar"], ["", "", "def", "put_scalars", "(", "self", ",", "*", ",", "smoothing_hint", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Put multiple scalars from keyword arguments.\n\n        Examples:\n\n            storage.put_scalars(\n                loss=my_loss, accuracy=my_accuracy, smoothing_hint=True\n            )\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "put_scalar", "(", "k", ",", "v", ",", "smoothing_hint", "=", "smoothing_hint", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.history": [[362, 371], ["events.EventStorage._history.get", "KeyError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "", "def", "history", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            HistoryBuffer: the scalar history for name\n        \"\"\"", "\n", "ret", "=", "self", ".", "_history", ".", "get", "(", "name", ",", "None", ")", "\n", "if", "ret", "is", "None", ":", "\n", "            ", "raise", "KeyError", "(", "\"No history metric available for {}!\"", ".", "format", "(", "name", ")", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.histories": [[372, 378], ["None"], "methods", ["None"], ["", "def", "histories", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> HistoryBuffer]: the HistoryBuffer for all scalars\n        \"\"\"", "\n", "return", "self", ".", "_history", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.latest": [[379, 386], ["None"], "methods", ["None"], ["", "def", "latest", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> number]: the scalars that's added in the current\n                iteration.\n        \"\"\"", "\n", "return", "self", ".", "_latest_scalars", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.latest_with_smoothing_hint": [[387, 400], ["events.EventStorage._latest_scalars.items", "events.EventStorage._history[].median"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "latest_with_smoothing_hint", "(", "self", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Similar to :meth:`latest`, but the returned values\n        are either the un-smoothed original latest value,\n        or a median of the given window_size,\n        depend on whether the smoothing_hint is True.\n\n        This provides a default behavior that other writers can use.\n        \"\"\"", "\n", "result", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "self", ".", "_latest_scalars", ".", "items", "(", ")", ":", "\n", "            ", "result", "[", "k", "]", "=", "self", ".", "_history", "[", "k", "]", ".", "median", "(", "window_size", ")", "if", "self", ".", "_smoothing_hints", "[", "k", "]", "else", "v", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.smoothing_hints": [[401, 408], ["None"], "methods", ["None"], ["", "def", "smoothing_hints", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> bool]: the user-provided hint on whether the scalar\n                is noisy and needs smoothing.\n        \"\"\"", "\n", "return", "self", ".", "_smoothing_hints", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.step": [[409, 418], ["None"], "methods", ["None"], ["", "def", "step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        User should call this function at the beginning of each iteration, to\n        notify the storage of the start of a new iteration.\n        The storage will then be able to associate the new data with the\n        correct iteration number.\n        \"\"\"", "\n", "self", ".", "_iter", "+=", "1", "\n", "self", ".", "_latest_scalars", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.vis_data": [[419, 422], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "vis_data", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_vis_data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter": [[423, 426], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "iter", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iteration": [[427, 431], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "iteration", "(", "self", ")", ":", "\n", "# for backward compatibility", "\n", "        ", "return", "self", ".", "_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.__enter__": [[432, 435], ["_CURRENT_STORAGE_STACK.append"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "_CURRENT_STORAGE_STACK", ".", "append", "(", "self", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.__exit__": [[436, 439], ["_CURRENT_STORAGE_STACK.pop"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "exc_type", ",", "exc_val", ",", "exc_tb", ")", ":", "\n", "        ", "assert", "_CURRENT_STORAGE_STACK", "[", "-", "1", "]", "==", "self", "\n", "_CURRENT_STORAGE_STACK", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.name_scope": [[440, 451], ["name.rstrip"], "methods", ["None"], ["", "@", "contextmanager", "\n", "def", "name_scope", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Yields:\n            A context within which all the events added to this storage\n            will be prefixed by the name scope.\n        \"\"\"", "\n", "old_prefix", "=", "self", ".", "_current_prefix", "\n", "self", ".", "_current_prefix", "=", "name", ".", "rstrip", "(", "\"/\"", ")", "+", "\"/\"", "\n", "yield", "\n", "self", ".", "_current_prefix", "=", "old_prefix", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage": [[28, 38], ["len"], "function", ["None"], ["def", "get_event_storage", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The :class:`EventStorage` object that's currently being used.\n        Throws an error if no :class`EventStorage` is currently enabled.\n    \"\"\"", "\n", "assert", "len", "(", "_CURRENT_STORAGE_STACK", ")", ",", "(", "\n", "\"get_event_storage() has to be called inside a \"", "\"'with EventStorage(...)' context!\"", "\n", ")", "\n", "return", "_CURRENT_STORAGE_STACK", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_world_size": [[26, 34], ["torch.get_world_size", "torch.is_available", "torch.is_initialized", "meddlr.utils.env.is_pt_lightning", "int"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_pt_lightning"], ["def", "get_world_size", "(", ")", "->", "int", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "if", "env", ".", "is_pt_lightning", "(", ")", "and", "\"WORLD_SIZE\"", "in", "os", ".", "environ", ":", "\n", "            ", "return", "int", "(", "os", ".", "environ", "[", "\"WORLD_SIZE\"", "]", ")", "\n", "", "return", "1", "\n", "", "return", "dist", ".", "get_world_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank": [[36, 50], ["torch.get_rank", "torch.is_available", "torch.is_initialized", "meddlr.utils.env.is_pt_lightning", "os.environ.get", "max", "len", "len", "comm.get_local_rank", "os.environ.get.split", "int"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_pt_lightning", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_local_rank"], ["", "def", "get_rank", "(", ")", "->", "int", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "if", "env", ".", "is_pt_lightning", "(", ")", "and", "\"NODE_RANK\"", "in", "os", ".", "environ", ":", "\n", "# Assumes same number of gpus are assigned per machine.", "\n", "# Does not support distributed with TPUs", "\n", "            ", "gpu_ids", "=", "os", ".", "environ", ".", "get", "(", "\"CUDA_VISIBLE_DEVICES\"", ",", "\"\"", ")", "\n", "if", "len", "(", "gpu_ids", ")", "==", "1", ":", "\n", "                ", "gpu_ids", "=", "f\"{gpu_ids},\"", "\n", "", "num_processes", "=", "max", "(", "1", ",", "len", "(", "gpu_ids", ".", "split", "(", "\",\"", ")", ")", ")", "\n", "return", "int", "(", "os", ".", "environ", "[", "\"NODE_RANK\"", "]", ")", "*", "num_processes", "+", "get_local_rank", "(", ")", "\n", "", "return", "0", "\n", "", "return", "dist", ".", "get_rank", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_local_rank": [[52, 65], ["torch.get_rank", "torch.is_available", "meddlr.utils.env.is_pt_lightning", "int", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_pt_lightning"], ["", "def", "get_local_rank", "(", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The rank of the current process within the local (per-machine) process group.\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "if", "env", ".", "is_pt_lightning", "(", ")", "and", "\"LOCAL_RANK\"", "in", "os", ".", "environ", ":", "\n", "        ", "return", "int", "(", "os", ".", "environ", "[", "\"LOCAL_RANK\"", "]", ")", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "assert", "_LOCAL_PROCESS_GROUP", "is", "not", "None", "\n", "return", "dist", ".", "get_rank", "(", "group", "=", "_LOCAL_PROCESS_GROUP", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_local_size": [[67, 78], ["torch.get_world_size", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size"], ["", "def", "get_local_size", "(", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The size of the per-machine process group,\n        i.e. the number of processes per machine.\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "return", "dist", ".", "get_world_size", "(", "group", "=", "_LOCAL_PROCESS_GROUP", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.is_main_process": [[80, 82], ["comm.get_rank"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank"], ["", "def", "is_main_process", "(", ")", "->", "bool", ":", "\n", "    ", "return", "get_rank", "(", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.synchronize": [[84, 97], ["torch.get_world_size", "torch.barrier", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size"], ["", "def", "synchronize", "(", ")", ":", "\n", "    ", "\"\"\"\n    Helper function to synchronize (barrier) among all processes when\n    using distributed training\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "\n", "", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "\n", "if", "world_size", "==", "1", ":", "\n", "        ", "return", "\n", "", "dist", ".", "barrier", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.use_synchronize": [[99, 102], ["torch.is_available", "torch.is_initialized", "torch.get_world_size"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size"], ["", "def", "use_synchronize", "(", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Returns ``True`` if synchronization is needed.\"\"\"", "\n", "return", "dist", ".", "is_available", "(", ")", "and", "dist", ".", "is_initialized", "(", ")", "and", "dist", ".", "get_world_size", "(", ")", ">", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._get_global_gloo_group": [[104, 114], ["functools.lru_cache", "torch.get_backend", "torch.new_group"], "function", ["None"], ["", "@", "functools", ".", "lru_cache", "(", ")", "\n", "def", "_get_global_gloo_group", "(", ")", ":", "\n", "    ", "\"\"\"\n    Return a process group based on gloo backend, containing all the ranks\n    The result is cached.\n    \"\"\"", "\n", "if", "dist", ".", "get_backend", "(", ")", "==", "\"nccl\"", ":", "\n", "        ", "return", "dist", ".", "new_group", "(", "backend", "=", "\"gloo\"", ")", "\n", "", "else", ":", "\n", "        ", "return", "dist", ".", "group", ".", "WORLD", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._serialize_to_tensor": [[116, 132], ["torch.get_backend", "torch.device", "torch.device", "pickle.dumps", "torch.ByteStorage.from_buffer", "torch.ByteStorage.from_buffer", "torch.ByteTensor().to", "torch.ByteTensor().to", "len", "logging.getLogger", "logging.getLogger.warning", "torch.ByteTensor", "torch.ByteTensor", "comm.get_rank", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank"], ["", "", "def", "_serialize_to_tensor", "(", "data", ",", "group", ")", ":", "\n", "    ", "backend", "=", "dist", ".", "get_backend", "(", "group", ")", "\n", "assert", "backend", "in", "[", "\"gloo\"", ",", "\"nccl\"", "]", "\n", "device", "=", "torch", ".", "device", "(", "\"cpu\"", "if", "backend", "==", "\"gloo\"", "else", "\"cuda\"", ")", "\n", "\n", "buffer", "=", "pickle", ".", "dumps", "(", "data", ")", "\n", "if", "len", "(", "buffer", ")", ">", "1024", "**", "3", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"Rank {} trying to all-gather {:.2f} GB of data on device {}\"", ".", "format", "(", "\n", "get_rank", "(", ")", ",", "len", "(", "buffer", ")", "/", "(", "1024", "**", "3", ")", ",", "device", "\n", ")", "\n", ")", "\n", "", "storage", "=", "torch", ".", "ByteStorage", ".", "from_buffer", "(", "buffer", ")", "\n", "tensor", "=", "torch", ".", "ByteTensor", "(", "storage", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._pad_to_largest_tensor": [[134, 159], ["torch.get_world_size", "torch.tensor", "torch.tensor", "torch.all_gather", "max", "torch.zeros", "torch.zeros", "int", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat.numel", "range", "size.item"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.all_gather"], ["", "def", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        list[int]: size of the tensor, on each rank\n        Tensor: padded tensor that has the max size\n    \"\"\"", "\n", "world_size", "=", "dist", ".", "get_world_size", "(", "group", "=", "group", ")", "\n", "assert", "(", "\n", "world_size", ">=", "1", "\n", ")", ",", "\"comm.gather/all_gather must be called from ranks within the given group!\"", "\n", "local_size", "=", "torch", ".", "tensor", "(", "[", "tensor", ".", "numel", "(", ")", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "tensor", ".", "device", ")", "\n", "size_list", "=", "[", "\n", "torch", ".", "zeros", "(", "[", "1", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "range", "(", "world_size", ")", "\n", "]", "\n", "dist", ".", "all_gather", "(", "size_list", ",", "local_size", ",", "group", "=", "group", ")", "\n", "size_list", "=", "[", "int", "(", "size", ".", "item", "(", ")", ")", "for", "size", "in", "size_list", "]", "\n", "\n", "max_size", "=", "max", "(", "size_list", ")", "\n", "\n", "# we pad the tensor because torch all_gather does not support", "\n", "# gathering tensors of different shapes", "\n", "if", "local_size", "!=", "max_size", ":", "\n", "        ", "padding", "=", "torch", ".", "zeros", "(", "(", "max_size", "-", "local_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "\n", "tensor", "=", "torch", ".", "cat", "(", "(", "tensor", ",", "padding", ")", ",", "dim", "=", "0", ")", "\n", "", "return", "size_list", ",", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.all_gather": [[161, 195], ["comm._serialize_to_tensor", "comm._pad_to_largest_tensor", "max", "torch.all_gather", "zip", "comm.get_world_size", "comm._get_global_gloo_group", "torch.get_world_size", "torch.empty", "torch.empty", "data_list.append", "_serialize_to_tensor.cpu().numpy().tobytes", "pickle.loads", "_serialize_to_tensor.cpu().numpy", "_serialize_to_tensor.cpu"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._serialize_to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._pad_to_largest_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.all_gather", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._get_global_gloo_group", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "def", "all_gather", "(", "data", ",", "group", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Run all_gather on arbitrary picklable data (not necessarily tensors).\n    Args:\n        data: any picklable object\n        group: a torch process group. By default, will use a group which\n            contains all ranks on gloo backend.\n    Returns:\n        list[data]: list of data gathered from each rank\n    \"\"\"", "\n", "if", "get_world_size", "(", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "if", "group", "is", "None", ":", "\n", "        ", "group", "=", "_get_global_gloo_group", "(", ")", "\n", "", "if", "dist", ".", "get_world_size", "(", "group", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "\n", "", "tensor", "=", "_serialize_to_tensor", "(", "data", ",", "group", ")", "\n", "\n", "size_list", ",", "tensor", "=", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", "\n", "max_size", "=", "max", "(", "size_list", ")", "\n", "\n", "# receiving Tensor from all ranks", "\n", "tensor_list", "=", "[", "\n", "torch", ".", "empty", "(", "(", "max_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "size_list", "\n", "]", "\n", "dist", ".", "all_gather", "(", "tensor_list", ",", "tensor", ",", "group", "=", "group", ")", "\n", "\n", "data_list", "=", "[", "]", "\n", "for", "size", ",", "tensor", "in", "zip", "(", "size_list", ",", "tensor_list", ")", ":", "\n", "        ", "buffer", "=", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", "[", ":", "size", "]", "\n", "data_list", ".", "append", "(", "pickle", ".", "loads", "(", "buffer", ")", ")", "\n", "\n", "", "return", "data_list", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.gather": [[197, 236], ["torch.get_rank", "comm._serialize_to_tensor", "comm._pad_to_largest_tensor", "comm.get_world_size", "comm._get_global_gloo_group", "torch.get_world_size", "max", "torch.gather", "zip", "torch.gather", "torch.empty", "torch.empty", "data_list.append", "_serialize_to_tensor.cpu().numpy().tobytes", "pickle.loads", "_serialize_to_tensor.cpu().numpy", "_serialize_to_tensor.cpu"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._serialize_to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._pad_to_largest_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm._get_global_gloo_group", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.gather", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.gather", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "def", "gather", "(", "data", ",", "dst", "=", "0", ",", "group", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Run gather on arbitrary picklable data (not necessarily tensors).\n    Args:\n        data: any picklable object\n        dst (int): destination rank\n        group: a torch process group. By default, will use a group which\n            contains all ranks on gloo backend.\n    Returns:\n        list[data]: on dst, a list of data gathered from each rank. Otherwise,\n            an empty list.\n    \"\"\"", "\n", "if", "get_world_size", "(", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "if", "group", "is", "None", ":", "\n", "        ", "group", "=", "_get_global_gloo_group", "(", ")", "\n", "", "if", "dist", ".", "get_world_size", "(", "group", "=", "group", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "rank", "=", "dist", ".", "get_rank", "(", "group", "=", "group", ")", "\n", "\n", "tensor", "=", "_serialize_to_tensor", "(", "data", ",", "group", ")", "\n", "size_list", ",", "tensor", "=", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", "\n", "\n", "# receiving Tensor from all ranks", "\n", "if", "rank", "==", "dst", ":", "\n", "        ", "max_size", "=", "max", "(", "size_list", ")", "\n", "tensor_list", "=", "[", "\n", "torch", ".", "empty", "(", "(", "max_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "size_list", "\n", "]", "\n", "dist", ".", "gather", "(", "tensor", ",", "tensor_list", ",", "dst", "=", "dst", ",", "group", "=", "group", ")", "\n", "\n", "data_list", "=", "[", "]", "\n", "for", "size", ",", "tensor", "in", "zip", "(", "size_list", ",", "tensor_list", ")", ":", "\n", "            ", "buffer", "=", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", "[", ":", "size", "]", "\n", "data_list", ".", "append", "(", "pickle", ".", "loads", "(", "buffer", ")", ")", "\n", "", "return", "data_list", "\n", "", "else", ":", "\n", "        ", "dist", ".", "gather", "(", "tensor", ",", "[", "]", ",", "dst", "=", "dst", ",", "group", "=", "group", ")", "\n", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.shared_random_seed": [[238, 249], ["numpy.random.randint", "comm.all_gather"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.all_gather"], ["", "", "def", "shared_random_seed", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        int: a random number that is the same across all workers.\n            If workers need a shared RNG, they can use this shared seed to\n            create one.\n    All workers must call this function, otherwise it will deadlock.\n    \"\"\"", "\n", "ints", "=", "np", ".", "random", ".", "randint", "(", "2", "**", "31", ")", "\n", "all_ints", "=", "all_gather", "(", "ints", ")", "\n", "return", "all_ints", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.reduce_dict": [[251, 279], ["comm.get_world_size", "torch.no_grad", "torch.no_grad", "sorted", "torch.stack", "torch.stack", "torch.reduce", "input_dict.keys", "names.append", "torch.stack.append", "torch.get_rank", "zip"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank"], ["", "def", "reduce_dict", "(", "input_dict", ",", "average", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Reduce the values in the dictionary from all processes so that process with rank\n    0 has the reduced results.\n    Args:\n        input_dict (dict): inputs to be reduced. All the values must be scalar CUDA Tensor.\n        average (bool): whether to do average or sum\n    Returns:\n        a dict with the same keys as input_dict, after reduction.\n    \"\"\"", "\n", "world_size", "=", "get_world_size", "(", ")", "\n", "if", "world_size", "<", "2", ":", "\n", "        ", "return", "input_dict", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "names", "=", "[", "]", "\n", "values", "=", "[", "]", "\n", "# sort the keys so that they are consistent across processes", "\n", "for", "k", "in", "sorted", "(", "input_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "names", ".", "append", "(", "k", ")", "\n", "values", ".", "append", "(", "input_dict", "[", "k", "]", ")", "\n", "", "values", "=", "torch", ".", "stack", "(", "values", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "values", ",", "dst", "=", "0", ")", "\n", "if", "dist", ".", "get_rank", "(", ")", "==", "0", "and", "average", ":", "\n", "# only main process gets accumulated, so only divide by", "\n", "# world_size in this case", "\n", "            ", "values", "/=", "world_size", "\n", "", "reduced_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "names", ",", "values", ")", "}", "\n", "", "return", "reduced_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.rank_zero_only": [[281, 288], ["functools.wraps", "fn"], "function", ["None"], ["", "def", "rank_zero_only", "(", "fn", ")", ":", "\n", "    ", "@", "functools", ".", "wraps", "(", "fn", ")", "\n", "def", "wrapped_fn", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "rank_zero_only", ".", "rank", "==", "0", ":", "\n", "            ", "return", "fn", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapped_fn", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.__init__": [[51, 59], ["collections.defaultdict"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "delimiter", "=", "\".\"", ",", "unroll", "=", "False", ",", "data", "=", "None", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "delimiter", "=", "delimiter", "\n", "self", ".", "unroll", "=", "unroll", "\n", "self", ".", "timer_started", "=", "defaultdict", "(", "bool", ")", "\n", "if", "data", "is", "None", ":", "\n", "            ", "data", "=", "{", "}", "\n", "", "self", ".", "data", "=", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.start": [[60, 63], ["time.perf_counter"], "methods", ["None"], ["", "def", "start", "(", "self", ",", "key", ")", ":", "\n", "        ", "self", ".", "data", "[", "key", "]", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "timer_started", "[", "key", "]", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.time": [[64, 70], ["ValueError", "time.perf_counter"], "methods", ["None"], ["", "def", "time", "(", "self", ",", "key", ")", ":", "\n", "        ", "if", "not", "self", ".", "timer_started", "[", "key", "]", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Must start timer for key '{key}' before calling `time`.\"", ")", "\n", "", "self", ".", "data", "[", "key", "]", "=", "time", ".", "perf_counter", "(", ")", "-", "self", ".", "data", "[", "key", "]", "\n", "self", ".", "timer_started", "[", "key", "]", "=", "False", "\n", "return", "self", ".", "data", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.stop": [[71, 73], ["profiler.AdvancedTimer.time"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.time"], ["", "def", "stop", "(", "self", ",", "key", ")", ":", "\n", "        ", "return", "self", ".", "time", "(", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.update": [[74, 77], ["profiler.AdvancedTimer.data.update", "profiler.AdvancedTimer.timer_started.update"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "def", "update", "(", "self", ",", "data", ":", "Mapping", ")", ":", "\n", "        ", "self", ".", "data", ".", "update", "(", "data", ")", "\n", "self", ".", "timer_started", ".", "update", "(", "{", "k", ":", "False", "for", "k", "in", "data", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.summarize": [[78, 80], ["profiler.AdvancedTimer.data.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "summarize", "(", "self", ")", "->", "Dict", ":", "\n", "        ", "return", "{", "f\"{self.name}{self.delimiter}{k}\"", ":", "v", "for", "k", ",", "v", "in", "self", ".", "data", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.__enter__": [[81, 84], ["_CURRENT_TIMER_STACK.append"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "_CURRENT_TIMER_STACK", ".", "append", "(", "self", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.__exit__": [[85, 90], ["_CURRENT_TIMER_STACK.pop", "_CURRENT_TIMER_STACK[].update", "len", "profiler.AdvancedTimer.summarize"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.summarize"], ["", "def", "__exit__", "(", "self", ",", "exc_type", ",", "exc_val", ",", "exc_tb", ")", ":", "\n", "        ", "assert", "_CURRENT_TIMER_STACK", "[", "-", "1", "]", "==", "self", "\n", "if", "self", ".", "unroll", "and", "len", "(", "_CURRENT_TIMER_STACK", ")", ">", "1", ":", "\n", "            ", "_CURRENT_TIMER_STACK", "[", "-", "2", "]", ".", "update", "(", "self", ".", "summarize", "(", ")", ")", "\n", "", "_CURRENT_TIMER_STACK", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.__repr__": [[91, 93], ["type"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "f\"{type(self).__name__}({self.name})\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.get_timer": [[10, 20], ["len"], "function", ["None"], ["def", "get_timer", "(", ")", "->", "\"AdvancedTimer\"", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The :class:`EventStorage` object that's currently being used.\n        Throws an error if no :class`EventStorage` is currently enabled.\n    \"\"\"", "\n", "assert", "len", "(", "_CURRENT_TIMER_STACK", ")", ",", "(", "\n", "\"get_event_storage() has to be called inside a \"", "\"'with EventStorage(...)' context!\"", "\n", ")", "\n", "return", "_CURRENT_TIMER_STACK", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.time_profile": [[22, 48], ["meddlr.utils.env.is_profiling_enabled", "func", "profiler.AdvancedTimer", "func", "timer.summarize", "isinstance", "out[].update", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_profiling_enabled", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.summarize", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "def", "time_profile", "(", "prefix", "=", "None", ",", "delimiter", "=", "\".\"", ",", "disable", "=", "None", ",", "top_lvl_only", "=", "True", ")", ":", "\n", "    ", "if", "disable", "is", "None", ":", "\n", "        ", "disable", "=", "not", "env", ".", "is_profiling_enabled", "(", ")", "\n", "\n", "", "def", "_decorator", "(", "func", ")", ":", "\n", "        ", "name", "=", "func", ".", "__qualname__", "\n", "if", "prefix", "is", "not", "None", ":", "\n", "            ", "name", "=", "f\"{prefix}{delimiter}{name}\"", "\n", "\n", "", "def", "_wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "if", "disable", ":", "\n", "                ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "with", "AdvancedTimer", "(", "name", ",", "unroll", "=", "True", ")", "as", "timer", ":", "\n", "                ", "out", "=", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "time_args", "=", "timer", ".", "summarize", "(", ")", "\n", "\n", "", "if", "(", "top_lvl_only", "and", "len", "(", "_CURRENT_TIMER_STACK", ")", "==", "0", ")", "and", "isinstance", "(", "out", ",", "Dict", ")", ":", "\n", "                ", "if", "\"_profiler\"", "not", "in", "out", ":", "\n", "                    ", "out", "[", "\"_profiler\"", "]", "=", "{", "}", "\n", "", "out", "[", "\"_profiler\"", "]", ".", "update", "(", "time_args", ")", "\n", "", "return", "out", "\n", "\n", "", "return", "_wrapper", "\n", "\n", "", "return", "_decorator", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._ColorfulFormatter.__init__": [[22, 28], ["kwargs.pop", "len", "logging.Formatter.__init__", "kwargs.pop"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "_root_name", "=", "kwargs", ".", "pop", "(", "\"root_name\"", ")", "+", "\".\"", "\n", "self", ".", "_abbrev_name", "=", "kwargs", ".", "pop", "(", "\"abbrev_name\"", ",", "\"\"", ")", "\n", "if", "len", "(", "self", ".", "_abbrev_name", ")", ":", "\n", "            ", "self", ".", "_abbrev_name", "=", "self", ".", "_abbrev_name", "+", "\".\"", "\n", "", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._ColorfulFormatter.formatMessage": [[29, 39], ["record.name.replace", "super().formatMessage", "termcolor.colored", "termcolor.colored"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._ColorfulFormatter.formatMessage"], ["", "def", "formatMessage", "(", "self", ",", "record", ")", ":", "\n", "        ", "record", ".", "name", "=", "record", ".", "name", ".", "replace", "(", "self", ".", "_root_name", ",", "self", ".", "_abbrev_name", ")", "\n", "log", "=", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "formatMessage", "(", "record", ")", "\n", "if", "record", ".", "levelno", "==", "logging", ".", "WARNING", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"WARNING\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", "]", ")", "\n", "", "elif", "record", ".", "levelno", "==", "logging", ".", "ERROR", "or", "record", ".", "levelno", "==", "logging", ".", "CRITICAL", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"ERROR\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", ",", "\"underline\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "log", "\n", "", "return", "prefix", "+", "\" \"", "+", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.setup_logger": [[42, 106], ["functools.lru_cache", "logging.getLogger", "logging.getLogger.setLevel", "logging.Formatter", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "_PATH_MANAGER.mkdirs", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logger._ColorfulFormatter", "output.endswith", "output.endswith", "os.path.join", "os.path.dirname", "logger._cached_log_stream", "termcolor.colored", "str"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._cached_log_stream"], ["", "", "@", "functools", ".", "lru_cache", "(", ")", "\n", "def", "setup_logger", "(", "output", "=", "None", ",", "distributed_rank", "=", "0", ",", "*", ",", "color", "=", "True", ",", "name", "=", "\"meddlr\"", ",", "abbrev_name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Initialize loggers for different modules.\n\n    By default, the logger of the module will be set to logging.DEBUG level.\n\n    Args:\n        output (str): a file name or a directory to save log. If None, will not\n            save log file.\n            If ends with \".txt\" or \".log\", assumed to be a file name.\n            Otherwise, logs will be saved to `output/log.txt`.\n        name (str): the root module name of this logger\n        abbrev_name (str): an abbreviation of the module, to avoid long names\n            in logs.\n            Set to \"\" to not log the root module in logs.\n            By default, will abbreviate \"meddlr\" to \"mr\" and leave other\n            modules unchanged.\n\n    Returns:\n        logging.Logger: a logger\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "\n", "if", "abbrev_name", "is", "None", ":", "\n", "        ", "abbrev_name", "=", "\"mr\"", "if", "name", "==", "\"meddlr\"", "else", "name", "\n", "\n", "", "plain_formatter", "=", "logging", ".", "Formatter", "(", "\n", "\"[%(asctime)s] %(name)s %(levelname)s: %(message)s\"", ",", "datefmt", "=", "\"%m/%d %H:%M:%S\"", "\n", ")", "\n", "# stdout logging: master only", "\n", "if", "distributed_rank", "==", "0", ":", "\n", "        ", "ch", "=", "logging", ".", "StreamHandler", "(", "stream", "=", "sys", ".", "stdout", ")", "\n", "ch", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "if", "color", ":", "\n", "            ", "formatter", "=", "_ColorfulFormatter", "(", "\n", "colored", "(", "\"[%(asctime)s %(name)s]: \"", ",", "\"green\"", ")", "+", "\"%(message)s\"", ",", "\n", "datefmt", "=", "\"%m/%d %H:%M:%S\"", ",", "\n", "root_name", "=", "name", ",", "\n", "abbrev_name", "=", "str", "(", "abbrev_name", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "formatter", "=", "plain_formatter", "\n", "", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "ch", ")", "\n", "\n", "# file logging: all workers", "\n", "", "if", "output", "is", "not", "None", ":", "\n", "        ", "if", "output", ".", "endswith", "(", "\".txt\"", ")", "or", "output", ".", "endswith", "(", "\".log\"", ")", ":", "\n", "            ", "filename", "=", "output", "\n", "", "else", ":", "\n", "            ", "filename", "=", "os", ".", "path", ".", "join", "(", "output", ",", "\"log.txt\"", ")", "\n", "", "if", "distributed_rank", ">", "0", ":", "\n", "            ", "filename", "=", "filename", "+", "\".rank{}\"", ".", "format", "(", "distributed_rank", ")", "\n", "", "_PATH_MANAGER", ".", "mkdirs", "(", "os", ".", "path", ".", "dirname", "(", "filename", ")", ")", "\n", "\n", "fh", "=", "logging", ".", "StreamHandler", "(", "_cached_log_stream", "(", "filename", ")", ")", "\n", "fh", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "fh", ".", "setFormatter", "(", "plain_formatter", ")", "\n", "logger", ".", "addHandler", "(", "fh", ")", "\n", "\n", "", "return", "logger", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._cached_log_stream": [[110, 113], ["functools.lru_cache", "_PATH_MANAGER.open"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["", "@", "functools", ".", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "_cached_log_stream", "(", "filename", ")", ":", "\n", "    ", "return", "_PATH_MANAGER", ".", "open", "(", "filename", ",", "\"a\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._find_caller": [[122, 137], ["sys._getframe", "os.path.join"], "function", ["None"], ["def", "_find_caller", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        str: module name of the caller\n        tuple: a hashable key to be used to identify different callers\n    \"\"\"", "\n", "frame", "=", "sys", ".", "_getframe", "(", "2", ")", "\n", "while", "frame", ":", "\n", "        ", "code", "=", "frame", ".", "f_code", "\n", "if", "os", ".", "path", ".", "join", "(", "\"utils\"", ",", "\"logger.\"", ")", "not", "in", "code", ".", "co_filename", ":", "\n", "            ", "mod_name", "=", "frame", ".", "f_globals", "[", "\"__name__\"", "]", "\n", "if", "mod_name", "==", "\"__main__\"", ":", "\n", "                ", "mod_name", "=", "\"meddlr\"", "\n", "", "return", "mod_name", ",", "(", "code", ".", "co_filename", ",", "frame", ".", "f_lineno", ",", "code", ".", "co_name", ")", "\n", "", "frame", "=", "frame", ".", "f_back", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.log_first_n": [[143, 179], ["isinstance", "logger._find_caller", "len", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._find_caller"], ["def", "log_first_n", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ",", "key", "=", "\"caller\"", ")", ":", "\n", "    ", "\"\"\"\n    Log only for the first n times.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by\n            default.\n        key (str or tuple[str]): the string(s) can be one of \"caller\" or\n            \"message\", which defines how to identify duplicated logs.\n            For example, if called with `n=1, key=\"caller\"`, this function\n            will only log the first call from the same caller, regardless of\n            the message content.\n            If called with `n=1, key=\"message\"`, this function will log the\n            same content only once, even if they are called from different\n            places.\n            If called with `n=1, key=(\"caller\", \"message\")`, this function\n            will not log only if the same caller has logged the same message\n            before.\n    \"\"\"", "\n", "if", "isinstance", "(", "key", ",", "str", ")", ":", "\n", "        ", "key", "=", "(", "key", ",", ")", "\n", "", "assert", "len", "(", "key", ")", ">", "0", "\n", "\n", "caller_module", ",", "caller_key", "=", "_find_caller", "(", ")", "\n", "hash_key", "=", "(", ")", "\n", "if", "\"caller\"", "in", "key", ":", "\n", "        ", "hash_key", "=", "hash_key", "+", "caller_key", "\n", "", "if", "\"message\"", "in", "key", ":", "\n", "        ", "hash_key", "=", "hash_key", "+", "(", "msg", ",", ")", "\n", "\n", "", "_LOG_COUNTER", "[", "hash_key", "]", "+=", "1", "\n", "if", "_LOG_COUNTER", "[", "hash_key", "]", "<=", "n", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.log_every_n": [[181, 196], ["logger._find_caller", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._find_caller"], ["", "", "def", "log_every_n", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Log once per n times.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by\n            default.\n    \"\"\"", "\n", "caller_module", ",", "key", "=", "_find_caller", "(", ")", "\n", "_LOG_COUNTER", "[", "key", "]", "+=", "1", "\n", "if", "n", "==", "1", "or", "_LOG_COUNTER", "[", "key", "]", "%", "n", "==", "1", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.log_every_n_seconds": [[198, 215], ["logger._find_caller", "_LOG_TIMER.get", "time.time", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.logger._find_caller", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.time"], ["", "", "def", "log_every_n_seconds", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Log no more than once per n seconds.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by\n            default.\n    \"\"\"", "\n", "caller_module", ",", "key", "=", "_find_caller", "(", ")", "\n", "last_logged", "=", "_LOG_TIMER", ".", "get", "(", "key", ",", "None", ")", "\n", "current_time", "=", "time", ".", "time", "(", ")", "\n", "if", "last_logged", "is", "None", "or", "current_time", "-", "last_logged", ">=", "n", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "_LOG_TIMER", "[", "key", "]", "=", "current_time", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.create_small_table": [[217, 238], ["tuple", "tabulate.tabulate", "zip", "small_dict.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "def", "create_small_table", "(", "small_dict", ")", ":", "\n", "    ", "\"\"\"\n    Create a small table using the keys of small_dict as headers. This is only\n    suitable for small dictionaries.\n\n    Args:\n        small_dict (dict): a result dictionary of only a few items.\n\n    Returns:\n        str: the table as a string.\n    \"\"\"", "\n", "keys", ",", "values", "=", "tuple", "(", "zip", "(", "*", "small_dict", ".", "items", "(", ")", ")", ")", "\n", "table", "=", "tabulate", "(", "\n", "[", "values", "]", ",", "\n", "headers", "=", "keys", ",", "\n", "tablefmt", "=", "\"pipe\"", ",", "\n", "floatfmt", "=", "\".3f\"", ",", "\n", "stralign", "=", "\"center\"", ",", "\n", "numalign", "=", "\"center\"", ",", "\n", ")", "\n", "return", "table", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry.__init__": [[13, 16], ["fvcore.common.registry.Registry.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "_metadata_map", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._get_aliases": [[17, 22], ["hasattr", "getattr"], "methods", ["None"], ["", "def", "_get_aliases", "(", "self", ",", "obj_func_or_class", ")", ":", "\n", "        ", "for", "kw", "in", "self", ".", "_ALIAS_KEYWORDS", ":", "\n", "            ", "if", "hasattr", "(", "obj_func_or_class", ",", "kw", ")", ":", "\n", "                ", "return", "getattr", "(", "obj_func_or_class", ",", "kw", ")", "\n", "", "", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry.register": [[23, 49], ["registry.Registry._do_register", "any", "registry.Registry._do_register", "registry.Registry._do_register", "functools.partial", "isinstance", "registry.Registry._get_aliases", "registry.Registry._get_aliases", "isinstance", "registry.Registry._do_register", "kwargs.values"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._do_register", "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._do_register", "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._do_register", "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._get_aliases", "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._get_aliases", "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._do_register", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "register", "(", "self", ",", "obj", ":", "object", "=", "None", ",", "aliases", ":", "Sequence", "[", "str", "]", "=", "None", ")", "->", "Optional", "[", "object", "]", ":", "\n", "        ", "if", "obj", "is", "None", ":", "\n", "# used as a decorator", "\n", "            ", "def", "deco", "(", "func_or_class", ":", "object", ",", "aliases", "=", "None", ")", "->", "object", ":", "\n", "                ", "name", "=", "func_or_class", ".", "__name__", "\n", "self", ".", "_do_register", "(", "name", ",", "func_or_class", ")", "\n", "if", "aliases", "is", "None", ":", "\n", "                    ", "aliases", "=", "self", ".", "_get_aliases", "(", "func_or_class", ")", "\n", "", "if", "not", "isinstance", "(", "aliases", ",", "(", "list", ",", "tuple", ",", "set", ")", ")", ":", "\n", "                    ", "aliases", "=", "[", "aliases", "]", "\n", "", "for", "alias", "in", "aliases", ":", "\n", "                    ", "self", ".", "_do_register", "(", "alias", ",", "func_or_class", ",", "is_alias", "=", "True", ")", "\n", "", "return", "func_or_class", "\n", "\n", "", "kwargs", "=", "{", "\"aliases\"", ":", "aliases", "}", "\n", "if", "any", "(", "v", "is", "not", "None", "for", "v", "in", "kwargs", ".", "values", "(", ")", ")", ":", "\n", "                ", "return", "functools", ".", "partial", "(", "deco", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "                ", "return", "deco", "\n", "\n", "", "", "name", "=", "obj", ".", "__name__", "\n", "self", ".", "_do_register", "(", "name", ",", "obj", ")", "\n", "if", "aliases", "is", "None", ":", "\n", "            ", "aliases", "=", "self", ".", "_get_aliases", "(", "obj", ")", "if", "isinstance", "(", "obj", ",", "type", ")", "else", "[", "]", "\n", "", "for", "alias", "in", "aliases", ":", "\n", "            ", "self", ".", "_do_register", "(", "alias", ",", "obj", ",", "is_alias", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._do_register": [[50, 66], ["super()._do_register", "isinstance", "registry.Registry._get_aliases", "kwargs.pop", "docstring.split"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._do_register", "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry._get_aliases"], ["", "", "def", "_do_register", "(", "self", ",", "name", ":", "str", ",", "obj", ":", "object", ",", "**", "kwargs", ")", "->", "None", ":", "\n", "        ", "docstring", "=", "obj", ".", "__doc__", "\n", "if", "docstring", "is", "None", ":", "\n", "            ", "docstring", "=", "\"\"", "\n", "\n", "", "aliases", "=", "self", ".", "_get_aliases", "(", "obj", ")", "if", "isinstance", "(", "obj", ",", "type", ")", "else", "None", "\n", "if", "not", "aliases", ":", "\n", "            ", "aliases", "=", "None", "\n", "\n", "", "self", ".", "_metadata_map", "[", "name", "]", "=", "{", "\n", "\"name\"", ":", "name", ",", "\n", "\"description\"", ":", "kwargs", ".", "pop", "(", "\"description\"", ",", "docstring", ".", "split", "(", "\"\\n\"", ")", "[", "0", "]", ")", ",", "\n", "\"aliases\"", ":", "aliases", ",", "\n", "**", "kwargs", ",", "\n", "}", "\n", "return", "super", "(", ")", ".", "_do_register", "(", "name", ",", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry.clear": [[67, 70], ["None"], "methods", ["None"], ["", "def", "clear", "(", "self", ")", ":", "\n", "        ", "self", ".", "_obj_map", "=", "{", "}", "\n", "self", ".", "_metadata_map", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.registry.Registry.__repr__": [[71, 75], ["tabulate.tabulate.tabulate", "registry.Registry._metadata_map.values", "v.get"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "metadata", "=", "[", "v", "for", "v", "in", "self", ".", "_metadata_map", ".", "values", "(", ")", "if", "not", "v", ".", "get", "(", "\"is_alias\"", ",", "False", ")", "]", "\n", "table", "=", "tabulate", "(", "metadata", ",", "headers", "=", "\"keys\"", ",", "tablefmt", "=", "\"fancy_grid\"", ")", "\n", "return", "\"Registry of {}:\\n{}\"", ".", "format", "(", "self", ".", "_name", ",", "table", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GeneralPathHandler._get_supported_prefixes": [[45, 47], ["None"], "methods", ["None"], ["def", "_get_supported_prefixes", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "PREFIX", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GeneralPathHandler._get_local_path": [[48, 51], ["os.path.join", "path.GeneralPathHandler._root_dir", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.DownloadHandler._root_dir"], ["", "def", "_get_local_path", "(", "self", ",", "path", ":", "str", ",", "**", "kwargs", ")", ":", "\n", "        ", "name", "=", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", "\n", "return", "os", ".", "path", ".", "join", "(", "self", ".", "_root_dir", "(", ")", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GeneralPathHandler._open": [[52, 54], ["meddlr.utils.env.get_path_manager().open", "path.GeneralPathHandler._get_local_path", "meddlr.utils.env.get_path_manager"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager"], ["", "def", "_open", "(", "self", ",", "path", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "env", ".", "get_path_manager", "(", ")", ".", "open", "(", "self", ".", "_get_local_path", "(", "path", ")", ",", "mode", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GeneralPathHandler._mkdirs": [[55, 57], ["os.makedirs", "path.GeneralPathHandler._get_local_path"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path"], ["", "def", "_mkdirs", "(", "self", ",", "path", ":", "str", ",", "**", "kwargs", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "self", ".", "_get_local_path", "(", "path", ")", ",", "exist_ok", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GeneralPathHandler._root_dir": [[58, 61], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_root_dir", "(", "self", ")", "->", "str", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.DataHandler._root_dir": [[66, 68], ["meddlr.utils.cluster.Cluster.working_cluster().get_path", "meddlr.utils.cluster.Cluster.working_cluster"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.get_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.working_cluster"], ["def", "_root_dir", "(", "self", ")", ":", "\n", "        ", "return", "Cluster", ".", "working_cluster", "(", ")", ".", "get_path", "(", "\"data_dir\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ResultsHandler._root_dir": [[73, 75], ["meddlr.utils.cluster.Cluster.working_cluster().get_path", "meddlr.utils.cluster.Cluster.working_cluster"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.get_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.working_cluster"], ["def", "_root_dir", "(", "self", ")", ":", "\n", "        ", "return", "Cluster", ".", "working_cluster", "(", ")", ".", "get_path", "(", "\"results_dir\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.CacheHandler._root_dir": [[80, 82], ["meddlr.utils.cluster.Cluster.working_cluster().get_path", "meddlr.utils.cluster.Cluster.working_cluster"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.get_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.working_cluster"], ["def", "_root_dir", "(", "self", ")", ":", "\n", "        ", "return", "Cluster", ".", "working_cluster", "(", ")", ".", "get_path", "(", "\"cache_dir\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GithubHandler.__init__": [[104, 117], ["iopath.common.file_io.PathHandler.__init__", "meddlr.utils.env.get_github_url"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_github_url"], ["def", "__init__", "(", "\n", "self", ",", "\n", "github_url", ":", "str", "=", "None", ",", "\n", "default_branch_or_tag", ":", "str", "=", "\"main\"", ",", "\n", "default_cache_path", ":", "str", "=", "None", ",", "\n", "async_executor", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "if", "github_url", "is", "None", ":", "\n", "            ", "github_url", "=", "env", ".", "get_github_url", "(", ")", "\n", "", "self", ".", "github_url", "=", "github_url", "\n", "self", ".", "default_branch_or_tag", "=", "default_branch_or_tag", "\n", "self", ".", "default_cache_path", "=", "default_cache_path", "\n", "super", "(", ")", ".", "__init__", "(", "async_executor", "=", "async_executor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GithubHandler._root_dir": [[118, 120], ["None"], "methods", ["None"], ["", "def", "_root_dir", "(", "self", ")", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GithubHandler._get_default_branch_or_tag": [[121, 123], ["None"], "methods", ["None"], ["", "def", "_get_default_branch_or_tag", "(", "self", ")", ":", "\n", "        ", "return", "f\"v{mr.__version__}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GithubHandler._get_default_cache_path": [[124, 128], ["os.path.join", "meddlr.utils.env.get_path_manager().get_local_path", "meddlr.utils.env.get_path_manager", "meddlr.utils.cluster.Cluster.working_cluster"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.working_cluster"], ["", "def", "_get_default_cache_path", "(", "self", ")", ":", "\n", "        ", "return", "os", ".", "path", ".", "join", "(", "\n", "env", ".", "get_path_manager", "(", ")", ".", "get_local_path", "(", "Cluster", ".", "working_cluster", "(", ")", ".", "cache_dir", ")", ",", "\n", "f\"github-repo/v{mr.__version__}\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GithubHandler.download": [[130, 137], ["path.download_github_repository", "path.GithubHandler._get_default_branch_or_tag"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.download_github_repository", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GithubHandler._get_default_branch_or_tag"], ["", "def", "download", "(", "self", ",", "cache_dir", ",", "branch_or_tag", ":", "str", "=", "None", ",", "force", ":", "bool", "=", "False", ")", ":", "\n", "        ", "if", "branch_or_tag", "is", "None", ":", "\n", "            ", "branch_or_tag", "=", "self", ".", "default_branch_or_tag", "\n", "", "if", "branch_or_tag", "is", "None", ":", "\n", "            ", "branch_or_tag", "=", "self", ".", "_get_default_branch_or_tag", "(", ")", "\n", "", "return", "download_github_repository", "(", "\n", "url", "=", "self", ".", "github_url", ",", "branch_or_tag", "=", "branch_or_tag", ",", "cache_path", "=", "cache_dir", ",", "force", "=", "force", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GithubHandler._get_local_path": [[139, 188], ["path.GithubHandler._check_kwargs", "os.path.join", "logging.getLogger", "logging.getLogger.info", "path.GithubHandler.download", "logging.getLogger.info", "str", "os.path.exists", "FileNotFoundError", "len", "path.GithubHandler._get_default_cache_path", "os.path.exists", "os.listdir"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler.download", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GithubHandler._get_default_cache_path"], ["", "def", "_get_local_path", "(", "\n", "self", ",", "\n", "path", ":", "str", ",", "\n", "branch_or_tag", ":", "str", "=", "None", ",", "\n", "force", ":", "bool", "=", "False", ",", "\n", "cache_dir", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "str", ":", "\n", "        ", "\"\"\"Get local path to GitHub repository for the current meddlr version.\n\n        This implementation will only download the GitHub repository if it does\n        not exist. To force a download, set ``force=True``.\n\n        Args:\n            path (str): The relative file path in the GitHub repository.\n                Must start with ``'github://'``.\n            branch_or_tag (str): The Github branch or tag to download from.\n            force (bool, optional): If ``True``, force a download of the Github\n                repository. Defaults to ``False``.\n            cache_dir (str, optional): The local cache directory to use.\n\n        Returns:\n            str: The local path to the file/directory.\n        \"\"\"", "\n", "path", "=", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", "\n", "self", ".", "_check_kwargs", "(", "kwargs", ")", "\n", "if", "cache_dir", "is", "None", ":", "\n", "            ", "cache_dir", "=", "(", "\n", "self", ".", "default_cache_path", "\n", "if", "self", ".", "default_cache_path", "\n", "else", "self", ".", "_get_default_cache_path", "(", ")", "\n", ")", "\n", "\n", "", "if", "force", "or", "not", "os", ".", "path", ".", "exists", "(", "cache_dir", ")", "or", "not", "os", ".", "listdir", "(", "cache_dir", ")", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\n", "\"Downloading github repository (tag/branch {}) from {}...\"", ".", "format", "(", "\n", "mr", ".", "__version__", ",", "self", ".", "github_url", "\n", ")", "\n", ")", "\n", "self", ".", "download", "(", "cache_dir", ",", "force", "=", "force", ",", "branch_or_tag", "=", "branch_or_tag", ")", "\n", "logger", ".", "info", "(", "\"Repository cached to {}\"", ".", "format", "(", "cache_dir", ")", ")", "\n", "\n", "", "expected_path", "=", "os", ".", "path", ".", "join", "(", "str", "(", "cache_dir", ")", ",", "path", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "expected_path", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "\n", "\"Could not find {} in local Github cache: {}\"", ".", "format", "(", "path", ",", "cache_dir", ")", "\n", ")", "\n", "", "return", "expected_path", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler._get_cache_path": [[193, 195], ["None"], "methods", ["None"], ["def", "_get_cache_path", "(", "self", ")", ":", "\n", "        ", "return", "\"github://annotations\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler._root_dir": [[196, 205], ["os.path.abspath", "os.path.isdir", "meddlr.utils.env.get_path_manager().get_local_path", "os.path.join", "path.AnnotationsHandler._get_cache_path", "os.path.isdir", "path.AnnotationsHandler.download", "meddlr.utils.env.get_path_manager"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler._get_cache_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler.download", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager"], ["", "def", "_root_dir", "(", "self", ")", ":", "\n", "        ", "local_path", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "_REPO_DIR", ",", "\"annotations\"", ")", ")", "\n", "if", "os", ".", "path", ".", "isdir", "(", "local_path", ")", ":", "\n", "            ", "return", "local_path", "\n", "\n", "", "cache_path", "=", "env", ".", "get_path_manager", "(", ")", ".", "get_local_path", "(", "self", ".", "_get_cache_path", "(", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "cache_path", ")", ":", "\n", "            ", "self", ".", "download", "(", ")", "\n", "", "return", "cache_path", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler.download": [[206, 223], ["_LOGGER.info", "path.download_github_repository", "meddlr.utils.env.get_path_manager().get_local_path", "os.makedirs", "os.system", "path.AnnotationsHandler._get_cache_path", "RuntimeError", "meddlr.utils.env.get_path_manager"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.download_github_repository", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler._get_cache_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager"], ["", "def", "download", "(", "self", ")", ":", "\n", "        ", "\"\"\"Downloads annotations from meddlr github.\n\n        Note:\n            This method downloads the full repository of the current\n            meddlr version and then copies the annotation files to\n            the respective directory. This may not be very efficient,\n            but it ensures that the annotation download process is\n            less onerous on the user.\n        \"\"\"", "\n", "_LOGGER", ".", "info", "(", "\"Downloading annotations...\"", ")", "\n", "repo_path", "=", "download_github_repository", "(", ")", "\n", "cache_path", "=", "env", ".", "get_path_manager", "(", ")", ".", "get_local_path", "(", "self", ".", "_get_cache_path", "(", ")", ")", "\n", "os", ".", "makedirs", "(", "cache_path", ",", "exist_ok", "=", "True", ")", "\n", "retval", "=", "os", ".", "system", "(", "f\"cp -r {repo_path}/annotations {cache_path}/\"", ")", "\n", "if", "retval", "!=", "0", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Could not download annotations.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GoogleDriveHandler.__init__": [[243, 248], ["iopath.common.file_io.PathHandler.__init__", "os.path.expanduser"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "cache_dir", "=", "None", ",", "**", "kwargs", ")", "->", "None", ":", "\n", "        ", "if", "cache_dir", "is", "None", ":", "\n", "            ", "cache_dir", "=", "os", ".", "path", ".", "expanduser", "(", "\"~/.cache/gdrive\"", ")", "\n", "", "self", ".", "cache_dir", "=", "cache_dir", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GoogleDriveHandler._root_dir": [[249, 251], ["None"], "methods", ["None"], ["", "def", "_root_dir", "(", "self", ")", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GoogleDriveHandler._get_local_path": [[252, 289], ["str", "path.GoogleDriveHandler.GoogleDriveHandler._check_kwargs", "ModuleNotFoundError", "path.GoogleDriveHandler.GoogleDriveHandler._handle_folder", "path.GoogleDriveHandler.GoogleDriveHandler._handle_file", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GoogleDriveHandler._handle_folder", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GoogleDriveHandler._handle_file"], ["", "def", "_get_local_path", "(", "\n", "self", ",", "\n", "path", ":", "str", ",", "\n", "force", ":", "bool", "=", "False", ",", "\n", "cache", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "is_folder", "=", "None", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "str", ":", "\n", "        ", "\"\"\"Get local path to google drive file.\n\n        To force a download, set ``force=True``.\n\n        Args:\n            path (str): The relative file path in the GitHub repository.\n                Must start with ``'gdrive://'``.\n            force (bool, optional): If ``True``, force a download of the Github\n                repository. Defaults to ``False``.\n            cache (str, optional): The path to cache file to.\n\n        Returns:\n            str: The local path to the file/directory.\n        \"\"\"", "\n", "if", "not", "_GDOWN_AVAILABLE", ":", "\n", "            ", "raise", "ModuleNotFoundError", "(", "\"`gdown` not installed. Install it via `pip install gdown`\"", ")", "\n", "\n", "", "path", "=", "str", "(", "path", ")", "\n", "path", "=", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", "\n", "self", ".", "_check_kwargs", "(", "kwargs", ")", "\n", "\n", "if", "is_folder", "is", "None", ":", "\n", "            ", "is_folder", "=", "\"drive.google.com\"", "in", "path", "and", "\"folders\"", "in", "path", "\n", "\n", "", "if", "is_folder", ":", "\n", "            ", "path", "=", "self", ".", "_handle_folder", "(", "path", ",", "cache", ",", "force", ")", "\n", "", "else", ":", "\n", "            ", "path", "=", "self", ".", "_handle_file", "(", "path", ",", "cache", ",", "force", ")", "\n", "", "return", "path", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GoogleDriveHandler._handle_file": [[290, 309], ["os.makedirs", "os.path.join", "str", "os.path.dirname", "logging.getLogger", "logging.getLogger.info", "gdown.download", "logging.getLogger.info", "[].split", "os.path.exists", "path.split"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler.download"], ["", "def", "_handle_file", "(", "self", ",", "path", ":", "str", ",", "cache", ":", "str", ",", "force", ":", "bool", ")", "->", "str", ":", "\n", "        ", "if", "\"drive.google.com\"", "in", "path", ":", "\n", "            ", "gdrive_id", "=", "path", ".", "split", "(", "\"/d/\"", ")", "[", "1", "]", ".", "split", "(", "\"/\"", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "gdrive_id", "=", "path", "\n", "\n", "", "if", "cache", "is", "None", ":", "\n", "            ", "cache", "=", "os", ".", "path", ".", "join", "(", "self", ".", "cache_dir", ",", "gdrive_id", ")", "\n", "", "else", ":", "\n", "            ", "cache", "=", "str", "(", "cache", ")", "\n", "", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "cache", ")", ",", "exist_ok", "=", "True", ")", "\n", "\n", "if", "force", "or", "not", "os", ".", "path", ".", "exists", "(", "cache", ")", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Downloading gdrive file from {}...\"", ".", "format", "(", "path", ")", ")", "\n", "gdown", ".", "download", "(", "id", "=", "gdrive_id", ",", "output", "=", "cache", ")", "\n", "logger", ".", "info", "(", "\"File cached to {}\"", ".", "format", "(", "cache", ")", ")", "\n", "\n", "", "return", "cache", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.GoogleDriveHandler._handle_folder": [[310, 332], ["logging.getLogger", "client.get", "parse_google_drive_file", "os.path.join", "str", "logging.getLogger.info", "gdown.download_folder", "logging.getLogger.info", "logging.getLogger.info", "ValueError", "os.path.exists"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "_handle_folder", "(", "self", ",", "path", ":", "str", ",", "cache", ":", "str", ",", "force", ":", "bool", ")", "->", "str", ":", "\n", "        ", "from", "gdown", ".", "download_folder", "import", "client", ",", "parse_google_drive_file", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "if", "cache", "is", "None", ":", "\n", "            ", "folder_page", "=", "client", ".", "get", "(", "path", ")", "\n", "if", "folder_page", ".", "status_code", "!=", "200", ":", "\n", "                ", "raise", "ValueError", "(", "\"Unable to download gdrive url: {}\"", ".", "format", "(", "path", ")", ")", "\n", "", "gdrive_file", ",", "_", "=", "parse_google_drive_file", "(", "path", ",", "folder_page", ".", "content", ")", "\n", "cache", "=", "os", ".", "path", ".", "join", "(", "self", ".", "cache_dir", ",", "gdrive_file", ".", "name", ")", "\n", "", "else", ":", "\n", "            ", "cache", "=", "str", "(", "cache", ")", "\n", "\n", "", "if", "force", "or", "not", "os", ".", "path", ".", "exists", "(", "cache", ")", ":", "\n", "            ", "logger", ".", "info", "(", "\"Downloading gdrive folder from {}...\"", ".", "format", "(", "path", ")", ")", "\n", "gdown", ".", "download_folder", "(", "url", "=", "path", ",", "output", "=", "cache", ")", "\n", "logger", ".", "info", "(", "\"Folder cached to {}\"", ".", "format", "(", "cache", ")", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "\"Folder {} already exists. Skipping download.\"", ".", "format", "(", "cache", ")", ")", "\n", "\n", "", "return", "cache", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler.__init__": [[355, 359], ["weakref.proxy", "iopath.common.file_io.PathHandler.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "path_manager", ":", "PathManager", ",", "cache_dir", "=", "None", ",", "**", "kwargs", ")", "->", "None", ":", "\n", "        ", "self", ".", "path_manager", "=", "weakref", ".", "proxy", "(", "path_manager", ")", "\n", "self", ".", "cache_dir", "=", "cache_dir", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._get_supported_prefixes": [[360, 362], ["None"], "methods", ["None"], ["", "def", "_get_supported_prefixes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "PREFIX", "+", "self", ".", "LEGACY_PREFIX", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._root_dir": [[363, 365], ["None"], "methods", ["None"], ["", "def", "_root_dir", "(", "self", ")", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._check_other_prefixes": [[366, 373], ["str", "path.URLHandler.URLHandler._DOMAIN_TO_PREFIX_MATCH.items", "path.URLHandler.URLHandler._parse_legacy_prefix"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._parse_legacy_prefix"], ["", "def", "_check_other_prefixes", "(", "self", ",", "path", ":", "str", ")", "->", "str", ":", "\n", "        ", "path", "=", "str", "(", "path", ")", "\n", "for", "domain", ",", "prefix", "in", "self", ".", "_DOMAIN_TO_PREFIX_MATCH", ".", "items", "(", ")", ":", "\n", "            ", "if", "domain", "in", "path", ":", "\n", "                ", "path", "=", "self", ".", "_parse_legacy_prefix", "(", "path", ")", "\n", "return", "f\"{prefix}{path}\"", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._parse_legacy_prefix": [[374, 380], ["path.startswith", "len"], "methods", ["None"], ["", "def", "_parse_legacy_prefix", "(", "self", ",", "path", ":", "str", ")", "->", "str", ":", "\n", "        ", "\"\"\"Parses legacy prefixes out of the url path.\"\"\"", "\n", "for", "prefix", "in", "self", ".", "LEGACY_PREFIX", ":", "\n", "            ", "if", "path", ".", "startswith", "(", "prefix", ")", ":", "\n", "                ", "return", "path", "[", "len", "(", "prefix", ")", ":", "]", "\n", "", "", "return", "path", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._open": [[381, 402], ["path.URLHandler.URLHandler._check_other_prefixes", "path.URLHandler.URLHandler._parse_legacy_prefix", "requests.get", "requests.get.raise_for_status", "ValueError", "path.URLHandler.URLHandler.path_manager.open", "ModuleNotFoundError", "iocursor.Cursor", "io.BytesIO"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._check_other_prefixes", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._parse_legacy_prefix", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["", "def", "_open", "(", "self", ",", "path", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "mode", "not", "in", "(", "\"r\"", ",", "\"rb\"", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only file reading is supported.\"", ")", "\n", "\n", "", "other_domain_path", "=", "self", ".", "_check_other_prefixes", "(", "path", ")", "\n", "if", "other_domain_path", ":", "\n", "            ", "return", "self", ".", "path_manager", ".", "open", "(", "other_domain_path", ",", "mode", "=", "mode", ",", "**", "kwargs", ")", "\n", "\n", "", "if", "not", "_REQUESTS_AVAILABLE", ":", "\n", "            ", "raise", "ModuleNotFoundError", "(", "\n", "\"`requests` not installed. Install it via `pip install requests`\"", "\n", ")", "\n", "\n", "", "path", "=", "self", ".", "_parse_legacy_prefix", "(", "path", ")", "\n", "r", "=", "requests", ".", "get", "(", "path", ",", "**", "kwargs", ")", "\n", "r", ".", "raise_for_status", "(", ")", "\n", "\n", "if", "_IOCURSOR_AVAILABLE", ":", "\n", "            ", "return", "iocursor", ".", "Cursor", "(", "r", ".", "content", ")", "\n", "", "else", ":", "\n", "            ", "return", "io", ".", "BytesIO", "(", "r", ".", "content", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._get_local_path": [[403, 461], ["path.URLHandler.URLHandler._check_other_prefixes", "path.URLHandler.URLHandler._parse_legacy_prefix", "path.URLHandler.URLHandler._check_kwargs", "path.URLHandler.URLHandler.path_manager.get_local_path", "ModuleNotFoundError", "str", "os.path.join", "os.path.join", "logging.getLogger", "logging.getLogger.info", "requests.get", "requests.get.raise_for_status", "os.makedirs", "logging.getLogger.info", "meddlr.utils.env.get_path_manager().get_local_path", "path.URLHandler.URLHandler.split", "str().endswith", "os.path.isdir", "os.path.join", "os.path.isfile", "os.path.dirname", "open", "f.write", "os.path.basename", "meddlr.utils.env.get_path_manager", "meddlr.utils.cluster.Cluster.working_cluster", "str"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._check_other_prefixes", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._parse_legacy_prefix", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.working_cluster"], ["", "", "def", "_get_local_path", "(", "\n", "self", ",", "\n", "path", ":", "str", ",", "\n", "force", ":", "bool", "=", "False", ",", "\n", "cache", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "str", ":", "\n", "        ", "\"\"\"Get local path to google drive file.\n\n        To force a download, set ``force=True``.\n\n        Args:\n            path (str): The relative file path in the GitHub repository.\n                Must start with ``'gdrive://'``.\n            force (bool, optional): If ``True``, force a download of the Github\n                repository. Defaults to ``False``.\n            cache (str, optional): The path to cache file to.\n\n        Returns:\n            str: The local path to the file/directory.\n        \"\"\"", "\n", "other_domain_path", "=", "self", ".", "_check_other_prefixes", "(", "path", ")", "\n", "if", "other_domain_path", ":", "\n", "            ", "return", "self", ".", "path_manager", ".", "get_local_path", "(", "\n", "other_domain_path", ",", "force", "=", "force", ",", "cache", "=", "cache", ",", "**", "kwargs", "\n", ")", "\n", "\n", "", "if", "not", "_REQUESTS_AVAILABLE", ":", "\n", "            ", "raise", "ModuleNotFoundError", "(", "\n", "\"`requests` not installed. Install it via `pip install requests`\"", "\n", ")", "\n", "\n", "", "path", "=", "self", ".", "_parse_legacy_prefix", "(", "str", "(", "path", ")", ")", "\n", "self", ".", "_check_kwargs", "(", "kwargs", ")", "\n", "\n", "if", "cache", "is", "None", ":", "\n", "            ", "cache", "=", "os", ".", "path", ".", "join", "(", "\n", "env", ".", "get_path_manager", "(", ")", ".", "get_local_path", "(", "Cluster", ".", "working_cluster", "(", ")", ".", "cache_dir", ")", ",", "\"url\"", "\n", ")", "\n", "base", "=", "path", ".", "split", "(", "\"://\"", ",", "1", ")", "[", "1", "]", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "cache", ",", "base", ")", "\n", "", "elif", "str", "(", "cache", ")", ".", "endswith", "(", "os", ".", "pathsep", ")", "or", "os", ".", "path", ".", "isdir", "(", "path", ")", ":", "\n", "            ", "out_file", "=", "os", ".", "path", ".", "join", "(", "cache", ",", "os", ".", "path", ".", "basename", "(", "path", ")", ")", "\n", "", "else", ":", "\n", "            ", "out_file", "=", "cache", "\n", "\n", "# TODO: Make caching smarter based on time of file creation and update.", "\n", "", "if", "force", "or", "not", "os", ".", "path", ".", "isfile", "(", "out_file", ")", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Downloading file from {}...\"", ".", "format", "(", "path", ")", ")", "\n", "r", "=", "requests", ".", "get", "(", "path", ")", "\n", "r", ".", "raise_for_status", "(", ")", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "out_file", ")", ",", "exist_ok", "=", "True", ")", "\n", "with", "open", "(", "out_file", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "r", ".", "content", ")", "\n", "", "logger", ".", "info", "(", "\"File cached to {}\"", ".", "format", "(", "out_file", ")", ")", "\n", "\n", "", "return", "out_file", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.DownloadHandler.__init__": [[475, 479], ["weakref.proxy", "iopath.common.file_io.PathHandler.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "path_manager", ":", "PathManager", ",", "async_executor", "=", "None", ")", "->", "None", ":", "\n", "# Avoid memory leak.", "\n", "        ", "self", ".", "path_manager", "=", "weakref", ".", "proxy", "(", "path_manager", ")", "\n", "super", "(", ")", ".", "__init__", "(", "async_executor", "=", "async_executor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.DownloadHandler._root_dir": [[480, 482], ["None"], "methods", ["None"], ["", "def", "_root_dir", "(", "self", ")", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.DownloadHandler._get_local_path": [[483, 507], ["path.DownloadHandler.path_manager.get_local_path", "len", "path.DownloadHandler.path_manager.get_local_path", "ValueError"], "methods", ["None"], ["", "def", "_get_local_path", "(", "\n", "self", ",", "\n", "path", ":", "str", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "str", ":", "\n", "        ", "\"\"\"Get local path to google drive file.\n\n        To force a download, set ``force=True``.\n\n        Args:\n            path (str): The relative file path in the GitHub repository.\n                Must start with ``'download://'``.\n\n        Returns:\n            str: The local path to the file/directory.\n        \"\"\"", "\n", "path", "=", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", "\n", "\n", "if", "\"drive.google.com\"", "in", "path", ":", "\n", "            ", "return", "self", ".", "path_manager", ".", "get_local_path", "(", "f\"gdrive://{path}\"", ",", "**", "kwargs", ")", "\n", "", "elif", "\"huggingface.co\"", "in", "path", ":", "\n", "            ", "return", "self", ".", "path_manager", ".", "get_local_path", "(", "path", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Download not supported for url {path}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path": [[521, 529], ["kwargs.pop", "path.ForceDownloadHandler.path_manager.get_local_path", "len"], "methods", ["None"], ["def", "_get_local_path", "(", "\n", "self", ",", "\n", "path", ":", "str", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "str", ":", "\n", "        ", "path", "=", "f\"{DownloadHandler.PREFIX}{path[len(self.PREFIX) :]}\"", "\n", "kwargs", ".", "pop", "(", "\"force\"", ",", "None", ")", "\n", "return", "self", ".", "path_manager", ".", "get_local_path", "(", "path", ",", "force", "=", "True", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.download_github_repository": [[531, 568], ["str", "cache_path.format.format", "os.makedirs", "os.system", "os.listdir", "os.path.join", "os.system", "shutil.rmtree", "os.path.isdir", "os.listdir", "shutil.rmtree", "RuntimeError", "len", "RuntimeError"], "function", ["None"], ["", "", "def", "download_github_repository", "(", "url", ",", "cache_path", ",", "branch_or_tag", "=", "\"main\"", ",", "force", "=", "False", ")", "->", "str", ":", "\n", "    ", "\"\"\"Downloads the repository from Github.\n\n    Args:\n        version (str): The version to download. Defaults to the\n            version of the current codebase.\n        path (str): The path to download the repository to.\n            Defaults to the the cache directory.\n        force (bool): Whether to overwrite existing files.\n\n    Returns:\n        str: The path to the downloaded repository.\n    \"\"\"", "\n", "url", "=", "f\"{url}/tarball/{branch_or_tag}\"", "\n", "cache_path", "=", "str", "(", "cache_path", ")", "\n", "cache_path", "=", "cache_path", ".", "format", "(", "branch_or_tag", "=", "branch_or_tag", ")", "\n", "\n", "dir_exists_and_not_empty", "=", "os", ".", "path", ".", "isdir", "(", "cache_path", ")", "and", "os", ".", "listdir", "(", "cache_path", ")", "\n", "if", "dir_exists_and_not_empty", ":", "\n", "        ", "if", "not", "force", ":", "\n", "            ", "return", "cache_path", "\n", "", "shutil", ".", "rmtree", "(", "cache_path", ")", "\n", "", "os", ".", "makedirs", "(", "cache_path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "retval", "=", "os", ".", "system", "(", "f\"wget -O - {url} | tar xz -C {cache_path}\"", ")", "\n", "if", "retval", "!=", "0", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Could not download repository.\"", ")", "\n", "\n", "", "folders", "=", "os", ".", "listdir", "(", "cache_path", ")", "\n", "assert", "len", "(", "folders", ")", "==", "1", "\n", "curr_path", "=", "os", ".", "path", ".", "join", "(", "cache_path", ",", "folders", "[", "0", "]", ")", "\n", "retval", "=", "os", ".", "system", "(", "f\"mv {curr_path}/* {cache_path}\"", ")", "\n", "if", "retval", "!=", "0", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Could not download repository.\"", ")", "\n", "", "shutil", ".", "rmtree", "(", "curr_path", ")", "\n", "\n", "return", "cache_path", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.__init__": [[64, 101], ["isinstance", "socket.gethostname", "socket.gethostname"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", "=", "None", ",", "\n", "patterns", ":", "Union", "[", "str", ",", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "data_dir", ":", "str", "=", "None", ",", "\n", "results_dir", ":", "str", "=", "None", ",", "\n", "cache_dir", ":", "str", "=", "None", ",", "\n", "**", "cfg_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            name (str): The name of the cluster. Name is case-sensitive.\n            patterns (Sequence[str]): Regex pattern(s) for identifying nodes\n                in the cluster. Cluster will be identified by\n                ``any(re.match(p, socket.gethostname()) for p in patterns)``.\n                If ``None``, defaults to current hostname.\n            data_dir (str, optional): The data directory. Defaults to\n                ``os.environ['MEDDLR_DATASETS_DIR']`` or ``\"./datasets\"``.\n            results_dir (str, optional): The results directory. Defaults to\n                `\"os.environ['MEDDLR_RESULTS_DIR']\"` or ``\"./results\"``.\n            cfg_kwargs (optional): Any other configurations you would like to\n                store for the cluster.\n        \"\"\"", "\n", "if", "name", "is", "None", ":", "\n", "            ", "name", "=", "socket", ".", "gethostname", "(", ")", "\n", "", "self", ".", "name", "=", "name", "\n", "\n", "if", "patterns", "is", "None", ":", "\n", "            ", "patterns", "=", "socket", ".", "gethostname", "(", ")", "\n", "", "if", "isinstance", "(", "patterns", ",", "str", ")", ":", "\n", "            ", "patterns", "=", "[", "patterns", "]", "\n", "", "self", ".", "patterns", "=", "patterns", "\n", "\n", "self", ".", "_data_dir", "=", "data_dir", "\n", "self", ".", "_results_dir", "=", "results_dir", "\n", "self", ".", "_cache_dir", "=", "cache_dir", "\n", "self", ".", "_cfg_kwargs", "=", "cfg_kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.data_dir": [[102, 107], ["os.environ.get", "_PATH_MANAGER.get_local_path"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "@", "property", "\n", "def", "data_dir", "(", "self", ")", ":", "\n", "        ", "path", "=", "self", ".", "_data_dir", "\n", "path", "=", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_DATASETS_DIR\"", ",", "path", "if", "path", "else", "\"./datasets\"", ")", "\n", "return", "_PATH_MANAGER", ".", "get_local_path", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.datasets_dir": [[108, 112], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "datasets_dir", "(", "self", ")", ":", "\n", "        ", "\"\"\"Alias for ``self.data_dir``.\"\"\"", "\n", "return", "self", ".", "data_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.results_dir": [[113, 118], ["os.environ.get", "_PATH_MANAGER.get_local_path"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "@", "property", "\n", "def", "results_dir", "(", "self", ")", ":", "\n", "        ", "path", "=", "self", ".", "_results_dir", "\n", "path", "=", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_RESULTS_DIR\"", ",", "path", "if", "path", "else", "\"./results\"", ")", "\n", "return", "_PATH_MANAGER", ".", "get_local_path", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.cache_dir": [[119, 126], ["os.environ.get", "_PATH_MANAGER.get_local_path", "os.path.expanduser"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "@", "property", "\n", "def", "cache_dir", "(", "self", ")", ":", "\n", "        ", "path", "=", "self", ".", "_cache_dir", "\n", "if", "not", "path", ":", "\n", "            ", "path", "=", "os", ".", "path", ".", "expanduser", "(", "\"~/.cache/meddlr\"", ")", "\n", "", "path", "=", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_CACHE_DIR\"", ",", "path", ")", "\n", "return", "_PATH_MANAGER", ".", "get_local_path", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.set": [[127, 147], ["kwargs.items", "hasattr", "setattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "set", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Set cluster configuration properties.\n\n        Args:\n            kwargs: Keyword arguments to set.\n\n        Examples:\n            >>> cluster.set(data_dir=\"/path/to/datasets\", results_dir=\"/path/to/results\")\n\n        Note:\n            Setting attributes for the cluster will not override environment variables.\n            For example, if ``os.environ['MEDDLR_DATASETS_DIR']`` is set, setting ``data_dir``\n            will have no effect.\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "private_key", "=", "f\"_{k}\"", "\n", "if", "hasattr", "(", "self", ",", "private_key", ")", ":", "\n", "                ", "setattr", "(", "self", ",", "private_key", ",", "v", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_cfg_kwargs", "[", "k", "]", "=", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.__getattr__": [[148, 155], ["os.environ.get", "attr.upper", "AttributeError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "", "", "def", "__getattr__", "(", "self", ",", "attr", ":", "str", ")", ":", "\n", "        ", "attr_env", "=", "f\"MEDDLR_{attr.upper()}\"", "\n", "try", ":", "\n", "            ", "value", "=", "os", ".", "environ", ".", "get", "(", "attr_env", ",", "self", ".", "_cfg_kwargs", "[", "attr", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "raise", "AttributeError", "(", "f\"Attribute {attr} not specified for cluster {self.name}.\"", ")", "\n", "", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.save": [[156, 171], ["cluster.Cluster.config_file", "os.makedirs", "os.path.isfile", "os.path.dirname", "open", "yaml.safe_dump", "open", "yaml.safe_load", "k.startswith", "cluster.Cluster.__dict__.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.config_file", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "save", "(", "self", ")", ":", "\n", "        ", "\"\"\"Save cluster config to yaml file.\"\"\"", "\n", "filepath", "=", "self", ".", "config_file", "(", ")", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "filepath", ")", ",", "exist_ok", "=", "True", ")", "\n", "\n", "cluster_cfgs", "=", "{", "}", "\n", "if", "os", ".", "path", ".", "isfile", "(", "filepath", ")", ":", "\n", "            ", "with", "open", "(", "filepath", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "cluster_cfgs", "=", "yaml", ".", "safe_load", "(", "f", ")", "\n", "\n", "", "", "data", "=", "{", "(", "k", "[", "1", ":", "]", "if", "k", ".", "startswith", "(", "\"_\"", ")", "else", "k", ")", ":", "v", "for", "k", ",", "v", "in", "self", ".", "__dict__", ".", "items", "(", ")", "}", "\n", "cluster_cfgs", "[", "self", ".", "name", "]", "=", "data", "\n", "\n", "with", "open", "(", "filepath", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "yaml", ".", "safe_dump", "(", "cluster_cfgs", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.delete": [[172, 187], ["cluster.Cluster.config_file", "cluster_cfgs.pop", "os.path.isfile", "open", "yaml.safe_load", "open", "yaml.safe_dump"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.config_file", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["", "", "def", "delete", "(", "self", ")", ":", "\n", "        ", "\"\"\"Deletes cluster config from yaml file.\"\"\"", "\n", "filepath", "=", "self", ".", "config_file", "(", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "filepath", ")", ":", "\n", "            ", "return", "\n", "\n", "", "with", "open", "(", "filepath", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "cluster_cfgs", ":", "Dict", "[", "str", ",", "Any", "]", "=", "yaml", ".", "safe_load", "(", "f", ")", "\n", "\n", "", "if", "self", ".", "name", "not", "in", "cluster_cfgs", ":", "\n", "            ", "return", "\n", "\n", "", "cluster_cfgs", ".", "pop", "(", "self", ".", "name", ")", "\n", "with", "open", "(", "filepath", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "yaml", ".", "safe_dump", "(", "cluster_cfgs", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.get_path": [[188, 191], ["getattr"], "methods", ["None"], ["", "", "def", "get_path", "(", "self", ",", "key", ")", ":", "\n", "        ", "\"\"\"Legacy method for fetching cluster-specific paths.\"\"\"", "\n", "return", "getattr", "(", "self", ",", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.all_clusters": [[192, 195], ["cls.from_config"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.from_config"], ["", "@", "classmethod", "\n", "def", "all_clusters", "(", "cls", ")", "->", "List", "[", "\"Cluster\"", "]", ":", "\n", "        ", "return", "cls", ".", "from_config", "(", "name", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.cluster": [[196, 217], ["socket.gethostname", "cls.all_clusters", "any", "re.match"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.all_clusters"], ["", "@", "classmethod", "\n", "def", "cluster", "(", "cls", ")", ":", "\n", "        ", "\"\"\"Searches saved clusters by regex matching with hostname.\n\n        Returns:\n            Cluster: The current cluster.\n\n        Note:\n            The cluster must have been saved to a config file. Also, if\n            there are multiple cluster matches, only the first (sorted alphabetically)\n            will be returned.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "clusters", "=", "cls", ".", "all_clusters", "(", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "            ", "return", "_UNKNOWN", "\n", "", "hostname", "=", "socket", ".", "gethostname", "(", ")", "\n", "for", "clus", "in", "clusters", ":", "\n", "            ", "if", "any", "(", "re", ".", "match", "(", "p", ",", "hostname", ")", "for", "p", "in", "clus", ".", "patterns", ")", ":", "\n", "                ", "return", "clus", "\n", "", "", "return", "_UNKNOWN", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.from_config": [[218, 242], ["cls.config_file", "os.path.isfile", "FileNotFoundError", "open", "yaml.safe_load", "isinstance", "cls", "cls", "yaml.safe_load.values", "type", "cls"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.config_file", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "name", ")", ":", "\n", "        ", "\"\"\"Loads cluster from config.\n\n        Args:\n            name (str | Sequence[str] | None): Cluster name(s) to load.\n                If ``None``, all clusters will be loaded.\n\n        Returns:\n            Cluster: The Cluster object(s).\n        \"\"\"", "\n", "filepath", "=", "cls", ".", "config_file", "(", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "filepath", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "f\"Config file not found: {filepath}\"", ")", "\n", "\n", "", "with", "open", "(", "filepath", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "cfg", "=", "yaml", ".", "safe_load", "(", "f", ")", "\n", "\n", "", "if", "name", "is", "None", ":", "\n", "            ", "return", "[", "cls", "(", "**", "cluster_cfg", ")", "for", "cluster_cfg", "in", "cfg", ".", "values", "(", ")", "]", "\n", "", "elif", "isinstance", "(", "name", ",", "str", ")", ":", "\n", "            ", "return", "cls", "(", "**", "cfg", "[", "name", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "type", "(", "name", ")", "(", "[", "cls", "(", "**", "cfg", "[", "n", "]", ")", "for", "n", "in", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.config_file": [[243, 246], ["os.path.join", "meddlr.utils.env.settings_dir"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.settings_dir"], ["", "", "@", "staticmethod", "\n", "def", "config_file", "(", ")", ":", "\n", "        ", "return", "os", ".", "path", ".", "join", "(", "env", ".", "settings_dir", "(", ")", ",", "\"clusters.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.working_cluster": [[247, 250], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "working_cluster", "(", ")", "->", "\"Cluster\"", ":", "\n", "        ", "return", "_CLUSTER", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.use": [[251, 265], ["cluster.set_cluster"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.set_cluster"], ["", "def", "use", "(", "self", ")", ":", "\n", "        ", "\"\"\"Sets ``self`` to be the working cluster of the project.\n\n        The working cluster is the default cluster that is used to manage\n        paths and other configuration variables.\n\n        Examples:\n            >>> cluster.use()\n\n        Note:\n            This function does not override environment variables.\n            All environment variables will take priority over this clusters\n        \"\"\"", "\n", "set_cluster", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.__repr__": [[266, 269], ["cluster.Cluster.__dict__.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"Cluster({})\"", ".", "format", "(", "\n", "\", \"", ".", "join", "(", "\"{}={}\"", ".", "format", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "self", ".", "__dict__", ".", "items", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.set_cluster": [[272, 288], ["isinstance", "Cluster.from_config.lower", "_UNKNOWN.name.lower", "cluster.Cluster.from_config"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.from_config"], ["", "", "def", "set_cluster", "(", "cluster", ":", "Union", "[", "str", ",", "Cluster", "]", "=", "None", ")", ":", "\n", "    ", "\"\"\"Sets the working cluster.\n    Args:\n        cluster (`str` or `Cluster`): The cluster name or cluster.\n            If ``None``, will reset cluster to _UNKNOWN, meaning default\n            data and results dirs will be used.\n    \"\"\"", "\n", "if", "cluster", "is", "None", ":", "\n", "        ", "cluster", "=", "_UNKNOWN", "\n", "", "elif", "isinstance", "(", "cluster", ",", "str", ")", ":", "\n", "        ", "if", "cluster", ".", "lower", "(", ")", "==", "_UNKNOWN", ".", "name", ".", "lower", "(", ")", ":", "\n", "            ", "cluster", "=", "_UNKNOWN", "\n", "", "else", ":", "\n", "            ", "cluster", "=", "Cluster", ".", "from_config", "(", "cluster", ")", "\n", "", "", "global", "_CLUSTER", "\n", "_CLUSTER", "=", "cluster", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.collect_env.collect_torch_env": [[21, 31], ["torch.__config__.show", "get_pretty_env_info"], "function", ["None"], ["def", "collect_torch_env", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "import", "torch", ".", "__config__", "\n", "\n", "return", "torch", ".", "__config__", ".", "show", "(", ")", "\n", "", "except", "ImportError", ":", "\n", "# compatible with older versions of pytorch", "\n", "        ", "from", "torch", ".", "utils", ".", "collect_env", "import", "get_pretty_env_info", "\n", "\n", "return", "get_pretty_env_info", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.collect_env.detect_compute_compatibility": [[33, 52], ["os.path.join", "os.path.isfile", "subprocess.check_output", "output.decode().strip().split.decode().strip().split", "sorted", "sorted.append", "set", "output.decode().strip().split.decode().strip", "re.findall", "line.strip", "output.decode().strip().split.decode"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "", "def", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "so_file", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "cuobjdump", "=", "os", ".", "path", ".", "join", "(", "CUDA_HOME", ",", "\"bin\"", ",", "\"cuobjdump\"", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "cuobjdump", ")", ":", "\n", "            ", "output", "=", "subprocess", ".", "check_output", "(", "\n", "\"'{}' --list-elf '{}'\"", ".", "format", "(", "cuobjdump", ",", "so_file", ")", ",", "shell", "=", "True", "\n", ")", "\n", "output", "=", "output", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", ".", "split", "(", "\"\\n\"", ")", "\n", "sm", "=", "[", "]", "\n", "for", "line", "in", "output", ":", "\n", "                ", "line", "=", "re", ".", "findall", "(", "r\"\\.sm_[0-9]*\\.\"", ",", "line", ")", "[", "0", "]", "\n", "sm", ".", "append", "(", "line", ".", "strip", "(", "\".\"", ")", ")", "\n", "", "sm", "=", "sorted", "(", "set", "(", "sm", ")", ")", "\n", "return", "\", \"", ".", "join", "(", "sm", ")", "\n", "", "else", ":", "\n", "            ", "return", "so_file", "+", "\"; cannot find cuobjdump\"", "\n", "", "", "except", "Exception", ":", "\n", "# unhandled failure", "\n", "        ", "return", "so_file", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.collect_env.collect_env_info": [[54, 122], ["torch.cuda.is_available", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "collect_env.collect_torch_env", "collections.defaultdict", "range", "collections.defaultdict.items", "data.append", "os.environ.get", "data.append", "data.append", "tabulate.tabulate", "sys.version.replace", "torch.cuda.device_count", "devices[].append", "data.append", "os.path.isdir", "data.append", "data.append", "data.append", "os.environ.get", "os.path.dirname", "str", "str", "os.path.join", "subprocess.check_output", "nvcc.decode().strip.decode().strip", "collect_env.detect_compute_compatibility", "data.append", "os.path.dirname", "importlib.util.find_spec", "data.append", "nvcc.decode().strip.decode", "str", "torch.cuda.get_device_name"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.collect_env.collect_torch_env", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.collect_env.detect_compute_compatibility"], ["", "", "def", "collect_env_info", "(", ")", ":", "\n", "    ", "has_cuda", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "\n", "data", "=", "[", "]", "\n", "data", ".", "append", "(", "(", "\"sys.platform\"", ",", "sys", ".", "platform", ")", ")", "\n", "data", ".", "append", "(", "(", "\"Python\"", ",", "sys", ".", "version", ".", "replace", "(", "\"\\n\"", ",", "\"\"", ")", ")", ")", "\n", "data", ".", "append", "(", "(", "\"numpy\"", ",", "np", ".", "__version__", ")", ")", "\n", "\n", "data", ".", "append", "(", "(", "\"PyTorch\"", ",", "torch", ".", "__version__", "+", "\" @\"", "+", "os", ".", "path", ".", "dirname", "(", "torch", ".", "__file__", ")", ")", ")", "\n", "data", ".", "append", "(", "(", "\"PyTorch debug build\"", ",", "torch", ".", "version", ".", "debug", ")", ")", "\n", "\n", "data", ".", "append", "(", "(", "\"CUDA available\"", ",", "has_cuda", ")", ")", "\n", "if", "has_cuda", ":", "\n", "        ", "devices", "=", "defaultdict", "(", "list", ")", "\n", "for", "k", "in", "range", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ":", "\n", "            ", "devices", "[", "torch", ".", "cuda", ".", "get_device_name", "(", "k", ")", "]", ".", "append", "(", "str", "(", "k", ")", ")", "\n", "", "for", "name", ",", "devids", "in", "devices", ".", "items", "(", ")", ":", "\n", "            ", "data", ".", "append", "(", "(", "\"GPU \"", "+", "\",\"", ".", "join", "(", "devids", ")", ",", "name", ")", ")", "\n", "\n", "# NOTE: the use of CUDA_HOME requires the CUDA build deps, though in", "\n", "# theory meddlr should be made runnable with only the CUDA runtime", "\n", "", "from", "torch", ".", "utils", ".", "cpp_extension", "import", "CUDA_HOME", "\n", "\n", "data", ".", "append", "(", "(", "\"CUDA_HOME\"", ",", "str", "(", "CUDA_HOME", ")", ")", ")", "\n", "\n", "if", "CUDA_HOME", "is", "not", "None", "and", "os", ".", "path", ".", "isdir", "(", "CUDA_HOME", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "nvcc", "=", "os", ".", "path", ".", "join", "(", "CUDA_HOME", ",", "\"bin\"", ",", "\"nvcc\"", ")", "\n", "nvcc", "=", "subprocess", ".", "check_output", "(", "\"'{}' -V | tail -n1\"", ".", "format", "(", "nvcc", ")", ",", "shell", "=", "True", ")", "\n", "nvcc", "=", "nvcc", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", "\n", "", "except", "subprocess", ".", "SubprocessError", ":", "\n", "                ", "nvcc", "=", "\"Not Available\"", "\n", "", "data", ".", "append", "(", "(", "\"NVCC\"", ",", "nvcc", ")", ")", "\n", "\n", "", "cuda_arch_list", "=", "os", ".", "environ", ".", "get", "(", "\"TORCH_CUDA_ARCH_LIST\"", ",", "None", ")", "\n", "if", "cuda_arch_list", ":", "\n", "            ", "data", ".", "append", "(", "(", "\"TORCH_CUDA_ARCH_LIST\"", ",", "cuda_arch_list", ")", ")", "\n", "", "", "data", ".", "append", "(", "(", "\"Pillow\"", ",", "PIL", ".", "__version__", ")", ")", "\n", "\n", "try", ":", "\n", "        ", "data", ".", "append", "(", "\n", "(", "\n", "\"torchvision\"", ",", "\n", "str", "(", "torchvision", ".", "__version__", ")", "+", "\" @\"", "+", "os", ".", "path", ".", "dirname", "(", "torchvision", ".", "__file__", ")", ",", "\n", ")", "\n", ")", "\n", "if", "has_cuda", ":", "\n", "            ", "try", ":", "\n", "                ", "torchvision_C", "=", "importlib", ".", "util", ".", "find_spec", "(", "\"torchvision._C\"", ")", ".", "origin", "\n", "msg", "=", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "torchvision_C", ")", "\n", "data", ".", "append", "(", "(", "\"torchvision arch flags\"", ",", "msg", ")", ")", "\n", "", "except", "ImportError", ":", "\n", "                ", "data", ".", "append", "(", "(", "\"torchvision._C\"", ",", "\"failed to find\"", ")", ")", "\n", "", "", "", "except", "AttributeError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"torchvision\"", ",", "\"unknown\"", ")", ")", "\n", "\n", "# Slurm info", "\n", "", "data", ".", "append", "(", "(", "\"SLURM_JOB_ID\"", ",", "os", ".", "environ", ".", "get", "(", "\"SLURM_JOB_ID\"", ",", "\"slurm not detected\"", ")", ")", ")", "\n", "\n", "try", ":", "\n", "        ", "import", "cv2", "\n", "\n", "data", ".", "append", "(", "(", "\"cv2\"", ",", "cv2", ".", "__version__", ")", ")", "\n", "", "except", "ImportError", ":", "\n", "        ", "pass", "\n", "", "env_str", "=", "tabulate", "(", "data", ")", "+", "\"\\n\"", "\n", "env_str", "+=", "collect_torch_env", "(", ")", "\n", "return", "env_str", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated": [[7, 16], ["deprecated._get_deprecated_msg", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated._get_deprecated_msg"], ["def", "deprecated", "(", "\n", "reason", "=", "None", ",", "vdeprecated", "=", "None", ",", "vremove", "=", "None", ",", "replacement", "=", "None", "\n", ")", "->", "Callable", "[", "[", "TCallable", "]", ",", "TCallable", "]", ":", "\n", "    ", "def", "fn", "(", "func", ":", "TCallable", ")", "->", "TCallable", ":", "\n", "        ", "msg", "=", "_get_deprecated_msg", "(", "func", ",", "reason", ",", "vdeprecated", ",", "vremove", ",", "replacement", ")", "\n", "warnings", ".", "warn", "(", "msg", ",", "DeprecationWarning", ")", "\n", "return", "func", "\n", "\n", "", "return", "fn", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated._get_deprecated_msg": [[18, 37], ["fmt.format"], "function", ["None"], ["", "def", "_get_deprecated_msg", "(", "wrapped", ",", "reason", ",", "vdeprecated", ",", "vremoved", ",", "replacement", "=", "None", ")", ":", "\n", "    ", "fmt", "=", "\"{name} is deprecated\"", "\n", "if", "vdeprecated", ":", "\n", "        ", "fmt", "+=", "\" since v{vdeprecated}\"", "\n", "", "if", "vremoved", ":", "\n", "        ", "fmt", "+=", "\" and will be removed in v{vremoved}\"", "\n", "", "fmt", "+=", "\".\"", "\n", "\n", "if", "reason", ":", "\n", "        ", "fmt", "+=", "\" ({reason})\"", "\n", "", "if", "replacement", ":", "\n", "        ", "fmt", "+=", "\" -- Use meddlr.{replacement} instead.\"", "\n", "\n", "", "return", "fmt", ".", "format", "(", "\n", "name", "=", "wrapped", ".", "__name__", ",", "\n", "reason", "=", "reason", "or", "\"\"", ",", "\n", "vdeprecated", "=", "vdeprecated", "or", "\"\"", ",", "\n", "vremoved", "=", "vremoved", "or", "\"\"", ",", "\n", "replacement", "=", "replacement", "or", "\"\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device": [[11, 52], ["isinstance", "isinstance", "obj.to", "torch.cuda.is_available", "isinstance", "isinstance", "obj.to", "isinstance", "isinstance", "general.move_to_device", "isinstance", "obj.items", "general.move_to_device", "tuple", "general.move_to_device"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device", "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device"], ["def", "move_to_device", "(", "obj", ",", "device", ",", "non_blocking", "=", "False", ",", "base_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Given a structure (possibly) containing Tensors on the CPU, move all the Tensors\n      to the specified GPU (or do nothing, if they should be on the CPU).\n        device = -1 -> \"cpu\"\n        device =  0 -> \"cuda:0\"\n\n    Args:\n      obj(Any): The object to convert.\n      device(int): The device id, defaults to -1.\n\n    Returns:\n      Any: The converted object.\n    \"\"\"", "\n", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", "or", "(", "isinstance", "(", "device", ",", "int", ")", "and", "device", "<", "0", ")", ":", "\n", "        ", "device", "=", "\"cpu\"", "\n", "", "elif", "isinstance", "(", "device", ",", "int", ")", ":", "\n", "        ", "device", "=", "f\"cuda:{device}\"", "\n", "\n", "", "if", "isinstance", "(", "obj", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "obj", ".", "to", "(", "device", ",", "non_blocking", "=", "non_blocking", ")", "# type: ignore", "\n", "", "elif", "base_types", "is", "not", "None", "and", "isinstance", "(", "obj", ",", "base_types", ")", ":", "\n", "        ", "return", "obj", ".", "to", "(", "device", ")", "\n", "", "elif", "isinstance", "(", "obj", ",", "dict", ")", ":", "\n", "        ", "return", "{", "\n", "key", ":", "move_to_device", "(", "value", ",", "device", ",", "non_blocking", "=", "non_blocking", ",", "base_types", "=", "base_types", ")", "\n", "for", "key", ",", "value", "in", "obj", ".", "items", "(", ")", "\n", "}", "\n", "", "elif", "isinstance", "(", "obj", ",", "list", ")", ":", "\n", "        ", "return", "[", "\n", "move_to_device", "(", "item", ",", "device", ",", "non_blocking", "=", "non_blocking", ",", "base_types", "=", "base_types", ")", "\n", "for", "item", "in", "obj", "\n", "]", "\n", "", "elif", "isinstance", "(", "obj", ",", "tuple", ")", ":", "\n", "        ", "return", "tuple", "(", "\n", "[", "\n", "move_to_device", "(", "item", ",", "device", ",", "non_blocking", "=", "non_blocking", ",", "base_types", "=", "base_types", ")", "\n", "for", "item", "in", "obj", "\n", "]", "\n", ")", "\n", "", "else", ":", "\n", "        ", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.find_experiment_dirs": [[54, 85], ["_PATH_MANAGER.get_local_path", "general.find_experiment_dirs._find_exp_dirs"], "function", ["None"], ["", "", "def", "find_experiment_dirs", "(", "dirpath", ",", "completed", "=", "True", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "\"\"\"Recursively search for experiment directories under the ``dirpath``.\n\n    Args:\n        dirpath (str): The base directory under which to search.\n        completed (bool, optional): If `True`, filter directories where runs\n            are completed.\n\n    Returns:\n        exp_dirs (List[str]): A list of experiment directories.\n    \"\"\"", "\n", "\n", "def", "_find_exp_dirs", "(", "_dirpath", ")", ":", "\n", "# Directories with \"config.yaml\" are considered experiment directories.", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "_dirpath", ",", "\"config.yaml\"", ")", ")", ":", "\n", "            ", "return", "[", "_dirpath", "]", "\n", "# Directories with no more subdirectories do not have a path.", "\n", "", "subfiles", "=", "[", "os", ".", "path", ".", "join", "(", "_dirpath", ",", "x", ")", "for", "x", "in", "os", ".", "listdir", "(", "_dirpath", ")", "]", "\n", "subdirs", "=", "[", "x", "for", "x", "in", "subfiles", "if", "os", ".", "path", ".", "isdir", "(", "x", ")", "]", "\n", "if", "len", "(", "subdirs", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "exp_dirs", "=", "[", "]", "\n", "for", "dp", "in", "subdirs", ":", "\n", "            ", "exp_dirs", ".", "extend", "(", "_find_exp_dirs", "(", "dp", ")", ")", "\n", "", "return", "exp_dirs", "\n", "\n", "", "dirpath", "=", "_PATH_MANAGER", ".", "get_local_path", "(", "dirpath", ")", "\n", "exp_dirs", "=", "_find_exp_dirs", "(", "dirpath", ")", "\n", "if", "completed", ":", "\n", "        ", "exp_dirs", "=", "[", "x", "for", "x", "in", "exp_dirs", "if", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "x", ",", "\"model_final.pth\"", ")", ")", "]", "\n", "", "return", "exp_dirs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.flatten_dict": [[87, 105], ["results.items", "isinstance", "general.flatten_dict", "flatten_dict.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.flatten_dict", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "flatten_dict", "(", "results", ",", "delimiter", "=", "\"/\"", ")", ":", "\n", "    ", "\"\"\"\n    Expand a hierarchical dict of scalars into a flat dict of scalars.\n    If results[k1][k2][k3] = v, the returned dict will have the entry\n    {\"k1/k2/k3\": v}.\n\n    Args:\n        results (dict):\n    \"\"\"", "\n", "r", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "results", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "Mapping", ")", ":", "\n", "            ", "v", "=", "flatten_dict", "(", "v", ")", "\n", "for", "kk", ",", "vv", "in", "v", ".", "items", "(", ")", ":", "\n", "                ", "r", "[", "k", "+", "delimiter", "+", "kk", "]", "=", "vv", "\n", "", "", "else", ":", "\n", "            ", "r", "[", "k", "]", "=", "v", "\n", "", "", "return", "r", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.seed_all_rng": [[28, 50], ["numpy.random.seed", "torch.set_rng_state", "random.seed", "logging.getLogger", "logging.getLogger.info", "torch.manual_seed().get_state", "int.from_bytes", "os.getpid", "int", "os.urandom", "torch.manual_seed", "datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed"], ["def", "seed_all_rng", "(", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Set the random seed for the RNG in torch, numpy and python.\n\n    Args:\n        seed (int): if None, will use a strong random seed.\n\n    Returns:\n        seed (int): The seed used.\n    \"\"\"", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "seed", "=", "(", "\n", "os", ".", "getpid", "(", ")", "\n", "+", "int", "(", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%S%f\"", ")", ")", "\n", "+", "int", ".", "from_bytes", "(", "os", ".", "urandom", "(", "2", ")", ",", "\"big\"", ")", "\n", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Using a generated random seed {}\"", ".", "format", "(", "seed", ")", ")", "\n", "", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "set_rng_state", "(", "torch", ".", "manual_seed", "(", "seed", ")", ".", "get_state", "(", ")", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "return", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env._import_file": [[53, 60], ["importlib.util.spec_from_file_location", "importlib.util.spec_from_file_location", "importlib.util.module_from_spec", "importlib.util.module_from_spec", "importlib.util.spec_from_file_location.loader.exec_module"], "function", ["None"], ["", "def", "_import_file", "(", "module_name", ",", "file_path", ",", "make_importable", "=", "False", ")", ":", "\n", "    ", "spec", "=", "importlib", ".", "util", ".", "spec_from_file_location", "(", "module_name", ",", "file_path", ")", "\n", "module", "=", "importlib", ".", "util", ".", "module_from_spec", "(", "spec", ")", "\n", "spec", ".", "loader", ".", "exec_module", "(", "module", ")", "\n", "if", "make_importable", ":", "\n", "        ", "sys", ".", "modules", "[", "module_name", "]", "=", "module", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env._configure_libraries": [[62, 83], ["int", "os.environ.get", "int", "cv2.ocl.setUseOpenCL", "cv2.__version__.split"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "_configure_libraries", "(", ")", ":", "\n", "    ", "\"\"\"\n    Configurations for some libraries.\n    \"\"\"", "\n", "# An environment option to disable `import cv2` globally,", "\n", "# in case it leads to negative performance impact", "\n", "disable_cv2", "=", "int", "(", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_DISABLE_CV2\"", ",", "False", ")", ")", "\n", "if", "disable_cv2", ":", "\n", "        ", "sys", ".", "modules", "[", "\"cv2\"", "]", "=", "None", "\n", "", "else", ":", "\n", "# Disable opencl in opencv since its interaction with cuda often", "\n", "# has negative effects", "\n", "# This envvar is supported after OpenCV 3.4.0", "\n", "        ", "os", ".", "environ", "[", "\"OPENCV_OPENCL_RUNTIME\"", "]", "=", "\"disabled\"", "\n", "try", ":", "\n", "            ", "import", "cv2", "\n", "\n", "if", "int", "(", "cv2", ".", "__version__", ".", "split", "(", "\".\"", ")", "[", "0", "]", ")", ">=", "3", ":", "\n", "                ", "cv2", ".", "ocl", ".", "setUseOpenCL", "(", "False", ")", "\n", "", "", "except", "ImportError", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.setup_environment": [[88, 108], ["env._configure_libraries", "os.environ.get", "env.setup_custom_environment"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env._configure_libraries", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.setup_custom_environment"], ["def", "setup_environment", "(", ")", ":", "\n", "    ", "\"\"\"Perform environment setup work. The default setup is a no-op, but this\n    function allows the user to specify a Python source file or a module in\n    the $MEDSEGPY_ENV_MODULE environment variable, that performs\n    custom setup work that may be necessary to their computing environment.\n    \"\"\"", "\n", "global", "_ENV_SETUP_DONE", "\n", "if", "_ENV_SETUP_DONE", ":", "\n", "        ", "return", "\n", "", "_ENV_SETUP_DONE", "=", "True", "\n", "\n", "_configure_libraries", "(", ")", "\n", "\n", "custom_module_path", "=", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_ENV_MODULE\"", ")", "\n", "\n", "if", "custom_module_path", ":", "\n", "        ", "setup_custom_environment", "(", "custom_module_path", ")", "\n", "", "else", ":", "\n", "# The default setup is a no-op", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.setup_custom_environment": [[110, 124], ["custom_module.endswith", "importlib.import_module.setup_environment", "env._import_file", "importlib.import_module", "importlib.import_module", "hasattr", "callable"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.setup_environment", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env._import_file"], ["", "", "def", "setup_custom_environment", "(", "custom_module", ")", ":", "\n", "    ", "\"\"\"\n    Load custom environment setup by importing a Python source file or a\n    module, and run the setup function.\n    \"\"\"", "\n", "if", "custom_module", ".", "endswith", "(", "\".py\"", ")", ":", "\n", "        ", "module", "=", "_import_file", "(", "\"meddlr.utils.env.custom_module\"", ",", "custom_module", ")", "\n", "", "else", ":", "\n", "        ", "module", "=", "importlib", ".", "import_module", "(", "custom_module", ")", "\n", "", "assert", "hasattr", "(", "module", ",", "\"setup_environment\"", ")", "and", "callable", "(", "module", ".", "setup_environment", ")", ",", "(", "\n", "\"Custom environment module defined in {} does not have the \"", "\n", "\"required callable attribute 'setup_environment'.\"", "\n", ")", ".", "format", "(", "custom_module", ")", "\n", "module", ".", "setup_environment", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_available_gpus": [[126, 172], ["isinstance", "subprocess.check_output().decode", "float", "ValueError", "type", "len", "subprocess.check_output", "subprocess.check_output().decode.split", "range", "enumerate", "len", "subprocess.check_output().decode().split", "len", "subprocess.check_output().decode", "subprocess.check_output"], "function", ["None"], ["", "def", "get_available_gpus", "(", "num_gpus", ":", "int", "=", "None", ")", ":", "\n", "    ", "\"\"\"Get gpu ids for gpus that are >95% free.\n\n    Tensorflow does not support checking free memory on gpus.\n    This is a crude method that relies on `nvidia-smi` to\n    determine which gpus are occupied and which are free.\n\n    Args:\n        num_gpus: Number of requested gpus. If not specified,\n            ids of all available gpu(s) are returned.\n\n    Returns:\n        List[int]: List of gpu ids that are free. Length\n            will equal `num_gpus`, if specified and gpus are available.\n            If no gpus are found, returns an empty list.\n    \"\"\"", "\n", "# Built-in tensorflow gpu id.", "\n", "assert", "isinstance", "(", "num_gpus", ",", "(", "type", "(", "None", ")", ",", "int", ")", ")", "\n", "if", "num_gpus", "==", "0", ":", "\n", "        ", "return", "[", "]", "\n", "\n", "", "num_requested_gpus", "=", "num_gpus", "\n", "try", ":", "\n", "        ", "num_gpus", "=", "(", "\n", "len", "(", "subprocess", ".", "check_output", "(", "\"nvidia-smi --list-gpus\"", ",", "shell", "=", "True", ")", ".", "decode", "(", ")", ".", "split", "(", "\"\\n\"", ")", ")", "\n", "-", "1", "\n", ")", "\n", "", "except", "subprocess", ".", "CalledProcessError", ":", "\n", "        ", "return", "[", "]", "\n", "\n", "", "out_str", "=", "subprocess", ".", "check_output", "(", "\"nvidia-smi | grep MiB\"", ",", "shell", "=", "True", ")", ".", "decode", "(", ")", "\n", "mem_str", "=", "[", "x", "for", "x", "in", "out_str", ".", "split", "(", ")", "if", "\"MiB\"", "in", "x", "]", "\n", "# First 2 * num_gpu elements correspond to memory for gpus", "\n", "# Order: (occupied-0, total-0, occupied-1, total-1, ...)", "\n", "mems", "=", "[", "float", "(", "x", "[", ":", "-", "3", "]", ")", "for", "x", "in", "mem_str", "]", "\n", "gpu_percent_occupied_mem", "=", "[", "\n", "mems", "[", "2", "*", "gpu_id", "]", "/", "mems", "[", "2", "*", "gpu_id", "+", "1", "]", "for", "gpu_id", "in", "range", "(", "num_gpus", ")", "\n", "]", "\n", "\n", "available_gpus", "=", "[", "gpu_id", "for", "gpu_id", ",", "mem", "in", "enumerate", "(", "gpu_percent_occupied_mem", ")", "if", "mem", "<", "0.05", "]", "\n", "if", "num_requested_gpus", "and", "num_requested_gpus", ">", "len", "(", "available_gpus", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Requested {} gpus, only {} are free\"", ".", "format", "(", "num_requested_gpus", ",", "len", "(", "available_gpus", ")", ")", "\n", ")", "\n", "\n", "", "return", "available_gpus", "[", ":", "num_requested_gpus", "]", "if", "num_requested_gpus", "else", "available_gpus", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size": [[174, 180], ["os.environ[].split", "len", "len"], "function", ["None"], ["", "def", "get_world_size", "(", ")", ":", "\n", "    ", "\"\"\"Returns number of gpus currently being used by this process\"\"\"", "\n", "gpu_ids", "=", "os", ".", "environ", "[", "\"CUDA_VISIBLE_DEVICES\"", "]", ".", "split", "(", "\",\"", ")", "\n", "if", "len", "(", "gpu_ids", ")", "==", "1", "and", "gpu_ids", "[", "0", "]", "==", "\"-1\"", ":", "\n", "        ", "return", "0", "\n", "", "return", "len", "(", "gpu_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.package_available": [[182, 195], ["importlib.util.find_spec", "importlib.util.find_spec"], "function", ["None"], ["", "def", "package_available", "(", "name", ":", "str", ")", ":", "\n", "    ", "\"\"\"Returns if package is available.\n\n    Args:\n        name (str): Name of the package.\n\n    Returns:\n        bool: Whether module exists in environment.\n    \"\"\"", "\n", "global", "_SUPPORTED_PACKAGES", "\n", "if", "name", "not", "in", "_SUPPORTED_PACKAGES", ":", "\n", "        ", "_SUPPORTED_PACKAGES", "[", "name", "]", "=", "importlib", ".", "util", ".", "find_spec", "(", "name", ")", "is", "not", "None", "\n", "", "return", "_SUPPORTED_PACKAGES", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_package_version": [[197, 219], ["isinstance", "importlib.util.find_spec", "importlib.util.module_from_spec", "util.find_spec.loader.exec_module", "env.package_available", "ValueError"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.package_available"], ["", "def", "get_package_version", "(", "package_or_name", ")", "->", "str", ":", "\n", "    ", "\"\"\"Returns package version.\n\n    Args:\n        package_or_name (``module`` or ``str``): Module or name of module.\n            This package must have the version accessible through ``<module>.__version__``.\n\n    Returns:\n        str: The package version.\n\n    Examples:\n        >>> get_version(\"numpy\")\n        \"1.20.0\"\n    \"\"\"", "\n", "if", "isinstance", "(", "package_or_name", ",", "str", ")", ":", "\n", "        ", "if", "not", "package_available", "(", "package_or_name", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Package {package_or_name} not available\"", ")", "\n", "", "spec", "=", "util", ".", "find_spec", "(", "package_or_name", ")", "\n", "package_or_name", "=", "util", ".", "module_from_spec", "(", "spec", ")", "\n", "spec", ".", "loader", ".", "exec_module", "(", "package_or_name", ")", "\n", "", "version", "=", "package_or_name", ".", "__version__", "\n", "return", "version", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed": [[221, 270], ["pkg_str.replace.strip", "pkg_str.replace.replace", "list", "packaging.version.Version", "pkg_str[].split", "re.finditer", "len", "env.package_available", "env.package_available", "env.get_package_version", "list", "packaging.version.Version", "dependency[].start", "re.finditer", "len", "ValueError", "comp_loc[].start", "comp_loc[].end", "dependency[].start", "comp_loc[].end"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.package_available", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.package_available", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_package_version", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.start", "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.start", "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.start"], ["", "def", "is_package_installed", "(", "pkg_str", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Verify that a package dependency is installed and in the expected version range.\n\n    This is useful for optional third-party dependencies where implementation\n    changes are not backwards-compatible.\n\n    Args:\n        pkg_str (str): The pip formatted dependency string.\n            E.g. \"numpy\", \"numpy>=1.0.0\", \"numpy>=1.0.0,<=1.10.0\", \"numpy==1.10.0\"\n\n    Returns:\n        bool: Whether dependency is satisfied.\n\n    Note:\n        This cannot resolve packages where the pip name does not match the python\n        package name. ``'-'`` characters are automatically changed to ``'_'``.\n    \"\"\"", "\n", "ops", "=", "{", "\n", "\"==\"", ":", "lambda", "x", ",", "y", ":", "x", "==", "y", ",", "\n", "\"<=\"", ":", "lambda", "x", ",", "y", ":", "x", "<=", "y", ",", "\n", "\">=\"", ":", "lambda", "x", ",", "y", ":", "x", ">=", "y", ",", "\n", "\"<\"", ":", "lambda", "x", ",", "y", ":", "x", "<", "y", ",", "\n", "\">\"", ":", "lambda", "x", ",", "y", ":", "x", ">", "y", ",", "\n", "}", "\n", "comparison_patterns", "=", "\"(==|<=|>=|>|<)\"", "\n", "\n", "pkg_str", "=", "pkg_str", ".", "strip", "(", ")", "\n", "pkg_str", "=", "pkg_str", ".", "replace", "(", "\"-\"", ",", "\"_\"", ")", "\n", "dependency", "=", "list", "(", "re", ".", "finditer", "(", "comparison_patterns", ",", "pkg_str", ")", ")", "\n", "\n", "if", "len", "(", "dependency", ")", "==", "0", ":", "\n", "        ", "return", "package_available", "(", "pkg_str", ")", "\n", "\n", "", "pkg_name", "=", "pkg_str", "[", ":", "dependency", "[", "0", "]", ".", "start", "(", ")", "]", "\n", "if", "not", "package_available", "(", "pkg_name", ")", ":", "\n", "        ", "return", "False", "\n", "\n", "", "pkg_version", "=", "version", ".", "Version", "(", "get_package_version", "(", "pkg_name", ")", ")", "\n", "version_limits", "=", "pkg_str", "[", "dependency", "[", "0", "]", ".", "start", "(", ")", ":", "]", ".", "split", "(", "\",\"", ")", "\n", "\n", "for", "vlimit", "in", "version_limits", ":", "\n", "        ", "comp_loc", "=", "list", "(", "re", ".", "finditer", "(", "comparison_patterns", ",", "vlimit", ")", ")", "\n", "if", "len", "(", "comp_loc", ")", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid version string: {pkg_str}\"", ")", "\n", "", "comp_op", "=", "vlimit", "[", "comp_loc", "[", "0", "]", ".", "start", "(", ")", ":", "comp_loc", "[", "0", "]", ".", "end", "(", ")", "]", "\n", "comp_version", "=", "version", ".", "Version", "(", "vlimit", "[", "comp_loc", "[", "0", "]", ".", "end", "(", ")", ":", "]", ")", "\n", "if", "not", "ops", "[", "comp_op", "]", "(", "pkg_version", ",", "comp_version", ")", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_debug": [[272, 274], ["os.environ.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "is_debug", "(", ")", "->", "bool", ":", "\n", "    ", "return", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_DEBUG\"", ",", "\"\"", ")", "==", "\"True\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_pt_lightning": [[276, 278], ["os.environ.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "is_pt_lightning", "(", ")", "->", "bool", ":", "\n", "    ", "return", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_PT_LIGHTNING\"", ",", "\"\"", ")", "==", "\"True\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_repro": [[280, 282], ["os.environ.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "is_repro", "(", ")", "->", "bool", ":", "\n", "    ", "return", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_REPRO\"", ",", "\"\"", ")", "==", "\"True\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_profiling_enabled": [[284, 286], ["os.environ.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "is_profiling_enabled", "(", ")", "->", "bool", ":", "\n", "    ", "return", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_PROFILE\"", ",", "\"True\"", ")", "==", "\"True\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.profile_memory": [[288, 290], ["os.environ.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "profile_memory", "(", ")", "->", "bool", ":", "\n", "    ", "return", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_MPROFILE\"", ",", "\"\"", ")", "==", "\"True\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_wandb": [[292, 294], ["env.is_debug"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_debug"], ["", "def", "supports_wandb", "(", ")", ":", "\n", "    ", "return", "\"wandb\"", "in", "sys", ".", "modules", "and", "not", "is_debug", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_d2": [[296, 299], ["None"], "function", ["None"], ["", "def", "supports_d2", "(", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Supports detectron2.\"\"\"", "\n", "return", "\"detectron2\"", "in", "sys", ".", "modules", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cupy": [[301, 308], ["env.package_available"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.package_available"], ["", "def", "supports_cupy", "(", ")", ":", "\n", "    ", "if", "\"cupy\"", "not", "in", "_SUPPORTED_PACKAGES", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "cupy", "# noqa", "\n", "", "except", "ImportError", ":", "\n", "            ", "_SUPPORTED_PACKAGES", "[", "\"cupy\"", "]", "=", "False", "\n", "", "", "return", "package_available", "(", "\"cupy\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version": [[310, 316], ["list", "_PT_VERSION.split", "version[].split", "issubclass", "dtype"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "def", "pt_version", "(", "dtype", "=", "int", ")", "->", "List", ":", "\n", "    ", "version", "=", "list", "(", "_PT_VERSION", ".", "split", "(", "\".\"", ")", ")", "\n", "version", "[", "-", "1", "]", "=", "version", "[", "-", "1", "]", ".", "split", "(", "\"+\"", ")", "[", "0", "]", "\n", "if", "not", "issubclass", "(", "dtype", ",", "str", ")", ":", "\n", "        ", "version", "=", "[", "dtype", "(", "x", ")", "for", "x", "in", "version", "]", "\n", "", "return", "version", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor": [[318, 348], ["os.environ.get", "env.pt_version", "env.pt_version", "str", "str.lower", "str.lower", "ValueError", "RuntimeError", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version"], ["", "def", "supports_cplx_tensor", "(", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Returns `True` if complex tensors supported.\n\n    This can be controlled by the environment variable\n    \"MEDDLR_ENABLE_CPLX_TENSORS\", which should be set to\n    \"True\", \"False\", or \"auto\". Defaults to \"auto\" functionality,\n    which enables complex tensors if PyTorch>=1.7.0.\n    While complex tensors were introduced in PyTorch 1.6, there were\n    known bugs. Enhanced complex tensor support offered in PyTorch >=1.7.0.\n\n    Returns:\n        bool: `True` if complex tensors are supported.\n    \"\"\"", "\n", "env_var", "=", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_ENABLE_CPLX_TENSORS\"", ",", "\"auto\"", ")", "\n", "is_min_version", "=", "pt_version", "(", ")", ">=", "[", "1", ",", "6", "]", "\n", "is_auto_version", "=", "pt_version", "(", ")", ">=", "[", "1", ",", "7", "]", "\n", "\n", "if", "env_var", "==", "\"auto\"", ":", "\n", "        ", "env_var", "=", "str", "(", "is_auto_version", ")", "\n", "\n", "", "if", "env_var", ".", "lower", "(", ")", "==", "\"false\"", ":", "\n", "        ", "return", "False", "\n", "", "elif", "env_var", ".", "lower", "(", ")", "==", "\"true\"", ":", "\n", "        ", "if", "not", "is_min_version", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"Complex tensors not supported in PyTorch {_PT_VERSION}\"", ")", "\n", "", "if", "not", "is_auto_version", ":", "\n", "            ", "warnings", ".", "warn", "(", "\"Complex tensor support has known breaking bugs for PyTorch <1.7\"", ")", "\n", "", "return", "True", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Unknown environment value: {env_var}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process": [[350, 354], ["tuple", "multiprocessing.parent_process", "multiprocessing.current_process"], "function", ["None"], ["", "", "def", "is_main_process", "(", ")", ":", "\n", "    ", "py_version", "=", "tuple", "(", "sys", ".", "version_info", "[", "0", ":", "2", "]", ")", "\n", "return", "(", "py_version", "<", "(", "3", ",", "8", ")", "and", "mp", ".", "current_process", "(", ")", ".", "name", "==", "\"MainProcess\"", ")", "or", "(", "\n", "py_version", ">=", "(", "3", ",", "8", ")", "and", "mp", ".", "parent_process", "(", ")", "is", "None", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.settings_dir": [[357, 359], ["os.environ.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "settings_dir", "(", ")", ":", "\n", "    ", "return", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_SETTINGS\"", ",", "_SETTINGS_DIR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager": [[361, 363], ["iopath.common.file_io.PathManagerFactory.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "get_path_manager", "(", "key", "=", "\"meddlr\"", ")", "->", "PathManager", ":", "\n", "    ", "return", "PathManagerFactory", ".", "get", "(", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_github_url": [[365, 367], ["None"], "function", ["None"], ["", "def", "get_github_url", "(", ")", "->", "str", ":", "\n", "    ", "return", "_GITHUB_URL", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.memory._ignore_torch_cuda_oom": [[12, 25], ["str"], "function", ["None"], ["@", "contextmanager", "\n", "def", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "    ", "\"\"\"\n    A context which ignores CUDA OOM exception from pytorch.\n    \"\"\"", "\n", "try", ":", "\n", "        ", "yield", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "# NOTE: the string may change?", "\n", "        ", "if", "\"CUDA out of memory. \"", "in", "str", "(", "e", ")", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.memory.retry_if_cuda_oom": [[27, 90], ["functools.wraps", "torch.cuda.empty_cache", "logging.getLogger", "logging.getLogger.info", "func", "x.to", "memory._ignore_torch_cuda_oom", "func", "memory._ignore_torch_cuda_oom", "func", "memory.retry_if_cuda_oom.maybe_to_cpu"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.utils.memory._ignore_torch_cuda_oom", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.utils.memory._ignore_torch_cuda_oom", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func"], ["", "", "", "def", "retry_if_cuda_oom", "(", "func", ")", ":", "\n", "    ", "\"\"\"\n    Makes a function retry itself after encountering\n    pytorch's CUDA OOM error.\n    It will first retry after calling `torch.cuda.empty_cache()`.\n\n    If that still fails, it will then retry by trying to convert inputs to CPUs.\n    In this case, it expects the function to dispatch to CPU implementation.\n    The return values may become CPU tensors as well and it's user's\n    responsibility to convert it back to CUDA tensor if needed.\n\n    Args:\n        func: a stateless callable that takes tensor-like objects as arguments\n\n    Returns:\n        a callable which retries `func` if OOM is encountered.\n\n    Examples:\n\n    .. code-block:: python\n\n        output = retry_if_cuda_oom(some_torch_function)(input1, input2)\n        # output may be on CPU even if inputs are on GPU\n\n    Note:\n        1. When converting inputs to CPU, it will only look at each argument\n           and check\n           if it has `.device` and `.to` for conversion. Nested structures of\n           tensors are not supported.\n\n        2. Since the function might be called more than once, it has to be\n           stateless.\n    \"\"\"", "\n", "\n", "def", "maybe_to_cpu", "(", "x", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "like_gpu_tensor", "=", "x", ".", "device", ".", "type", "==", "\"cuda\"", "and", "hasattr", "(", "x", ",", "\"to\"", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "like_gpu_tensor", "=", "False", "\n", "", "if", "like_gpu_tensor", ":", "\n", "            ", "return", "x", ".", "to", "(", "device", "=", "\"cpu\"", ")", "\n", "", "else", ":", "\n", "            ", "return", "x", "\n", "\n", "", "", "@", "wraps", "(", "func", ")", "\n", "def", "wrapped", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "with", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# Clear cache and retry", "\n", "", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "with", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# Try on CPU.", "\n", "# This slows down the code significantly, therefore print a notice.", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Attempting to copy inputs of {} to CPU due to CUDA OOM\"", ".", "format", "(", "str", "(", "func", ")", ")", ")", "\n", "new_args", "=", "(", "maybe_to_cpu", "(", "x", ")", "for", "x", "in", "args", ")", "\n", "new_kwargs", "=", "{", "k", ":", "maybe_to_cpu", "(", "v", ")", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "}", "\n", "return", "func", "(", "*", "new_args", ",", "**", "new_kwargs", ")", "\n", "\n", "", "return", "wrapped", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition._random_balance": [[14, 100], ["numpy.asarray", "numpy.sum", "range", "ValueError", "numpy.allclose", "ValueError", "numpy.asarray", "len", "len", "len", "len", "range", "numpy.sum", "numpy.sum", "len", "list", "numpy.random.choice", "numpy.asarray", "numpy.random.choice", "c_bin.remove", "candidate_bin.remove", "c_bin.append", "candidate_bin.append", "numpy.all", "numpy.abs", "numpy.argwhere().flatten", "numpy.argwhere().flatten", "numpy.argwhere().flatten", "numpy.argwhere().flatten", "len", "set", "numpy.random.choice", "numpy.abs", "numpy.argwhere", "numpy.argwhere", "numpy.arange", "numpy.argwhere", "numpy.argwhere", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["def", "_random_balance", "(", "\n", "bins", ":", "List", "[", "List", "[", "Any", "]", "]", ",", "\n", "expected_dist", ":", "Union", "[", "List", "[", "float", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "buffer", ":", "float", ",", "\n", "weights_dict", ":", "dict", ",", "\n", "iters", ":", "int", "=", "100", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Randomly balance bins.\n\n    Args:\n        bins (:obj:`List[List[Any]]`): Separated bins.\n        expected_dist (array-like): Expected distribution/split percentages. Must sum up to 1.\n        buffer (:obj:`float`): If bin percentages are within +/-:obj:`buffer`, the split is valid.\n        weights_dict (:obj:`dict`): Mapping from value to weight.\n        iters (:obj:`int`, optional): Number of iterations to try. Defaults to ``100``.\n\n    Returns:\n        :obj:`List[List[Any]]`: Balanced bins.\n    \"\"\"", "\n", "if", "not", "np", ".", "allclose", "(", "np", ".", "sum", "(", "expected_dist", ")", ",", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"expected_dist must sum to 1.\"", ")", "\n", "\n", "", "curr_weights", "=", "np", ".", "asarray", "(", "[", "np", ".", "sum", "(", "[", "weights_dict", "[", "elem", "]", "for", "elem", "in", "c_bin", "]", ")", "for", "c_bin", "in", "bins", "]", ")", "\n", "total_weight", "=", "np", ".", "sum", "(", "curr_weights", ")", "\n", "buffer", "=", "buffer", "*", "total_weight", "\n", "expected_dist", "=", "np", ".", "asarray", "(", "expected_dist", ")", "*", "total_weight", "\n", "\n", "assert", "len", "(", "bins", ")", "==", "len", "(", "\n", "expected_dist", "\n", ")", ",", "\"Size mismatch: {} bins, {} expected distributions\"", ".", "format", "(", "len", "(", "bins", ")", ",", "len", "(", "expected_dist", ")", ")", "\n", "\n", "for", "_", "in", "range", "(", "iters", ")", ":", "\n", "        ", "for", "c_ind", "in", "range", "(", "len", "(", "bins", ")", ")", ":", "\n", "            ", "c_bin", "=", "bins", "[", "c_ind", "]", "# current bin", "\n", "\n", "# If bin is within expected buffer range, then discount.", "\n", "delta", "=", "curr_weights", "[", "c_ind", "]", "-", "expected_dist", "[", "c_ind", "]", "\n", "if", "np", ".", "abs", "(", "delta", ")", "<=", "buffer", ":", "\n", "                ", "continue", "\n", "\n", "", "is_bin_overfilled", "=", "delta", ">", "0", "\n", "\n", "# Select candidate bin. If c_bin is overfilled (delta > 0),", "\n", "# pick an underfilled bin. And vice versa.", "\n", "candidate_indexes", "=", "(", "\n", "np", ".", "argwhere", "(", "curr_weights", "-", "expected_dist", "<", "0", ")", ".", "flatten", "(", ")", "\n", "if", "is_bin_overfilled", "\n", "else", "np", ".", "argwhere", "(", "curr_weights", "-", "expected_dist", ">", "0", ")", ".", "flatten", "(", ")", "\n", ")", "\n", "candidate_indexes", "=", "list", "(", "set", "(", "candidate_indexes", ")", "-", "{", "c_ind", "}", ")", "# exclude current bin", "\n", "candidate_ind", "=", "np", ".", "random", ".", "choice", "(", "candidate_indexes", ")", "\n", "candidate_bin", "=", "bins", "[", "candidate_ind", "]", "\n", "\n", "# Select element at random from current bin.", "\n", "c_bin_elem", "=", "c_bin", "[", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "len", "(", "c_bin", ")", ")", ")", "]", "\n", "ce_weight", "=", "weights_dict", "[", "c_bin_elem", "]", "\n", "\n", "# Select candidate element.", "\n", "# If overfilled, pick element with weight < ce_weight.", "\n", "# If underfilled, pick element with weight > ce_weight.", "\n", "# If no such candidate element is found, we continue.", "\n", "candidate_bin_weights", "=", "np", ".", "asarray", "(", "[", "weights_dict", "[", "elem", "]", "for", "elem", "in", "candidate_bin", "]", ")", "\n", "candidate_elems_idxs", "=", "(", "\n", "np", ".", "argwhere", "(", "candidate_bin_weights", "<", "ce_weight", ")", ".", "flatten", "(", ")", "\n", "if", "is_bin_overfilled", "\n", "else", "np", ".", "argwhere", "(", "candidate_bin_weights", ">", "ce_weight", ")", ".", "flatten", "(", ")", "\n", ")", "\n", "if", "len", "(", "candidate_elems_idxs", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "candidate_elem_ind", "=", "np", ".", "random", ".", "choice", "(", "candidate_elems_idxs", ")", "\n", "candidate_elem", "=", "candidate_bin", "[", "candidate_elem_ind", "]", "\n", "candidate_elem_weight", "=", "candidate_bin_weights", "[", "candidate_elem_ind", "]", "\n", "\n", "# Swap elements and adjust weights.", "\n", "c_bin", ".", "remove", "(", "c_bin_elem", ")", "\n", "candidate_bin", ".", "remove", "(", "candidate_elem", ")", "\n", "c_bin", ".", "append", "(", "candidate_elem", ")", "\n", "candidate_bin", ".", "append", "(", "c_bin_elem", ")", "\n", "\n", "curr_weights", "[", "c_ind", "]", "+=", "candidate_elem_weight", "-", "ce_weight", "\n", "curr_weights", "[", "candidate_ind", "]", "+=", "ce_weight", "-", "candidate_elem_weight", "\n", "\n", "if", "np", ".", "all", "(", "np", ".", "abs", "(", "curr_weights", "-", "expected_dist", ")", "<", "buffer", ")", ":", "\n", "                ", "return", "bins", "\n", "\n", "", "", "", "raise", "ValueError", "(", "\"Random balancing failed. Try increasing the number of iterations.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition._greedy_balance": [[102, 192], ["numpy.asarray", "numpy.sum", "numpy.allclose", "ValueError", "numpy.asarray", "sorted", "numpy.all", "numpy.argmin", "numpy.abs", "min", "enumerate", "numpy.random.choice", "of_bin.remove", "uf_bin.append", "numpy.sum", "numpy.sum", "numpy.argsort().flatten", "numpy.abs", "min", "candidate_elems.append", "numpy.argsort"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "_greedy_balance", "(", "\n", "bins", ":", "List", "[", "List", "[", "Any", "]", "]", ",", "\n", "expected_dist", ":", "Union", "[", "List", "[", "float", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "buffer", ":", "float", ",", "\n", "weights_dict", ":", "dict", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Greedily balance bins.\n\n    Fills the most underfilled bin from most overfilled bin at each iteration.\n\n    Args:\n        bins (:obj:`List[List[Any]]`): Separated bins.\n        expected_dist (array-like): Expected distribution/split percentages. Must sum up to 1.\n        buffer (:obj:`float`): If bin percentages are within +/-:obj:`buffer`, the split is valid.\n        weights_dict (:obj:`dict`): Mapping from value to weight.\n\n    Returns:\n        :obj:`List[List[Any]]`: Balanced bins.\n    \"\"\"", "\n", "if", "not", "np", ".", "allclose", "(", "np", ".", "sum", "(", "expected_dist", ")", ",", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"expected_dist must sum to 1.\"", ")", "\n", "\n", "", "curr_weights", "=", "np", ".", "asarray", "(", "[", "np", ".", "sum", "(", "[", "weights_dict", "[", "elem", "]", "for", "elem", "in", "c_bin", "]", ")", "for", "c_bin", "in", "bins", "]", ")", "\n", "total_weight", "=", "np", ".", "sum", "(", "curr_weights", ")", "\n", "buffer", "=", "buffer", "*", "total_weight", "\n", "expected_dist", "=", "np", ".", "asarray", "(", "expected_dist", ")", "*", "total_weight", "\n", "\n", "# Sort elements in bins in ascending order of weight.", "\n", "# First element will always have the lowest weight among all elements in the bin.", "\n", "sorted_bins", "=", "[", "\n", "sorted", "(", "[", "(", "val", ",", "weights_dict", "[", "val", "]", ")", "for", "val", "in", "c_bin", "]", ",", "key", "=", "lambda", "x", ":", "x", "[", "-", "1", "]", ")", "for", "c_bin", "in", "bins", "\n", "]", "\n", "bins", "=", "[", "[", "val", "for", "val", ",", "_", "in", "x", "]", "for", "x", "in", "sorted_bins", "]", "\n", "\n", "# Create list of { -> num elements with weight}.", "\n", "while", "True", ":", "\n", "        ", "deltas", "=", "curr_weights", "-", "expected_dist", "\n", "if", "np", ".", "all", "(", "np", ".", "abs", "(", "deltas", ")", "<", "buffer", ")", ":", "\n", "            ", "break", "\n", "\n", "# Select the most underfilled bin and the delta weight.", "\n", "", "uf_bin_ind", "=", "np", ".", "argmin", "(", "deltas", ")", "# index of most underfilled bin.", "\n", "uf_bin", "=", "bins", "[", "uf_bin_ind", "]", "\n", "uf_delta_mag", "=", "np", ".", "abs", "(", "deltas", "[", "uf_bin_ind", "]", ")", "\n", "\n", "# Select most overfilled bin that has at least one element.", "\n", "# An overfilled bin has a positive delta.", "\n", "of_bin_ind", "=", "-", "1", "\n", "for", "ind", "in", "np", ".", "argsort", "(", "deltas", ")", ".", "flatten", "(", ")", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "c_delta", "=", "deltas", "[", "ind", "]", "\n", "if", "c_delta", "<=", "0", ":", "\n", "                ", "break", "\n", "\n", "# Check if there is at least one element with a weight <= min(c_delta, uf_delta_mag).", "\n", "", "if", "weights_dict", "[", "bins", "[", "ind", "]", "[", "0", "]", "]", "<=", "min", "(", "c_delta", ",", "uf_delta_mag", ")", ":", "\n", "                ", "of_bin_ind", "=", "ind", "\n", "break", "\n", "\n", "", "", "if", "of_bin_ind", "==", "-", "1", ":", "\n", "            ", "break", "\n", "\n", "", "assert", "of_bin_ind", "!=", "uf_bin_ind", ",", "\"Bin cannot be both overfilled and underfilled\"", "\n", "max_weight", "=", "min", "(", "uf_delta_mag", ",", "deltas", "[", "of_bin_ind", "]", ")", "\n", "of_bin", "=", "bins", "[", "of_bin_ind", "]", "\n", "\n", "# Select the element greedily from the overfilled bin", "\n", "# that has a weight <= abs(delta[uf_bin]).", "\n", "candidate_elems", "=", "[", "]", "\n", "candidate_weight", "=", "0", "\n", "for", "ind", ",", "elem", "in", "enumerate", "(", "of_bin", ")", ":", "# noqa: B007", "\n", "            ", "e_weight", "=", "weights_dict", "[", "elem", "]", "\n", "if", "e_weight", ">", "max_weight", "or", "e_weight", "<", "candidate_weight", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "e_weight", "==", "candidate_weight", ":", "\n", "                ", "candidate_elems", ".", "append", "(", "elem", ")", "\n", "", "elif", "e_weight", ">", "candidate_weight", ":", "\n", "                ", "candidate_weight", "=", "e_weight", "\n", "candidate_elems", "=", "[", "elem", "]", "\n", "\n", "", "", "candidate_elem", "=", "np", ".", "random", ".", "choice", "(", "candidate_elems", ")", "\n", "\n", "# Move candidate element to underfilled bin.", "\n", "of_bin", ".", "remove", "(", "candidate_elem", ")", "\n", "uf_bin", ".", "append", "(", "candidate_elem", ")", "\n", "\n", "curr_weights", "[", "uf_bin_ind", "]", "+=", "candidate_weight", "\n", "curr_weights", "[", "of_bin_ind", "]", "-=", "candidate_weight", "\n", "\n", "", "return", "bins", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition.approximately_split_weighted": [[194, 333], ["numpy.asarray", "len", "numpy.sum", "numpy.asarray", "list", "numpy.ceil", "numpy.arange", "numpy.random.shuffle", "numpy.cumsum", "all", "numpy.allclose", "ValueError", "len", "len", "ValueError", "ValueError", "numpy.ones", "numpy.cumsum", "numpy.random.get_state", "numpy.random.seed", "_random_balance.append", "numpy.sum", "len", "len", "numpy.random.set_state", "numpy.sum", "set", "isinstance", "TypeError", "len", "ValueError", "isinstance", "numpy.asarray", "ValueError", "numpy.max", "list", "data_partition._greedy_balance", "len", "numpy.argwhere", "zip", "data_partition._random_balance", "len", "len", "range", "range", "len", "len", "len", "set", "set"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition._greedy_balance", "home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition._random_balance", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "def", "approximately_split_weighted", "(", "\n", "values", ":", "List", "[", "Any", "]", ",", "\n", "split_percentages", ":", "List", "[", "float", "]", ",", "\n", "weights", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "balance", ":", "str", "=", "None", ",", "\n", "buffer", ":", "float", "=", "0.01", ",", "\n", "num_iters", ":", "int", "=", "100", ",", "\n", "seed", ":", "int", "=", "None", ",", "\n", ")", "->", "List", "[", "List", "[", "Any", "]", "]", ":", "\n", "    ", "\"\"\"Approximately split values into different bins.\n\n    This function should be used to split :obj:`values` into N disjoint sets.\n    This is useful for applications in machine learning where dataset splits\n    should be disjoint.\n\n    In certain cases, values will not have uniform weights. For example, consider\n    the case where there are frames extracted from 3 videos: video A- 10 frames,\n    video B- 5 frames, video C- 2 frames. In this case, we would like to keep frames\n    sampled from the same video within a specific set. For example, frames from video A\n    cannot be in both bin 1 and bin 2. The :obj:`weights` attribute can be specified to\n    keep the videos separate:\n\n    >>> approximately_split(values=[\"videoA\", \"videoB\", \"videoC\"], weights=[10, 5, 2], ...)\n\n    In these cases, because of the randomness of splits, we may end up with a\n    lop-sided split. Let's consider the example above, where the\n    ``split_percentages=[0.3, 0.7]``. Assume after random shuffling values are in the order\n    ``[\"videoA\", \"videoB\", \"videoC\"]``. In this case, no value will be assigned to the first\n    bin. Balancing will allow bins to randomly or greedily reconfigure into an appropriate.\n    This method is not guaranteed to converge.\n\n    In random balancing, entries between overfilled and underfilled bins are pseudo-randomly\n    swapped. Bins are sequentially selected. If the current bin is overfilled, a candidate bin\n    that is underfilled is selected at random. If the current bin is underfilled, a candidate\n    bin that is overfilled is selected. Then an element from the overfilled bin with a weight\n    greater than that of the other element is randomly selected and the two elements are\n    swapped. This is repeated at most :obj:`iter` times or until bin is within buffer.\n\n    In greedy balancing, the bin that is most underfilled is filled greedily\n    iteratively from overfilled bins just enough so that it meets the buffer criteria.\n    To fill the underfilled bin to as close to its size, set :obj:`buffer=0`.\n\n    TODO: Write unit test.\n\n    Args:\n        values (:obj:`List[Any]`): A list of values that should be divided into different groups.\n        split_percentages (:obj:`List[float]`): The approximate percent split between datasets.\n            Must add up to 1.\n        weights (:obj:`List[int]`, optional): Weights for each value in :obj:`values`.\n            Use if certain values have a larger weight than others (i.e. more examples\n            associated with value). Defaults to weight of 1 per each value in :obj:`values`.\n        balance (:obj:`str`, optional): Balance weighting after partition.\n            Options: `\"greedy\"`, `\"random\"`. Use with :obj:`weights`. Defaults to ``None``.\n        buffer (:obj:`float`, optional): If bin percentages are within +/-:obj:`buffer`,\n            the split is valid. Defaults to 0.01 (+/-1%).\n        num_iters (:obj:`int`, optional): Number of iterations for random balancing.\n            Defaults to ``100``.\n\n    Returns:\n        List[List[Any]]: A list of splits of values.\n    \"\"\"", "\n", "if", "not", "np", ".", "allclose", "(", "np", ".", "sum", "(", "split_percentages", ")", ",", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"split_percentages must sum to 1.\"", ")", "\n", "\n", "", "if", "len", "(", "set", "(", "values", ")", ")", "!=", "len", "(", "values", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Values must be distinct\"", ")", "\n", "\n", "", "if", "balance", "not", "in", "[", "None", ",", "\"greedy\"", ",", "\"random\"", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"Balance {} not supported\"", ".", "format", "(", "balance", ")", ")", "\n", "\n", "", "values", "=", "np", ".", "asarray", "(", "values", ")", "\n", "num_values", "=", "len", "(", "values", ")", "\n", "\n", "use_weights", "=", "False", "\n", "if", "weights", ":", "\n", "        ", "if", "not", "isinstance", "(", "weights", ",", "(", "list", ",", "tuple", ",", "np", ".", "ndarray", ")", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"weights must be a list, tuple, or np.ndarray\"", ")", "\n", "", "if", "len", "(", "weights", ")", "!=", "num_values", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"{} weights found, but {} values provided\"", ".", "format", "(", "len", "(", "weights", ")", ",", "num_values", ")", "\n", ")", "\n", "", "if", "not", "isinstance", "(", "weights", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "weights", "=", "np", ".", "asarray", "(", "weights", ")", "\n", "", "if", "weights", ".", "ndim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"weights must be 1D\"", ")", "\n", "", "use_weights", "=", "True", "\n", "", "else", ":", "\n", "        ", "weights", "=", "np", ".", "ones", "(", "num_values", ")", "\n", "\n", "", "total_weight", "=", "np", ".", "sum", "(", "weights", ")", "\n", "\n", "split_percentages", "=", "np", ".", "asarray", "(", "split_percentages", ")", "\n", "boundaries", "=", "list", "(", "np", ".", "cumsum", "(", "split_percentages", "*", "total_weight", ")", ")", "\n", "boundaries", "[", "-", "1", "]", "=", "np", ".", "ceil", "(", "boundaries", "[", "-", "1", "]", ")", "\n", "\n", "if", "seed", "is", "not", "None", ":", "\n", "        ", "rand_state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "", "shuffled_inds", "=", "np", ".", "arange", "(", "num_values", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "shuffled_inds", ")", "\n", "values", "=", "values", "[", "shuffled_inds", "]", "\n", "weights", "=", "weights", "[", "shuffled_inds", "]", "\n", "cum_weights", "=", "np", ".", "cumsum", "(", "weights", ")", "\n", "\n", "start_ind", "=", "0", "\n", "\n", "outputs", "=", "[", "]", "\n", "for", "bnd", "in", "boundaries", ":", "\n", "        ", "end_ind", "=", "np", ".", "max", "(", "np", ".", "argwhere", "(", "cum_weights", "-", "bnd", "<=", "0", ")", ")", "+", "1", "\n", "outputs", ".", "append", "(", "list", "(", "values", "[", "start_ind", ":", "end_ind", "]", ")", ")", "\n", "start_ind", "=", "end_ind", "\n", "\n", "", "if", "use_weights", "and", "balance", ":", "\n", "        ", "weights_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "values", ",", "weights", ")", "}", "\n", "if", "balance", "==", "\"greedy\"", ":", "\n", "            ", "outputs", "=", "_greedy_balance", "(", "outputs", ",", "split_percentages", ",", "buffer", ",", "weights_dict", ")", "\n", "", "elif", "balance", "==", "\"random\"", ":", "\n", "            ", "outputs", "=", "_random_balance", "(", "outputs", ",", "split_percentages", ",", "buffer", ",", "weights_dict", ",", "num_iters", ")", "\n", "", "else", ":", "\n", "            ", "assert", "False", ",", "\"Should never reach here.\"", "\n", "\n", "", "", "assert", "np", ".", "sum", "(", "[", "len", "(", "x", ")", "for", "x", "in", "outputs", "]", ")", "==", "num_values", "\n", "assert", "len", "(", "outputs", ")", "==", "len", "(", "split_percentages", ")", "\n", "assert", "all", "(", "\n", "[", "\n", "len", "(", "set", "(", "outputs", "[", "i", "]", ")", "&", "set", "(", "outputs", "[", "j", "]", ")", ")", "==", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "outputs", ")", ")", "\n", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "outputs", ")", ")", "\n", "]", "\n", ")", "\n", "\n", "for", "x", "in", "outputs", ":", "\n", "        ", "assert", "len", "(", "x", ")", ">", "0", "\n", "\n", "", "if", "seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "set_state", "(", "rand_state", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition.approximately_split": [[335, 377], ["copy.deepcopy", "len", "numpy.asarray", "list", "numpy.ceil", "numpy.ceil", "random.shuffle", "zip", "numpy.allclose", "ValueError", "numpy.cumsum", "int", "outputs.append", "numpy.sum", "len", "len", "numpy.sum", "numpy.floor", "len", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "def", "approximately_split", "(", "values", ":", "List", "[", "Any", "]", ",", "split_percentages", ":", "List", "[", "float", "]", ")", "->", "List", "[", "List", "[", "Any", "]", "]", ":", "\n", "    ", "\"\"\"Approximately split values into different bins.\n\n    TODO: Deprecate once unit test is written for approximately_split_weighted.\n\n    Args:\n        values (:obj:`List[Any]`): A list of values that should be divided into different groups.\n        split_percentages (:obj:`List[float]`): The approximate percent split between datasets.\n            Must add up to 1.\n\n    Returns:\n        List[List[Any]]: A list of splits of values.\n    \"\"\"", "\n", "if", "not", "np", ".", "allclose", "(", "np", ".", "sum", "(", "split_percentages", ")", ",", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"split_percentages must sum to 1.\"", ")", "\n", "\n", "", "values", "=", "deepcopy", "(", "values", ")", "\n", "\n", "num_values", "=", "len", "(", "values", ")", "\n", "split_percentages", "=", "np", ".", "asarray", "(", "split_percentages", ")", "\n", "boundaries", "=", "list", "(", "np", ".", "cumsum", "(", "split_percentages", "*", "num_values", ")", ")", "\n", "boundaries", "[", "0", "]", "=", "np", ".", "ceil", "(", "boundaries", "[", "0", "]", ")", "\n", "boundaries", "[", "-", "1", "]", "=", "np", ".", "ceil", "(", "boundaries", "[", "-", "1", "]", ")", "\n", "\n", "random", ".", "shuffle", "(", "values", ")", "\n", "start_ind", "=", "0", "\n", "\n", "outputs", "=", "[", "]", "\n", "for", "end_ind_f", "in", "boundaries", ":", "\n", "# Round such that .5 always rounds up.", "\n", "        ", "end_ind", "=", "int", "(", "np", ".", "floor", "(", "end_ind_f", "+", "0.5", ")", ")", "\n", "outputs", ".", "append", "(", "values", "[", "start_ind", ":", "end_ind", "]", ")", "\n", "start_ind", "=", "end_ind", "\n", "\n", "", "assert", "np", ".", "sum", "(", "[", "len", "(", "x", ")", "for", "x", "in", "outputs", "]", ")", "==", "num_values", "\n", "assert", "len", "(", "outputs", ")", "==", "len", "(", "split_percentages", ")", "\n", "\n", "for", "x", ",", "per", "in", "zip", "(", "outputs", ",", "split_percentages", ")", ":", "\n", "        ", "if", "per", ">", "0", ":", "\n", "            ", "assert", "len", "(", "x", ")", ">", "0", "\n", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition.write_split": [[379, 403], ["range", "os.path.isdir", "os.makedirs", "len", "os.path.join", "logging.info", "open", "f.write", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write"], ["", "def", "write_split", "(", "train_split", ",", "val_split", ",", "test_split", ",", "save_path", ")", ":", "\n", "    ", "\"\"\"Write files in given splits to directory.\n\n    Args:\n        train_split (:obj:`List[str]`): Training files.\n        val_split (:obj:`List[str]`): Validation files.\n        test_split (:obj:`List[str]`): Test Files.\n        save_path (str): Directory to save partitions.\n    \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_path", ")", "\n", "\n", "", "outputs", "=", "[", "train_split", ",", "val_split", ",", "test_split", "]", "\n", "\n", "# Write partition folders per dataset to text file.", "\n", "dataset_suffixes", "=", "[", "\"train\"", ",", "\"val\"", ",", "\"test\"", "]", "\n", "filenames", "=", "[", "\"%s.txt\"", "%", "x", "for", "x", "in", "dataset_suffixes", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "outputs", ")", ")", ":", "\n", "        ", "fpath", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "filenames", "[", "i", "]", ")", "\n", "logging", ".", "info", "(", "\"Writing %d partitions to %s.\"", "%", "(", "len", "(", "outputs", "[", "i", "]", ")", ",", "fpath", ")", ")", "\n", "\n", "with", "open", "(", "fpath", ",", "\"w+\"", ")", "as", "f", ":", "\n", "            ", "for", "partition_folder", "in", "outputs", "[", "i", "]", ":", "\n", "                ", "f", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "partition_folder", ")", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.fftc.ifftnc": [[8, 12], ["fft.fftshift", "fft.ifftn", "fft.ifftshift"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift"], ["", "def", "ifftnc", "(", "x", ",", "axes", ",", "ortho", "=", "True", ")", ":", "\n", "    ", "tmp", "=", "fft", ".", "fftshift", "(", "x", ",", "axes", "=", "axes", ")", "\n", "tmp", "=", "fft", ".", "ifftn", "(", "tmp", ",", "axes", "=", "axes", ",", "norm", "=", "\"ortho\"", "if", "ortho", "else", "None", ")", "\n", "return", "fft", ".", "ifftshift", "(", "tmp", ",", "axes", "=", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.fftc.fftnc": [[14, 18], ["fft.fftshift", "fft.fftn", "fft.ifftshift"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift"], ["", "def", "fftnc", "(", "x", ",", "axes", ",", "ortho", "=", "True", ")", ":", "\n", "    ", "tmp", "=", "fft", ".", "fftshift", "(", "x", ",", "axes", "=", "axes", ")", "\n", "tmp", "=", "fft", ".", "fftn", "(", "tmp", ",", "axes", "=", "axes", ",", "norm", "=", "\"ortho\"", "if", "ortho", "else", "None", ")", "\n", "return", "fft", ".", "ifftshift", "(", "tmp", ",", "axes", "=", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.fftc.fftc": [[20, 22], ["fftc.fftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftnc"], ["", "def", "fftc", "(", "x", ",", "axis", "=", "0", ",", "ortho", "=", "True", ")", ":", "\n", "    ", "return", "fftnc", "(", "x", ",", "(", "axis", ",", ")", ",", "ortho", "=", "ortho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.fftc.ifftc": [[24, 26], ["fftc.ifftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftnc"], ["", "def", "ifftc", "(", "x", ",", "axis", "=", "0", ",", "ortho", "=", "True", ")", ":", "\n", "    ", "return", "ifftnc", "(", "x", ",", "(", "axis", ",", ")", ",", "ortho", "=", "ortho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.fftc.fft2c": [[28, 30], ["fftc.fftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftnc"], ["", "def", "fft2c", "(", "x", ",", "ortho", "=", "True", ")", ":", "\n", "    ", "return", "fftnc", "(", "x", ",", "(", "-", "2", ",", "-", "1", ")", ",", "ortho", "=", "ortho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.fftc.ifft2c": [[32, 34], ["fftc.ifftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftnc"], ["", "def", "ifft2c", "(", "x", ",", "ortho", "=", "True", ")", ":", "\n", "    ", "return", "ifftnc", "(", "x", ",", "(", "-", "2", ",", "-", "1", ")", ",", "ortho", "=", "ortho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.fftc.fft3c": [[36, 38], ["fftc.fftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftnc"], ["", "def", "fft3c", "(", "x", ",", "ortho", "=", "True", ")", ":", "\n", "    ", "return", "fftnc", "(", "x", ",", "(", "-", "3", ",", "-", "2", ",", "-", "1", ")", ",", "ortho", "=", "ortho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.fftc.ifft3c": [[40, 42], ["fftc.ifftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftnc"], ["", "def", "ifft3c", "(", "x", ",", "ortho", "=", "True", ")", ":", "\n", "    ", "return", "ifftnc", "(", "x", ",", "(", "-", "3", ",", "-", "2", ",", "-", "1", ")", ",", "ortho", "=", "ortho", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_transforms.TestFFT.test_fft2_cplx_tensors": [[10, 19], ["unittest.skipIf", "torch.Generator().manual_seed", "torch.rand", "meddlr.fft2", "meddlr.fft2", "torch.allclose", "torch.view_as_complex", "torch.view_as_real", "meddlr.utils.env.pt_version", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version"], ["    ", "@", "unittest", ".", "skipIf", "(", "env", ".", "pt_version", "(", ")", ">=", "[", "1", ",", "8", "]", ",", "\"torch.fft not supported in torch>=1.8\"", ")", "\n", "def", "test_fft2_cplx_tensors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test fft2 with PyTorch>=1.7 complex tensor support.\"\"\"", "\n", "g", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "1", ")", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "8", ",", "2", ",", "generator", "=", "g", ")", "# B x H x W x #coils x 2", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "X2", "=", "T", ".", "fft2", "(", "torch", ".", "view_as_complex", "(", "x", ")", ")", "# B x H x W x #coils", "\n", "\n", "assert", "torch", ".", "allclose", "(", "torch", ".", "view_as_real", "(", "X2", ")", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_transforms.TestFFT.test_ifft2_cplx_tensors": [[20, 38], ["unittest.skipIf", "torch.Generator().manual_seed", "torch.rand", "meddlr.fft2", "torch.view_as_complex", "meddlr.ifft2", "meddlr.ifft2", "torch.allclose", "torch.view_as_real", "torch.max", "meddlr.utils.env.pt_version", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version"], ["", "@", "unittest", ".", "skipIf", "(", "env", ".", "pt_version", "(", ")", ">=", "[", "1", ",", "8", "]", ",", "\"torch.fft not supported in torch>=1.8\"", ")", "\n", "def", "test_ifft2_cplx_tensors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test ifft2 with PyTorch>=1.7 complex tensor support.\"\"\"", "\n", "g", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "1", ")", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "8", ",", "2", ",", "generator", "=", "g", ")", "# B x H x W x #coils x 2", "\n", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "X2", "=", "torch", ".", "view_as_complex", "(", "X", ")", "# B x H x W x #coils", "\n", "\n", "xhat", "=", "T", ".", "ifft2", "(", "X", ")", "\n", "xhat2", "=", "T", ".", "ifft2", "(", "X2", ")", "\n", "assert", "torch", ".", "allclose", "(", "torch", ".", "view_as_real", "(", "xhat2", ")", ",", "xhat", ")", "\n", "# torch.allclose causes some issues with the comparison below", "\n", "# on certain machines. However, the maximum deviation between", "\n", "# the two tensors is the same across machines where torch.allclose", "\n", "# works and doesn't work. We compare the maximum of the difference", "\n", "# instead to get around this issue.", "\n", "assert", "torch", ".", "max", "(", "x", "-", "xhat", ")", "<", "1e-7", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_cluster.TestCluster.test_basic": [[11, 27], ["meddlr.utils.cluster.Cluster", "socket.gethostname", "os.path.expanduser", "socket.gethostname"], "methods", ["None"], ["    ", "def", "test_basic", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test basic cluster creation.\"\"\"", "\n", "cluster", "=", "Cluster", "(", ")", "\n", "\n", "assert", "cluster", ".", "name", "==", "socket", ".", "gethostname", "(", ")", "\n", "assert", "cluster", ".", "patterns", "==", "[", "socket", ".", "gethostname", "(", ")", "]", "\n", "\n", "assert", "cluster", ".", "_data_dir", "is", "None", "\n", "assert", "cluster", ".", "_results_dir", "is", "None", "\n", "assert", "cluster", ".", "_cache_dir", "is", "None", "\n", "assert", "cluster", ".", "_cfg_kwargs", "==", "{", "}", "\n", "\n", "assert", "cluster", ".", "data_dir", "==", "\"./datasets\"", "\n", "assert", "cluster", ".", "datasets_dir", "==", "cluster", ".", "data_dir", "\n", "assert", "cluster", ".", "results_dir", "==", "\"./results\"", "\n", "assert", "cluster", ".", "cache_dir", "==", "os", ".", "path", ".", "expanduser", "(", "\"~/.cache/meddlr\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_cluster.TestCluster.test_set": [[28, 39], ["meddlr.utils.cluster.Cluster", "meddlr.utils.cluster.Cluster.set", "meddlr.utils.cluster.Cluster.set"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "def", "test_set", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test setting configuration properties.\"\"\"", "\n", "cluster", "=", "Cluster", "(", ")", "\n", "\n", "cluster", ".", "set", "(", "data_dir", "=", "\"my-data\"", ",", "results_dir", "=", "\"my-results\"", ",", "cache_dir", "=", "\"my-cache\"", ")", "\n", "assert", "cluster", ".", "data_dir", "==", "\"my-data\"", "\n", "assert", "cluster", ".", "results_dir", "==", "\"my-results\"", "\n", "assert", "cluster", ".", "cache_dir", "==", "\"my-cache\"", "\n", "\n", "cluster", ".", "set", "(", "foo", "=", "\"bar\"", ")", "\n", "assert", "cluster", ".", "foo", "==", "\"bar\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_cluster.TestCluster.test_environment_variables": [[40, 52], ["meddlr.utils.cluster.Cluster", "meddlr.utils.cluster.Cluster.set"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "@", "temp_env", "\n", "def", "test_environment_variables", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test that environment variables are overrides for cluster configurations.\"\"\"", "\n", "cluster", "=", "Cluster", "(", ")", "\n", "\n", "cluster", ".", "set", "(", "data_dir", "=", "\"my-data\"", ",", "results_dir", "=", "\"my-results\"", ",", "cache_dir", "=", "\"my-cache\"", ")", "\n", "assert", "cluster", ".", "data_dir", "==", "\"my-data\"", "\n", "assert", "cluster", ".", "results_dir", "==", "\"my-results\"", "\n", "assert", "cluster", ".", "cache_dir", "==", "\"my-cache\"", "\n", "\n", "os", ".", "environ", "[", "\"MEDDLR_DATASETS_DIR\"", "]", "=", "\"foo-bar\"", "\n", "assert", "cluster", ".", "data_dir", "==", "\"foo-bar\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_cluster.TestCluster.test_peristence": [[53, 76], ["meddlr.utils.cluster.Cluster", "meddlr.utils.cluster.Cluster.set", "meddlr.utils.cluster.Cluster.save", "meddlr.utils.cluster.Cluster.from_config", "meddlr.utils.cluster.Cluster.delete", "test_cluster.TestCluster.assertRaises", "meddlr.utils.cluster.Cluster.from_config"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.save", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.from_config", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.delete", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.from_config"], ["", "def", "test_peristence", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test that cluster configuration can be persisted (saved, loaded, deleted).\n\n        Note:\n            This test is not thread-safe. Please do not run multiple instances of\n            this test simultaneously with multiprocessing.\n        \"\"\"", "\n", "name", "=", "\"test-foobar\"", "\n", "cluster", "=", "Cluster", "(", "name", "=", "name", ")", "\n", "\n", "cluster", ".", "set", "(", "data_dir", "=", "\"my-data\"", ",", "results_dir", "=", "\"my-results\"", ",", "cache_dir", "=", "\"my-cache\"", ")", "\n", "\n", "cluster", ".", "save", "(", ")", "\n", "cluster2", "=", "cluster", ".", "from_config", "(", "name", ")", "\n", "assert", "cluster2", "is", "not", "cluster", "\n", "assert", "cluster2", ".", "data_dir", "==", "\"my-data\"", "\n", "assert", "cluster2", ".", "results_dir", "==", "\"my-results\"", "\n", "assert", "cluster2", ".", "cache_dir", "==", "\"my-cache\"", "\n", "\n", "cluster", ".", "delete", "(", ")", "\n", "with", "self", ".", "assertRaises", "(", "KeyError", ")", ":", "\n", "# Once deleted the cluster should not be found.", "\n", "            ", "cluster2", "=", "cluster", ".", "from_config", "(", "name", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_env.TestEnvVariables.setUpClass": [[10, 13], ["dict"], "methods", ["None"], ["@", "classmethod", "\n", "def", "setUpClass", "(", "cls", ")", ":", "\n", "        ", "cls", ".", "_env", "=", "dict", "(", "os", ".", "environ", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_env.TestEnvVariables.tearDownClass": [[14, 18], ["os.environ.clear", "os.environ.update"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "@", "classmethod", "\n", "def", "tearDownClass", "(", "cls", ")", ":", "\n", "        ", "os", ".", "environ", ".", "clear", "(", ")", "\n", "os", ".", "environ", ".", "update", "(", "cls", ".", "_env", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_env.TestEnvVariables._reset_var": [[19, 28], ["os.environ.pop"], "methods", ["None"], ["", "def", "_reset_var", "(", "self", ",", "env_var", ",", "value", ",", "force", "=", "False", ")", ":", "\n", "        ", "if", "force", ":", "\n", "            ", "os", ".", "environ", "[", "env_var", "]", "=", "value", "\n", "return", "\n", "\n", "", "if", "value", "==", "\"\"", ":", "\n", "            ", "os", ".", "environ", ".", "pop", "(", "env_var", ",", "None", ")", "\n", "", "else", ":", "\n", "            ", "os", ".", "environ", "[", "env_var", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_env.TestEnvVariables.test_supports_cplx_tensors": [[29, 57], ["os.environ.get", "test_env.TestEnvVariables._reset_var", "meddlr.utils.env.pt_version", "meddlr.utils.env.supports_cplx_tensor", "meddlr.utils.env.pt_version", "meddlr.utils.env.supports_cplx_tensor", "meddlr.utils.env.supports_cplx_tensor", "meddlr.utils.env.supports_cplx_tensor", "meddlr.utils.env.supports_cplx_tensor", "test_env.TestEnvVariables.assertRaises", "meddlr.utils.env.supports_cplx_tensor"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_var", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor"], ["", "", "def", "test_supports_cplx_tensors", "(", "self", ")", ":", "\n", "        ", "env_var", "=", "\"MEDDLR_ENABLE_CPLX_TENSORS\"", "\n", "orig_val", "=", "os", ".", "environ", ".", "get", "(", "env_var", ",", "\"\"", ")", "\n", "is_pt17", "=", "env", ".", "pt_version", "(", ")", ">=", "[", "1", ",", "7", "]", "\n", "\n", "# auto", "\n", "os", ".", "environ", "[", "env_var", "]", "=", "\"auto\"", "\n", "if", "is_pt17", ":", "\n", "            ", "assert", "env", ".", "supports_cplx_tensor", "(", ")", "\n", "", "else", ":", "\n", "            ", "assert", "not", "env", ".", "supports_cplx_tensor", "(", ")", "\n", "\n", "# True", "\n", "", "os", ".", "environ", "[", "env_var", "]", "=", "\"True\"", "\n", "is_pt16", "=", "env", ".", "pt_version", "(", ")", ">=", "[", "1", ",", "6", "]", "\n", "if", "is_pt17", ":", "\n", "            ", "assert", "env", ".", "supports_cplx_tensor", "(", ")", "\n", "", "elif", "is_pt16", ":", "\n", "            ", "assert", "env", ".", "supports_cplx_tensor", "(", ")", "\n", "", "else", ":", "\n", "            ", "with", "self", ".", "assertRaises", "(", "RuntimeError", ")", ":", "\n", "                ", "env", ".", "supports_cplx_tensor", "(", ")", "\n", "\n", "# False", "\n", "", "", "os", ".", "environ", "[", "env_var", "]", "=", "\"False\"", "\n", "assert", "not", "env", ".", "supports_cplx_tensor", "(", ")", "\n", "\n", "self", ".", "_reset_var", "(", "env_var", ",", "orig_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_env.TestEnvVariables.test_debug": [[58, 69], ["os.environ.get", "meddlr.utils.env.is_debug", "test_env.TestEnvVariables._reset_var", "meddlr.utils.env.is_debug"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_debug", "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_var", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_debug"], ["", "def", "test_debug", "(", "self", ")", ":", "\n", "        ", "env_var", "=", "\"MEDDLR_DEBUG\"", "\n", "orig_val", "=", "os", ".", "environ", ".", "get", "(", "env_var", ",", "\"\"", ")", "\n", "\n", "os", ".", "environ", "[", "env_var", "]", "=", "\"\"", "\n", "assert", "not", "env", ".", "is_debug", "(", ")", "\n", "\n", "os", ".", "environ", "[", "env_var", "]", "=", "\"True\"", "\n", "assert", "env", ".", "is_debug", "(", ")", "\n", "\n", "self", ".", "_reset_var", "(", "env_var", ",", "orig_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_env.TestEnvVariables.test_reproducibility_mode": [[70, 81], ["os.environ.get", "meddlr.utils.env.is_repro", "test_env.TestEnvVariables._reset_var", "meddlr.utils.env.is_repro"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_repro", "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_var", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_repro"], ["", "def", "test_reproducibility_mode", "(", "self", ")", ":", "\n", "        ", "env_var", "=", "\"MEDDLR_REPRO\"", "\n", "orig_val", "=", "os", ".", "environ", ".", "get", "(", "env_var", ",", "\"\"", ")", "\n", "\n", "os", ".", "environ", "[", "env_var", "]", "=", "\"\"", "\n", "assert", "not", "env", ".", "is_repro", "(", ")", "\n", "\n", "os", ".", "environ", "[", "env_var", "]", "=", "\"True\"", "\n", "assert", "env", ".", "is_repro", "(", ")", "\n", "\n", "self", ".", "_reset_var", "(", "env_var", ",", "orig_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_env.test_is_package_installed": [[83, 93], ["meddlr.utils.env.is_package_installed", "meddlr.utils.env.is_package_installed", "meddlr.utils.env.is_package_installed", "meddlr.utils.env.get_package_version", "meddlr.utils.env.is_package_installed", "meddlr.utils.env.is_package_installed", "meddlr.utils.env.is_package_installed", "meddlr.utils.env.is_package_installed"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_package_version", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed"], ["", "", "def", "test_is_package_installed", "(", ")", ":", "\n", "    ", "assert", "env", ".", "is_package_installed", "(", "\"numpy\"", ")", "\n", "assert", "env", ".", "is_package_installed", "(", "\"numpy>=0.0.1\"", ")", "\n", "assert", "env", ".", "is_package_installed", "(", "\"numpy>=0.0.1,<=1000.0.0\"", ")", "\n", "assert", "not", "env", ".", "is_package_installed", "(", "\"numpy<=0.0.1\"", ")", "\n", "assert", "not", "env", ".", "is_package_installed", "(", "\"numpy>=1000.0.0\"", ")", "\n", "\n", "numpy_version", "=", "env", ".", "get_package_version", "(", "\"numpy\"", ")", "\n", "assert", "not", "env", ".", "is_package_installed", "(", "\"numpy==0.0.1\"", ")", "\n", "assert", "env", ".", "is_package_installed", "(", "f\"numpy=={numpy_version}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_registry._mock_fn": [[6, 9], ["_MOCK_REGISTRY.register"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.register"], ["@", "_MOCK_REGISTRY", ".", "register", "(", "aliases", "=", "\"mock_fn\"", ")", "\n", "def", "_mock_fn", "(", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_registry.test_registry_decorator": [[21, 30], ["_MOCK_REGISTRY.get", "_MOCK_REGISTRY.get", "_MOCK_REGISTRY.get", "_MOCK_REGISTRY.get", "_MOCK_REGISTRY.get", "_MOCK_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "test_registry_decorator", "(", ")", ":", "\n", "    ", "assert", "_MOCK_REGISTRY", ".", "get", "(", "\"_mock_fn\"", ")", "==", "_mock_fn", "\n", "assert", "_MOCK_REGISTRY", ".", "get", "(", "\"mock_fn\"", ")", "==", "_mock_fn", "\n", "\n", "assert", "_MOCK_REGISTRY", ".", "get", "(", "\"_MockCls\"", ")", "==", "_MockCls", "\n", "assert", "_MOCK_REGISTRY", ".", "get", "(", "\"MockCls\"", ")", "==", "_MockCls", "\n", "\n", "assert", "_MOCK_REGISTRY", ".", "get", "(", "\"_MockAliasCls\"", ")", "==", "_MockAliasCls", "\n", "assert", "_MOCK_REGISTRY", ".", "get", "(", "\"MockAliasCls\"", ")", "==", "_MockAliasCls", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_registry.test_registry_object": [[32, 45], ["test_registry._MockAliasCls", "meddlr.utils.registry.Registry", "meddlr.utils.registry.Registry.register", "meddlr.utils.registry.Registry.clear", "meddlr.utils.registry.Registry.register", "meddlr.utils.registry.Registry.get", "meddlr.utils.registry.Registry.get", "meddlr.utils.registry.Registry.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.register", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.register", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "test_registry_object", "(", ")", ":", "\n", "    ", "obj", "=", "_MockAliasCls", "(", ")", "\n", "obj", ".", "__name__", "=", "\"Sample\"", "\n", "\n", "registry", "=", "Registry", "(", "\"Mock\"", ")", "\n", "\n", "registry", ".", "register", "(", "obj", ")", "\n", "assert", "registry", ".", "get", "(", "\"Sample\"", ")", "==", "obj", "\n", "\n", "registry", ".", "clear", "(", ")", "\n", "registry", ".", "register", "(", "obj", ",", "[", "\"FooBar\"", "]", ")", "\n", "assert", "registry", ".", "get", "(", "\"Sample\"", ")", "==", "obj", "\n", "assert", "registry", ".", "get", "(", "\"FooBar\"", ")", "==", "obj", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_path.test_download_github": [[25, 29], ["tmpdir.mkdir", "meddlr.utils.path.download_github_repository", "os.path.isdir", "meddlr.utils.env.get_github_url", "tmpdir.mkdir.join"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.download_github_repository", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_github_url"], ["def", "test_download_github", "(", "tmpdir", ")", ":", "\n", "    ", "download_dir", "=", "tmpdir", ".", "mkdir", "(", "\"download\"", ")", "\n", "download_github_repository", "(", "env", ".", "get_github_url", "(", ")", ",", "branch_or_tag", "=", "\"main\"", ",", "cache_path", "=", "download_dir", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "download_dir", ".", "join", "(", "\"annotations\"", ")", ".", "strpath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_path.test_github_handler": [[31, 39], ["tmpdir.mkdir", "meddlr.utils.path.GithubHandler", "meddlr.utils.path.GithubHandler._get_local_path", "os.path.isdir", "meddlr.utils.env.get_github_url", "str", "os.path.join"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_github_url"], ["", "def", "test_github_handler", "(", "tmpdir", ")", ":", "\n", "    ", "download_dir", "=", "tmpdir", ".", "mkdir", "(", "\"download\"", ")", "\n", "handler", "=", "GithubHandler", "(", "\n", "env", ".", "get_github_url", "(", ")", ",", "default_branch_or_tag", "=", "\"main\"", ",", "default_cache_path", "=", "download_dir", "/", "\"main\"", "\n", ")", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "\"github://annotations\"", ")", "\n", "assert", "str", "(", "path", ")", "==", "os", ".", "path", ".", "join", "(", "download_dir", ".", "strpath", ",", "\"main\"", ",", "\"annotations\"", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_path.test_gdrive_handler": [[41, 70], ["tmpdir.mkdir", "meddlr.utils.path.GoogleDriveHandler", "meddlr.utils.path.GoogleDriveHandler._get_local_path", "os.path.exists", "os.path.getmtime", "meddlr.utils.path.GoogleDriveHandler._get_local_path", "os.path.getmtime", "meddlr.utils.path.GoogleDriveHandler._get_local_path", "os.path.isdir", "os.path.getmtime", "meddlr.utils.path.GoogleDriveHandler._get_local_path", "os.path.getmtime", "meddlr.utils.path.GoogleDriveHandler._get_local_path", "os.path.isdir"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path"], ["", "def", "test_gdrive_handler", "(", "tmpdir", ")", ":", "\n", "    ", "download_dir", "=", "tmpdir", ".", "mkdir", "(", "\"download\"", ")", "\n", "\n", "handler", "=", "GoogleDriveHandler", "(", "cache_dir", "=", "tmpdir", ")", "\n", "\n", "# File", "\n", "url", "=", "\"gdrive://https://drive.google.com/file/d/1fWgHNUljPrJj-97YPbbrqugSPnS2zXnx/view?usp=sharing\"", "# noqa: E501", "\n", "cache", "=", "download_dir", "/", "\"hello-world.txt\"", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "url", ",", "cache", "=", "cache", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "path", ")", "\n", "mtime", "=", "os", ".", "path", ".", "getmtime", "(", "path", ")", "\n", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "url", ",", "cache", "=", "cache", ")", "\n", "mtime2", "=", "os", ".", "path", ".", "getmtime", "(", "path", ")", "\n", "assert", "mtime2", "==", "mtime", "\n", "\n", "# Folder", "\n", "folder_url", "=", "\"gdrive://https://drive.google.com/drive/folders/1UosSskt3H61wcIGUNehhsYoHNBmk-bGi?usp=sharing\"", "# noqa: E501", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "folder_url", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "path", ")", "\n", "mtime", "=", "os", ".", "path", ".", "getmtime", "(", "path", ")", "\n", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "folder_url", ")", "\n", "mtime2", "=", "os", ".", "path", ".", "getmtime", "(", "path", ")", "\n", "assert", "mtime2", "==", "mtime", "\n", "\n", "cache", "=", "download_dir", "/", "\"sample-dir\"", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "folder_url", ",", "cache", "=", "cache", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "cache", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_path.test_force_download": [[72, 90], ["tmpdir.mkdir", "meddlr.utils.env.get_path_manager", "env.get_path_manager.register_handler", "meddlr.utils.path.ForceDownloadHandler", "meddlr.utils.path.ForceDownloadHandler._get_local_path", "os.path.exists", "os.path.getmtime", "time.sleep", "meddlr.utils.path.ForceDownloadHandler._get_local_path", "os.path.getmtime", "meddlr.utils.path.URLHandler"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path"], ["", "def", "test_force_download", "(", "tmpdir", ")", ":", "\n", "    ", "download_dir", "=", "tmpdir", ".", "mkdir", "(", "\"download\"", ")", "\n", "url", "=", "\"force-download://https://huggingface.co/datasets/arjundd/meddlr-data/resolve/main/test-data/test-exps/basic-cpu.tar.gz\"", "# noqa: E501", "\n", "cache", "=", "download_dir", "/", "\"sample-download.zip\"", "\n", "\n", "path_manager", "=", "env", ".", "get_path_manager", "(", "\"meddlr_test\"", ")", "\n", "path_manager", ".", "register_handler", "(", "URLHandler", "(", "path_manager", ")", ")", "\n", "handler", "=", "ForceDownloadHandler", "(", "path_manager", ")", "\n", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "url", ",", "cache", "=", "cache", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "path", ")", "\n", "mtime", "=", "os", ".", "path", ".", "getmtime", "(", "path", ")", "\n", "time", ".", "sleep", "(", "0.1", ")", "\n", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "url", ",", "cache", "=", "cache", ")", "\n", "mtime2", "=", "os", ".", "path", ".", "getmtime", "(", "path", ")", "\n", "\n", "assert", "mtime2", "!=", "mtime", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_path.test_url_local_path": [[92, 107], ["tmpdir.mkdir", "meddlr.utils.env.get_path_manager", "meddlr.utils.path.URLHandler", "meddlr.utils.path.URLHandler._get_local_path", "os.path.exists", "os.path.getmtime", "meddlr.utils.path.URLHandler._get_local_path", "os.path.getmtime"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path"], ["", "def", "test_url_local_path", "(", "tmpdir", ")", ":", "\n", "    ", "download_dir", "=", "tmpdir", ".", "mkdir", "(", "\"download\"", ")", "\n", "url", "=", "\"https://huggingface.co/arjundd/vortex-release/raw/main/fastmri_brain_mini/Aug_Motion/config.yaml\"", "# noqa: E501", "\n", "\n", "path_manager", "=", "env", ".", "get_path_manager", "(", "\"meddlr_test\"", ")", "\n", "handler", "=", "URLHandler", "(", "path_manager", ",", "cache_dir", "=", "tmpdir", ")", "\n", "\n", "cache", "=", "download_dir", "/", "\"config.yaml\"", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "url", ",", "cache", "=", "cache", ",", "force", "=", "True", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "path", ")", "\n", "mtime", "=", "os", ".", "path", ".", "getmtime", "(", "path", ")", "\n", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "url", ",", "cache", "=", "cache", ")", "\n", "mtime2", "=", "os", ".", "path", ".", "getmtime", "(", "path", ")", "\n", "assert", "mtime2", "==", "mtime", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.utils.test_path.test_url_open": [[109, 125], ["tmpdir.mkdir", "meddlr.utils.env.get_path_manager", "meddlr.utils.path.URLHandler", "meddlr.utils.path.URLHandler._get_local_path", "open", "yaml.safe_load", "meddlr.utils.path.URLHandler._open", "yaml.safe_load"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.ForceDownloadHandler._get_local_path", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.URLHandler._open"], ["", "def", "test_url_open", "(", "tmpdir", ")", ":", "\n", "    ", "download_dir", "=", "tmpdir", ".", "mkdir", "(", "\"download\"", ")", "\n", "url", "=", "\"https://huggingface.co/arjundd/vortex-release/raw/main/fastmri_brain_mini/Aug_Motion/config.yaml\"", "# noqa: E501", "\n", "\n", "path_manager", "=", "env", ".", "get_path_manager", "(", "\"meddlr_test\"", ")", "\n", "handler", "=", "URLHandler", "(", "path_manager", ",", "cache_dir", "=", "tmpdir", ")", "\n", "\n", "cache", "=", "download_dir", "/", "\"config.yaml\"", "\n", "path", "=", "handler", ".", "_get_local_path", "(", "url", ",", "cache", "=", "cache", ",", "force", "=", "True", ")", "\n", "with", "open", "(", "path", ")", "as", "f", ":", "\n", "        ", "expected", "=", "yaml", ".", "safe_load", "(", "f", ")", "\n", "\n", "", "with", "handler", ".", "_open", "(", "url", ")", "as", "f", ":", "\n", "        ", "out", "=", "yaml", ".", "safe_load", "(", "f", ")", "\n", "\n", "", "assert", "out", "==", "expected", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.LossComputer.__init__": [[28, 30], ["meddlr.data.transforms.transform.build_normalizer"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.build_normalizer"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "_normalizer", "=", "build_normalizer", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.LossComputer.__call__": [[31, 34], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "input", ",", "output", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.LossComputer._get_metrics": [[35, 87], ["torch.mean", "torch.mean", "meddlr.ops.complex.abs.view", "torch.sqrt", "torch.abs", "meddlr.ops.complex.abs", "torch.abs", "torch.abs().view", "meddlr.ops.complex.abs().view", "torch.mean", "torch.log10", "torch.sqrt", "torch.sqrt.mean", "psnr.mean", "nrmse.mean", "metrics_dict.update", "meddlr.ops.complex.abs", "torch.mean", "loss_computer.perp_loss", "meddlr.utils.transforms.fft2", "meddlr.utils.transforms.fft2", "torch.mean", "meddlr.ops.complex.abs", "meddlr.ops.complex.abs", "torch.abs", "meddlr.ops.complex.abs", "torch.mean", "meddlr.ops.complex.abs().view.max", "torch.sum", "torch.sum", "torch.sqrt", "torch.sqrt", "meddlr.ops.complex.abs", "meddlr.ops.complex.abs", "torch.sum", "torch.sum", "meddlr.ops.complex.abs"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.perp_loss", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "_get_metrics", "(", "self", ",", "target", ":", "torch", ".", "Tensor", ",", "output", ":", "torch", ".", "Tensor", ",", "loss_name", ")", ":", "\n", "# Compute metrics", "\n", "        ", "if", "loss_name", "==", "\"mag_l1\"", ":", "\n", "            ", "abs_error", "=", "torch", ".", "abs", "(", "output", "-", "target", ")", "\n", "abs_mag_error", "=", "abs_error", "\n", "", "else", ":", "\n", "            ", "abs_error", "=", "cplx", ".", "abs", "(", "output", "-", "target", ")", "\n", "abs_mag_error", "=", "torch", ".", "abs", "(", "cplx", ".", "abs", "(", "output", ")", "-", "cplx", ".", "abs", "(", "target", ")", ")", "\n", "", "l1", "=", "torch", ".", "mean", "(", "abs_error", ")", "\n", "mag_l1", "=", "torch", ".", "mean", "(", "abs_mag_error", ")", "\n", "N", "=", "target", ".", "shape", "[", "0", "]", "\n", "\n", "abs_error", "=", "abs_error", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "if", "loss_name", "==", "\"mag_l1\"", ":", "\n", "            ", "tgt_mag", "=", "torch", ".", "abs", "(", "target", ")", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "tgt_mag", "=", "cplx", ".", "abs", "(", "target", ")", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "", "l2", "=", "torch", ".", "sqrt", "(", "torch", ".", "mean", "(", "abs_error", "**", "2", ",", "dim", "=", "1", ")", ")", "\n", "psnr", "=", "20", "*", "torch", ".", "log10", "(", "tgt_mag", ".", "max", "(", "dim", "=", "1", ")", "[", "0", "]", "/", "(", "l2", "+", "EPS", ")", ")", "\n", "nrmse", "=", "l2", "/", "torch", ".", "sqrt", "(", "torch", ".", "mean", "(", "tgt_mag", "**", "2", ",", "dim", "=", "1", ")", ")", "\n", "\n", "metrics_dict", "=", "{", "\n", "\"l1\"", ":", "l1", ",", "\n", "\"l2\"", ":", "l2", ".", "mean", "(", ")", ",", "\n", "\"psnr\"", ":", "psnr", ".", "mean", "(", ")", ",", "\n", "\"nrmse\"", ":", "nrmse", ".", "mean", "(", ")", ",", "\n", "\"mag_l1\"", ":", "mag_l1", ",", "\n", "}", "\n", "\n", "if", "loss_name", "==", "\"perp_loss\"", ":", "\n", "            ", "metrics_dict", ".", "update", "(", "perp_loss", "(", "output", ",", "target", ")", ")", "\n", "\n", "", "if", "loss_name", "in", "KSPACE_LOSSES", ":", "\n", "            ", "target", ",", "output", "=", "T", ".", "fft2", "(", "target", ")", ",", "T", ".", "fft2", "(", "output", ")", "\n", "abs_error", "=", "cplx", ".", "abs", "(", "target", "-", "output", ")", "\n", "if", "loss_name", "==", "\"k_l1\"", ":", "\n", "                ", "metrics_dict", "[", "\"loss\"", "]", "=", "torch", ".", "mean", "(", "abs_error", ")", "\n", "", "elif", "loss_name", "==", "\"k_l1_normalized\"", ":", "\n", "                ", "metrics_dict", "[", "\"loss\"", "]", "=", "torch", ".", "mean", "(", "abs_error", "/", "(", "cplx", ".", "abs", "(", "target", ")", "+", "EPS", ")", ")", "\n", "", "elif", "loss_name", "==", "\"k_l1_l2_sum_normalized\"", ":", "\n", "                ", "kl1_norm", "=", "torch", ".", "sum", "(", "abs_error", ")", "/", "torch", ".", "sum", "(", "cplx", ".", "abs", "(", "target", ")", ")", "\n", "kl2_norm", "=", "torch", ".", "sqrt", "(", "torch", ".", "sum", "(", "abs_error", "**", "2", ")", ")", "/", "torch", ".", "sqrt", "(", "\n", "torch", ".", "sum", "(", "cplx", ".", "abs", "(", "target", ")", "**", "2", ")", "\n", ")", "# noqa: E501", "\n", "metrics_dict", "[", "\"loss\"", "]", "=", "0.5", "*", "kl1_norm", "+", "0.5", "*", "kl2_norm", "\n", "", "else", ":", "\n", "                ", "assert", "False", "# should not reach here", "\n", "", "", "else", ":", "\n", "            ", "loss", "=", "metrics_dict", "[", "loss_name", "]", "\n", "metrics_dict", "[", "\"loss\"", "]", "=", "loss", "\n", "\n", "", "return", "metrics_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.BasicLossComputer.__init__": [[91, 97], ["loss_computer.LossComputer.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ")", "\n", "loss_name", "=", "cfg", ".", "MODEL", ".", "RECON_LOSS", ".", "NAME", "\n", "assert", "loss_name", "in", "IMAGE_LOSSES", "or", "loss_name", "in", "KSPACE_LOSSES", "\n", "self", ".", "loss", "=", "loss_name", "\n", "self", ".", "renormalize_data", "=", "cfg", ".", "MODEL", ".", "RECON_LOSS", ".", "RENORMALIZE_DATA", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.BasicLossComputer.__call__": [[98, 117], ["output[].to", "loss_computer.BasicLossComputer._get_metrics", "loss_computer.BasicLossComputer._normalizer.undo", "input.get", "output.get"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.LossComputer._get_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.AffineNormalizer.undo", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "__call__", "(", "self", ",", "input", ",", "output", ")", ":", "\n", "        ", "pred", ":", "torch", ".", "Tensor", "=", "output", "[", "\"pred\"", "]", "\n", "target", "=", "output", "[", "\"target\"", "]", ".", "to", "(", "pred", ".", "device", ")", "\n", "\n", "if", "self", ".", "renormalize_data", ":", "\n", "            ", "normalization_args", "=", "{", "k", ":", "input", ".", "get", "(", "k", ",", "output", ".", "get", "(", "k", ",", "None", ")", ")", "for", "k", "in", "[", "\"mean\"", ",", "\"std\"", "]", "}", "\n", "normalized", "=", "self", ".", "_normalizer", ".", "undo", "(", "\n", "image", "=", "pred", ",", "\n", "target", "=", "target", ",", "\n", "mean", "=", "normalization_args", "[", "\"mean\"", "]", ",", "\n", "std", "=", "normalization_args", "[", "\"std\"", "]", ",", "\n", ")", "\n", "output", "=", "normalized", "[", "\"image\"", "]", "\n", "target", "=", "normalized", "[", "\"target\"", "]", "\n", "", "else", ":", "\n", "            ", "output", "=", "pred", "\n", "\n", "", "metrics_dict", "=", "self", ".", "_get_metrics", "(", "target", ",", "output", ",", "self", ".", "loss", ")", "\n", "return", "metrics_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.N2RLossComputer.__init__": [[121, 140], ["loss_computer.LossComputer.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ")", "\n", "recon_loss", "=", "cfg", ".", "MODEL", ".", "RECON_LOSS", ".", "NAME", "\n", "consistency_loss", "=", "cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "LOSS_NAME", "\n", "latent_loss", "=", "cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "LATENT_LOSS_NAME", "\n", "\n", "assert", "recon_loss", "in", "IMAGE_LOSSES", "or", "recon_loss", "in", "KSPACE_LOSSES", "\n", "assert", "consistency_loss", "in", "IMAGE_LOSSES", "or", "consistency_loss", "in", "KSPACE_LOSSES", "\n", "\n", "self", ".", "recon_loss", "=", "recon_loss", "\n", "self", ".", "consistency_loss", "=", "consistency_loss", "\n", "self", ".", "latent_loss", "=", "latent_loss", "\n", "self", ".", "renormalize_data", "=", "cfg", ".", "MODEL", ".", "RECON_LOSS", ".", "RENORMALIZE_DATA", "\n", "self", ".", "consistency_weight", "=", "cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "LOSS_WEIGHT", "\n", "self", ".", "latent_weight", "=", "cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "LATENT_LOSS_WEIGHT", "\n", "self", ".", "use_latent", "=", "cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "USE_LATENT", "\n", "self", ".", "use_consistency", "=", "cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "USE_CONSISTENCY", "\n", "self", ".", "num_latent_layers", "=", "cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "NUM_LATENT_LAYERS", "\n", "self", ".", "latent_keys", "=", "[", "\"E4\"", ",", "\"E3\"", ",", "\"D3\"", ",", "\"E2\"", ",", "\"D2\"", ",", "\"E1\"", ",", "\"D1\"", "]", "\n", "# self.use_robust = cfg.MODEL.LOSS.USE_ROBUST", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.N2RLossComputer._compute_metrics": [[144, 163], ["output[].to", "loss_computer.N2RLossComputer._get_metrics", "loss_computer.N2RLossComputer._normalizer.undo", "len", "torch.Tensor().detach", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.LossComputer._get_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.AffineNormalizer.undo"], ["", "def", "_compute_metrics", "(", "self", ",", "input", ",", "output", ",", "loss", ")", ":", "\n", "        ", "\"\"\"Computes image metrics on prediction and target data.\"\"\"", "\n", "if", "output", "is", "None", "or", "len", "(", "output", ")", "==", "0", ":", "\n", "            ", "return", "{", "k", ":", "torch", ".", "Tensor", "(", "[", "0.0", "]", ")", ".", "detach", "(", ")", "for", "k", "in", "[", "\"l1\"", ",", "\"l2\"", ",", "\"psnr\"", ",", "\"loss\"", "]", "}", "\n", "\n", "", "pred", ":", "torch", ".", "Tensor", "=", "output", "[", "\"pred\"", "]", "\n", "target", "=", "output", "[", "\"target\"", "]", ".", "to", "(", "pred", ".", "device", ")", "\n", "if", "self", ".", "renormalize_data", ":", "\n", "            ", "normalized", "=", "self", ".", "_normalizer", ".", "undo", "(", "\n", "image", "=", "pred", ",", "target", "=", "target", ",", "mean", "=", "input", "[", "\"mean\"", "]", ",", "std", "=", "input", "[", "\"std\"", "]", "\n", ")", "\n", "output", "=", "normalized", "[", "\"image\"", "]", "\n", "target", "=", "normalized", "[", "\"target\"", "]", "\n", "", "else", ":", "\n", "            ", "output", "=", "pred", "\n", "\n", "# Compute metrics", "\n", "", "metrics_dict", "=", "self", ".", "_get_metrics", "(", "target", ",", "output", ",", "loss", ")", "\n", "return", "metrics_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.N2RLossComputer.__call__": [[183, 237], ["output.get", "output.get", "range", "metrics.update", "metrics.update", "range", "loss_computer.N2RLossComputer._compute_metrics().items", "loss_computer.N2RLossComputer._compute_metrics().items", "all_metrics_latent.append", "metrics.update", "loss_computer.N2RLossComputer._compute_metrics", "loss_computer.N2RLossComputer._compute_metrics", "loss_computer.N2RLossComputer._compute_metrics().items", "input.get", "input.get", "loss_computer.N2RLossComputer._compute_metrics"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.N2RLossComputer._compute_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.N2RLossComputer._compute_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.N2RLossComputer._compute_metrics"], ["", "def", "__call__", "(", "self", ",", "input", ",", "output", ")", ":", "\n", "        ", "output_recon", "=", "output", ".", "get", "(", "\"recon\"", ",", "None", ")", "\n", "output_consistency", "=", "output", ".", "get", "(", "\"consistency\"", ",", "None", ")", "\n", "\n", "loss", "=", "0", "\n", "metrics_recon", "=", "{", "\n", "\"recon_{}\"", ".", "format", "(", "k", ")", ":", "v", "\n", "for", "k", ",", "v", "in", "self", ".", "_compute_metrics", "(", "\n", "input", ".", "get", "(", "\"supervised\"", ",", "None", ")", ",", "output_recon", ",", "self", ".", "recon_loss", "\n", ")", ".", "items", "(", ")", "\n", "}", "\n", "if", "output_recon", "is", "not", "None", ":", "\n", "            ", "loss", "+=", "metrics_recon", "[", "\"recon_loss\"", "]", "\n", "\n", "", "metrics_consistency", "=", "{", "\n", "\"cons_{}\"", ".", "format", "(", "k", ")", ":", "v", "\n", "for", "k", ",", "v", "in", "self", ".", "_compute_metrics", "(", "\n", "input", ".", "get", "(", "\"unsupervised\"", ",", "None", ")", ",", "output_consistency", ",", "self", ".", "consistency_loss", "\n", ")", ".", "items", "(", ")", "# noqa", "\n", "}", "\n", "if", "output_consistency", "is", "not", "None", "and", "self", ".", "use_consistency", ":", "\n", "            ", "loss", "+=", "self", ".", "consistency_weight", "*", "metrics_consistency", "[", "\"cons_loss\"", "]", "\n", "\n", "", "if", "self", ".", "use_latent", ":", "\n", "            ", "num_losses", "=", "self", ".", "num_latent_layers", "*", "2", "-", "1", "\n", "all_metrics_latent", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_losses", ")", ":", "\n", "                ", "output_latent", "=", "{", "}", "\n", "output_latent", "[", "\"target\"", "]", "=", "output_recon", "[", "\"latent\"", "]", "[", "self", ".", "latent_keys", "[", "i", "]", "]", "\n", "output_latent", "[", "\"pred\"", "]", "=", "output_consistency", "[", "\"latent\"", "]", "[", "self", ".", "latent_keys", "[", "i", "]", "]", "\n", "\n", "metrics_latent", "=", "{", "\n", "\"latent_\"", "+", "self", ".", "latent_keys", "[", "i", "]", "+", "\"_{}\"", ".", "format", "(", "k", ")", ":", "v", "\n", "for", "k", ",", "v", "in", "self", ".", "_compute_metrics", "(", "\n", "None", ",", "output_latent", ",", "self", ".", "latent_loss", "\n", ")", ".", "items", "(", ")", "# noqa", "\n", "}", "\n", "\n", "all_metrics_latent", ".", "append", "(", "metrics_latent", ")", "\n", "loss", "+=", "(", "\n", "self", ".", "latent_weight", "*", "metrics_latent", "[", "\"latent_\"", "+", "self", ".", "latent_keys", "[", "i", "]", "+", "\"_loss\"", "]", "\n", ")", "\n", "\n", "", "", "metrics", "=", "{", "}", "\n", "if", "output_consistency", "is", "not", "None", "and", "self", ".", "use_consistency", ":", "\n", "            ", "metrics", ".", "update", "(", "metrics_consistency", ")", "\n", "", "if", "output_recon", "is", "not", "None", ":", "\n", "            ", "metrics", ".", "update", "(", "metrics_recon", ")", "\n", "", "if", "self", ".", "use_latent", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_losses", ")", ":", "\n", "                ", "metrics", ".", "update", "(", "all_metrics_latent", "[", "i", "]", ")", "\n", "\n", "", "", "metrics", "[", "\"loss\"", "]", "=", "loss", "\n", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.build_loss_computer": [[23, 25], ["LOSS_COMPUTER_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["def", "build_loss_computer", "(", "cfg", ",", "name", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "LOSS_COMPUTER_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.modeling.loss_computer.perp_loss": [[239, 264], ["meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex", "torch.abs", "torch.view_as_real", "torch.view_as_real", "torch.abs", "meddlr.ops.complex.abs", "torch.mean", "torch.mean", "meddlr.ops.complex.abs", "meddlr.ops.complex.abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "", "def", "perp_loss", "(", "yhat", ",", "y", ")", ":", "\n", "    ", "\"\"\"Implementation of the perpendicular loss.\n\n    Args:\n        yhat: Predicted reconstruction. Must be complex.\n        y: Target reconstruction. Must be complex.\n\n    Returns:\n        Dict[str, scalar]:\n\n    References:\n        Terpstra, et al. \"Rethinking complex image reconstruction:\n        \u27c2-loss for improved complex image reconstruction with deep learning.\"\n        International Society of Magnetic Resonance in Medicine Annual Meeting\n        2021.\n    \"\"\"", "\n", "if", "cplx", ".", "is_complex", "(", "yhat", ")", ":", "\n", "        ", "yhat", "=", "torch", ".", "view_as_real", "(", "yhat", ")", "\n", "", "if", "cplx", ".", "is_complex", "(", "y", ")", ":", "\n", "        ", "y", "=", "torch", ".", "view_as_real", "(", "y", ")", "\n", "\n", "", "P", "=", "torch", ".", "abs", "(", "yhat", "[", "...", ",", "0", "]", "*", "y", "[", "...", ",", "1", "]", "-", "yhat", "[", "...", ",", "1", "]", "*", "y", "[", "...", ",", "0", "]", ")", "/", "cplx", ".", "abs", "(", "y", ")", "\n", "l1", "=", "torch", ".", "abs", "(", "cplx", ".", "abs", "(", "y", ")", "-", "cplx", ".", "abs", "(", "yhat", ")", ")", "\n", "\n", "return", "{", "\"p_perp_loss\"", ":", "torch", ".", "mean", "(", "P", ")", ",", "\"perp_loss\"", ":", "torch", ".", "mean", "(", "P", "+", "l1", ")", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.n2r.N2RModel.__init__": [[24, 55], ["torch.nn.Module.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "nn", ".", "Module", ",", "\n", "noiser", ":", "NoiseModel", ",", "\n", "use_supervised_consistency", ":", "bool", "=", "False", ",", "\n", "vis_period", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            model (nn.Module): The base model.\n            noiser (NoiseModel): The additive noise module.\n            use_supervised_consistency (bool, optional): If ``True``, use consistency\n                with supervised examples too.\n            vis_period (int, optional): The period over which to visualize images.\n                If ``<=0``, it is ignored. Note if the ``model`` has a ``vis_period``\n                attribute, it will be overridden so that this class handles visualization.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "\n", "# Visualization done by this model", "\n", "if", "hasattr", "(", "self", ".", "model", ",", "\"vis_period\"", ")", "and", "vis_period", ">", "0", ":", "\n", "            ", "self", ".", "model", ".", "vis_period", "=", "-", "1", "\n", "", "self", ".", "vis_period", "=", "vis_period", "\n", "\n", "# Keep gradient for base images in transform.", "\n", "self", ".", "use_base_grad", "=", "False", "\n", "# Use supervised examples for consistency", "\n", "self", ".", "use_supervised_consistency", "=", "use_supervised_consistency", "\n", "self", ".", "noiser", "=", "noiser", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.n2r.N2RModel.augment": [[56, 75], ["inputs[].clone", "n2r.N2RModel.noiser", "v.clone", "inputs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "augment", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Noise augmentation module for the consistency branch.\n\n        Args:\n            inputs (Dict[str, Any]): The input dictionary.\n                It must contain a key ``'kspace'``, which traditionally\n                corresponds to the undersampled kspace when performing\n                augmentation for consistency.\n\n        Returns:\n            Dict[str, Any]: The input dictionary with the kspace polluted\n                with additive masked complex Gaussian noise.\n        \"\"\"", "\n", "kspace", "=", "inputs", "[", "\"kspace\"", "]", ".", "clone", "(", ")", "\n", "aug_kspace", "=", "self", ".", "noiser", "(", "kspace", ",", "clone", "=", "False", ")", "\n", "\n", "inputs", "=", "{", "k", ":", "v", ".", "clone", "(", ")", "for", "k", ",", "v", "in", "inputs", ".", "items", "(", ")", "if", "k", "!=", "\"kspace\"", "}", "\n", "inputs", "[", "\"kspace\"", "]", "=", "aug_kspace", "\n", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.n2r.N2RModel.visualize_aug_training": [[76, 121], ["meddlr.utils.events.get_event_storage", "torch.no_grad", "meddlr.ops.complex.is_complex", "[].unsqueeze", "meddlr.ops.complex.is_complex", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "torch.cat", "torch.cat", "torch.cat", "imgs_to_write.items", "torch.view_as_real", "torch.view_as_real", "meddlr.ops.complex.abs", "[].unsqueeze", "torch.cat.append", "torch.cat.append", "meddlr.ops.complex.angle", "meddlr.ops.complex.abs", "meddlr.ops.complex.get_mask", "meddlr.ops.complex.abs", "torchvision.make_grid.squeeze().unsqueeze", "torchvision.make_grid", "meddlr.utils.events.get_event_storage.put_image", "meddlr.ops.complex.abs", "torchvision.make_grid.numpy", "torch.view_as_real.cpu", "torch.view_as_real.cpu", "[].unsqueeze.cpu", "[].unsqueeze.cpu", "torchvision.make_grid.squeeze", "[].unsqueeze.cpu"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "def", "visualize_aug_training", "(", "self", ",", "kspace", ",", "kspace_aug", ",", "preds", ",", "preds_base", ",", "target", "=", "None", ")", ":", "\n", "        ", "\"\"\"Visualize training of augmented data.\n\n        Args:\n            kspace: The base kspace.\n            kspace_aug: The augmented kspace.\n            preds: Reconstruction of augmented kspace. Shape: NxHxWx2.\n            preds_base: Reconstruction of base kspace. Shape: NxHxWx2.\n        \"\"\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# calc mask for first coil only", "\n", "            ", "if", "cplx", ".", "is_complex", "(", "kspace", ")", ":", "\n", "                ", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "", "kspace", "=", "kspace", ".", "cpu", "(", ")", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "if", "cplx", ".", "is_complex", "(", "kspace_aug", ")", ":", "\n", "                ", "kspace_aug", "=", "torch", ".", "view_as_real", "(", "kspace_aug", ")", "\n", "", "kspace_aug", "=", "kspace_aug", ".", "cpu", "(", ")", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "preds", "=", "preds", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "preds_base", "=", "preds_base", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "all_images", "=", "[", "preds", ",", "preds_base", "]", "\n", "errors", "=", "[", "cplx", ".", "abs", "(", "preds_base", "-", "preds", ")", "]", "\n", "if", "target", "is", "not", "None", ":", "\n", "                ", "target", "=", "target", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "all_images", ".", "append", "(", "target", ")", "\n", "errors", ".", "append", "(", "cplx", ".", "abs", "(", "target", "-", "preds", ")", ")", "\n", "\n", "", "all_images", "=", "torch", ".", "cat", "(", "all_images", ",", "dim", "=", "2", ")", "\n", "all_kspace", "=", "torch", ".", "cat", "(", "[", "kspace", ",", "kspace_aug", "]", ",", "dim", "=", "2", ")", "\n", "errors", "=", "torch", ".", "cat", "(", "errors", ",", "dim", "=", "2", ")", "\n", "\n", "imgs_to_write", "=", "{", "\n", "\"phases\"", ":", "cplx", ".", "angle", "(", "all_images", ")", ",", "\n", "\"images\"", ":", "cplx", ".", "abs", "(", "all_images", ")", ",", "\n", "\"errors\"", ":", "errors", ",", "\n", "\"masks\"", ":", "cplx", ".", "get_mask", "(", "kspace", ")", ",", "\n", "\"kspace\"", ":", "cplx", ".", "abs", "(", "all_kspace", ")", ",", "\n", "}", "\n", "\n", "for", "name", ",", "data", "in", "imgs_to_write", ".", "items", "(", ")", ":", "\n", "                ", "data", "=", "data", ".", "squeeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "data", "=", "tv_utils", ".", "make_grid", "(", "data", ",", "nrow", "=", "1", ",", "padding", "=", "1", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", ")", "\n", "storage", ".", "put_image", "(", "\"train_aug/{}\"", ".", "format", "(", "name", ")", ",", "data", ".", "numpy", "(", ")", ",", "data_format", "=", "\"CHW\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.n2r.N2RModel.forward": [[122, 186], ["inputs.get.get.get", "inputs.get.get.get", "inputs.get.get.get", "n2r.N2RModel.model", "meddlr.utils.events.get_event_storage", "ValueError", "n2r.N2RModel.model", "inputs_consistency.append", "inputs_consistency.append", "len", "n2r.N2RModel.augment", "n2r.N2RModel.model", "n2r.N2RModel.detach", "len", "torch.no_grad", "n2r.N2RModel.model", "inputs_consistency.get", "n2r.N2RModel.visualize_aug_training", "torch.cat", "inputs.get.get.items", "inputs_consistency[].keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.visualize_aug_training", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "not", "self", ".", "training", ":", "\n", "            ", "assert", "(", "\n", "\"unsupervised\"", "not", "in", "inputs", "\n", ")", ",", "\"unsupervised inputs should not be provided in eval mode\"", "\n", "inputs", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "inputs", ")", "\n", "return", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "", "vis_training", "=", "False", "\n", "if", "self", ".", "training", "and", "self", ".", "vis_period", ">", "0", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "vis_training", "=", "True", "\n", "\n", "", "", "inputs_supervised", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "None", ")", "\n", "inputs_unsupervised", "=", "inputs", ".", "get", "(", "\"unsupervised\"", ",", "None", ")", "\n", "if", "inputs_supervised", "is", "None", "and", "inputs_unsupervised", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Examples not formatted in the proper way\"", ")", "\n", "", "output_dict", "=", "{", "}", "\n", "\n", "# Recon", "\n", "if", "inputs_supervised", "is", "not", "None", ":", "\n", "            ", "output_dict", "[", "\"recon\"", "]", "=", "self", ".", "model", "(", "\n", "inputs_supervised", ",", "return_pp", "=", "True", ",", "vis_training", "=", "vis_training", "\n", ")", "\n", "\n", "# Consistency.", "\n", "# kspace_aug = kspace + U \\sigma \\mathcal{N}", "\n", "# Loss = L(f(kspace_aug, \\theta), f(kspace, \\theta))", "\n", "", "inputs_consistency", "=", "[", "]", "\n", "if", "inputs_unsupervised", "is", "not", "None", ":", "\n", "            ", "inputs_consistency", ".", "append", "(", "inputs_unsupervised", ")", "\n", "", "if", "self", ".", "use_supervised_consistency", "and", "inputs_supervised", "is", "not", "None", ":", "\n", "            ", "inputs_consistency", ".", "append", "(", "{", "k", ":", "v", "for", "k", ",", "v", "in", "inputs_supervised", ".", "items", "(", ")", "if", "k", "!=", "\"target\"", "}", ")", "\n", "\n", "", "if", "len", "(", "inputs_consistency", ")", ">", "0", ":", "\n", "            ", "if", "len", "(", "inputs_consistency", ")", ">", "1", ":", "\n", "                ", "inputs_consistency", "=", "{", "\n", "k", ":", "torch", ".", "cat", "(", "[", "x", "[", "k", "]", "for", "x", "in", "inputs_consistency", "]", ",", "dim", "=", "0", ")", "\n", "for", "k", "in", "inputs_consistency", "[", "0", "]", ".", "keys", "(", ")", "\n", "}", "\n", "", "else", ":", "\n", "                ", "inputs_consistency", "=", "inputs_consistency", "[", "0", "]", "\n", "", "inputs_consistency_aug", "=", "self", ".", "augment", "(", "inputs_consistency", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "pred_base", "=", "self", ".", "model", "(", "inputs_consistency", ")", "\n", "# Target only used for visualization purposes not for loss.", "\n", "target", "=", "inputs_consistency", ".", "get", "(", "\"target\"", ",", "None", ")", "\n", "pred_base", "=", "pred_base", "[", "\"pred\"", "]", "\n", "", "pred_aug", "=", "self", ".", "model", "(", "inputs_consistency_aug", ",", "return_pp", "=", "True", ")", "\n", "if", "\"target\"", "in", "pred_aug", ":", "\n", "                ", "del", "pred_aug", "[", "\"target\"", "]", "\n", "", "pred_aug", "[", "\"target\"", "]", "=", "pred_base", ".", "detach", "(", ")", "\n", "output_dict", "[", "\"consistency\"", "]", "=", "pred_aug", "\n", "if", "vis_training", ":", "\n", "                ", "self", ".", "visualize_aug_training", "(", "\n", "inputs_consistency", "[", "\"kspace\"", "]", ",", "\n", "inputs_consistency_aug", "[", "\"kspace\"", "]", ",", "\n", "pred_aug", "[", "\"pred\"", "]", ",", "\n", "pred_base", ",", "\n", "target", "=", "target", ",", "\n", ")", "\n", "\n", "", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.n2r.N2RModel.load_state_dict": [[187, 195], ["any", "super().load_state_dict", "ValueError", "x.startswith", "state_dict.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.load_state_dict"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ",", "strict", "=", "True", ")", ":", "\n", "# TODO: Configure backwards compatibility", "\n", "        ", "if", "any", "(", "x", ".", "startswith", "(", "\"unrolled\"", ")", "for", "x", "in", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`self.unrolled` was renamed to `self.model`. \"", "\n", "\"Backwards compatibility has not been configured.\"", "\n", ")", "\n", "", "return", "super", "(", ")", ".", "load_state_dict", "(", "state_dict", ",", "strict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.n2r.N2RModel.from_config": [[196, 211], ["cfg.clone", "cfg.clone.defrost", "cfg.clone.freeze", "meddlr.modeling.meta_arch.build.build_model", "meddlr.data.transforms.noise.NoiseModel.from_cfg"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "model_cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "model_cfg", ".", "defrost", "(", ")", "\n", "model_cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "=", "cfg", ".", "MODEL", ".", "N2R", ".", "META_ARCHITECTURE", "\n", "model_cfg", ".", "freeze", "(", ")", "\n", "model", "=", "build_model", "(", "model_cfg", ")", "\n", "\n", "noiser", "=", "NoiseModel", ".", "from_cfg", "(", "cfg", ")", "\n", "\n", "return", "{", "\n", "\"model\"", ":", "model", ",", "\n", "\"noiser\"", ":", "noiser", ",", "\n", "\"use_supervised_consistency\"", ":", "cfg", ".", "MODEL", ".", "N2R", ".", "USE_SUPERVISED_CONSISTENCY", ",", "\n", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.ConvBlock.__init__": [[29, 51], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.InstanceNorm2d", "torch.nn.LeakyReLU", "torch.nn.Dropout2d", "torch.nn.Conv2d", "torch.nn.InstanceNorm2d", "torch.nn.LeakyReLU", "torch.nn.Dropout2d"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "in_chans", ",", "out_chans", ",", "drop_prob", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_chans (int): Number of channels in the input.\n            out_chans (int): Number of channels in the output.\n            drop_prob (float): Dropout probability.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "in_chans", "=", "in_chans", "\n", "self", ".", "out_chans", "=", "out_chans", "\n", "self", ".", "drop_prob", "=", "drop_prob", "\n", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_chans", ",", "out_chans", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm2d", "(", "out_chans", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Dropout2d", "(", "drop_prob", ")", ",", "\n", "nn", ".", "Conv2d", "(", "out_chans", ",", "out_chans", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm2d", "(", "out_chans", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Dropout2d", "(", "drop_prob", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.ConvBlock.forward": [[53, 61], ["unet.ConvBlock.layers"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape [batch_size, self.in_chans, height, width]\n        Returns:\n            (torch.Tensor): Output tensor of shape [batch_size, self.out_chans, height, width]\n        \"\"\"", "\n", "return", "self", ".", "layers", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.ConvBlock.__repr__": [[62, 65], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "(", "\n", "f\"ConvBlock(in_chans={self.in_chans}, out_chans={self.out_chans}, \"", "\n", "f\"drop_prob={self.drop_prob})\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.TransposeConvBlock.__init__": [[75, 90], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.ConvTranspose2d", "torch.nn.InstanceNorm2d", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "in_chans", ",", "out_chans", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_chans (int): Number of channels in the input.\n            out_chans (int): Number of channels in the output.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "in_chans", "=", "in_chans", "\n", "self", ".", "out_chans", "=", "out_chans", "\n", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ConvTranspose2d", "(", "in_chans", ",", "out_chans", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm2d", "(", "out_chans", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.TransposeConvBlock.forward": [[92, 100], ["unet.TransposeConvBlock.layers"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape [batch_size, self.in_chans, height, width]\n        Returns:\n            (torch.Tensor): Output tensor of shape [batch_size, self.out_chans, height, width]\n        \"\"\"", "\n", "return", "self", ".", "layers", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.TransposeConvBlock.__repr__": [[101, 103], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"ConvBlock(in_chans={self.in_chans}, out_chans={self.out_chans})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.__init__": [[115, 171], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "range", "unet.ConvBlock", "torch.nn.ModuleList", "torch.nn.ModuleList", "range", "unet.TransposeConvBlock", "torch.nn.Sequential", "unet.ConvBlock", "unet.ConvBlock", "unet.TransposeConvBlock", "unet.ConvBlock", "unet.ConvBlock", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "out_channels", ":", "int", ",", "\n", "channels", ":", "int", "=", "32", ",", "\n", "num_pool_layers", ":", "int", "=", "4", ",", "\n", "dropout", ":", "float", "=", "0.0", ",", "\n", "use_latent", ":", "bool", "=", "False", ",", "\n", "num_latent_layers", ":", "int", "=", "1", ",", "\n", "normalize", ":", "bool", "=", "False", ",", "\n", "vis_period", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_chans (int): Number of channels in the input to the U-Net model.\n            out_chans (int): Number of channels in the output to the U-Net model.\n            chans (int): Number of output channels of the first convolution layer.\n            num_pool_layers (int): Number of down-sampling and up-sampling layers.\n            drop_prob (float): Dropout probability.\n            normalize (bool, optional): If ``True``, normalize the input for stability.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "in_chans", "=", "in_channels", "\n", "self", ".", "out_chans", "=", "out_channels", "\n", "self", ".", "chans", "=", "channels", "\n", "self", ".", "num_pool_layers", "=", "num_pool_layers", "\n", "self", ".", "drop_prob", "=", "dropout", "\n", "self", ".", "use_latent", "=", "use_latent", "\n", "self", ".", "num_latent_layers", "=", "num_latent_layers", "\n", "self", ".", "normalize", "=", "normalize", "\n", "\n", "self", ".", "down_sample_layers", "=", "nn", ".", "ModuleList", "(", "[", "ConvBlock", "(", "in_channels", ",", "channels", ",", "dropout", ")", "]", ")", "\n", "ch", "=", "channels", "\n", "for", "_i", "in", "range", "(", "num_pool_layers", "-", "1", ")", ":", "\n", "            ", "self", ".", "down_sample_layers", "+=", "[", "ConvBlock", "(", "ch", ",", "ch", "*", "2", ",", "dropout", ")", "]", "\n", "ch", "*=", "2", "\n", "", "self", ".", "conv", "=", "ConvBlock", "(", "ch", ",", "ch", "*", "2", ",", "dropout", ")", "\n", "\n", "self", ".", "up_conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "up_transpose_conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "_i", "in", "range", "(", "num_pool_layers", "-", "1", ")", ":", "\n", "            ", "self", ".", "up_transpose_conv", "+=", "[", "TransposeConvBlock", "(", "ch", "*", "2", ",", "ch", ")", "]", "\n", "self", ".", "up_conv", "+=", "[", "ConvBlock", "(", "ch", "*", "2", ",", "ch", ",", "dropout", ")", "]", "\n", "ch", "//=", "2", "\n", "\n", "", "self", ".", "up_transpose_conv", "+=", "[", "TransposeConvBlock", "(", "ch", "*", "2", ",", "ch", ")", "]", "\n", "self", ".", "up_conv", "+=", "[", "\n", "nn", ".", "Sequential", "(", "\n", "ConvBlock", "(", "ch", "*", "2", ",", "ch", ",", "dropout", ")", ",", "\n", "nn", ".", "Conv2d", "(", "ch", ",", "self", ".", "out_chans", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ",", "\n", ")", "\n", "]", "\n", "\n", "self", ".", "vis_period", "=", "vis_period", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.register_hooks": [[172, 184], ["unet.UnetModel.hooks.append", "range", "unet.UnetModel.conv.register_forward_hook", "unet.UnetModel.hooks.append", "unet.UnetModel.hooks.append", "unet.UnetModel.get_latent", "unet.UnetModel.up_conv[].register_forward_hook", "unet.UnetModel.down_sample_layers[].register_forward_hook", "unet.UnetModel.get_latent", "unet.UnetModel.get_latent", "str", "str"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.get_latent", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.get_latent", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.get_latent"], ["", "def", "register_hooks", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "use_latent", ":", "\n", "            ", "self", ".", "feats", "=", "{", "}", "\n", "self", ".", "hooks", "=", "[", "]", "\n", "self", ".", "hooks", ".", "append", "(", "self", ".", "conv", ".", "register_forward_hook", "(", "self", ".", "get_latent", "(", "\"E4\"", ")", ")", ")", "\n", "for", "_i", "in", "range", "(", "self", ".", "num_latent_layers", "-", "1", ")", ":", "\n", "                ", "k", "=", "self", ".", "num_pool_layers", "-", "1", "-", "_i", "\n", "self", ".", "hooks", ".", "append", "(", "\n", "self", ".", "up_conv", "[", "_i", "]", ".", "register_forward_hook", "(", "self", ".", "get_latent", "(", "\"D\"", "+", "str", "(", "k", ")", ")", ")", "\n", ")", "\n", "self", ".", "hooks", ".", "append", "(", "\n", "self", ".", "down_sample_layers", "[", "k", "]", ".", "register_forward_hook", "(", "self", ".", "get_latent", "(", "\"E\"", "+", "str", "(", "k", ")", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.remove_hooks": [[186, 189], ["range", "unet.UnetModel.hooks[].remove"], "methods", ["None"], ["", "", "", "def", "remove_hooks", "(", "self", ")", ":", "\n", "        ", "for", "_i", "in", "range", "(", "self", ".", "num_latent_layers", "-", "1", ")", ":", "\n", "            ", "self", ".", "hooks", "[", "_i", "]", ".", "remove", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.get_latent": [[190, 195], ["None"], "methods", ["None"], ["", "", "def", "get_latent", "(", "self", ",", "layer_name", ")", ":", "\n", "        ", "def", "hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "            ", "self", ".", "feats", "[", "layer_name", "]", "=", "output", "\n", "\n", "", "return", "hook", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.visualize_training": [[196, 231], ["meddlr.utils.events.get_event_storage", "torch.no_grad", "meddlr.is_complex", "kspace[].unsqueeze().cpu", "targets[].unsqueeze().cpu", "preds[].unsqueeze().cpu", "zfs[].unsqueeze().cpu", "torch.cat", "imgs_to_write.items", "torch.view_as_real", "meddlr.is_complex", "torch.view_as_complex", "meddlr.angle", "meddlr.abs", "meddlr.abs", "meddlr.get_mask", "torchvision.make_grid.squeeze().unsqueeze", "torchvision.make_grid", "meddlr.utils.events.get_event_storage.put_image", "meddlr.is_complex", "kspace[].unsqueeze", "targets[].unsqueeze", "preds[].unsqueeze", "zfs[].unsqueeze", "torchvision.make_grid.numpy", "torchvision.make_grid.squeeze"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "def", "visualize_training", "(", "self", ",", "kspace", ",", "zfs", ",", "targets", ",", "preds", ")", ":", "\n", "        ", "\"\"\"A function used to visualize reconstructions.\n\n        TODO: Refactor out\n\n        Args:\n            targets: NxHxWx2 tensors of target images.\n            preds: NxHxWx2 tensors of predictions.\n        \"\"\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "cplx", ".", "is_complex", "(", "kspace", ")", ":", "\n", "                ", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "", "if", "cplx", ".", "is_complex", "(", "targets", ")", "and", "not", "cplx", ".", "is_complex", "(", "zfs", ")", ":", "\n", "# Zero-filled needs to be manually converted.", "\n", "                ", "zfs", "=", "torch", ".", "view_as_complex", "(", "zfs", ")", "\n", "", "kspace", "=", "kspace", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "# calc mask for first coil only", "\n", "targets", "=", "targets", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "preds", "=", "preds", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "zfs", "=", "zfs", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "\n", "all_images", "=", "torch", ".", "cat", "(", "[", "zfs", ",", "preds", ",", "targets", "]", ",", "dim", "=", "2", ")", "\n", "\n", "imgs_to_write", "=", "{", "\n", "\"phases\"", ":", "cplx", ".", "angle", "(", "all_images", ")", ",", "\n", "\"images\"", ":", "cplx", ".", "abs", "(", "all_images", ")", ",", "\n", "\"errors\"", ":", "cplx", ".", "abs", "(", "preds", "-", "targets", ")", ",", "\n", "\"masks\"", ":", "cplx", ".", "get_mask", "(", "kspace", ")", ",", "\n", "}", "\n", "\n", "for", "name", ",", "data", "in", "imgs_to_write", ".", "items", "(", ")", ":", "\n", "                ", "data", "=", "data", ".", "squeeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "data", "=", "tv_utils", ".", "make_grid", "(", "data", ",", "nrow", "=", "1", ",", "padding", "=", "1", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", ")", "\n", "storage", ".", "put_image", "(", "\"train/{}\"", ".", "format", "(", "name", ")", ",", "data", ".", "numpy", "(", ")", ",", "data_format", "=", "\"CHW\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.norm": [[232, 244], ["x.view.view.view", "x.view.view.mean().reshape", "x.view.view.std().reshape", "x.view.view.mean", "x.view.view.std"], "methods", ["None"], ["", "", "", "def", "norm", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (torch.Tensor): Input tensor. Shape [B, 2*C, H, W, ...]\n        \"\"\"", "\n", "ndim", "=", "x", ".", "ndim", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "shape", "[", ":", "2", "]", "+", "(", "-", "1", ",", ")", ")", "\n", "\n", "mean", "=", "x", ".", "mean", "(", "dim", "=", "-", "1", ")", ".", "reshape", "(", "x", ".", "shape", "[", ":", "2", "]", "+", "(", "1", ",", ")", "*", "(", "ndim", "-", "2", ")", ")", "\n", "std", "=", "x", ".", "std", "(", "dim", "=", "-", "1", ")", ".", "reshape", "(", "x", ".", "shape", "[", ":", "2", "]", "+", "(", "1", ",", ")", "*", "(", "ndim", "-", "2", ")", ")", "\n", "\n", "return", "(", "x", "-", "mean", ")", "/", "std", ",", "mean", ",", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.unnorm": [[245, 247], ["None"], "methods", ["None"], ["", "def", "unnorm", "(", "self", ",", "x", ",", "mean", ",", "std", ")", ":", "\n", "        ", "return", "x", "*", "std", "+", "mean", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.base_forward": [[248, 295], ["unet.UnetModel.conv", "zip", "unet.UnetModel.norm", "layer", "stack.append", "torch.nn.functional.avg_pool2d", "stack.pop", "transpose_conv", "torch.cat", "conv", "unet.UnetModel.unnorm", "sum", "torch.nn.functional.pad"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.norm", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.unnorm", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad"], ["", "def", "base_forward", "(", "self", ",", "zf_image", ")", ":", "\n", "        ", "\"\"\"The base forward function.\n\n        Args:\n            zf_image (torch.Tensor): Zero-filled image. Shape [B, C, ..., H, W].\n                The real and imaginary channels should be part of the channels\n                dimension if the input is complex and the model does not have\n                complex weights.\n\n        Returns:\n            torch.Tensor: Reconstructed image. Shape [B, C, ..., H, W].\n        \"\"\"", "\n", "x", "=", "zf_image", "\n", "\n", "stack", "=", "[", "]", "\n", "if", "self", ".", "normalize", ":", "\n", "            ", "x", ",", "mean", ",", "std", "=", "self", ".", "norm", "(", "x", ")", "\n", "\n", "# Apply down-sampling layers", "\n", "", "for", "layer", "in", "self", ".", "down_sample_layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "stack", ".", "append", "(", "x", ")", "\n", "x", "=", "F", ".", "avg_pool2d", "(", "x", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ")", "\n", "\n", "", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "\n", "# Apply up-sampling layers", "\n", "for", "transpose_conv", ",", "conv", "in", "zip", "(", "self", ".", "up_transpose_conv", ",", "self", ".", "up_conv", ")", ":", "\n", "            ", "downsample_layer", "=", "stack", ".", "pop", "(", ")", "\n", "x", "=", "transpose_conv", "(", "x", ")", "\n", "\n", "# Reflect pad on the right/botton if needed to handle odd input dimensions.", "\n", "padding", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "if", "x", ".", "shape", "[", "-", "1", "]", "!=", "downsample_layer", ".", "shape", "[", "-", "1", "]", ":", "\n", "                ", "padding", "[", "1", "]", "=", "1", "# Padding right", "\n", "", "if", "x", ".", "shape", "[", "-", "2", "]", "!=", "downsample_layer", ".", "shape", "[", "-", "2", "]", ":", "\n", "                ", "padding", "[", "3", "]", "=", "1", "# Padding bottom", "\n", "", "if", "sum", "(", "padding", ")", "!=", "0", ":", "\n", "                ", "x", "=", "F", ".", "pad", "(", "x", ",", "padding", ",", "\"reflect\"", ")", "\n", "\n", "", "x", "=", "torch", ".", "cat", "(", "[", "x", ",", "downsample_layer", "]", ",", "dim", "=", "1", ")", "\n", "x", "=", "conv", "(", "x", ")", "\n", "\n", "", "if", "self", ".", "normalize", ":", "\n", "            ", "x", "=", "self", ".", "unnorm", "(", "x", ",", "mean", ",", "std", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.forward": [[296, 376], ["unet.UnetModel.register_hooks", "inputs[].to", "inputs[].to", "meddlr.is_complex", "meddlr.is_complex", "torch.view_as_complex.reshape().unsqueeze.permute().squeeze", "unet.UnetModel.base_forward", "all", "unet.UnetModel.remove_hooks", "next", "inputs[].to", "inputs[].to", "inputs[].to", "meddlr.get_mask", "meddlr.forward.mri.SenseModel", "meddlr.forward.mri.SenseModel.", "meddlr.utils.transforms.ifft2", "torch.sqrt", "torch.complex().unsqueeze", "torch.view_as_real", "torch.view_as_complex.reshape().unsqueeze", "torch.view_as_complex.reshape().unsqueeze.permute", "torch.view_as_complex.reshape", "torch.view_as_complex.reshape().unsqueeze.unsqueeze().permute", "torch.view_as_complex", "output_dict.update", "meddlr.utils.events.get_event_storage", "torch.view_as_complex", "unet.UnetModel.parameters", "torch.sum", "torch.view_as_complex.reshape().unsqueeze.permute", "torch.view_as_complex.contiguous", "unet.UnetModel.visualize_training", "torch.complex", "torch.view_as_complex.reshape", "torch.view_as_complex.reshape().unsqueeze.unsqueeze", "meddlr.abs", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.base_forward", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.remove_hooks", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.visualize_training", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "forward", "(", "self", ",", "input", ",", "return_pp", "=", "False", ",", "vis_training", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape [batch_size, self.in_chans, height, width]\n        Returns:\n            (torch.Tensor): Output tensor of shape [batch_size, self.out_chans, height, width]\n        \"\"\"", "\n", "self", ".", "register_hooks", "(", ")", "\n", "\n", "# Need to fetch device at runtime for proper data transfer.", "\n", "inputs", "=", "input", "\n", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "kspace", "=", "inputs", "[", "\"kspace\"", "]", ".", "to", "(", "device", ")", "\n", "target", "=", "inputs", "[", "\"target\"", "]", ".", "to", "(", "device", ")", "if", "\"target\"", "in", "inputs", "else", "None", "\n", "mask", "=", "inputs", "[", "\"mask\"", "]", ".", "to", "(", "device", ")", "if", "\"mask\"", "in", "inputs", "else", "None", "\n", "A", "=", "inputs", "[", "\"signal_model\"", "]", ".", "to", "(", "device", ")", "if", "\"signal_model\"", "in", "inputs", "else", "None", "\n", "maps", "=", "inputs", "[", "\"maps\"", "]", ".", "to", "(", "device", ")", "\n", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "cplx", ".", "get_mask", "(", "kspace", ")", "\n", "", "kspace", "*=", "mask", "\n", "\n", "# Declare signal model.", "\n", "if", "A", "is", "None", ":", "\n", "            ", "A", "=", "SenseModel", "(", "maps", ",", "weights", "=", "mask", ")", "\n", "\n", "# Zero-filled Sense Recon.", "\n", "", "if", "cplx", ".", "is_complex", "(", "maps", ")", ":", "\n", "            ", "zf_image", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "# Zero-filled RSS Recon.", "\n", "", "else", ":", "\n", "            ", "zf_image_init", "=", "T", ".", "ifft2", "(", "kspace", ")", "\n", "zf_image_rss", "=", "torch", ".", "sqrt", "(", "torch", ".", "sum", "(", "cplx", ".", "abs", "(", "zf_image_init", ")", "**", "2", ",", "axis", "=", "-", "1", ")", ")", "\n", "zf_image", "=", "torch", ".", "complex", "(", "zf_image_rss", ",", "torch", ".", "zeros_like", "(", "zf_image_rss", ")", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "", "use_cplx", "=", "cplx", ".", "is_complex", "(", "zf_image", ")", "\n", "if", "use_cplx", ":", "\n", "            ", "zf_image", "=", "torch", ".", "view_as_real", "(", "zf_image", ")", "\n", "\n", "", "num_maps", "=", "zf_image", ".", "shape", "[", "-", "2", "]", "\n", "if", "num_maps", ">", "1", ":", "\n", "            ", "output", "=", "zf_image", ".", "reshape", "(", "zf_image", ".", "shape", "[", ":", "-", "2", "]", "+", "(", "-", "1", ",", ")", ")", ".", "unsqueeze", "(", "-", "2", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "zf_image", "\n", "", "output", "=", "output", ".", "permute", "(", "0", ",", "4", ",", "1", ",", "2", ",", "3", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "# Run U-Net.", "\n", "output", "=", "self", ".", "base_forward", "(", "output", ")", "\n", "\n", "if", "num_maps", ">", "1", ":", "\n", "            ", "pred", "=", "output", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "pred", "=", "pred", ".", "reshape", "(", "pred", ".", "shape", "[", ":", "-", "1", "]", "+", "(", "num_maps", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "pred", "=", "output", ".", "unsqueeze", "(", "-", "1", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", "\n", "\n", "", "if", "use_cplx", ":", "\n", "            ", "pred", "=", "torch", ".", "view_as_complex", "(", "pred", ".", "contiguous", "(", ")", ")", "\n", "\n", "", "output_dict", "=", "{", "\"pred\"", ":", "pred", ",", "\"target\"", ":", "target", "}", "# N x Y x Z x 1 (x 2)  # N x Y x Z x 1 (x 2)", "\n", "\n", "if", "return_pp", ":", "\n", "            ", "output_dict", ".", "update", "(", "{", "k", ":", "inputs", "[", "k", "]", "for", "k", "in", "[", "\"mean\"", ",", "\"std\"", ",", "\"norm\"", "]", "}", ")", "\n", "\n", "# TODO (arjundd): Figure out why this is needed during SSDU training.", "\n", "", "images_available", "=", "all", "(", "x", "is", "not", "None", "for", "x", "in", "[", "kspace", ",", "zf_image", ",", "target", ",", "pred", "]", ")", "\n", "if", "images_available", "and", "self", ".", "training", "and", "(", "vis_training", "or", "self", ".", "vis_period", ">", "0", ")", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "vis_training", "or", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "self", ".", "visualize_training", "(", "kspace", ",", "zf_image", ",", "target", ",", "pred", ")", "\n", "\n", "", "", "if", "use_cplx", ":", "\n", "            ", "zf_image", "=", "torch", ".", "view_as_complex", "(", "zf_image", ")", "\n", "", "output_dict", "[", "\"zf_image\"", "]", "=", "zf_image", "\n", "\n", "if", "self", ".", "use_latent", ":", "\n", "            ", "output_dict", "[", "\"latent\"", "]", "=", "self", ".", "feats", "\n", "\n", "", "self", ".", "remove_hooks", "(", ")", "\n", "\n", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.from_config": [[377, 389], ["cfg.get_recursive", "cfg.get_recursive"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.get_recursive", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.get_recursive"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "return", "{", "\n", "\"in_channels\"", ":", "cfg", ".", "MODEL", ".", "UNET", ".", "IN_CHANNELS", ",", "\n", "\"out_channels\"", ":", "cfg", ".", "MODEL", ".", "UNET", ".", "OUT_CHANNELS", ",", "\n", "\"channels\"", ":", "cfg", ".", "MODEL", ".", "UNET", ".", "CHANNELS", ",", "\n", "\"num_pool_layers\"", ":", "cfg", ".", "MODEL", ".", "UNET", ".", "NUM_POOL_LAYERS", ",", "\n", "\"dropout\"", ":", "cfg", ".", "MODEL", ".", "UNET", ".", "DROPOUT", ",", "\n", "\"use_latent\"", ":", "cfg", ".", "get_recursive", "(", "\"MODEL.CONSISTENCY.USE_LATENT\"", ",", "False", ")", ",", "\n", "\"num_latent_layers\"", ":", "cfg", ".", "get_recursive", "(", "\"MODEL.CONSISTENCY.NUM_LATENT_LAYERS\"", ",", "1", ")", ",", "\n", "\"normalize\"", ":", "cfg", ".", "MODEL", ".", "UNET", ".", "NORMALIZE", ",", "\n", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.vortex.VortexModel.__init__": [[34, 63], ["torch.nn.Module.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "nn", ".", "Module", ",", "\n", "augmentor", ":", "MRIReconAugmentor", ",", "\n", "use_supervised_consistency", ":", "bool", "=", "False", ",", "\n", "vis_period", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            model (nn.Module): The base model.\n            augmentor (MRIReconAugmentor): The augmentation module.\n            use_supervised_consistency (bool, optional): If ``True``, use consistency\n                with supervised examples too.\n            vis_period (int, optional): The period over which to visualize images.\n                If ``<=0``, it is ignored. Note if the ``model`` has a ``vis_period``\n                attribute, it will be overridden so that this class handles visualization.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "augmentor", "=", "augmentor", "\n", "self", ".", "use_base_grad", "=", "False", "# Keep gradient for base images in transform.", "\n", "self", ".", "use_supervised_consistency", "=", "use_supervised_consistency", "\n", "\n", "# Visualization done by this model", "\n", "if", "hasattr", "(", "model", ",", "\"vis_period\"", ")", "and", "vis_period", ">", "0", ":", "\n", "            ", "self", ".", "model", ".", "vis_period", "=", "-", "1", "\n", "", "self", ".", "vis_period", "=", "vis_period", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.vortex.VortexModel.augment": [[64, 80], ["meddlr.utils.general.move_to_device", "meddlr.utils.general.move_to_device", "vortex.VortexModel.augmentor", "inputs[].clone", "inputs[].clone", "isinstance", "v.clone", "meddlr.utils.general.move_to_device.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device", "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "augment", "(", "self", ",", "inputs", ",", "pred_base", ")", ":", "\n", "        ", "inputs", "=", "move_to_device", "(", "inputs", ",", "device", "=", "\"cuda\"", ")", "\n", "pred_base", "=", "move_to_device", "(", "pred_base", ",", "device", "=", "\"cuda\"", ")", "\n", "kspace", ",", "maps", "=", "inputs", "[", "\"kspace\"", "]", ".", "clone", "(", ")", ",", "inputs", "[", "\"maps\"", "]", ".", "clone", "(", ")", "\n", "\n", "out", ",", "_", ",", "_", "=", "self", ".", "augmentor", "(", "kspace", ",", "maps", ",", "pred_base", ",", "mask", "=", "True", ")", "\n", "\n", "inputs", "=", "{", "\n", "k", ":", "v", ".", "clone", "(", ")", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", "else", "v", "\n", "for", "k", ",", "v", "in", "inputs", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "(", "\"kspace\"", ",", "\"maps\"", ")", "\n", "}", "\n", "inputs", "[", "\"kspace\"", "]", "=", "out", "[", "\"kspace\"", "]", "\n", "inputs", "[", "\"maps\"", "]", "=", "out", "[", "\"maps\"", "]", "\n", "aug_pred_base", "=", "out", "[", "\"target\"", "]", "\n", "return", "inputs", ",", "aug_pred_base", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.vortex.VortexModel.visualize_aug_training": [[81, 126], ["meddlr.utils.events.get_event_storage", "torch.no_grad", "meddlr.ops.complex.is_complex", "[].unsqueeze", "meddlr.ops.complex.is_complex", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "torch.cat", "torch.cat", "torch.cat", "imgs_to_write.items", "torch.view_as_real", "torch.view_as_real", "meddlr.ops.complex.abs", "[].unsqueeze", "torch.cat.append", "torch.cat.append", "meddlr.ops.complex.angle", "meddlr.ops.complex.abs", "meddlr.ops.complex.get_mask", "meddlr.ops.complex.abs", "torchvision.make_grid.squeeze().unsqueeze", "torchvision.make_grid", "meddlr.utils.events.get_event_storage.put_image", "meddlr.ops.complex.abs", "torchvision.make_grid.numpy", "torch.view_as_real.cpu", "torch.view_as_real.cpu", "[].unsqueeze.cpu", "[].unsqueeze.cpu", "torchvision.make_grid.squeeze", "[].unsqueeze.cpu"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "def", "visualize_aug_training", "(", "self", ",", "kspace", ",", "kspace_aug", ",", "preds", ",", "preds_base", ",", "target", "=", "None", ")", ":", "\n", "        ", "\"\"\"Visualize training of augmented data.\n\n        Args:\n            kspace: The base kspace.\n            kspace_aug: The augmented kspace.\n            preds: Reconstruction of augmented kspace. Shape: NxHxWx2.\n            preds_base: Reconstruction of base kspace. Shape: NxHxWx2.\n        \"\"\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# calc mask for first coil only", "\n", "            ", "if", "cplx", ".", "is_complex", "(", "kspace", ")", ":", "\n", "                ", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "", "kspace", "=", "kspace", ".", "cpu", "(", ")", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "if", "cplx", ".", "is_complex", "(", "kspace_aug", ")", ":", "\n", "                ", "kspace_aug", "=", "torch", ".", "view_as_real", "(", "kspace_aug", ")", "\n", "", "kspace_aug", "=", "kspace_aug", ".", "cpu", "(", ")", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "preds", "=", "preds", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "preds_base", "=", "preds_base", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "all_images", "=", "[", "preds", ",", "preds_base", "]", "\n", "errors", "=", "[", "cplx", ".", "abs", "(", "preds_base", "-", "preds", ")", "]", "\n", "if", "target", "is", "not", "None", ":", "\n", "                ", "target", "=", "target", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "all_images", ".", "append", "(", "target", ")", "\n", "errors", ".", "append", "(", "cplx", ".", "abs", "(", "target", "-", "preds", ")", ")", "\n", "\n", "", "all_images", "=", "torch", ".", "cat", "(", "all_images", ",", "dim", "=", "2", ")", "\n", "all_kspace", "=", "torch", ".", "cat", "(", "[", "kspace", ",", "kspace_aug", "]", ",", "dim", "=", "2", ")", "\n", "errors", "=", "torch", ".", "cat", "(", "errors", ",", "dim", "=", "2", ")", "\n", "\n", "imgs_to_write", "=", "{", "\n", "\"phases\"", ":", "cplx", ".", "angle", "(", "all_images", ")", ",", "\n", "\"images\"", ":", "cplx", ".", "abs", "(", "all_images", ")", ",", "\n", "\"errors\"", ":", "errors", ",", "\n", "\"masks\"", ":", "cplx", ".", "get_mask", "(", "kspace", ")", ",", "\n", "\"kspace\"", ":", "cplx", ".", "abs", "(", "all_kspace", ")", ",", "\n", "}", "\n", "\n", "for", "name", ",", "data", "in", "imgs_to_write", ".", "items", "(", ")", ":", "\n", "                ", "data", "=", "data", ".", "squeeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "data", "=", "tv_utils", ".", "make_grid", "(", "data", ",", "nrow", "=", "1", ",", "padding", "=", "1", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", ")", "\n", "storage", ".", "put_image", "(", "\"train_aug/{}\"", ".", "format", "(", "name", ")", ",", "data", ".", "numpy", "(", ")", ",", "data_format", "=", "\"CHW\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.vortex.VortexModel.forward": [[127, 191], ["inputs.get.get.get", "inputs.get.get.get", "inputs.get.get.get", "vortex.VortexModel.model", "meddlr.utils.events.get_event_storage", "ValueError", "vortex.VortexModel.model", "inputs_consistency.append", "inputs_consistency.append", "len", "vortex.VortexModel.augment", "vortex.VortexModel.model", "vortex.VortexModel.detach", "len", "torch.no_grad", "vortex.VortexModel.model", "inputs.get.get.get", "vortex.VortexModel.visualize_aug_training", "torch.cat", "inputs.get.get.items", "inputs_consistency[].keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.visualize_aug_training", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "not", "self", ".", "training", ":", "\n", "            ", "assert", "(", "\n", "\"unsupervised\"", "not", "in", "inputs", "\n", ")", ",", "\"unsupervised inputs should not be provided in eval mode\"", "\n", "inputs", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "inputs", ")", "\n", "return", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "", "vis_training", "=", "False", "\n", "if", "self", ".", "training", "and", "self", ".", "vis_period", ">", "0", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "vis_training", "=", "True", "\n", "\n", "", "", "inputs_supervised", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "None", ")", "\n", "inputs_unsupervised", "=", "inputs", ".", "get", "(", "\"unsupervised\"", ",", "None", ")", "\n", "if", "inputs_supervised", "is", "None", "and", "inputs_unsupervised", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Examples not formatted in the proper way\"", ")", "\n", "", "output_dict", "=", "{", "}", "\n", "\n", "# Recon", "\n", "if", "inputs_supervised", "is", "not", "None", ":", "\n", "            ", "output_dict", "[", "\"recon\"", "]", "=", "self", ".", "model", "(", "\n", "inputs_supervised", ",", "return_pp", "=", "True", ",", "vis_training", "=", "vis_training", "\n", ")", "\n", "\n", "# Consistency.", "\n", "# kspace_aug = kspace + U \\sigma \\mathcal{N}", "\n", "# Loss = L(f(Ti(Te(kspace)), \\theta), Te(f(kspace, \\theta)))", "\n", "", "inputs_consistency", "=", "[", "]", "\n", "if", "inputs_unsupervised", "is", "not", "None", ":", "\n", "            ", "inputs_consistency", ".", "append", "(", "inputs_unsupervised", ")", "\n", "", "if", "self", ".", "use_supervised_consistency", "and", "inputs_supervised", "is", "not", "None", ":", "\n", "            ", "inputs_consistency", ".", "append", "(", "{", "k", ":", "v", "for", "k", ",", "v", "in", "inputs_supervised", ".", "items", "(", ")", "if", "k", "!=", "\"target\"", "}", ")", "\n", "\n", "", "if", "len", "(", "inputs_consistency", ")", ">", "0", ":", "\n", "            ", "if", "len", "(", "inputs_consistency", ")", ">", "1", ":", "\n", "                ", "inputs_consistency", "=", "{", "\n", "k", ":", "torch", ".", "cat", "(", "[", "x", "[", "k", "]", "for", "x", "in", "inputs_consistency", "]", ",", "dim", "=", "0", ")", "\n", "for", "k", "in", "inputs_consistency", "[", "0", "]", ".", "keys", "(", ")", "\n", "}", "\n", "", "else", ":", "\n", "                ", "inputs_consistency", "=", "inputs_consistency", "[", "0", "]", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "pred_base", "=", "self", ".", "model", "(", "inputs_consistency", ")", "\n", "# Target only used for visualization purposes not for loss.", "\n", "target", "=", "inputs_unsupervised", ".", "get", "(", "\"target\"", ",", "None", ")", "\n", "pred_base", "=", "pred_base", "[", "\"pred\"", "]", "\n", "", "inputs_consistency_aug", ",", "pred_base", "=", "self", ".", "augment", "(", "inputs_consistency", ",", "pred_base", ")", "\n", "pred_aug", "=", "self", ".", "model", "(", "inputs_consistency_aug", ",", "return_pp", "=", "True", ")", "\n", "if", "\"target\"", "in", "pred_aug", ":", "\n", "                ", "del", "pred_aug", "[", "\"target\"", "]", "\n", "", "pred_aug", "[", "\"target\"", "]", "=", "pred_base", ".", "detach", "(", ")", "\n", "output_dict", "[", "\"consistency\"", "]", "=", "pred_aug", "\n", "if", "vis_training", ":", "\n", "                ", "self", ".", "visualize_aug_training", "(", "\n", "inputs_consistency", "[", "\"kspace\"", "]", ",", "\n", "inputs_consistency_aug", "[", "\"kspace\"", "]", ",", "\n", "pred_aug", "[", "\"pred\"", "]", ",", "\n", "pred_base", ",", "\n", "target", "=", "target", ",", "\n", ")", "\n", "\n", "", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.vortex.VortexModel.from_config": [[192, 212], ["logging.getLogger", "cfg.clone", "cfg.clone.defrost", "cfg.clone.freeze", "meddlr.modeling.meta_arch.build.build_model", "meddlr.transforms.builtin.mri.MRIReconAugmentor.from_cfg", "logging.getLogger.info", "str"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "model_cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "model_cfg", ".", "defrost", "(", ")", "\n", "model_cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "=", "cfg", ".", "MODEL", ".", "A2R", ".", "META_ARCHITECTURE", "\n", "model_cfg", ".", "freeze", "(", ")", "\n", "model", "=", "build_model", "(", "model_cfg", ")", "\n", "\n", "augmentor", "=", "MRIReconAugmentor", ".", "from_cfg", "(", "\n", "cfg", ",", "aug_kind", "=", "\"consistency\"", ",", "device", "=", "cfg", ".", "MODEL", ".", "DEVICE", ",", "seed", "=", "cfg", ".", "SEED", "\n", ")", "\n", "_logger", ".", "info", "(", "\"Built augmentor:\\n{}\"", ".", "format", "(", "str", "(", "augmentor", ".", "tfms_or_gens", ")", ")", ")", "\n", "\n", "return", "{", "\n", "\"model\"", ":", "model", ",", "\n", "\"augmentor\"", ":", "augmentor", ",", "\n", "\"use_supervised_consistency\"", ":", "cfg", ".", "MODEL", ".", "A2R", ".", "USE_SUPERVISED_CONSISTENCY", ",", "\n", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build.build_model": [[23, 30], ["META_ARCH_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "return", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build.initialize_model": [[32, 163], ["isinstance", "build._to_literal", "any", "list", "isinstance", "all", "ValueError", "init_cfg.pop", "init_cfg.pop", "tuple", "build._get_model_layers", "model.named_parameters", "logger.warning", "any", "isinstance", "isinstance", "len", "len", "ValueError", "patterns_to_initializers.items", "matched_patterns.items", "len", "zip", "isinstance", "isinstance", "getattr", "zip", "logger.warning", "any", "isinstance", "isinstance", "isinstance", "len", "len", "isinstance", "layer.named_parameters", "isinstance", "type", "isinstance", "isinstance", "getattr", "re.match", "v", "str", "model.named_parameters", "len", "isinstance", "type"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build._to_literal", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build._get_model_layers", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "initialize_model", "(", "model", ":", "nn", ".", "Module", ",", "initializers", ":", "Union", "[", "Dict", ",", "Tuple", "]", ")", ":", "\n", "    ", "\"\"\"Initialize the model.\n\n    This function initializes the model using the initialization method\n    specified in ``initializers``.\n\n    ``initializers`` should be a sequence of dicts, where each dict\n    defines the layer type (optional), regex pattern of the parameter\n    name (optional), or the dict. The dict has the following keys:\n\n        * 'kind' (str, optional): The layer kind to apply this (e.g. 'conv', 'norm')\n        * 'patterns' (Tuple[str] | str, optional): The regex patterns of the\n                parameters to use initializer on. If not specified, all parameters\n                of\n        * 'initializers' (Sequence[Callable | str]): The initializers to use on the\n                parameters. These should be called as ``initializer(param)``.\n                These values should be 1:1 with the values in ``'patterns'``.\n\n    Args:\n        model (nn.Model): The model to initialize. Parameters will be fetched\n            with ``model.named_parameters()``.\n        initializers (Dict[str, Union[str, Callable]] | Tuple[str]):\n            See above.\n    \"\"\"", "\n", "_kind_kwd", "=", "\"kind\"", "\n", "_pattern_kwd", "=", "\"patterns\"", "\n", "_init_kwd", "=", "\"initializers\"", "\n", "\n", "if", "isinstance", "(", "initializers", ",", "Dict", ")", ":", "\n", "        ", "initializers", "=", "[", "initializers", "]", "\n", "\n", "# Backwards compatibility with pattern-only initialization.", "\n", "", "if", "isinstance", "(", "initializers", ",", "Sequence", ")", "and", "not", "any", "(", "isinstance", "(", "x", ",", "Dict", ")", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "assert", "len", "(", "initializers", ")", "%", "2", "==", "0", ",", "\"Sequence of regex_to_init must be even\"", "\n", "initializers", "=", "[", "\n", "{", "_pattern_kwd", ":", "k", ",", "_init_kwd", ":", "v", "}", "for", "k", ",", "v", "in", "zip", "(", "initializers", "[", ":", ":", "2", "]", ",", "initializers", "[", "1", ":", ":", "2", "]", ")", "\n", "]", "\n", "\n", "# Convert string values to python literals.", "\n", "", "initializers", "=", "_to_literal", "(", "initializers", ")", "\n", "\n", "if", "not", "all", "(", "\n", "isinstance", "(", "x", ",", "Dict", ")", "or", "(", "isinstance", "(", "x", ",", "Sequence", ")", "and", "len", "(", "x", ")", "==", "2", ")", "for", "x", "in", "initializers", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"All initializers must either be a dict or sequence of 2 elements \"", "\n", "\"(pattern, initializer). Got:\\n\\t{}\"", ".", "format", "(", "initializers", ")", "\n", ")", "\n", "\n", "", "initializers", ":", "List", "[", "Dict", "]", "=", "[", "\n", "{", "_pattern_kwd", ":", "x", "[", "0", "]", ",", "_init_kwd", ":", "x", "[", "1", "]", "}", "if", "isinstance", "(", "x", ",", "Sequence", ")", "else", "x", "\n", "for", "x", "in", "initializers", "\n", "]", "\n", "matched_patterns", "=", "{", "}", "\n", "for", "init_cfg", "in", "initializers", ":", "\n", "        ", "pattern", "=", "init_cfg", ".", "pop", "(", "_pattern_kwd", ",", "None", ")", "\n", "if", "pattern", "is", "None", ":", "\n", "            ", "pattern", "=", "(", "\".*\"", ",", ")", "\n", "", "elif", "not", "isinstance", "(", "pattern", ",", "Sequence", ")", "or", "isinstance", "(", "pattern", ",", "str", ")", ":", "\n", "            ", "pattern", "=", "(", "pattern", ",", ")", "\n", "\n", "", "init_method", "=", "init_cfg", ".", "pop", "(", "_init_kwd", ")", "\n", "if", "not", "isinstance", "(", "init_method", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "init_method", "=", "(", "init_method", ",", ")", "\n", "\n", "", "if", "len", "(", "pattern", ")", "!=", "len", "(", "init_method", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Got {} pattern(s) but {} initializer(s):\\n\\t\"", "\n", "\"Patterns: {}\\n\\tInitializers: {}\"", ".", "format", "(", "\n", "len", "(", "pattern", ")", ",", "len", "(", "init_method", ")", ",", "pattern", ",", "init_method", "\n", ")", "\n", ")", "\n", "\n", "", "pattern", "=", "tuple", "(", "\n", "(", "p", ",", ")", "if", "not", "isinstance", "(", "p", ",", "Sequence", ")", "or", "isinstance", "(", "p", ",", "str", ")", "else", "p", "for", "p", "in", "pattern", "\n", ")", "\n", "\n", "init_method", "=", "[", "\n", "getattr", "(", "nn", ".", "init", ",", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "str", ")", "\n", "else", "(", "getattr", "(", "nn", ".", "init", ",", "v", "[", "0", "]", ")", ",", "v", "[", "1", "]", ")", "\n", "if", "isinstance", "(", "v", ",", "Sequence", ")", "\n", "else", "v", "\n", "for", "v", "in", "init_method", "\n", "]", "\n", "init_cfg", "[", "_init_kwd", "]", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "pattern", ",", "init_method", ")", "}", "\n", "for", "pattern_val", "in", "pattern", ":", "\n", "            ", "key", "=", "(", "init_cfg", "[", "_kind_kwd", "]", ",", "pattern_val", ")", "if", "_kind_kwd", "in", "init_cfg", "else", "pattern_val", "\n", "matched_patterns", "[", "key", "]", "=", "False", "\n", "\n", "", "", "model_layers", "=", "{", "}", "\n", "if", "any", "(", "_kind_kwd", "in", "x", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "model_layers", ":", "Dict", "[", "str", ",", "nn", ".", "Module", "]", "=", "_get_model_layers", "(", "model", ",", "by_kind", "=", "True", ")", "\n", "", "named_parameters", "=", "list", "(", "model", ".", "named_parameters", "(", ")", ")", "\n", "\n", "# Initialize parameters", "\n", "for", "init_cfg", "in", "initializers", ":", "\n", "        ", "layer_kind", "=", "\"\"", "\n", "if", "_kind_kwd", "in", "init_cfg", ":", "\n", "            ", "layer_kind", "=", "init_cfg", "[", "_kind_kwd", "]", "\n", "if", "layer_kind", "not", "in", "model_layers", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "f\"Layer kind '{layer_kind}' not found in model {type(model).__name__}\"", "\n", ")", "\n", "continue", "\n", "", "parameters", "=", "[", "\n", "named_param", "\n", "for", "layer", "in", "model_layers", "[", "layer_kind", "]", "\n", "for", "named_param", "in", "layer", ".", "named_parameters", "(", ")", "\n", "]", "\n", "", "else", ":", "\n", "            ", "parameters", "=", "named_parameters", "\n", "\n", "", "patterns_to_initializers", "=", "init_cfg", "[", "_init_kwd", "]", "\n", "for", "name", ",", "param", "in", "parameters", ":", "\n", "            ", "for", "patterns", ",", "v", "in", "patterns_to_initializers", ".", "items", "(", ")", ":", "\n", "                ", "if", "any", "(", "re", ".", "match", "(", "k", ",", "name", ")", "for", "k", "in", "patterns", ")", ":", "\n", "                    ", "matched_patterns", "[", "(", "layer_kind", ",", "patterns", ")", "if", "layer_kind", "else", "patterns", "]", "=", "True", "\n", "if", "isinstance", "(", "v", ",", "tuple", ")", ":", "\n", "                        ", "v", "[", "0", "]", "(", "param", ",", "**", "v", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                        ", "v", "(", "param", ")", "\n", "\n", "", "", "", "", "", "unmatched_patterns", "=", "[", "k", "for", "k", ",", "v", "in", "matched_patterns", ".", "items", "(", ")", "if", "not", "v", "]", "\n", "if", "unmatched_patterns", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"No matches found for these patterns when initialing model '{}':\"", "\n", "\"\\n\\t- {}\\nCheck the model's named parameters: {}\\n\"", ".", "format", "(", "\n", "type", "(", "model", ")", ".", "__name__", ",", "\n", "\"\\n\\t- \"", ".", "join", "(", "str", "(", "x", ")", "for", "x", "in", "unmatched_patterns", ")", ",", "\n", "[", "x", "[", "0", "]", "for", "x", "in", "model", ".", "named_parameters", "(", ")", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build._get_model_layers": [[167, 189], ["model.modules", "module.children", "collections.defaultdict", "layers.append", "layers_by_kind[].append", "meddlr.modeling.layers.build.get_layer_kind", "type"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_kind"], ["", "", "def", "_get_model_layers", "(", "model", ",", "by_kind", "=", "False", ")", ":", "\n", "    ", "\"\"\"Get all layers of a model.\n\n    A layer is defined as a ``nn.Module`` that does not have\n    any children.\n    \"\"\"", "\n", "modules", "=", "model", ".", "modules", "(", ")", "\n", "layers", "=", "[", "]", "\n", "for", "module", "in", "modules", ":", "\n", "        ", "has_children", "=", "False", "\n", "for", "_", "in", "module", ".", "children", "(", ")", ":", "\n", "            ", "has_children", "=", "True", "\n", "break", "\n", "", "if", "not", "has_children", ":", "\n", "            ", "layers", ".", "append", "(", "module", ")", "\n", "\n", "", "", "if", "by_kind", ":", "\n", "        ", "layers_by_kind", "=", "defaultdict", "(", "list", ")", "\n", "for", "layer", "in", "layers", ":", "\n", "            ", "layers_by_kind", "[", "get_layer_kind", "(", "type", "(", "layer", ")", ")", "]", ".", "append", "(", "layer", ")", "\n", "", "return", "layers_by_kind", "\n", "", "return", "layers", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build._to_literal": [[191, 208], ["isinstance", "any", "isinstance", "isinstance", "ast.literal_eval", "build._to_literal", "build._to_literal", "x.startswith", "x.endswith", "x.items", "type", "build._to_literal"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build._to_literal", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build._to_literal", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build._to_literal"], ["", "def", "_to_literal", "(", "x", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "str", ")", ":", "\n", "        ", "v", "=", "x", "\n", "if", "any", "(", "\n", "x", ".", "startswith", "(", "c1", ")", "and", "x", ".", "endswith", "(", "c2", ")", "for", "c1", ",", "c2", "in", "[", "(", "\"(\"", ",", "\")\"", ")", ",", "(", "\"[\"", ",", "\"]\"", ")", ",", "(", "\"{\"", ",", "\"}\"", ")", "]", "\n", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "v", "=", "ast", ".", "literal_eval", "(", "v", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "pass", "\n", "", "", "return", "v", "\n", "", "elif", "isinstance", "(", "x", ",", "Dict", ")", ":", "\n", "        ", "return", "{", "_to_literal", "(", "k", ")", ":", "_to_literal", "(", "v", ")", "for", "k", ",", "v", "in", "x", ".", "items", "(", ")", "}", "\n", "", "elif", "isinstance", "(", "x", ",", "Sequence", ")", ":", "\n", "        ", "return", "type", "(", "x", ")", "(", "_to_literal", "(", "v", ")", "for", "v", "in", "x", ")", "\n", "", "else", ":", "\n", "        ", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.m2r.M2RModel.__init__": [[23, 44], ["torch.nn.Module.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "nn", ".", "Module", ",", "\n", "augmentor", ":", "MotionModel", ",", "\n", "use_supervised_consistency", ":", "bool", "=", "False", ",", "\n", "vis_period", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "\n", "# Visualization done by this model", "\n", "if", "hasattr", "(", "self", ".", "model", ",", "\"vis_period\"", ")", "and", "vis_period", ">", "0", ":", "\n", "            ", "self", ".", "model", ".", "vis_period", "=", "-", "1", "\n", "", "self", ".", "vis_period", "=", "vis_period", "\n", "\n", "# Keep gradient for base images in transform.", "\n", "self", ".", "use_base_grad", "=", "False", "\n", "# Use supervised examples for consistency", "\n", "self", ".", "use_supervised_consistency", "=", "use_supervised_consistency", "\n", "self", ".", "augmentor", "=", "augmentor", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.m2r.M2RModel.augment": [[45, 55], ["inputs[].clone", "m2r.M2RModel.augmentor", "v.clone", "inputs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "augment", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Motion augmentation module.\n        TODO: Perform the augmentation here.\n        \"\"\"", "\n", "kspace", "=", "inputs", "[", "\"kspace\"", "]", ".", "clone", "(", ")", "\n", "aug_kspace", "=", "self", ".", "augmentor", "(", "kspace", ",", "clone", "=", "False", ")", "\n", "\n", "inputs", "=", "{", "k", ":", "v", ".", "clone", "(", ")", "for", "k", ",", "v", "in", "inputs", ".", "items", "(", ")", "if", "k", "!=", "\"kspace\"", "}", "\n", "inputs", "[", "\"kspace\"", "]", "=", "aug_kspace", "\n", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.m2r.M2RModel.visualize_aug_training": [[56, 101], ["meddlr.utils.events.get_event_storage", "torch.no_grad", "meddlr.ops.complex.is_complex", "[].unsqueeze", "meddlr.ops.complex.is_complex", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "torch.cat", "torch.cat", "torch.cat", "imgs_to_write.items", "torch.view_as_real", "torch.view_as_real", "meddlr.ops.complex.abs", "[].unsqueeze", "torch.cat.append", "torch.cat.append", "meddlr.ops.complex.angle", "meddlr.ops.complex.abs", "meddlr.ops.complex.get_mask", "meddlr.ops.complex.abs", "torchvision.make_grid.squeeze().unsqueeze", "torchvision.make_grid", "meddlr.utils.events.get_event_storage.put_image", "meddlr.ops.complex.abs", "torchvision.make_grid.numpy", "torch.view_as_real.cpu", "torch.view_as_real.cpu", "[].unsqueeze.cpu", "[].unsqueeze.cpu", "torchvision.make_grid.squeeze", "[].unsqueeze.cpu"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "def", "visualize_aug_training", "(", "self", ",", "kspace", ",", "kspace_aug", ",", "preds", ",", "preds_base", ",", "target", "=", "None", ")", ":", "\n", "        ", "\"\"\"Visualize training of augmented data.\n\n        Args:\n            kspace: The base kspace.\n            kspace_aug: The augmented kspace.\n            preds: Reconstruction of augmented kspace. Shape: NxHxWx2.\n            preds_base: Reconstruction of base kspace. Shape: NxHxWx2.\n        \"\"\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# calc mask for first coil only", "\n", "            ", "if", "cplx", ".", "is_complex", "(", "kspace", ")", ":", "\n", "                ", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "", "kspace", "=", "kspace", ".", "cpu", "(", ")", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "if", "cplx", ".", "is_complex", "(", "kspace_aug", ")", ":", "\n", "                ", "kspace_aug", "=", "torch", ".", "view_as_real", "(", "kspace_aug", ")", "\n", "", "kspace_aug", "=", "kspace_aug", ".", "cpu", "(", ")", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "preds", "=", "preds", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "preds_base", "=", "preds_base", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "all_images", "=", "[", "preds", ",", "preds_base", "]", "\n", "errors", "=", "[", "cplx", ".", "abs", "(", "preds_base", "-", "preds", ")", "]", "\n", "if", "target", "is", "not", "None", ":", "\n", "                ", "target", "=", "target", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "all_images", ".", "append", "(", "target", ")", "\n", "errors", ".", "append", "(", "cplx", ".", "abs", "(", "target", "-", "preds", ")", ")", "\n", "\n", "", "all_images", "=", "torch", ".", "cat", "(", "all_images", ",", "dim", "=", "2", ")", "\n", "all_kspace", "=", "torch", ".", "cat", "(", "[", "kspace", ",", "kspace_aug", "]", ",", "dim", "=", "2", ")", "\n", "errors", "=", "torch", ".", "cat", "(", "errors", ",", "dim", "=", "2", ")", "\n", "\n", "imgs_to_write", "=", "{", "\n", "\"phases\"", ":", "cplx", ".", "angle", "(", "all_images", ")", ",", "\n", "\"images\"", ":", "cplx", ".", "abs", "(", "all_images", ")", ",", "\n", "\"errors\"", ":", "errors", ",", "\n", "\"masks\"", ":", "cplx", ".", "get_mask", "(", "kspace", ")", ",", "\n", "\"kspace\"", ":", "cplx", ".", "abs", "(", "all_kspace", ")", ",", "\n", "}", "\n", "\n", "for", "name", ",", "data", "in", "imgs_to_write", ".", "items", "(", ")", ":", "\n", "                ", "data", "=", "data", ".", "squeeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "data", "=", "tv_utils", ".", "make_grid", "(", "data", ",", "nrow", "=", "1", ",", "padding", "=", "1", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", ")", "\n", "storage", ".", "put_image", "(", "\"train_aug/{}\"", ".", "format", "(", "name", ")", ",", "data", ".", "numpy", "(", ")", ",", "data_format", "=", "\"CHW\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.m2r.M2RModel.forward": [[102, 166], ["inputs.get.get.get", "inputs.get.get.get", "inputs.get.get.get", "m2r.M2RModel.model", "meddlr.utils.events.get_event_storage", "ValueError", "m2r.M2RModel.model", "inputs_consistency.append", "inputs_consistency.append", "len", "m2r.M2RModel.augment", "m2r.M2RModel.model", "m2r.M2RModel.detach", "len", "torch.no_grad", "m2r.M2RModel.model", "inputs.get.get.get", "m2r.M2RModel.visualize_aug_training", "torch.cat", "inputs.get.get.items", "inputs_consistency[].keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.visualize_aug_training", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "not", "self", ".", "training", ":", "\n", "            ", "assert", "(", "\n", "\"unsupervised\"", "not", "in", "inputs", "\n", ")", ",", "\"unsupervised inputs should not be provided in eval mode\"", "\n", "inputs", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "inputs", ")", "\n", "return", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "", "vis_training", "=", "False", "\n", "if", "self", ".", "training", "and", "self", ".", "vis_period", ">", "0", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "vis_training", "=", "True", "\n", "\n", "", "", "inputs_supervised", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "None", ")", "\n", "inputs_unsupervised", "=", "inputs", ".", "get", "(", "\"unsupervised\"", ",", "None", ")", "\n", "if", "inputs_supervised", "is", "None", "and", "inputs_unsupervised", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Examples not formatted in the proper way\"", ")", "\n", "", "output_dict", "=", "{", "}", "\n", "\n", "# Recon", "\n", "if", "inputs_supervised", "is", "not", "None", ":", "\n", "            ", "output_dict", "[", "\"recon\"", "]", "=", "self", ".", "model", "(", "\n", "inputs_supervised", ",", "return_pp", "=", "True", ",", "vis_training", "=", "vis_training", "\n", ")", "\n", "\n", "# Consistency.", "\n", "# kspace_aug = kspace + U \\sigma \\mathcal{N}", "\n", "# Loss = L(f(kspace_aug, \\theta), f(kspace, \\theta))", "\n", "", "inputs_consistency", "=", "[", "]", "\n", "if", "inputs_unsupervised", "is", "not", "None", ":", "\n", "            ", "inputs_consistency", ".", "append", "(", "inputs_unsupervised", ")", "\n", "", "if", "self", ".", "use_supervised_consistency", "and", "inputs_supervised", "is", "not", "None", ":", "\n", "            ", "inputs_consistency", ".", "append", "(", "{", "k", ":", "v", "for", "k", ",", "v", "in", "inputs_supervised", ".", "items", "(", ")", "if", "k", "!=", "\"target\"", "}", ")", "\n", "\n", "", "if", "len", "(", "inputs_consistency", ")", ">", "0", ":", "\n", "            ", "if", "len", "(", "inputs_consistency", ")", ">", "1", ":", "\n", "                ", "inputs_consistency", "=", "{", "\n", "k", ":", "torch", ".", "cat", "(", "[", "x", "[", "k", "]", "for", "x", "in", "inputs_consistency", "]", ",", "dim", "=", "0", ")", "\n", "for", "k", "in", "inputs_consistency", "[", "0", "]", ".", "keys", "(", ")", "\n", "}", "\n", "", "else", ":", "\n", "                ", "inputs_consistency", "=", "inputs_consistency", "[", "0", "]", "\n", "", "inputs_consistency_aug", "=", "self", ".", "augment", "(", "inputs_consistency", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "pred_base", "=", "self", ".", "model", "(", "inputs_consistency", ")", "\n", "# Target only used for visualization purposes not for loss.", "\n", "target", "=", "inputs_unsupervised", ".", "get", "(", "\"target\"", ",", "None", ")", "\n", "pred_base", "=", "pred_base", "[", "\"pred\"", "]", "\n", "", "pred_aug", "=", "self", ".", "model", "(", "inputs_consistency_aug", ",", "return_pp", "=", "True", ")", "\n", "if", "\"target\"", "in", "pred_aug", ":", "\n", "                ", "del", "pred_aug", "[", "\"target\"", "]", "\n", "", "pred_aug", "[", "\"target\"", "]", "=", "pred_base", ".", "detach", "(", ")", "\n", "output_dict", "[", "\"consistency\"", "]", "=", "pred_aug", "\n", "if", "vis_training", ":", "\n", "                ", "self", ".", "visualize_aug_training", "(", "\n", "inputs_consistency", "[", "\"kspace\"", "]", ",", "\n", "inputs_consistency_aug", "[", "\"kspace\"", "]", ",", "\n", "pred_aug", "[", "\"pred\"", "]", ",", "\n", "pred_base", ",", "\n", "target", "=", "target", ",", "\n", ")", "\n", "\n", "", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.m2r.M2RModel.load_state_dict": [[167, 175], ["any", "super().load_state_dict", "ValueError", "x.startswith", "state_dict.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.load_state_dict"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ",", "strict", "=", "True", ")", ":", "\n", "# TODO: Configure backwards compatibility", "\n", "        ", "if", "any", "(", "x", ".", "startswith", "(", "\"unrolled\"", ")", "for", "x", "in", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`self.unrolled` was renamed to `self.model`. \"", "\n", "\"Backwards compatibility has not been configured.\"", "\n", ")", "\n", "", "return", "super", "(", ")", ".", "load_state_dict", "(", "state_dict", ",", "strict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.m2r.M2RModel.from_config": [[176, 191], ["cfg.clone", "cfg.clone.defrost", "cfg.clone.freeze", "meddlr.modeling.meta_arch.build.build_model", "meddlr.data.transforms.motion.MotionModel.from_cfg"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "model_cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "model_cfg", ".", "defrost", "(", ")", "\n", "model_cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "=", "cfg", ".", "MODEL", ".", "M2R", ".", "META_ARCHITECTURE", "\n", "model_cfg", ".", "freeze", "(", ")", "\n", "model", "=", "build_model", "(", "model_cfg", ")", "\n", "\n", "augmentor", "=", "MotionModel", ".", "from_cfg", "(", "cfg", ")", "\n", "\n", "return", "{", "\n", "\"model\"", ":", "model", ",", "\n", "\"augmentor\"", ":", "augmentor", ",", "\n", "\"use_supervised_consistency\"", ":", "cfg", ".", "MODEL", ".", "M2R", ".", "USE_SUPERVISED_CONSISTENCY", ",", "\n", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet.__init__": [[16, 105], ["torch.nn.Module.__init__", "list", "len", "generalized_unet.GeneralizedUNet._arg_to_seq", "generalized_unet.GeneralizedUNet._arg_to_seq", "meddlr.modeling.layers.build.get_layer_type", "zip", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "zip", "torch.nn.ModuleDict", "generalized_unet.GeneralizedUNet._arg_to_seq", "range", "meddlr.modeling.blocks.SimpleConvBlockNd", "range", "meddlr.modeling.blocks.SimpleConvBlockNd", "meddlr.modeling.blocks.SimpleConvBlockNd", "torch.nn.ModuleList", "meddlr.modeling.layers.build.get_layer_type", "isinstance", "meddlr.modeling.layers.build.get_layer_type.", "enumerate", "enumerate", "meddlr.modeling.layers.build.get_layer_kind", "meddlr.modeling.layers.build.get_layer_kind"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet._arg_to_seq", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet._arg_to_seq", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet._arg_to_seq", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_kind", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_kind"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "dimensions", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "channels", ":", "Sequence", "[", "int", "]", ",", "\n", "strides", ":", "Sequence", "[", "int", "]", "=", "1", ",", "\n", "kernel_size", ":", "Union", "[", "Sequence", "[", "int", "]", ",", "int", "]", "=", "3", ",", "\n", "up_kernel_size", ":", "Union", "[", "Sequence", "[", "int", "]", ",", "int", "]", "=", "None", ",", "\n", "dropout", ":", "float", "=", "0.0", ",", "\n", "block_order", ":", "Tuple", "[", "str", ",", "...", "]", "=", "(", "\"conv\"", ",", "\"relu\"", ",", "\"conv\"", ",", "\"relu\"", ",", "\"batchnorm\"", ",", "\"dropout\"", ")", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "channels", "=", "list", "(", "channels", ")", "\n", "depth", "=", "len", "(", "channels", ")", "\n", "assert", "depth", ">=", "2", "# must have at least 2 blocks for U-Net", "\n", "\n", "kernel_size", "=", "self", ".", "_arg_to_seq", "(", "kernel_size", ",", "depth", ")", "\n", "up_kernel_size", "=", "(", "\n", "self", ".", "_arg_to_seq", "(", "up_kernel_size", ",", "depth", "-", "1", ")", "if", "up_kernel_size", "else", "kernel_size", "[", ":", "-", "1", "]", "\n", ")", "\n", "strides", "=", "self", ".", "_arg_to_seq", "(", "strides", ",", "depth", ")", "\n", "pool_type", "=", "get_layer_type", "(", "\"maxpool\"", ",", "dimension", "=", "dimensions", ")", "\n", "\n", "block_order_names", ":", "Sequence", "[", "str", "]", "=", "[", "x", "if", "isinstance", "(", "x", ",", "str", ")", "else", "x", "[", "0", "]", "for", "x", "in", "block_order", "]", "\n", "act_idx", "=", "[", "i", "for", "i", ",", "x", "in", "enumerate", "(", "block_order_names", ")", "if", "get_layer_kind", "(", "x", ")", "==", "\"act\"", "]", "[", "0", "]", "\n", "norm_idx", "=", "[", "i", "for", "i", ",", "x", "in", "enumerate", "(", "block_order_names", ")", "if", "get_layer_kind", "(", "x", ")", "==", "\"norm\"", "]", "[", "0", "]", "\n", "up_block_order", "=", "(", "\"convtranspose\"", ",", "block_order", "[", "act_idx", "]", ",", "block_order", "[", "norm_idx", "]", ")", "\n", "\n", "# Down blocks + Bottleneck", "\n", "down_blocks", "=", "{", "}", "\n", "pool_blocks", "=", "{", "}", "\n", "for", "i", ",", "inc", ",", "outc", ",", "ks", ",", "s", "in", "zip", "(", "\n", "range", "(", "depth", ")", ",", "[", "in_channels", "]", "+", "channels", "[", ":", "-", "1", "]", ",", "channels", ",", "kernel_size", ",", "strides", "\n", ")", ":", "\n", "            ", "d_block", "=", "SimpleConvBlockNd", "(", "\n", "inc", ",", "\n", "outc", ",", "\n", "kernel_size", "=", "ks", ",", "\n", "dimension", "=", "dimensions", ",", "\n", "stride", "=", "s", ",", "\n", "dropout", "=", "dropout", ",", "\n", "order", "=", "block_order", ",", "\n", ")", "\n", "down_blocks", "[", "f\"block{i}\"", "]", "=", "d_block", "\n", "if", "i", "<", "depth", "-", "1", ":", "\n", "                ", "pool_blocks", "[", "f\"block{i}\"", "]", "=", "pool_type", "(", "2", ")", "\n", "", "", "self", ".", "down_blocks", "=", "nn", ".", "ModuleDict", "(", "down_blocks", ")", "\n", "self", ".", "pool_blocks", "=", "nn", ".", "ModuleDict", "(", "pool_blocks", ")", "\n", "\n", "# Up blocks - Up conv + concat + Block", "\n", "up_blocks", "=", "{", "}", "\n", "for", "i", ",", "inc", ",", "outc", ",", "ks", ",", "s", "in", "zip", "(", "\n", "range", "(", "depth", "-", "2", ",", "-", "1", ",", "-", "1", ")", ",", "\n", "channels", "[", ":", ":", "-", "1", "]", ",", "\n", "channels", "[", ":", ":", "-", "1", "]", "[", "1", ":", "]", ",", "\n", "kernel_size", "[", ":", ":", "-", "1", "]", ",", "\n", "strides", "[", ":", ":", "-", "1", "]", ",", "\n", ")", ":", "\n", "            ", "conv_t", "=", "SimpleConvBlockNd", "(", "\n", "inc", ",", "\n", "outc", ",", "\n", "dimension", "=", "dimensions", ",", "\n", "kernel_size", "=", "2", ",", "\n", "stride", "=", "2", ",", "\n", "order", "=", "up_block_order", ",", "\n", "padding", "=", "None", ",", "\n", ")", "\n", "block", "=", "SimpleConvBlockNd", "(", "\n", "outc", "*", "2", ",", "\n", "outc", ",", "\n", "kernel_size", "=", "ks", ",", "\n", "dimension", "=", "dimensions", ",", "\n", "stride", "=", "s", ",", "\n", "dropout", "=", "dropout", ",", "\n", "order", "=", "block_order", ",", "\n", ")", "\n", "block", "=", "nn", ".", "ModuleList", "(", "[", "conv_t", ",", "block", "]", ")", "\n", "up_blocks", "[", "f\"block{i}\"", "]", "=", "block", "\n", "", "self", ".", "up_blocks", "=", "nn", ".", "ModuleDict", "(", "up_blocks", ")", "\n", "\n", "self", ".", "output_block", "=", "get_layer_type", "(", "\"conv\"", ",", "dimension", "=", "dimensions", ")", "(", "\n", "channels", "[", "0", "]", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet.bottleneck": [[107, 111], ["list", "generalized_unet.GeneralizedUNet.down_blocks.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "@", "property", "\n", "def", "bottleneck", "(", "self", ")", ":", "\n", "        ", "\"\"\"Easy access property for bottleneck layer.\"\"\"", "\n", "return", "self", ".", "down_blocks", "[", "list", "(", "self", ".", "down_blocks", ".", "keys", "(", ")", ")", "[", "-", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet.depth": [[112, 115], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "depth", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "down_blocks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet.forward": [[116, 134], ["range", "zip", "generalized_unet.GeneralizedUNet.output_block", "len", "range", "tuple", "torch.cat", "conv_block", "skip_connections.append", "len", "upsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "down_blocks", "=", "self", ".", "down_blocks", "\n", "pool_blocks", "=", "self", ".", "pool_blocks", "\n", "up_blocks", "=", "self", ".", "up_blocks", "\n", "\n", "skip_connections", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "down_blocks", ")", ")", ":", "\n", "            ", "x", "=", "self", ".", "down_blocks", "[", "f\"block{i}\"", "]", "(", "x", ")", "\n", "if", "i", "<", "len", "(", "down_blocks", ")", "-", "1", ":", "\n", "                ", "skip_connections", ".", "append", "(", "x", ")", "\n", "x", "=", "pool_blocks", "[", "f\"block{i}\"", "]", "(", "x", ")", "\n", "\n", "", "", "for", "i", ",", "sc", "in", "zip", "(", "range", "(", "self", ".", "depth", "-", "2", ",", "-", "1", ",", "-", "1", ")", ",", "skip_connections", "[", ":", ":", "-", "1", "]", ")", ":", "\n", "            ", "upsample", ",", "conv_block", "=", "tuple", "(", "up_blocks", "[", "f\"block{i}\"", "]", ")", "\n", "x", "=", "torch", ".", "cat", "(", "[", "upsample", "(", "x", ")", ",", "sc", "]", ",", "dim", "=", "1", ")", "\n", "x", "=", "conv_block", "(", "x", ")", "\n", "\n", "", "return", "self", ".", "output_block", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet._arg_to_seq": [[135, 145], ["isinstance", "ValueError", "isinstance", "isinstance", "len", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_arg_to_seq", "(", "arg", ",", "num", ":", "int", ")", ":", "\n", "        ", "\"\"\"Converts arguments that are supposed to be sequences of a particular length.\"\"\"", "\n", "if", "isinstance", "(", "arg", ",", "Sequence", ")", "and", "len", "(", "arg", ")", "!=", "num", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Got `arg` {arg}. Expected len {num}\"", ")", "\n", "", "if", "isinstance", "(", "arg", ",", "Sequence", ")", "and", "len", "(", "arg", ")", "==", "1", ":", "\n", "            ", "arg", "=", "arg", "[", "0", "]", "\n", "", "if", "not", "isinstance", "(", "arg", ",", "Sequence", ")", ":", "\n", "            ", "arg", "=", "(", "arg", ",", ")", "*", "num", "\n", "", "return", "arg", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.generalized_unet.GeneralizedUNet.from_config": [[146, 171], ["cfg.get", "cfg.get", "kwargs.get", "tuple", "cfg.get", "init_args.update", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "**", "kwargs", ")", ":", "\n", "# Returns kwargs to be passed to __init__", "\n", "        ", "if", "\"MODEL\"", "in", "cfg", ":", "\n", "            ", "cfg", "=", "cfg", ".", "MODEL", ".", "UNET", "\n", "", "elif", "\"UNET\"", "in", "cfg", ":", "\n", "            ", "cfg", "=", "cfg", ".", "UNET", "\n", "", "in_channels", "=", "cfg", ".", "get", "(", "\"IN_CHANNELS\"", ",", "None", ")", "\n", "out_channels", "=", "cfg", ".", "get", "(", "\"OUT_CHANNELS\"", ",", "None", ")", "\n", "dimensions", "=", "kwargs", ".", "get", "(", "\"dimensions\"", ",", "2", ")", "\n", "num_pool_layers", "=", "cfg", ".", "NUM_POOL_LAYERS", "\n", "num_channels", "=", "tuple", "(", "cfg", ".", "CHANNELS", "*", "(", "2", "**", "i", ")", "for", "i", "in", "range", "(", "num_pool_layers", "+", "1", ")", ")", "\n", "\n", "init_args", "=", "{", "\n", "\"dimensions\"", ":", "dimensions", ",", "\n", "\"in_channels\"", ":", "in_channels", ",", "\n", "\"out_channels\"", ":", "out_channels", ",", "\n", "\"channels\"", ":", "num_channels", ",", "\n", "\"dropout\"", ":", "cfg", ".", "DROPOUT", ",", "\n", "}", "\n", "block_order", "=", "cfg", ".", "get", "(", "\"BLOCK_ORDER\"", ",", "None", ")", "\n", "if", "block_order", "is", "not", "None", ":", "\n", "            ", "init_args", "[", "\"block_order\"", "]", "=", "block_order", "\n", "", "init_args", ".", "update", "(", "**", "kwargs", ")", "\n", "return", "init_args", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.cs_model.CSModel.__init__": [[40, 67], ["torch.nn.Module.__init__", "ModuleNotFoundError", "ValueError", "torch.device"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "reg", ":", "float", ",", "max_iter", ":", "int", ",", "device", "=", "\"cpu\"", ",", "num_emaps", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            reg (float): The regularization strength.\n            max_iter (int): Maximum number of iterations.\n            device (str | torch.device, optional): The device to execute on.\n            num_emaps (int, optional): Number of estimated sensitivity maps.\n                Currently only ``1`` is supported.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "device", "!=", "torch", ".", "device", "(", "\"cpu\"", ")", "and", "not", "_CUPY_AVAILABLE", ":", "\n", "            ", "raise", "ModuleNotFoundError", "(", "\n", "f\"Requested device {device}, but cupy not installed. \"", "\n", "f\"Install cupy>=9.0 following instructions at \"", "\n", "f\"https://docs.cupy.dev/en/stable/install.html\"", "\n", ")", "\n", "", "self", ".", "device", "=", "device", "\n", "\n", "# Extract network parameters", "\n", "self", ".", "l1_reg", "=", "reg", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "\n", "# Data dimensions", "\n", "self", ".", "num_emaps", "=", "num_emaps", "\n", "if", "self", ".", "num_emaps", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"CS currentlyonly supports one sensitivity map.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.cs_model.CSModel.forward": [[68, 151], ["meddlr.utils.general.move_to_device", "meddlr.utils.general.move_to_device.get", "meddlr.utils.general.move_to_device.get", "meddlr.utils.general.move_to_device.get", "meddlr.forward.mri.SenseModel.", "kspace[].permute", "[].permute", "mask[].permute", "xp.asarray", "xp.asarray", "xp.asarray", "sigpy.app.L1WaveletRecon().run", "sigpy.app.L1WaveletRecon().run", "torch.as_tensor", "image.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze().unsqueeze", "ValueError", "meddlr.is_complex_as_real", "ValueError", "meddlr.get_mask", "meddlr.forward.mri.SenseModel", "output_dict.update", "xp.asarray.size", "torch.device", "sigpy.app.L1WaveletRecon", "sigpy.app.L1WaveletRecon", "image.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze", "xp.asarray.squeeze", "sigpy.get_device", "sigpy.get_device"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "", "def", "forward", "(", "self", ",", "inputs", ",", "return_pp", "=", "False", ",", "vis_training", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        TODO: condense into list of dataset dicts.\n        Args:\n            inputs: Standard ss_recon module input dictionary\n                * \"kspace\": Kspace. If fully sampled, and want to simulate\n                    undersampled kspace, provide \"mask\" argument.\n                * \"maps\": Sensitivity maps\n                * \"target\" (optional): Target image (typically fully sampled).\n                * \"mask\" (optional): Undersampling mask to apply.\n                * \"signal_model\" (optional): The signal model. If provided,\n                    \"maps\" will not be used to estimate the signal model.\n                    Use with caution.\n            return_pp (bool, optional): If `True`, return post-processing\n                parameters \"mean\", \"std\", and \"norm\" if included in the input.\n            vis_training (bool, optional): If `True`, force visualize training\n                on this pass. Can only be `True` if model is in training mode.\n\n        Returns:\n            Dict: A standard ss_recon output dict\n                * \"pred\": The reconstructed image\n                * \"target\" (optional): The target image.\n                    Added if provided in the input.\n                * \"mean\"/\"std\"/\"norm\" (optional): Pre-processing parameters.\n                    Added if provided in the input.\n                * \"zf_image\": The zero-filled image.\n                    Added when model is in eval mode.\n        \"\"\"", "\n", "if", "inputs", "[", "\"kspace\"", "]", ".", "shape", "[", "0", "]", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only batch size == 1 is supported in compressed sensing\"", ")", "\n", "\n", "# Need to fetch device at runtime for proper data transfer.", "\n", "# device = self.resnets[0].final_layer.weight.device", "\n", "", "device", "=", "self", ".", "device", "\n", "inputs", "=", "move_to_device", "(", "inputs", ",", "device", ")", "\n", "kspace", "=", "inputs", "[", "\"kspace\"", "]", "\n", "target", "=", "inputs", ".", "get", "(", "\"target\"", ",", "None", ")", "\n", "mask", "=", "inputs", ".", "get", "(", "\"mask\"", ",", "None", ")", "\n", "A", "=", "inputs", ".", "get", "(", "\"signal_model\"", ",", "None", ")", "\n", "maps", "=", "inputs", "[", "\"maps\"", "]", "\n", "num_maps_dim", "=", "-", "2", "if", "cplx", ".", "is_complex_as_real", "(", "maps", ")", "else", "-", "1", "\n", "if", "self", ".", "num_emaps", "!=", "maps", ".", "size", "(", ")", "[", "num_maps_dim", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Incorrect number of ESPIRiT maps! Re-prep data...\"", ")", "\n", "\n", "", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "cplx", ".", "get_mask", "(", "kspace", ")", "\n", "", "kspace", "*=", "mask", "\n", "\n", "# Declare signal model.", "\n", "if", "A", "is", "None", ":", "\n", "            ", "A", "=", "SenseModel", "(", "maps", ",", "weights", "=", "mask", ")", "\n", "", "zf_image", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "\n", "# Channel-first - (#coils, ky, kz)", "\n", "# TODO: Generalize to 3D", "\n", "kspace", "=", "kspace", "[", "0", "]", ".", "permute", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "maps", "=", "maps", ".", "squeeze", "(", "num_maps_dim", ")", "[", "0", "]", ".", "permute", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "mask", "=", "mask", "[", "0", "]", ".", "permute", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "xp", "=", "np", "if", "device", "==", "torch", ".", "device", "(", "\"cpu\"", ")", "else", "cp", "\n", "kspace", "=", "xp", ".", "asarray", "(", "kspace", ")", "\n", "maps", "=", "xp", ".", "asarray", "(", "maps", ")", "\n", "mask", "=", "xp", ".", "asarray", "(", "mask", ")", "\n", "\n", "image", "=", "mr", ".", "app", ".", "L1WaveletRecon", "(", "\n", "kspace", ",", "\n", "maps", ",", "\n", "self", ".", "l1_reg", ",", "\n", "weights", "=", "mask", ",", "\n", "max_iter", "=", "self", ".", "max_iter", ",", "\n", "device", "=", "sp", ".", "get_device", "(", "kspace", ")", ",", "\n", ")", ".", "run", "(", ")", "\n", "image", "=", "torch", ".", "as_tensor", "(", "image", ",", "device", "=", "device", ")", "\n", "image", "=", "image", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "output_dict", "=", "{", "\"pred\"", ":", "image", ",", "\"target\"", ":", "target", "}", "# N x Y x Z x 1 x 2  # N x Y x Z x 1 x 2", "\n", "if", "return_pp", ":", "\n", "            ", "output_dict", ".", "update", "(", "{", "k", ":", "inputs", "[", "k", "]", "for", "k", "in", "[", "\"mean\"", ",", "\"std\"", ",", "\"norm\"", "]", "}", ")", "\n", "\n", "", "if", "not", "self", ".", "training", ":", "\n", "            ", "output_dict", "[", "\"zf_image\"", "]", "=", "zf_image", "\n", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.cs_model.CSModel.from_config": [[152, 159], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "return", "{", "\n", "\"reg\"", ":", "cfg", ".", "MODEL", ".", "CS", ".", "REGULARIZATION", ",", "\n", "\"max_iter\"", ":", "cfg", ".", "MODEL", ".", "CS", ".", "MAX_ITER", ",", "\n", "\"device\"", ":", "cfg", ".", "MODEL", ".", "DEVICE", ",", "\n", "\"num_emaps\"", ":", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "NUM_EMAPS", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.denoising.DenoisingModel.__init__": [[20, 53], ["torch.nn.Module.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ",", "\n", "noiser", ":", "NoiseModel", ",", "\n", "use_fully_sampled_target", "=", "False", ",", "\n", "use_fully_sampled_target_eval", ":", "bool", "=", "None", ",", "\n", "vis_period", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            model (nn.Module): The base model.\n            noiser (NoiseModel): The additive noise model.\n            use_fully_sampled_target (bool, optional): If ``True``,\n                use fully sampled images as the target for denoising during training.\n            use_fully_sampled_target_eval (bool, optional): If ``True``,\n                use fully sampled images as the target for denoising during evaluation\n                (includes validation). If ``None``, defaults to ``use_fully_sampled_target``.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "noiser", "=", "noiser", "\n", "\n", "# Default validation to use_fully_sampled_target_eval.", "\n", "if", "use_fully_sampled_target_eval", "is", "None", ":", "\n", "            ", "use_fully_sampled_target_eval", "=", "use_fully_sampled_target", "\n", "", "self", ".", "use_fully_sampled_target", "=", "use_fully_sampled_target", "\n", "self", ".", "use_fully_sampled_target_eval", "=", "use_fully_sampled_target_eval", "\n", "\n", "# Visualization done by this model", "\n", "if", "hasattr", "(", "self", ".", "model", ",", "\"vis_period\"", ")", "and", "vis_period", ">", "0", ":", "\n", "            ", "self", ".", "model", ".", "vis_period", "=", "-", "1", "\n", "", "self", ".", "vis_period", "=", "vis_period", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.denoising.DenoisingModel.augment": [[54, 60], ["kspace.detach().clone.detach().clone.detach().clone", "denoising.DenoisingModel.noiser", "kspace.detach().clone.detach().clone.detach"], "methods", ["None"], ["", "def", "augment", "(", "self", ",", "kspace", ")", ":", "\n", "        ", "\"\"\"Noise augmentation module.\n        TODO: Perform the augmentation here.\n        \"\"\"", "\n", "kspace", "=", "kspace", ".", "detach", "(", ")", ".", "clone", "(", ")", "\n", "return", "self", ".", "noiser", "(", "kspace", ",", "clone", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.denoising.DenoisingModel.visualize_training": [[61, 91], ["meddlr.utils.events.get_event_storage", "torch.no_grad", "meddlr.is_complex", "kspace[].unsqueeze().cpu", "targets[].unsqueeze().cpu", "preds[].unsqueeze().cpu", "zfs[].unsqueeze().cpu", "torch.cat", "imgs_to_write.items", "torch.view_as_real", "meddlr.angle", "meddlr.abs", "meddlr.abs", "meddlr.get_mask", "torchvision.make_grid.squeeze().unsqueeze", "torchvision.make_grid", "meddlr.utils.events.get_event_storage.put_image", "kspace[].unsqueeze", "targets[].unsqueeze", "preds[].unsqueeze", "zfs[].unsqueeze", "torchvision.make_grid.numpy", "torchvision.make_grid.squeeze"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image"], ["", "def", "visualize_training", "(", "self", ",", "kspace", ",", "zfs", ",", "targets", ",", "preds", ")", ":", "\n", "        ", "\"\"\"A function used to visualize reconstructions.\n\n        Args:\n            targets: NxHxWx2 tensors of target images.\n            preds: NxHxWx2 tensors of predictions.\n        \"\"\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "cplx", ".", "is_complex", "(", "kspace", ")", ":", "\n", "                ", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "", "kspace", "=", "kspace", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "# calc mask for first coil only", "\n", "targets", "=", "targets", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "preds", "=", "preds", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "zfs", "=", "zfs", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "\n", "all_images", "=", "torch", ".", "cat", "(", "[", "zfs", ",", "preds", ",", "targets", "]", ",", "dim", "=", "2", ")", "\n", "\n", "imgs_to_write", "=", "{", "\n", "\"phases\"", ":", "cplx", ".", "angle", "(", "all_images", ")", ",", "\n", "\"images\"", ":", "cplx", ".", "abs", "(", "all_images", ")", ",", "\n", "\"errors\"", ":", "cplx", ".", "abs", "(", "preds", "-", "targets", ")", ",", "\n", "\"masks\"", ":", "cplx", ".", "get_mask", "(", "kspace", ")", ",", "\n", "}", "\n", "\n", "for", "name", ",", "data", "in", "imgs_to_write", ".", "items", "(", ")", ":", "\n", "                ", "data", "=", "data", ".", "squeeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "data", "=", "tv_utils", ".", "make_grid", "(", "data", ",", "nrow", "=", "1", ",", "padding", "=", "1", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", ")", "\n", "storage", ".", "put_image", "(", "\"train/{}\"", ".", "format", "(", "name", ")", ",", "data", ".", "numpy", "(", ")", ",", "data_format", "=", "\"CHW\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.denoising.DenoisingModel.forward": [[92, 169], ["meddlr.utils.general.move_to_device", "keys[].intersection", "denoising.DenoisingModel.model", "ValueError", "next", "meddlr.utils.events.get_event_storage", "any", "meddlr.forward.mri.SenseModel", "meddlr.forward.mri.SenseModel.detach", "denoising.DenoisingModel.augment", "set", "denoising.DenoisingModel.parameters", "meddlr.forward.mri.SenseModel", "denoising.DenoisingModel.augment", "meddlr.forward.mri.SenseModel", "meddlr.forward.mri.SenseModel.detach", "denoising.DenoisingModel.augment", "v.keys", "meddlr.utils.general.move_to_device.values", "isinstance", "torch.cat", "itertools.chain", "meddlr.utils.general.move_to_device.keys", "meddlr.forward.mri.SenseModel.", "meddlr.get_mask", "meddlr.forward.mri.SenseModel.", "meddlr.utils.general.move_to_device.keys", "meddlr.get_mask", "meddlr.forward.mri.SenseModel."], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ",", "return_pp", "=", "False", ",", "vis_training", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        TODO: condense into list of dataset dicts.\n        Args:\n            inputs: Standard meddlr module input dictionary\n                * \"kspace\": Kspace. If fully sampled, and want to simulate\n                    undersampled kspace, provide \"mask\" argument.\n                * \"maps\": Sensitivity maps\n                * \"target\" (optional): Target image (typically fully sampled).\n                * \"mask\" (optional): Undersampling mask to apply.\n                * \"signal_model\" (optional): The signal model. If provided,\n                    \"maps\" will not be used to estimate the signal model.\n                    Use with caution.\n            return_pp (bool, optional): If `True`, return post-processing\n                parameters \"mean\", \"std\", and \"norm\" if included in the input.\n            vis_training (bool, optional): If `True`, force visualize training\n                on this pass. Can only be `True` if model is in training mode.\n\n        Returns:\n            Dict: A standard meddlr output dict\n                * \"pred\": The reconstructed image\n                * \"target\" (optional): The target image.\n                    Added if provided in the input.\n                * \"mean\"/\"std\"/\"norm\" (optional): Pre-processing parameters.\n                    Added if provided in the input.\n                * \"zf_image\": The zero-filled image.\n                    Added when model is in eval mode.\n        \"\"\"", "\n", "if", "vis_training", "and", "not", "self", ".", "training", ":", "\n", "            ", "raise", "ValueError", "(", "\"vis_training is only applicable in training mode.\"", ")", "\n", "\n", "", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "inputs", "=", "move_to_device", "(", "inputs", ",", "device", ")", "\n", "\n", "if", "self", ".", "training", "and", "self", ".", "vis_period", ">", "0", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "vis_training", "=", "True", "\n", "\n", "", "", "if", "not", "any", "(", "k", "in", "inputs", "for", "k", "in", "[", "\"supervised\"", ",", "\"unsupervised\"", "]", ")", ":", "\n", "            ", "inputs", "=", "{", "\"supervised\"", ":", "inputs", "}", "\n", "\n", "", "use_fully_sampled_target", "=", "(", "self", ".", "training", "and", "self", ".", "use_fully_sampled_target", ")", "or", "(", "\n", "not", "self", ".", "training", "and", "self", ".", "use_fully_sampled_target_eval", "\n", ")", "\n", "\n", "if", "\"supervised\"", "in", "inputs", ":", "\n", "            ", "sup_inputs", "=", "inputs", "[", "\"supervised\"", "]", "\n", "if", "use_fully_sampled_target", ":", "\n", "                ", "img", "=", "sup_inputs", "[", "\"target\"", "]", "\n", "A", "=", "SenseModel", "(", "sup_inputs", "[", "\"maps\"", "]", ")", "\n", "sup_inputs", "[", "\"kspace\"", "]", "=", "self", ".", "augment", "(", "A", "(", "img", ",", "adjoint", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "kspace", "=", "sup_inputs", "[", "\"kspace\"", "]", "\n", "A", "=", "SenseModel", "(", "sup_inputs", "[", "\"maps\"", "]", ",", "weights", "=", "cplx", ".", "get_mask", "(", "kspace", ")", ")", "\n", "sup_inputs", "[", "\"target\"", "]", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", ".", "detach", "(", ")", "\n", "sup_inputs", "[", "\"kspace\"", "]", "=", "self", ".", "augment", "(", "kspace", ")", "\n", "", "", "if", "\"unsupervised\"", "in", "inputs", ":", "\n", "            ", "unsup_inputs", "=", "inputs", "[", "\"unsupervised\"", "]", "\n", "kspace", "=", "unsup_inputs", "[", "\"kspace\"", "]", "\n", "A", "=", "SenseModel", "(", "unsup_inputs", "[", "\"maps\"", "]", ",", "weights", "=", "cplx", ".", "get_mask", "(", "kspace", ")", ")", "\n", "unsup_inputs", "[", "\"target\"", "]", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", ".", "detach", "(", ")", "\n", "unsup_inputs", "[", "\"kspace\"", "]", "=", "self", ".", "augment", "(", "kspace", ")", "\n", "\n", "", "keys", "=", "[", "set", "(", "v", ".", "keys", "(", ")", ")", "for", "v", "in", "inputs", ".", "values", "(", ")", "]", "\n", "keys", "=", "keys", "[", "0", "]", ".", "intersection", "(", "*", "keys", ")", "\n", "inputs", "=", "{", "k", ":", "[", "inputs", "[", "field", "]", "[", "k", "]", "for", "field", "in", "inputs", ".", "keys", "(", ")", "]", "for", "k", "in", "keys", "}", "\n", "inputs", "=", "{", "\n", "k", ":", "torch", ".", "cat", "(", "inputs", "[", "k", "]", ",", "dim", "=", "0", ")", "\n", "if", "isinstance", "(", "inputs", "[", "k", "]", "[", "0", "]", ",", "torch", ".", "Tensor", ")", "\n", "else", "itertools", ".", "chain", "(", "inputs", "[", "k", "]", ")", "\n", "for", "k", "in", "inputs", ".", "keys", "(", ")", "\n", "}", "\n", "\n", "output_dict", "=", "self", ".", "model", "(", "inputs", ",", "return_pp", "=", "True", ",", "vis_training", "=", "vis_training", ")", "\n", "\n", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.denoising.DenoisingModel.from_config": [[170, 193], ["torch.device", "cfg.clone", "cfg.clone.defrost", "cfg.clone.freeze", "meddlr.modeling.meta_arch.build.build_model", "cfg.clone", "cfg.clone.defrost", "cfg.clone.freeze", "meddlr.data.transforms.noise.NoiseModel.from_cfg"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", "\n", "\n", "model_cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "model_cfg", ".", "defrost", "(", ")", "\n", "model_cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "=", "cfg", ".", "MODEL", ".", "DENOISING", ".", "META_ARCHITECTURE", "\n", "model_cfg", ".", "freeze", "(", ")", "\n", "model", "=", "build_model", "(", "model_cfg", ")", "\n", "\n", "noise_cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "noise_cfg", ".", "defrost", "(", ")", "\n", "noise_cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", ".", "STD_DEV", "=", "cfg", ".", "MODEL", ".", "DENOISING", ".", "NOISE", ".", "STD_DEV", "\n", "noise_cfg", ".", "freeze", "(", ")", "\n", "noiser", "=", "NoiseModel", ".", "from_cfg", "(", "noise_cfg", ",", "device", "=", "device", ")", "\n", "\n", "use_fully_sampled_target", "=", "cfg", ".", "MODEL", ".", "DENOISING", ".", "NOISE", ".", "USE_FULLY_SAMPLED_TARGET", "\n", "use_fully_sampled_target_eval", "=", "cfg", ".", "MODEL", ".", "DENOISING", ".", "NOISE", ".", "USE_FULLY_SAMPLED_TARGET_EVAL", "\n", "return", "{", "\n", "\"model\"", ":", "model", ",", "\n", "\"noiser\"", ":", "noiser", ",", "\n", "\"use_fully_sampled_target\"", ":", "use_fully_sampled_target", ",", "\n", "\"use_fully_sampled_target_eval\"", ":", "use_fully_sampled_target_eval", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.ssdu.SSDUModel.__init__": [[36, 53], ["torch.nn.Module.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "model", ":", "nn", ".", "Module", ",", "masker", ":", "RandomKspaceMask", ",", "vis_period", ":", "int", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            model (nn.Module): The base model.\n            masker (NoiseModel): The additive noise module.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "masker", "=", "masker", "\n", "# Visualization done by this model", "\n", "if", "hasattr", "(", "self", ".", "model", ",", "\"vis_period\"", ")", ":", "\n", "            ", "if", "vis_period", "is", "not", "None", ":", "\n", "                ", "self", ".", "model", ".", "vis_period", "=", "vis_period", "\n", "", "else", ":", "\n", "                ", "vis_period", "=", "self", ".", "model", ".", "vis_period", "\n", "", "", "self", ".", "vis_period", "=", "vis_period", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.ssdu.SSDUModel.augment": [[54, 82], ["inputs[].clone", "meddlr.ops.complex.get_mask", "masker.get_transform", "tfm.generate_mask", "torch.all", "v.clone", "inputs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.generate_mask", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "augment", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Noise augmentation module for the consistency branch.\n\n        Args:\n            inputs (Dict[str, Any]): The input dictionary.\n                It must contain a key ``'kspace'``, which traditionally\n                corresponds to the undersampled kspace when performing\n                augmentation for consistency. For supervised examples,\n                this can correspond to either the retrospectively\n                undersampled k-space or the fully-sampled kspace.\n\n        Returns:\n            Dict[str, Any]: The input dictionary with the kspace polluted\n                with additive masked complex Gaussian noise.\n        \"\"\"", "\n", "masker", "=", "self", ".", "masker", "\n", "kspace", "=", "inputs", "[", "\"kspace\"", "]", ".", "clone", "(", ")", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "kspace", ")", "\n", "\n", "tfm", ":", "KspaceMaskTransform", "=", "masker", ".", "get_transform", "(", "kspace", ")", "\n", "train_mask", "=", "tfm", ".", "generate_mask", "(", "kspace", ",", "channels_last", "=", "True", ")", "\n", "loss_mask", "=", "mask", "-", "train_mask", "\n", "# TODO (arjundd): See if we can remove this check for speed reasons.", "\n", "assert", "torch", ".", "all", "(", "loss_mask", ">=", "0", ")", "\n", "\n", "inputs", "=", "{", "k", ":", "v", ".", "clone", "(", ")", "for", "k", ",", "v", "in", "inputs", ".", "items", "(", ")", "if", "k", "!=", "\"kspace\"", "}", "\n", "inputs", "[", "\"kspace\"", "]", "=", "train_mask", "*", "kspace", "\n", "return", "inputs", ",", "mask", "[", "...", ",", "0", ":", "1", "]", ",", "train_mask", ",", "loss_mask", "[", "...", ",", "0", ":", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.ssdu.SSDUModel.visualize": [[83, 105], ["torch.no_grad", "images_dict.items", "meddlr.utils.events.get_event_storage", "isinstance", "torch.stack.items", "torch.stack", "meddlr.ops.complex.is_complex_as_real", "meddlr.ops.complex.is_complex", "data.squeeze.squeeze.unsqueeze", "torchvision.make_grid", "meddlr.utils.events.get_event_storage.put_image", "meddlr.ops.complex.angle", "meddlr.ops.complex.abs", "data.squeeze.squeeze.squeeze", "data.squeeze.squeeze.cpu().numpy", "len", "data.squeeze.squeeze.cpu"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "visualize", "(", "self", ",", "images_dict", ")", ":", "\n", "        ", "for", "name", ",", "images", "in", "images_dict", ".", "items", "(", ")", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "isinstance", "(", "images", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "                ", "images", "=", "torch", ".", "stack", "(", "images", ",", "dim", "=", "0", ")", "\n", "", "if", "cplx", ".", "is_complex_as_real", "(", "images", ")", "or", "cplx", ".", "is_complex", "(", "images", ")", ":", "\n", "                ", "images", "=", "{", "\n", "f\"{name}-phase\"", ":", "cplx", ".", "angle", "(", "images", ")", ",", "\n", "f\"{name}-mag\"", ":", "cplx", ".", "abs", "(", "images", ")", ",", "\n", "}", "\n", "", "else", ":", "\n", "                ", "images", "=", "{", "name", ":", "images", "}", "\n", "\n", "", "for", "name", ",", "data", "in", "images", ".", "items", "(", ")", ":", "\n", "                ", "if", "data", ".", "shape", "[", "-", "1", "]", "==", "1", ":", "\n", "                    ", "data", "=", "data", ".", "squeeze", "(", "-", "1", ")", "\n", "", "data", "=", "data", ".", "unsqueeze", "(", "1", ")", "\n", "data", "=", "tv_utils", ".", "make_grid", "(", "\n", "data", ",", "nrow", "=", "len", "(", "data", ")", ",", "padding", "=", "1", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", "\n", ")", "\n", "storage", ".", "put_image", "(", "\"ssdu/{}\"", ".", "format", "(", "name", ")", ",", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "data_format", "=", "\"CHW\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.ssdu.SSDUModel.forward": [[106, 171], ["inputs.get.get.get", "inputs.get.get.get", "all", "meddlr.utils.general.move_to_device", "ssdu.SSDUModel.augment", "ssdu.SSDUModel.model", "meddlr.forward.mri.SenseModel", "meddlr.ifft2c", "meddlr.ifft2c", "inputs.get.get.get", "ssdu.SSDUModel.model", "next", "meddlr.forward.mri.SenseModel.", "torch.cat", "ssdu.SSDUModel.model.parameters", "torch.no_grad", "meddlr.utils.events.get_event_storage", "meddlr.forward.mri.SenseModel", "meddlr.forward.mri.SenseModel.", "ssdu.SSDUModel.visualize", "inputs.get.get.get", "inputs.get.get.get", "inputs.get.get.keys", "inputs.get.get.keys", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.ssdu.SSDUModel.visualize", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "not", "self", ".", "training", ":", "\n", "            ", "assert", "(", "\n", "\"unsupervised\"", "not", "in", "inputs", "\n", ")", ",", "\"unsupervised inputs should not be provided in eval mode\"", "\n", "inputs", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "inputs", ")", "\n", "return", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "# Put supervised and unsupervised scans in a single tensor.", "\n", "", "sup", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "{", "}", ")", "\n", "unsup", "=", "inputs", ".", "get", "(", "\"unsupervised\"", ",", "{", "}", ")", "\n", "if", "sup", "or", "unsup", ":", "\n", "            ", "inputs", "=", "{", "\n", "k", ":", "torch", ".", "cat", "(", "[", "sup", ".", "get", "(", "k", ",", "torch", ".", "tensor", "(", "[", "]", ")", ")", ",", "unsup", ".", "get", "(", "k", ",", "torch", ".", "tensor", "(", "[", "]", ")", ")", "]", ")", "\n", "for", "k", "in", "sup", ".", "keys", "(", ")", "|", "unsup", ".", "keys", "(", ")", "\n", "}", "\n", "", "assert", "all", "(", "k", "in", "inputs", "for", "k", "in", "[", "\"kspace\"", "]", ")", "\n", "\n", "device", "=", "next", "(", "self", ".", "model", ".", "parameters", "(", ")", ")", ".", "device", "\n", "inputs", "=", "move_to_device", "(", "inputs", ",", "device", "=", "device", ",", "non_blocking", "=", "True", ")", "\n", "\n", "kspace", "=", "inputs", "[", "\"kspace\"", "]", "\n", "inputs_aug", ",", "orig_mask", ",", "train_mask", ",", "loss_mask", "=", "self", ".", "augment", "(", "inputs", ")", "\n", "outputs", "=", "self", ".", "model", "(", "inputs_aug", ")", "\n", "\n", "# Get the signal model reconstructed images.", "\n", "# TODO: Make it possible to use these are the target instead of multi-coil images.", "\n", "pred_img", ",", "target_img", ",", "zf_image", "=", "outputs", "[", "\"pred\"", "]", ",", "outputs", "[", "\"target\"", "]", ",", "outputs", "[", "\"zf_image\"", "]", "\n", "\n", "# Use signal model (SENSE) to get weighted kspace.", "\n", "A", "=", "SenseModel", "(", "maps", "=", "inputs_aug", "[", "\"maps\"", "]", ")", "# no weights - we do not want to mask the data.", "\n", "loss_pred_kspace", "=", "loss_mask", "*", "A", "(", "outputs", "[", "\"pred\"", "]", ",", "adjoint", "=", "False", ")", "\n", "loss_kspace", "=", "loss_mask", "*", "kspace", "\n", "\n", "# A hacky way to prepare the predictions and target for the loss.", "\n", "# This may result in inaccurate training metrics outside of the loss.", "\n", "# TODO (arjundd): Fix this.", "\n", "outputs", "[", "\"pred\"", "]", "=", "oF", ".", "ifft2c", "(", "loss_pred_kspace", ",", "channels_last", "=", "True", ")", "\n", "outputs", "[", "\"target\"", "]", "=", "oF", ".", "ifft2c", "(", "loss_kspace", ",", "channels_last", "=", "True", ")", "\n", "\n", "# Visualize.", "\n", "if", "self", ".", "training", "and", "self", ".", "vis_period", ">", "0", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                    ", "A", "=", "SenseModel", "(", "maps", "=", "inputs", "[", "\"maps\"", "]", "[", "0", ":", "1", "]", ",", "weights", "=", "train_mask", "[", "0", ":", "1", "]", ")", "\n", "base_image", "=", "A", "(", "kspace", "[", "0", ":", "1", "]", ",", "adjoint", "=", "True", ")", "\n", "self", ".", "visualize", "(", "\n", "{", "\n", "\"masks\"", ":", "[", "orig_mask", "[", "0", "]", ",", "train_mask", "[", "0", "]", ",", "loss_mask", "[", "0", "]", "]", ",", "\n", "\"kspace\"", ":", "[", "\n", "kspace", "[", "0", ",", "...", ",", "0", ":", "1", "]", ",", "\n", "inputs_aug", "[", "\"kspace\"", "]", "[", "0", ",", "...", ",", "0", ":", "1", "]", ",", "\n", "loss_pred_kspace", "[", "0", ",", "...", ",", "0", ":", "1", "]", ",", "\n", "loss_kspace", "[", "0", ",", "...", ",", "0", ":", "1", "]", ",", "\n", "]", ",", "\n", "\"images\"", ":", "[", "\n", "x", "[", "0", "]", "\n", "for", "x", "in", "[", "base_image", ",", "zf_image", ",", "pred_img", ",", "target_img", "]", "\n", "if", "x", "is", "not", "None", "\n", "]", ",", "\n", "}", "\n", ")", "\n", "\n", "", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.ssdu.SSDUModel.from_config": [[172, 186], ["cfg.clone", "cfg.clone.defrost", "cfg.clone.freeze", "meddlr.modeling.meta_arch.build.build_model", "meddlr.transforms.gen.mask.RandomKspaceMask", "meddlr.transforms.gen.mask.RandomKspaceMask.to"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "model_cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "model_cfg", ".", "defrost", "(", ")", "\n", "model_cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "=", "cfg", ".", "MODEL", ".", "SSDU", ".", "META_ARCHITECTURE", "\n", "model_cfg", ".", "freeze", "(", ")", "\n", "model", "=", "build_model", "(", "model_cfg", ")", "\n", "\n", "# TODO: Configure this", "\n", "params", "=", "cfg", ".", "MODEL", ".", "SSDU", ".", "MASKER", ".", "PARAMS", "\n", "masker", "=", "RandomKspaceMask", "(", "**", "params", ")", "\n", "masker", ".", "to", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", "\n", "\n", "return", "{", "\"model\"", ":", "model", ",", "\"masker\"", ":", "masker", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.__init__": [[16, 37], ["torch.nn.Module.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "nn", ".", "Module", ",", "\n", "augmentor", ":", "NoiseAndMotionModel", ",", "\n", "use_supervised_consistency", ":", "bool", "=", "False", ",", "\n", "vis_period", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "\n", "# Visualization done by this model", "\n", "if", "hasattr", "(", "self", ".", "model", ",", "\"vis_period\"", ")", "and", "vis_period", ">", "0", ":", "\n", "            ", "self", ".", "model", ".", "vis_period", "=", "-", "1", "\n", "", "self", ".", "vis_period", "=", "vis_period", "\n", "\n", "# Keep gradient for base images in transform.", "\n", "self", ".", "use_base_grad", "=", "False", "\n", "# Use supervised examples for consistency", "\n", "self", ".", "use_supervised_consistency", "=", "use_supervised_consistency", "\n", "self", ".", "augmentor", "=", "augmentor", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment": [[38, 46], ["inputs[].clone", "nm2r.NM2RModel.augmentor", "v.clone", "inputs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "augment", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Noise + motion augmentation.\"\"\"", "\n", "kspace", "=", "inputs", "[", "\"kspace\"", "]", ".", "clone", "(", ")", "\n", "aug_kspace", "=", "self", ".", "augmentor", "(", "kspace", ",", "clone", "=", "False", ")", "\n", "\n", "inputs", "=", "{", "k", ":", "v", ".", "clone", "(", ")", "for", "k", ",", "v", "in", "inputs", ".", "items", "(", ")", "if", "k", "!=", "\"kspace\"", "}", "\n", "inputs", "[", "\"kspace\"", "]", "=", "aug_kspace", "\n", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.visualize_aug_training": [[47, 92], ["meddlr.utils.events.get_event_storage", "torch.no_grad", "meddlr.ops.complex.is_complex", "[].unsqueeze", "meddlr.ops.complex.is_complex", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "torch.cat", "torch.cat", "torch.cat", "imgs_to_write.items", "torch.view_as_real", "torch.view_as_real", "meddlr.ops.complex.abs", "[].unsqueeze", "torch.cat.append", "torch.cat.append", "meddlr.ops.complex.angle", "meddlr.ops.complex.abs", "meddlr.ops.complex.get_mask", "meddlr.ops.complex.abs", "torchvision.make_grid.squeeze().unsqueeze", "torchvision.make_grid", "meddlr.utils.events.get_event_storage.put_image", "meddlr.ops.complex.abs", "torchvision.make_grid.numpy", "torch.view_as_real.cpu", "torch.view_as_real.cpu", "[].unsqueeze.cpu", "[].unsqueeze.cpu", "torchvision.make_grid.squeeze", "[].unsqueeze.cpu"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "def", "visualize_aug_training", "(", "self", ",", "kspace", ",", "kspace_aug", ",", "preds", ",", "preds_base", ",", "target", "=", "None", ")", ":", "\n", "        ", "\"\"\"Visualize training of augmented data.\n\n        Args:\n            kspace: The base kspace.\n            kspace_aug: The augmented kspace.\n            preds: Reconstruction of augmented kspace. Shape: NxHxWx2.\n            preds_base: Reconstruction of base kspace. Shape: NxHxWx2.\n        \"\"\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# calc mask for first coil only", "\n", "            ", "if", "cplx", ".", "is_complex", "(", "kspace", ")", ":", "\n", "                ", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "", "kspace", "=", "kspace", ".", "cpu", "(", ")", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "if", "cplx", ".", "is_complex", "(", "kspace_aug", ")", ":", "\n", "                ", "kspace_aug", "=", "torch", ".", "view_as_real", "(", "kspace_aug", ")", "\n", "", "kspace_aug", "=", "kspace_aug", ".", "cpu", "(", ")", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "preds", "=", "preds", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "preds_base", "=", "preds_base", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "all_images", "=", "[", "preds", ",", "preds_base", "]", "\n", "errors", "=", "[", "cplx", ".", "abs", "(", "preds_base", "-", "preds", ")", "]", "\n", "if", "target", "is", "not", "None", ":", "\n", "                ", "target", "=", "target", ".", "cpu", "(", ")", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", "\n", "all_images", ".", "append", "(", "target", ")", "\n", "errors", ".", "append", "(", "cplx", ".", "abs", "(", "target", "-", "preds", ")", ")", "\n", "\n", "", "all_images", "=", "torch", ".", "cat", "(", "all_images", ",", "dim", "=", "2", ")", "\n", "all_kspace", "=", "torch", ".", "cat", "(", "[", "kspace", ",", "kspace_aug", "]", ",", "dim", "=", "2", ")", "\n", "errors", "=", "torch", ".", "cat", "(", "errors", ",", "dim", "=", "2", ")", "\n", "\n", "imgs_to_write", "=", "{", "\n", "\"phases\"", ":", "cplx", ".", "angle", "(", "all_images", ")", ",", "\n", "\"images\"", ":", "cplx", ".", "abs", "(", "all_images", ")", ",", "\n", "\"errors\"", ":", "errors", ",", "\n", "\"masks\"", ":", "cplx", ".", "get_mask", "(", "kspace", ")", ",", "\n", "\"kspace\"", ":", "cplx", ".", "abs", "(", "all_kspace", ")", ",", "\n", "}", "\n", "\n", "for", "name", ",", "data", "in", "imgs_to_write", ".", "items", "(", ")", ":", "\n", "                ", "data", "=", "data", ".", "squeeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "data", "=", "tv_utils", ".", "make_grid", "(", "data", ",", "nrow", "=", "1", ",", "padding", "=", "1", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", ")", "\n", "storage", ".", "put_image", "(", "\"train_aug/{}\"", ".", "format", "(", "name", ")", ",", "data", ".", "numpy", "(", ")", ",", "data_format", "=", "\"CHW\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.forward": [[93, 155], ["inputs.get.get.get", "inputs.get.get.get", "inputs.get.get.get", "nm2r.NM2RModel.model", "meddlr.utils.events.get_event_storage", "ValueError", "nm2r.NM2RModel.model", "inputs_consistency.append", "inputs_consistency.append", "len", "nm2r.NM2RModel.augment", "nm2r.NM2RModel.model", "nm2r.NM2RModel.detach", "len", "torch.no_grad", "nm2r.NM2RModel.model", "inputs.get.get.get", "nm2r.NM2RModel.visualize_aug_training", "torch.cat", "inputs.get.get.items", "inputs_consistency[].keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.augment", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.visualize_aug_training", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "not", "self", ".", "training", ":", "\n", "            ", "assert", "(", "\n", "\"unsupervised\"", "not", "in", "inputs", "\n", ")", ",", "\"unsupervised inputs should not be provided in eval mode\"", "\n", "inputs", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "inputs", ")", "\n", "return", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "", "vis_training", "=", "False", "\n", "if", "self", ".", "training", "and", "self", ".", "vis_period", ">", "0", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "vis_training", "=", "True", "\n", "\n", "", "", "inputs_supervised", "=", "inputs", ".", "get", "(", "\"supervised\"", ",", "None", ")", "\n", "inputs_unsupervised", "=", "inputs", ".", "get", "(", "\"unsupervised\"", ",", "None", ")", "\n", "if", "inputs_supervised", "is", "None", "and", "inputs_unsupervised", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Examples not formatted in the proper way\"", ")", "\n", "", "output_dict", "=", "{", "}", "\n", "\n", "# Recon", "\n", "if", "inputs_supervised", "is", "not", "None", ":", "\n", "            ", "output_dict", "[", "\"recon\"", "]", "=", "self", ".", "model", "(", "\n", "inputs_supervised", ",", "return_pp", "=", "True", ",", "vis_training", "=", "vis_training", "\n", ")", "\n", "\n", "# Consistency.", "\n", "", "inputs_consistency", "=", "[", "]", "\n", "if", "inputs_unsupervised", "is", "not", "None", ":", "\n", "            ", "inputs_consistency", ".", "append", "(", "inputs_unsupervised", ")", "\n", "", "if", "self", ".", "use_supervised_consistency", "and", "inputs_supervised", "is", "not", "None", ":", "\n", "            ", "inputs_consistency", ".", "append", "(", "{", "k", ":", "v", "for", "k", ",", "v", "in", "inputs_supervised", ".", "items", "(", ")", "if", "k", "!=", "\"target\"", "}", ")", "\n", "\n", "", "if", "len", "(", "inputs_consistency", ")", ">", "0", ":", "\n", "            ", "if", "len", "(", "inputs_consistency", ")", ">", "1", ":", "\n", "                ", "inputs_consistency", "=", "{", "\n", "k", ":", "torch", ".", "cat", "(", "[", "x", "[", "k", "]", "for", "x", "in", "inputs_consistency", "]", ",", "dim", "=", "0", ")", "\n", "for", "k", "in", "inputs_consistency", "[", "0", "]", ".", "keys", "(", ")", "\n", "}", "\n", "", "else", ":", "\n", "                ", "inputs_consistency", "=", "inputs_consistency", "[", "0", "]", "\n", "", "inputs_consistency_aug", "=", "self", ".", "augment", "(", "inputs_consistency", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "pred_base", "=", "self", ".", "model", "(", "inputs_consistency", ")", "\n", "# Target only used for visualization purposes not for loss.", "\n", "target", "=", "inputs_unsupervised", ".", "get", "(", "\"target\"", ",", "None", ")", "\n", "pred_base", "=", "pred_base", "[", "\"pred\"", "]", "\n", "", "pred_aug", "=", "self", ".", "model", "(", "inputs_consistency_aug", ",", "return_pp", "=", "True", ")", "\n", "if", "\"target\"", "in", "pred_aug", ":", "\n", "                ", "del", "pred_aug", "[", "\"target\"", "]", "\n", "", "pred_aug", "[", "\"target\"", "]", "=", "pred_base", ".", "detach", "(", ")", "\n", "output_dict", "[", "\"consistency\"", "]", "=", "pred_aug", "\n", "if", "vis_training", ":", "\n", "                ", "self", ".", "visualize_aug_training", "(", "\n", "inputs_consistency", "[", "\"kspace\"", "]", ",", "\n", "inputs_consistency_aug", "[", "\"kspace\"", "]", ",", "\n", "pred_aug", "[", "\"pred\"", "]", ",", "\n", "pred_base", ",", "\n", "target", "=", "target", ",", "\n", ")", "\n", "\n", "", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.load_state_dict": [[156, 164], ["any", "super().load_state_dict", "ValueError", "x.startswith", "state_dict.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.load_state_dict"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ",", "strict", "=", "True", ")", ":", "\n", "# TODO: Configure backwards compatibility", "\n", "        ", "if", "any", "(", "x", ".", "startswith", "(", "\"unrolled\"", ")", "for", "x", "in", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`self.unrolled` was renamed to `self.model`. \"", "\n", "\"Backwards compatibility has not been configured.\"", "\n", ")", "\n", "", "return", "super", "(", ")", ".", "load_state_dict", "(", "state_dict", ",", "strict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.nm2r.NM2RModel.from_config": [[165, 180], ["cfg.clone", "cfg.clone.defrost", "cfg.clone.freeze", "meddlr.modeling.meta_arch.build.build_model", "meddlr.data.transforms.noiseandmotion.NoiseAndMotionModel.from_cfg"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "model_cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "model_cfg", ".", "defrost", "(", ")", "\n", "model_cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "=", "cfg", ".", "MODEL", ".", "NM2R", ".", "META_ARCHITECTURE", "\n", "model_cfg", ".", "freeze", "(", ")", "\n", "model", "=", "build_model", "(", "model_cfg", ")", "\n", "\n", "augmentor", "=", "NoiseAndMotionModel", ".", "from_cfg", "(", "cfg", ")", "\n", "\n", "return", "{", "\n", "\"model\"", ":", "model", ",", "\n", "\"augmentor\"", ":", "augmentor", ",", "\n", "\"use_supervised_consistency\"", ":", "cfg", ".", "MODEL", ".", "NM2R", ".", "USE_SUPERVISED_CONSISTENCY", ",", "\n", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.__init__": [[36, 79], ["torch.nn.Module.__init__", "isinstance", "len", "torch.nn.ParameterList", "isinstance", "torch.nn.ModuleList", "isinstance", "TypeError", "ValueError", "torch.tensor", "len", "ValueError", "torch.tensor", "isinstance", "isinstance", "range", "torch.nn.Parameter"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "blocks", ":", "Union", "[", "nn", ".", "Module", ",", "Sequence", "[", "nn", ".", "Module", "]", "]", ",", "\n", "step_sizes", ":", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", "=", "-", "2.0", ",", "\n", "fix_step_size", ":", "bool", "=", "False", ",", "\n", "num_emaps", ":", "int", "=", "1", ",", "\n", "vis_period", ":", "int", "=", "-", "1", ",", "\n", "num_grad_steps", ":", "int", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "resnets", "=", "blocks", "\n", "if", "num_grad_steps", "is", "None", ":", "\n", "            ", "if", "isinstance", "(", "blocks", ",", "Sequence", ")", "and", "not", "isinstance", "(", "blocks", ",", "nn", ".", "ModuleList", ")", ":", "\n", "                ", "blocks", "=", "nn", ".", "ModuleList", "(", "blocks", ")", "\n", "", "if", "not", "isinstance", "(", "blocks", ",", "nn", ".", "ModuleList", ")", ":", "\n", "                ", "raise", "TypeError", "(", "\"`blocks` must be a sequence of nn.Modules or a nn.ModuleList\"", ")", "\n", "", "num_grad_steps", "=", "len", "(", "blocks", ")", "\n", "num_repeat_steps", "=", "0", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "num_grad_steps", ",", "int", ")", "or", "num_grad_steps", "<=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"`num_grad_steps` must be positive integer\"", ")", "\n", "", "num_repeat_steps", "=", "num_grad_steps", "\n", "\n", "", "if", "isinstance", "(", "step_sizes", ",", "Number", ")", ":", "\n", "            ", "step_sizes", "=", "[", "\n", "torch", ".", "tensor", "(", "[", "step_sizes", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "for", "_", "in", "range", "(", "num_grad_steps", ")", "\n", "]", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "step_sizes", ")", "!=", "num_grad_steps", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"`step_sizes` must be a single value or a list of the \"", "\n", "\"same length as `blocks` or `num_grad_steps`\"", "\n", ")", "\n", "", "step_sizes", "=", "[", "torch", ".", "tensor", "(", "s", ")", "for", "s", "in", "step_sizes", "]", "\n", "", "if", "not", "fix_step_size", ":", "\n", "            ", "step_sizes", "=", "nn", ".", "ParameterList", "(", "[", "nn", ".", "Parameter", "(", "s", ")", "for", "s", "in", "step_sizes", "]", ")", "\n", "", "self", ".", "step_sizes", ":", "Sequence", "[", "Union", "[", "torch", ".", "Tensor", ",", "nn", ".", "Parameter", "]", "]", "=", "step_sizes", "\n", "\n", "self", ".", "num_repeat_steps", "=", "num_repeat_steps", "\n", "self", ".", "num_emaps", "=", "num_emaps", "\n", "self", ".", "vis_period", "=", "vis_period", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.visualize_training": [[80, 110], ["meddlr.utils.events.get_event_storage", "torch.no_grad", "meddlr.is_complex", "kspace[].unsqueeze().cpu", "targets[].unsqueeze().cpu", "preds[].unsqueeze().cpu", "zfs[].unsqueeze().cpu", "torch.cat", "imgs_to_write.items", "torch.view_as_real", "meddlr.angle", "meddlr.abs", "meddlr.abs", "meddlr.get_mask", "torchvision.make_grid.squeeze().unsqueeze", "torchvision.make_grid", "meddlr.utils.events.get_event_storage.put_image", "kspace[].unsqueeze", "targets[].unsqueeze", "preds[].unsqueeze", "zfs[].unsqueeze", "torchvision.make_grid.numpy", "torchvision.make_grid.squeeze"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_image"], ["", "def", "visualize_training", "(", "self", ",", "kspace", ",", "zfs", ",", "targets", ",", "preds", ")", ":", "\n", "        ", "\"\"\"A function used to visualize reconstructions.\n\n        Args:\n            targets: NxHxWx2 tensors of target images.\n            preds: NxHxWx2 tensors of predictions.\n        \"\"\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "cplx", ".", "is_complex", "(", "kspace", ")", ":", "\n", "                ", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "", "kspace", "=", "kspace", "[", "0", ",", "...", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "# calc mask for first coil only", "\n", "targets", "=", "targets", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "preds", "=", "preds", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "zfs", "=", "zfs", "[", "0", ",", "...", "]", ".", "unsqueeze", "(", "0", ")", ".", "cpu", "(", ")", "\n", "\n", "all_images", "=", "torch", ".", "cat", "(", "[", "zfs", ",", "preds", ",", "targets", "]", ",", "dim", "=", "2", ")", "\n", "\n", "imgs_to_write", "=", "{", "\n", "\"phases\"", ":", "cplx", ".", "angle", "(", "all_images", ")", ",", "\n", "\"images\"", ":", "cplx", ".", "abs", "(", "all_images", ")", ",", "\n", "\"errors\"", ":", "cplx", ".", "abs", "(", "preds", "-", "targets", ")", ",", "\n", "\"masks\"", ":", "cplx", ".", "get_mask", "(", "kspace", ")", ",", "\n", "}", "\n", "\n", "for", "name", ",", "data", "in", "imgs_to_write", ".", "items", "(", ")", ":", "\n", "                ", "data", "=", "data", ".", "squeeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "data", "=", "tv_utils", ".", "make_grid", "(", "data", ",", "nrow", "=", "1", ",", "padding", "=", "1", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", ")", "\n", "storage", ".", "put_image", "(", "\"train/{}\"", ".", "format", "(", "name", ")", ",", "data", ".", "numpy", "(", ")", ",", "data_format", "=", "\"CHW\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.forward": [[111, 218], ["meddlr.utils.general.move_to_device", "meddlr.utils.general.move_to_device.get", "meddlr.utils.general.move_to_device.get", "meddlr.utils.general.move_to_device.get", "tuple", "meddlr.forward.mri.SenseModel.", "zip", "ValueError", "next", "meddlr.is_complex_as_real", "ValueError", "x.to", "meddlr.get_mask", "kspace.size", "meddlr.forward.mri.SenseModel", "meddlr.is_complex", "torch.view_as_complex.reshape().permute", "torch.view_as_complex.permute().reshape", "output_dict.update", "meddlr.utils.events.get_event_storage", "conv_blocks[].parameters", "meddlr.forward.mri.SenseModel.", "torch.view_as_real", "hasattr", "callable", "resnet.base_forward", "resnet", "torch.view_as_complex.is_contiguous", "torch.view_as_complex.contiguous", "torch.view_as_complex", "unrolled.GeneralizedUnrolledCNN.visualize_training", "maps.size", "maps.size", "meddlr.forward.mri.SenseModel.", "torch.view_as_complex.reshape", "torch.view_as_complex.permute"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.general.move_to_device", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unet.UnetModel.base_forward", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.visualize_training"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ",", "return_pp", "=", "False", ",", "vis_training", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        TODO: condense into list of dataset dicts.\n        Args:\n            inputs: Standard meddlr module input dictionary\n                * \"kspace\": Kspace. If fully sampled, and want to simulate\n                    undersampled kspace, provide \"mask\" argument.\n                * \"maps\": Sensitivity maps\n                * \"target\" (optional): Target image (typically fully sampled).\n                * \"mask\" (optional): Undersampling mask to apply.\n                * \"signal_model\" (optional): The signal model. If provided,\n                    \"maps\" will not be used to estimate the signal model.\n                    Use with caution.\n            return_pp (bool, optional): If `True`, return post-processing\n                parameters \"mean\", \"std\", and \"norm\" if included in the input.\n            vis_training (bool, optional): If `True`, force visualize training\n                on this pass. Can only be `True` if model is in training mode.\n\n        Returns:\n            Dict: A standard meddlr output dict\n                * \"pred\": The reconstructed image\n                * \"target\" (optional): The target image.\n                    Added if provided in the input.\n                * \"mean\"/\"std\"/\"norm\" (optional): Pre-processing parameters.\n                    Added if provided in the input.\n                * \"zf_image\": The zero-filled image.\n                    Added when model is in eval mode.\n        \"\"\"", "\n", "if", "self", ".", "num_repeat_steps", ">", "0", ":", "\n", "            ", "conv_blocks", "=", "[", "self", ".", "resnets", "]", "*", "self", ".", "num_repeat_steps", "\n", "", "else", ":", "\n", "            ", "conv_blocks", "=", "self", ".", "resnets", "\n", "\n", "", "if", "vis_training", "and", "not", "self", ".", "training", ":", "\n", "            ", "raise", "ValueError", "(", "\"vis_training is only applicable in training mode.\"", ")", "\n", "# Need to fetch device at runtime for proper data transfer.", "\n", "", "device", "=", "next", "(", "conv_blocks", "[", "0", "]", ".", "parameters", "(", ")", ")", ".", "device", "\n", "inputs", "=", "move_to_device", "(", "inputs", ",", "device", ")", "\n", "kspace", "=", "inputs", "[", "\"kspace\"", "]", "\n", "target", "=", "inputs", ".", "get", "(", "\"target\"", ",", "None", ")", "\n", "mask", "=", "inputs", ".", "get", "(", "\"mask\"", ",", "None", ")", "\n", "A", "=", "inputs", ".", "get", "(", "\"signal_model\"", ",", "None", ")", "\n", "maps", "=", "inputs", "[", "\"maps\"", "]", "\n", "num_maps_dim", "=", "-", "2", "if", "cplx", ".", "is_complex_as_real", "(", "maps", ")", "else", "-", "1", "\n", "if", "self", ".", "num_emaps", "!=", "maps", ".", "size", "(", ")", "[", "num_maps_dim", "]", "and", "maps", ".", "size", "(", ")", "[", "num_maps_dim", "]", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Incorrect number of ESPIRiT maps! Re-prep data...\"", ")", "\n", "\n", "# Move step sizes to the right device.", "\n", "", "step_sizes", "=", "[", "x", ".", "to", "(", "device", ")", "for", "x", "in", "self", ".", "step_sizes", "]", "\n", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "cplx", ".", "get_mask", "(", "kspace", ")", "\n", "", "kspace", "*=", "mask", "\n", "\n", "# Get data dimensions", "\n", "dims", "=", "tuple", "(", "kspace", ".", "size", "(", ")", ")", "\n", "\n", "# Declare signal model.", "\n", "if", "A", "is", "None", ":", "\n", "            ", "A", "=", "SenseModel", "(", "maps", ",", "weights", "=", "mask", ")", "\n", "\n", "# Compute zero-filled image reconstruction", "\n", "", "zf_image", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "\n", "# Begin unrolled proximal gradient descent", "\n", "image", "=", "zf_image", "\n", "for", "resnet", ",", "step_size", "in", "zip", "(", "conv_blocks", ",", "step_sizes", ")", ":", "\n", "# dc update", "\n", "            ", "grad_x", "=", "A", "(", "A", "(", "image", ")", ",", "adjoint", "=", "True", ")", "-", "zf_image", "\n", "image", "=", "image", "+", "step_size", "*", "grad_x", "\n", "\n", "# If the image is a complex tensor, we view it as a real image", "\n", "# where last dimension has 2 channels (real, imaginary).", "\n", "# This may take more time, but is done for backwards compatibility", "\n", "# reasons.", "\n", "# TODO (arjundd): Fix to auto-detect which version of the model is", "\n", "# being used.", "\n", "use_cplx", "=", "cplx", ".", "is_complex", "(", "image", ")", "\n", "if", "use_cplx", ":", "\n", "                ", "image", "=", "torch", ".", "view_as_real", "(", "image", ")", "\n", "\n", "# prox update", "\n", "", "image", "=", "image", ".", "reshape", "(", "dims", "[", "0", ":", "3", "]", "+", "(", "self", ".", "num_emaps", "*", "2", ",", ")", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "if", "hasattr", "(", "resnet", ",", "\"base_forward\"", ")", "and", "callable", "(", "resnet", ".", "base_forward", ")", ":", "\n", "                ", "image", "=", "resnet", ".", "base_forward", "(", "image", ")", "\n", "", "else", ":", "\n", "                ", "image", "=", "resnet", "(", "image", ")", "\n", "\n", "", "image", "=", "image", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "dims", "[", "0", ":", "3", "]", "+", "(", "self", ".", "num_emaps", ",", "2", ")", ")", "\n", "if", "not", "image", ".", "is_contiguous", "(", ")", ":", "\n", "                ", "image", "=", "image", ".", "contiguous", "(", ")", "\n", "", "if", "use_cplx", ":", "\n", "                ", "image", "=", "torch", ".", "view_as_complex", "(", "image", ")", "\n", "\n", "", "", "output_dict", "=", "{", "\"pred\"", ":", "image", ",", "\"target\"", ":", "target", "}", "# N x Y x Z x 1 x 2  # N x Y x Z x 1 x 2", "\n", "\n", "if", "return_pp", ":", "\n", "            ", "output_dict", ".", "update", "(", "{", "k", ":", "inputs", "[", "k", "]", "for", "k", "in", "[", "\"mean\"", ",", "\"std\"", ",", "\"norm\"", "]", "}", ")", "\n", "\n", "", "if", "self", ".", "training", "and", "(", "vis_training", "or", "self", ".", "vis_period", ">", "0", ")", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "vis_training", "or", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "self", ".", "visualize_training", "(", "kspace", ",", "zf_image", ",", "target", ",", "image", ")", "\n", "\n", "", "", "output_dict", "[", "\"zf_image\"", "]", "=", "zf_image", "\n", "\n", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled.GeneralizedUnrolledCNN.from_config": [[219, 262], ["cfg.clone().defrost", "mcfg.freeze.freeze.freeze", "builder", "torch.nn.ModuleList", "len", "unrolled._build_resblock", "build.build_model", "cfg.clone", "builder", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled._build_resblock", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Note:\n            Currently, only resblocks can be constructed from the config.\n            Step sizes are currently fixed at initialization to -2.0.\n        \"\"\"", "\n", "# Extract network parameters", "\n", "num_grad_steps", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "NUM_UNROLLED_STEPS", "\n", "share_weights", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "SHARE_WEIGHTS", "\n", "\n", "# Data dimensions", "\n", "num_emaps", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "NUM_EMAPS", "\n", "\n", "# Determine block to use for each unrolled step.", "\n", "if", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "BLOCK_ARCHITECTURE", "==", "\"ResNet\"", ":", "\n", "            ", "builder", "=", "lambda", ":", "_build_resblock", "(", "cfg", ")", "# noqa: E731", "\n", "", "else", ":", "\n", "# TODO: Fix any inconsistencies between config's IN_CHANNELS", "\n", "# and the number of channels that the unrolled net expects.", "\n", "            ", "mcfg", "=", "cfg", ".", "clone", "(", ")", ".", "defrost", "(", ")", "\n", "mcfg", ".", "MODEL", ".", "META_ARCHITECTURE", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "BLOCK_ARCHITECTURE", "\n", "mcfg", "=", "mcfg", ".", "freeze", "(", ")", "\n", "builder", "=", "lambda", ":", "build_model", "(", "mcfg", ")", "# noqa: E731", "\n", "\n", "# Declare ResNets and RNNs for each unrolled iteration", "\n", "", "if", "share_weights", ":", "\n", "            ", "blocks", "=", "builder", "(", ")", "\n", "", "else", ":", "\n", "            ", "blocks", "=", "nn", ".", "ModuleList", "(", "[", "builder", "(", ")", "for", "_", "in", "range", "(", "num_grad_steps", ")", "]", ")", "\n", "\n", "# Step sizes", "\n", "", "step_sizes", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "STEP_SIZES", "\n", "if", "len", "(", "step_sizes", ")", "==", "1", ":", "\n", "            ", "step_sizes", "=", "step_sizes", "[", "0", "]", "\n", "\n", "", "return", "{", "\n", "\"blocks\"", ":", "blocks", ",", "\n", "\"step_sizes\"", ":", "step_sizes", ",", "\n", "\"fix_step_size\"", ":", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "FIX_STEP_SIZE", ",", "\n", "\"num_emaps\"", ":", "num_emaps", ",", "\n", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", ",", "\n", "\"num_grad_steps\"", ":", "num_grad_steps", "if", "share_weights", "else", "None", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.unrolled._build_resblock": [[265, 297], ["dict", "layers.layers2D.ResNet", "len"], "function", ["None"], ["", "", "def", "_build_resblock", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"Build the resblock for unrolled network.\n\n    Args:\n        cfg (CfgNode): The network configuration.\n\n    Note:\n        This is a temporary method used as a base case for building\n        unrolled networks with the default resblocks. In the future,\n        this will be handled by :func:`meddlr.modeling.meta_arch.build_model`.\n    \"\"\"", "\n", "# Data dimensions", "\n", "num_emaps", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "NUM_EMAPS", "\n", "\n", "# ResNet parameters", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "KERNEL_SIZE", "\n", "if", "len", "(", "kernel_size", ")", "==", "1", ":", "\n", "        ", "kernel_size", "=", "kernel_size", "[", "0", "]", "\n", "", "resnet_params", "=", "dict", "(", "\n", "num_resblocks", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "NUM_RESBLOCKS", ",", "\n", "in_chans", "=", "2", "*", "num_emaps", ",", "# complex -> real/imag", "\n", "chans", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "NUM_FEATURES", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "drop_prob", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "DROPOUT", ",", "\n", "circular_pad", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "PADDING", "==", "\"circular\"", ",", "\n", "act_type", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", ".", "ACTIVATION", ",", "\n", "norm_type", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", ".", "NORM", ",", "\n", "norm_affine", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", ".", "NORM_AFFINE", ",", "\n", "order", "=", "cfg", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", ".", "ORDER", ",", "\n", ")", "\n", "\n", "return", "ResNet", "(", "**", "resnet_params", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.test_generalized_unet.TestGeneralizedUnet.test_build": [[10, 16], ["meddlr.config.get_cfg", "meddlr.modeling.meta_arch.GeneralizedUNet"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg"], ["    ", "def", "test_build", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "META_ARCH", "=", "\"GeneralizedUnet\"", "\n", "\n", "model", "=", "GeneralizedUNet", "(", "cfg", ",", "dimensions", "=", "2", ")", "\n", "assert", "model", ".", "depth", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.test_generalized_unet.TestGeneralizedUnet.test_forward": [[17, 29], ["meddlr.modeling.meta_arch.GeneralizedUNet", "torch.randn", "meddlr.modeling.meta_arch.GeneralizedUNet."], "methods", ["None"], ["", "def", "test_forward", "(", "self", ")", ":", "\n", "        ", "model", "=", "GeneralizedUNet", "(", "\n", "dimensions", "=", "2", ",", "\n", "in_channels", "=", "1", ",", "\n", "out_channels", "=", "2", ",", "\n", "channels", "=", "(", "32", ",", "64", ",", "128", ")", ",", "\n", "block_order", "=", "(", "\"conv\"", ",", "\"relu\"", ",", "\"conv\"", ",", "\"relu\"", ",", "\"batchnorm\"", ",", "\"dropout\"", ")", ",", "\n", ")", "\n", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "128", ",", "128", ")", "\n", "out", "=", "model", "(", "x", ")", "\n", "assert", "out", ".", "shape", "==", "(", "1", ",", "2", ",", "128", ",", "128", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.test_build.test_initialize_model": [[7, 22], ["meddlr.modeling.meta_arch.GeneralizedUNet", "meddlr.modeling.meta_arch.build.initialize_model", "meddlr.modeling.meta_arch.build._get_model_layers", "torch.all"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build.initialize_model", "home.repos.pwc.inspect_result.ad12_meddlr.meta_arch.build._get_model_layers"], ["def", "test_initialize_model", "(", ")", ":", "\n", "    ", "model", "=", "GeneralizedUNet", "(", "\n", "dimensions", "=", "2", ",", "\n", "in_channels", "=", "1", ",", "\n", "out_channels", "=", "4", ",", "\n", "channels", "=", "(", "4", ",", "8", ",", "16", ")", ",", "\n", "block_order", "=", "(", "\"conv\"", ",", "\"relu\"", ",", "\"conv\"", ",", "\"relu\"", ",", "\"batchnorm\"", ",", "\"dropout\"", ")", ",", "\n", ")", "\n", "initialize_model", "(", "\n", "model", ",", "initializers", "=", "{", "\"kind\"", ":", "\"conv\"", ",", "\"patterns\"", ":", "\".*bias\"", ",", "\"initializers\"", ":", "\"zeros_\"", "}", "\n", ")", "\n", "\n", "layers_by_kind", "=", "_get_model_layers", "(", "model", ",", "by_kind", "=", "True", ")", "\n", "for", "layer", "in", "layers_by_kind", "[", "\"conv\"", "]", ":", "\n", "        ", "assert", "torch", ".", "all", "(", "layer", ".", "bias", "==", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers2D.ConvBlock.__init__": [[31, 91], ["torch.nn.Module.__init__", "isinstance", "tuple", "order.index", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.Dropout2d", "torch.nn.Conv2d", "meddlr.modeling.layers.conv.ConvWS2d", "torch.nn.Sequential", "all", "ValueError", "len", "order.index", "torch.nn.Identity", "torch.nn.Identity", "torch.nn.InstanceNorm2d", "torch.nn.BatchNorm2d", "torch.nn.GroupNorm", "torch.nn.ReLU", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_chans", ":", "int", ",", "\n", "out_chans", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", "drop_prob", ":", "float", ",", "\n", "act_type", ":", "str", "=", "\"relu\"", ",", "\n", "norm_type", ":", "str", "=", "\"none\"", ",", "\n", "norm_affine", ":", "bool", "=", "False", ",", "\n", "order", ":", "Tuple", "[", "str", ",", "str", ",", "str", ",", "str", "]", "=", "(", "\"norm\"", ",", "\"act\"", ",", "\"drop\"", ",", "\"conv\"", ")", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_chans (int): Number of channels in the input.\n            out_chans (int): Number of channels in the output.\n            drop_prob (float): Dropout probability.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "in_chans", "=", "in_chans", "\n", "self", ".", "out_chans", "=", "out_chans", "\n", "self", ".", "drop_prob", "=", "drop_prob", "\n", "\n", "if", "isinstance", "(", "kernel_size", ",", "int", ")", ":", "\n", "            ", "kernel_size", "=", "(", "kernel_size", ",", "kernel_size", ")", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "kernel_size", ")", "==", "2", "\n", "", "if", "not", "all", "(", "k", "%", "2", "==", "1", "for", "k", "in", "kernel_size", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Kernel size must be odd - got {}\"", ".", "format", "(", "kernel_size", ")", ")", "\n", "\n", "", "padding", "=", "tuple", "(", "k", "//", "2", "for", "k", "in", "kernel_size", ")", "\n", "\n", "# Define choices for each layer in ConvBlock", "\n", "conv_idx", "=", "order", ".", "index", "(", "[", "x", "for", "x", "in", "order", "if", "\"conv\"", "in", "x", "]", "[", "0", "]", ")", "\n", "conv_after_norm", "=", "\"norm\"", "in", "order", "and", "conv_idx", ">", "order", ".", "index", "(", "\"norm\"", ")", "\n", "norm_channels", "=", "in_chans", "if", "conv_after_norm", "else", "out_chans", "\n", "normalizations", "=", "nn", ".", "ModuleDict", "(", "\n", "[", "\n", "[", "\"none\"", ",", "nn", ".", "Identity", "(", ")", "]", ",", "\n", "[", "\"instance\"", ",", "nn", ".", "InstanceNorm2d", "(", "norm_channels", ",", "affine", "=", "norm_affine", ")", "]", ",", "\n", "[", "\"batch\"", ",", "nn", ".", "BatchNorm2d", "(", "norm_channels", ",", "affine", "=", "norm_affine", ")", "]", ",", "\n", "[", "\"group\"", ",", "nn", ".", "GroupNorm", "(", "norm_channels", "//", "8", ",", "norm_channels", ",", "affine", "=", "norm_affine", ")", "]", ",", "\n", "]", "\n", ")", "\n", "activations", "=", "nn", ".", "ModuleDict", "(", "[", "[", "\"relu\"", ",", "nn", ".", "ReLU", "(", ")", "]", ",", "[", "\"leaky_relu\"", ",", "nn", ".", "LeakyReLU", "(", ")", "]", "]", ")", "\n", "dropout", "=", "nn", ".", "Dropout2d", "(", "p", "=", "drop_prob", ")", "\n", "convolution", "=", "nn", ".", "Conv2d", "(", "in_chans", ",", "out_chans", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ")", "\n", "convolution_ws", "=", "ConvWS2d", "(", "in_chans", ",", "out_chans", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ")", "\n", "\n", "layer_dict", "=", "{", "\n", "\"conv\"", ":", "convolution", ",", "\n", "\"conv+ws\"", ":", "convolution_ws", ",", "\n", "\"drop\"", ":", "dropout", ",", "\n", "\"act\"", ":", "activations", "[", "act_type", "]", ",", "\n", "\"norm\"", ":", "normalizations", "[", "norm_type", "]", "if", "norm_type", "in", "normalizations", "else", "nn", ".", "Identity", "(", ")", ",", "\n", "}", "\n", "layers", "=", "[", "layer_dict", "[", "lyr", "]", "for", "lyr", "in", "order", "]", "\n", "\n", "# Define forward pass", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers2D.ConvBlock.forward": [[92, 101], ["layers2D.ConvBlock.layers"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape ``(B,C_{in},D,H,W)``.\n\n        Returns:\n            (torch.Tensor): Output tensor of shape ``(B,C_{in},D,H,W)``.\n        \"\"\"", "\n", "return", "self", ".", "layers", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers2D.ResBlock.__init__": [[109, 148], ["torch.nn.Module.__init__", "torch.nn.Sequential", "layers2D.ConvBlock", "layers2D.ConvBlock", "torch.nn.Conv2d", "torch.nn.Identity"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_chans", ",", "\n", "out_chans", ",", "\n", "kernel_size", ",", "\n", "drop_prob", ",", "\n", "act_type", ":", "str", "=", "\"relu\"", ",", "\n", "norm_type", ":", "str", "=", "\"none\"", ",", "\n", "norm_affine", ":", "bool", "=", "False", ",", "\n", "order", ":", "Tuple", "[", "str", ",", "str", ",", "str", ",", "str", "]", "=", "(", "\"norm\"", ",", "\"act\"", ",", "\"drop\"", ",", "\"conv\"", ")", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_chans (int): Number of channels in the input.\n            out_chans (int): Number of channels in the output.\n            drop_prob (float): Dropout probability.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "\n", "ConvBlock", "(", "\n", "in_chans", ",", "out_chans", ",", "kernel_size", ",", "drop_prob", ",", "act_type", ",", "norm_type", ",", "norm_affine", ",", "order", "\n", ")", ",", "# noqa", "\n", "ConvBlock", "(", "\n", "out_chans", ",", "\n", "out_chans", ",", "\n", "kernel_size", ",", "\n", "drop_prob", ",", "\n", "act_type", ",", "\n", "norm_type", ",", "\n", "norm_affine", ",", "\n", "order", ",", "\n", ")", ",", "# noqa", "\n", ")", "\n", "\n", "if", "in_chans", "!=", "out_chans", ":", "\n", "            ", "self", ".", "resample", "=", "nn", ".", "Conv2d", "(", "in_chans", ",", "out_chans", ",", "kernel_size", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "resample", "=", "nn", ".", "Identity", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers2D.ResBlock.forward": [[149, 162], ["layers2D.ResBlock.resample", "layers2D.ResBlock.layers"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape ``(B,C_{in},D,H,W)``.\n\n        Returns:\n            (torch.Tensor): Output tensor of shape ``(B,C_{in},D,H,W)``.\n        \"\"\"", "\n", "\n", "# To have a residual connection, number of inputs must be equal to outputs", "\n", "shortcut", "=", "self", ".", "resample", "(", "input", ")", "\n", "\n", "return", "self", ".", "layers", "(", "input", ")", "+", "shortcut", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers2D.ResNet.__init__": [[169, 209], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "range", "layers2D._get_same_padding", "torch.nn.Conv2d", "NotImplementedError", "layers2D.ResBlock", "layers2D.ResBlock"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers2D._get_same_padding"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_resblocks", ",", "\n", "in_chans", ",", "\n", "chans", ",", "\n", "kernel_size", ",", "\n", "drop_prob", ",", "\n", "circular_pad", "=", "False", ",", "\n", "act_type", ":", "str", "=", "\"relu\"", ",", "\n", "norm_type", ":", "str", "=", "\"none\"", ",", "\n", "norm_affine", ":", "bool", "=", "False", ",", "\n", "order", ":", "Tuple", "[", "str", ",", "str", ",", "str", ",", "str", "]", "=", "(", "\"norm\"", ",", "\"act\"", ",", "\"drop\"", ",", "\"conv\"", ")", ",", "\n", ")", ":", "\n", "        ", "\"\"\" \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "circular_pad", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Circular padding is not available. \"", "\n", "\"It is retained in the init to be used in the future.\"", "\n", ")", "\n", "", "self", ".", "circular_pad", "=", "circular_pad", "\n", "self", ".", "pad_size", "=", "2", "*", "num_resblocks", "+", "1", "\n", "\n", "resblock_params", "=", "{", "\n", "\"act_type\"", ":", "act_type", ",", "\n", "\"norm_type\"", ":", "norm_type", ",", "\n", "\"norm_affine\"", ":", "norm_affine", ",", "\n", "\"order\"", ":", "order", ",", "\n", "\"kernel_size\"", ":", "kernel_size", ",", "\n", "\"drop_prob\"", ":", "drop_prob", ",", "\n", "}", "\n", "# Declare ResBlock layers", "\n", "self", ".", "res_blocks", "=", "nn", ".", "ModuleList", "(", "[", "ResBlock", "(", "in_chans", ",", "chans", ",", "**", "resblock_params", ")", "]", ")", "\n", "for", "_", "in", "range", "(", "num_resblocks", "-", "1", ")", ":", "\n", "            ", "self", ".", "res_blocks", "+=", "[", "ResBlock", "(", "chans", ",", "chans", ",", "**", "resblock_params", ")", "]", "\n", "\n", "# Declare final conv layer (down-sample to original in_chans)", "\n", "", "padding", "=", "_get_same_padding", "(", "kernel_size", ")", "\n", "self", ".", "final_layer", "=", "nn", ".", "Conv2d", "(", "chans", ",", "in_chans", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers2D.ResNet.forward": [[210, 234], ["res_block", "layers2D.ResNet.final_layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape ``(B,C_{in},D,H,W)``.\n\n        Returns:\n            (torch.Tensor): Output tensor of shape ``(B,C_{in},D,H,W)``.\n        \"\"\"", "\n", "\n", "# orig_shape = input.shape", "\n", "# if self.circular_pad:", "\n", "#     input = nn.functional.pad(", "\n", "#         input, 2 * (self.pad_size,) + (0, 0), mode=\"circular\"", "\n", "#     )", "\n", "\n", "# Perform forward pass through the network", "\n", "output", "=", "input", "\n", "for", "res_block", "in", "self", ".", "res_blocks", ":", "\n", "            ", "output", "=", "res_block", "(", "output", ")", "\n", "", "output", "=", "self", ".", "final_layer", "(", "output", ")", "+", "input", "\n", "\n", "# return center_crop(output, orig_shape)", "\n", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers2D._get_same_padding": [[11, 21], ["isinstance", "tuple", "all", "ValueError", "len"], "function", ["None"], ["def", "_get_same_padding", "(", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", ")", ":", "\n", "    ", "if", "isinstance", "(", "kernel_size", ",", "int", ")", ":", "\n", "        ", "kernel_size", "=", "(", "kernel_size", ",", "kernel_size", ")", "\n", "", "else", ":", "\n", "        ", "assert", "len", "(", "kernel_size", ")", "==", "2", "\n", "", "if", "not", "all", "(", "k", "%", "2", "==", "1", "for", "k", "in", "kernel_size", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Kernel size must be odd - got {}\"", ".", "format", "(", "kernel_size", ")", ")", "\n", "", "padding", "=", "tuple", "(", "k", "//", "2", "for", "k", "in", "kernel_size", ")", "\n", "\n", "return", "padding", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.SeparableConv3d.__init__": [[15, 49], ["torch.nn.Module.__init__", "torch.nn.Conv3d", "torch.nn.Conv3d", "torch.nn.ModuleDict", "torch.nn.Sequential", "int", "torch.nn.Identity", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "in_chans", ",", "out_chans", ",", "kernel_size", ",", "spatial_chans", "=", "None", ",", "act_type", "=", "\"relu\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_chans (int): Number of channels in the input.\n            out_chans (int): Number of channels in the output.\n            kernel_size (int): Size of kernel (repeated for all three dimensions).\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "sp_kernel_size", "=", "(", "1", ",", "kernel_size", ",", "kernel_size", ")", "\n", "sp_pad_size", "=", "(", "0", ",", "1", ",", "1", ")", "\n", "t_kernel_size", "=", "(", "kernel_size", ",", "1", ",", "1", ")", "\n", "t_pad_size", "=", "(", "1", ",", "0", ",", "0", ")", "\n", "\n", "if", "spatial_chans", "is", "None", ":", "\n", "# Force number of spatial features, such that the total number of", "\n", "# parameters is the same as a nn.Conv3D(in_chans, out_chans)", "\n", "            ", "spatial_chans", "=", "(", "kernel_size", "**", "3", ")", "*", "in_chans", "*", "out_chans", "\n", "spatial_chans", "/=", "(", "kernel_size", "**", "2", ")", "*", "in_chans", "+", "kernel_size", "*", "out_chans", "\n", "spatial_chans", "=", "int", "(", "spatial_chans", ")", "\n", "\n", "# Define each layer in SeparableConv3d block", "\n", "", "spatial_conv", "=", "nn", ".", "Conv3d", "(", "\n", "in_chans", ",", "spatial_chans", ",", "kernel_size", "=", "sp_kernel_size", ",", "padding", "=", "sp_pad_size", "\n", ")", "\n", "temporal_conv", "=", "nn", ".", "Conv3d", "(", "\n", "spatial_chans", ",", "out_chans", ",", "kernel_size", "=", "t_kernel_size", ",", "padding", "=", "t_pad_size", "\n", ")", "\n", "\n", "# Define choices for intermediate activation layer", "\n", "activations", "=", "nn", ".", "ModuleDict", "(", "[", "[", "\"none\"", ",", "nn", ".", "Identity", "(", ")", "]", "[", "\"relu\"", ",", "nn", ".", "ReLU", "(", ")", "]", "]", ")", "\n", "\n", "# Define the forward pass", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "spatial_conv", ",", "activations", "[", "act_type", "]", ",", "temporal_conv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.SeparableConv3d.forward": [[50, 59], ["layers3D.SeparableConv3d.layers"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape ``(B,C_{in},D,H,W)``.\n\n        Returns:\n            (torch.Tensor): Output tensor of shape ``(B,C_{in},D,H,W)``.\n        \"\"\"", "\n", "return", "self", ".", "layers", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.ConvBlock.__init__": [[69, 112], ["torch.nn.Module.__init__", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.Dropout3d", "torch.nn.Sequential", "torch.nn.Conv3d", "layers3D.SeparableConv3d", "torch.nn.Identity", "torch.nn.InstanceNorm3d", "torch.nn.BatchNorm3d", "torch.nn.ReLU", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_chans", ",", "\n", "out_chans", ",", "\n", "kernel_size", ",", "\n", "drop_prob", ",", "\n", "conv_type", "=", "\"conv3d\"", ",", "\n", "act_type", "=", "\"relu\"", ",", "\n", "norm_type", "=", "\"none\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_chans (int): Number of channels in the input.\n            out_chans (int): Number of channels in the output.\n            drop_prob (float): Dropout probability.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "in_chans", "=", "in_chans", "\n", "self", ".", "out_chans", "=", "out_chans", "\n", "self", ".", "drop_prob", "=", "drop_prob", "\n", "\n", "# Define choices for each layer in ConvBlock", "\n", "normalizations", "=", "nn", ".", "ModuleDict", "(", "\n", "[", "\n", "[", "\"none\"", ",", "nn", ".", "Identity", "(", ")", "]", ",", "\n", "[", "\"instance\"", ",", "nn", ".", "InstanceNorm3d", "(", "in_chans", ",", "affine", "=", "False", ")", "]", ",", "\n", "[", "\"batch\"", ",", "nn", ".", "BatchNorm3d", "(", "in_chans", ",", "affine", "=", "False", ")", "]", ",", "\n", "]", "\n", ")", "\n", "activations", "=", "nn", ".", "ModuleDict", "(", "[", "[", "\"relu\"", ",", "nn", ".", "ReLU", "(", ")", "]", ",", "[", "\"leaky_relu\"", ",", "nn", ".", "LeakyReLU", "(", ")", "]", "]", ")", "\n", "dropout", "=", "nn", ".", "Dropout3d", "(", "p", "=", "drop_prob", ",", "inplace", "=", "True", ")", "\n", "\n", "# Note: don't use ModuleDict here. Otherwise, the parameters for the un-selected", "\n", "# convolution type will still be initialized and added to model.parameters()", "\n", "if", "conv_type", "==", "\"conv3d\"", ":", "\n", "            ", "convolution", "=", "nn", ".", "Conv3d", "(", "in_chans", ",", "out_chans", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "convolution", "=", "SeparableConv3d", "(", "in_chans", ",", "out_chans", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "1", ")", "\n", "\n", "# Define forward pass", "\n", "", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "\n", "normalizations", "[", "norm_type", "]", ",", "activations", "[", "act_type", "]", ",", "dropout", ",", "convolution", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.ConvBlock.forward": [[114, 123], ["layers3D.ConvBlock.layers"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape ``(B,C_{in},D,H,W)``.\n\n        Returns:\n            (torch.Tensor): Output tensor of shape ``(B,C_{in},D,H,W)``.\n        \"\"\"", "\n", "return", "self", ".", "layers", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.ConvBlock.__repr__": [[124, 127], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "(", "\n", "f\"ConvBlock3D(in_chans={self.in_chans}, out_chans={self.out_chans}, \"", "\n", "f\"drop_prob={self.drop_prob})\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.ResBlock.__init__": [[136, 154], ["torch.nn.Module.__init__", "torch.nn.Sequential", "layers3D.ConvBlock", "layers3D.ConvBlock", "torch.nn.Conv3d", "torch.nn.Identity"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "in_chans", ",", "out_chans", ",", "kernel_size", ",", "drop_prob", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_chans (int): Number of channels in the input.\n            out_chans (int): Number of channels in the output.\n            drop_prob (float): Dropout probability.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "\n", "ConvBlock", "(", "in_chans", ",", "out_chans", ",", "kernel_size", ",", "drop_prob", ")", ",", "\n", "ConvBlock", "(", "out_chans", ",", "out_chans", ",", "kernel_size", ",", "drop_prob", ")", ",", "\n", ")", "\n", "\n", "if", "in_chans", "!=", "out_chans", ":", "\n", "            ", "self", ".", "resample", "=", "nn", ".", "Conv3d", "(", "in_chans", ",", "out_chans", ",", "kernel_size", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "resample", "=", "nn", ".", "Identity", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.ResBlock.forward": [[155, 168], ["layers3D.ResBlock.resample", "layers3D.ResBlock.layers"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape ``(B,C_{in},D,H,W)``.\n\n        Returns:\n            (torch.Tensor): Output tensor of shape ``(B,C_{in},D,H,W)``.\n        \"\"\"", "\n", "\n", "# To have a residual connection, number of inputs must be equal to outputs", "\n", "shortcut", "=", "self", ".", "resample", "(", "input", ")", "\n", "\n", "return", "self", ".", "layers", "(", "input", ")", "+", "shortcut", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.ResNet.__init__": [[175, 189], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "range", "torch.nn.Conv3d", "layers3D.ResBlock", "layers3D.ResBlock"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "num_resblocks", ",", "in_chans", ",", "chans", ",", "kernel_size", ",", "drop_prob", ",", "circular_pad", "=", "True", ")", ":", "\n", "        ", "\"\"\" \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "circular_pad", "=", "circular_pad", "\n", "self", ".", "pad_size", "=", "2", "*", "num_resblocks", "+", "1", "\n", "\n", "# Declare ResBlock layers", "\n", "self", ".", "res_blocks", "=", "nn", ".", "ModuleList", "(", "[", "ResBlock", "(", "in_chans", ",", "chans", ",", "kernel_size", ",", "drop_prob", ")", "]", ")", "\n", "for", "_", "in", "range", "(", "num_resblocks", "-", "1", ")", ":", "\n", "            ", "self", ".", "res_blocks", "+=", "[", "ResBlock", "(", "chans", ",", "chans", ",", "kernel_size", ",", "drop_prob", ")", "]", "\n", "\n", "# Declare final conv layer (down-sample to original in_chans)", "\n", "", "self", ".", "final_layer", "=", "nn", ".", "Conv3d", "(", "chans", ",", "in_chans", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.layers3D.ResNet.forward": [[190, 211], ["meddlr.utils.transforms.center_crop", "torch.nn.functional.pad", "res_block", "layers3D.ResNet.final_layer"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.center_crop", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (torch.Tensor): Input tensor of shape ``(B,C_{in},D,H,W)``.\n\n        Returns:\n            (torch.Tensor): Output tensor of shape ``(B,C_{in},D,H,W)``.\n        \"\"\"", "\n", "\n", "orig_shape", "=", "input", ".", "shape", "\n", "if", "self", ".", "circular_pad", ":", "\n", "            ", "input", "=", "nn", ".", "functional", ".", "pad", "(", "input", ",", "(", "0", ",", "0", ",", "0", ",", "0", ")", "+", "2", "*", "(", "self", ".", "pad_size", ",", ")", ",", "mode", "=", "\"circular\"", ")", "\n", "# input = nn.functional.pad(input, 4*(self.pad_size,) + (0,0), mode='replicate')", "\n", "\n", "# Perform forward pass through the network", "\n", "", "output", "=", "input", "\n", "for", "res_block", "in", "self", ".", "res_blocks", ":", "\n", "            ", "output", "=", "res_block", "(", "output", ")", "\n", "", "output", "=", "self", ".", "final_layer", "(", "output", ")", "+", "input", "\n", "\n", "return", "center_crop", "(", "output", ",", "orig_shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type": [[26, 76], ["name.lower.lower", "any", "ValueError", "x.lower", "CUSTOM_LAYERS_REGISTRY.get", "CUSTOM_LAYERS_REGISTRY.get", "_PT_LAYERS_LOWERCASE.get", "CUSTOM_LAYERS_REGISTRY.get", "CUSTOM_LAYERS_REGISTRY.get", "_PT_LAYERS_LOWERCASE.get", "ValueError"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "return", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "\n", "\n", "", "def", "initialize_model", "(", "model", ":", "nn", ".", "Module", ",", "initializers", ":", "Union", "[", "Dict", ",", "Tuple", "]", ")", ":", "\n", "    ", "\"\"\"Initialize the model.\n\n    This function initializes the model using the initialization method\n    specified in ``initializers``.\n\n    ``initializers`` should be a sequence of dicts, where each dict\n    defines the layer type (optional), regex pattern of the parameter\n    name (optional), or the dict. The dict has the following keys:\n\n        * 'kind' (str, optional): The layer kind to apply this (e.g. 'conv', 'norm')\n        * 'patterns' (Tuple[str] | str, optional): The regex patterns of the\n                parameters to use initializer on. If not specified, all parameters\n                of\n        * 'initializers' (Sequence[Callable | str]): The initializers to use on the\n                parameters. These should be called as ``initializer(param)``.\n                These values should be 1:1 with the values in ``'patterns'``.\n\n    Args:\n        model (nn.Model): The model to initialize. Parameters will be fetched\n            with ``model.named_parameters()``.\n        initializers (Dict[str, Union[str, Callable]] | Tuple[str]):\n            See above.\n    \"\"\"", "\n", "_kind_kwd", "=", "\"kind\"", "\n", "_pattern_kwd", "=", "\"patterns\"", "\n", "_init_kwd", "=", "\"initializers\"", "\n", "\n", "if", "isinstance", "(", "initializers", ",", "Dict", ")", ":", "\n", "        ", "initializers", "=", "[", "initializers", "]", "\n", "\n", "# Backwards compatibility with pattern-only initialization.", "\n", "", "if", "isinstance", "(", "initializers", ",", "Sequence", ")", "and", "not", "any", "(", "isinstance", "(", "x", ",", "Dict", ")", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "assert", "len", "(", "initializers", ")", "%", "2", "==", "0", ",", "\"Sequence of regex_to_init must be even\"", "\n", "initializers", "=", "[", "\n", "{", "_pattern_kwd", ":", "k", ",", "_init_kwd", ":", "v", "}", "for", "k", ",", "v", "in", "zip", "(", "initializers", "[", ":", ":", "2", "]", ",", "initializers", "[", "1", ":", ":", "2", "]", ")", "\n", "]", "\n", "\n", "# Convert string values to python literals.", "\n", "", "initializers", "=", "_to_literal", "(", "initializers", ")", "\n", "\n", "if", "not", "all", "(", "\n", "isinstance", "(", "x", ",", "Dict", ")", "or", "(", "isinstance", "(", "x", ",", "Sequence", ")", "and", "len", "(", "x", ")", "==", "2", ")", "for", "x", "in", "initializers", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_kind": [[78, 119], ["isinstance", "issubclass", "name.lower", "hasattr", "build.get_layer_type"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type"], ["\"(pattern, initializer). Got:\\n\\t{}\"", ".", "format", "(", "initializers", ")", "\n", ")", "\n", "\n", "", "initializers", ":", "List", "[", "Dict", "]", "=", "[", "\n", "{", "_pattern_kwd", ":", "x", "[", "0", "]", ",", "_init_kwd", ":", "x", "[", "1", "]", "}", "if", "isinstance", "(", "x", ",", "Sequence", ")", "else", "x", "\n", "for", "x", "in", "initializers", "\n", "]", "\n", "matched_patterns", "=", "{", "}", "\n", "for", "init_cfg", "in", "initializers", ":", "\n", "        ", "pattern", "=", "init_cfg", ".", "pop", "(", "_pattern_kwd", ",", "None", ")", "\n", "if", "pattern", "is", "None", ":", "\n", "            ", "pattern", "=", "(", "\".*\"", ",", ")", "\n", "", "elif", "not", "isinstance", "(", "pattern", ",", "Sequence", ")", "or", "isinstance", "(", "pattern", ",", "str", ")", ":", "\n", "            ", "pattern", "=", "(", "pattern", ",", ")", "\n", "\n", "", "init_method", "=", "init_cfg", ".", "pop", "(", "_init_kwd", ")", "\n", "if", "not", "isinstance", "(", "init_method", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "init_method", "=", "(", "init_method", ",", ")", "\n", "\n", "", "if", "len", "(", "pattern", ")", "!=", "len", "(", "init_method", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Got {} pattern(s) but {} initializer(s):\\n\\t\"", "\n", "\"Patterns: {}\\n\\tInitializers: {}\"", ".", "format", "(", "\n", "len", "(", "pattern", ")", ",", "len", "(", "init_method", ")", ",", "pattern", ",", "init_method", "\n", ")", "\n", ")", "\n", "\n", "", "pattern", "=", "tuple", "(", "\n", "(", "p", ",", ")", "if", "not", "isinstance", "(", "p", ",", "Sequence", ")", "or", "isinstance", "(", "p", ",", "str", ")", "else", "p", "for", "p", "in", "pattern", "\n", ")", "\n", "\n", "init_method", "=", "[", "\n", "getattr", "(", "nn", ".", "init", ",", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "str", ")", "\n", "else", "(", "getattr", "(", "nn", ".", "init", ",", "v", "[", "0", "]", ")", ",", "v", "[", "1", "]", ")", "\n", "if", "isinstance", "(", "v", ",", "Sequence", ")", "\n", "else", "v", "\n", "for", "v", "in", "init_method", "\n", "]", "\n", "init_cfg", "[", "_init_kwd", "]", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "pattern", ",", "init_method", ")", "}", "\n", "for", "pattern_val", "in", "pattern", ":", "\n", "            ", "key", "=", "(", "init_cfg", "[", "_kind_kwd", "]", ",", "pattern_val", ")", "if", "_kind_kwd", "in", "init_cfg", "else", "pattern_val", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.conv.ConvWS2d.__init__": [[23, 39], ["torch.Conv2d.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "out_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "bias", "=", "True", ",", "\n", "eps", "=", "1e-5", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", ",", "padding", ",", "dilation", ",", "groups", ",", "bias", "\n", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.conv.ConvWS2d.forward": [[40, 47], ["weight.view().mean().view", "torch.conv2d", "torch.conv2d", "weight.view().std().view", "std.expand_as", "weight.view().mean", "weight.view().std", "weight.view", "weight.size", "weight.view", "weight.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "weight", "=", "self", ".", "weight", "\n", "weight_mean", "=", "weight", ".", "view", "(", "weight", ".", "size", "(", "0", ")", ",", "-", "1", ")", ".", "mean", "(", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "weight", "=", "weight", "-", "weight_mean", "\n", "std", "=", "weight", ".", "view", "(", "weight", ".", "size", "(", "0", ")", ",", "-", "1", ")", ".", "std", "(", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", "+", "self", ".", "eps", "\n", "weight", "=", "weight", "/", "std", ".", "expand_as", "(", "weight", ")", "\n", "return", "F", ".", "conv2d", "(", "x", ",", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.conv.ConvWS3d.__init__": [[61, 77], ["torch.Conv3d.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "out_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "bias", "=", "True", ",", "\n", "eps", "=", "1e-5", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", ",", "padding", ",", "dilation", ",", "groups", ",", "bias", "\n", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.conv.ConvWS3d.forward": [[78, 85], ["weight.view().mean().view", "torch.conv3d", "torch.conv3d", "weight.view().std().view", "std.expand_as", "weight.view().mean", "weight.view().std", "weight.view", "weight.size", "weight.view", "weight.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "weight", "=", "self", ".", "weight", "\n", "weight_mean", "=", "weight", ".", "view", "(", "weight", ".", "size", "(", "0", ")", ",", "-", "1", ")", ".", "mean", "(", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "weight", "=", "weight", "-", "weight_mean", "\n", "std", "=", "weight", ".", "view", "(", "weight", ".", "size", "(", "0", ")", ",", "-", "1", ")", ".", "std", "(", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", "+", "self", ".", "eps", "\n", "weight", "=", "weight", "/", "std", ".", "expand_as", "(", "weight", ")", "\n", "return", "F", ".", "conv3d", "(", "x", ",", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "groups", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.GaussianBlur.__init__": [[95, 114], ["torch.Module.__init__", "any", "gauss.GaussianBlur.compute_zero_padding", "torch.Parameter", "torch.Parameter", "torch.Parameter", "len", "tuple", "ValueError", "tuple", "gauss.get_gaussian_kernel", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.GaussianBlur.compute_zero_padding", "home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.get_gaussian_kernel"], ["def", "__init__", "(", "\n", "self", ",", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "sigma", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "...", "]", "]", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "kernel_size", "=", "(", "\n", "(", "kernel_size", ",", ")", "if", "not", "isinstance", "(", "kernel_size", ",", "Sequence", ")", "else", "tuple", "(", "kernel_size", ")", "\n", ")", "\n", "if", "any", "(", "k", "%", "2", "==", "0", "for", "k", "in", "kernel_size", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"kernel_size must be odd and positive. Got {}\"", ".", "format", "(", "kernel_size", ")", ")", "\n", "", "sigma", "=", "(", "sigma", ",", ")", "if", "not", "isinstance", "(", "sigma", ",", "Sequence", ")", "else", "tuple", "(", "sigma", ")", "\n", "self", ".", "kernel_size", ":", "Tuple", "[", "int", ",", "...", "]", "=", "kernel_size", "\n", "self", ".", "sigma", ":", "Tuple", "[", "float", ",", "...", "]", "=", "sigma", "\n", "self", ".", "_padding", ":", "Tuple", "[", "int", ",", "...", "]", "=", "self", ".", "compute_zero_padding", "(", "kernel_size", ")", "\n", "self", ".", "kernel", ":", "torch", ".", "Tensor", "=", "nn", ".", "Parameter", "(", "\n", "get_gaussian_kernel", "(", "kernel_size", ",", "sigma", ",", "normalize", "=", "True", ")", ",", "\n", "requires_grad", "=", "False", ",", "\n", ")", "\n", "self", ".", "spatial_dim", "=", "len", "(", "kernel_size", ")", "\n", "self", ".", "conv", "=", "[", "F", ".", "conv1d", ",", "F", ".", "conv2d", ",", "F", ".", "conv3d", "]", "[", "self", ".", "spatial_dim", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.GaussianBlur.compute_zero_padding": [[115, 120], ["tuple"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "compute_zero_padding", "(", "kernel_size", ":", "Tuple", "[", "int", ",", "...", "]", ")", "->", "Tuple", "[", "int", ",", "...", "]", ":", "\n", "        ", "\"\"\"Computes zero padding tuple.\"\"\"", "\n", "computed", "=", "[", "(", "k", "-", "1", ")", "//", "2", "for", "k", "in", "kernel_size", "]", "\n", "return", "tuple", "(", "computed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.GaussianBlur.forward": [[121, 134], ["tmp_kernel.repeat", "gauss.GaussianBlur.conv", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "TypeError", "type"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "if", "not", "torch", ".", "is_tensor", "(", "x", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"Input x type is not a torch.Tensor. Got {}\"", ".", "format", "(", "type", "(", "x", ")", ")", ")", "\n", "\n", "", "c", "=", "x", ".", "shape", "[", "1", "]", "\n", "spatial_dim", "=", "self", ".", "spatial_dim", "\n", "tmp_kernel", ":", "torch", ".", "Tensor", "=", "self", ".", "kernel", "\n", "kernel", ":", "torch", ".", "Tensor", "=", "tmp_kernel", ".", "repeat", "(", "[", "c", ",", "1", "]", "+", "[", "1", "]", "*", "spatial_dim", ")", "\n", "\n", "# TODO: explore solution when using jit.trace since it raises a warning", "\n", "# because the shape is converted to a tensor instead to a int.", "\n", "# convolve tensor with gaussian kernel", "\n", "return", "self", ".", "conv", "(", "x", ",", "kernel", ",", "padding", "=", "self", ".", "_padding", ",", "stride", "=", "1", ",", "groups", "=", "c", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.gaussian": [[12, 21], ["torch.stack", "torch.stack", "torch.stack", "float", "torch.exp", "torch.exp", "torch.exp", "torch.stack.sum", "torch.tensor", "torch.tensor", "torch.tensor", "range", "gauss.gaussian.gauss_fcn"], "function", ["None"], ["def", "gaussian", "(", "window_size", ",", "sigma", ",", "normalize", "=", "True", ")", ":", "\n", "    ", "def", "gauss_fcn", "(", "x", ")", ":", "\n", "        ", "center", "=", "window_size", "//", "2", "if", "window_size", "%", "2", "==", "1", "else", "window_size", "//", "2", "-", "0.5", "\n", "return", "-", "(", "(", "x", "-", "center", ")", "**", "2", ")", "/", "float", "(", "2", "*", "sigma", "**", "2", ")", "\n", "\n", "", "gauss", "=", "torch", ".", "stack", "(", "[", "torch", ".", "exp", "(", "torch", ".", "tensor", "(", "gauss_fcn", "(", "x", ")", ")", ")", "for", "x", "in", "range", "(", "window_size", ")", "]", ")", "\n", "if", "normalize", ":", "\n", "        ", "gauss", "=", "gauss", "/", "gauss", ".", "sum", "(", ")", "\n", "", "return", "gauss", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.get_gaussian_kernel": [[23, 67], ["tuple", "tuple", "torch.einsum", "torch.einsum", "torch.einsum", "any", "TypeError", "len", "len", "ValueError", "len", "isinstance", "isinstance", "isinstance", "gauss.gaussian", "chr", "zip", "range", "ord", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.gaussian"], ["", "def", "get_gaussian_kernel", "(", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Sequence", "[", "int", "]", "]", ",", "\n", "sigma", ":", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", ",", "\n", "normalize", ":", "bool", "=", "True", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Function that returns Gaussian filter coefficients.\n\n    Args:\n        kernel_size (int(s)): filter size. It should be positive.\n        sigma (float(s)): gaussian standard deviation.\n        normalize (bool, optional): If `True`, kernel will be normalized. i.e. `kernel.sum() == 1)\n\n    Returns:\n        Tensor: nD tensor with gaussian filter coefficients. Shape :math:`(\\text{kernel_size})`\n\n    Examples::\n\n        >>> medsegpy.layers.get_gaussian_kernel(3, 2.5)\n        tensor([0.3243, 0.3513, 0.3243])\n\n        >>> medsegpy.layers.get_gaussian_kernel((3, 3), (1.5, 1.5))\n        tensor([[0.0947, 0.1183, 0.0947],\n                [0.1183, 0.1478, 0.1183],\n                [0.0947, 0.1183, 0.0947]])\n    \"\"\"", "\n", "kernel_size_seq", "=", "(", "kernel_size", ",", ")", "if", "not", "isinstance", "(", "kernel_size", ",", "Sequence", ")", "else", "kernel_size", "\n", "sigma_seq", "=", "(", "sigma", ",", ")", "if", "not", "isinstance", "(", "sigma", ",", "Sequence", ")", "else", "sigma", "\n", "if", "not", "isinstance", "(", "kernel_size", ",", "(", "int", ",", "Tuple", ")", ")", "or", "any", "(", "k", "<=", "0", "for", "k", "in", "kernel_size_seq", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "\"kernel_size must be a (sequence of) odd positive integer. \"", "\n", "\"Got {}\"", ".", "format", "(", "kernel_size", ")", "\n", ")", "\n", "", "if", "len", "(", "kernel_size_seq", ")", "!=", "len", "(", "sigma_seq", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"kernel_size and sigma must have same number of elements. \"", "\n", "\"Got kernel_size={}, sigma={}\"", ".", "format", "(", "kernel_size", ",", "sigma", ")", "\n", ")", "\n", "", "assert", "len", "(", "kernel_size_seq", ")", "<=", "26", "\n", "kernels_1d", "=", "tuple", "(", "\n", "gaussian", "(", "ksize", ",", "sigma", ",", "normalize", ")", "for", "ksize", ",", "sigma", "in", "zip", "(", "kernel_size_seq", ",", "sigma_seq", ")", "\n", ")", "\n", "elems", "=", "tuple", "(", "chr", "(", "ord", "(", "\"a\"", ")", "+", "i", ")", "for", "i", "in", "range", "(", "len", "(", "kernels_1d", ")", ")", ")", "\n", "equation", "=", "\"{}->{}\"", ".", "format", "(", "\",\"", ".", "join", "(", "elems", ")", ",", "\"\"", ".", "join", "(", "elems", ")", ")", "\n", "return", "torch", ".", "einsum", "(", "equation", ",", "*", "kernels_1d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.test_gauss.TestGaussianBlur.test_kernel_normalized": [[9, 15], ["torch.rand().tolist", "meddlr.modeling.layers.gauss.get_gaussian_kernel", "torch.allclose", "meddlr.modeling.layers.gauss.get_gaussian_kernel.sum", "torch.Tensor", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.layers.gauss.get_gaussian_kernel"], ["    ", "def", "test_kernel_normalized", "(", "self", ")", ":", "\n", "        ", "for", "dim", "in", "[", "1", ",", "2", ",", "3", "]", ":", "\n", "            ", "kernel_size", "=", "(", "3", ",", ")", "*", "dim", "\n", "sigma", "=", "torch", ".", "rand", "(", "dim", ")", ".", "tolist", "(", ")", "\n", "kernel", "=", "get_gaussian_kernel", "(", "kernel_size", ",", "sigma", ")", "\n", "assert", "torch", ".", "allclose", "(", "kernel", ".", "sum", "(", ")", ",", "torch", ".", "Tensor", "(", "[", "1.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.test_gauss.TestGaussianBlur.test_filter": [[16, 23], ["torch.zeros", "x.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze().unsqueeze", "meddlr.modeling.layers.gauss.GaussianBlur", "meddlr.modeling.layers.gauss.GaussianBlur.", "x.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze"], "methods", ["None"], ["", "", "def", "test_filter", "(", "self", ")", ":", "\n", "        ", "s", "=", "5", "\n", "x", "=", "torch", ".", "zeros", "(", "s", ",", "s", ",", "s", ")", "\n", "x", "[", "s", "//", "2", ",", "s", "//", "2", ",", "s", "//", "2", "]", "=", "1.0", "\n", "x", "=", "x", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "gauss", "=", "GaussianBlur", "(", "(", "3", ",", "3", ",", "3", ")", ",", "(", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "y", "=", "gauss", "(", "x", ")", "# noqa: F841", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.test_build.test_pt_layers_type": [[7, 78], ["issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type"], ["def", "test_initialize_model", "(", ")", ":", "\n", "    ", "model", "=", "GeneralizedUNet", "(", "\n", "dimensions", "=", "2", ",", "\n", "in_channels", "=", "1", ",", "\n", "out_channels", "=", "4", ",", "\n", "channels", "=", "(", "4", ",", "8", ",", "16", ")", ",", "\n", "block_order", "=", "(", "\"conv\"", ",", "\"relu\"", ",", "\"conv\"", ",", "\"relu\"", ",", "\"batchnorm\"", ",", "\"dropout\"", ")", ",", "\n", ")", "\n", "initialize_model", "(", "\n", "model", ",", "initializers", "=", "{", "\"kind\"", ":", "\"conv\"", ",", "\"patterns\"", ":", "\".*bias\"", ",", "\"initializers\"", ":", "\"zeros_\"", "}", "\n", ")", "\n", "\n", "layers_by_kind", "=", "_get_model_layers", "(", "model", ",", "by_kind", "=", "True", ")", "\n", "for", "layer", "in", "layers_by_kind", "[", "\"conv\"", "]", ":", "\n", "        ", "assert", "torch", ".", "all", "(", "layer", ".", "bias", "==", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.layers.test_build.test_custom_layers_type": [[80, 88], ["issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_type"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type"], []], "home.repos.pwc.inspect_result.ad12_meddlr.layers.test_build.test_custom_layer_conflicting_names": [[90, 94], ["x.lower", "len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.conv_blocks.SimpleConvBlockNd.__init__": [[40, 104], ["isinstance", "enumerate", "torch.Sequential.__init__", "tuple", "meddlr.modeling.layers.build.get_layer_type", "meddlr.modeling.layers.build.get_layer_kind", "zip", "layers.append", "len", "all", "ValueError", "ValueError", "isinstance", "isinstance", "layer_cls", "isinstance", "isinstance", "inspect.signature", "layer_cls", "layer_cls", "layer_cls", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_type", "home.repos.pwc.inspect_result.ad12_meddlr.layers.build.get_layer_kind"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "out_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "dimension", ":", "int", ",", "\n", "stride", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", "=", "1", ",", "\n", "dropout", ":", "float", "=", "0.0", ",", "\n", "order", ":", "Tuple", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "Dict", "]", "]", ",", "...", "]", "=", "(", "\"conv\"", ",", "\"batchnorm\"", ",", "\"relu\"", ",", "\"dropout\"", ")", ",", "\n", "padding", ":", "Union", "[", "str", ",", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", "=", "\"same\"", ",", "\n", ")", ":", "\n", "        ", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "dropout_prob", "=", "dropout", "\n", "\n", "if", "isinstance", "(", "kernel_size", ",", "int", ")", ":", "\n", "            ", "kernel_size", "=", "(", "kernel_size", ",", ")", "*", "dimension", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "kernel_size", ")", "==", "dimension", "\n", "\n", "", "if", "not", "padding", ":", "\n", "            ", "padding", "=", "0", "\n", "", "if", "padding", "==", "\"same\"", ":", "\n", "            ", "if", "not", "all", "(", "k", "%", "2", "==", "1", "for", "k", "in", "kernel_size", ")", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Kernel sizes must be odd - got {kernel_size}\"", ")", "\n", "", "padding", "=", "tuple", "(", "k", "//", "2", "for", "k", "in", "kernel_size", ")", "\n", "", "elif", "not", "isinstance", "(", "padding", ",", "int", ")", "and", "not", "isinstance", "(", "padding", ",", "Tuple", ")", ":", "# TODO: Improve check", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid value for padding '{padding}'\"", ")", "\n", "\n", "", "names", "=", "[", "x", "if", "isinstance", "(", "x", ",", "str", ")", "else", "x", "[", "0", "]", "for", "x", "in", "order", "]", "\n", "layer_classes", "=", "[", "get_layer_type", "(", "layer_name", ",", "dimension", ")", "for", "layer_name", "in", "names", "]", "\n", "layer_kinds", "=", "[", "get_layer_kind", "(", "x", ")", "for", "x", "in", "layer_classes", "]", "\n", "\n", "layers", "=", "[", "]", "\n", "running_num_channels", "=", "in_channels", "\n", "for", "idx", ",", "(", "name", ",", "layer_cls", ",", "kind", ")", "in", "enumerate", "(", "zip", "(", "order", ",", "layer_classes", ",", "layer_kinds", ")", ")", ":", "\n", "            ", "curr_layer", "=", "order", "[", "idx", "]", "\n", "lyr_kwargs", ":", "Dict", "[", "str", ",", "Any", "]", "=", "curr_layer", "[", "1", "]", "if", "isinstance", "(", "curr_layer", "[", "1", "]", ",", "dict", ")", "else", "{", "}", "\n", "if", "kind", "==", "\"conv\"", ":", "\n", "                ", "layer", "=", "layer_cls", "(", "\n", "running_num_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", "stride", "=", "stride", ",", "\n", "**", "lyr_kwargs", ",", "\n", ")", "\n", "running_num_channels", "=", "out_channels", "\n", "", "elif", "kind", "==", "\"norm\"", ":", "\n", "                ", "sig", "=", "inspect", ".", "signature", "(", "layer_cls", ")", "\n", "for", "kwarg_name", "in", "(", "\"num_channels\"", ",", "\"num_features\"", ")", ":", "\n", "                    ", "if", "kwarg_name", "not", "in", "lyr_kwargs", "and", "kwarg_name", "in", "sig", ".", "parameters", ":", "\n", "                        ", "lyr_kwargs", "[", "kwarg_name", "]", "=", "running_num_channels", "\n", "", "", "layer", "=", "layer_cls", "(", "**", "lyr_kwargs", ")", "\n", "", "elif", "kind", "==", "\"dropout\"", ":", "\n", "                ", "layer", "=", "layer_cls", "(", "dropout", ",", "**", "lyr_kwargs", ")", "\n", "", "elif", "kind", "==", "\"act\"", ":", "\n", "                ", "layer", "=", "layer_cls", "(", "**", "lyr_kwargs", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Layer {name} (kind: {kind}) not supported\"", ")", "\n", "", "layers", ".", "append", "(", "layer", ")", "\n", "\n", "# Define forward pass", "\n", "", "super", "(", ")", ".", "__init__", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.conv_blocks.SimpleConvBlock2d.__init__": [[118, 137], ["conv_blocks.SimpleConvBlockNd.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "out_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", "stride", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", "=", "1", ",", "\n", "dropout", ":", "float", "=", "0.0", ",", "\n", "order", ":", "Tuple", "[", "str", ",", "...", "]", "=", "(", "\"conv\"", ",", "\"batchnorm\"", ",", "\"relu\"", ",", "\"dropout\"", ")", ",", "\n", "padding", ":", "Union", "[", "str", ",", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", "=", "\"same\"", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "dimension", "=", "2", ",", "\n", "stride", "=", "stride", ",", "\n", "dropout", "=", "dropout", ",", "\n", "order", "=", "order", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.conv_blocks.SimpleConvBlock3d.__init__": [[152, 171], ["conv_blocks.SimpleConvBlockNd.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "out_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", ",", "int", "]", "]", ",", "\n", "stride", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", "=", "1", ",", "\n", "dropout", ":", "float", "=", "0.0", ",", "\n", "order", ":", "Tuple", "[", "str", ",", "...", "]", "=", "(", "\"conv\"", ",", "\"batchnorm\"", ",", "\"relu\"", ",", "\"dropout\"", ")", ",", "\n", "padding", ":", "Union", "[", "str", ",", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", "=", "\"same\"", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "dimension", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "dropout", "=", "dropout", ",", "\n", "order", "=", "order", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks._SimpleFuseBlockNd.__init__": [[26, 89], ["super().__init__", "kwargs.pop", "torch.ModuleDict", "torch.ModuleDict", "kwargs.pop.index", "ValueError", "ValueError", "meddlr.modeling.blocks.conv_blocks.SimpleConvBlockNd", "enumerate", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "n_blocks", ":", "int", ",", "\n", "dimension", ":", "int", ",", "\n", "connect_before", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_channels (int): Number of channels in the input.\n            kernel_size (`int(s)`): Convolution kernel size.\n            n_blocks (int): Number of conv blocks.\n            dimension (int): Integer specifying the dimension of convolution.\n            connect_before (str, optional): Layer to add residual connection before in conv block.\n                For example, if `n_blocks=1`, conv block `order=(\"conv\", \"batchnorm\", \"relu\")`,\n                and `connect_before=\"relu\"`, residual block will look like below. If `None`,\n                residual connection will be made after full conv block.\n                    x -> Conv -> BatchNorm -> + -> ReLU\n                    |                         ^\n                    |                         |\n                    --------------------------\n            kwargs: `SimpleConvBlockNd` arguments. `in_channels` and `out_channels` required.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_blocks", "=", "n_blocks", "\n", "\n", "# Determine order for connecting before.", "\n", "order", "=", "kwargs", ".", "pop", "(", "\"order\"", ",", "self", ".", "_DEFAULT_CONV_BLOCK_ORDER", ")", "\n", "if", "connect_before", ":", "\n", "            ", "if", "connect_before", "not", "in", "order", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Layer {connect_before} not in conv block `order` ({order})\"", ")", "\n", "", "layer_idx", "=", "order", ".", "index", "(", "connect_before", ")", "\n", "if", "layer_idx", "==", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Layer {connect_before} occurs first in conv block `order` ({order}). \"", "\n", "f\"Reduce n_block by 1, set `connect_before=None`, and add `SimpleConvBlockNd` \"", "\n", "f\"after this residual block.\"", "\n", ")", "\n", "", "standard_order", "=", "[", "order", "]", "*", "(", "self", ".", "n_blocks", "-", "1", ")", "\n", "split_order", "=", "[", "order", "[", ":", "layer_idx", "]", ",", "order", "[", "layer_idx", ":", "]", "]", "\n", "conv_orders", "=", "standard_order", "+", "split_order", "\n", "", "else", ":", "\n", "            ", "conv_orders", "=", "[", "order", "]", "*", "self", ".", "n_blocks", "\n", "", "self", ".", "connect_before", "=", "connect_before", "\n", "\n", "# Build conv blocks", "\n", "self", ".", "blocks", "=", "nn", ".", "ModuleDict", "(", "\n", "{", "\n", "f\"block_{i+1}\"", ":", "SimpleConvBlockNd", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "in_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "dimension", "=", "dimension", ",", "\n", "order", "=", "order", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "for", "i", ",", "order", "in", "enumerate", "(", "conv_orders", ")", "\n", "}", "\n", ")", "\n", "assert", "(", "self", ".", "connect_before", "and", "len", "(", "self", ".", "blocks", ")", "==", "self", ".", "n_blocks", "+", "1", ")", "or", "(", "\n", "not", "self", ".", "connect_before", "and", "len", "(", "self", ".", "blocks", ")", "==", "self", ".", "n_blocks", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks._SimpleFuseBlockNd.forward": [[91, 103], ["range", "fuse_blocks._SimpleFuseBlockNd.fuse"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ConcatBlockNd.fuse"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "x", "\n", "for", "i", "in", "range", "(", "self", ".", "n_blocks", ")", ":", "\n", "            ", "out", "=", "self", ".", "blocks", "[", "f\"block_{i+1}\"", "]", "(", "out", ")", "\n", "\n", "", "out", "=", "self", ".", "fuse", "(", "x", ",", "out", ")", "\n", "\n", "# Handle any remaining layers when connect_before is specified", "\n", "if", "self", ".", "connect_before", ":", "\n", "            ", "out", "=", "self", ".", "blocks", "[", "f\"block_{self.n_blocks + 1}\"", "]", "(", "out", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks._SimpleFuseBlockNd.fuse": [[104, 108], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "fuse", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "\"\"\"Fuse two tensors\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ResBlockNd.__init__": [[133, 143], ["fuse_blocks._SimpleFuseBlockNd.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "n_blocks", ":", "int", ",", "\n", "dimension", ":", "int", ",", "\n", "connect_before", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "kernel_size", ",", "n_blocks", ",", "dimension", ",", "connect_before", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ResBlockNd.fuse": [[144, 146], ["None"], "methods", ["None"], ["", "def", "fuse", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "return", "x", "+", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ResBlock2d.__init__": [[151, 160], ["fuse_blocks.ResBlockNd.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "n_blocks", ":", "int", ",", "\n", "connect_before", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "kernel_size", ",", "n_blocks", ",", "2", ",", "connect_before", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ResBlock3d.__init__": [[165, 174], ["fuse_blocks.ResBlockNd.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "n_blocks", ":", "int", ",", "\n", "connect_before", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "kernel_size", ",", "n_blocks", ",", "3", ",", "connect_before", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ConcatBlockNd.__init__": [[195, 205], ["fuse_blocks._SimpleFuseBlockNd.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "n_blocks", ":", "int", ",", "\n", "dimension", ":", "int", ",", "\n", "connect_before", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "kernel_size", ",", "n_blocks", ",", "dimension", ",", "connect_before", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ConcatBlockNd.fuse": [[206, 208], ["torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "fuse", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "return", "torch", ".", "cat", "(", "[", "x", ",", "y", "]", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ConcatBlock2d.__init__": [[213, 222], ["fuse_blocks.ConcatBlockNd.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "n_blocks", ":", "int", ",", "\n", "connect_before", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "kernel_size", ",", "n_blocks", ",", "2", ",", "connect_before", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.fuse_blocks.ConcatBlock3d.__init__": [[227, 236], ["fuse_blocks.ConcatBlockNd.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ":", "int", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "n_blocks", ":", "int", ",", "\n", "connect_before", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "kernel_size", ",", "n_blocks", ",", "3", ",", "connect_before", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.test_basic.TestSimpleConvBlock.test_structure": [[15, 39], ["meddlr.modeling.blocks.conv_blocks.SimpleConvBlockNd", "all", "meddlr.modeling.blocks.conv_blocks.SimpleConvBlockNd", "all", "isinstance", "isinstance", "zip", "zip"], "methods", ["None"], ["    ", "def", "test_structure", "(", "self", ")", ":", "\n", "# 2D", "\n", "        ", "block", "=", "SimpleConvBlockNd", "(", "16", ",", "32", ",", "3", ",", "2", ",", "dropout", "=", "0.5", ")", "\n", "assert", "all", "(", "\n", "[", "\n", "isinstance", "(", "x", ",", "cls", ")", "\n", "for", "x", ",", "cls", "in", "zip", "(", "block", ",", "[", "nn", ".", "Conv2d", ",", "nn", ".", "BatchNorm2d", ",", "nn", ".", "ReLU", ",", "nn", ".", "Dropout2d", "]", ")", "\n", "]", "\n", ")", ",", "f\"Got {block}\"", "\n", "assert", "block", "[", "0", "]", ".", "in_channels", "==", "16", "\n", "assert", "block", "[", "0", "]", ".", "out_channels", "==", "32", "\n", "assert", "block", "[", "0", "]", ".", "kernel_size", "==", "(", "3", ",", "3", ")", "\n", "\n", "# 3D", "\n", "block", "=", "SimpleConvBlockNd", "(", "16", ",", "32", ",", "3", ",", "3", ",", "dropout", "=", "0.5", ")", "\n", "assert", "all", "(", "\n", "[", "\n", "isinstance", "(", "x", ",", "cls", ")", "\n", "for", "x", ",", "cls", "in", "zip", "(", "block", ",", "[", "nn", ".", "Conv3d", ",", "nn", ".", "BatchNorm3d", ",", "nn", ".", "ReLU", ",", "nn", ".", "Dropout3d", "]", ")", "\n", "]", "\n", ")", ",", "f\"Got {block}\"", "\n", "assert", "block", "[", "0", "]", ".", "in_channels", "==", "16", "\n", "assert", "block", "[", "0", "]", ".", "out_channels", "==", "32", "\n", "assert", "block", "[", "0", "]", ".", "kernel_size", "==", "(", "3", ",", "3", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.test_basic.TestSimpleConvBlock.test_order": [[40, 51], ["meddlr.modeling.blocks.conv_blocks.SimpleConvBlockNd", "all", "isinstance", "zip"], "methods", ["None"], ["", "def", "test_order", "(", "self", ")", ":", "\n", "# order", "\n", "        ", "block", "=", "SimpleConvBlockNd", "(", "\n", "16", ",", "32", ",", "3", ",", "2", ",", "order", "=", "(", "\"convws\"", ",", "(", "\"groupnorm\"", ",", "{", "\"num_groups\"", ":", "6", "}", ")", ",", "\"relu\"", ")", "\n", ")", "\n", "assert", "all", "(", "\n", "[", "isinstance", "(", "x", ",", "cls", ")", "for", "x", ",", "cls", "in", "zip", "(", "block", ",", "[", "ConvWS2d", ",", "nn", ".", "GroupNorm", ",", "nn", ".", "ReLU", "]", ")", "]", "\n", ")", ",", "f\"Got {block}\"", "\n", "assert", "block", "[", "0", "]", ".", "in_channels", "==", "16", "\n", "assert", "block", "[", "0", "]", ".", "out_channels", "==", "32", "\n", "assert", "block", "[", "0", "]", ".", "kernel_size", "==", "(", "3", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.blocks.test_basic.TestSimpleConvBlock.test_nd_subclass_signature": [[52, 78], ["inspect.getfullargspec", "expected_args.remove", "inspect.getfullargspec", "zip", "zip", "zip", "len", "len"], "methods", ["None"], ["", "def", "test_nd_subclass_signature", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Verify that the signature for SimpleConvBlock2d and SimpleConvBlock3d are the same as\n        SimpleConvBlockNd (except for `dimension`)\n        \"\"\"", "\n", "expected_signature", "=", "inspect", ".", "getfullargspec", "(", "SimpleConvBlockNd", ")", "\n", "expected_args", "=", "expected_signature", ".", "args", "\n", "expected_args", ".", "remove", "(", "\"dimension\"", ")", "\n", "expected_defaults", "=", "{", "\n", "arg", ":", "default", "\n", "for", "arg", ",", "default", "in", "zip", "(", "\n", "expected_signature", ".", "args", "[", "-", "len", "(", "expected_signature", ".", "defaults", ")", ":", "]", ",", "\n", "expected_signature", ".", "defaults", ",", "\n", ")", "\n", "}", "\n", "for", "subclass", "in", "[", "SimpleConvBlock2d", ",", "SimpleConvBlock3d", "]", ":", "\n", "            ", "signature", "=", "inspect", ".", "getfullargspec", "(", "subclass", ")", "\n", "defaults", "=", "{", "\n", "arg", ":", "default", "\n", "for", "arg", ",", "default", "in", "zip", "(", "\n", "signature", ".", "args", "[", "-", "len", "(", "signature", ".", "defaults", ")", ":", "]", ",", "signature", ".", "defaults", "\n", ")", "\n", "}", "\n", "\n", "assert", "[", "x", "==", "e", "for", "x", ",", "e", "in", "zip", "(", "signature", ".", "args", ",", "expected_args", ")", "]", "\n", "assert", "expected_defaults", "==", "defaults", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file": [[27, 74], ["fvcore.common.config.CfgNode.load_yaml_with_base", "logging.getLogger", "fvcore.common.config.CfgNode.load_yaml_with_base.get", "type", "guess_version", "config.CfgNode.merge_from_other_cfg", "logging.getLogger.warning", "downgrade_config", "downgrade_config.merge_from_other_cfg", "upgrade_config", "config.CfgNode.clear", "config.CfgNode.update"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.config.compat.guess_version", "home.repos.pwc.inspect_result.ad12_meddlr.config.compat.downgrade_config", "home.repos.pwc.inspect_result.ad12_meddlr.config.compat.upgrade_config", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Adapted from https://github.com/facebookresearch/detectron2\n        \"\"\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "latest_ver", "==", "self", ".", "VERSION", ",", "(", "\n", "\"CfgNode.merge_from_file is only allowed on a config \"", "\"object of latest version!\"", "\n", ")", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n", "            ", "from", ".", "compat", "import", "downgrade_config", ",", "upgrade_config", "\n", "\n", "logger", ".", "warning", "(", "\n", "\"Loading an old v{} config file '{}' by \"", "\n", "\"automatically upgrading to v{}. \"", "\n", "\"See docs/CHANGELOG.md for instructions to \"", "\n", "\"update your files.\"", ".", "format", "(", "loaded_ver", ",", "cfg_filename", ",", "self", ".", "VERSION", ")", "\n", ")", "\n", "# To convert, first obtain a full config at an old version", "\n", "old_self", "=", "downgrade_config", "(", "self", ",", "to_version", "=", "loaded_ver", ")", "\n", "old_self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "new_config", "=", "upgrade_config", "(", "old_self", ")", "\n", "self", ".", "clear", "(", ")", "\n", "self", ".", "update", "(", "new_config", ")", "\n", "", "return", "self", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_list": [[75, 85], ["super().merge_from_list"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_list"], ["", "def", "merge_from_list", "(", "self", ",", "cfg_list", ":", "list", ")", ":", "\n", "        ", "\"\"\"Update (keys, values) in a list (e.g., from command line).\n\n        For example, ``cfg_list = ['FOO.BAR', 0.5]`` to set ``self.FOO.BAR = 0.5``.\n\n        Args:\n            cfg_list (list): list of configs to merge from.\n        \"\"\"", "\n", "super", "(", ")", ".", "merge_from_list", "(", "cfg_list", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.format_fields": [[86, 102], ["config.format_config_fields"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.format_config_fields"], ["", "def", "format_fields", "(", "self", ",", "unroll", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Format string fields in the config by filling them in\n        with different parameter values.\n\n        The operation is done in place.\n\n        Args:\n            unroll (bool, optional): If ``True``, sequence types (e.g. tuple, list)\n                stringified as ``seq[0]-seq[1]-...``. Dict types will be\n                stringified as ``k[0]=v[0]-k[1]=v[1]-...``.\n\n        Returns:\n            CfgNode: self\n        \"\"\"", "\n", "return", "format_config_fields", "(", "self", ",", "unroll", "=", "unroll", ",", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.get_recursive": [[103, 126], ["key.split", "KeyError"], "methods", ["None"], ["", "def", "get_recursive", "(", "self", ",", "key", ",", "default", ":", "Any", "=", "np", ".", "_NoValue", ")", ":", "\n", "        ", "\"\"\"Get a key recursively from the config.\n\n        Args:\n            key (str): The dot-separated key.\n            default (Any, optional): The value to return if the key is not found.\n                If not provided, a KeyError will be raised.\n\n        Returns:\n            object: The value corresponding to the key.\n\n        Raises:\n            KeyError: If the key is not found and no default was provided.\n        \"\"\"", "\n", "d", "=", "self", "\n", "try", ":", "\n", "            ", "for", "k", "in", "key", ".", "split", "(", "\".\"", ")", ":", "\n", "                ", "d", "=", "d", "[", "k", "]", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "if", "default", "!=", "np", ".", "_NoValue", ":", "\n", "                ", "return", "default", "\n", "", "raise", "KeyError", "(", "\"Config does not have key '{}'\"", ".", "format", "(", "key", ")", ")", "\n", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.set_recursive": [[127, 140], ["name.split", "setattr"], "methods", ["None"], ["", "def", "set_recursive", "(", "self", ",", "name", ":", "str", ",", "value", ":", "Any", ")", ":", "\n", "        ", "\"\"\"Set a key recursively in the config.\n\n        Args:\n            name (str): The dot-separated key.\n            value (object): The value to set.\n        \"\"\"", "\n", "cfg", "=", "self", "\n", "keys", "=", "name", ".", "split", "(", "\".\"", ")", "\n", "for", "k", "in", "keys", "[", ":", "-", "1", "]", ":", "\n", "            ", "cfg", "=", "cfg", "[", "k", "]", "\n", "\n", "", "setattr", "(", "cfg", ",", "keys", "[", "-", "1", "]", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.update_recursive": [[141, 154], ["mapping.items", "config.CfgNode.set_recursive"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.set_recursive"], ["", "def", "update_recursive", "(", "self", ",", "mapping", ":", "Mapping", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "\"\"\"\n        Update this CfgNode and all of its children recursively.\n\n        Args:\n            mapping (dict): a dict to update this CfgNode and all of its children.\n\n        Returns:\n            CfgNode: self\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "set_recursive", "(", "k", ",", "v", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.dump": [[155, 162], ["super().dump"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.dump"], ["", "def", "dump", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "# pragma: no cover", "\n", "        ", "\"\"\"\n        Returns:\n            str: a yaml string representation of the config\n        \"\"\"", "\n", "# to make it show up in docs", "\n", "return", "super", "(", ")", ".", "dump", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze": [[163, 171], ["super().freeze"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze"], ["", "def", "freeze", "(", "self", ")", ":", "\n", "        ", "\"\"\"Make this CfgNode and all of its children immutable.\n\n        Returns:\n            CfgNode: self\n        \"\"\"", "\n", "super", "(", ")", ".", "freeze", "(", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost": [[172, 180], ["super().defrost"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost"], ["", "def", "defrost", "(", "self", ")", ":", "\n", "        ", "\"\"\"Make this CfgNode and all of its children mutable.\n\n        Returns:\n            CfgNode: self\n        \"\"\"", "\n", "super", "(", ")", ".", "defrost", "(", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg": [[186, 197], ["cfg.clone"], "function", ["None"], ["def", "get_cfg", "(", ")", "->", "CfgNode", ":", "\n", "    ", "\"\"\"\n    Get a copy of the default config.\n\n    Returns:\n        a meddlr CfgNode instance.\n    \"\"\"", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "cfg", "=", "_C", "if", "_base_cfg", "is", "None", "else", "_base_cfg", "\n", "return", "cfg", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.set_cfg": [[199, 209], ["None"], "function", ["None"], ["", "def", "set_cfg", "(", "cfg", ":", "CfgNode", ")", "->", "None", ":", "\n", "    ", "\"\"\"Set the base config object to use.\n\n    This is useful when customizing meddlr for different projects.\n\n    Args:\n        cfg (CfgNode): Set the base config.\n    \"\"\"", "\n", "global", "_base_cfg", "\n", "_base_cfg", "=", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.set_global_cfg": [[211, 231], ["global_cfg.clear", "global_cfg.update"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "def", "set_global_cfg", "(", "cfg", ":", "CfgNode", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Let the global config point to the given cfg.\n\n    Assume that the given \"cfg\" has the key \"KEY\", after calling\n    `set_global_cfg(cfg)`, the key can be accessed by:\n\n    .. code-block:: python\n\n        from meddlr.config import global_cfg\n        print(global_cfg.KEY)\n\n    By using a hacky global config, you can access these configs anywhere,\n    without having to pass the config object or the values deep into the code.\n    This is a hacky feature introduced for quick prototyping / research\n    exploration.\n    \"\"\"", "\n", "global", "global_cfg", "\n", "global_cfg", ".", "clear", "(", ")", "\n", "global_cfg", ".", "update", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.configurable": [[233, 315], ["functools.wraps", "inspect.isfunction", "inspect.isfunction", "config._called_with_cfg", "functools.wraps", "inspect.ismethod", "TypeError", "config._get_args_from_config", "init_func", "init_func", "config._called_with_cfg", "type", "AttributeError", "config._get_args_from_config", "orig_func", "orig_func"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config._called_with_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config._get_args_from_config", "home.repos.pwc.inspect_result.ad12_meddlr.config.config._called_with_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config._get_args_from_config"], ["", "def", "configurable", "(", "init_func", "=", "None", ",", "*", ",", "from_config", "=", "None", ")", ":", "# pragma: no cover", "\n", "    ", "\"\"\"\n    Decorate a function or a class's __init__ method so that it can be called\n    with a :class:`CfgNode` object using a :func:`from_config` function that translates\n    :class:`CfgNode` to arguments.\n\n    Adapted from https://github.com/facebookresearch/detectron2\n\n    Examples:\n    ::\n        # Usage 1: Decorator on __init__:\n        class A:\n            @configurable\n            def __init__(self, a, b=2, c=3):\n                pass\n            @classmethod\n            def from_config(cls, cfg):   # 'cfg' must be the first argument\n                # Returns kwargs to be passed to __init__\n                return {\"a\": cfg.A, \"b\": cfg.B}\n        a1 = A(a=1, b=2)  # regular construction\n        a2 = A(cfg)       # construct with a cfg\n        a3 = A(cfg, b=3, c=4)  # construct with extra overwrite\n        # Usage 2: Decorator on any function. Needs an extra from_config argument:\n        @configurable(from_config=lambda cfg: {\"a: cfg.A, \"b\": cfg.B})\n        def a_func(a, b=2, c=3):\n            pass\n        a1 = a_func(a=1, b=2)  # regular call\n        a2 = a_func(cfg)       # call with a cfg\n        a3 = a_func(cfg, b=3, c=4)  # call with extra overwrite\n    Args:\n        init_func (callable): a class's ``__init__`` method in usage 1. The\n            class must have a ``from_config`` classmethod which takes `cfg` as\n            the first argument.\n        from_config (callable): the from_config function in usage 2. It must take `cfg`\n            as its first argument.\n    \"\"\"", "\n", "\n", "if", "init_func", "is", "not", "None", ":", "\n", "        ", "assert", "(", "\n", "inspect", ".", "isfunction", "(", "init_func", ")", "\n", "and", "from_config", "is", "None", "\n", "and", "init_func", ".", "__name__", "==", "\"__init__\"", "\n", ")", ",", "\"Incorrect use of @configurable. Check API documentation for examples.\"", "\n", "\n", "@", "functools", ".", "wraps", "(", "init_func", ")", "\n", "def", "wrapped", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "from_config_func", "=", "type", "(", "self", ")", ".", "from_config", "\n", "", "except", "AttributeError", "as", "e", ":", "\n", "                ", "raise", "AttributeError", "(", "\n", "\"Class with @configurable must have a 'from_config' classmethod.\"", "\n", ")", "from", "e", "\n", "", "if", "not", "inspect", ".", "ismethod", "(", "from_config_func", ")", ":", "\n", "                ", "raise", "TypeError", "(", "\"Class with @configurable must have a 'from_config' classmethod.\"", ")", "\n", "\n", "", "if", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "                ", "explicit_args", "=", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "init_func", "(", "self", ",", "**", "explicit_args", ")", "\n", "", "else", ":", "\n", "                ", "init_func", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapped", "\n", "\n", "", "else", ":", "\n", "        ", "if", "from_config", "is", "None", ":", "\n", "            ", "return", "configurable", "# @configurable() is made equivalent to @configurable", "\n", "", "assert", "inspect", ".", "isfunction", "(", "\n", "from_config", "\n", ")", ",", "\"from_config argument of configurable must be a function!\"", "\n", "\n", "def", "wrapper", "(", "orig_func", ")", ":", "\n", "            ", "@", "functools", ".", "wraps", "(", "orig_func", ")", "\n", "def", "wrapped", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "                ", "if", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "                    ", "explicit_args", "=", "_get_args_from_config", "(", "from_config", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "return", "orig_func", "(", "**", "explicit_args", ")", "\n", "", "else", ":", "\n", "                    ", "return", "orig_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapped", "\n", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config._get_args_from_config": [[317, 347], ["inspect.signature", "any", "inspect.isfunction", "TypeError", "from_config_func", "set", "list", "from_config_func", "from_config_func.update", "list", "inspect.signature.parameters.keys", "kwargs.keys", "inspect.signature.parameters.keys", "inspect.signature.parameters.values", "kwargs.pop"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "", "def", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Use `from_config` to obtain explicit arguments.\n    Returns:\n        dict: arguments to be used for cls.__init__\n    \"\"\"", "\n", "signature", "=", "inspect", ".", "signature", "(", "from_config_func", ")", "\n", "if", "list", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "[", "0", "]", "!=", "\"cfg\"", ":", "\n", "        ", "if", "inspect", ".", "isfunction", "(", "from_config_func", ")", ":", "\n", "            ", "name", "=", "from_config_func", ".", "__name__", "\n", "", "else", ":", "\n", "            ", "name", "=", "f\"{from_config_func.__self__}.from_config\"", "\n", "", "raise", "TypeError", "(", "f\"{name} must take 'cfg' as the first argument!\"", ")", "\n", "", "support_var_arg", "=", "any", "(", "\n", "param", ".", "kind", "in", "[", "param", ".", "VAR_POSITIONAL", ",", "param", ".", "VAR_KEYWORD", "]", "\n", "for", "param", "in", "signature", ".", "parameters", ".", "values", "(", ")", "\n", ")", "\n", "if", "support_var_arg", ":", "# forward all arguments to from_config, if from_config accepts them", "\n", "        ", "ret", "=", "from_config_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# forward supported arguments to from_config", "\n", "        ", "supported_arg_names", "=", "set", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "\n", "extra_kwargs", "=", "{", "}", "\n", "for", "name", "in", "list", "(", "kwargs", ".", "keys", "(", ")", ")", ":", "\n", "            ", "if", "name", "not", "in", "supported_arg_names", ":", "\n", "                ", "extra_kwargs", "[", "name", "]", "=", "kwargs", ".", "pop", "(", "name", ")", "\n", "", "", "ret", "=", "from_config_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# forward the other arguments to __init__", "\n", "ret", ".", "update", "(", "extra_kwargs", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config._called_with_cfg": [[349, 364], ["isinstance", "len", "isinstance", "kwargs.pop"], "function", ["None"], ["", "def", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        bool: whether the arguments contain CfgNode and should be considered\n            forwarded to from_config.\n    \"\"\"", "\n", "from", "omegaconf", "import", "DictConfig", "\n", "\n", "if", "len", "(", "args", ")", "and", "isinstance", "(", "args", "[", "0", "]", ",", "(", "_CfgNode", ",", "DictConfig", ")", ")", ":", "\n", "        ", "return", "True", "\n", "", "if", "isinstance", "(", "kwargs", ".", "pop", "(", "\"cfg\"", ",", "None", ")", ",", "(", "_CfgNode", ",", "DictConfig", ")", ")", ":", "\n", "        ", "return", "True", "\n", "# `from_config`'s first argument is forced to be \"cfg\".", "\n", "# So the above check covers all cases.", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config._find_format_str_keys": [[366, 377], ["set", "cfg.items", "isinstance", "config._find_format_str_keys", "isinstance", "v.startswith", "v.endswith", "v.startswith", "v.endswith"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.config.config._find_format_str_keys"], ["", "def", "_find_format_str_keys", "(", "cfg", ":", "Mapping", ",", "prefix", "=", "\"\"", ",", "accum", "=", "(", ")", ")", ":", "\n", "    ", "accum", "=", "set", "(", "accum", ")", "\n", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", ":", "\n", "        ", "k_prefix", "=", "prefix", "+", "\".\"", "+", "k", "if", "prefix", "else", "k", "\n", "if", "isinstance", "(", "v", ",", "Mapping", ")", ":", "\n", "            ", "accum", "|=", "_find_format_str_keys", "(", "cfg", "[", "k", "]", ",", "prefix", "=", "k_prefix", ",", "accum", "=", "accum", ")", "\n", "", "elif", "isinstance", "(", "v", ",", "str", ")", "and", "(", "\n", "(", "v", ".", "startswith", "(", "'f\"'", ")", "and", "v", ".", "endswith", "(", "'\"'", ")", ")", "or", "(", "v", ".", "startswith", "(", "\"f'\"", ")", "and", "v", ".", "endswith", "(", "\"'\"", ")", ")", "\n", ")", ":", "\n", "            ", "accum", "|=", "{", "(", "k_prefix", ",", "v", ")", "}", "\n", "", "", "return", "accum", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config._unroll_value_to_str": [[379, 386], ["isinstance", "isinstance", "str", "config._unroll_value_to_str", "value.items", "config._unroll_value_to_str"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config._unroll_value_to_str", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.config.config._unroll_value_to_str"], ["", "def", "_unroll_value_to_str", "(", "value", ")", "->", "str", ":", "\n", "    ", "if", "isinstance", "(", "value", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "        ", "return", "\"-\"", ".", "join", "(", "_unroll_value_to_str", "(", "v", ")", "for", "v", "in", "value", ")", "\n", "", "elif", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "        ", "return", "\"-\"", ".", "join", "(", "f\"{k}={_unroll_value_to_str(v)}\"", "for", "k", ",", "v", "in", "value", ".", "items", "(", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "str", "(", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.config.format_config_fields": [[388, 410], ["config._find_format_str_keys", "cfg.defrost().merge_from_list", "range", "eval", "values_list.extend", "cfg.clone", "x.start", "x.start", "len", "len", "cfg.get_recursive", "eval.format", "cfg.defrost", "re.finditer", "re.finditer", "zip", "config._unroll_value_to_str", "len", "len", "zip"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config._find_format_str_keys", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_list", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval", "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.start", "home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.AdvancedTimer.start", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.get_recursive", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config._unroll_value_to_str"], ["", "", "def", "format_config_fields", "(", "cfg", ":", "CfgNode", ",", "unroll", "=", "False", ",", "inplace", "=", "False", ")", ":", "\n", "    ", "keys_and_val_str", "=", "_find_format_str_keys", "(", "cfg", ")", "\n", "values_list", "=", "[", "]", "\n", "for", "k", ",", "val_str", "in", "keys_and_val_str", ":", "\n", "        ", "start", "=", "[", "x", ".", "start", "(", ")", "for", "x", "in", "re", ".", "finditer", "(", "\"\\{\"", ",", "val_str", ")", "]", "\n", "end", "=", "[", "x", ".", "start", "(", ")", "for", "x", "in", "re", ".", "finditer", "(", "\"\\}\"", ",", "val_str", ")", "]", "\n", "assert", "len", "(", "start", ")", "==", "len", "(", "end", ")", ",", "f\"Could not determine formatting string: {val_str}\"", "\n", "cfg_keys_to_search", "=", "[", "val_str", "[", "s", "+", "1", ":", "e", "]", "for", "s", ",", "e", "in", "zip", "(", "start", ",", "end", ")", "]", "\n", "values", "=", "[", "cfg", ".", "get_recursive", "(", "v", ")", "for", "v", "in", "cfg_keys_to_search", "]", "\n", "if", "unroll", ":", "\n", "            ", "values", "=", "[", "_unroll_value_to_str", "(", "v", ")", "for", "v", "in", "values", "]", "\n", "\n", "", "fmt_str", "=", "\"\"", "\n", "idxs", "=", "[", "0", "]", "+", "[", "y", "for", "x", "in", "zip", "(", "start", ",", "end", ")", "for", "y", "in", "x", "]", "+", "[", "len", "(", "val_str", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "idxs", ")", "//", "2", ")", ":", "\n", "            ", "fmt_str", "+=", "val_str", "[", "idxs", "[", "2", "*", "i", "]", ":", "idxs", "[", "2", "*", "i", "+", "1", "]", "+", "1", "]", "\n", "", "fmt_str", "=", "eval", "(", "fmt_str", ".", "format", "(", "*", "values", ")", ")", "\n", "values_list", ".", "extend", "(", "[", "k", ",", "fmt_str", "]", ")", "\n", "", "if", "not", "inplace", ":", "\n", "        ", "cfg", ".", "clone", "(", ")", "\n", "", "cfg", ".", "defrost", "(", ")", ".", "merge_from_list", "(", "values_list", ")", "\n", "return", "cfg", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.config.util.configure_params": [[11, 40], ["itertools.product", "list", "c.update", "base_cfg.clone().defrost().merge_from_list().freeze", "d.items", "params.values", "zip", "params.keys", "base_cfg.clone().defrost().merge_from_list", "util.configure_params._dict_to_list"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_list"], ["def", "configure_params", "(", "\n", "params", ":", "Dict", "[", "str", ",", "Sequence", "]", ",", "fixed", ":", "Dict", "[", "str", ",", "Any", "]", "=", "None", ",", "base_cfg", ":", "CfgNode", "=", "None", "\n", ")", "->", "List", "[", "Dict", "]", ":", "\n", "    ", "\"\"\"Unroll parameters into a list of configurations.\n\n    Args:\n        params (Dict[Sequence]): Config keys and potential values they can take on.\n            These parameters will be mixed and matched to create configs.\n            Order is ``{\"param1\": [valA, valB, ...], \"param2\": [val1, val2, ...]}``\n        fixed (Dict[str, Any]): Fixed parameters to apply to every configuration.\n\n    Returns:\n        List[Dict] | List[CfgNode]: Different configurations. If ``base_cfg`` provided,\n            the different configurations are merged into the config.\n    \"\"\"", "\n", "\n", "def", "_dict_to_list", "(", "d", ")", ":", "\n", "        ", "return", "[", "x", "for", "key_value", "in", "d", ".", "items", "(", ")", "for", "x", "in", "key_value", "]", "\n", "\n", "", "configs", "=", "itertools", ".", "product", "(", "*", "list", "(", "params", ".", "values", "(", ")", ")", ")", "\n", "configs", "=", "[", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "params", ".", "keys", "(", ")", ",", "cfg", ")", "}", "for", "cfg", "in", "configs", "]", "\n", "if", "fixed", "is", "not", "None", ":", "\n", "        ", "for", "c", "in", "configs", ":", "\n", "            ", "c", ".", "update", "(", "fixed", ")", "\n", "", "", "if", "base_cfg", ":", "\n", "        ", "configs", "=", "[", "\n", "base_cfg", ".", "clone", "(", ")", ".", "defrost", "(", ")", ".", "merge_from_list", "(", "_dict_to_list", "(", "c", ")", ")", ".", "freeze", "(", ")", "for", "c", "in", "configs", "\n", "]", "\n", "", "return", "configs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.util.stringify": [[42, 54], ["util._stringify_value", "isinstance", "cfg.items", "cfg.items", "cfg.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.util._stringify_value", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "stringify", "(", "cfg", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "    ", "\"\"\"Convert param/value pairs into a command-line compatible string.\n\n    Args:\n        cfg (Dict[str, Any]): The configuration to stringify.\n\n    Return:\n        str: A command line compatible string.\n    \"\"\"", "\n", "cfg", "=", "{", "k", ":", "f\"'{v}'\"", "if", "isinstance", "(", "v", ",", "str", ")", "else", "v", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", "}", "\n", "cfg", "=", "{", "k", ":", "_stringify_value", "(", "v", ")", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", "}", "\n", "return", "\" \"", ".", "join", "(", "f'{k} \"{v}\"'", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.util.check_dependencies": [[56, 92], ["isinstance", "line.strip", "dep.strip", "open", "f.readlines", "[].strip().split", "meddlr.utils.env.is_package_installed", "missing_deps.append", "len", "[].strip", "line.split"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_package_installed"], ["", "def", "check_dependencies", "(", "\n", "cfg_file_or_lines", ",", "return_failed_deps", ":", "bool", "=", "False", "\n", ")", "->", "Union", "[", "bool", ",", "List", "[", "str", "]", "]", ":", "\n", "    ", "\"\"\"Check that module dependencies are met for the config file.\n\n    Dependencies are specified as comments in the config file starting\n    with ``\"# DEPENDENCY:\"``.\n\n    Args:\n        cfg_file (str): The path to the config file.\n        return_failed_deps (bool, optional): Whether to return the list of\n            dependencies that are not met. Defaults to ``False``.\n\n    Returns:\n        bool | List[str]: If ``return_failed_deps=True``, returns the list of\n        dependencies that are not met. Else returns boolean of whether all\n        dependencies are met.\n    \"\"\"", "\n", "keyword", "=", "\"# DEPENDENCY:\"", "\n", "\n", "if", "isinstance", "(", "cfg_file_or_lines", ",", "(", "str", ",", "os", ".", "PathLike", ",", "pathlib", ".", "Path", ")", ")", ":", "\n", "        ", "with", "open", "(", "cfg_file_or_lines", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "lines", "=", "cfg_file_or_lines", "\n", "", "lines", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "lines", "if", "keyword", "in", "line", "]", "\n", "dependencies", "=", "[", "\n", "dep", ".", "strip", "(", ")", "for", "line", "in", "lines", "for", "dep", "in", "line", ".", "split", "(", "keyword", ")", "[", "-", "1", "]", ".", "strip", "(", ")", ".", "split", "(", "\";\"", ")", "\n", "]", "\n", "\n", "missing_deps", "=", "[", "]", "\n", "for", "dep", "in", "dependencies", ":", "\n", "        ", "if", "not", "env", ".", "is_package_installed", "(", "dep", ")", ":", "\n", "            ", "missing_deps", ".", "append", "(", "dep", ")", "\n", "\n", "", "", "return", "missing_deps", "if", "return_failed_deps", "else", "len", "(", "missing_deps", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.util._stringify_value": [[94, 136], ["isinstance", "isinstance", "list", "util._to_str", "util._to_str", "isinstance", "value.keys", "util._stringify_value", "util._stringify_value", "util._stringify_value", "zip", "str", "zip", "len", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.config.util._to_str", "home.repos.pwc.inspect_result.ad12_meddlr.config.util._to_str", "home.repos.pwc.inspect_result.ad12_meddlr.config.util._stringify_value", "home.repos.pwc.inspect_result.ad12_meddlr.config.util._stringify_value", "home.repos.pwc.inspect_result.ad12_meddlr.config.util._stringify_value"], ["", "def", "_stringify_value", "(", "value", ",", "depth", "=", "0", ")", "->", "str", ":", "\n", "    ", "\"\"\"Convert value into command-line comaptible string.\n\n    The string representations of certain types (e.g. list, tuple)\n    are not command-line compatible. We have to add extra ``\"\"``\n    around the string for proper formatting. This function\n    formats values of primitive types (numbers, strs, collections, dicts).\n\n    Args:\n        value (Number | str | Collection | Dict): The value to convert\n            to a command-line compatible string.\n\n    Returns:\n        str: The stringified value.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "value", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", ":", "\n", "        ", "return", "value", "\n", "", "if", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "        ", "keys", "=", "list", "(", "value", ".", "keys", "(", ")", ")", "\n", "values", "=", "[", "value", "[", "k", "]", "for", "k", "in", "keys", "]", "\n", "keys_str", "=", "[", "_stringify_value", "(", "k", ",", "depth", "=", "depth", "+", "1", ")", "for", "k", "in", "keys", "]", "\n", "values_str", "=", "[", "_stringify_value", "(", "v", ",", "depth", "=", "depth", "+", "1", ")", "for", "v", "in", "values", "]", "\n", "keys_str", "=", "_to_str", "(", "keys_str", ",", "keys", ")", "\n", "values_str", "=", "_to_str", "(", "values_str", ",", "values", ")", "\n", "val_dict_str", "=", "{", "f\"{k}:{v}\"", "for", "k", ",", "v", "in", "zip", "(", "keys_str", ",", "values_str", ")", "}", "\n", "value_str", "=", "\"\\{\"", "\n", "value_str", "+=", "\",\"", ".", "join", "(", "val_dict_str", ")", "\n", "value_str", "+=", "\"\\}\"", "\n", "", "else", ":", "\n", "        ", "all_vals", "=", "[", "_stringify_value", "(", "v", ",", "depth", "=", "depth", "+", "1", ")", "for", "v", "in", "value", "]", "\n", "value_str", "=", "\",\"", ".", "join", "(", "\n", "str", "(", "v", ")", "\n", "if", "not", "isinstance", "(", "v", ",", "str", ")", "or", "isinstance", "(", "ov", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", "\n", "else", "f\"'\\\"'\\\"'{v}'\\\"'\\\"'\"", "\n", "for", "v", ",", "ov", "in", "zip", "(", "all_vals", ",", "value", ")", "\n", ")", "\n", "if", "isinstance", "(", "value", ",", "tuple", ")", ":", "\n", "            ", "value_str", "=", "f\"\\({value_str},\\)\"", "if", "len", "(", "value", ")", ">", "0", "else", "\"\\(\\)\"", "\n", "", "else", ":", "\n", "            ", "value_str", "=", "f\"[{value_str}]\"", "\n", "\n", "", "", "return", "value_str", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.util._to_str": [[138, 144], ["str", "zip", "isinstance", "isinstance"], "function", ["None"], ["", "def", "_to_str", "(", "all_vals", ",", "value", ")", ":", "\n", "    ", "return", "[", "\n", "str", "(", "v", ")", "\n", "if", "not", "isinstance", "(", "v", ",", "str", ")", "or", "isinstance", "(", "ov", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", "\n", "else", "f\"'\\\"'\\\"'{v}'\\\"'\\\"'\"", "\n", "for", "v", ",", "ov", "in", "zip", "(", "all_vals", ",", "value", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.compat._RenameConverter.upgrade": [[156, 160], ["compat._rename"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.compat._rename"], ["@", "classmethod", "\n", "def", "upgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "for", "old", ",", "new", "in", "cls", ".", "RENAME", ":", "\n", "            ", "_rename", "(", "cfg", ",", "old", ",", "new", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.compat._RenameConverter.downgrade": [[161, 165], ["compat._rename"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.compat._rename"], ["", "", "@", "classmethod", "\n", "def", "downgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "for", "old", ",", "new", "in", "cls", ".", "RENAME", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "_rename", "(", "cfg", ",", "new", ",", "old", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.config.compat.upgrade_config": [[36, 56], ["cfg.clone.clone", "range", "converter.upgrade", "globals", "str"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.compat._RenameConverter.upgrade"], ["def", "upgrade_config", "(", "cfg", ":", "CN", ",", "to_version", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "CN", ":", "\n", "    ", "\"\"\"\n    Upgrade a config from its current version to a newer version.\n\n    Args:\n        cfg (CfgNode):\n        to_version (int): defaults to the latest version.\n    \"\"\"", "\n", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "if", "to_version", "is", "None", ":", "\n", "        ", "to_version", "=", "_C", ".", "VERSION", "\n", "\n", "", "assert", "cfg", ".", "VERSION", "<=", "to_version", ",", "\"Cannot upgrade from v{} to v{}!\"", ".", "format", "(", "\n", "cfg", ".", "VERSION", ",", "to_version", "\n", ")", "\n", "for", "k", "in", "range", "(", "cfg", ".", "VERSION", ",", "to_version", ")", ":", "\n", "        ", "converter", "=", "globals", "(", ")", "[", "\"ConverterV\"", "+", "str", "(", "k", "+", "1", ")", "]", "\n", "converter", ".", "upgrade", "(", "cfg", ")", "\n", "cfg", ".", "VERSION", "=", "k", "+", "1", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.compat.downgrade_config": [[58, 83], ["cfg.clone.clone", "range", "converter.downgrade", "globals", "str"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.compat._RenameConverter.downgrade"], ["", "def", "downgrade_config", "(", "cfg", ":", "CN", ",", "to_version", ":", "int", ")", "->", "CN", ":", "\n", "    ", "\"\"\"\n    Downgrade a config from its current version to an older version.\n\n    Args:\n        cfg (CfgNode):\n        to_version (int):\n\n    Note:\n        A general downgrade of arbitrary configs is not always possible due to\n        the different functionalities in different versions.\n        The purpose of downgrade is only to recover the defaults in old\n        versions, allowing it to load an old partial yaml config.\n        Therefore, the implementation only needs to fill in the default values\n        in the old version when a general downgrade is not possible.\n    \"\"\"", "\n", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "assert", "cfg", ".", "VERSION", ">=", "to_version", ",", "\"Cannot downgrade from v{} to v{}!\"", ".", "format", "(", "\n", "cfg", ".", "VERSION", ",", "to_version", "\n", ")", "\n", "for", "k", "in", "range", "(", "cfg", ".", "VERSION", ",", "to_version", ",", "-", "1", ")", ":", "\n", "        ", "converter", "=", "globals", "(", ")", "[", "\"ConverterV\"", "+", "str", "(", "k", ")", "]", "\n", "converter", ".", "downgrade", "(", "cfg", ")", "\n", "cfg", ".", "VERSION", "=", "k", "-", "1", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.compat.guess_version": [[85, 117], ["logging.getLogger", "name.split", "compat.guess_version._has"], "function", ["None"], ["", "def", "guess_version", "(", "cfg", ":", "CN", ",", "filename", ":", "str", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Guess the version of a partial config where the VERSION field is not\n    specified.\n    Returns the version, or the latest if cannot make a guess.\n\n    This makes it easier for users to migrate.\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "def", "_has", "(", "name", ":", "str", ")", "->", "bool", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "n", "in", "name", ".", "split", "(", "\".\"", ")", ":", "\n", "            ", "if", "n", "not", "in", "cur", ":", "\n", "                ", "return", "False", "\n", "", "cur", "=", "cur", "[", "n", "]", "\n", "", "return", "True", "\n", "\n", "# Most users' partial configs have \"MODEL.WEIGHT\", so guess on it", "\n", "", "ret", "=", "None", "\n", "if", "_has", "(", "\"MODEL.WEIGHT\"", ")", "or", "_has", "(", "\"TEST.AUG_ON\"", ")", ":", "\n", "        ", "ret", "=", "1", "\n", "\n", "", "if", "ret", "is", "not", "None", ":", "\n", "        ", "logger", ".", "warning", "(", "\"Config '{}' has no VERSION. Assuming it to be v{}.\"", ".", "format", "(", "filename", ",", "ret", ")", ")", "\n", "", "else", ":", "\n", "        ", "ret", "=", "_C", ".", "VERSION", "\n", "logger", ".", "warning", "(", "\n", "\"Config '{}' has no VERSION. \"", "\n", "\"Assuming it to be compatible with latest v{}.\"", ".", "format", "(", "filename", ",", "ret", ")", "\n", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.compat._rename": [[119, 147], ["old.split", "new.split", "compat._rename._set"], "function", ["None"], ["", "def", "_rename", "(", "cfg", ":", "CN", ",", "old", ":", "str", ",", "new", ":", "str", ")", "->", "None", ":", "\n", "    ", "old_keys", "=", "old", ".", "split", "(", "\".\"", ")", "\n", "new_keys", "=", "new", ".", "split", "(", "\".\"", ")", "\n", "\n", "def", "_set", "(", "key_seq", ":", "List", "[", "str", "]", ",", "val", ":", "str", ")", "->", "None", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", "[", ":", "-", "1", "]", ":", "\n", "            ", "if", "k", "not", "in", "cur", ":", "\n", "                ", "cur", "[", "k", "]", "=", "CN", "(", ")", "\n", "", "cur", "=", "cur", "[", "k", "]", "\n", "", "cur", "[", "key_seq", "[", "-", "1", "]", "]", "=", "val", "\n", "\n", "", "def", "_get", "(", "key_seq", ":", "List", "[", "str", "]", ")", "->", "CN", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", ":", "\n", "            ", "cur", "=", "cur", "[", "k", "]", "\n", "", "return", "cur", "\n", "\n", "", "def", "_del", "(", "key_seq", ":", "List", "[", "str", "]", ")", "->", "None", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", "[", ":", "-", "1", "]", ":", "\n", "            ", "cur", "=", "cur", "[", "k", "]", "\n", "", "del", "cur", "[", "key_seq", "[", "-", "1", "]", "]", "\n", "if", "len", "(", "cur", ")", "==", "0", "and", "len", "(", "key_seq", ")", ">", "1", ":", "\n", "            ", "_del", "(", "key_seq", "[", ":", "-", "1", "]", ")", "\n", "\n", "", "", "_set", "(", "new_keys", ",", "_get", "(", "old_keys", ")", ")", "\n", "_del", "(", "old_keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.test_util.test_check_dependencies": [[9, 12], ["util.get_cfg_path", "meddlr.config.util.check_dependencies"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.get_cfg_path", "home.repos.pwc.inspect_result.ad12_meddlr.config.util.check_dependencies"], ["def", "test_check_dependencies", "(", ")", ":", "\n", "    ", "cfg_file", "=", "util", ".", "get_cfg_path", "(", "\"tests/basic-with-deps.yaml\"", ")", "\n", "assert", "check_dependencies", "(", "cfg_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.test_util.test_configure_params": [[14, 34], ["meddlr.config.config.get_cfg", "meddlr.config.util.configure_params", "zip", "meddlr.config.util.configure_params", "zip", "meddlr.config.util.configure_params", "zip", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.util.configure_params", "home.repos.pwc.inspect_result.ad12_meddlr.config.util.configure_params", "home.repos.pwc.inspect_result.ad12_meddlr.config.util.configure_params"], ["", "def", "test_configure_params", "(", ")", ":", "\n", "    ", "params", "=", "{", "\"DESCRIPTION.BRIEF\"", ":", "[", "\"foo\"", ",", "\"bar\"", ",", "\"foobar\"", "]", "}", "\n", "fixed", "=", "{", "\"DESCRIPTION.PROJECT_NAME\"", ":", "\"test\"", "}", "\n", "base_cfg", "=", "get_cfg", "(", ")", "\n", "\n", "cfgs", "=", "configure_params", "(", "params", ")", "\n", "assert", "len", "(", "cfgs", ")", "==", "3", "\n", "for", "cfg", ",", "val", "in", "zip", "(", "cfgs", ",", "params", "[", "\"DESCRIPTION.BRIEF\"", "]", ")", ":", "\n", "        ", "assert", "cfg", "[", "\"DESCRIPTION.BRIEF\"", "]", "==", "val", "\n", "\n", "", "cfgs", "=", "configure_params", "(", "params", ",", "base_cfg", "=", "base_cfg", ")", "\n", "assert", "len", "(", "cfgs", ")", "==", "3", "\n", "for", "cfg", ",", "val", "in", "zip", "(", "cfgs", ",", "params", "[", "\"DESCRIPTION.BRIEF\"", "]", ")", ":", "\n", "        ", "assert", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "==", "val", "\n", "\n", "", "cfgs", "=", "configure_params", "(", "params", ",", "fixed", "=", "fixed", ",", "base_cfg", "=", "base_cfg", ")", "\n", "assert", "len", "(", "cfgs", ")", "==", "3", "\n", "for", "cfg", ",", "val", "in", "zip", "(", "cfgs", ",", "params", "[", "\"DESCRIPTION.BRIEF\"", "]", ")", ":", "\n", "        ", "assert", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "==", "val", "\n", "assert", "cfg", ".", "DESCRIPTION", ".", "PROJECT_NAME", "==", "\"test\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.test_util.test_stringify": [[36, 55], ["pytest.mark.parametrize", "meddlr.config.util.stringify"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.util.stringify"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"cfg,expected_str\"", ",", "\n", "[", "\n", "(", "\n", "{", "\"ALPHA\"", ":", "\"foo\"", ",", "\"BETA\"", ":", "(", "\"bar\"", ",", "\"tie\"", ")", "}", ",", "\n", "\"ALPHA \\\"'foo'\\\" BETA \\\"\\('\\\"'\\\"'bar'\\\"'\\\"','\\\"'\\\"'tie'\\\"'\\\"',\\)\\\"\"", ",", "\n", ")", ",", "\n", "(", "\n", "{", "\"ALPHA\"", ":", "\"foo\"", ",", "\"BETA\"", ":", "[", "\"bar\"", ",", "\"tie\"", "]", "}", ",", "\n", "\"ALPHA \\\"'foo'\\\" BETA \\\"['\\\"'\\\"'bar'\\\"'\\\"','\\\"'\\\"'tie'\\\"'\\\"']\\\"\"", ",", "\n", ")", ",", "\n", "(", "\n", "{", "\"ALPHA\"", ":", "\"foo\"", ",", "\"BETA\"", ":", "{", "\"bar\"", ":", "\"tie\"", "}", "}", ",", "\n", "\"ALPHA \\\"'foo'\\\" BETA \\\"\\{'\\\"'\\\"'bar'\\\"'\\\"':'\\\"'\\\"'tie'\\\"'\\\"'\\}\\\"\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_stringify", "(", "cfg", ",", "expected_str", ")", ":", "\n", "    ", "assert", "stringify", "(", "cfg", ")", "==", "expected_str", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.config.test_config.TestConfig.test_format_fields": [[9, 36], ["meddlr.config.config.get_cfg", "meddlr.config.config.get_cfg.format_fields", "meddlr.config.config.get_cfg", "meddlr.config.config.get_cfg.format_fields", "meddlr.config.config.get_cfg", "meddlr.config.config.get_cfg.format_fields", "meddlr.config.config.get_cfg", "meddlr.config.config.get_cfg.format_fields", "str"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.format_fields", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.format_fields", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.format_fields", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.format_fields"], ["    ", "def", "test_format_fields", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "=", "'f\"seed={SEED},project={DESCRIPTION.PROJECT_NAME}\"'", "\n", "cfg", ".", "format_fields", "(", ")", "\n", "assert", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "==", "f\"seed={cfg.SEED},project={cfg.DESCRIPTION.PROJECT_NAME}\"", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "=", "'f\"{SEED},project={DESCRIPTION.PROJECT_NAME}\"'", "\n", "cfg", ".", "format_fields", "(", ")", "\n", "assert", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "==", "f\"{cfg.SEED},project={cfg.DESCRIPTION.PROJECT_NAME}\"", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "=", "'f\"{SEED},project={DESCRIPTION.PROJECT_NAME}-today\"'", "\n", "cfg", ".", "format_fields", "(", ")", "\n", "assert", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "==", "f\"{cfg.SEED},project={cfg.DESCRIPTION.PROJECT_NAME}-today\"", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", ".", "ACCELERATIONS", "=", "(", "6", ",", "8", ")", "\n", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "=", "(", "\n", "'f\"{AUG_TRAIN.UNDERSAMPLE.ACCELERATIONS},project={DESCRIPTION.PROJECT_NAME}-today\"'", "\n", ")", "\n", "cfg", ".", "format_fields", "(", "unroll", "=", "True", ")", "\n", "expected", "=", "\"{},project={}-today\"", ".", "format", "(", "\n", "\"-\"", ".", "join", "(", "str", "(", "x", ")", "for", "x", "in", "cfg", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", ".", "ACCELERATIONS", ")", ",", "\n", "cfg", ".", "DESCRIPTION", ".", "PROJECT_NAME", ",", "\n", ")", "\n", "assert", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.config.test_config.TestConfig.test_get_recursive": [[37, 45], ["meddlr.config.config.get_cfg", "meddlr.config.config.get_cfg.get_recursive", "meddlr.config.config.get_cfg.get_recursive", "pytest.raises", "meddlr.config.config.get_cfg.get_recursive"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.get_recursive", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.get_recursive", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.get_recursive"], ["", "def", "test_get_recursive", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "=", "\"foobar\"", "\n", "\n", "assert", "cfg", ".", "get_recursive", "(", "\"DESCRIPTION.BRIEF\"", ")", "==", "\"foobar\"", "\n", "assert", "cfg", ".", "get_recursive", "(", "\"DESCRIPTION.FOO\"", ",", "None", ")", "is", "None", "\n", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "            ", "cfg", ".", "get_recursive", "(", "\"DESCRIPTION.FOO\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint.Checkpointer.__init__": [[19, 21], ["fvcore.common.checkpoint.Checkpointer.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "save_dir", "=", "\"\"", ",", "*", ",", "save_to_disk", "=", "None", ",", "**", "checkpointables", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "model", ",", "save_dir", ",", "save_to_disk", "=", "True", ",", "**", "checkpointables", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint.Checkpointer._load_file": [[22, 27], ["super()._load_file"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint.Checkpointer._load_file"], ["", "def", "_load_file", "(", "self", ",", "filename", ")", ":", "\n", "        ", "loaded", "=", "super", "(", ")", ".", "_load_file", "(", "filename", ")", "# load native pth checkpoint", "\n", "if", "\"model\"", "not", "in", "loaded", ":", "\n", "            ", "loaded", "=", "{", "\"model\"", ":", "loaded", "}", "\n", "", "return", "loaded", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint.Checkpointer._load_model": [[28, 42], ["super()._load_model", "logger.warn", "fvcore.common.checkpoint._strip_prefix_if_present", "fvcore.common.checkpoint._strip_prefix_if_present", "super()._load_model", "checkpoint._has_incompatible_keys", "checkpoint._has_incompatible_keys", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint.Checkpointer._load_model", "home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint.Checkpointer._load_model", "home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint._has_incompatible_keys", "home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint._has_incompatible_keys"], ["", "def", "_load_model", "(", "self", ",", "checkpoint", ")", ":", "\n", "        ", "model_state_dict", "=", "checkpoint", "[", "\"model\"", "]", "\n", "incompatible", "=", "super", "(", ")", ".", "_load_model", "(", "checkpoint", ")", "\n", "if", "not", "_has_incompatible_keys", "(", "incompatible", ")", ":", "\n", "            ", "return", "\n", "\n", "# Load models that are wrapped in an nn.Module.", "\n", "# Following convention, these wrapped models begin with the \"model.\" prefix.", "\n", "", "logger", ".", "warn", "(", "\"Attempting to load wrapped model from model state dict.\"", ")", "\n", "_strip_prefix_if_present", "(", "model_state_dict", ",", "\"module.\"", ")", "\n", "_strip_prefix_if_present", "(", "model_state_dict", ",", "\"model.\"", ")", "\n", "incompatible", "=", "super", "(", ")", ".", "_load_model", "(", "{", "\"model\"", ":", "model_state_dict", "}", ")", "\n", "if", "_has_incompatible_keys", "(", "incompatible", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Found incompatible keys or shapes:\\n{}\"", ".", "format", "(", "incompatible", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.checkpoint.checkpoint._has_incompatible_keys": [[44, 49], ["bool", "bool", "bool"], "function", ["None"], ["", "", "", "def", "_has_incompatible_keys", "(", "incompatible", ")", ":", "\n", "    ", "return", "(", "\n", "bool", "(", "incompatible", ".", "missing_keys", ")", "\n", "|", "bool", "(", "incompatible", ".", "unexpected_keys", ")", "\n", "|", "bool", "(", "incompatible", ".", "incorrect_shapes", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.one_hot_to_categorical": [[13, 40], ["isinstance", "torch.as_tensor", "torch.as_tensor", "torch.argmax", "torch.argmax", "torch.where", "torch.where", "out.numpy.numpy", "torch.argmax", "torch.argmax", "torch.tensor", "torch.tensor", "torch.as_tensor.type", "torch.as_tensor.sum"], "function", ["None"], ["def", "one_hot_to_categorical", "(", "x", ",", "channel_dim", ":", "int", "=", "1", ",", "background", "=", "False", ")", ":", "\n", "    ", "\"\"\"Converts one-hot encoded predictions to categorical predictions.\n\n    Args:\n        x (torch.Tensor | np.ndarray): One-hot encoded predictions.\n        channel_dim (int, optional): Channel dimension.\n            Defaults to ``1`` (i.e. ``(B,C,...)``).\n        background (bool, optional): If ``True``, assumes index 0 in the\n            channel dimension is the background.\n\n    Returns:\n        torch.Tensor | np.ndarray: Categorical array or tensor. If ``background=False``,\n        the output will be 1-indexed such that ``0`` corresponds to the background.\n    \"\"\"", "\n", "is_ndarray", "=", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", "\n", "if", "is_ndarray", ":", "\n", "        ", "x", "=", "torch", ".", "as_tensor", "(", "x", ")", "\n", "\n", "", "if", "background", "is", "not", "None", "and", "background", "is", "not", "False", ":", "\n", "        ", "out", "=", "torch", ".", "argmax", "(", "x", ",", "channel_dim", ")", "\n", "", "else", ":", "\n", "        ", "out", "=", "torch", ".", "argmax", "(", "x", ".", "type", "(", "torch", ".", "long", ")", ",", "dim", "=", "channel_dim", ")", "+", "1", "\n", "out", "=", "torch", ".", "where", "(", "x", ".", "sum", "(", "channel_dim", ")", "==", "0", ",", "torch", ".", "tensor", "(", "[", "0", "]", ",", "device", "=", "x", ".", "device", ")", ",", "out", ")", "\n", "\n", "", "if", "is_ndarray", ":", "\n", "        ", "out", "=", "out", ".", "numpy", "(", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.categorical_to_one_hot": [[42, 90], ["isinstance", "torch.zeros", "torch.zeros", "out.numpy.scatter_", "torch.from_numpy", "torch.from_numpy", "torch.max().type().cpu().item", "torch.max().type().cpu().item", "x.type.type", "x.type.reshape", "torch.cat", "torch.cat", "out.numpy.permute", "out.numpy.contiguous", "out.numpy.numpy", "tuple", "tuple", "torch.max().type().cpu", "torch.max().type().cpu", "numpy.argsort", "torch.max().type", "torch.max().type", "range", "torch.max", "torch.max"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "def", "categorical_to_one_hot", "(", "x", ",", "channel_dim", ":", "int", "=", "1", ",", "background", "=", "0", ",", "num_categories", "=", "None", ",", "dtype", "=", "None", ")", ":", "\n", "    ", "\"\"\"Converts categorical predictions to one-hot encoded predictions.\n\n    Args:\n        x (torch.Tensor | np.ndarray): Categorical array or tensor.\n        channel_dim (int, optional): Channel dimension for output tensor.\n        background (int | NoneType, optional): The numerical label of the\n            background category. If ``None``, assumes that the background is\n            a class that should be one-hot encoded.\n        num_categories (int, optional): Number of categories (excluding background).\n            Defaults to the ``max(x) + 1``.\n        dtype (type, optional): Data type of the output.\n            Defaults to boolean (``torch.bool`` or ``np.bool``).\n\n    Returns:\n        torch.Tensor | np.ndarray: One-hot encoded predictions.\n    \"\"\"", "\n", "is_ndarray", "=", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", "\n", "if", "is_ndarray", ":", "\n", "        ", "x", "=", "torch", ".", "from_numpy", "(", "x", ")", "\n", "\n", "", "if", "num_categories", "is", "None", ":", "\n", "        ", "num_categories", "=", "torch", ".", "max", "(", "x", ")", ".", "type", "(", "torch", ".", "long", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "", "num_categories", "+=", "1", "\n", "\n", "shape", "=", "x", ".", "shape", "\n", "out_shape", "=", "(", "num_categories", ",", ")", "+", "shape", "\n", "\n", "if", "dtype", "is", "None", ":", "\n", "        ", "dtype", "=", "torch", ".", "bool", "\n", "", "default_value", "=", "True", "if", "dtype", "==", "torch", ".", "bool", "else", "1", "\n", "if", "x", ".", "dtype", "!=", "torch", ".", "long", ":", "\n", "        ", "x", "=", "x", ".", "type", "(", "torch", ".", "long", ")", "\n", "\n", "", "out", "=", "torch", ".", "zeros", "(", "out_shape", ",", "dtype", "=", "dtype", ",", "device", "=", "x", ".", "device", ")", "\n", "out", ".", "scatter_", "(", "0", ",", "x", ".", "reshape", "(", "(", "1", ",", ")", "+", "x", ".", "shape", ")", ",", "default_value", ")", "\n", "if", "background", "is", "not", "None", ":", "\n", "        ", "out", "=", "torch", ".", "cat", "(", "[", "out", "[", "0", ":", "background", "]", ",", "out", "[", "background", "+", "1", ":", "]", "]", ",", "dim", "=", "0", ")", "\n", "", "if", "channel_dim", "!=", "0", ":", "\n", "        ", "if", "channel_dim", "<", "0", ":", "\n", "            ", "channel_dim", "=", "out", ".", "ndim", "+", "channel_dim", "\n", "", "order", "=", "(", "channel_dim", ",", ")", "+", "tuple", "(", "d", "for", "d", "in", "range", "(", "out", ".", "ndim", ")", "if", "d", "!=", "channel_dim", ")", "\n", "out", "=", "out", ".", "permute", "(", "tuple", "(", "np", ".", "argsort", "(", "order", ")", ")", ")", "\n", "out", "=", "out", ".", "contiguous", "(", ")", "\n", "\n", "", "if", "is_ndarray", ":", "\n", "        ", "out", "=", "out", ".", "numpy", "(", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.logits_to_prob": [[92, 117], ["isinstance", "torch.from_numpy", "torch.from_numpy", "torch.sigmoid", "torch.sigmoid", "F.softmax.numpy", "torch.softmax", "ValueError"], "function", ["None"], ["", "def", "logits_to_prob", "(", "logits", ",", "activation", ",", "channel_dim", ":", "int", "=", "1", ")", ":", "\n", "    ", "\"\"\"Converts logits to probabilities.\n\n    Args:\n        logits (torch.Tensor | np.ndarray): The logits.\n        activation (str): Activation to use. One of ``'sigmoid'``, ``'softmax'``.\n        channel_dim (int, optional): The channel dimension.\n\n    Returns:\n        torch.Tensor | np.ndarray: The probabilities.\n    \"\"\"", "\n", "is_ndarray", "=", "isinstance", "(", "logits", ",", "np", ".", "ndarray", ")", "\n", "if", "is_ndarray", ":", "\n", "        ", "logits", "=", "torch", ".", "from_numpy", "(", "logits", ")", "\n", "\n", "", "if", "activation", "==", "\"sigmoid\"", ":", "\n", "        ", "out", "=", "torch", ".", "sigmoid", "(", "logits", ")", "\n", "", "elif", "activation", "==", "\"softmax\"", ":", "\n", "        ", "out", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "channel_dim", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"activation '{activation}' not supported'\"", ")", "\n", "\n", "", "if", "is_ndarray", ":", "\n", "        ", "out", "=", "out", ".", "numpy", "(", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.pred_to_categorical": [[119, 153], ["isinstance", "ValueError", "torch.from_numpy", "torch.from_numpy", "categorical.one_hot_to_categorical", "one_hot_to_categorical.numpy", "torch.argmax", "torch.argmax", "torch.sigmoid", "torch.sigmoid", "categorical.one_hot_to_categorical", "ValueError"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.one_hot_to_categorical", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.one_hot_to_categorical"], ["", "def", "pred_to_categorical", "(", "pred_or_logits", ",", "activation", ",", "channel_dim", ":", "int", "=", "1", ",", "threshold", ":", "float", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Converts one-hot encoded predictions or logits to category.\n\n    Args:\n        pred_or_logits: One-hot encoded predictions or logits. Shape BxCx...\n        activation (str): Activation to use.\n            Either ``'sigmoid'`` or ``'softmax'`` if ``pred_or_logits`` are logits.\n            If `None` or '', assumes that `pred` does not need to be passed through\n            activation function. If 'softmax', should include a background class.\n        include_background (bool): If `True`, the first slice of class dimension (``C``)\n            will not be dropped.\n    \"\"\"", "\n", "if", "activation", "not", "in", "[", "None", ",", "\"\"", ",", "\"sigmoid\"", ",", "\"softmax\"", "]", ":", "\n", "        ", "raise", "ValueError", "(", "f\"activation '{activation}' not supported'\"", ")", "\n", "\n", "", "pred", "=", "pred_or_logits", "\n", "is_ndarray", "=", "isinstance", "(", "pred", ",", "np", ".", "ndarray", ")", "\n", "if", "is_ndarray", ":", "\n", "        ", "pred", "=", "torch", ".", "from_numpy", "(", "pred", ")", "\n", "\n", "", "if", "activation", "==", "\"sigmoid\"", ":", "\n", "# TODO: Validate this case.", "\n", "        ", "out", "=", "one_hot_to_categorical", "(", "torch", ".", "sigmoid", "(", "pred", ")", ">", "threshold", ",", "channel_dim", "=", "channel_dim", ")", "\n", "", "elif", "activation", "==", "\"softmax\"", ":", "\n", "        ", "out", "=", "torch", ".", "argmax", "(", "pred", ",", "dim", "=", "channel_dim", ")", "\n", "", "elif", "activation", "in", "(", "None", ",", "\"\"", ")", ":", "\n", "# if not activation specified, assume it is one-hot encoded.", "\n", "        ", "out", "=", "one_hot_to_categorical", "(", "pred", ",", "channel_dim", "=", "channel_dim", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"activation '{activation}' not supported'\"", ")", "\n", "\n", "", "if", "is_ndarray", ":", "\n", "        ", "out", "=", "out", ".", "numpy", "(", ")", "\n", "", "return", "out", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftnc": [[27, 50], ["fft._fft_template"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._fft_template"], ["def", "fftnc", "(", "input", ":", "torch", ".", "Tensor", ",", "dim", "=", "None", ",", "norm", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Apply nD centered fast fourier transform.\n\n    This function is a backwards-compatible wrapper for centered :meth:`torch.fft.fftn`.\n    It supports backwards compatibility with ``torch.fft``as implemented in torch<1.7.\n\n    Args:\n        input (torch.Tensor): A tensor (typically complex).\n        dim (Tuple[int]): Dimensions to be transformed.\n        norm (str | bool, optional): The normalization method.\n            Defaults to ``'ortho'``. For torch<1.7, only ``'ortho'``\n            is supported.\n        is_real (bool, optional): If ``True``, ``input`` is a real-valued\n            tensor. If ``None`` or ``False`` and ``input.shape[-1] == 2``,\n            ``input`` is a real-view of a complex tensor.\n\n    Returns:\n        torch.Tensor\n\n    Note:\n        Real-valued tensors are not supported with ``torch<1.7``.\n    \"\"\"", "\n", "return", "_fft_template", "(", "input", ",", "kind", "=", "\"fft\"", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ",", "is_real", "=", "is_real", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftnc": [[52, 75], ["fft._fft_template"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._fft_template"], ["", "def", "ifftnc", "(", "input", ":", "torch", ".", "Tensor", ",", "dim", "=", "None", ",", "norm", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Apply nD centered inverse fast fourier transform.\n\n    This supports backwards compatibility with ``torch.fft``\n    as implemented in torch<1.7.\n\n    Args:\n        input (torch.Tensor): A tensor (typically complex).\n        dim (Tuple[int]): Dimensions to be transformed.\n        norm (str | bool, optional): The normalization method.\n            Defaults to ``'ortho'``. For torch<1.7, only ``'ortho'``\n            is supported.\n        is_real (bool, optional): If ``True``, ``input`` is a real-valued\n            tensor. If ``None`` or ``False`` and ``input.shape[-1] == 2``,\n            ``input`` is a real-view of a complex tensor.\n\n    Returns:\n        torch.Tensor\n\n    Note:\n        Real-valued tensors are not supported with ``torch<1.7``.\n    \"\"\"", "\n", "return", "_fft_template", "(", "input", ",", "kind", "=", "\"ifft\"", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ",", "is_real", "=", "is_real", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftc": [[77, 96], ["fft._get_fft_dims", "fft.fftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._get_fft_dims", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftnc"], ["", "def", "fftc", "(", "input", ":", "torch", ".", "Tensor", ",", "norm", ":", "str", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ",", "channels_last", "=", "False", ")", ":", "\n", "    ", "\"\"\"Apply 1D centered Fast Fourier Transform (FFT).\n\n    Args:\n        input (torch.Tensor): A tensor.\n        norm (str | bool, optional): The normalization method.\n            Defaults to ``'ortho'``. For torch<1.7, only ``'ortho'``\n            is supported.\n        is_real (bool, optional): If ``True``, ``input`` is a real-valued\n            tensor. If ``None`` or ``False`` and ``input.shape[-1] == 2``,\n            ``input`` is a real-view of a complex tensor.\n        channels_last (bool, optional): If ``True``, apply to first\n            non-batch dimensions. If ``False``, apply to last dimension.\n\n    Returns:\n        torch.Tensor: The 1D centered FFT of the input.\n    \"\"\"", "\n", "dim", "=", "_get_fft_dims", "(", "input", ",", "1", ",", "is_real", "=", "is_real", ",", "channels_last", "=", "channels_last", ")", "\n", "return", "fftnc", "(", "input", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ",", "is_real", "=", "is_real", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftc": [[98, 110], ["fft._get_fft_dims", "fft.ifftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._get_fft_dims", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftnc"], ["", "def", "ifftc", "(", "input", ":", "torch", ".", "Tensor", ",", "channels_last", "=", "False", ",", "norm", ":", "str", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply centered 2 dimensional Fast Fourier Transform.\n\n    Args:\n        data (torch.Tensor): Complex valued input data with the last dimension\n            containing real and imaginary components.\n        dims (2-tuple): Containing spatial dimension indices.\n    Returns:\n        torch.Tensor: The FFT of the input.\n    \"\"\"", "\n", "dim", "=", "_get_fft_dims", "(", "input", ",", "1", ",", "is_real", "=", "is_real", ",", "channels_last", "=", "channels_last", ")", "\n", "return", "ifftnc", "(", "input", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ",", "is_real", "=", "is_real", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c": [[112, 124], ["fft._get_fft_dims", "fft.fftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._get_fft_dims", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftnc"], ["", "def", "fft2c", "(", "input", ":", "torch", ".", "Tensor", ",", "channels_last", "=", "False", ",", "norm", ":", "str", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply centered 2 dimensional Fast Fourier Transform.\n\n    Args:\n        data (torch.Tensor): Complex valued input data with the last dimension\n            containing real and imaginary components.\n        dims (2-tuple): Containing spatial dimension indices.\n    Returns:\n        torch.Tensor: The FFT of the input.\n    \"\"\"", "\n", "dim", "=", "_get_fft_dims", "(", "input", ",", "2", ",", "is_real", "=", "is_real", ",", "channels_last", "=", "channels_last", ")", "\n", "return", "fftnc", "(", "input", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ",", "is_real", "=", "is_real", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c": [[126, 138], ["fft._get_fft_dims", "fft.ifftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._get_fft_dims", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftnc"], ["", "def", "ifft2c", "(", "input", ",", "channels_last", "=", "False", ",", "norm", ":", "str", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply centered 2-dimensional Inverse Fast Fourier Transform.\n\n    Args:\n        data (torch.Tensor): Complex valued input data with the last dimension\n            containing real and imaginary components.\n        dims (2-tuple): Containing spatial dimension indices.\n    Returns:\n        torch.Tensor: The IFFT of the input.\n    \"\"\"", "\n", "dim", "=", "_get_fft_dims", "(", "input", ",", "2", ",", "is_real", "=", "is_real", ",", "channels_last", "=", "channels_last", ")", "\n", "return", "ifftnc", "(", "input", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ",", "is_real", "=", "is_real", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft3c": [[140, 152], ["fft._get_fft_dims", "fft.fftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._get_fft_dims", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftnc"], ["", "def", "fft3c", "(", "input", ":", "torch", ".", "Tensor", ",", "channels_last", "=", "False", ",", "norm", ":", "str", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply centered 2 dimensional Fast Fourier Transform.\n\n    Args:\n        data (torch.Tensor): Complex valued input data with the last dimension\n            containing real and imaginary components.\n        dims (2-tuple): Containing spatial dimension indices.\n    Returns:\n        torch.Tensor: The FFT of the input.\n    \"\"\"", "\n", "dim", "=", "_get_fft_dims", "(", "input", ",", "3", ",", "is_real", "=", "is_real", ",", "channels_last", "=", "channels_last", ")", "\n", "return", "fftnc", "(", "input", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ",", "is_real", "=", "is_real", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft3c": [[154, 166], ["fft._get_fft_dims", "fft.ifftnc"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._get_fft_dims", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftnc"], ["", "def", "ifft3c", "(", "input", ",", "channels_last", "=", "False", ",", "norm", ":", "str", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply centered 2-dimensional Inverse Fast Fourier Transform.\n\n    Args:\n        data (torch.Tensor): Complex valued input data with the last dimension\n            containing real and imaginary components.\n        dims (2-tuple): Containing spatial dimension indices.\n    Returns:\n        torch.Tensor: The IFFT of the input.\n    \"\"\"", "\n", "dim", "=", "_get_fft_dims", "(", "input", ",", "3", ",", "is_real", "=", "is_real", ",", "channels_last", "=", "channels_last", ")", "\n", "return", "ifftnc", "(", "input", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ",", "is_real", "=", "is_real", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift": [[168, 180], ["meddlr.ops.utils.roll", "tuple", "isinstance", "range", "x.dim"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.roll"], ["", "def", "fftshift", "(", "x", ",", "dim", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Similar to np.fft.fftshift but applies to PyTorch Tensors\n    \"\"\"", "\n", "if", "dim", "is", "None", ":", "\n", "        ", "dim", "=", "tuple", "(", "range", "(", "x", ".", "dim", "(", ")", ")", ")", "\n", "shift", "=", "[", "dim", "//", "2", "for", "dim", "in", "x", ".", "shape", "]", "\n", "", "elif", "isinstance", "(", "dim", ",", "int", ")", ":", "\n", "        ", "shift", "=", "x", ".", "shape", "[", "dim", "]", "//", "2", "\n", "", "else", ":", "\n", "        ", "shift", "=", "[", "x", ".", "shape", "[", "i", "]", "//", "2", "for", "i", "in", "dim", "]", "\n", "", "return", "roll", "(", "x", ",", "shift", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift": [[182, 194], ["meddlr.ops.utils.roll", "tuple", "isinstance", "range", "x.dim"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.roll"], ["", "def", "ifftshift", "(", "x", ",", "dim", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Similar to np.fft.ifftshift but applies to PyTorch Tensors\n    \"\"\"", "\n", "if", "dim", "is", "None", ":", "\n", "        ", "dim", "=", "tuple", "(", "range", "(", "x", ".", "dim", "(", ")", ")", ")", "\n", "shift", "=", "[", "(", "dim", "+", "1", ")", "//", "2", "for", "dim", "in", "x", ".", "shape", "]", "\n", "", "elif", "isinstance", "(", "dim", ",", "int", ")", ":", "\n", "        ", "shift", "=", "(", "x", ".", "shape", "[", "dim", "]", "+", "1", ")", "//", "2", "\n", "", "else", ":", "\n", "        ", "shift", "=", "[", "(", "x", ".", "shape", "[", "i", "]", "+", "1", ")", "//", "2", "for", "i", "in", "dim", "]", "\n", "", "return", "roll", "(", "x", ",", "shift", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._fft_template": [[196, 296], ["isinstance", "meddlr.utils.env.supports_cplx_tensor", "meddlr.ops.complex.is_complex_as_real", "tuple", "len", "tuple", "meddlr.ops.complex.is_complex_as_real", "fft._to_positive_index", "torch.view_as_complex", "torch.fft.fftn", "torch.view_as_real", "sorted", "ValueError", "len", "len", "ValueError", "ValueError", "tuple", "fftshift.permute", "torch.Tensor.fft", "tuple", "fftshift.permute", "fft.ifftshift", "fft.fftshift", "torch.fft.ifftn", "ValueError", "meddlr.ops.complex.is_complex_as_real", "meddlr.ops.complex.is_complex", "fft._to_positive_index", "set", "range", "tuple", "fft.ifftshift", "fft.fftshift", "torch.ifft", "ValueError", "numpy.argsort", "fft.ifftshift", "fft.fftshift", "fft.ifftshift", "fft.fftshift", "len", "range", "range", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._to_positive_index", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._to_positive_index", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftshift", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftshift"], ["", "def", "_fft_template", "(", "\n", "data", ":", "torch", ".", "Tensor", ",", "kind", ",", "dim", "=", "None", ",", "norm", "=", "\"ortho\"", ",", "is_real", ":", "bool", "=", "None", ",", "centered", ":", "bool", "=", "True", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Template for fft operations.\n\n    Args:\n        data (torch.Tensor): A tensor.\n        kind (str): Either ``'fft'`` or ``'ifft'``.\n        dim (int(s), optional): The dimension(s) along which to apply the operation.\n            Defaults to all dimensions.\n        norm (str, optional): The normalization method. Defaults to ``'ortho'``.\n        is_real (bool, optional): If ``True``, ``input`` is treated like a real-valued\n            tensor. If not specified, this is ``True`` only if ``data`` is not complex\n            and data is not inferred to be a real view of a complex tensor\n            (i.e. ``data.shape[-1] != 2``).\n        centered (bool, optional): If ``True``, apply centered FFT. Defaults to ``True``.\n\n    Returns:\n        torch.Tensor: The FFT (or IFFT) of the input.\n    \"\"\"", "\n", "if", "isinstance", "(", "dim", ",", "int", ")", ":", "\n", "        ", "dim", "=", "(", "dim", ",", ")", "\n", "", "if", "norm", "is", "True", ":", "\n", "        ", "norm", "=", "\"ortho\"", "\n", "", "assert", "kind", "in", "(", "\"fft\"", ",", "\"ifft\"", ")", "\n", "\n", "if", "is_real", "is", "None", ":", "\n", "        ", "is_real", "=", "not", "(", "cplx", ".", "is_complex_as_real", "(", "data", ")", "or", "cplx", ".", "is_complex", "(", "data", ")", ")", "\n", "", "ndim", "=", "data", ".", "ndim", "\n", "\n", "if", "not", "env", ".", "supports_cplx_tensor", "(", ")", ":", "\n", "# Defaults to torch.fft method.", "\n", "        ", "assert", "norm", "in", "(", "\"ortho\"", ",", "False", ")", "# norm not supported", "\n", "norm", "=", "norm", "==", "\"ortho\"", "\n", "assert", "not", "is_real", "# real tensors not supported", "\n", "assert", "cplx", ".", "is_complex_as_real", "(", "data", ")", "\n", "\n", "dim", "=", "tuple", "(", "sorted", "(", "_to_positive_index", "(", "dim", ")", ")", ")", "\n", "if", "ndim", "-", "1", "in", "dim", ":", "\n", "            ", "raise", "ValueError", "(", "\"Cannot take fft along the real/imaginary channel.\"", ")", "\n", "", "if", "len", "(", "set", "(", "dim", ")", ")", "!=", "len", "(", "dim", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Expected unique dimensions, got {dim}.\"", ")", "\n", "\n", "", "signal_ndim", "=", "len", "(", "dim", ")", "\n", "if", "signal_ndim", ">", "3", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Number of dimensions must be <=3, got {len(dim)}.\"", ")", "\n", "\n", "# Reorder dims (if necessary).", "\n", "", "last_dims", "=", "dim", "+", "(", "ndim", "-", "1", ",", ")", "\n", "permute", "=", "last_dims", "!=", "tuple", "(", "range", "(", "ndim", "-", "signal_ndim", "-", "1", ",", "ndim", ")", ")", "\n", "if", "permute", ":", "\n", "            ", "order", "=", "tuple", "(", "i", "for", "i", "in", "range", "(", "ndim", ")", ")", "+", "last_dims", "\n", "data", "=", "data", ".", "permute", "(", "order", ")", "\n", "\n", "", "shift_dims", "=", "tuple", "(", "[", "-", "2", "-", "i", "for", "i", "in", "range", "(", "len", "(", "dim", ")", ")", "]", "[", ":", ":", "-", "1", "]", ")", "\n", "\n", "if", "kind", "==", "\"fft\"", ":", "\n", "            ", "if", "centered", ":", "\n", "                ", "data", "=", "ifftshift", "(", "data", ",", "dim", "=", "shift_dims", ")", "\n", "", "data", "=", "torch", ".", "Tensor", ".", "fft", "(", "data", ",", "signal_ndim", ",", "normalized", "=", "norm", ")", "\n", "if", "centered", ":", "\n", "                ", "data", "=", "fftshift", "(", "data", ",", "shift_dims", ")", "\n", "", "", "elif", "kind", "==", "\"ifft\"", ":", "\n", "            ", "if", "centered", ":", "\n", "                ", "data", "=", "ifftshift", "(", "data", ",", "dim", "=", "shift_dims", ")", "\n", "", "data", "=", "torch", ".", "ifft", "(", "data", ",", "signal_ndim", ",", "normalized", "=", "norm", ")", "\n", "if", "centered", ":", "\n", "                ", "data", "=", "fftshift", "(", "data", ",", "shift_dims", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Unknown `kind={kind}`\"", ")", "\n", "\n", "# Reorder dims (if necessary).", "\n", "", "if", "permute", ":", "\n", "            ", "reorder", "=", "tuple", "(", "np", ".", "argsort", "(", "order", ")", ")", "\n", "data", "=", "data", ".", "permute", "(", "reorder", ")", "\n", "", "return", "data", "\n", "\n", "", "is_real_view", "=", "not", "is_real", "and", "cplx", ".", "is_complex_as_real", "(", "data", ")", "\n", "if", "is_real_view", ":", "\n", "# Make dimensions positive relative to input dimensions.", "\n", "        ", "dim", "=", "_to_positive_index", "(", "dim", ",", "ndim", "=", "data", ".", "ndim", ")", "\n", "data", "=", "torch", ".", "view_as_complex", "(", "data", ")", "\n", "\n", "", "if", "kind", "==", "\"fft\"", ":", "\n", "        ", "if", "centered", ":", "\n", "            ", "data", "=", "ifftshift", "(", "data", ",", "dim", "=", "dim", ")", "\n", "", "data", "=", "torch", ".", "fft", ".", "fftn", "(", "data", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ")", "\n", "if", "centered", ":", "\n", "            ", "data", "=", "fftshift", "(", "data", ",", "dim", "=", "dim", ")", "\n", "", "", "elif", "kind", "==", "\"ifft\"", ":", "\n", "        ", "if", "centered", ":", "\n", "            ", "data", "=", "ifftshift", "(", "data", ",", "dim", "=", "dim", ")", "\n", "", "data", "=", "torch", ".", "fft", ".", "ifftn", "(", "data", ",", "dim", "=", "dim", ",", "norm", "=", "norm", ")", "\n", "if", "centered", ":", "\n", "            ", "data", "=", "fftshift", "(", "data", ",", "dim", "=", "dim", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Unknown `kind={kind}`\"", ")", "\n", "", "if", "is_real_view", ":", "\n", "        ", "data", "=", "torch", ".", "view_as_real", "(", "data", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._get_fft_dims": [[298, 306], ["tuple", "meddlr.ops.complex.is_complex_as_real", "tuple", "tuple", "range", "meddlr.ops.complex.is_complex", "range", "range"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "def", "_get_fft_dims", "(", "x", ",", "signal_ndim", ",", "is_real", ",", "channels_last", ")", ":", "\n", "    ", "if", "channels_last", ":", "\n", "        ", "return", "tuple", "(", "range", "(", "1", ",", "1", "+", "signal_ndim", ")", ")", "\n", "\n", "", "if", "not", "is_real", "and", "not", "cplx", ".", "is_complex", "(", "x", ")", "and", "cplx", ".", "is_complex_as_real", "(", "x", ")", ":", "\n", "        ", "return", "tuple", "(", "range", "(", "-", "1", "-", "signal_ndim", ",", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "tuple", "(", "range", "(", "-", "signal_ndim", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft._to_positive_index": [[308, 310], ["tuple"], "function", ["None"], ["", "", "def", "_to_positive_index", "(", "idxs", ":", "Sequence", "[", "int", "]", ",", "ndim", ":", "int", ")", ":", "\n", "    ", "return", "tuple", "(", "ndim", "+", "i", "if", "i", "<", "0", "else", "i", "for", "i", "in", "idxs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex": [[33, 47], ["meddlr.utils.env.supports_cplx_tensor", "torch.is_complex"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["def", "is_complex", "(", "x", ")", ":", "\n", "    ", "\"\"\"Returns if ``x`` is a complex-tensor.\n\n    This function is a wrapper around torch.is_complex() for PyTorch<1.7.\n    torch < 1.7 does not have the ``torch.is_complex`` directive, so\n    we can't call it for older PyTorch versions.\n\n    Args:\n        x (torch.Tensor): A tensor.\n\n    Returns:\n        bool: ``True`` if complex tensors are supported and the tensor is complex.\n    \"\"\"", "\n", "return", "supports_cplx_tensor", "(", ")", "and", "torch", ".", "is_complex", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real": [[49, 70], ["complex.is_complex", "x.size"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "def", "is_complex_as_real", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Returns ``True`` if the tensor follows the real-view\n    convention for complex numbers.\n\n    The real-view of a complex tensor has the shape [..., 2].\n\n    Args:\n        x (torch.Tensor): A tensor.\n\n    Returns:\n        bool: ``True`` if the tensor follows the real-view convention\n            for complex numbers.\n\n    Note:\n        We recommend using complex tensors instead of the real-view\n        convention. This function cannot interpret if the last dimension\n        has a size of ``2`` because it is the real-imaginary channel or\n        for some other reason.\n    \"\"\"", "\n", "return", "not", "is_complex", "(", "x", ")", "and", "x", ".", "size", "(", "-", "1", ")", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj": [[72, 91], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "x.conj", "torch.stack"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj"], ["", "def", "conj", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Computes the complex conjugate of complex-valued input tensor (x).\n\n    ``conj(a + ib)`` = :math:`\\\\bar{a + ib} = a - ib`\n\n    Args:\n        x (torch.Tensor): A tensor.\n\n    Returns:\n        torch.Tensor: The conjugate.\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "conj", "(", ")", "\n", "", "else", ":", "\n", "        ", "real", "=", "x", "[", "...", ",", "0", "]", "\n", "imag", "=", "x", "[", "...", ",", "1", "]", "\n", "return", "torch", ".", "stack", "(", "(", "real", ",", "-", "1.0", "*", "imag", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul": [[93, 132], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "torch.stack", "x.select", "y.select", "x.select", "y.select", "x.select", "y.select", "x.select", "y.select"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "", "def", "mul", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"\n    Multiplies two complex-valued tensors x and y.\n\n    :math:`z = (a + ib) * (c + id) = (ac - bd) + i(ad + bc)`\n\n    Args:\n        x (torch.Tensor): A tensor.\n        y (torch.Tensor): A tensor.\n\n    Returns:\n        torch.Tensor: The matrix multiplication.\n    \"\"\"", "\n", "# assert x.size(-1) == 2", "\n", "# assert y.size(-1) == 2", "\n", "#", "\n", "# a = x[..., 0]", "\n", "# b = x[..., 1]", "\n", "# c = y[..., 0]", "\n", "# d = y[..., 1]", "\n", "#", "\n", "# real = a * c - b * d", "\n", "# imag = a * d + b * c", "\n", "\n", "# return torch.stack((real, imag), dim=-1)", "\n", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "assert", "is_complex_as_real", "(", "y", ")", "or", "is_complex", "(", "y", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", "*", "y", "\n", "", "else", ":", "\n", "# note: using select() makes sure that another copy is not made.", "\n", "# real = a*c - b*d", "\n", "        ", "real", "=", "x", ".", "select", "(", "-", "1", ",", "0", ")", "*", "y", ".", "select", "(", "-", "1", ",", "0", ")", "# a*c", "\n", "real", "-=", "x", ".", "select", "(", "-", "1", ",", "1", ")", "*", "y", ".", "select", "(", "-", "1", ",", "1", ")", "# b*d", "\n", "# imag = a*d + b*c", "\n", "imag", "=", "x", ".", "select", "(", "-", "1", ",", "0", ")", "*", "y", ".", "select", "(", "-", "1", ",", "1", ")", "# a*d", "\n", "imag", "+=", "x", ".", "select", "(", "-", "1", ",", "1", ")", "*", "y", ".", "select", "(", "-", "1", ",", "0", ")", "# b*c", "\n", "return", "torch", ".", "stack", "(", "(", "real", ",", "imag", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs": [[134, 149], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "x.abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "", "def", "abs", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Computes the absolute value (magnitude) of a complex-valued input tensor (x).\n\n    Args:\n        x (torch.Tensor): A tensor.\n\n    Returns:\n        torch.Tensor: The magnitude tensor.\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "abs", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "x", "**", "2", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", ".", "sqrt", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle": [[151, 166], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "x.angle", "torch.atan"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle"], ["", "", "def", "angle", "(", "x", ",", "eps", "=", "1e-11", ")", ":", "\n", "    ", "\"\"\"\n    Computes the phase of a complex-valued input tensor (x).\n\n    Args:\n        x (torch.Tensor): A tensor.\n\n    Returns:\n        torch.Tensor: The angle tensor.\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "angle", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "torch", ".", "atan", "(", "x", "[", "...", ",", "1", "]", "/", "(", "x", "[", "...", ",", "0", "]", "+", "eps", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.real": [[168, 177], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "", "def", "real", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Gets real component of complex tensor.\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "real", "\n", "", "else", ":", "\n", "        ", "return", "x", "[", "...", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.imag": [[179, 188], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "", "def", "imag", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Gets imaginary component of complex tensor.\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "imag", "\n", "", "else", ":", "\n", "        ", "return", "x", "[", "...", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.from_polar": [[190, 206], ["meddlr.utils.env.supports_cplx_tensor", "RuntimeError", "torch.polar", "torch.stack", "meddlr.utils.env.supports_cplx_tensor", "torch.view_as_real", "torch.cos", "torch.sin"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor"], ["", "", "def", "from_polar", "(", "magnitude", ",", "phase", ",", "return_cplx", ":", "bool", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Computes real and imaginary values from polar representation.\n    \"\"\"", "\n", "if", "return_cplx", "and", "not", "supports_cplx_tensor", "(", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "f\"torch {torch.__version__} does not support complex tensors\"", ")", "\n", "\n", "", "if", "supports_cplx_tensor", "(", ")", ":", "\n", "        ", "out", "=", "torch", ".", "polar", "(", "magnitude", ",", "phase", ")", "\n", "if", "return_cplx", "is", "False", ":", "\n", "            ", "out", "=", "torch", ".", "view_as_real", "(", "out", ")", "\n", "", "return", "out", "\n", "", "else", ":", "\n", "        ", "real", "=", "magnitude", "*", "torch", ".", "cos", "(", "phase", ")", "\n", "imag", "=", "magnitude", "*", "torch", ".", "sin", "(", "phase", ")", "\n", "return", "torch", ".", "stack", "(", "(", "real", ",", "imag", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.channels_first": [[211, 234], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "x.permute", "x.permute", "tuple", "range", "tuple", "range"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["def", "channels_first", "(", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "\"\"\"Permute complex-valued ``x`` to channels-first convention.\n\n    For complex values, there are two potential conventions:\n\n    1. ``x`` is complex-valued: ``(B,...,C)`` -> ``(B, C, ...)``.\n    2. The real and imaginary components are stored in the last dimension.\n       ``(B,...,C,2)`` -> ``(B, C, ..., 2)``.\n\n    Args:\n        x (torch.Tensor): A complex-valued tensor of shape ``(B,...,C)``\n            or a real-valued tensor of shape ``(B,...,C,2)``.\n\n    Returns:\n        torch.Tensor: A channels-first tensor. If ``x`` is complex,\n            this will also be complex. If ``x`` is the real-view of\n            a complex tensor, this will also be the real view.\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "permute", "(", "(", "0", ",", "x", ".", "ndim", "-", "1", ")", "+", "tuple", "(", "range", "(", "1", ",", "x", ".", "ndim", "-", "1", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "x", ".", "permute", "(", "(", "0", ",", "x", ".", "ndim", "-", "2", ")", "+", "tuple", "(", "range", "(", "1", ",", "x", ".", "ndim", "-", "2", ")", ")", "+", "(", "x", ".", "ndim", "-", "1", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.channel_first": [[236, 244], ["meddlr.utils.deprecated.deprecated", "complex.channels_first"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.channels_first"], ["", "", "@", "deprecated", "(", "\n", "reason", "=", "\"Renamed to channels_first\"", ",", "\n", "vremove", "=", "\"v0.1.0\"", ",", "\n", "replacement", "=", "\"meddlr.ops.complex.channels_first\"", ",", "\n", ")", "\n", "def", "channel_first", "(", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "\"\"\"Deprecated alias for :func:`channels_first`.\"\"\"", "\n", "return", "channels_first", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.channels_last": [[246, 261], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "x.permute", "x.permute", "tuple", "tuple", "range", "range"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "def", "channels_last", "(", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "\"\"\"Permute complex-valued ``x`` to channels-last convention.\n\n    Args:\n        x (torch.Tensor): A tensor of shape [B,C,H,W,...] or [B,C,H,W,...,2].\n\n    Returns:\n        torch.Tensor: A tensor of shape [B,H,W,...,C] or [B,H,W,...,C,2].\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "permute", "(", "(", "0", ",", ")", "+", "tuple", "(", "range", "(", "2", ",", "x", ".", "ndim", ")", "+", "(", "1", ",", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "order", "=", "(", "0", ",", ")", "+", "tuple", "(", "range", "(", "2", ",", "x", ".", "ndim", "-", "2", ")", ")", "+", "(", "1", ",", "x", ".", "ndim", "-", "1", ")", "\n", "return", "x", ".", "permute", "(", "order", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask": [[263, 286], ["complex.is_complex", "complex.abs", "torch.where", "torch.view_as_real", "torch.view_as_real.size", "torch.ones_like", "torch.zeros_like", "mask.unsqueeze.unsqueeze"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "", "def", "get_mask", "(", "x", ",", "eps", "=", "1e-11", ")", ":", "\n", "    ", "\"\"\"Returns a binary mask for where ``x`` is nonzero with ``eps`` tolerance.\n\n      - 0, if both real and imaginary components are zero.\n      - 1, if either real and imaginary components are non-zero.\n\n    Args:\n        x (torch.Tensor): A complex-valued tensor.\n        eps (float): Tolerance for zer0-value.\n\n    Returns:\n        torch.Tensor: A binary mask of shape ``x.shape``.\n    \"\"\"", "\n", "unsqueeze", "=", "True", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "unsqueeze", "=", "False", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "", "assert", "x", ".", "size", "(", "-", "1", ")", "==", "2", "\n", "absx", "=", "abs", "(", "x", ")", "# squashes last dimension", "\n", "mask", "=", "torch", ".", "where", "(", "absx", ">", "eps", ",", "torch", ".", "ones_like", "(", "absx", ")", ",", "torch", ".", "zeros_like", "(", "absx", ")", ")", "\n", "if", "unsqueeze", ":", "\n", "        ", "mask", "=", "mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul": [[288, 304], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "torch.matmul", "torch.stack", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul"], ["", "def", "matmul", "(", "X", ",", "Y", ")", ":", "\n", "    ", "\"\"\"\n    Computes complex-valued matrix product of X and Y.\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "X", ")", "or", "is_complex", "(", "X", ")", "\n", "assert", "is_complex_as_real", "(", "Y", ")", "or", "is_complex", "(", "Y", ")", "\n", "if", "is_complex", "(", "X", ")", ":", "\n", "        ", "return", "torch", ".", "matmul", "(", "X", ",", "Y", ")", "\n", "", "else", ":", "\n", "        ", "A", "=", "X", "[", "...", ",", "0", "]", "\n", "B", "=", "X", "[", "...", ",", "1", "]", "\n", "C", "=", "Y", "[", "...", ",", "0", "]", "\n", "D", "=", "Y", "[", "...", ",", "1", "]", "\n", "real", "=", "torch", ".", "matmul", "(", "A", ",", "C", ")", "-", "torch", ".", "matmul", "(", "B", ",", "D", ")", "\n", "imag", "=", "torch", ".", "matmul", "(", "A", ",", "D", ")", "+", "torch", ".", "matmul", "(", "B", ",", "C", ")", "\n", "return", "torch", ".", "stack", "(", "(", "real", ",", "imag", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.power_method": [[306, 332], ["complex.matmul", "range", "eigenvals.reshape", "complex.is_complex_as_real", "complex.is_complex", "torch.view_as_real", "torch.view_as_real.size", "conj().permute", "torch.cuda.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "complex.matmul", "complex.conj", "torch.cuda.FloatTensor", "torch.FloatTensor", "eigenvals.reshape", "complex.abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "", "def", "power_method", "(", "X", ",", "num_iter", "=", "10", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "\"\"\"\n    Iteratively computes first singular value of X using power method.\n    \"\"\"", "\n", "if", "is_complex_as_real", "(", "X", ")", "or", "is_complex", "(", "X", ")", ":", "\n", "        ", "X", "=", "torch", ".", "view_as_real", "(", "X", ")", "\n", "", "assert", "X", ".", "size", "(", "-", "1", ")", "==", "2", "\n", "\n", "# get data dimensions", "\n", "batch_size", ",", "m", ",", "n", ",", "_", "=", "X", ".", "shape", "\n", "\n", "XhX", "=", "matmul", "(", "conj", "(", "X", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ",", "X", ")", "\n", "\n", "# initialize random eigenvector", "\n", "if", "XhX", ".", "is_cuda", ":", "\n", "        ", "v", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "batch_size", ",", "n", ",", "1", ",", "2", ")", ".", "uniform_", "(", ")", "\n", "", "else", ":", "\n", "        ", "v", "=", "torch", ".", "FloatTensor", "(", "batch_size", ",", "n", ",", "1", ",", "2", ")", ".", "uniform_", "(", ")", "\n", "# v = torch.rand(batch_size, n, 1, 2).to(X.device) # slow way", "\n", "\n", "", "for", "_i", "in", "range", "(", "num_iter", ")", ":", "\n", "        ", "v", "=", "matmul", "(", "XhX", ",", "v", ")", "\n", "eigenvals", "=", "(", "abs", "(", "v", ")", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "sqrt", "(", ")", "\n", "v", "=", "v", "/", "(", "eigenvals", ".", "reshape", "(", "batch_size", ",", "1", ",", "1", ",", "1", ")", "+", "eps", ")", "\n", "\n", "", "return", "eigenvals", ".", "reshape", "(", "batch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.svd": [[334, 374], ["torch.svd", "torch.stack", "torch.stack", "complex.is_complex_as_real", "complex.is_complex", "torch.view_as_real", "torch.view_as_real.size", "torch.cuda.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.cuda.FloatTensor", "torch.FloatTensor"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.svd", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "def", "svd", "(", "X", ",", "compute_uv", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Computes singular value decomposition of batch of complex-valued matrices.\n\n    Args:\n        matrix (torch.Tensor): batch of complex-valued 2D matrices\n            [batch, m, n, 2]\n    Returns:\n        U, S, V (tuple)\n    \"\"\"", "\n", "if", "is_complex_as_real", "(", "X", ")", "or", "is_complex", "(", "X", ")", ":", "\n", "        ", "X", "=", "torch", ".", "view_as_real", "(", "X", ")", "\n", "", "assert", "X", ".", "size", "(", "-", "1", ")", "==", "2", "\n", "\n", "# Get data dimensions", "\n", "batch_size", ",", "m", ",", "n", ",", "_", "=", "X", ".", "shape", "\n", "\n", "# Allocate block-wise matrix", "\n", "# (otherwise, need to allocate new arrays three times)", "\n", "if", "X", ".", "is_cuda", ":", "\n", "        ", "Xb", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "batch_size", ",", "2", "*", "m", ",", "2", "*", "n", ")", ".", "fill_", "(", "0", ")", "\n", "", "else", ":", "\n", "        ", "Xb", "=", "torch", ".", "FloatTensor", "(", "batch_size", ",", "2", "*", "m", ",", "2", "*", "n", ")", ".", "fill_", "(", "0", ")", "\n", "\n", "# Construct real-valued block matrix", "\n", "# Xb = [X.real, X.imag; -X.imag, X.real]", "\n", "", "Xb", "[", ":", ",", ":", "m", ",", ":", "n", "]", "=", "X", "[", "...", ",", "0", "]", "\n", "Xb", "[", ":", ",", ":", "m", ",", "n", ":", "]", "=", "X", "[", "...", ",", "1", "]", "\n", "Xb", "[", ":", ",", "m", ":", ",", ":", "n", "]", "=", "-", "X", "[", "...", ",", "1", "]", "\n", "Xb", "[", ":", ",", "m", ":", ",", "n", ":", "]", "=", "X", "[", "...", ",", "0", "]", "\n", "\n", "# Perform real-valued SVD", "\n", "U", ",", "S", ",", "V", "=", "torch", ".", "svd", "(", "Xb", ",", "compute_uv", "=", "compute_uv", ")", "\n", "\n", "# Slice U, S, V appropriately", "\n", "S", "=", "S", "[", ":", ",", ":", ":", "2", "]", "\n", "U", "=", "torch", ".", "stack", "(", "(", "U", "[", ":", ",", ":", "m", ",", ":", ":", "2", "]", ",", "-", "U", "[", ":", ",", "m", ":", ",", ":", ":", "2", "]", ")", ",", "dim", "=", "3", ")", "\n", "V", "=", "torch", ".", "stack", "(", "(", "V", "[", ":", ",", ":", "n", ",", ":", ":", "2", "]", ",", "-", "V", "[", ":", ",", "n", ":", ",", ":", ":", "2", "]", ")", ",", "dim", "=", "3", ")", "\n", "\n", "return", "U", ",", "S", ",", "V", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_numpy": [[376, 386], ["complex.is_complex", "complex.is_complex_as_real", "complex.is_complex", "x.numpy.clone().numpy", "x.numpy.numpy", "x.numpy.clone"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "def", "to_numpy", "(", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "\"\"\"\n    Convert real-valued PyTorch tensor to complex-valued numpy array.\n    \"\"\"", "\n", "assert", "is_complex_as_real", "(", "x", ")", "or", "is_complex", "(", "x", ")", "\n", "if", "is_complex", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "clone", "(", ")", ".", "numpy", "(", ")", "# previously returned copy", "\n", "", "else", ":", "\n", "        ", "x", "=", "x", ".", "numpy", "(", ")", "\n", "return", "x", "[", "...", ",", "0", "]", "+", "1j", "*", "x", "[", "...", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor": [[388, 395], ["torch.from_numpy", "meddlr.utils.env.supports_cplx_tensor", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor"], ["", "", "def", "to_tensor", "(", "x", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "\"\"\"\n    Convert complex-valued numpy array to real-valued PyTorch tensor.\n    \"\"\"", "\n", "if", "not", "supports_cplx_tensor", "(", ")", ":", "\n", "        ", "x", "=", "np", ".", "stack", "(", "(", "x", ".", "real", ",", "x", ".", "imag", ")", ",", "axis", "=", "-", "1", ")", "\n", "", "return", "torch", ".", "from_numpy", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.rss": [[397, 410], ["torch.sqrt", "complex.abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "rss", "(", "x", ":", "torch", ".", "Tensor", ",", "dim", ":", "int", "=", "0", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Compute the root-sum-of-squares (RSS) for complex inputs.\n    RSS is computed assuming that dim is the coil dimension.\n\n    Args:\n        data: The complex-valued input tensor.\n        dim: The dimensions along which to apply the RSS transform.\n\n    Returns:\n        torch.Tensor: The RSS value.\n    \"\"\"", "\n", "return", "torch", ".", "sqrt", "(", "(", "abs", "(", "x", ")", "**", "2", ")", ".", "sum", "(", "dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.center_crop": [[415, 445], ["tuple", "all", "zip", "range", "slice", "slice", "complex.is_complex_as_real", "range", "range", "range", "len", "complex.is_complex", "range", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["def", "center_crop", "(", "x", ":", "torch", ".", "Tensor", ",", "shape", ",", "channels_last", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Apply a center crop to the input image or batch of complex images.\n\n    Args:\n        data (torch.Tensor): The complex input tensor to be center cropped.\n        shape (int, int): The output shape. The shape should be smaller than the\n            corresponding dimensions of data.\n        channels_last (bool, optional): If ``True``, crop dimensions ``range(1, 1+len(shape))``.\n            If ``False``, apply to last non-real/imaginary channel dimensions.\n\n    Returns:\n        torch.Tensor: The center cropped image.\n    \"\"\"", "\n", "if", "channels_last", ":", "\n", "        ", "dims", "=", "range", "(", "1", ",", "1", "+", "len", "(", "shape", ")", ")", "\n", "", "elif", "not", "is_complex", "(", "x", ")", "and", "is_complex_as_real", "(", "x", ")", ":", "\n", "        ", "dims", "=", "range", "(", "-", "1", "-", "len", "(", "shape", ")", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "dims", "=", "range", "(", "-", "len", "(", "shape", ")", ",", "0", ")", "\n", "\n", "", "x_shape", "=", "tuple", "(", "x", ".", "shape", "[", "d", "]", "for", "d", "in", "dims", ")", "\n", "assert", "all", "(", "0", "<", "shape", "[", "idx", "]", "<=", "x_shape", "[", "idx", "]", "for", "idx", "in", "range", "(", "len", "(", "shape", ")", ")", ")", "\n", "\n", "sl", "=", "[", "slice", "(", "None", ")", "for", "_", "in", "range", "(", "x", ".", "ndim", ")", "]", "\n", "for", "d", ",", "shp", ",", "x_shp", "in", "zip", "(", "dims", ",", "shape", ",", "x_shape", ")", ":", "\n", "        ", "start", "=", "(", "x_shp", "-", "shp", ")", "//", "2", "\n", "end", "=", "start", "+", "shp", "\n", "sl", "[", "d", "]", "=", "slice", "(", "start", ",", "end", ")", "\n", "", "return", "x", "[", "sl", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.roll": [[20, 35], ["isinstance", "roll.narrow", "roll.narrow", "torch.cat", "torch.cat", "zip", "roll.size", "len", "len", "utils.roll", "roll.size", "roll.size"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.roll"], ["def", "roll", "(", "x", ",", "shift", ",", "dim", ")", ":", "\n", "    ", "\"\"\"\n    Similar to np.roll but applies to PyTorch Tensors\n    \"\"\"", "\n", "if", "isinstance", "(", "shift", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "        ", "assert", "len", "(", "shift", ")", "==", "len", "(", "dim", ")", "\n", "for", "s", ",", "d", "in", "zip", "(", "shift", ",", "dim", ")", ":", "\n", "            ", "x", "=", "roll", "(", "x", ",", "s", ",", "d", ")", "\n", "", "return", "x", "\n", "", "shift", "=", "shift", "%", "x", ".", "size", "(", "dim", ")", "\n", "if", "shift", "==", "0", ":", "\n", "        ", "return", "x", "\n", "", "left", "=", "x", ".", "narrow", "(", "dim", ",", "0", ",", "x", ".", "size", "(", "dim", ")", "-", "shift", ")", "\n", "right", "=", "x", ".", "narrow", "(", "dim", ",", "x", ".", "size", "(", "dim", ")", "-", "shift", ",", "shift", ")", "\n", "return", "torch", ".", "cat", "(", "(", "right", ",", "left", ")", ",", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad": [[37, 84], ["all", "tuple", "torch.pad", "pad.extend", "len", "len", "range", "zip", "len", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad"], ["", "def", "pad", "(", "x", ":", "torch", ".", "Tensor", ",", "shape", ":", "Sequence", "[", "int", "]", ",", "mode", "=", "\"constant\"", ",", "value", "=", "0", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Center pad a batched tensor.\n\n    This function pads a tensor to a given shape such that the center\n    of the output tensor is equal to input ``x``. Padding is applied\n    on dimensions ``range(1, 1+len(shape))``.\n\n    Args:\n        x (torch.Tensor): Input tensor of shape (B, ...)\n        shape (Tuple[int]): Shape to zero pad to.\n            Use ``None`` to skip padding certain dimensions.\n            If ``len(shape) < x.ndim - 1``, then the last dimension(s)\n            of ``x`` will not be padded.\n\n    Returns:\n        torch.Tensor: Padded tensor of shape (B, ...)\n\n    Note:\n        The 0-th dimension is assumed to be the batch dimension and is not padded.\n        To pad this dimension, unsqueeze your tensor first.\n\n    Example:\n        >>> x = torch.randn(1, 100, 150, 3)\n        >>> out = pad(x, (200, 250))\n        >>> out.shape\n        torch.Size([1, 200, 250, 3])\n    \"\"\"", "\n", "x_shape", "=", "x", ".", "shape", "[", "1", ":", "1", "+", "len", "(", "shape", ")", "]", "\n", "assert", "all", "(", "\n", "x_shape", "[", "i", "]", "<=", "shape", "[", "i", "]", "or", "shape", "[", "i", "]", "is", "None", "for", "i", "in", "range", "(", "len", "(", "shape", ")", ")", "\n", ")", ",", "f\"Tensor spatial dimensions {x_shape} smaller than zero pad dimensions\"", "\n", "\n", "total_padding", "=", "tuple", "(", "\n", "desired", "-", "current", "if", "desired", "is", "not", "None", "else", "0", "for", "current", ",", "desired", "in", "zip", "(", "x_shape", ",", "shape", ")", "\n", ")", "\n", "# Adding no padding for terminal dimensions.", "\n", "# torch.nn.functional.pad pads dimensions in reverse order.", "\n", "total_padding", "+=", "(", "0", ",", ")", "*", "(", "len", "(", "x", ".", "shape", ")", "-", "1", "-", "len", "(", "x_shape", ")", ")", "\n", "total_padding", "=", "total_padding", "[", ":", ":", "-", "1", "]", "\n", "\n", "pad", "=", "[", "]", "\n", "for", "padding", "in", "total_padding", ":", "\n", "        ", "pad1", "=", "padding", "//", "2", "\n", "pad2", "=", "padding", "-", "pad1", "\n", "pad", ".", "extend", "(", "[", "pad1", ",", "pad2", "]", ")", "\n", "\n", "", "return", "F", ".", "pad", "(", "x", ",", "pad", ",", "mode", "=", "mode", ",", "value", "=", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.zero_pad": [[86, 105], ["utils.pad"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad"], ["", "def", "zero_pad", "(", "x", ":", "torch", ".", "Tensor", ",", "shape", ":", "Sequence", "[", "int", "]", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Zero-pad a batched tensor.\n\n    See :func:`pad` for more details.\n\n    Args:\n        x (torch.Tensor): Input tensor of shape (B, ...).\n        shape (Tuple[int]): Shape to zero pad to.\n\n    Returns:\n        torch.Tensor: Zero-padded tensor.\n\n    Example:\n        >>> x = torch.randn(1, 100, 150, 3)\n        >>> out = zero_pad(x, (200, 250))\n        >>> out.shape\n        torch.Size([1, 200, 250, 3])\n    \"\"\"", "\n", "return", "pad", "(", "x", ",", "shape", ",", "mode", "=", "\"constant\"", ",", "value", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.time_average": [[107, 113], ["meddlr.get_mask", "x.sum", "cplx.get_mask.sum"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask"], ["", "def", "time_average", "(", "x", ",", "dim", ",", "eps", "=", "1e-6", ",", "keepdim", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Computes time average across a specified axis.\n    \"\"\"", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "x", ")", "\n", "return", "x", ".", "sum", "(", "dim", ",", "keepdim", "=", "keepdim", ")", "/", "(", "mask", ".", "sum", "(", "dim", ",", "keepdim", "=", "keepdim", ")", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.sliding_window": [[115, 129], ["range", "torch.cat", "torch.cat", "utils.roll", "roll.narrow", "utils.time_average", "int"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.roll", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.time_average"], ["", "def", "sliding_window", "(", "x", ",", "dim", ",", "window_size", ")", ":", "\n", "    ", "\"\"\"\n    Computes sliding window with circular boundary conditions across a specified\n    axis.\n    \"\"\"", "\n", "assert", "0", "<", "window_size", "<=", "x", ".", "shape", "[", "dim", "]", "\n", "\n", "windows", "=", "[", "None", "]", "*", "x", ".", "shape", "[", "dim", "]", "\n", "for", "i", "in", "range", "(", "x", ".", "shape", "[", "dim", "]", ")", ":", "\n", "        ", "data_slide", "=", "roll", "(", "x", ",", "int", "(", "window_size", "/", "2", ")", "-", "i", ",", "dim", ")", "\n", "window", "=", "data_slide", ".", "narrow", "(", "dim", ",", "0", ",", "window_size", ")", "\n", "windows", "[", "i", "]", "=", "time_average", "(", "window", ",", "dim", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "windows", ",", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.center_crop": [[131, 157], ["range", "len", "data.narrow.narrow"], "function", ["None"], ["", "def", "center_crop", "(", "data", ",", "shape", ",", "include_batch", ":", "bool", "=", "False", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Apply a center crop to a batch of images.\n\n    Args:\n        data (torch.Tensor): The input tensor to be center cropped.\n        shape (Tuple[int]): The output shape. If shape[dim] = -1 or None,\n            then no crop will be applied in that dimension.\n        include_batch (bool): If ``True``, the center crop will also be\n            applied to the batch dimension (``dim=0``).\n\n    Returns:\n        torch.Tensor: The center-cropped tensor.\n\n    Note:\n        The 0-th dimension is assumed to be the batch dimension.\n        To apply the crop to this dimension as well, set ``include_batch=True``.\n    \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "shape", ")", ")", ":", "\n", "        ", "data_dim", "=", "i", "if", "include_batch", "else", "i", "+", "1", "\n", "if", "(", "shape", "[", "i", "]", "==", "data", ".", "shape", "[", "data_dim", "]", ")", "or", "(", "shape", "[", "i", "]", "==", "-", "1", ")", ":", "\n", "            ", "continue", "\n", "", "assert", "0", "<", "shape", "[", "i", "]", "<=", "data", ".", "shape", "[", "data_dim", "]", "\n", "idx_start", "=", "(", "data", ".", "shape", "[", "data_dim", "]", "-", "shape", "[", "i", "]", ")", "//", "2", "\n", "data", "=", "data", ".", "narrow", "(", "data_dim", ",", "idx_start", ",", "shape", "[", "i", "]", ")", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.normalize": [[159, 172], ["None"], "function", ["None"], ["", "def", "normalize", "(", "data", ",", "mean", ",", "stddev", ",", "eps", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"\n    Normalize the given tensor using:\n        (data - mean) / (stddev + eps)\n    Args:\n        data (torch.Tensor): Input data to be normalized\n        mean (float): Mean value\n        stddev (float): Standard deviation\n        eps (float): Added to stddev to prevent dividing by zero\n    Returns:\n        torch.Tensor: Normalized tensor\n    \"\"\"", "\n", "return", "(", "data", "-", "mean", ")", "/", "(", "stddev", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.normalize_instance": [[174, 188], ["data.mean", "data.std", "utils.normalize"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TopMagnitudeNormalizer.normalize"], ["", "def", "normalize_instance", "(", "data", ",", "eps", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"\n    Normalize the given tensor using:\n        (data - mean) / (stddev + eps)\n    where mean and stddev are computed from the data itself.\n    Args:\n        data (torch.Tensor): Input data to be normalized\n        eps (float): Added to stddev to prevent dividing by zero\n    Returns:\n        torch.Tensor: Normalized tensor\n    \"\"\"", "\n", "mean", "=", "data", ".", "mean", "(", ")", "\n", "std", "=", "data", ".", "std", "(", ")", "\n", "return", "normalize", "(", "data", ",", "mean", ",", "std", ",", "eps", ")", ",", "mean", ",", "std", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_fft.TestFFTReproducibility.test_fft2": [[17, 42], ["unittest.skipIf", "torch.Generator().manual_seed", "torch.rand", "meddlr.fft2", "meddlr.fft2", "meddlr.fft2c", "meddlr.fft2c", "torch.allclose", "torch.rand", "meddlr.fft2", "meddlr.fft2", "meddlr.fft2c", "meddlr.fft2c", "torch.allclose", "torch.rand", "meddlr.fft2", "meddlr.fft2", "meddlr.fft2c", "meddlr.fft2c", "torch.allclose", "torch.rand", "meddlr.fft2", "meddlr.fft2", "meddlr.fft2c", "meddlr.fft2c", "torch.allclose", "meddlr.utils.env.pt_version", "meddlr.utils.env.pt_version", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version"], ["@", "unittest", ".", "skipIf", "(", "env", ".", "pt_version", "(", ")", ">=", "[", "1", ",", "8", "]", ",", "\"torch.fft not supported in torch>=1.8\"", ")", "\n", "def", "test_fft2", "(", "self", ")", ":", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "1", ")", "\n", "\n", "# Complex tensor as real tensor.", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "8", ",", "2", ",", "generator", "=", "g", ")", "# B x H x W x #coils x 2", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "X2", "=", "oF", ".", "fft2c", "(", "x", ",", "channels_last", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "X2", ",", "X", ")", "\n", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "5", ",", "8", ",", "2", ",", "generator", "=", "g", ")", "# B x H x W x D x #coils x 2", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "X2", "=", "oF", ".", "fft2c", "(", "x", ",", "channels_last", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "X2", ",", "X", ")", "\n", "\n", "# Complex tensor.", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "8", ",", "generator", "=", "g", ",", "dtype", "=", "torch", ".", "complex64", ")", "# B x H x W x #coils", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "X2", "=", "oF", ".", "fft2c", "(", "x", ",", "channels_last", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "X2", ",", "X", ")", "\n", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "5", ",", "8", ",", "generator", "=", "g", ",", "dtype", "=", "torch", ".", "complex64", ")", "# B x H x W x D x #coils", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "X2", "=", "oF", ".", "fft2c", "(", "x", ",", "channels_last", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "X2", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_fft.TestFFTReproducibility.test_ifft2": [[43, 72], ["unittest.skipIf", "torch.Generator().manual_seed", "torch.rand", "meddlr.fft2", "meddlr.fft2", "meddlr.ifft2", "meddlr.ifft2", "meddlr.ifft2c", "meddlr.ifft2c", "torch.allclose", "torch.rand", "meddlr.fft2", "meddlr.fft2", "meddlr.ifft2", "meddlr.ifft2", "meddlr.ifft2c", "meddlr.ifft2c", "torch.allclose", "torch.rand", "meddlr.fft2", "meddlr.fft2", "meddlr.ifft2", "meddlr.ifft2", "meddlr.ifft2c", "meddlr.ifft2c", "torch.allclose", "torch.rand", "meddlr.fft2", "meddlr.fft2", "meddlr.ifft2", "meddlr.ifft2", "meddlr.ifft2c", "meddlr.ifft2c", "torch.allclose", "meddlr.utils.env.pt_version", "meddlr.utils.env.pt_version", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version"], ["", "@", "unittest", ".", "skipIf", "(", "env", ".", "pt_version", "(", ")", ">=", "[", "1", ",", "8", "]", ",", "\"torch.fft not supported in torch>=1.8\"", ")", "\n", "def", "test_ifft2", "(", "self", ")", ":", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "1", ")", "\n", "\n", "# Complex tensor as real tensor.", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "8", ",", "2", ",", "generator", "=", "g", ")", "# B x H x W x #coils x 2", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "xhat", "=", "T", ".", "ifft2", "(", "X", ")", "\n", "xhat2", "=", "oF", ".", "ifft2c", "(", "X", ",", "channels_last", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "xhat2", ",", "xhat", ")", "\n", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "5", ",", "8", ",", "2", ",", "generator", "=", "g", ")", "# B x H x W x D x #coils x 2", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "xhat", "=", "T", ".", "ifft2", "(", "X", ")", "\n", "xhat2", "=", "oF", ".", "ifft2c", "(", "X", ",", "channels_last", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "xhat2", ",", "xhat", ")", "\n", "\n", "# Complex tensor.", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "8", ",", "generator", "=", "g", ",", "dtype", "=", "torch", ".", "complex64", ")", "# B x H x W x #coils", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "xhat", "=", "T", ".", "ifft2", "(", "X", ")", "\n", "xhat2", "=", "oF", ".", "ifft2c", "(", "X", ",", "channels_last", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "xhat2", ",", "xhat", ")", "\n", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "5", ",", "8", ",", "generator", "=", "g", ",", "dtype", "=", "torch", ".", "complex64", ")", "# B x H x W x D x #coils", "\n", "X", "=", "T", ".", "fft2", "(", "x", ")", "\n", "xhat", "=", "T", ".", "ifft2", "(", "X", ")", "\n", "xhat2", "=", "oF", ".", "ifft2c", "(", "X", ",", "channels_last", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "xhat2", ",", "xhat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_fft.TestFFTOp.test_fft2_cplx_tensors": [[75, 83], ["torch.Generator().manual_seed", "torch.rand", "meddlr.fft2c", "meddlr.fft2c", "meddlr.fft2c", "meddlr.fft2c", "torch.allclose", "torch.view_as_complex", "torch.view_as_real", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c"], ["    ", "def", "test_fft2_cplx_tensors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test fft2 with PyTorch>=1.7 complex tensor support.\"\"\"", "\n", "g", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "1", ")", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "8", ",", "2", ",", "generator", "=", "g", ")", "# B x H x W x #coils x 2", "\n", "X", "=", "oF", ".", "fft2c", "(", "x", ")", "\n", "X2", "=", "oF", ".", "fft2c", "(", "torch", ".", "view_as_complex", "(", "x", ")", ")", "# B x H x W x #coils", "\n", "\n", "assert", "torch", ".", "allclose", "(", "torch", ".", "view_as_real", "(", "X2", ")", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_fft.TestFFTOp.test_ifft2_cplx_tensors": [[84, 101], ["torch.Generator().manual_seed", "torch.rand", "meddlr.fft2c", "meddlr.fft2c", "torch.view_as_complex", "meddlr.ifft2c", "meddlr.ifft2c", "meddlr.ifft2c", "meddlr.ifft2c", "torch.allclose", "torch.view_as_real", "torch.max", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c"], ["", "def", "test_ifft2_cplx_tensors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test ifft2 with PyTorch>=1.7 complex tensor support.\"\"\"", "\n", "g", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "1", ")", "\n", "x", "=", "torch", ".", "rand", "(", "4", ",", "3", ",", "3", ",", "8", ",", "2", ",", "generator", "=", "g", ")", "# B x H x W x #coils x 2", "\n", "\n", "X", "=", "oF", ".", "fft2c", "(", "x", ")", "\n", "X2", "=", "torch", ".", "view_as_complex", "(", "X", ")", "# B x H x W x #coils", "\n", "\n", "xhat", "=", "oF", ".", "ifft2c", "(", "X", ")", "\n", "xhat2", "=", "oF", ".", "ifft2c", "(", "X2", ")", "\n", "assert", "torch", ".", "allclose", "(", "torch", ".", "view_as_real", "(", "xhat2", ")", ",", "xhat", ")", "\n", "# torch.allclose causes some issues with the comparison below", "\n", "# on certain machines. However, the maximum deviation between", "\n", "# the two tensors is the same across machines where torch.allclose", "\n", "# works and doesn't work. We compare the maximum of the difference", "\n", "# instead to get around this issue.", "\n", "assert", "torch", ".", "max", "(", "x", "-", "xhat", ")", "<", "5e-7", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_complex.test_complex_realview": [[10, 43], ["pytest.mark.skipif", "torch.randn", "torch.randn", "torch.allclose", "torch.allclose", "torch.allclose", "torch.allclose", "torch.allclose", "torch.randn", "torch.view_as_real", "torch.polar", "torch.allclose", "torch.allclose", "torch.allclose", "torch.view_as_real", "torch.view_as_real", "meddlr.is_complex", "meddlr.is_complex", "meddlr.is_complex_as_real", "meddlr.is_complex_as_real", "meddlr.conj", "torch.view_as_complex", "meddlr.mul", "torch.view_as_complex", "meddlr.abs", "meddlr.abs", "meddlr.real", "meddlr.real", "meddlr.imag", "meddlr.imag", "torch.abs", "torch.angle", "meddlr.polar", "meddlr.polar", "torch.view_as_real", "util.cplx_tensor_support", "torch.allclose", "meddlr.utils.env.supports_cplx_tensor", "meddlr.conj", "meddlr.mul", "torch.manual_seed", "torch.polar", "meddlr.polar", "torch.view_as_real", "torch.polar"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.imag", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.imag", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.angle", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_cplx_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul"], ["@", "pytest", ".", "mark", ".", "skipif", "(", "not", "env", ".", "supports_cplx_tensor", "(", ")", ",", "reason", "=", "\"Complex tensors not supported\"", ")", "\n", "def", "test_complex_realview", "(", ")", ":", "\n", "    ", "x", "=", "torch", ".", "randn", "(", "5", ",", "10", ",", "10", ",", "dtype", "=", "torch", ".", "complex64", ")", "\n", "y", "=", "torch", ".", "randn", "(", "5", ",", "10", ",", "10", ",", "dtype", "=", "torch", ".", "complex64", ")", "\n", "x_real", ",", "y_real", "=", "torch", ".", "view_as_real", "(", "x", ")", ",", "torch", ".", "view_as_real", "(", "y", ")", "\n", "\n", "assert", "cplx", ".", "is_complex", "(", "x", ")", "and", "cplx", ".", "is_complex", "(", "y", ")", "\n", "assert", "cplx", ".", "is_complex_as_real", "(", "x_real", ")", "and", "cplx", ".", "is_complex_as_real", "(", "y_real", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "cplx", ".", "conj", "(", "x", ")", ",", "torch", ".", "view_as_complex", "(", "cplx", ".", "conj", "(", "x_real", ")", ")", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "cplx", ".", "mul", "(", "x", ",", "y", ")", ",", "torch", ".", "view_as_complex", "(", "cplx", ".", "mul", "(", "x_real", ",", "y_real", ")", ")", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "cplx", ".", "abs", "(", "x", ")", ",", "cplx", ".", "abs", "(", "x_real", ")", ")", "\n", "\n", "# assert torch.allclose(cplx.angle(x), cplx.angle(x_real, eps=0))", "\n", "\n", "assert", "torch", ".", "allclose", "(", "cplx", ".", "real", "(", "x", ")", ",", "cplx", ".", "real", "(", "x_real", ")", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "cplx", ".", "imag", "(", "x", ")", ",", "cplx", ".", "imag", "(", "x_real", ")", ")", "\n", "\n", "x", "=", "torch", ".", "randn", "(", "5", ",", "10", ",", "10", ",", "dtype", "=", "torch", ".", "complex64", ",", "generator", "=", "torch", ".", "manual_seed", "(", "0", ")", ")", "\n", "x_real", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "mag", ",", "angle", "=", "torch", ".", "abs", "(", "x", ")", ",", "torch", ".", "angle", "(", "x", ")", "\n", "torch_polar", "=", "torch", ".", "polar", "(", "mag", ",", "angle", ")", "\n", "assert", "torch", ".", "allclose", "(", "torch_polar", ",", "x", ")", "\n", "assert", "torch", ".", "allclose", "(", "cplx", ".", "polar", "(", "mag", ",", "angle", ",", "return_cplx", "=", "True", ")", ",", "x", ")", "\n", "assert", "torch", ".", "allclose", "(", "\n", "cplx", ".", "polar", "(", "mag", ",", "angle", ",", "return_cplx", "=", "False", ")", ",", "torch", ".", "view_as_real", "(", "torch", ".", "polar", "(", "mag", ",", "angle", ")", ")", "\n", ")", "\n", "with", "util", ".", "cplx_tensor_support", "(", "False", ")", ":", "\n", "        ", "assert", "torch", ".", "allclose", "(", "\n", "cplx", ".", "polar", "(", "mag", ",", "angle", ",", "return_cplx", "=", "False", ")", ",", "torch", ".", "view_as_real", "(", "torch", ".", "polar", "(", "mag", ",", "angle", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_categorical.test_categorical_to_one_hot": [[9, 46], ["pytest.mark.parametrize", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "meddlr.ops.categorical.categorical_to_one_hot", "all_func", "meddlr.ops.categorical.categorical_to_one_hot", "all_func", "meddlr.ops.categorical.categorical_to_one_hot", "all_func", "labels.numpy.numpy", "expected.numpy.numpy", "meddlr.ops.categorical.categorical_to_one_hot", "all_func"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.categorical_to_one_hot", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.categorical_to_one_hot", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.categorical_to_one_hot", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.categorical_to_one_hot"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"use_numpy\"", ",", "[", "False", ",", "True", "]", ")", "\n", "def", "test_categorical_to_one_hot", "(", "use_numpy", ")", ":", "\n", "    ", "labels", "=", "torch", ".", "tensor", "(", "[", "3", ",", "0", ",", "1", ",", "0", ",", "2", ",", "0", ",", "0", ",", "3", "]", ")", "\n", "expected", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "if", "use_numpy", ":", "\n", "        ", "labels", "=", "labels", ".", "numpy", "(", ")", "\n", "expected", "=", "expected", ".", "numpy", "(", ")", "\n", "all_func", "=", "np", ".", "all", "\n", "", "else", ":", "\n", "        ", "all_func", "=", "torch", ".", "all", "\n", "dtype", "=", "torch", ".", "int64", "\n", "\n", "", "out", "=", "categorical_to_one_hot", "(", "labels", ",", "channel_dim", "=", "-", "1", ",", "background", "=", "None", ")", "\n", "assert", "all_func", "(", "out", "==", "expected", ")", "\n", "\n", "out", "=", "categorical_to_one_hot", "(", "labels", ",", "channel_dim", "=", "-", "1", ",", "background", "=", "0", ")", "\n", "assert", "all_func", "(", "out", "==", "expected", "[", ":", ",", "1", ":", "]", ")", "\n", "\n", "out", "=", "categorical_to_one_hot", "(", "labels", ",", "channel_dim", "=", "-", "1", ",", "background", "=", "None", ",", "num_categories", "=", "3", ")", "\n", "assert", "all_func", "(", "out", "==", "expected", ")", "\n", "\n", "if", "not", "use_numpy", ":", "\n", "        ", "out", "=", "categorical_to_one_hot", "(", "labels", ".", "T", ",", "channel_dim", "=", "0", ",", "background", "=", "0", ",", "dtype", "=", "dtype", ")", "\n", "assert", "out", ".", "dtype", "==", "dtype", "\n", "assert", "all_func", "(", "out", ".", "T", "==", "expected", "[", ":", ",", "1", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_categorical.test_one_hot_to_categorical": [[48, 76], ["pytest.mark.parametrize", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "meddlr.ops.categorical.one_hot_to_categorical", "all_func", "meddlr.ops.categorical.one_hot_to_categorical", "all_func", "one_hot.numpy.numpy", "expected.numpy.numpy"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.one_hot_to_categorical", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.one_hot_to_categorical"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"use_numpy\"", ",", "[", "False", ",", "True", "]", ")", "\n", "def", "test_one_hot_to_categorical", "(", "use_numpy", ")", ":", "\n", "    ", "one_hot", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "]", "\n", ")", "\n", "expected", "=", "torch", ".", "tensor", "(", "[", "3", ",", "0", ",", "1", ",", "0", ",", "2", ",", "0", ",", "0", ",", "3", "]", ")", "\n", "\n", "if", "use_numpy", ":", "\n", "        ", "one_hot", "=", "one_hot", ".", "numpy", "(", ")", "\n", "expected", "=", "expected", ".", "numpy", "(", ")", "\n", "all_func", "=", "np", ".", "all", "\n", "", "else", ":", "\n", "        ", "all_func", "=", "torch", ".", "all", "\n", "\n", "", "out", "=", "one_hot_to_categorical", "(", "one_hot", ",", "channel_dim", "=", "-", "1", ",", "background", "=", "None", ")", "\n", "assert", "all_func", "(", "out", "==", "expected", "+", "1", ")", "\n", "\n", "out", "=", "one_hot_to_categorical", "(", "one_hot", ",", "channel_dim", "=", "-", "1", ",", "background", "=", "0", ")", "\n", "assert", "all_func", "(", "out", "==", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_categorical.test_logits_to_prob": [[78, 96], ["pytest.mark.parametrize", "torch.randn", "torch.randn", "torch.sigmoid", "torch.sigmoid", "torch.softmax", "all_func", "all_func", "logits.numpy.numpy", "sigmoid.numpy.numpy", "softmax.numpy.numpy", "pytest.raises", "meddlr.ops.categorical.logits_to_prob", "meddlr.ops.categorical.logits_to_prob", "meddlr.ops.categorical.logits_to_prob"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.logits_to_prob", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.logits_to_prob", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.logits_to_prob"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"use_numpy\"", ",", "[", "False", ",", "True", "]", ")", "\n", "def", "test_logits_to_prob", "(", "use_numpy", ")", ":", "\n", "    ", "logits", "=", "torch", ".", "randn", "(", "10", ",", "4", ")", "\n", "sigmoid", "=", "torch", ".", "sigmoid", "(", "logits", ")", "\n", "softmax", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "1", ")", "\n", "\n", "if", "use_numpy", ":", "\n", "        ", "logits", "=", "logits", ".", "numpy", "(", ")", "\n", "sigmoid", "=", "sigmoid", ".", "numpy", "(", ")", "\n", "softmax", "=", "softmax", ".", "numpy", "(", ")", "\n", "all_func", "=", "np", ".", "all", "\n", "", "else", ":", "\n", "        ", "all_func", "=", "torch", ".", "all", "\n", "\n", "", "assert", "all_func", "(", "logits_to_prob", "(", "logits", ",", "\"sigmoid\"", ")", "==", "sigmoid", ")", "\n", "assert", "all_func", "(", "logits_to_prob", "(", "logits", ",", "\"softmax\"", ")", "==", "softmax", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "logits_to_prob", "(", "logits", ",", "\"invalid\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_utils.test_zero_pad": [[7, 27], ["pytest.mark.parametrize", "pytest.mark.parametrize", "len", "torch.randn", "meddlr.ops.utils.zero_pad().squeeze", "enumerate", "zip", "torch.all", "zip", "torch.all", "torch.all", "sl.append", "meddlr.ops.utils.zero_pad", "slice", "torch.randn.unsqueeze", "torch.index_select", "torch.index_select", "torch.arange", "torch.arange", "tuple"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.zero_pad"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"out_shape\"", ",", "[", "(", "40", ",", "40", ")", ",", "(", "40", ",", "50", ")", ",", "(", "40", ",", "50", ",", "60", ")", ",", "(", "40", ",", "41", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"dtype\"", ",", "[", "torch", ".", "float32", ",", "torch", ".", "complex64", "]", ")", "\n", "def", "test_zero_pad", "(", "out_shape", ",", "dtype", ")", ":", "\n", "    ", "ndim", "=", "len", "(", "out_shape", ")", "\n", "\n", "in_shape", "=", "(", "10", ",", ")", "*", "ndim", "# (B, ...)", "\n", "x", "=", "torch", ".", "randn", "(", "*", "in_shape", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "zero_pad", "(", "x", ".", "unsqueeze", "(", "0", ")", ",", "out_shape", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "assert", "out", ".", "shape", "==", "out_shape", "\n", "assert", "out", ".", "dtype", "==", "dtype", "\n", "\n", "for", "dim", ",", "(", "i", ",", "o", ")", "in", "enumerate", "(", "zip", "(", "in_shape", ",", "out_shape", ")", ")", ":", "\n", "        ", "assert", "torch", ".", "all", "(", "torch", ".", "index_select", "(", "out", ",", "dim", ",", "torch", ".", "arange", "(", "0", ",", "(", "o", "-", "i", ")", "//", "2", ")", ")", "==", "0", ")", "\n", "assert", "torch", ".", "all", "(", "torch", ".", "index_select", "(", "out", ",", "dim", ",", "torch", ".", "arange", "(", "(", "o", "-", "i", ")", "//", "2", "+", "i", ",", "o", ")", ")", "==", "0", ")", "\n", "\n", "", "sl", "=", "[", "]", "\n", "for", "i", ",", "o", "in", "zip", "(", "in_shape", ",", "out_shape", ")", ":", "\n", "        ", "sl", ".", "append", "(", "slice", "(", "(", "o", "-", "i", ")", "//", "2", ",", "(", "o", "-", "i", ")", "//", "2", "+", "i", ")", ")", "\n", "", "assert", "torch", ".", "all", "(", "out", "[", "tuple", "(", "sl", ")", "]", "==", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_utils.test_zero_pad_mismatched_dims": [[29, 36], ["torch.randn", "meddlr.ops.utils.zero_pad().squeeze", "meddlr.ops.utils.zero_pad", "torch.randn.unsqueeze"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.zero_pad"], ["", "def", "test_zero_pad_mismatched_dims", "(", ")", ":", "\n", "    ", "in_shape", "=", "(", "10", ",", "10", ",", "3", ")", "\n", "out_shape", "=", "(", "20", ",", "30", ")", "\n", "\n", "x", "=", "torch", ".", "randn", "(", "*", "in_shape", ")", "\n", "out", "=", "zero_pad", "(", "x", ".", "unsqueeze", "(", "0", ")", ",", "out_shape", ")", ".", "squeeze", "(", "0", ")", "\n", "assert", "out", ".", "shape", "==", "(", "20", ",", "30", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.ops.test_utils.test_center_crop": [[38, 57], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "tuple", "torch.randn", "meddlr.ops.utils.center_crop", "tuple", "torch.all", "x.squeeze.unsqueeze", "x.squeeze.squeeze", "out.squeeze.squeeze", "slice", "zip"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.center_crop"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"out_shape\"", ",", "[", "(", "40", ",", "40", ")", ",", "(", "40", ",", "50", ")", ",", "(", "40", ",", "50", ",", "60", ")", ",", "(", "40", ",", "41", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"dtype\"", ",", "[", "torch", ".", "float32", ",", "torch", ".", "complex64", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"include_batch\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_center_crop", "(", "out_shape", ",", "dtype", ",", "include_batch", ")", ":", "\n", "    ", "in_shape", "=", "tuple", "(", "d", "*", "2", "for", "d", "in", "out_shape", ")", "\n", "x", "=", "torch", ".", "randn", "(", "*", "in_shape", ",", "dtype", "=", "dtype", ")", "\n", "\n", "if", "not", "include_batch", ":", "\n", "        ", "x", "=", "x", ".", "unsqueeze", "(", "0", ")", "\n", "", "out", "=", "center_crop", "(", "x", ",", "out_shape", ",", "include_batch", "=", "include_batch", ")", "\n", "if", "not", "include_batch", ":", "\n", "        ", "assert", "out", ".", "shape", "==", "(", "1", ",", ")", "+", "out_shape", "\n", "x", "=", "x", ".", "squeeze", "(", "0", ")", "\n", "out", "=", "out", ".", "squeeze", "(", "0", ")", "\n", "\n", "", "assert", "out", ".", "shape", "==", "out_shape", "\n", "sl", "=", "tuple", "(", "[", "slice", "(", "(", "i", "-", "o", ")", "//", "2", ",", "(", "i", "-", "o", ")", "//", "2", "+", "o", ")", "for", "i", ",", "o", "in", "zip", "(", "in_shape", ",", "out_shape", ")", "]", ")", "\n", "assert", "out", ".", "shape", "==", "x", "[", "sl", "]", ".", "shape", "\n", "assert", "torch", ".", "all", "(", "out", "==", "x", "[", "sl", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.forward.mri.SenseModel.__init__": [[28, 42], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "maps", ":", "torch", ".", "Tensor", ",", "weights", ":", "torch", ".", "Tensor", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            maps (torch.Tensor): Sensitivity maps.\n            weights (torch.Tensor): Undersampling masks.\n                If ``None``, it is assumed that inputs are fully-sampled.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "maps", "=", "maps", "\n", "if", "weights", "is", "None", ":", "\n", "            ", "self", ".", "weights", "=", "1.0", "\n", "", "else", ":", "\n", "            ", "self", ".", "weights", "=", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.forward.mri.SenseModel._adjoint_op": [[43, 63], ["meddlr.ifft2c", "meddlr.ifft2c", "meddlr.is_complex_as_real", "meddlr.is_complex_as_real", "meddlr.mul", "meddlr.mul", "image.unsqueeze.unsqueeze.sum", "meddlr.mul", "meddlr.mul", "image.unsqueeze.unsqueeze.sum", "image.unsqueeze.unsqueeze.unsqueeze", "meddlr.conj", "meddlr.conj", "image.unsqueeze.unsqueeze.unsqueeze", "meddlr.conj", "meddlr.conj"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.conj"], ["", "", "def", "_adjoint_op", "(", "self", ",", "kspace", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            kspace: Shape (B,H,W,#coils,[2])\n        Returns:\n            image: Shape (B,H,W,#maps,[2])\n        \"\"\"", "\n", "image", "=", "oF", ".", "ifft2c", "(", "self", ".", "weights", "*", "kspace", ",", "channels_last", "=", "True", ")", "\n", "if", "cplx", ".", "is_complex_as_real", "(", "kspace", ")", ":", "\n", "            ", "image", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "2", ")", ",", "cplx", ".", "conj", "(", "self", ".", "maps", ")", ")", "# [B,...,#coils,#maps,2]", "\n", "return", "image", ".", "sum", "(", "-", "3", ")", "\n", "", "else", ":", "\n", "# This is a hacky solution managing multi-channel inputs.", "\n", "# Note multi-channel inputs are only supported in complex tensors.", "\n", "# TODO (arjundd, issue #18): Fix with tensor ordering.", "\n", "            ", "if", "image", ".", "ndim", "!=", "self", ".", "maps", ".", "ndim", ":", "\n", "                ", "image", "=", "image", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "", "image", "=", "cplx", ".", "mul", "(", "image", ",", "cplx", ".", "conj", "(", "self", ".", "maps", ")", ")", "# [B,...,#coils,#maps,1]", "\n", "return", "image", ".", "sum", "(", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.forward.mri.SenseModel._forward_op": [[64, 84], ["meddlr.is_complex_as_real", "meddlr.is_complex_as_real", "meddlr.mul", "meddlr.mul", "meddlr.mul", "meddlr.mul", "image.unsqueeze", "meddlr.fft2c", "meddlr.fft2c", "image.unsqueeze", "kspace.sum.sum.sum", "meddlr.fft2c", "meddlr.fft2c", "kspace.sum.sum.sum"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.mul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fft2c"], ["", "", "def", "_forward_op", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image: Shape (B,H,W,#maps,[2])\n        Returns:\n            kspace: Shape (B,H,W,#coils,[2])\n        \"\"\"", "\n", "if", "cplx", ".", "is_complex_as_real", "(", "image", ")", ":", "\n", "            ", "kspace", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "3", ")", ",", "self", ".", "maps", ")", "# [B,...,1,#maps,2]", "\n", "kspace", "=", "self", ".", "weights", "*", "oF", ".", "fft2c", "(", "kspace", ".", "sum", "(", "-", "2", ")", ",", "channels_last", "=", "True", ")", "# [B,...,#coils,2]", "\n", "", "else", ":", "\n", "            ", "kspace", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "2", ")", ",", "self", ".", "maps", ")", "\n", "# This is a hacky solution managing multi-channel inputs.", "\n", "# Note this change means that multiple maps with multi-channel inputs", "\n", "# is not supported for forward operations. This will change in future updates.", "\n", "# TODO (arjundd, issue #18): Fix with tensor ordering.", "\n", "if", "image", ".", "shape", "[", "-", "1", "]", "==", "self", ".", "maps", ".", "shape", "[", "-", "1", "]", ":", "\n", "                ", "kspace", "=", "kspace", ".", "sum", "(", "-", "1", ")", "\n", "", "kspace", "=", "self", ".", "weights", "*", "oF", ".", "fft2c", "(", "kspace", ",", "channels_last", "=", "True", ")", "\n", "", "return", "kspace", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.forward.mri.SenseModel.forward": [[85, 106], ["mri.SenseModel._adjoint_op", "mri.SenseModel._forward_op"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.forward.mri.SenseModel._adjoint_op", "home.repos.pwc.inspect_result.ad12_meddlr.forward.mri.SenseModel._forward_op"], ["", "def", "forward", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ",", "adjoint", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Run forward or adjoint SENSE operation on the input.\n\n        Depending on if ``adjoint=True``, the input should either be the\n        k-space or the complex image. The shapes for these are as follows:\n            - kspace: ``(B, H, W, #coils, [2])\n            - image: ``(B, H, W, #maps, [2])``\n\n        Args:\n            input (torch.Tensor): If ``adjoint=True``, this is the multi-coil k-space,\n                else it is the image.\n            adjoint (bool, optional): If ``True``, use adjoint operation.\n\n        Returns:\n            torch.Tensor: If ``adjoint=True``, the image, else multi-coil k-space.\n        \"\"\"", "\n", "if", "adjoint", ":", "\n", "            ", "output", "=", "self", ".", "_adjoint_op", "(", "input", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "self", ".", "_forward_op", "(", "input", ")", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.forward.test_mri.TestSenseModel.test_reproducibility": [[12, 52], ["unittest.skipIf", "torch.view_as_complex", "meddlr.SenseModel", "meddlr.SenseModel", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel", "meddlr.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "torch.allclose", "torch.allclose", "meddlr.get_mask", "meddlr.get_mask", "meddlr.SenseModel", "meddlr.SenseModel", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel", "meddlr.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "torch.allclose", "torch.allclose", "torch.view_as_real", "torch.view_as_real", "meddlr.SenseModel", "meddlr.SenseModel", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel", "meddlr.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "torch.allclose", "torch.allclose", "torch.view_as_complex", "torch.randn", "meddlr.rss().unsqueeze", "meddlr.rss().unsqueeze", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.SenseModel.", "meddlr.utils.env.pt_version", "meddlr.utils.env.pt_version", "torch.randn", "meddlr.rss", "meddlr.rss"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.pt_version", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.rss", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.rss"], ["    ", "@", "unittest", ".", "skipIf", "(", "env", ".", "pt_version", "(", ")", ">=", "[", "1", ",", "8", "]", ",", "\"Old SENSE model requires torch.fft module\"", ")", "\n", "def", "test_reproducibility", "(", "self", ")", ":", "\n", "        ", "ky", "=", "20", "\n", "kz", "=", "20", "\n", "nc", "=", "8", "\n", "nm", "=", "5", "\n", "bsz", "=", "8", "\n", "scale", "=", "1.0", "\n", "\n", "# Complex tensor.", "\n", "kspace", "=", "torch", ".", "view_as_complex", "(", "torch", ".", "randn", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "2", ")", ")", "*", "scale", "\n", "maps", "=", "torch", ".", "view_as_complex", "(", "torch", ".", "randn", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "nm", ",", "2", ")", ")", "\n", "maps", "=", "maps", "/", "cplx", ".", "rss", "(", "maps", ",", "dim", "=", "-", "2", ")", ".", "unsqueeze", "(", "-", "2", ")", "\n", "\n", "A", "=", "T", ".", "SenseModel", "(", "maps", ")", "\n", "A_new", "=", "SenseModel", "(", "maps", ")", "\n", "expected", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "out", "=", "A_new", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "expected", ")", "\n", "assert", "torch", ".", "allclose", "(", "A_new", "(", "out", ",", "adjoint", "=", "False", ")", ",", "A", "(", "expected", ",", "adjoint", "=", "False", ")", ")", "\n", "\n", "# With mask.", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "kspace", ")", "\n", "A", "=", "T", ".", "SenseModel", "(", "maps", ",", "weights", "=", "mask", ")", "\n", "A_new", "=", "SenseModel", "(", "maps", ",", "weights", "=", "mask", ")", "\n", "expected", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "out", "=", "A_new", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "expected", ")", "\n", "assert", "torch", ".", "allclose", "(", "A_new", "(", "out", ",", "adjoint", "=", "False", ")", ",", "A", "(", "expected", ",", "adjoint", "=", "False", ")", ")", "\n", "\n", "# Complex tensor as real view.", "\n", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "maps", "=", "torch", ".", "view_as_real", "(", "maps", ")", "\n", "\n", "A", "=", "T", ".", "SenseModel", "(", "maps", ")", "\n", "A_new", "=", "SenseModel", "(", "maps", ")", "\n", "expected", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "out", "=", "A_new", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "expected", ")", "\n", "assert", "torch", ".", "allclose", "(", "A_new", "(", "out", ",", "adjoint", "=", "False", ")", ",", "A", "(", "expected", ",", "adjoint", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.forward.test_mri.TestSenseModel.test_multichannel": [[53, 82], ["torch.randn", "torch.rand", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel", "range", "torch.cat", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "torch.allclose", "range", "torch.stack", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "torch.allclose", "meddlr.rss().unsqueeze", "meddlr.rss().unsqueeze", "torch.stack.append", "torch.stack.append", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.forward.SenseModel.", "meddlr.rss", "meddlr.rss"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.rss", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.rss"], ["", "def", "test_multichannel", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test multi-channel inputs.\"\"\"", "\n", "ky", "=", "20", "\n", "kz", "=", "20", "\n", "nc", "=", "8", "\n", "num_channels", "=", "3", "\n", "nm", "=", "1", "\n", "bsz", "=", "5", "\n", "\n", "kspace", "=", "torch", ".", "randn", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "num_channels", ",", "dtype", "=", "torch", ".", "complex64", ")", "\n", "maps", "=", "torch", ".", "rand", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "nm", ",", "dtype", "=", "torch", ".", "complex64", ")", "\n", "maps", "=", "maps", "/", "cplx", ".", "rss", "(", "maps", ",", "dim", "=", "-", "2", ")", ".", "unsqueeze", "(", "-", "2", ")", "\n", "\n", "A", "=", "SenseModel", "(", "maps", ")", "\n", "\n", "expected", "=", "[", "]", "\n", "for", "c", "in", "range", "(", "num_channels", ")", ":", "\n", "            ", "expected", ".", "append", "(", "A", "(", "kspace", "[", "...", ",", "c", "]", ",", "adjoint", "=", "True", ")", ")", "\n", "", "expected", "=", "torch", ".", "cat", "(", "expected", ",", "dim", "=", "-", "1", ")", "\n", "out_image", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "out_image", ",", "expected", ",", "atol", "=", "1e-5", ")", "\n", "\n", "expected", "=", "[", "]", "\n", "for", "c", "in", "range", "(", "num_channels", ")", ":", "\n", "            ", "expected", ".", "append", "(", "A", "(", "out_image", "[", "...", ",", "c", ":", "c", "+", "1", "]", ",", "adjoint", "=", "False", ")", ")", "\n", "", "expected", "=", "torch", ".", "stack", "(", "expected", ",", "dim", "=", "-", "1", ")", "\n", "out_kspace", "=", "A", "(", "out_image", ",", "adjoint", "=", "False", ")", "\n", "# both clauses required for CI to pass on python 3.7 - torch.allclose does not work", "\n", "assert", "torch", ".", "allclose", "(", "out_kspace", ",", "expected", ",", "atol", "=", "1e-5", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.default_argument_parser": [[31, 69], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["_C", ".", "MODEL", ".", "META_ARCHITECTURE", "=", "\"GeneralizedUnrolledCNN\"", "\n", "_C", ".", "MODEL", ".", "WEIGHTS", "=", "\"\"", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Unrolled model - TODO: Deprecate", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "UNROLLED", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "BLOCK_ARCHITECTURE", "=", "\"ResNet\"", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "NUM_UNROLLED_STEPS", "=", "5", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "NUM_RESBLOCKS", "=", "2", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "NUM_FEATURES", "=", "256", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "DROPOUT", "=", "0.0", "\n", "# Padding options. \"\" for now. TODO: add \"circular\"", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "PADDING", "=", "\"\"", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "STEP_SIZES", "=", "(", "-", "2.0", ",", ")", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "FIX_STEP_SIZE", "=", "False", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "SHARE_WEIGHTS", "=", "False", "\n", "# Kernel size", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "KERNEL_SIZE", "=", "(", "3", ",", ")", "\n", "# Number of ESPIRiT maps", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "NUM_EMAPS", "=", "1", "\n", "\n", "# Conv block parameters", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", "=", "CN", "(", ")", "\n", "# Either \"relu\" or \"leaky_relu\"", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", ".", "ACTIVATION", "=", "\"relu\"", "\n", "# Either \"none\", \"instance\", or \"batch\"", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", ".", "NORM", "=", "\"none\"", "\n", "# Use affine on norm", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", ".", "NORM_AFFINE", "=", "False", "\n", "_C", ".", "MODEL", ".", "UNROLLED", ".", "CONV_BLOCK", ".", "ORDER", "=", "(", "\"norm\"", ",", "\"act\"", ",", "\"drop\"", ",", "\"conv\"", ")", "\n", "\n", "_C", ".", "MODEL", ".", "RECON_LOSS", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "RECON_LOSS", ".", "NAME", "=", "\"l1\"", "\n", "_C", ".", "MODEL", ".", "RECON_LOSS", ".", "RENORMALIZE_DATA", "=", "True", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "USE_LATENT", "=", "False", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "USE_CONSISTENCY", "=", "True", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "LATENT_LOSS_NAME", "=", "\"mag_l1\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.default_setup": [[71, 182], ["cfg.defrost", "cfg.format_fields", "cfg.freeze", "cfg.defrost", "_PATH_MANAGER.get_local_path", "cfg.freeze", "meddlr.utils.logger.setup_logger", "meddlr.utils.logger.setup_logger", "meddlr.utils.logger.setup_logger.info", "meddlr.utils.logger.setup_logger.info", "meddlr.utils.logger.setup_logger.info", "meddlr.utils.env.seed_all_rng", "meddlr.utils.env.is_repro", "meddlr.utils.env.is_repro", "hasattr", "hasattr", "_PATH_MANAGER.get_local_path", "bool", "defaults._get_next_experiment_version", "cfg.defrost", "os.path.join", "cfg.freeze", "defaults.init_reproducible_mode", "_PATH_MANAGER.mkdirs", "meddlr.utils.logger.setup_logger.info", "meddlr.utils.logger.setup_logger.info", "hasattr", "meddlr.utils.logger.setup_logger.info", "os.path.join", "meddlr.utils.logger.setup_logger.info", "hasattr", "os.path.join", "meddlr.utils.collect_env.collect_env_info", "str", "meddlr.utils.env.get_available_gpus", "torch.cuda.set_device", "_PATH_MANAGER.open", "f.write", "_PATH_MANAGER.open().read", "isinstance", "len", "ValueError", "cfg.dump", "os.path.abspath", "str", "_PATH_MANAGER.open"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.format_fields", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.setup_logger", "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.setup_logger", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.seed_all_rng", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_repro", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_repro", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults._get_next_experiment_version", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.init_reproducible_mode", "home.repos.pwc.inspect_result.ad12_meddlr.utils.collect_env.collect_env_info", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_available_gpus", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.read", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.dump", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["_C", ".", "MODEL", ".", "CONSISTENCY", ".", "LOSS_NAME", "=", "\"l1\"", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "LOSS_WEIGHT", "=", "0.1", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "LATENT_LOSS_WEIGHT", "=", "0.1", "\n", "# Consistency Augmentations", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "MOTION", "=", "CN", "(", ")", "\n", "# Noise standard deviation - 1,5,8 used for 3D FSE in Lustig paper.", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", ".", "STD_DEV", "=", "(", "1", ",", ")", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "MOTION", ".", "RANGE", "=", "(", "0.2", ",", "0.5", ")", "\n", "\n", "# Noise scheduler", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", ".", "SCHEDULER", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", ".", "SCHEDULER", ".", "WARMUP_METHOD", "=", "\"\"", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", ".", "SCHEDULER", ".", "WARMUP_ITERS", "=", "0", "\n", "# Noise masking", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", ".", "MASK", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", ".", "MASK", ".", "RHO", "=", "1.0", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "MRI_RECON", "=", "_MRI_RECON_TFM", ".", "clone", "(", ")", "\n", "\n", "# Motion scheduler", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "MOTION", ".", "SCHEDULER", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "MOTION", ".", "SCHEDULER", ".", "WARMUP_METHOD", "=", "\"\"", "\n", "_C", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "MOTION", ".", "SCHEDULER", ".", "WARMUP_ITERS", "=", "0", "\n", "\n", "# Image normalization options.", "\n", "# See meddlr/data/transforms/transform.py for more details.", "\n", "_C", ".", "MODEL", ".", "NORMALIZER", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "NORMALIZER", ".", "NAME", "=", "\"TopMagnitudeNormalizer\"", "\n", "# Keywords to normalize", "\n", "# See meddlr/data/transforms/transform.py for more details", "\n", "_C", ".", "MODEL", ".", "NORMALIZER", ".", "KEYWORDS", "=", "(", ")", "\n", "\n", "_C", ".", "MODEL", ".", "SEG", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "SEG", ".", "CLASSES", "=", "(", ")", "\n", "_C", ".", "MODEL", ".", "SEG", ".", "INCLUDE_BACKGROUND", "=", "False", "\n", "_C", ".", "MODEL", ".", "SEG", ".", "ACTIVATION", "=", "\"sigmoid\"", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# UNET model - shared by UNetModel and GeneralizedUNet modules", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "UNET", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "UNET", ".", "OUT_CHANNELS", "=", "2", "\n", "_C", ".", "MODEL", ".", "UNET", ".", "IN_CHANNELS", "=", "2", "\n", "_C", ".", "MODEL", ".", "UNET", ".", "CHANNELS", "=", "32", "\n", "_C", ".", "MODEL", ".", "UNET", ".", "NUM_POOL_LAYERS", "=", "4", "\n", "_C", ".", "MODEL", ".", "UNET", ".", "DROPOUT", "=", "0.0", "\n", "_C", ".", "MODEL", ".", "UNET", ".", "NORMALIZE", "=", "False", "\n", "# BLOCK_ORDER only applies to GeneralizedUNet", "\n", "_C", ".", "MODEL", ".", "UNET", ".", "BLOCK_ORDER", "=", "(", "\"conv\"", ",", "\"relu\"", ",", "\"conv\"", ",", "\"relu\"", ",", "\"batchnorm\"", ",", "\"dropout\"", ")", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Denoising model", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "DENOISING", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "DENOISING", ".", "META_ARCHITECTURE", "=", "\"GeneralizedUnrolledCNN\"", "\n", "_C", ".", "MODEL", ".", "DENOISING", ".", "NOISE", "=", "CN", "(", ")", "\n", "# Noise standard deviation to use for augmentations.", "\n", "_C", ".", "MODEL", ".", "DENOISING", ".", "NOISE", ".", "STD_DEV", "=", "(", "1", ",", ")", "\n", "# When fully sampled kspace is available, if True, perform denoising on the", "\n", "# fully sampled kspace. If False, denoising will be performed on the", "\n", "# randomly generated undersampled kspace.", "\n", "_C", ".", "MODEL", ".", "DENOISING", ".", "NOISE", ".", "USE_FULLY_SAMPLED_TARGET", "=", "True", "\n", "# Same as above, but at eval time (e.g. validation).", "\n", "# Defaults to MODEL.DENOISING.NOISE.USE_FULLY_SAMPLED_TARGET", "\n", "_C", ".", "MODEL", ".", "DENOISING", ".", "NOISE", ".", "USE_FULLY_SAMPLED_TARGET_EVAL", "=", "None", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Compressed Sensing (CS) model", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "CS", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "CS", ".", "REGULARIZATION", "=", "0.005", "\n", "_C", ".", "MODEL", ".", "CS", ".", "MAX_ITER", "=", "200", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Noise2Recon (N2R) model", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "N2R", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "N2R", ".", "META_ARCHITECTURE", "=", "\"GeneralizedUnrolledCNN\"", "\n", "_C", ".", "MODEL", ".", "N2R", ".", "USE_SUPERVISED_CONSISTENCY", "=", "False", "\n", "# Use MODEL.CONSISTENCY.AUG.NOISE.STD_DEV to control noise parameters.", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Motion2Recon (M2R) model", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "M2R", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "M2R", ".", "META_ARCHITECTURE", "=", "\"GeneralizedUnrolledCNN\"", "\n", "_C", ".", "MODEL", ".", "M2R", ".", "USE_SUPERVISED_CONSISTENCY", "=", "False", "\n", "# Use MODEL.CONSISTENCY.AUG.MOTION_RANGE to control motion parameters.", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# NoiseMotion2Recon (NM2R) model", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "NM2R", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "NM2R", ".", "META_ARCHITECTURE", "=", "\"GeneralizedUnrolledCNN\"", "\n", "_C", ".", "MODEL", ".", "NM2R", ".", "USE_SUPERVISED_CONSISTENCY", "=", "False", "\n", "# Use MODEL.CONSISTENCY.AUG.MOTION_RANGE to control motion parameters.", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Aug2Recon (A2R) / VORTEX model", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "A2R", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "A2R", ".", "META_ARCHITECTURE", "=", "\"GeneralizedUnrolledCNN\"", "\n", "_C", ".", "MODEL", ".", "A2R", ".", "USE_SUPERVISED_CONSISTENCY", "=", "False", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# SSDU model", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "MODEL", ".", "SSDU", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "SSDU", ".", "META_ARCHITECTURE", "=", "\"GeneralizedUnrolledCNN\"", "\n", "_C", ".", "MODEL", ".", "SSDU", ".", "MASKER", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "SSDU", ".", "MASKER", ".", "PARAMS", "=", "CN", "(", "new_allowed", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.find_wandb_exp_id": [[184, 212], ["os.path.join", "os.path.isfile", "os.path.join", "os.path.isdir", "open", "f.read", "len", "len", "[].split", "os.listdir", "os.path.isfile", "os.path.join", "os.path.splitext"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.read"], ["# -----------------------------------------------------------------------------", "\n", "# Dataset", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "DATASETS", "=", "CN", "(", ")", "\n", "# List of the dataset names for training. Must be registered in DatasetCatalog", "\n", "_C", ".", "DATASETS", ".", "TRAIN", "=", "(", ")", "\n", "# List of the dataset names for validation. Must be registered in DatasetCatalog", "\n", "_C", ".", "DATASETS", ".", "VAL", "=", "(", ")", "\n", "# List of the dataset names for testing. Must be registered in DatasetCatalog", "\n", "_C", ".", "DATASETS", ".", "TEST", "=", "(", ")", "\n", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# DataLoader", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "DATALOADER", "=", "CN", "(", ")", "\n", "# Number of data loading threads", "\n", "_C", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "4", "\n", "# Number of batches to prefetch per worker", "\n", "_C", ".", "DATALOADER", ".", "PREFETCH_FACTOR", "=", "2", "\n", "# If True, the dataloader will drop the last batch.", "\n", "_C", ".", "DATALOADER", ".", "DROP_LAST", "=", "True", "\n", "# Subsample training data to simulate data limited scenarios.", "\n", "_C", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", "=", "CN", "(", ")", "\n", "# Number of training examples to retain. All others will be force dropped", "\n", "# meaning they will not be used for any training, even w/ semi-supervised N2R", "\n", "# framework", "\n", "_C", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "NUM_TOTAL", "=", "-", "1", "\n", "# Number of training examples to retain based on metadata properties.", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.init_wandb_run": [[214, 302], ["os.environ.get", "dict", "wandb.util.generate_id", "wandb.init", "job_type.lower", "defaults.find_wandb_exp_id", "wandb.Api", "wandb.Api.run", "warnings.warn", "warnings.warn", "warnings.warn", "os.path.basename", "open", "f.write", "ValueError", "os.path.join"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.find_wandb_exp_id", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write"], ["# 15 AXT2 scans and 10 AXT1 scans where AXT2 and AXT1 are categories in the", "\n", "# \"acquisition\" metadata field.", "\n", "_C", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "NUM_TOTAL_BY_GROUP", "=", "(", ")", "\n", "# Number of scans out of total to undersample. If NUM_TOTAL is not -1, must be", "\n", "# less than NUM_TOTAL.", "\n", "_C", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "NUM_UNDERSAMPLED", "=", "0", "\n", "# Number of scans with ground truth for validation.", "\n", "_C", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "NUM_VAL", "=", "-", "1", "\n", "# Number of validation examples to retain based on metadata properties.", "\n", "_C", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "NUM_VAL_BY_GROUP", "=", "(", ")", "\n", "# Seed for shuffling data. Should always be deterministic", "\n", "_C", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "SEED", "=", "1000", "\n", "# Options: \"\" (defaults to random sampling), \"AlternatingSampler\"", "\n", "_C", ".", "DATALOADER", ".", "SAMPLER_TRAIN", "=", "\"\"", "\n", "# AlternatingSampler config parameters.", "\n", "_C", ".", "DATALOADER", ".", "ALT_SAMPLER", "=", "CN", "(", ")", "\n", "_C", ".", "DATALOADER", ".", "ALT_SAMPLER", ".", "PERIOD_SUPERVISED", "=", "1", "\n", "_C", ".", "DATALOADER", ".", "ALT_SAMPLER", ".", "PERIOD_UNSUPERVISED", "=", "1", "\n", "# GroupSampler config parameters.", "\n", "_C", ".", "DATALOADER", ".", "GROUP_SAMPLER", "=", "CN", "(", ")", "\n", "_C", ".", "DATALOADER", ".", "GROUP_SAMPLER", ".", "BATCH_BY", "=", "(", ")", "\n", "_C", ".", "DATALOADER", ".", "GROUP_SAMPLER", ".", "AS_BATCH_SAMPLER", "=", "False", "\n", "# Paired tuple of data keys and H5DF keys. Empty tuple will result in default keys being used.", "\n", "# e.g. ((\"target\", \"espirit_recon\"), (\"maps\", \"espirit_maps\"))", "\n", "# See data/slice_data.py for more information.", "\n", "_C", ".", "DATALOADER", ".", "DATA_KEYS", "=", "(", ")", "\n", "\n", "_C", ".", "DATALOADER", ".", "FILTER", "=", "CN", "(", ")", "\n", "# Paired tuple of key and values for filtering. Multiple values should be specified as tuple.", "\n", "# e.g. ((\"num_slices\", 30),) will only keep data with number of slices = 30", "\n", "# Field must appear in all dataset dicts.", "\n", "# Training, validation, and testing data is filtered by this field.", "\n", "_C", ".", "DATALOADER", ".", "FILTER", ".", "BY", "=", "(", ")", "\n", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Augmentations/Transforms", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "AUG_TRAIN", "=", "CN", "(", ")", "\n", "_C", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", "=", "CN", "(", ")", "\n", "_C", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", ".", "NAME", "=", "\"PoissonDiskMaskFunc\"", "\n", "_C", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", ".", "ACCELERATIONS", "=", "(", "6", ",", ")", "\n", "_C", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", ".", "CALIBRATION_SIZE", "=", "20", "\n", "_C", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", ".", "CENTER_FRACTIONS", "=", "(", ")", "\n", "_C", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", ".", "MAX_ATTEMPTS", "=", "30", "\n", "# Augment with noise. See MODEL.CONSISTENCY.AUG.NOISE for parameters.", "\n", "_C", ".", "AUG_TRAIN", ".", "USE_NOISE", "=", "False", "\n", "_C", ".", "AUG_TRAIN", ".", "USE_MOTION", "=", "False", "\n", "_C", ".", "AUG_TRAIN", ".", "NOISE_P", "=", "0.2", "\n", "_C", ".", "AUG_TRAIN", ".", "MOTION_P", "=", "0.2", "\n", "# Augmentations using MRIReconAugmentor pipeline.", "\n", "# If this is specified, it will be used in place of MOTION and NOISE", "\n", "# augmentation parameters above. If you would like to use those parameters", "\n", "# set AUG_TRAIN.MRI_RECON.TRANSFORMS=().", "\n", "# This augmentation pipeline will automatically be ignored at test time (for now).", "\n", "_C", ".", "AUG_TRAIN", ".", "MRI_RECON", "=", "_MRI_RECON_TFM", ".", "clone", "(", ")", "\n", "\n", "_C", ".", "AUG_TEST", "=", "CN", "(", ")", "\n", "_C", ".", "AUG_TEST", ".", "UNDERSAMPLE", "=", "CN", "(", ")", "\n", "_C", ".", "AUG_TEST", ".", "UNDERSAMPLE", ".", "ACCELERATIONS", "=", "(", "6", ",", ")", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Solver", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "SOLVER", "=", "CN", "(", ")", "\n", "\n", "_C", ".", "SOLVER", ".", "OPTIMIZER", "=", "\"Adam\"", "\n", "\n", "# See meddlr/solver/build.py for LR scheduler options", "\n", "_C", ".", "SOLVER", ".", "LR_SCHEDULER_NAME", "=", "\"WarmupMultiStepLR\"", "\n", "\n", "_C", ".", "SOLVER", ".", "MAX_ITER", "=", "20", "\n", "\n", "_C", ".", "SOLVER", ".", "BASE_LR", "=", "1e-4", "\n", "\n", "_C", ".", "SOLVER", ".", "MOMENTUM", "=", "0.9", "\n", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY", "=", "0.0001", "\n", "# The weight decay that's applied to parameters of normalization layers", "\n", "# (typically the affine transformation)", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY_NORM", "=", "0.0", "\n", "\n", "_C", ".", "SOLVER", ".", "GAMMA", "=", "0.1", "\n", "# The iteration number to decrease learning rate by GAMMA.", "\n", "_C", ".", "SOLVER", ".", "STEPS", "=", "(", "30000", ",", ")", "\n", "\n", "_C", ".", "SOLVER", ".", "WARMUP_FACTOR", "=", "1.0", "/", "1000", "\n", "_C", ".", "SOLVER", ".", "WARMUP_ITERS", "=", "1000", "\n", "_C", ".", "SOLVER", ".", "WARMUP_METHOD", "=", "\"linear\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.init_reproducible_mode": [[304, 349], ["cfg.clone", "cfg.defrost", "meddlr.utils.env.seed_all_rng", "defaults._set_all_seeds", "cfg.freeze"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.seed_all_rng", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults._set_all_seeds", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze"], ["_C", ".", "SOLVER", ".", "GRAD_ACCUM_ITERS", "=", "1", "\n", "\n", "# Save a checkpoint after every this number of iterations", "\n", "_C", ".", "SOLVER", ".", "CHECKPOINT_PERIOD", "=", "1", "\n", "\n", "# Number of images per batch across all machines.", "\n", "# If we have 16 GPUs and IMS_PER_BATCH = 32,", "\n", "# each GPU will see 2 images per batch.", "\n", "_C", ".", "SOLVER", ".", "TRAIN_BATCH_SIZE", "=", "16", "\n", "_C", ".", "SOLVER", ".", "TEST_BATCH_SIZE", "=", "16", "\n", "\n", "_C", ".", "SOLVER", ".", "BIAS_LR_FACTOR", "=", "1.0", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY_BIAS", "=", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Specific test options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "TEST", "=", "CN", "(", ")", "\n", "# The period over which to evaluate the model during training.", "\n", "# Set to 0 to disable.", "\n", "_C", ".", "TEST", ".", "EVAL_PERIOD", "=", "1", "\n", "# For end-to-end tests to verify the expected accuracy.", "\n", "# Each item is [task, metric, value, tolerance]", "\n", "# e.g.: [['bbox', 'AP', 38.5, 0.2]]", "\n", "_C", ".", "TEST", ".", "EXPECTED_RESULTS", "=", "[", "]", "\n", "# Validate with test-like functionality.", "\n", "# If True, undersampling masks for every validation scan will be fixed", "\n", "# given an acceleration.", "\n", "_C", ".", "TEST", ".", "VAL_AS_TEST", "=", "True", "\n", "# Validation metrics.", "\n", "_C", ".", "TEST", ".", "VAL_METRICS", "=", "CN", "(", ")", "\n", "_C", ".", "TEST", ".", "VAL_METRICS", ".", "RECON", "=", "(", ")", "\n", "# The period over which to flush evaluation results.", "\n", "# Specify if you are getting OOM errors during evaluation.", "\n", "# Set to 0 to disable.", "\n", "_C", ".", "TEST", ".", "FLUSH_PERIOD", "=", "0", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Misc options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Directory where output files are written", "\n", "_C", ".", "OUTPUT_DIR", "=", "\"\"", "\n", "# Set seed to negative to fully randomize everything.", "\n", "# Set seed to positive to use a fixed seed. Note that a fixed seed does not", "\n", "# guarantee fully deterministic behavior.", "\n", "_C", ".", "SEED", "=", "-", "1", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults._set_all_seeds": [[351, 357], ["cfg.items", "isinstance", "re.match", "isinstance", "cfg.__setattr__", "defaults._set_all_seeds"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.__setattr__", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults._set_all_seeds"], ["# Set to 0 to disable. Currently not functional.", "\n", "# This will always be in number of iterations.", "\n", "_C", ".", "VIS_PERIOD", "=", "0", "\n", "# The scale when referring to time generally in the config.", "\n", "# Note that there are certain fields, which are explicitly at the iteration", "\n", "# scale (e.g. GRAD_ACCUM_ITERS).", "\n", "# Either \"epoch\" or \"iter\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults._get_next_experiment_version": [[359, 375], ["_PATH_MANAGER.get_local_path", "os.path.isdir", "int", "max", "os.listdir", "x.startswith", "x.split"], "function", ["None"], ["_C", ".", "CUDNN_BENCHMARK", "=", "False", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Config Description", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "DESCRIPTION", "=", "CN", "(", ")", "\n", "# Brief description about config", "\n", "_C", ".", "DESCRIPTION", ".", "BRIEF", "=", "\"\"", "\n", "# The entity (team/individual) account for logging to Weights & Biases", "\n", "_C", ".", "DESCRIPTION", ".", "ENTITY_NAME", "=", "\"ss_recon\"", "\n", "# Project name for logging to Weights & Biases", "\n", "_C", ".", "DESCRIPTION", ".", "PROJECT_NAME", "=", "\"ss_recon\"", "\n", "# Experiment name for logging to Weights & Biases", "\n", "_C", ".", "DESCRIPTION", ".", "EXP_NAME", "=", "\"\"", "\n", "# Tags associated with experiment.", "\n", "# e.g. \"fastmri_knee_mc\" for fastMRI dataset; \"unrolled\" for using unrolled network; etc.", "\n", "_C", ".", "DESCRIPTION", ".", "TAGS", "=", "(", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.__init__": [[186, 237], ["logging.getLogger", "trainer.DefaultTrainer.build_train_loader", "trainer.convert_cfg_time_to_iter", "logging.getLogger.info", "trainer.DefaultTrainer.build_train_loader", "trainer.DefaultTrainer.build_model", "trainer.DefaultTrainer.build_optimizer", "len", "torch.nn.DataParallel.to", "trainer.DefaultTrainer.build_loss_computer", "meddlr.engine.SimpleTrainer.__init__", "trainer.DefaultTrainer.build_lr_scheduler", "meddlr.checkpoint.Checkpointer", "trainer.DefaultTrainer.register_hooks", "logging.getLogger.isEnabledFor", "meddlr.utils.logger.setup_logger", "len", "int", "math.ceil", "os.environ.get().split", "logging.getLogger.info", "torch.nn.DataParallel", "trainer.DefaultTrainer.build_hooks", "os.environ.get"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_train_loader", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.convert_cfg_time_to_iter", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_train_loader", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.solver.build.build_optimizer", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_loss_computer", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.solver.build.build_lr_scheduler", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.setup_logger", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_hooks", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n        \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "\"meddlr\"", ")", "\n", "if", "not", "logger", ".", "isEnabledFor", "(", "logging", ".", "INFO", ")", ":", "# setup_logger is not called for d2", "\n", "            ", "setup_logger", "(", ")", "\n", "\n", "# Assume these objects must be constructed in this order.", "\n", "", "data_loader", "=", "self", ".", "build_train_loader", "(", "cfg", ")", "\n", "num_iter_per_epoch", "=", "len", "(", "data_loader", ".", "dataset", ")", "/", "cfg", ".", "SOLVER", ".", "TRAIN_BATCH_SIZE", "\n", "if", "cfg", ".", "DATALOADER", ".", "DROP_LAST", ":", "\n", "            ", "num_iter_per_epoch", "=", "int", "(", "num_iter_per_epoch", ")", "\n", "", "else", ":", "\n", "            ", "num_iter_per_epoch", "=", "math", ".", "ceil", "(", "num_iter_per_epoch", ")", "\n", "", "cfg", "=", "convert_cfg_time_to_iter", "(", "cfg", ",", "num_iter_per_epoch", ")", "\n", "logger", ".", "info", "(", "f\"Calculated {num_iter_per_epoch} iterations per epoch\"", ")", "\n", "\n", "# Recreate data loader in case data loader required epoch -> iter conversion.", "\n", "del", "data_loader", "\n", "data_loader", "=", "self", ".", "build_train_loader", "(", "cfg", ")", "\n", "\n", "model", "=", "self", ".", "build_model", "(", "cfg", ")", "\n", "optimizer", "=", "self", ".", "build_optimizer", "(", "cfg", ",", "model", ")", "\n", "\n", "# For training, wrap with DP. But don't need this for inference.", "\n", "num_gpus", "=", "len", "(", "os", ".", "environ", ".", "get", "(", "\"CUDA_VISIBLE_DEVICES\"", ",", "\"\"", ")", ".", "split", "(", "\",\"", ")", ")", "\n", "if", "num_gpus", ">", "1", ":", "\n", "            ", "logger", ".", "info", "(", "\"Using data parallel...\"", ")", "\n", "model", "=", "DataParallel", "(", "model", ")", "\n", "", "model", ".", "to", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", "\n", "\n", "loss_computer", "=", "self", ".", "build_loss_computer", "(", "cfg", ")", "\n", "super", "(", ")", ".", "__init__", "(", "model", ",", "data_loader", ",", "optimizer", ",", "loss_computer", ")", "\n", "\n", "self", ".", "scheduler", "=", "self", ".", "build_lr_scheduler", "(", "cfg", ",", "optimizer", ")", "\n", "# Assume no other objects need to be checkpointed.", "\n", "# We can later make it checkpoint the stateful hooks", "\n", "self", ".", "checkpointer", "=", "Checkpointer", "(", "\n", "# Assume you want to save checkpoints together with logs/statistics", "\n", "model", ",", "\n", "cfg", ".", "OUTPUT_DIR", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "scheduler", "=", "self", ".", "scheduler", ",", "\n", ")", "\n", "self", ".", "start_iter", "=", "0", "\n", "self", ".", "max_iter", "=", "cfg", ".", "SOLVER", ".", "MAX_ITER", "\n", "self", ".", "cfg", "=", "cfg", "\n", "\n", "self", ".", "register_hooks", "(", "self", ".", "build_hooks", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.init_fine_tune": [[238, 255], ["logging.getLogger", "logging.getLogger.info", "meddlr.checkpoint.Checkpointer", "meddlr.checkpoint.Checkpointer.load", "os.path.isfile", "FileNotFoundError"], "methods", ["None"], ["", "def", "init_fine_tune", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Initialize model with fine-tune weights.\n\n        If fine tune weights not specified, results in no-op.\n        \"\"\"", "\n", "fine_tune_weights", "=", "self", ".", "cfg", ".", "MODEL", ".", "FINE_TUNE", ".", "WEIGHTS", "\n", "if", "not", "fine_tune_weights", ":", "\n", "            ", "return", "\n", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Loading fine-tune weights\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "fine_tune_weights", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "\"weights not found: {}\"", ".", "format", "(", "fine_tune_weights", ")", ")", "\n", "\n", "", "temp_checkpointer", "=", "Checkpointer", "(", "self", ".", "model", ")", "\n", "temp_checkpointer", ".", "load", "(", "fine_tune_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.resume_or_load": [[256, 275], ["trainer.DefaultTrainer.checkpointer.resume_or_load().get", "trainer.DefaultTrainer.checkpointer.resume_or_load"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.resume_or_load"], ["", "def", "resume_or_load", "(", "self", ",", "resume", "=", "True", ",", "restart_iter", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        If `resume==True`, and last checkpoint exists, resume from it.\n\n        Otherwise, load a model specified by the config.\n\n        Args:\n            resume (bool): whether to do resume or not\n        \"\"\"", "\n", "# The checkpoint stores the training iteration that just finished,", "\n", "# thus we start at the next iteration", "\n", "# (or iter zero if there's no checkpoint).", "\n", "iteration", "=", "(", "\n", "self", ".", "checkpointer", ".", "resume_or_load", "(", "self", ".", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "resume", ")", ".", "get", "(", "\n", "\"iteration\"", ",", "-", "1", "\n", ")", "\n", "+", "1", "\n", ")", "\n", "self", ".", "start_iter", "=", "iteration", "if", "not", "restart_iter", "else", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_hooks": [[276, 313], ["trainer.DefaultTrainer.cfg.clone", "trainer.DefaultTrainer.defrost", "ret.append", "meddlr.utils.env.profile_memory", "ret.append", "meddlr.engine.hooks.IterationTimer", "meddlr.engine.hooks.LRScheduler", "meddlr.engine.hooks.PeriodicCheckpointer", "trainer.DefaultTrainer.test", "meddlr.engine.hooks.EvalHook", "ret.append", "meddlr.engine.hooks.PeriodicWriter", "isinstance", "meddlr.engine.hooks.FlushOptimizer", "meddlr.engine.hooks.MemoryProfiler", "trainer.DefaultTrainer.build_writers"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.profile_memory", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.test", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_writers"], ["", "def", "build_hooks", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Build a list of default hooks, including timing, evaluation,\n        checkpointing, lr scheduling, precise BN, writing events.\n\n        Returns:\n            list[HookBase]:\n        \"\"\"", "\n", "cfg", "=", "self", ".", "cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "# save some memory and time for PreciseBN", "\n", "\n", "ret", "=", "[", "\n", "(", "\n", "hooks", ".", "FlushOptimizer", "(", "self", ".", "optimizer", ",", "cfg", ".", "TEST", ".", "EVAL_PERIOD", ")", "\n", "if", "isinstance", "(", "self", ".", "optimizer", ",", "GradAccumOptimizer", ")", "\n", "else", "None", "\n", ")", ",", "\n", "hooks", ".", "IterationTimer", "(", ")", ",", "\n", "hooks", ".", "LRScheduler", "(", "self", ".", "optimizer", ",", "self", ".", "scheduler", ")", ",", "\n", "hooks", ".", "PeriodicCheckpointer", "(", "self", ".", "checkpointer", ",", "cfg", ".", "SOLVER", ".", "CHECKPOINT_PERIOD", ")", ",", "\n", "]", "\n", "\n", "def", "test_and_save_results", "(", ")", ":", "\n", "            ", "self", ".", "_last_eval_results", "=", "self", ".", "test", "(", "self", ".", "cfg", ",", "self", ".", "model", ",", "use_val", "=", "True", ")", "\n", "return", "self", ".", "_last_eval_results", "\n", "\n", "# Do evaluation after checkpointer, because then if it fails,", "\n", "# we can use the saved checkpoint to debug.", "\n", "", "ret", ".", "append", "(", "hooks", ".", "EvalHook", "(", "cfg", ".", "TEST", ".", "EVAL_PERIOD", ",", "test_and_save_results", ")", ")", "\n", "if", "env", ".", "profile_memory", "(", ")", ":", "\n", "            ", "ret", ".", "append", "(", "hooks", ".", "MemoryProfiler", "(", "20", ")", ")", "\n", "\n", "# Writing should be last", "\n", "", "ret", ".", "append", "(", "hooks", ".", "PeriodicWriter", "(", "self", ".", "build_writers", "(", ")", ",", "periods", "=", "(", "20", ",", "cfg", ".", "TEST", ".", "EVAL_PERIOD", ")", ")", ")", "\n", "ret", "=", "[", "x", "for", "x", "in", "ret", "if", "x", "is", "not", "None", "]", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_writers": [[314, 348], ["meddlr.utils.events.CommonMetricPrinter", "meddlr.utils.events.JSONWriter", "meddlr.utils.events.TensorboardXWriter", "os.path.join"], "methods", ["None"], ["", "def", "build_writers", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Build a list of writers to be used. By default it contains\n        writers that write metrics to the screen,\n        a json file, and a tensorboard event file respectively.\n        If you'd like a different list of writers, you can overwrite it in\n        your trainer.\n\n        Returns:\n            list[EventWriter]: a list of :class:`EventWriter` objects.\n\n        It is now implemented by:\n\n        .. code-block:: python\n\n            return [\n                CommonMetricPrinter(self.max_iter),\n                JSONWriter(os.path.join(self.cfg.OUTPUT_DIR, \"metrics.json\")),\n                TensorboardXWriter(self.cfg.OUTPUT_DIR),\n            ]\n\n        \"\"\"", "\n", "assert", "(", "\n", "self", ".", "cfg", ".", "TIME_SCALE", "==", "\"iter\"", "and", "self", ".", "cfg", ".", "TEST", ".", "EVAL_PERIOD", ">=", "0", "\n", ")", ",", "\"cfg should be formatted in 'iter' time scale\"", "\n", "eval_period", "=", "self", ".", "cfg", ".", "TEST", ".", "EVAL_PERIOD", "\n", "\n", "# Assume the default print/log frequency.", "\n", "return", "[", "\n", "# It may not always print what you want to see,", "\n", "# since it prints \"common\" metrics only.", "\n", "CommonMetricPrinter", "(", "self", ".", "max_iter", ",", "eval_period", "=", "eval_period", ")", ",", "\n", "JSONWriter", "(", "os", ".", "path", ".", "join", "(", "self", ".", "cfg", ".", "OUTPUT_DIR", ",", "\"metrics.json\"", ")", ")", ",", "\n", "TensorboardXWriter", "(", "self", ".", "cfg", ".", "OUTPUT_DIR", ")", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.train": [[350, 361], ["super().train", "hasattr", "meddlr.evaluation.verify_results"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.verify_results"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Run training.\n\n        Returns:\n            OrderedDict of results, if evaluation is enabled. Otherwise None.\n        \"\"\"", "\n", "super", "(", ")", ".", "train", "(", "self", ".", "start_iter", ",", "self", ".", "max_iter", ")", "\n", "if", "hasattr", "(", "self", ",", "\"_last_eval_results\"", ")", ":", "\n", "            ", "verify_results", "(", "self", ".", "cfg", ",", "self", ".", "_last_eval_results", ")", "\n", "return", "self", ".", "_last_eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model": [[362, 376], ["meddlr.modeling.build_model"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model"], ["", "", "@", "classmethod", "\n", "def", "build_model", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            torch.nn.Module:\n\n        It now calls :func:`meddlr.modeling.build_model`.\n        Overwrite it if you'd like a different model.\n        \"\"\"", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "# logger = logging.getLogger(__name__)", "\n", "# printing model doesnt really help", "\n", "# logger.info(\"Model:\\n{}\".format(model))", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_loss_computer": [[377, 388], ["meddlr.modeling.build_loss_computer"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_loss_computer"], ["", "@", "classmethod", "\n", "def", "build_loss_computer", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "loss_computer", "=", "(", "\n", "\"N2RLossComputer\"", "\n", "if", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "==", "\"N2RModel\"", "\n", "or", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "==", "\"M2RModel\"", "\n", "or", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "==", "\"NM2RModel\"", "\n", "or", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "==", "\"A2RModel\"", "\n", "else", "\"BasicLossComputer\"", "\n", ")", "\n", "return", "build_loss_computer", "(", "cfg", ",", "loss_computer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_optimizer": [[389, 399], ["meddlr.solver.build_optimizer"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.build.build_optimizer"], ["", "@", "classmethod", "\n", "def", "build_optimizer", "(", "cls", ",", "cfg", ",", "model", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            torch.optim.Optimizer:\n\n        It now calls :func:`meddlr.solver.build_optimizer`.\n        Overwrite it if you'd like a different optimizer.\n        \"\"\"", "\n", "return", "build_optimizer", "(", "cfg", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_lr_scheduler": [[400, 407], ["meddlr.solver.build_lr_scheduler"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.build.build_lr_scheduler"], ["", "@", "classmethod", "\n", "def", "build_lr_scheduler", "(", "cls", ",", "cfg", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"\n        It now calls :func:`meddlr.solver.build_lr_scheduler`.\n        Overwrite it if you'd like a different scheduler.\n        \"\"\"", "\n", "return", "build_lr_scheduler", "(", "cfg", ",", "optimizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_train_loader": [[408, 418], ["meddlr.data.build_recon_train_loader"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_recon_train_loader"], ["", "@", "classmethod", "\n", "def", "build_train_loader", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            iterable\n\n        It now calls :func:`meddlr.data.build_recon_train_loader`.\n        Overwrite it if you'd like a different data loader.\n        \"\"\"", "\n", "return", "build_recon_train_loader", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_test_loader": [[419, 433], ["meddlr.data.build_recon_val_loader"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_recon_val_loader"], ["", "@", "classmethod", "\n", "def", "build_test_loader", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "is_val", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            iterable\n\n        It now calls :func:`meddlr.data.build_recon_val_loader`.\n        Overwrite it if you'd like a different data loader.\n        \"\"\"", "\n", "if", "is_val", ":", "\n", "            ", "as_test", "=", "cfg", ".", "TEST", ".", "VAL_AS_TEST", "\n", "", "else", ":", "\n", "            ", "as_test", "=", "True", "\n", "", "return", "build_recon_val_loader", "(", "cfg", ",", "dataset_name", ",", "as_test", "=", "as_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_evaluator": [[434, 447], ["meddlr.evaluation.ReconEvaluator", "len"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "is_val", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            DatasetEvaluator\n\n        It is not implemented by default.\n        \"\"\"", "\n", "if", "is_val", "and", "len", "(", "cfg", ".", "TEST", ".", "VAL_METRICS", ".", "RECON", ")", ">", "0", ":", "\n", "            ", "metrics", "=", "cfg", ".", "TEST", ".", "VAL_METRICS", ".", "RECON", "\n", "", "else", ":", "\n", "            ", "metrics", "=", "None", "\n", "", "return", "ReconEvaluator", "(", "dataset_name", ",", "cfg", ",", "metrics", "=", "metrics", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.test": [[448, 508], ["logging.getLogger", "isinstance", "collections.OrderedDict", "enumerate", "cls.build_test_loader", "meddlr.evaluation.inference_on_dataset", "isinstance", "logging.getLogger.info", "meddlr.evaluation.print_csv_format", "len", "len", "len", "len", "cls.build_evaluator", "logging.getLogger.warning"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_test_loader", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.inference_on_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.print_csv_format", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_evaluator"], ["", "@", "classmethod", "\n", "def", "test", "(", "cls", ",", "cfg", ",", "model", ",", "evaluators", "=", "None", ",", "use_val", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            model (nn.Module):\n            evaluators (list[DatasetEvaluator] or None): if None, will call\n                :meth:`build_evaluator`. Otherwise, must have the same length\n                as `cfg.DATASETS.{VAL/TEST}` depending on `use_val` flag.\n            use_val (bool, optional): If `True`, un inference on validation data.\n                Should be `True` during training.\n\n        Returns:\n            dict: a dict of result metrics\n        \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "if", "isinstance", "(", "evaluators", ",", "DatasetEvaluator", ")", ":", "\n", "            ", "evaluators", "=", "[", "evaluators", "]", "\n", "\n", "# To use validation data, flag must be enabled and val datasets must be available.", "\n", "", "if", "use_val", "and", "cfg", ".", "DATASETS", ".", "VAL", ":", "\n", "            ", "inf_dataset", "=", "cfg", ".", "DATASETS", ".", "VAL", "\n", "", "else", ":", "\n", "            ", "inf_dataset", "=", "cfg", ".", "DATASETS", ".", "TEST", "\n", "", "if", "evaluators", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "inf_dataset", ")", "==", "len", "(", "evaluators", ")", ",", "\"{} != {}\"", ".", "format", "(", "\n", "len", "(", "inf_dataset", ")", ",", "len", "(", "evaluators", ")", "\n", ")", "\n", "\n", "", "results", "=", "OrderedDict", "(", ")", "\n", "for", "idx", ",", "dataset_name", "in", "enumerate", "(", "inf_dataset", ")", ":", "\n", "            ", "data_loader", "=", "cls", ".", "build_test_loader", "(", "cfg", ",", "dataset_name", ")", "\n", "# When evaluators are passed in as arguments,", "\n", "# implicitly assume that evaluators can be created", "\n", "# before data_loader.", "\n", "if", "evaluators", "is", "not", "None", ":", "\n", "                ", "evaluator", "=", "evaluators", "[", "idx", "]", "\n", "", "else", ":", "\n", "                ", "try", ":", "\n", "                    ", "evaluator", "=", "cls", ".", "build_evaluator", "(", "cfg", ",", "dataset_name", ",", "is_val", "=", "use_val", ")", "\n", "", "except", "NotImplementedError", ":", "\n", "                    ", "logger", ".", "warning", "(", "\n", "\"No evaluator found. \"", "\n", "\"Use `DefaultTrainer.test(evaluators=)`, \"", "\n", "\"or implement its `build_evaluator` method.\"", "\n", ")", "\n", "results", "[", "dataset_name", "]", "=", "{", "}", "\n", "continue", "\n", "", "", "results_i", "=", "inference_on_dataset", "(", "model", ",", "data_loader", ",", "evaluator", ")", "\n", "results", "[", "dataset_name", "]", "=", "results_i", "\n", "assert", "isinstance", "(", "results_i", ",", "dict", ")", ",", "(", "\n", "\"Evaluator must return a dict or list on the main process. \"", "\n", "\"Got {} instead.\"", ".", "format", "(", "results_i", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\"Evaluation results for {} in csv format:\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "print_csv_format", "(", "results_i", ")", "\n", "\n", "# if len(results) == 1:", "\n", "#     results = list(results.values())[0]", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.format_as_iter": [[30, 64], ["isinstance", "all", "all", "type", "type", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["def", "format_as_iter", "(", "vals", ":", "Union", "[", "int", ",", "Sequence", "[", "int", "]", "]", ",", "iters_per_epoch", ":", "int", ",", "time_scale", ":", "str", ")", ":", "\n", "    ", "\"\"\"Format data to be at iteration time scale.\n\n    If values are negative, they correspond to the opposite time scale.\n    For example if `time_scale=\"epoch\"` and `val=-1`, `val` corresponds to\n    1 iteration.\n\n    Args:\n        vals (`int(s)`): Values to format.\n        iters_per_epoch (int): Number of iterations per epoch.\n        time_scale (str): Time scale of current values.\n\n    Returns:\n        int: Time (positive int) formatted in iteration format\n    \"\"\"", "\n", "assert", "time_scale", "in", "[", "\"epoch\"", ",", "\"iter\"", "]", "\n", "\n", "single_value", "=", "not", "isinstance", "(", "vals", ",", "Sequence", ")", "\n", "if", "single_value", ":", "\n", "        ", "vals", "=", "[", "vals", "]", "\n", "\n", "", "epoch_convention", "=", "(", "time_scale", "==", "\"epoch\"", "and", "all", "(", "x", ">=", "0", "for", "x", "in", "vals", ")", ")", "or", "(", "\n", "time_scale", "==", "\"iter\"", "and", "all", "(", "x", "<=", "0", "for", "x", "in", "vals", ")", "\n", ")", "\n", "\n", "if", "epoch_convention", ":", "\n", "        ", "vals", "=", "type", "(", "vals", ")", "(", "[", "iters_per_epoch", "*", "abs", "(", "x", ")", "for", "x", "in", "vals", "]", ")", "\n", "", "else", ":", "\n", "        ", "vals", "=", "type", "(", "vals", ")", "(", "[", "abs", "(", "x", ")", "for", "x", "in", "vals", "]", ")", "\n", "\n", "", "if", "single_value", ":", "\n", "        ", "return", "vals", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "return", "vals", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer._convert_time_recursive": [[66, 91], ["type", "isinstance", "type.", "isinstance", "out.append", "entity.keys", "type.", "trainer._convert_time_recursive", "trainer._convert_time_recursive", "entity.items", "isinstance", "any", "trainer.format_as_iter", "re.match", "isinstance"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer._convert_time_recursive", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer._convert_time_recursive", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.format_as_iter"], ["", "", "def", "_convert_time_recursive", "(", "\n", "entity", ":", "Union", "[", "Mapping", ",", "Sequence", "]", ",", "\n", "iters_per_epoch", ",", "\n", "time_scale", ",", "\n", "patterns", "=", "(", "\"^.*_iters$\"", ",", "\"^.*_iter$\"", ",", "\"^.*_milestones$\"", ")", ",", "\n", ")", ":", "\n", "    ", "otype", "=", "type", "(", "entity", ")", "\n", "if", "isinstance", "(", "entity", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "out", "=", "[", "]", "\n", "for", "e", "in", "entity", ":", "\n", "            ", "out", ".", "append", "(", "_convert_time_recursive", "(", "e", ",", "iters_per_epoch", ",", "time_scale", ",", "patterns", ")", ")", "\n", "", "return", "otype", "(", "out", ")", "\n", "", "elif", "isinstance", "(", "entity", ",", "Mapping", ")", ":", "\n", "        ", "entity", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "entity", ".", "items", "(", ")", "}", "\n", "for", "k", "in", "entity", ".", "keys", "(", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "entity", "[", "k", "]", ",", "Mapping", ")", ":", "\n", "                ", "if", "any", "(", "re", ".", "match", "(", "pattern", ",", "k", ")", "for", "pattern", "in", "patterns", ")", ":", "\n", "                    ", "entity", "[", "k", "]", "=", "format_as_iter", "(", "entity", "[", "k", "]", ",", "iters_per_epoch", ",", "time_scale", ")", "\n", "", "elif", "not", "isinstance", "(", "entity", "[", "k", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "                    ", "continue", "\n", "\n", "", "", "entity", "[", "k", "]", "=", "_convert_time_recursive", "(", "entity", "[", "k", "]", ",", "iters_per_epoch", ",", "time_scale", ",", "patterns", ")", "\n", "", "return", "otype", "(", "entity", ")", "\n", "", "else", ":", "\n", "        ", "return", "entity", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.convert_cfg_time_to_iter": [[93, 138], ["cfg.clone.clone", "cfg.clone.defrost", "cfg.clone.freeze", "func", "cfg.clone.set_recursive", "cfg.clone.get_recursive", "KeyError"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.set_recursive", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.get_recursive"], ["", "", "def", "convert_cfg_time_to_iter", "(", "cfg", ":", "CfgNode", ",", "iters_per_epoch", ":", "int", ",", "ignore_missing", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"Convert all config time-related parameters to iteration scale.\n\n    Args:\n        cfg (CfgNode): The config to\n        iters_per_epoch (int): Number of iterations per epoch.\n        ignore_missing (bool, optional): If ``True``, silently skip over missing keys.\n    \"\"\"", "\n", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "\n", "time_scale", "=", "cfg", ".", "TIME_SCALE", "\n", "\n", "time_fmt", "=", "(", "\n", "\"SOLVER.MAX_ITER\"", ",", "\n", "\"SOLVER.STEPS\"", ",", "\n", "\"SOLVER.CHECKPOINT_PERIOD\"", ",", "\n", "\"TEST.EVAL_PERIOD\"", ",", "\n", "\"VIS_PERIOD\"", ",", "\n", "\"MODEL.CONSISTENCY.AUG.NOISE.SCHEDULER.WARMUP_ITERS\"", ",", "\n", ")", "\n", "recursively_fmt", "=", "(", "\n", "\"AUG_TRAIN.MRI_RECON.TRANSFORMS\"", ",", "\n", "\"AUG_TRAIN.MRI_RECON.SCHEDULER_P\"", ",", "\n", "\"MODEL.CONSISTENCY.AUG.MRI_RECON.TRANSFORMS\"", ",", "\n", "\"MODEL.CONSISTENCY.AUG.MRI_RECON.SCHEDULER_P\"", ",", "\n", ")", "\n", "\n", "for", "keys_to_fmt", ",", "func", "in", "[", "\n", "(", "time_fmt", ",", "format_as_iter", ")", ",", "\n", "(", "recursively_fmt", ",", "_convert_time_recursive", ")", ",", "\n", "]", ":", "\n", "        ", "for", "key", "in", "keys_to_fmt", ":", "\n", "            ", "try", ":", "\n", "                ", "curr_val", "=", "cfg", ".", "get_recursive", "(", "key", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "if", "ignore_missing", ":", "\n", "                    ", "continue", "\n", "", "raise", "KeyError", "(", "f\"cfg does not contain key '{key}'\"", ")", "\n", "", "value", "=", "func", "(", "curr_val", ",", "iters_per_epoch", ",", "time_scale", ")", "\n", "cfg", ".", "set_recursive", "(", "key", ",", "value", ")", "\n", "\n", "", "", "cfg", ".", "TIME_SCALE", "=", "\"iter\"", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.get_model_from_zoo": [[15, 86], ["meddlr.utils.env.get_path_manager", "build_model_fn", "env.get_path_manager.get_local_path", "model_zoo.load_weights", "isinstance", "env.get_path_manager.get_local_path", "meddlr.check_dependencies", "meddlr.config.get_cfg", "meddlr.config.get_cfg.merge_from_file", "len", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.load_weights", "home.repos.pwc.inspect_result.ad12_meddlr.config.util.check_dependencies", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file"], ["def", "get_model_from_zoo", "(", "\n", "cfg_or_file", ":", "Union", "[", "str", ",", "os", ".", "PathLike", ",", "CfgNode", "]", ",", "\n", "weights_path", ":", "Union", "[", "str", ",", "os", ".", "PathLike", "]", "=", "None", ",", "\n", "strict", ":", "bool", "=", "True", ",", "\n", "ignore_shape_mismatch", ":", "bool", "=", "False", ",", "\n", "force_download", ":", "bool", "=", "False", ",", "\n", "build_model_fn", ":", "callable", "=", "None", ",", "\n", "build_model_kwargs", ":", "Dict", "[", "str", ",", "Any", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "nn", ".", "Module", ":", "\n", "    ", "\"\"\"Get model from zoo and optionally load in weights.\n\n    This function is designed for distributing models for use.\n    It builds the model from a configuration and optionally loads in pre-trained weights.\n    Pre-trained weights can either be specified by the ``weights_file`` argument\n    or by setting the config option ``cfg.MODEL.WEIGHTS``. If neither is specified,\n    the model is initialized randomly. If ``weights_file`` is an empty string,\n    ``cfg.MODEL.WEIGHTS`` will also be ignored, and the model will be initialized randomly.\n\n    Args:\n        cfg_or_file (str | path-like | CfgNode): The config (or file).\n            If it is a file, it will be merged with the default config.\n        weights_path (str | path-like, optional): The weights file to load.\n            This can also be specified in the ``cfg.MODEL.WEIGHTS`` config\n            field. If neither are provided, the uninitialized model will be returned.\n        strict (bool, optional): Strict option to pass to ``load_state_dict``.\n        ignore_shape_mismatch (bool, optional): If ``True``, weights that do not\n            match the model layer's shape will be ignored instead of raising\n            an error.\n        force_download (bool, optional): Force download of model config/weights\n            if downloading the model.\n        build_model_fn (callable, optional): A function to build the model.\n            Defaults to :func:`meddlr.modeling.meta_arch.build_model`.\n        build_model_kwargs (dict, optional): Keyword arguments to pass to\n            ``build_model_fn``.\n\n    Returns:\n        torch.nn.Module: The model loaded with pre-trained weights.\n    \"\"\"", "\n", "path_manager", "=", "env", ".", "get_path_manager", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "cfg_or_file", ",", "CfgNode", ")", ":", "\n", "        ", "cfg_file", "=", "path_manager", ".", "get_local_path", "(", "cfg_or_file", ",", "force", "=", "force_download", ")", "\n", "failed_deps", "=", "config_util", ".", "check_dependencies", "(", "cfg_file", ",", "return_failed_deps", "=", "True", ")", "\n", "if", "len", "(", "failed_deps", ")", ">", "0", ":", "# pragma: no cover", "\n", "            ", "warning_msg", "=", "(", "\n", "f\"Some dependenices are not met. \"", "\n", "f\"This may result in some issues with model construction or weight loading. \"", "\n", "f\"Unmet dependencies: {failed_deps}\"", "\n", ")", "\n", "warnings", ".", "warn", "(", "warning_msg", ")", "\n", "", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "cfg_file", ")", "\n", "", "else", ":", "\n", "        ", "cfg", "=", "cfg_or_file", "\n", "\n", "", "if", "build_model_fn", "is", "None", ":", "\n", "        ", "build_model_fn", "=", "build_model", "\n", "", "if", "not", "build_model_kwargs", ":", "\n", "        ", "build_model_kwargs", "=", "{", "}", "\n", "", "model", "=", "build_model_fn", "(", "cfg", ",", "**", "build_model_kwargs", ")", "\n", "\n", "if", "weights_path", "is", "None", ":", "\n", "        ", "weights_path", "=", "cfg", ".", "MODEL", ".", "WEIGHTS", "\n", "", "if", "not", "weights_path", ":", "\n", "        ", "return", "model", "\n", "\n", "", "weights_path", "=", "path_manager", ".", "get_local_path", "(", "weights_path", ",", "force", "=", "force_download", ")", "\n", "model", "=", "load_weights", "(", "\n", "model", ",", "weights_path", ",", "strict", "=", "strict", ",", "ignore_shape_mismatch", "=", "ignore_shape_mismatch", "\n", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.load_weights": [[88, 149], ["meddlr.utils.env.get_path_manager", "env.get_path_manager.get_local_path", "torch.load", "model.to.load_state_dict", "model_zoo._find_mismatch_sizes", "model.to.to", "len", "warnings.warn", "next", "torch.load.pop", "iter", "torch.load.values"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.load_state_dict", "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo._find_mismatch_sizes", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "load_weights", "(", "\n", "model", ":", "torch", ".", "nn", ".", "Module", ",", "\n", "weights_path", ":", "Union", "[", "str", ",", "os", ".", "PathLike", "]", ",", "\n", "strict", ":", "bool", "=", "True", ",", "\n", "ignore_shape_mismatch", ":", "bool", "=", "False", ",", "\n", "force_download", ":", "bool", "=", "False", ",", "\n", "find_device", ":", "bool", "=", "True", ",", "\n", ")", "->", "torch", ".", "nn", ".", "Module", ":", "\n", "    ", "\"\"\"Load model from checkpoint.\n\n    This function is designed for distributing models for use. It loads in pre-trained weights.\n    Pre-trained weights can either be specified by the ``weights_file`` argument\n    or by setting the config option ``cfg.MODEL.WEIGHTS``. If neither is specified,\n    the model is initialized randomly. If ``weights_file`` is an empty string,\n    ``cfg.MODEL.WEIGHTS`` will also be ignored, and the model will be initialized randomly.\n\n    Args:\n        model (torch.nn.Module): The model to load weights into.\n        checkpoint_path (str | path-like): The checkpoint file to load.\n        strict (bool, optional): Strict option to pass to ``load_state_dict``.\n        ignore_shape_mismatch (bool, optional): If ``True``, weights that do not\n            match the model layer's shape will be ignored instead of raising\n            an error.\n        force_download (bool, optional): Force download of model config/weights\n            if downloading the model.\n        find_device (bool, optional): If ``True``, find the device the weights\n            were stored on and moves the model prior to loading weights.\n\n    Returns:\n        torch.nn.Module: The model loaded with pre-trained weights.\n            Note this model will be unpacked from the PyTorch Lightnining modules.\n    \"\"\"", "\n", "path_manager", "=", "env", ".", "get_path_manager", "(", ")", "\n", "\n", "weights_path", "=", "path_manager", ".", "get_local_path", "(", "weights_path", ",", "force", "=", "force_download", ")", "\n", "weights", "=", "torch", ".", "load", "(", "weights_path", ")", "\n", "if", "\"state_dict\"", "in", "weights", ":", "\n", "        ", "weights", "=", "weights", "[", "\"state_dict\"", "]", "\n", "", "elif", "\"model\"", "in", "weights", ":", "\n", "        ", "weights", "=", "weights", "[", "\"model\"", "]", "\n", "\n", "", "if", "ignore_shape_mismatch", ":", "\n", "        ", "params_shape_mismatch", "=", "_find_mismatch_sizes", "(", "model", ",", "weights", ")", "\n", "if", "len", "(", "params_shape_mismatch", ")", ">", "0", ":", "\n", "            ", "mismatched_params_str", "=", "\"\"", ".", "join", "(", "\"\\t- {}\\n\"", ".", "format", "(", "x", ")", "for", "x", "in", "params_shape_mismatch", ")", "\n", "warnings", ".", "warn", "(", "\n", "\"Shape mismatch found for some parameters. Ignoring these weights:\\n{}\"", ".", "format", "(", "\n", "mismatched_params_str", "\n", ")", "\n", ")", "\n", "for", "p", "in", "params_shape_mismatch", ":", "\n", "                ", "weights", ".", "pop", "(", "p", ")", "\n", "", "strict", "=", "False", "\n", "\n", "", "", "if", "find_device", ":", "\n", "        ", "device", "=", "next", "(", "iter", "(", "weights", ".", "values", "(", ")", ")", ")", ".", "device", "\n", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "", "model", ".", "load_state_dict", "(", "weights", ",", "strict", "=", "strict", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo._find_mismatch_sizes": [[151, 168], ["set", "list", "model.state_dict().items", "model.named_parameters", "model.state_dict"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.state_dict"], ["", "def", "_find_mismatch_sizes", "(", "model", ":", "torch", ".", "nn", ".", "Module", ",", "state_dict", ")", ":", "\n", "    ", "\"\"\"Finds the keys in the state_dict that are different from the model.\n    Args:\n        model (torch.nn.Module): The model to load weights into.\n        state_dict (dict): The state_dict to load.\n    Returns:\n        list[str]: The list of keys that are different from the model.\n    \"\"\"", "\n", "params_shape_mismatch", "=", "set", "(", ")", "\n", "for", "source", "in", "[", "model", ".", "state_dict", "(", ")", ".", "items", "(", ")", ",", "model", ".", "named_parameters", "(", ")", "]", ":", "\n", "        ", "for", "name", ",", "param", "in", "source", ":", "\n", "            ", "if", "name", "not", "in", "state_dict", ":", "\n", "                ", "continue", "\n", "", "if", "param", ".", "shape", "!=", "state_dict", "[", "name", "]", ".", "shape", ":", "\n", "                ", "params_shape_mismatch", "|=", "{", "name", "}", "\n", "\n", "", "", "", "return", "list", "(", "params_shape_mismatch", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.CallbackHook.__init__": [[53, 61], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "*", ",", "before_train", "=", "None", ",", "after_train", "=", "None", ",", "before_step", "=", "None", ",", "after_step", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Each argument is a function that takes one argument: the trainer.\n        \"\"\"", "\n", "self", ".", "_before_train", "=", "before_train", "\n", "self", ".", "_before_step", "=", "before_step", "\n", "self", ".", "_after_step", "=", "after_step", "\n", "self", ".", "_after_train", "=", "after_train", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.CallbackHook.before_train": [[62, 65], ["hooks.CallbackHook._before_train"], "methods", ["None"], ["", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_before_train", ":", "\n", "            ", "self", ".", "_before_train", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.CallbackHook.after_train": [[66, 73], ["hooks.CallbackHook._after_train"], "methods", ["None"], ["", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_after_train", ":", "\n", "            ", "self", ".", "_after_train", "(", "self", ".", "trainer", ")", "\n", "# The functions may be closures that hold reference to the trainer", "\n", "# Therefore, delete them to avoid circular reference.", "\n", "", "del", "self", ".", "_before_train", ",", "self", ".", "_after_train", "\n", "del", "self", ".", "_before_step", ",", "self", ".", "_after_step", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.CallbackHook.before_step": [[74, 77], ["hooks.CallbackHook._before_step"], "methods", ["None"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_before_step", ":", "\n", "            ", "self", ".", "_before_step", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.CallbackHook.after_step": [[78, 81], ["hooks.CallbackHook._after_step"], "methods", ["None"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_after_step", ":", "\n", "            ", "self", ".", "_after_step", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.IterationTimer.__init__": [[95, 103], ["fvcore.common.timer.Timer"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "warmup_iter", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            warmup_iter (int): the number of iterations at the beginning to\n                exclude from timing.\n        \"\"\"", "\n", "self", ".", "_warmup_iter", "=", "warmup_iter", "\n", "self", ".", "_step_timer", "=", "Timer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.IterationTimer.before_train": [[104, 108], ["time.perf_counter", "fvcore.common.timer.Timer", "hooks.IterationTimer._total_timer.pause"], "methods", ["None"], ["", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "self", ".", "_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "_total_timer", "=", "Timer", "(", ")", "\n", "self", ".", "_total_timer", ".", "pause", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.IterationTimer.after_train": [[109, 133], ["logging.getLogger", "hooks.IterationTimer._total_timer.seconds", "logging.getLogger.info", "time.perf_counter", "logging.getLogger.info", "str", "str", "str", "datetime.timedelta", "datetime.timedelta", "datetime.timedelta", "int", "int", "int"], "methods", ["None"], ["", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "total_time", "=", "time", ".", "perf_counter", "(", ")", "-", "self", ".", "_start_time", "\n", "total_time_minus_hooks", "=", "self", ".", "_total_timer", ".", "seconds", "(", ")", "\n", "hook_time", "=", "total_time", "-", "total_time_minus_hooks", "\n", "\n", "num_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "-", "self", ".", "trainer", ".", "start_iter", "-", "self", ".", "_warmup_iter", "\n", "\n", "if", "num_iter", ">", "0", "and", "total_time_minus_hooks", ">", "0", ":", "\n", "# Speed is meaningful only after warmup", "\n", "# NOTE this format is parsed by grep in some scripts", "\n", "            ", "logger", ".", "info", "(", "\n", "\"Overall training speed: \"", "\n", "\"{} iterations in {} ({:.4f} s / it)\"", ".", "format", "(", "\n", "num_iter", ",", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_time_minus_hooks", ")", ")", ")", ",", "\n", "total_time_minus_hooks", "/", "num_iter", ",", "\n", ")", "\n", ")", "\n", "\n", "", "logger", ".", "info", "(", "\n", "\"Total training time: {} ({} on hooks)\"", ".", "format", "(", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_time", ")", ")", ")", ",", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "hook_time", ")", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.IterationTimer.before_step": [[136, 139], ["hooks.IterationTimer._step_timer.reset", "hooks.IterationTimer._total_timer.resume"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "self", ".", "_step_timer", ".", "reset", "(", ")", "\n", "self", ".", "_total_timer", ".", "resume", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.IterationTimer.after_step": [[140, 151], ["hooks.IterationTimer._total_timer.pause", "hooks.IterationTimer._step_timer.seconds", "hooks.IterationTimer.trainer.storage.put_scalars", "time.perf_counter", "hooks.IterationTimer._total_timer.reset"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalars", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "# +1 because we're in after_step", "\n", "        ", "iter_done", "=", "self", ".", "trainer", ".", "iter", "-", "self", ".", "trainer", ".", "start_iter", "+", "1", "\n", "if", "iter_done", ">=", "self", ".", "_warmup_iter", ":", "\n", "            ", "sec", "=", "self", ".", "_step_timer", ".", "seconds", "(", ")", "\n", "self", ".", "trainer", ".", "storage", ".", "put_scalars", "(", "time", "=", "sec", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "_total_timer", ".", "reset", "(", ")", "\n", "\n", "", "self", ".", "_total_timer", ".", "pause", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.PeriodicWriter.__init__": [[160, 174], ["isinstance", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "writers", ",", "periods", "=", "(", "20", ",", ")", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            writers (list[EventWriter]): a list of EventWriter objects\n            periods(`int` or `Sequence[int]`): Period(s) over which to\n                save data. This is useful when the evaluation period is\n                not a multiple of the default period.\n        \"\"\"", "\n", "self", ".", "_writers", "=", "writers", "\n", "for", "w", "in", "writers", ":", "\n", "            ", "assert", "isinstance", "(", "w", ",", "EventWriter", ")", ",", "w", "\n", "", "if", "isinstance", "(", "periods", ",", "int", ")", ":", "\n", "            ", "periods", "=", "(", "periods", ",", ")", "\n", "", "self", ".", "_periods", "=", "periods", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.PeriodicWriter.after_step": [[175, 182], ["any", "writer.write"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "(", "\n", "any", "(", "(", "self", ".", "trainer", ".", "iter", "+", "1", ")", "%", "period", "==", "0", "for", "period", "in", "self", ".", "_periods", ")", "\n", "or", "self", ".", "trainer", ".", "iter", "==", "self", ".", "trainer", ".", "max_iter", "-", "1", "\n", ")", ":", "\n", "            ", "for", "writer", "in", "self", ".", "_writers", ":", "\n", "                ", "writer", ".", "write", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.PeriodicWriter.after_train": [[183, 186], ["writer.close"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["", "", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "for", "writer", "in", "self", ".", "_writers", ":", "\n", "            ", "writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.PeriodicCheckpointer.before_train": [[199, 201], ["None"], "methods", ["None"], ["def", "before_train", "(", "self", ")", ":", "\n", "        ", "self", ".", "max_iter", "=", "self", ".", "trainer", ".", "max_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.PeriodicCheckpointer.after_step": [[202, 205], ["hooks.PeriodicCheckpointer.step"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "# No way to use **kwargs", "\n", "        ", "self", ".", "step", "(", "self", ".", "trainer", ".", "iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.LRScheduler.__init__": [[213, 240], ["max", "collections.Counter", "enumerate", "enumerate", "len", "collections.Counter.most_common", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "scheduler", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            optimizer (torch.optim.Optimizer):\n            scheduler (torch.optim._LRScheduler)\n        \"\"\"", "\n", "self", ".", "_optimizer", "=", "optimizer", "\n", "self", ".", "_scheduler", "=", "scheduler", "\n", "\n", "# NOTE: some heuristics on what LR to summarize", "\n", "# summarize the param group with most parameters", "\n", "largest_group", "=", "max", "(", "len", "(", "g", "[", "\"params\"", "]", ")", "for", "g", "in", "optimizer", ".", "param_groups", ")", "\n", "\n", "if", "largest_group", "==", "1", ":", "\n", "# If all groups have one parameter,", "\n", "# then find the most common initial LR, and use it for summary", "\n", "            ", "lr_count", "=", "Counter", "(", "[", "g", "[", "\"lr\"", "]", "for", "g", "in", "optimizer", ".", "param_groups", "]", ")", "\n", "lr", "=", "lr_count", ".", "most_common", "(", ")", "[", "0", "]", "[", "0", "]", "\n", "for", "i", ",", "g", "in", "enumerate", "(", "optimizer", ".", "param_groups", ")", ":", "\n", "                ", "if", "g", "[", "\"lr\"", "]", "==", "lr", ":", "\n", "                    ", "self", ".", "_best_param_group_id", "=", "i", "\n", "break", "\n", "", "", "", "else", ":", "\n", "            ", "for", "i", ",", "g", "in", "enumerate", "(", "optimizer", ".", "param_groups", ")", ":", "\n", "                ", "if", "len", "(", "g", "[", "\"params\"", "]", ")", "==", "largest_group", ":", "\n", "                    ", "self", ".", "_best_param_group_id", "=", "i", "\n", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.LRScheduler.after_step": [[241, 245], ["hooks.LRScheduler.trainer.storage.put_scalar", "hooks.LRScheduler._scheduler.step"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step"], ["", "", "", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "lr", "=", "self", ".", "_optimizer", ".", "param_groups", "[", "self", ".", "_best_param_group_id", "]", "[", "\"lr\"", "]", "\n", "self", ".", "trainer", ".", "storage", ".", "put_scalar", "(", "\"lr\"", ",", "lr", ",", "smoothing_hint", "=", "False", ")", "\n", "self", ".", "_scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.AutogradProfiler.__init__": [[274, 287], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "enable_predicate", ",", "output_dir", ",", "*", ",", "use_cuda", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            enable_predicate (callable[trainer -> bool]): a function which takes\n                a trainer, and returns whether to enable the profiler.\n                It will be called once every step, and can be used to select\n                which steps to profile.\n            output_dir (str): the output directory to dump tracing files.\n            use_cuda (bool): same as in `torch.autograd.profiler.profile`.\n        \"\"\"", "\n", "self", ".", "_enable_predicate", "=", "enable_predicate", "\n", "self", ".", "_use_cuda", "=", "use_cuda", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.AutogradProfiler.before_step": [[288, 294], ["hooks.AutogradProfiler._enable_predicate", "torch.autograd.profiler.profile", "hooks.AutogradProfiler._profiler.__enter__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__enter__"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_enable_predicate", "(", "self", ".", "trainer", ")", ":", "\n", "            ", "self", ".", "_profiler", "=", "torch", ".", "autograd", ".", "profiler", ".", "profile", "(", "use_cuda", "=", "self", ".", "_use_cuda", ")", "\n", "self", ".", "_profiler", ".", "__enter__", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_profiler", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.AutogradProfiler.after_step": [[295, 313], ["hooks.AutogradProfiler._profiler.__exit__", "os.path.join", "hooks.AutogradProfiler._profiler.export_chrome_trace", "tempfile.TemporaryDirectory", "os.path.join", "hooks.AutogradProfiler._profiler.export_chrome_trace", "_PATH_MANAGER.open", "f.write", "open", "f.read"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__exit__", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.read"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_profiler", "is", "None", ":", "\n", "            ", "return", "\n", "", "self", ".", "_profiler", ".", "__exit__", "(", "None", ",", "None", ",", "None", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "_output_dir", ",", "\"profiler-trace-iter{}.json\"", ".", "format", "(", "self", ".", "trainer", ".", "iter", ")", "\n", ")", "\n", "if", "\"://\"", "not", "in", "out_file", ":", "\n", "            ", "self", ".", "_profiler", ".", "export_chrome_trace", "(", "out_file", ")", "\n", "", "else", ":", "\n", "# Support non-posix filesystems", "\n", "            ", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_profiler\"", ")", "as", "d", ":", "\n", "                ", "tmp_file", "=", "os", ".", "path", ".", "join", "(", "d", ",", "\"tmp.json\"", ")", "\n", "self", ".", "_profiler", ".", "export_chrome_trace", "(", "tmp_file", ")", "\n", "with", "open", "(", "tmp_file", ")", "as", "f", ":", "\n", "                    ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "", "with", "_PATH_MANAGER", ".", "open", "(", "out_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "content", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.FlushOptimizer.__init__": [[318, 321], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "optimizer", ":", "GradAccumOptimizer", ",", "period", ")", ":", "\n", "        ", "self", ".", "_period", "=", "period", "\n", "self", ".", "_optimizer", "=", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.FlushOptimizer.after_step": [[322, 327], ["hooks.FlushOptimizer._optimizer.flush"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "next_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "\n", "is_final", "=", "next_iter", "==", "self", ".", "trainer", ".", "max_iter", "\n", "if", "is_final", "or", "(", "self", ".", "_period", ">", "0", "and", "next_iter", "%", "self", ".", "_period", "==", "0", ")", ":", "\n", "            ", "self", ".", "_optimizer", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.EvalHook.__init__": [[337, 352], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "eval_period", ",", "eval_function", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            eval_period (int): the period to run `eval_function`.\n            eval_function (callable): a function which takes no arguments, and\n                returns a nested dict of evaluation metrics.\n\n        Note:\n            This hook must be enabled in all or none workers.\n            If you would like only certain workers to perform evaluation,\n            give other workers a no-op function (`eval_function=lambda: None`).\n        \"\"\"", "\n", "self", ".", "_period", "=", "eval_period", "\n", "self", ".", "_func", "=", "eval_function", "\n", "self", ".", "_done_eval_at_last", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.EvalHook._do_eval": [[353, 377], ["time.perf_counter", "hooks.EvalHook._func", "hooks.EvalHook.trainer.storage.put_scalars", "isinstance", "meddlr.evaluation.testing.flatten_results_dict", "meddlr.evaluation.testing.flatten_results_dict.items", "hooks.EvalHook.trainer.storage.put_scalars", "time.perf_counter", "float", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalars", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.flatten_results_dict", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalars"], ["", "def", "_do_eval", "(", "self", ")", ":", "\n", "        ", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n", "results", "=", "self", ".", "_func", "(", ")", "\n", "\n", "if", "results", ":", "\n", "            ", "assert", "isinstance", "(", "\n", "results", ",", "dict", "\n", ")", ",", "\"Eval function must return a dict. Got {} instead.\"", ".", "format", "(", "results", ")", "\n", "\n", "flattened_results", "=", "flatten_results_dict", "(", "results", ")", "\n", "for", "k", ",", "v", "in", "flattened_results", ".", "items", "(", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "v", "=", "float", "(", "v", ")", "\n", "", "except", "Exception", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"[EvalHook] eval_function should return \"", "\n", "\"a nested dict of float. \"", "\n", "\"Got '{}: {}' instead.\"", ".", "format", "(", "k", ",", "v", ")", "\n", ")", "\n", "", "", "self", ".", "trainer", ".", "storage", ".", "put_scalars", "(", "**", "flattened_results", ",", "smoothing_hint", "=", "False", ")", "\n", "\n", "", "time_elapsed", "=", "time", ".", "perf_counter", "(", ")", "-", "start_time", "# in seconds", "\n", "self", ".", "trainer", ".", "storage", ".", "put_scalars", "(", "eval_time", "=", "time_elapsed", ",", "smoothing_hint", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.EvalHook.after_step": [[378, 385], ["hooks.EvalHook._do_eval"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.EvalHook._do_eval"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "next_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "\n", "is_final", "=", "next_iter", "==", "self", ".", "trainer", ".", "max_iter", "\n", "if", "is_final", "or", "(", "self", ".", "_period", ">", "0", "and", "next_iter", "%", "self", ".", "_period", "==", "0", ")", ":", "\n", "            ", "self", ".", "_do_eval", "(", ")", "\n", "if", "is_final", ":", "\n", "                ", "self", ".", "_done_eval_at_last", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.EvalHook.after_train": [[386, 392], ["hooks.EvalHook._do_eval"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.EvalHook._do_eval"], ["", "", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "_done_eval_at_last", ":", "\n", "            ", "self", ".", "_do_eval", "(", ")", "\n", "# func is likely a closure that holds reference to the trainer", "\n", "# therefore we clean it to avoid circular reference in the end", "\n", "", "del", "self", ".", "_func", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.MemoryProfiler.__init__": [[404, 408], ["ModuleNotFoundError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "period", ")", ":", "\n", "        ", "if", "hpy", "is", "None", ":", "\n", "            ", "raise", "ModuleNotFoundError", "(", "\"Module `guppy` not found. Install with `pip install guppy3`\"", ")", "\n", "", "self", ".", "_period", "=", "period", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.hooks.MemoryProfiler.after_step": [[409, 417], ["hpy", "hpy.heap", "hooks.MemoryProfiler.trainer.storage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalar"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "next_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "\n", "is_final", "=", "next_iter", "==", "self", ".", "trainer", ".", "max_iter", "\n", "if", "is_final", "or", "(", "self", ".", "_period", ">", "0", "and", "next_iter", "%", "self", ".", "_period", "==", "0", ")", ":", "\n", "            ", "hp", "=", "hpy", "(", ")", "\n", "heap", "=", "hp", ".", "heap", "(", ")", "\n", "self", ".", "trainer", ".", "storage", ".", "put_scalar", "(", "\n", "\"guppy/total_RAM\"", ",", "heap", ".", "size", "/", "1024.0", "/", "1024.0", ",", "smoothing_hint", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.HookBase.before_train": [[57, 62], ["None"], "methods", ["None"], ["def", "before_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called before the first iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.HookBase.after_train": [[63, 68], ["None"], "methods", ["None"], ["", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called after the last iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.HookBase.before_step": [[69, 74], ["None"], "methods", ["None"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called before each iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.HookBase.after_step": [[75, 80], ["None"], "methods", ["None"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called after each iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.__init__": [[103, 105], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_hooks", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.register_hooks": [[106, 124], ["train_loop.TrainerBase._hooks.extend", "isinstance", "weakref.proxy"], "methods", ["None"], ["", "def", "register_hooks", "(", "self", ",", "hooks", ")", ":", "\n", "        ", "\"\"\"\n        Register hooks to the trainer. The hooks are executed in the order\n        they are registered.\n\n        Args:\n            hooks (list[Optional[HookBase]]): list of hooks\n        \"\"\"", "\n", "hooks", "=", "[", "h", "for", "h", "in", "hooks", "if", "h", "is", "not", "None", "]", "\n", "for", "h", "in", "hooks", ":", "\n", "            ", "assert", "isinstance", "(", "h", ",", "HookBase", ")", "\n", "# To avoid circular reference, hooks and", "\n", "# trainer cannot own each other.", "\n", "# This normally does not matter, but will cause memory leak if the", "\n", "# involved objects contain __del__:", "\n", "# See http://engineering.hearsaysocial.com/2013/06/16/circular-references-in-python/  # noqa", "\n", "h", ".", "trainer", "=", "weakref", ".", "proxy", "(", "self", ")", "\n", "", "self", ".", "_hooks", ".", "extend", "(", "hooks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.train": [[125, 148], ["logging.getLogger", "logging.getLogger.info", "meddlr.utils.events.EventStorage", "train_loop.TrainerBase.before_train", "range", "train_loop.TrainerBase.after_train", "train_loop.TrainerBase.before_step", "train_loop.TrainerBase.run_step", "train_loop.TrainerBase.after_step", "logging.getLogger.error"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer.before_train", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.after_train", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.before_step", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer.run_step", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.after_step"], ["", "def", "train", "(", "self", ",", "start_iter", ":", "int", ",", "max_iter", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            start_iter, max_iter (int): See docs above\n        \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Starting training from iteration {}\"", ".", "format", "(", "start_iter", ")", ")", "\n", "\n", "self", ".", "iter", "=", "self", ".", "start_iter", "=", "start_iter", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "\n", "with", "EventStorage", "(", "start_iter", ")", "as", "self", ".", "storage", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "before_train", "(", ")", "\n", "for", "self", ".", "iter", "in", "range", "(", "start_iter", ",", "max_iter", ")", ":", "\n", "                    ", "self", ".", "before_step", "(", ")", "\n", "self", ".", "run_step", "(", ")", "\n", "self", ".", "after_step", "(", ")", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "                ", "logger", ".", "error", "(", "e", ")", "\n", "raise", "e", "\n", "", "finally", ":", "\n", "                ", "self", ".", "after_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.before_train": [[149, 152], ["h.before_train"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer.before_train"], ["", "", "", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "before_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.after_train": [[153, 156], ["h.after_train"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.after_train"], ["", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "after_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.before_step": [[157, 160], ["h.before_step"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.before_step"], ["", "", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "before_step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.after_step": [[161, 167], ["train_loop.TrainerBase.storage.step", "h.after_step"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.after_step"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "after_step", "(", ")", "\n", "# this guarantees, that in each hook's after_step,", "\n", "# storage.iter == trainer.iter", "\n", "", "self", ".", "storage", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.run_step": [[168, 170], ["None"], "methods", ["None"], ["", "def", "run_step", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer.__init__": [[187, 215], ["train_loop.TrainerBase.__init__", "model.train"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.train"], ["def", "__init__", "(", "self", ",", "model", ",", "data_loader", ",", "optimizer", ",", "loss_computer", ",", "metrics_computer", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            model: a torch Module. Takes a data from data_loader and returns a\n                dict of losses.\n            data_loader: an iterable. Contains data to be used to call model.\n            optimizer: a torch optimizer.\n            loss_computer: A callable that returns a dict of losses.\n                All terms must have the word \"loss\" to be a valid loss.\n            metrics_computer: A callable that returns a dict of metrics.\n                Will not be used for loss.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "\"\"\"\n        We set the model to training mode in the trainer.\n        However it's valid to train a model that's in eval mode.\n        If you want your model (or a submodule of it) to behave\n        like evaluation during training, you can overwrite its train() method.\n        \"\"\"", "\n", "model", ".", "train", "(", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "data_loader", "=", "data_loader", "\n", "self", ".", "_data_loader_iter", "=", "None", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "loss_computer", "=", "loss_computer", "\n", "self", ".", "metrics_computer", "=", "metrics_computer", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer.before_train": [[216, 220], ["train_loop.TrainerBase.before_train", "iter"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer.before_train", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "out", "=", "super", "(", ")", ".", "before_train", "(", ")", "\n", "self", ".", "_data_loader_iter", "=", "iter", "(", "self", ".", "data_loader", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer.run_step": [[221, 274], ["time.perf_counter", "train_loop.SimpleTrainer.model", "train_loop.SimpleTrainer.update", "loss_dict.update", "train_loop.SimpleTrainer._detect_anomaly", "metrics_dict.update", "metrics_dict.update", "train_loop.SimpleTrainer._write_metrics", "train_loop.SimpleTrainer.optimizer.zero_grad", "losses.backward", "train_loop.SimpleTrainer.optimizer.step", "next", "time.perf_counter", "train_loop.SimpleTrainer.loss_computer", "meddlr.utils.general.flatten_dict", "iter", "next", "train_loop.SimpleTrainer.items", "train_loop.SimpleTrainer.metrics_computer", "next.get().items", "next.get"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer._detect_anomaly", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer._write_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.utils.general.flatten_dict", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "run_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Implement the standard training logic described above.\n        \"\"\"", "\n", "assert", "self", ".", "model", ".", "training", ",", "\"[SimpleTrainer] model was changed to eval mode!\"", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "\"\"\"\n        If your want to do something with the data, you can wrap the dataloader.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "inputs", "=", "next", "(", "self", ".", "_data_loader_iter", ")", "\n", "", "except", "StopIteration", ":", "\n", "# Epoch has ended, reinitialize the iterator.", "\n", "            ", "self", ".", "_data_loader_iter", "=", "iter", "(", "self", ".", "data_loader", ")", "\n", "inputs", "=", "next", "(", "self", ".", "_data_loader_iter", ")", "\n", "\n", "", "data_time", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "\n", "\"\"\"\n        If your want to do something with the losses, you can wrap the model.\n        \"\"\"", "\n", "output_dict", "=", "self", ".", "model", "(", "inputs", ")", "\n", "output_dict", ".", "update", "(", "{", "k", ":", "inputs", "[", "k", "]", "for", "k", "in", "[", "\"mean\"", ",", "\"std\"", ",", "\"norm\"", "]", "if", "k", "in", "inputs", "}", ")", "\n", "loss_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "output_dict", ".", "items", "(", ")", "if", "\"loss\"", "in", "k", "}", "\n", "loss_dict", ".", "update", "(", "self", ".", "loss_computer", "(", "inputs", ",", "output_dict", ")", ")", "\n", "\n", "# losses = sum(v for k, v in loss_dict.items() if \"loss\" in k)", "\n", "losses", "=", "loss_dict", "[", "\"loss\"", "]", "\n", "self", ".", "_detect_anomaly", "(", "losses", ",", "loss_dict", ")", "\n", "\n", "metrics_dict", "=", "loss_dict", "\n", "metrics_dict", ".", "update", "(", "\n", "flatten_dict", "(", "\n", "{", "k", ":", "v", "for", "k", ",", "v", "in", "inputs", ".", "get", "(", "\"metrics\"", ",", "{", "}", ")", ".", "items", "(", ")", "if", "k", "not", "in", "metrics_dict", "}", "\n", ")", "\n", ")", "\n", "metrics_dict", "[", "\"data_time\"", "]", "=", "data_time", "\n", "metrics_dict", "[", "\"total_loss\"", "]", "=", "losses", "\n", "metrics_dict", ".", "update", "(", "self", ".", "metrics_computer", "(", "output_dict", ")", "if", "self", ".", "metrics_computer", "else", "{", "}", ")", "\n", "self", ".", "_write_metrics", "(", "metrics_dict", ")", "\n", "\n", "\"\"\"\n        If you need accumulate gradients or something similar, you can\n        wrap the optimizer with your custom `zero_grad()` method.\n        \"\"\"", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "\n", "\"\"\"\n        If you need gradient clipping/scaling or other processing, you can\n        wrap the optimizer with your custom `step()` method.\n        \"\"\"", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer._detect_anomaly": [[275, 280], ["torch.isfinite().all", "FloatingPointError", "torch.isfinite"], "methods", ["None"], ["", "def", "_detect_anomaly", "(", "self", ",", "losses", ",", "loss_dict", ")", ":", "\n", "        ", "if", "not", "torch", ".", "isfinite", "(", "losses", ")", ".", "all", "(", ")", ":", "\n", "            ", "raise", "FloatingPointError", "(", "\n", "\"Loss became infinite or NaN at iteration={}!\\n\"", "\n", "\"loss_dict = {}\"", ".", "format", "(", "self", ".", "iter", ",", "loss_dict", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.SimpleTrainer._write_metrics": [[282, 294], ["len", "train_loop.SimpleTrainer.storage.put_scalars", "isinstance", "torch.mean().item", "float", "metrics_dict.items", "torch.mean", "v.detach().cpu", "v.detach"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.put_scalars", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "", "def", "_write_metrics", "(", "self", ",", "metrics_dict", ":", "dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            metrics_dict (dict): dict of scalar metrics\n        \"\"\"", "\n", "metrics_dict", "=", "{", "\n", "k", ":", "torch", ".", "mean", "(", "v", ".", "detach", "(", ")", ".", "cpu", "(", ")", ")", ".", "item", "(", ")", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", "else", "float", "(", "v", ")", "\n", "for", "k", ",", "v", "in", "metrics_dict", ".", "items", "(", ")", "\n", "}", "\n", "\n", "if", "len", "(", "metrics_dict", ")", ">", "1", ":", "\n", "            ", "self", ".", "storage", ".", "put_scalars", "(", "**", "metrics_dict", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup.setUpClass": [[18, 21], ["dict"], "methods", ["None"], ["@", "classmethod", "\n", "def", "setUpClass", "(", "cls", ")", ":", "\n", "        ", "cls", ".", "_env", "=", "dict", "(", "os", ".", "environ", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup.tearDownClass": [[22, 25], ["cls._reset_env_vars"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_env_vars"], ["", "@", "classmethod", "\n", "def", "tearDownClass", "(", "cls", ")", ":", "\n", "        ", "cls", ".", "_reset_env_vars", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_env_vars": [[26, 30], ["os.environ.clear", "os.environ.update"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "@", "classmethod", "\n", "def", "_reset_env_vars", "(", "cls", ")", ":", "\n", "        ", "os", ".", "environ", ".", "clear", "(", ")", "\n", "os", ".", "environ", ".", "update", "(", "cls", ".", "_env", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_var": [[31, 40], ["os.environ.pop"], "methods", ["None"], ["", "def", "_reset_var", "(", "self", ",", "env_var", ",", "value", ",", "force", "=", "False", ")", ":", "\n", "        ", "if", "force", ":", "\n", "            ", "os", ".", "environ", "[", "env_var", "]", "=", "value", "\n", "return", "\n", "\n", "", "if", "value", "==", "\"\"", ":", "\n", "            ", "os", ".", "environ", ".", "pop", "(", "env_var", ",", "None", ")", "\n", "", "else", ":", "\n", "            ", "os", ".", "environ", "[", "env_var", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup.test_init_reproducible_mode": [[41, 85], ["meddlr.config.config.get_cfg", "meddlr.config.config.get_cfg.defrost", "meddlr.config.config.get_cfg.freeze", "meddlr.config.config.get_cfg.clone", "meddlr.engine.defaults.init_reproducible_mode", "meddlr.utils.env.is_repro", "test_defaults.TestDefaultSetup._reset_env_vars", "meddlr.config.config.get_cfg.clone", "meddlr.config.config.get_cfg.clone.defrost", "meddlr.config.config.get_cfg.clone.freeze", "meddlr.engine.defaults.init_reproducible_mode", "test_defaults.TestDefaultSetup._reset_env_vars", "meddlr.config.config.get_cfg.clone", "meddlr.config.config.get_cfg.clone.defrost", "meddlr.config.config.get_cfg.clone.freeze", "meddlr.engine.defaults.init_reproducible_mode", "test_defaults.TestDefaultSetup._reset_env_vars", "meddlr.config.config.get_cfg.clone", "meddlr.config.config.get_cfg.clone.defrost", "meddlr.config.config.get_cfg.clone.freeze", "meddlr.engine.defaults.init_reproducible_mode", "test_defaults.TestDefaultSetup._reset_env_vars"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.init_reproducible_mode", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_repro", "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_env_vars", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.init_reproducible_mode", "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_env_vars", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.init_reproducible_mode", "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_env_vars", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.init_reproducible_mode", "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup._reset_env_vars"], ["", "", "def", "test_init_reproducible_mode", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test that we properly initialize reproducibility.\"\"\"", "\n", "base_cfg", "=", "get_cfg", "(", ")", "\n", "base_cfg", ".", "defrost", "(", ")", "\n", "base_cfg", ".", "SEED", "=", "-", "1", "\n", "base_cfg", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "SEED", "=", "-", "1", "\n", "base_cfg", ".", "freeze", "(", ")", "\n", "\n", "os", ".", "environ", "[", "\"MEDDLR_REPRO\"", "]", "=", "\"\"", "\n", "cfg", "=", "base_cfg", ".", "clone", "(", ")", "\n", "init_reproducible_mode", "(", "cfg", ",", "eval_only", "=", "False", ")", "\n", "assert", "cfg", ".", "SEED", ">", "0", "\n", "assert", "cfg", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "SEED", ">", "0", "\n", "assert", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "\n", "assert", "not", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "\n", "assert", "env", ".", "is_repro", "(", ")", "\n", "self", ".", "_reset_env_vars", "(", ")", "\n", "\n", "cfg", "=", "base_cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "SEED", "=", "1000", "\n", "cfg", ".", "freeze", "(", ")", "\n", "init_reproducible_mode", "(", "cfg", ",", "eval_only", "=", "False", ")", "\n", "assert", "cfg", ".", "SEED", "==", "1000", "\n", "assert", "cfg", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "SEED", ">", "0", "\n", "assert", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "\n", "assert", "not", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "\n", "self", ".", "_reset_env_vars", "(", ")", "\n", "\n", "cfg", "=", "base_cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "CUDNN_BENCHMARK", "=", "True", "\n", "cfg", ".", "freeze", "(", ")", "\n", "init_reproducible_mode", "(", "cfg", ",", "eval_only", "=", "True", ")", "\n", "assert", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "\n", "self", ".", "_reset_env_vars", "(", ")", "\n", "\n", "cfg", "=", "base_cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "CUDNN_BENCHMARK", "=", "True", "\n", "cfg", ".", "freeze", "(", ")", "\n", "init_reproducible_mode", "(", "cfg", ",", "eval_only", "=", "False", ")", "\n", "assert", "not", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "\n", "self", ".", "_reset_env_vars", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_defaults.TestDefaultSetup.test_setup_cpu": [[86, 102], ["tempfile.mkdtemp", "meddlr.config.config.get_cfg", "types.SimpleNamespace", "meddlr.engine.defaults.default_setup", "os.path.exists", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.default_setup"], ["", "def", "test_setup_cpu", "(", "self", ")", ":", "\n", "        ", "tmpdir", "=", "tempfile", ".", "mkdtemp", "(", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "OUTPUT_DIR", "=", "tmpdir", "\n", "args", "=", "types", ".", "SimpleNamespace", "(", "\n", "reproducible", "=", "False", ",", "\n", "eval_only", "=", "False", ",", "\n", "auto_version", "=", "False", ",", "\n", "debug", "=", "False", ",", "\n", "devices", "=", "None", ",", "\n", "num_gpus", "=", "0", ",", "\n", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "tmpdir", ",", "\"config.yaml\"", ")", ")", "\n", "assert", "os", ".", "environ", "[", "\"CUDA_VISIBLE_DEVICES\"", "]", "==", "\"-1\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_model_zoo.TestModelZooExceptionsAndWarnings.test_get_model_from_zoo_dependency_warning": [[27, 32], ["test_model_zoo.TestModelZooExceptionsAndWarnings.assertWarnsRegex", "meddlr.engine.model_zoo.get_model_from_zoo"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.get_model_from_zoo"], ["def", "test_get_model_from_zoo_dependency_warning", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test that dependencies for configs get parsed.\"\"\"", "\n", "cfg_url", "=", "\"https://huggingface.co/datasets/arjundd/meddlr-data/raw/main/test-data/test-model/config-with-deps.yaml\"", "# noqa: E501", "\n", "with", "self", ".", "assertWarnsRegex", "(", "UserWarning", ",", "expected_regex", "=", "\".*dependencies.*\"", ")", ":", "\n", "            ", "get_model_from_zoo", "(", "cfg_url", ",", "force_download", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_model_zoo.test_get_model_from_zoo": [[34, 59], ["str", "meddlr.utils.env.get_path_manager", "meddlr.engine.model_zoo.get_model_from_zoo", "isinstance", "env.get_path_manager.get_local_path", "torch.load", "meddlr.engine.model_zoo.get_model_from_zoo.named_parameters", "meddlr.engine.model_zoo.get_model_from_zoo", "isinstance", "meddlr.config.config.get_cfg().merge_from_file", "meddlr.engine.model_zoo.get_model_from_zoo", "meddlr.engine.model_zoo.get_model_from_zoo.state_dict", "meddlr.engine.model_zoo.get_model_from_zoo.named_parameters", "torch.allclose", "type", "type", "env.get_path_manager.get_local_path", "torch.allclose", "meddlr.config.config.get_cfg"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.get_model_from_zoo", "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.get_model_from_zoo", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.get_model_from_zoo", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.state_dict", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg"], ["", "", "", "@", "util", ".", "temp_env", "\n", "def", "test_get_model_from_zoo", "(", ")", ":", "\n", "# Temporarily set cache dir to tmpdir", "\n", "    ", "os", ".", "environ", "[", "\"MEDDLR_CACHE_DIR\"", "]", "=", "str", "(", "util", ".", "TEMP_CACHE_DIR", "/", "\"test_get_model_from_zoo\"", ")", "\n", "\n", "path_mgr", "=", "env", ".", "get_path_manager", "(", ")", "\n", "\n", "model", "=", "get_model_from_zoo", "(", "_SAMPLE_MODEL_CFG", ",", "_SAMPLE_MODEL_WEIGHTS", ",", "force_download", "=", "True", ")", "\n", "assert", "isinstance", "(", "model", ",", "nn", ".", "Module", ")", "\n", "weights_path", "=", "path_mgr", ".", "get_local_path", "(", "_SAMPLE_MODEL_WEIGHTS", ")", "\n", "weights", "=", "torch", ".", "load", "(", "weights_path", ")", "\n", "for", "name", ",", "param", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "assert", "name", "in", "weights", "\n", "assert", "torch", ".", "allclose", "(", "param", ",", "weights", "[", "name", "]", ")", "\n", "\n", "", "model2", "=", "get_model_from_zoo", "(", "_SAMPLE_MODEL_CFG", ",", "force_download", "=", "True", ")", "\n", "assert", "isinstance", "(", "model2", ",", "nn", ".", "Module", ")", "\n", "assert", "type", "(", "model2", ")", "==", "type", "(", "model", ")", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", ".", "merge_from_file", "(", "path_mgr", ".", "get_local_path", "(", "_SAMPLE_MODEL_CFG", ")", ")", "\n", "model2", "=", "get_model_from_zoo", "(", "cfg", ",", "_SAMPLE_MODEL_WEIGHTS", ")", "\n", "state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "for", "name", ",", "param", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "assert", "name", "in", "state_dict", "\n", "assert", "torch", ".", "allclose", "(", "param", ",", "state_dict", "[", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_model_zoo.test_load_weights_shape_mismatch": [[61, 74], ["meddlr.utils.env.get_path_manager", "meddlr.config.config.get_cfg().merge_from_file", "meddlr.modeling.build_model", "meddlr.engine.model_zoo.load_weights", "env.get_path_manager.get_local_path", "torch.load", "meddlr.engine.model_zoo.load_weights.named_parameters", "env.get_path_manager.get_local_path", "torch.allclose", "meddlr.config.config.get_cfg"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.load_weights", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg"], ["", "", "def", "test_load_weights_shape_mismatch", "(", ")", ":", "\n", "    ", "path_mgr", "=", "env", ".", "get_path_manager", "(", ")", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", ".", "merge_from_file", "(", "path_mgr", ".", "get_local_path", "(", "_SAMPLE_MODEL_CFG", ")", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "model", ".", "resnets", "[", "0", "]", "=", "None", "\n", "model", "=", "load_weights", "(", "model", ",", "_SAMPLE_MODEL_WEIGHTS", ",", "ignore_shape_mismatch", "=", "True", ")", "\n", "\n", "weights_path", "=", "path_mgr", ".", "get_local_path", "(", "_SAMPLE_MODEL_WEIGHTS", ")", "\n", "weights", "=", "torch", ".", "load", "(", "weights_path", ")", "\n", "for", "name", ",", "param", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "assert", "name", "in", "weights", "\n", "assert", "torch", ".", "allclose", "(", "param", ",", "weights", "[", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_model_zoo.test_load_weights_find_device": [[76, 88], ["meddlr.utils.env.get_path_manager", "meddlr.config.config.get_cfg().merge_from_file", "meddlr.modeling.build_model", "meddlr.engine.model_zoo.load_weights", "env.get_path_manager.get_local_path", "torch.load", "meddlr.engine.model_zoo.load_weights.named_parameters", "env.get_path_manager.get_local_path", "torch.allclose", "meddlr.config.config.get_cfg"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.load_weights", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg"], ["", "", "def", "test_load_weights_find_device", "(", ")", ":", "\n", "    ", "path_mgr", "=", "env", ".", "get_path_manager", "(", ")", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", ".", "merge_from_file", "(", "path_mgr", ".", "get_local_path", "(", "_SAMPLE_MODEL_CFG", ")", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "model", "=", "load_weights", "(", "model", ",", "_SAMPLE_MODEL_WEIGHTS", ",", "find_device", "=", "False", ")", "\n", "\n", "weights_path", "=", "path_mgr", ".", "get_local_path", "(", "_SAMPLE_MODEL_WEIGHTS", ")", "\n", "weights", "=", "torch", ".", "load", "(", "weights_path", ")", "\n", "for", "name", ",", "param", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "assert", "name", "in", "weights", "\n", "assert", "torch", ".", "allclose", "(", "param", ",", "weights", "[", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_model_zoo.test_model_zoo_configs_for_projects": [[90, 127], ["pytest.mark.skipif", "pytest.mark.parametrize", "test_model_zoo._parse_model_zoo", "str", "_parse_model_zoo.items", "meddlr.utils.env.get_path_manager", "env.get_path_manager.get_local_path", "meddlr.check_dependencies", "len", "meddlr.engine.model_zoo.get_model_from_zoo", "isinstance", "type"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.engine.test_model_zoo._parse_model_zoo", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.config.util.check_dependencies", "home.repos.pwc.inspect_result.ad12_meddlr.engine.model_zoo.get_model_from_zoo"], ["", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "util", ".", "TEST_MODEL_ZOOS", ",", "reason", "=", "\"Model zoo testing not activated\"", ")", "\n", "@", "util", ".", "temp_env", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"project\"", ",", "[", "\"vortex\"", "]", ")", "\n", "def", "test_model_zoo_configs_for_projects", "(", "project", ")", ":", "\n", "    ", "\"\"\"\n    Test that all models in the zoo can be built with the appropriate config\n    and weight files.\n\n    Note:\n        This function does not test if the config can be used for training.\n        For now, the user must validate this manually.\n    \"\"\"", "\n", "model_zoo_file", "=", "REPO_DIR", "/", "\"projects\"", "/", "project", "/", "\"MODEL_ZOO.md\"", "\n", "models", "=", "_parse_model_zoo", "(", "model_zoo_file", ")", "\n", "\n", "# Temporarily set cache dir to tmpdir", "\n", "os", ".", "environ", "[", "\"MEDDLR_CACHE_DIR\"", "]", "=", "str", "(", "\n", "util", ".", "TEMP_CACHE_DIR", "/", "\"test_model_zoo_configs_for_projects\"", "/", "project", "\n", ")", "\n", "\n", "for", "name", ",", "model_info", "in", "models", ".", "items", "(", ")", ":", "\n", "# Skip models that have failed dependencies (for now).", "\n", "# TODO: Auto-configure github actions to run this test with different", "\n", "# combinations of dependencies.", "\n", "        ", "path_manager", "=", "env", ".", "get_path_manager", "(", ")", "\n", "cfg_file", "=", "path_manager", ".", "get_local_path", "(", "model_info", "[", "\"cfg_url\"", "]", ",", "force", "=", "True", ")", "\n", "failed_deps", "=", "config_util", ".", "check_dependencies", "(", "cfg_file", ",", "return_failed_deps", "=", "True", ")", "\n", "if", "len", "(", "failed_deps", ")", ">", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "try", ":", "\n", "            ", "model", "=", "get_model_from_zoo", "(", "\n", "model_info", "[", "\"cfg_url\"", "]", ",", "model_info", "[", "\"weights_url\"", "]", ",", "force_download", "=", "True", "\n", ")", "\n", "assert", "isinstance", "(", "model", ",", "nn", ".", "Module", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "raise", "type", "(", "e", ")", "(", "f\"Failed to build model '{name}':\\n{e}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.engine.test_model_zoo._parse_model_zoo": [[129, 163], ["util.parse_markdown", "node.to_dict().items", "open", "f.readlines", "line.strip", "re.match", "line.split", "columns[].strip", "re.search().group", "re.search().group", "node.to_dict", "test_model_zoo._parse_model_zoo._parse_model_line"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.parse_markdown", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict"], ["", "", "", "def", "_parse_model_zoo", "(", "model_zoo_file", ")", "->", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Any", "]", "]", ":", "\n", "    ", "\"\"\"Returns a dictionary representation of the model zoo.\n\n    This function parses the MODEL_ZOO.md file and returns a dictionary\n    mapping from the model name to the diction of model information.\n    \"\"\"", "\n", "\n", "def", "_has_model_line", "(", "line", ")", ":", "\n", "        ", "return", "re", ".", "match", "(", "\"^\\|.*\\[cfg\\].*$\"", ",", "line", ")", "is", "not", "None", "\n", "\n", "", "def", "_parse_model_line", "(", "line", ")", ":", "\n", "        ", "columns", "=", "line", ".", "split", "(", "\"|\"", ")", "[", "1", ":", "]", "\n", "return", "{", "\n", "\"name\"", ":", "columns", "[", "0", "]", ".", "strip", "(", ")", ",", "\n", "\"cfg_url\"", ":", "re", ".", "search", "(", "\"\\[cfg\\]\\((.+?)\\)\"", ",", "line", ")", ".", "group", "(", "1", ")", ",", "\n", "\"weights_url\"", ":", "re", ".", "search", "(", "\"\\[model\\]\\((.+?)\\)\"", ",", "line", ")", ".", "group", "(", "1", ")", ",", "\n", "}", "\n", "\n", "", "with", "open", "(", "model_zoo_file", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "lines", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "lines", "]", "\n", "lines", "=", "[", "line", "for", "line", "in", "lines", "if", "line", "]", "\n", "node", ",", "_", "=", "util", ".", "parse_markdown", "(", "lines", ")", "\n", "\n", "models", "=", "{", "}", "\n", "for", "heading", ",", "content", "in", "node", ".", "to_dict", "(", "flatten", "=", "True", ")", ".", "items", "(", ")", ":", "\n", "        ", "if", "not", "content", "or", "not", "any", "(", "_has_model_line", "(", "line", ")", "for", "line", "in", "content", ")", ":", "\n", "            ", "continue", "\n", "", "model_content", "=", "[", "line", "for", "line", "in", "content", "if", "_has_model_line", "(", "line", ")", "]", "\n", "\n", "for", "model_line", "in", "model_content", ":", "\n", "            ", "model_data", "=", "_parse_model_line", "(", "model_line", ")", "\n", "models", "[", "f\"{heading}/{model_data['name']}\"", "]", "=", "model_data", "\n", "", "", "return", "models", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.TransformCacheMixin._reset_transform": [[7, 9], ["None"], "methods", ["None"], ["    ", "def", "_reset_transform", "(", "self", ")", ":", "\n", "        ", "self", ".", "_transform", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.TransformCacheMixin.cached_transform": [[10, 12], ["None"], "methods", ["None"], ["", "def", "cached_transform", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_transform", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.to": [[17, 19], ["None"], "methods", ["None"], ["def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "self", ".", "_device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu": [[20, 22], ["mixins.DeviceMixin.to", "torch.device"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to"], ["", "def", "cpu", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "to", "(", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cuda": [[23, 25], ["mixins.DeviceMixin.to", "torch.device"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "to", "(", "torch", ".", "device", "(", "\"cuda\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.GeometricMixin.is_geometric": [[28, 30], ["None"], "methods", ["None"], ["    ", "def", "is_geometric", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen.__init__": [[27, 45], ["params.update", "transform_gen.TransformGen._set_attributes"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform._set_attributes"], ["def", "__init__", "(", "\n", "self", ",", "params", ":", "Dict", "[", "str", ",", "Any", "]", "=", "None", ",", "p", ":", "float", "=", "0.0", ",", "param_kinds", ":", "Dict", "[", "str", ",", "Any", "]", "=", "None", "\n", ")", "->", "None", ":", "\n", "        ", "from", "meddlr", ".", "transforms", ".", "tf_scheduler", "import", "TFScheduler", "\n", "\n", "self", ".", "_params", "=", "{", "}", "\n", "\n", "if", "params", "is", "None", ":", "\n", "            ", "params", "=", "{", "}", "\n", "", "if", "param_kinds", "is", "None", ":", "\n", "            ", "param_kinds", "=", "{", "}", "\n", "", "params", ".", "update", "(", "{", "\"p\"", ":", "p", "}", ")", "\n", "self", ".", "_set_attributes", "(", "params", ")", "\n", "self", ".", "_param_kinds", "=", "param_kinds", "\n", "self", ".", "_schedulers", ":", "Sequence", "[", "TFScheduler", "]", "=", "[", "]", "\n", "\n", "self", ".", "_generator", "=", "None", "\n", "self", ".", "_device", "=", "\"cpu\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._set_attributes": [[46, 53], ["params.update", "transform_gen.TransformGen._params.update", "params.items", "k.startswith"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "_set_attributes", "(", "self", ",", "params", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "params", "is", "None", ":", "\n", "            ", "params", "=", "{", "}", "\n", "", "params", ".", "update", "(", "kwargs", ")", "\n", "if", "params", ":", "\n", "            ", "self", ".", "_params", ".", "update", "(", "\n", "{", "k", ":", "v", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", "if", "k", "!=", "\"self\"", "and", "not", "k", ".", "startswith", "(", "\"_\"", ")", "}", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen.get_transform": [[55, 57], ["None"], "methods", ["None"], ["", "", "def", "get_transform", "(", "self", ",", "input", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen.reset": [[58, 60], ["transform_gen.TransformGen._reset_transform"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.TransformCacheMixin._reset_transform"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_reset_transform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen.__getattr__": [[61, 65], ["AttributeError", "type"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "if", "name", "in", "self", ".", "_params", ":", "\n", "            ", "return", "self", ".", "_params", "[", "name", "]", "\n", "", "raise", "AttributeError", "(", "f\"Attribute '{name}' does not exist in class {type(self)}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values": [[66, 74], ["transform_gen.TransformGen._params.copy", "transform_gen.TransformGen.update", "s.get_params"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.get_params"], ["", "def", "_get_param_values", "(", "self", ",", "use_schedulers", "=", "False", ")", ":", "\n", "        ", "if", "not", "use_schedulers", ":", "\n", "            ", "return", "self", ".", "_params", "\n", "\n", "", "params", "=", "self", ".", "_params", ".", "copy", "(", ")", "\n", "for", "s", "in", "self", ".", "_schedulers", ":", "\n", "            ", "params", ".", "update", "(", "s", ".", "get_params", "(", ")", ")", "\n", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand": [[75, 82], ["torch.rand().cpu().item", "torch.rand().cpu", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "def", "_rand", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"Uniform sample between [0, 1) using ``self._generator``.\n\n        Returns:\n            float: The sample between [0, 1).\n        \"\"\"", "\n", "return", "torch", ".", "rand", "(", "1", ",", "generator", "=", "self", ".", "_generator", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_choice": [[83, 98], ["torch.multinomial().cpu().item", "torch.ones", "torch.multinomial().cpu", "torch.multinomial", "probs.to"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to"], ["", "def", "_rand_choice", "(", "self", ",", "n", "=", "None", ",", "probs", ":", "torch", ".", "Tensor", "=", "None", ")", "->", "int", ":", "\n", "        ", "\"\"\"Chooses random integer between [0, n-1].\n\n        Args:\n            n (int): Number of choices. This is required if ``probs``\n                is not specified.\n            probs (torch.Tensor): The probability tensor.\n\n        Returns:\n            int: The index of the selected choice.\n        \"\"\"", "\n", "device", "=", "\"cpu\"", "if", "self", ".", "_generator", "is", "None", "else", "self", ".", "_generator", ".", "device", "\n", "if", "probs", "is", "None", ":", "\n", "            ", "probs", "=", "torch", ".", "ones", "(", "n", ",", "device", "=", "device", ")", "/", "n", "\n", "", "return", "torch", ".", "multinomial", "(", "probs", ".", "to", "(", "device", ")", ",", "1", ",", "generator", "=", "self", ".", "_generator", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range": [[99, 121], ["torch.rand"], "methods", ["None"], ["", "def", "_rand_range", "(", "self", ",", "low", ",", "high", ",", "size", ":", "int", "=", "None", ")", ":", "\n", "        ", "\"\"\"Uniform float random number between [low, high).\n\n        Args:\n            low (number-like): The lower bound.\n            high (number-like): The upper bound.\n            size (int): Number of samples to draw in the range.\n\n        Returns:\n            float: A uniformly sampled number in range [low, high).\n        \"\"\"", "\n", "if", "size", "is", "None", ":", "\n", "            ", "size", "=", "1", "\n", "\n", "", "if", "low", ">", "high", ":", "\n", "            ", "high", ",", "low", "=", "low", ",", "high", "\n", "\n", "", "if", "high", "-", "low", "==", "0", ":", "\n", "            ", "val", "=", "low", "\n", "", "else", ":", "\n", "            ", "val", "=", "(", "low", "+", "(", "high", "-", "low", ")", "*", "torch", ".", "rand", "(", "size", ",", "generator", "=", "self", ".", "_generator", ")", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "", "return", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._format_param": [[122, 139], ["isinstance", "isinstance", "len", "isinstance", "type", "out.append", "isinstance", "out.append", "ValueError", "type"], "methods", ["None"], ["", "def", "_format_param", "(", "self", ",", "val", ",", "kind", ":", "ParamKind", ",", "ndim", "=", "None", ")", ":", "\n", "        ", "if", "kind", "==", "ParamKind", ".", "MULTI_ARG", ":", "\n", "            ", "if", "isinstance", "(", "val", ",", "Number", ")", ":", "\n", "                ", "return", "(", "(", "-", "val", ",", "val", ")", ",", ")", "*", "ndim", "\n", "", "elif", "isinstance", "(", "val", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "                ", "out", "=", "[", "]", "\n", "if", "len", "(", "val", ")", "==", "1", ":", "\n", "                    ", "val", "=", "val", "*", "ndim", "\n", "", "for", "v", "in", "val", ":", "\n", "                    ", "if", "isinstance", "(", "v", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "                        ", "out", ".", "append", "(", "v", ")", "\n", "", "elif", "isinstance", "(", "v", ",", "Number", ")", ":", "\n", "                        ", "out", ".", "append", "(", "(", "-", "v", ",", "v", ")", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "ValueError", "(", "f\"Type {type(val)} not supported - val={val}\"", ")", "\n", "", "", "return", "type", "(", "val", ")", "(", "out", ")", "\n", "", "", "return", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen.seed": [[140, 143], ["torch.Generator().manual_seed", "torch.Generator"], "methods", ["None"], ["", "def", "seed", "(", "self", ",", "value", ":", "int", ")", ":", "\n", "        ", "self", ".", "_generator", "=", "torch", ".", "Generator", "(", "device", "=", "self", ".", "_device", ")", ".", "manual_seed", "(", "value", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen.__repr__": [[144, 170], ["inspect.signature", "inspect.signature.parameters.items", "type", "hasattr", "getattr", "argstr.append", "meddlr.transforms.mixins.DeviceMixin.__repr__", "pprint.pformat"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Produce something like:\n        \"MyTransformGen(field1={self.field1}, field2={self.field2})\"\n        \"\"\"", "\n", "try", ":", "\n", "            ", "sig", "=", "inspect", ".", "signature", "(", "self", ".", "__init__", ")", "\n", "classname", "=", "type", "(", "self", ")", ".", "__name__", "\n", "argstr", "=", "[", "]", "\n", "for", "name", ",", "param", "in", "sig", ".", "parameters", ".", "items", "(", ")", ":", "\n", "                ", "assert", "(", "\n", "param", ".", "kind", "!=", "param", ".", "VAR_POSITIONAL", "and", "param", ".", "kind", "!=", "param", ".", "VAR_KEYWORD", "\n", ")", ",", "\"The default __repr__ doesn't support *args or **kwargs\"", "\n", "assert", "hasattr", "(", "self", ",", "name", ")", ",", "(", "\n", "\"Attribute {} not found! \"", "\n", "\"Default __repr__ only works if attributes match \"", "\n", "\"the constructor.\"", ".", "format", "(", "name", ")", "\n", ")", "\n", "attr", "=", "getattr", "(", "self", ",", "name", ")", "\n", "default", "=", "param", ".", "default", "\n", "if", "default", "is", "attr", ":", "\n", "                    ", "continue", "\n", "", "argstr", ".", "append", "(", "\"{}={}\"", ".", "format", "(", "name", ",", "pprint", ".", "pformat", "(", "attr", ")", ")", ")", "\n", "", "return", "\"{}({})\"", ".", "format", "(", "classname", ",", "\", \"", ".", "join", "(", "argstr", ")", ")", "\n", "", "except", "AssertionError", ":", "\n", "            ", "return", "super", "(", ")", ".", "__repr__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen.__str__": [[171, 173], ["transform_gen.TransformGen.__repr__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.__repr__"], ["", "", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "__repr__", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_transforms": [[22, 39], ["isinstance", "build._build_transform", "build.seed_tfm_gens"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.build._build_transform", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.seed_tfm_gens"], ["\n", "def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "return", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "\n", "\n", "", "def", "initialize_model", "(", "model", ":", "nn", ".", "Module", ",", "initializers", ":", "Union", "[", "Dict", ",", "Tuple", "]", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build._build_transform": [[41, 69], ["tfm_cfg.copy.copy", "tfm_cfg.copy.pop", "tfm_cfg.copy.pop", "TRANSFORM_REGISTRY.get", "init_args.update", "hasattr", "isinstance", "tfm_gen.register_schedulers", "tfm_cfg.copy.pop", "inspect.signature", "TRANSFORM_REGISTRY.get.from_dict", "isinstance", "build.build_scheduler", "TRANSFORM_REGISTRY.get.", "TypeError", "RecursionError", "kwargs.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.from_dict", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_scheduler", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["\n", "_kind_kwd", "=", "\"kind\"", "\n", "_pattern_kwd", "=", "\"patterns\"", "\n", "_init_kwd", "=", "\"initializers\"", "\n", "\n", "if", "isinstance", "(", "initializers", ",", "Dict", ")", ":", "\n", "        ", "initializers", "=", "[", "initializers", "]", "\n", "\n", "# Backwards compatibility with pattern-only initialization.", "\n", "", "if", "isinstance", "(", "initializers", ",", "Sequence", ")", "and", "not", "any", "(", "isinstance", "(", "x", ",", "Dict", ")", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "assert", "len", "(", "initializers", ")", "%", "2", "==", "0", ",", "\"Sequence of regex_to_init must be even\"", "\n", "initializers", "=", "[", "\n", "{", "_pattern_kwd", ":", "k", ",", "_init_kwd", ":", "v", "}", "for", "k", ",", "v", "in", "zip", "(", "initializers", "[", ":", ":", "2", "]", ",", "initializers", "[", "1", ":", ":", "2", "]", ")", "\n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_scheduler": [[71, 104], ["scheduler_cfg.copy.copy", "scheduler_cfg.copy.pop", "scheduler_cfg.copy.pop", "ValueError", "meddlr.transforms.tf_scheduler.WarmupMultiStepTF", "meddlr.transforms.tf_scheduler.WarmupTF", "scheduler_cfg.copy.pop", "isinstance", "scheduler_cfg.copy.pop", "tuple", "dict", "dict.update", "meddlr.transforms.tf_scheduler.WarmupMultiStepTF", "len", "ValueError", "scheduler_cfg.copy.pop", "range", "scheduler_cfg.copy.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "initializers", "=", "_to_literal", "(", "initializers", ")", "\n", "\n", "if", "not", "all", "(", "\n", "isinstance", "(", "x", ",", "Dict", ")", "or", "(", "isinstance", "(", "x", ",", "Sequence", ")", "and", "len", "(", "x", ")", "==", "2", ")", "for", "x", "in", "initializers", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"All initializers must either be a dict or sequence of 2 elements \"", "\n", "\"(pattern, initializer). Got:\\n\\t{}\"", ".", "format", "(", "initializers", ")", "\n", ")", "\n", "\n", "", "initializers", ":", "List", "[", "Dict", "]", "=", "[", "\n", "{", "_pattern_kwd", ":", "x", "[", "0", "]", ",", "_init_kwd", ":", "x", "[", "1", "]", "}", "if", "isinstance", "(", "x", ",", "Sequence", ")", "else", "x", "\n", "for", "x", "in", "initializers", "\n", "]", "\n", "matched_patterns", "=", "{", "}", "\n", "for", "init_cfg", "in", "initializers", ":", "\n", "        ", "pattern", "=", "init_cfg", ".", "pop", "(", "_pattern_kwd", ",", "None", ")", "\n", "if", "pattern", "is", "None", ":", "\n", "            ", "pattern", "=", "(", "\".*\"", ",", ")", "\n", "", "elif", "not", "isinstance", "(", "pattern", ",", "Sequence", ")", "or", "isinstance", "(", "pattern", ",", "str", ")", ":", "\n", "            ", "pattern", "=", "(", "pattern", ",", ")", "\n", "\n", "", "init_method", "=", "init_cfg", ".", "pop", "(", "_init_kwd", ")", "\n", "if", "not", "isinstance", "(", "init_method", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "init_method", "=", "(", "init_method", ",", ")", "\n", "\n", "", "if", "len", "(", "pattern", ")", "!=", "len", "(", "init_method", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Got {} pattern(s) but {} initializer(s):\\n\\t\"", "\n", "\"Patterns: {}\\n\\tInitializers: {}\"", ".", "format", "(", "\n", "len", "(", "pattern", ")", ",", "len", "(", "init_method", ")", ",", "pattern", ",", "init_method", "\n", ")", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.seed_tfm_gens": [[106, 114], ["numpy.random.RandomState", "isinstance", "t.seed", "int", "np.random.RandomState.rand"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed"], ["(", "p", ",", ")", "if", "not", "isinstance", "(", "p", ",", "Sequence", ")", "or", "isinstance", "(", "p", ",", "str", ")", "else", "p", "for", "p", "in", "pattern", "\n", ")", "\n", "\n", "init_method", "=", "[", "\n", "getattr", "(", "nn", ".", "init", ",", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "str", ")", "\n", "else", "(", "getattr", "(", "nn", ".", "init", ",", "v", "[", "0", "]", ")", ",", "v", "[", "1", "]", ")", "\n", "if", "isinstance", "(", "v", ",", "Sequence", ")", "\n", "else", "v", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_iter_func": [[116, 124], ["int", "multiprocessing.current_process().name.split", "multiprocessing.current_process"], "function", ["None"], ["]", "\n", "init_cfg", "[", "_init_kwd", "]", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "pattern", ",", "init_method", ")", "}", "\n", "for", "pattern_val", "in", "pattern", ":", "\n", "            ", "key", "=", "(", "init_cfg", "[", "_kind_kwd", "]", ",", "pattern_val", ")", "if", "_kind_kwd", "in", "init_cfg", "else", "pattern_val", "\n", "matched_patterns", "[", "key", "]", "=", "False", "\n", "\n", "", "", "model_layers", "=", "{", "}", "\n", "if", "any", "(", "_kind_kwd", "in", "x", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "model_layers", ":", "Dict", "[", "str", ",", "nn", ".", "Module", "]", "=", "_get_model_layers", "(", "model", ",", "by_kind", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.__init__": [[54, 76], ["weakref.proxy", "tf_scheduler.TFScheduler._register_parameters", "meddlr.utils.env.is_main_process", "RuntimeError", "type"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._register_parameters", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process"], ["def", "__init__", "(", "\n", "self", ",", "tfm", ",", "params", ":", "Union", "[", "str", ",", "List", "[", "str", "]", ",", "Tuple", "[", "str", "]", "]", "=", "None", ",", "iter_fn", ":", "Callable", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tfm (SchedulableMixin): An instance of :cls:`SchedulableMixin`.\n                Typically a transform.\n            params (List[str]): Parameter name(s) for ``tfm`` that should be scheduled.\n                These parameters should be accessible from ``tfm._params``.\n            iter_fn (Callable): A function that returns the current iteration.\n                This function should take in one argument, ``self._step``.\n                Only used when the scheduler is being used across multiple workers\n                (e.g. data loading).\n        \"\"\"", "\n", "if", "not", "env", ".", "is_main_process", "(", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"{type(self)} must be constructed on the main thread.\"", ")", "\n", "\n", "", "self", ".", "tfm", ":", "SchedulableMixin", "=", "weakref", ".", "proxy", "(", "tfm", ")", "\n", "self", ".", "_params", "=", "[", "]", "\n", "self", ".", "_register_parameters", "(", "params", ")", "\n", "self", ".", "_iter_fn", "=", "iter_fn", "\n", "self", ".", "_step", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.get_params": [[77, 91], ["tf_scheduler.TFScheduler._parameter_names", "tf_scheduler.TFScheduler.tfm._param_kinds.get", "tf_scheduler.TFScheduler._fill_param_dict", "tf_scheduler.TFScheduler._compute_value", "tf_scheduler.TFScheduler._get_tfm_param_val"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._parameter_names", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._fill_param_dict", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF._compute_value", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._get_tfm_param_val"], ["", "def", "get_params", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"Returns dictionary of ``self.tfm`` parameters after scheduling.\n\n        Returns:\n            Dict[str, Any]: The parameters after being passed through the scheduler.\n        \"\"\"", "\n", "names", "=", "self", ".", "_parameter_names", "(", ")", "\n", "params", "=", "{", "}", "\n", "for", "pname", "in", "names", ":", "\n", "            ", "kind", "=", "self", ".", "tfm", ".", "_param_kinds", ".", "get", "(", "pname", ",", "ParamKind", ".", "SINGLE_ARG", ")", "\n", "self", ".", "_fill_param_dict", "(", "\n", "params", ",", "pname", ",", "self", ".", "_compute_value", "(", "self", ".", "_get_tfm_param_val", "(", "pname", ")", ",", "kind", ")", "\n", ")", "\n", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.get_iteration": [[92, 114], ["meddlr.utils.env.is_main_process", "tf_scheduler.TFScheduler._iter_fn", "meddlr.utils.events.get_event_storage", "meddlr.utils.events.get_event_storage"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage"], ["", "def", "get_iteration", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"Returns the estimated iteration.\n\n        Returns:\n            int: The estimated iteration.\n        \"\"\"", "\n", "if", "env", ".", "is_main_process", "(", ")", ":", "\n", "            ", "return", "get_event_storage", "(", ")", ".", "iter", "\n", "\n", "# The EventStorage object is not always synchronized betweeen different", "\n", "# forks. Therefore, directly accessing get_event_storage().iter may not", "\n", "# give the correct iteration estimate. `self._step` keeps track of changes", "\n", "# in iterations for each worker based on the computation from `self._iter_fn`.", "\n", "# `self._step` is and should always be 0 on the main process. In other words,", "\n", "# it is only updated on each worker and is reset to 0 everytime states are", "\n", "# synchronized.", "\n", "# Therefore, the true iteration count can be estimated by adding the", "\n", "# iteration number from EventStorage with the estimated elapsed iteration", "\n", "# between synchronization periods given by `self._iter_fn(self._step)`.", "\n", "", "base_iter", "=", "get_event_storage", "(", ")", ".", "iter", "\n", "delta_iter", "=", "self", ".", "_iter_fn", "(", "self", ".", "_step", ")", "\n", "return", "base_iter", "+", "delta_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.step": [[115, 135], ["meddlr.utils.env.is_main_process"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process"], ["", "def", "step", "(", "self", ",", "n", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"Take ``n`` step(s).\n\n        This function is used to maintain the step count\n        used to compute the current iteration number.\n        ``n`` should be configured to be compatible with ``self._iter_fn``.\n        If you are using :func:`build_iter_func`, ``n`` should correspond\n        to the number of examples in the batch.\n\n        This function does not do anything if ``self`` is executing on the\n        main thread.\n\n        Args:\n            n (int): The number of steps/examples to increase internal\n                step count by.\n        \"\"\"", "\n", "if", "env", ".", "is_main_process", "(", ")", ":", "\n", "            ", "return", "\n", "\n", "", "self", ".", "_step", "+=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._compute_value": [[136, 138], ["None"], "methods", ["None"], ["", "def", "_compute_value", "(", "self", ",", "value", ",", "param_kind", ":", "ParamKind", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._parameter_names": [[139, 141], ["list", "tf_scheduler.TFScheduler.tfm.params().keys", "tf_scheduler.TFScheduler.tfm.params"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "def", "_parameter_names", "(", "self", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "return", "self", ".", "_params", "if", "self", ".", "_params", "is", "not", "None", "else", "list", "(", "self", ".", "tfm", ".", "params", "(", ")", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._get_tfm_keys": [[142, 154], ["tf_scheduler.TFScheduler._get_tfm_keys._dfs_pname"], "methods", ["None"], ["", "def", "_get_tfm_keys", "(", "self", ")", ":", "\n", "        ", "def", "_dfs_pname", "(", "params", ",", "prefix", "=", "\"\"", ")", ":", "\n", "            ", "out", "=", "[", "]", "\n", "if", "isinstance", "(", "params", ",", "Mapping", ")", ":", "\n", "                ", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", ":", "\n", "                    ", "out", ".", "extend", "(", "_dfs_pname", "(", "v", ",", "f\"{prefix}.{k}\"", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "out", ".", "append", "(", "prefix", ")", "\n", "", "return", "out", "\n", "\n", "", "out", "=", "_dfs_pname", "(", "self", ".", "tfm", ".", "_params", ")", "\n", "return", "[", "x", "[", "1", ":", "]", "if", "x", ".", "startswith", "(", "\".\"", ")", "else", "x", "for", "x", "in", "out", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._register_parameters": [[155, 172], ["isinstance", "tf_scheduler.TFScheduler._get_tfm_keys", "tf_scheduler.TFScheduler._parameter_names", "tf_scheduler.TFScheduler._params.extend", "set", "len", "ValueError", "any", "set", "set", "any", "x.startswith", "x.startswith"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._get_tfm_keys", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._parameter_names", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "def", "_register_parameters", "(", "self", ",", "names", ":", "Union", "[", "str", ",", "Sequence", "[", "str", "]", "]", ")", ":", "\n", "# TODO (arjundd): names=None does not work.", "\n", "        ", "if", "isinstance", "(", "names", ",", "str", ")", ":", "\n", "            ", "names", "=", "[", "names", "]", "\n", "\n", "", "tfm_keys", "=", "self", ".", "_get_tfm_keys", "(", ")", "\n", "unmatched_names", "=", "[", "n", "for", "n", "in", "names", "if", "not", "any", "(", "x", ".", "startswith", "(", "n", ")", "for", "x", "in", "tfm_keys", ")", "]", "\n", "names", "=", "[", "x", "for", "x", "in", "tfm_keys", "if", "any", "(", "x", ".", "startswith", "(", "n", ")", "for", "n", "in", "names", ")", "]", "\n", "unknown_params", "=", "(", "set", "(", "names", ")", "-", "set", "(", "tfm_keys", ")", ")", "|", "set", "(", "unmatched_names", ")", "\n", "if", "len", "(", "unknown_params", ")", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Unknown parameters for transform {self.tfm.__class__.__name__}: {unknown_params}\"", "\n", ")", "\n", "\n", "", "params", "=", "self", ".", "_parameter_names", "(", ")", "\n", "params", "=", "[", "n", "for", "n", "in", "names", "if", "n", "not", "in", "params", "]", "\n", "self", ".", "_params", ".", "extend", "(", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._unregister_parameters": [[173, 180], ["isinstance", "tf_scheduler.TFScheduler._parameter_names", "tf_scheduler.TFScheduler._get_tfm_keys", "any", "x.startswith"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._parameter_names", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._get_tfm_keys"], ["", "def", "_unregister_parameters", "(", "self", ",", "names", ":", "Union", "[", "str", ",", "Sequence", "[", "str", "]", "]", ")", ":", "\n", "        ", "if", "isinstance", "(", "names", ",", "str", ")", ":", "\n", "            ", "names", "=", "[", "names", "]", "\n", "", "names", "=", "[", "x", "for", "x", "in", "self", ".", "_get_tfm_keys", "(", ")", "if", "any", "(", "x", ".", "startswith", "(", "n", ")", "for", "n", "in", "names", ")", "]", "\n", "params", "=", "self", ".", "_parameter_names", "(", ")", "\n", "params", "=", "[", "x", "for", "x", "in", "params", "if", "x", "not", "in", "names", "]", "\n", "self", ".", "_params", "=", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._get_tfm_param_val": [[181, 190], ["tf_scheduler._parse_pname", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler._parse_pname"], ["", "def", "_get_tfm_param_val", "(", "self", ",", "pname", ":", "str", ")", ":", "\n", "        ", "pname", "=", "_parse_pname", "(", "pname", ")", "\n", "if", "isinstance", "(", "pname", ",", "str", ")", ":", "\n", "            ", "return", "self", ".", "tfm", ".", "_params", "[", "pname", "]", "\n", "\n", "", "pval", "=", "self", ".", "tfm", ".", "_params", "\n", "for", "pn", "in", "pname", ":", "\n", "            ", "pval", "=", "pval", "[", "pn", "]", "\n", "", "return", "pval", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._fill_param_dict": [[191, 201], ["tf_scheduler._parse_pname", "isinstance", "enumerate", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler._parse_pname"], ["", "def", "_fill_param_dict", "(", "self", ",", "params", ":", "Dict", ",", "pname", ":", "str", ",", "pval", ")", ":", "\n", "        ", "pname", "=", "_parse_pname", "(", "pname", ")", "\n", "if", "isinstance", "(", "pname", ",", "str", ")", ":", "\n", "            ", "params", "[", "pname", "]", "=", "pval", "\n", "return", "\n", "\n", "", "for", "idx", ",", "pn", "in", "enumerate", "(", "pname", ")", ":", "\n", "            ", "if", "pn", "not", "in", "params", ":", "\n", "                ", "params", "[", "pn", "]", "=", "pval", "if", "idx", "==", "len", "(", "pname", ")", "-", "1", "else", "{", "}", "\n", "", "params", "=", "params", "[", "pn", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._repr_args": [[202, 204], ["None"], "methods", ["None"], ["", "", "def", "_repr_args", "(", "self", ")", "->", "List", "[", "str", "]", ":", "# pragma: no cover", "\n", "        ", "return", "[", "\"tfm\"", ",", "\"_params\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.__repr__": [[205, 212], ["tf_scheduler.TFScheduler._repr_args", "getattr", "type", "tf_scheduler.TFScheduler.items", "hasattr", "v.__repr__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF._repr_args", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.__repr__"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "args", "=", "self", ".", "_repr_args", "(", ")", "\n", "args", "=", "{", "k", ":", "getattr", "(", "self", ",", "k", ")", "for", "k", "in", "args", "}", "\n", "args_str", "=", "\"\\n  \"", ".", "join", "(", "\n", "[", "f\"{k}={v.__repr__() if hasattr(v, '__repr__') else v},\"", "for", "k", ",", "v", "in", "args", ".", "items", "(", ")", "]", "\n", ")", "\n", "return", "\"{}(\\n  {}\\n)\"", ".", "format", "(", "type", "(", "self", ")", ".", "__name__", ",", "args_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.__str__": [[213, 215], ["tf_scheduler.TFScheduler.__repr__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.__repr__"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "__repr__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.base_params": [[224, 233], ["None"], "methods", ["None"], ["def", "base_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"The base that defines the maximum value or range for different parameters.\n\n        Currently, this only supports numeric parameter types.\n\n        Returns:\n            Dict[str, Any]: The maximum value or range of different parameters.\n        \"\"\"", "\n", "return", "self", ".", "_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.validate_schedulers": [[234, 258], ["range", "any", "set", "len", "range", "ValueError", "len", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "def", "validate_schedulers", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Verifies that schedulers are valid.\n\n        A valid set of schedulers must fulfill at least the following criteria:\n            1. Any two different schedulers should not operate on any of the same paramters.\n            2. All schedulers must have a weak reference to this schedulable.\n\n        Raises:\n            ValueError: If parameters overlap between any two schedulers\n                or schedulers do not have a weakref to this schedulable.\n        \"\"\"", "\n", "schedulers", "=", "self", ".", "_schedulers", "\n", "\n", "# No parameters should overlap between schedulers.", "\n", "all_params", "=", "[", "set", "(", "scheduler", ".", "_params", ")", "for", "scheduler", "in", "schedulers", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "all_params", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "all_params", ")", ")", ":", "\n", "                ", "if", "len", "(", "all_params", "[", "i", "]", "&", "all_params", "[", "j", "]", ")", ">", "0", ":", "\n", "                    ", "raise", "ValueError", "(", "f\"Parameters overlapping between schedulers {i} and {j}\"", ")", "\n", "\n", "# All schedulers should be tied to this schedulable.", "\n", "", "", "", "if", "any", "(", "s", ".", "tfm", "!=", "self", ".", "__weakref__", "for", "s", "in", "self", ".", "_schedulers", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Schedulers can only be configured for the transform it is registered to\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers": [[260, 285], ["isinstance", "tf_scheduler.SchedulableMixin._schedulers.extend", "tf_scheduler.SchedulableMixin.validate_schedulers", "s._unregister_parameters", "s._parameter_names", "s._parameter_names"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.validate_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._unregister_parameters", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._parameter_names", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._parameter_names"], ["", "", "def", "register_schedulers", "(", "\n", "self", ",", "schedulers", ":", "Sequence", "[", "TFScheduler", "]", ",", "overwrite_params", ":", "bool", "=", "False", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"Register scheduler(s).\n\n        Args:\n            schedulers (Sequence[TFScheduler]): The sequence of schedulers to\n                register. These schedulers will be used to operate on certain\n                parameters.\n            overwrite_params (bool, optional): If ``True``, more recently added\n                schedulers will have exclusive priority to manage parameter values.\n                For example, if schedulers ``A`` and ``B`` were to be added in that\n                order, and they were both configured to operate on some parameter\n                ``param1``, then ``B``'s scheduling would be used, as it is the most\n                recent scheduler.\n        \"\"\"", "\n", "if", "isinstance", "(", "schedulers", ",", "TFScheduler", ")", ":", "\n", "            ", "schedulers", "=", "[", "schedulers", "]", "\n", "", "if", "overwrite_params", ":", "\n", "            ", "new_params", "=", "[", "name", "for", "s", "in", "schedulers", "for", "name", "in", "s", ".", "_parameter_names", "(", ")", "]", "\n", "for", "s", "in", "self", ".", "_schedulers", ":", "\n", "                ", "s", ".", "_unregister_parameters", "(", "[", "p", "for", "p", "in", "new_params", "if", "p", "in", "s", ".", "_parameter_names", "(", ")", "]", ")", "\n", "\n", "", "", "self", ".", "_schedulers", ".", "extend", "(", "schedulers", ")", "\n", "self", ".", "validate_schedulers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.schedulers": [[286, 288], ["None"], "methods", ["None"], ["", "def", "schedulers", "(", "self", ")", "->", "List", "[", "TFScheduler", "]", ":", "\n", "        ", "return", "self", ".", "_schedulers", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupTF.__init__": [[306, 344], ["logging.getLogger", "tf_scheduler.TFScheduler.__init__", "ValueError", "ValueError", "logging.getLogger.warning"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "tfm", ":", "SchedulableMixin", ",", "\n", "warmup_iters", ":", "int", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "delay_iters", ":", "int", "=", "0", ",", "\n", "gamma", ":", "float", "=", "1.0", ",", "\n", "params", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tfm: See :cls:`TFScheduler`.\n            warmup_iters (int): Number of iterations to warmup.\n            warmup_method (str, optional): One of [``'linear'``, ``'exp'``].\n            delay_iters (int, optional): Number of iterations to delay scheduling by.\n            gamma (float, optional): Scaling factor for time constant in exponential (``'exp'``)\n                scheduling.\n            params: See :cls:`TFScheduler`.\n        \"\"\"", "\n", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "if", "warmup_method", "not", "in", "(", "\"linear\"", ",", "\"exp\"", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"`warmup_method` must be one of (None, 'linear', 'exp'). Got '{warmup_method}'\"", "\n", ")", "\n", "", "if", "gamma", "<", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"gamma must be >=0\"", ")", "\n", "", "if", "warmup_iters", "==", "0", "and", "delay_iters", "==", "0", ":", "\n", "            ", "_logger", ".", "warning", "(", "\n", "\"No warmup or delay time specified. \"", "\"This will functionally be a no-op scheduler.\"", "\n", ")", "\n", "\n", "", "self", ".", "delay_iters", "=", "delay_iters", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "tfm", ",", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupTF._compute_value": [[345, 365], ["isinstance", "tf_scheduler._get_warmup_factor_at_iter", "tuple", "isinstance", "tf_scheduler.WarmupTF.get_iteration", "tf_scheduler.WarmupTF._compute_value", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler._get_warmup_factor_at_iter", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.get_iteration", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF._compute_value"], ["", "def", "_compute_value", "(", "self", ",", "value", ",", "kind", ":", "ParamKind", ")", ":", "\n", "        ", "if", "kind", "==", "ParamKind", ".", "MULTI_ARG", "and", "isinstance", "(", "value", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "return", "[", "self", ".", "_compute_value", "(", "v", ",", "kind", ".", "SINGLE_ARG", ")", "for", "v", "in", "value", "]", "\n", "\n", "", "is_number", "=", "isinstance", "(", "value", ",", "Number", ")", "\n", "if", "is_number", ":", "\n", "            ", "value", "=", "(", "0", ",", "value", ")", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "value", ",", "Sequence", ")", "and", "len", "(", "value", ")", "==", "2", "\n", "\n", "", "alpha", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "\n", "self", ".", "get_iteration", "(", ")", ",", "\n", "self", ".", "warmup_iters", ",", "\n", "self", ".", "delay_iters", ",", "\n", "self", ".", "gamma", ",", "\n", ")", "\n", "lb", ",", "ub", "=", "tuple", "(", "value", ")", "\n", "ub", "=", "lb", "+", "alpha", "*", "(", "ub", "-", "lb", ")", "\n", "return", "ub", "if", "is_number", "else", "(", "lb", ",", "ub", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupTF._repr_args": [[366, 370], ["tf_scheduler.TFScheduler._repr_args", "super()._repr_args.extend"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF._repr_args"], ["", "def", "_repr_args", "(", "self", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "base", "=", "super", "(", ")", ".", "_repr_args", "(", ")", "\n", "base", ".", "extend", "(", "[", "\"warmup_iters\"", ",", "\"warmup_method\"", ",", "\"delay_iters\"", ",", "\"gamma\"", "]", ")", "\n", "return", "base", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF.__init__": [[383, 413], ["tf_scheduler.TFScheduler.__init__", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "tfm", ":", "SchedulableMixin", ",", "\n", "warmup_milestones", ":", "Sequence", "[", "int", "]", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "gamma", ":", "float", "=", "1.0", ",", "\n", "params", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tfm: See :cls:`TFScheduler`.\n            warmup_milestones (Sequence[int]): Discrete iterations at which to take a\n                step on the scheduler.\n            warmup_method (str, optional): One of [``'linear'``, ``'exp'``].\n            gamma (float, optional): Scaling factor for time constant in exponential (``'exp'``)\n                scheduling.\n            params: See :cls:`TFScheduler`.\n        \"\"\"", "\n", "if", "warmup_method", "not", "in", "(", "None", ",", "\"linear\"", ",", "\"exp\"", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"`warmup_method` must be one of (None, 'linear', 'exp'). Got '{warmup_method}'\"", "\n", ")", "\n", "", "if", "gamma", "<", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"gamma must be >=0\"", ")", "\n", "\n", "", "self", ".", "warmup_milestones", "=", "warmup_milestones", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "tfm", ",", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF._compute_value": [[414, 434], ["tf_scheduler.WarmupMultiStepTF.get_iteration", "bisect.bisect_right", "len", "isinstance", "tf_scheduler._get_warmup_factor_at_iter", "tuple", "isinstance", "tf_scheduler.WarmupMultiStepTF._compute_value", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.get_iteration", "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler._get_warmup_factor_at_iter", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF._compute_value"], ["", "def", "_compute_value", "(", "self", ",", "value", ",", "kind", ":", "ParamKind", ")", ":", "\n", "        ", "if", "kind", "==", "ParamKind", ".", "MULTI_ARG", "and", "isinstance", "(", "value", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "return", "[", "self", ".", "_compute_value", "(", "v", ",", "kind", ".", "SINGLE_ARG", ")", "for", "v", "in", "value", "]", "\n", "\n", "", "t", "=", "self", ".", "get_iteration", "(", ")", "\n", "step", "=", "bisect_right", "(", "self", ".", "warmup_milestones", ",", "t", ")", "\n", "total_steps", "=", "len", "(", "self", ".", "warmup_milestones", ")", "\n", "\n", "is_number", "=", "isinstance", "(", "value", ",", "Number", ")", "\n", "if", "is_number", ":", "\n", "            ", "value", "=", "(", "0", ",", "value", ")", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "value", ",", "Sequence", ")", "and", "len", "(", "value", ")", "==", "2", "\n", "\n", "", "alpha", "=", "_get_warmup_factor_at_iter", "(", "self", ".", "warmup_method", ",", "step", ",", "total_steps", ",", "0", ",", "self", ".", "gamma", ")", "\n", "alpha", "=", "(", "step", ">", "0", ")", "*", "alpha", "\n", "\n", "lb", ",", "ub", "=", "tuple", "(", "value", ")", "\n", "ub", "=", "lb", "+", "alpha", "*", "(", "ub", "-", "lb", ")", "\n", "return", "ub", "if", "is_number", "else", "(", "lb", ",", "ub", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF._repr_args": [[435, 439], ["tf_scheduler.TFScheduler._repr_args", "super()._repr_args.extend"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.WarmupMultiStepTF._repr_args"], ["", "def", "_repr_args", "(", "self", ")", "->", "List", "[", "str", "]", ":", "# pragma: no cover", "\n", "        ", "base", "=", "super", "(", ")", ".", "_repr_args", "(", ")", "\n", "base", ".", "extend", "(", "[", "\"warmup_milestones\"", ",", "\"warmup_method\"", ",", "\"gamma\"", "]", ")", "\n", "return", "base", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler._get_warmup_factor_at_iter": [[441, 473], ["min", "min", "ValueError", "numpy.exp", "numpy.exp"], "function", ["None"], ["", "", "def", "_get_warmup_factor_at_iter", "(", "\n", "method", ":", "str", ",", "iter", ":", "int", ",", "warmup_iters", ":", "int", ",", "delay_iters", ":", "int", ",", "gamma", ":", "float", "=", "None", "\n", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    TODO: Merge this with the lr scheduler logic\n\n    Args:\n        method (str): warmup method; either \"constant\" or \"linear\".\n        iter (int): iteration at which to calculate the warmup factor.\n        warmup_iters (int): the number of warmup iterations.\n        warmup_factor (float): the base warmup factor (the meaning changes\n            according to the method used).\n\n    Returns:\n        float: the effective warmup factor at the given iteration.\n    \"\"\"", "\n", "if", "iter", ">=", "warmup_iters", ":", "\n", "        ", "return", "1.0", "\n", "", "if", "iter", "<", "delay_iters", ":", "\n", "        ", "return", "0.0", "\n", "", "assert", "warmup_iters", ">", "delay_iters", "\n", "\n", "if", "method", "==", "\"constant\"", ":", "\n", "        ", "return", "1.0", "/", "(", "warmup_iters", "-", "delay_iters", ")", "\n", "", "elif", "method", "==", "\"linear\"", ":", "\n", "        ", "return", "min", "(", "(", "iter", "-", "delay_iters", ")", "/", "(", "warmup_iters", "-", "delay_iters", ")", ",", "1.0", ")", "\n", "", "elif", "method", "==", "\"exp\"", ":", "\n", "        ", "assert", "gamma", "is", "not", "None", "\n", "tau", "=", "(", "warmup_iters", "-", "delay_iters", ")", "/", "gamma", "\n", "return", "min", "(", "(", "1", "-", "np", ".", "exp", "(", "-", "(", "iter", "-", "delay_iters", ")", "/", "tau", ")", ")", "/", "(", "1", "-", "np", ".", "exp", "(", "-", "gamma", ")", ")", ",", "1.0", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown warmup method: {}\"", ".", "format", "(", "method", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler._parse_pname": [[475, 479], ["pname.split"], "function", ["None"], ["", "", "def", "_parse_pname", "(", "pname", ":", "str", ")", ":", "\n", "    ", "if", "\".\"", "not", "in", "pname", ":", "\n", "        ", "return", "pname", "\n", "", "return", "pname", ".", "split", "(", "\".\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform._set_attributes": [[40, 52], ["params.items", "setattr", "k.startswith"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["def", "_set_attributes", "(", "self", ",", "params", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Set attributes from the input list of parameters.\n\n        Args:\n            params (list): list of parameters.\n        \"\"\"", "\n", "\n", "if", "params", ":", "\n", "            ", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "!=", "\"self\"", "and", "not", "k", ".", "startswith", "(", "\"_\"", ")", ":", "\n", "                    ", "setattr", "(", "self", ",", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform.register_type": [[53, 100], ["callable", "inspect.getfullargspec", "setattr", "len", "str", "cls.register_type"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform.register_type"], ["", "", "", "", "@", "classmethod", "\n", "def", "register_type", "(", "cls", ",", "data_type", ":", "str", ",", "func", ":", "Optional", "[", "Callable", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Register the given function as a handler that this transform will use\n        for a specific data type.\n\n        Args:\n            data_type (str): the name of the data type (e.g., box)\n            func (callable): takes a transform and a data, returns the\n                transformed data.\n\n        Examples:\n\n        .. code-block:: python\n\n            # call it directly\n            def func(flip_transform, voxel_data):\n                return transformed_voxel_data\n            HFlipTransform.register_type(\"voxel\", func)\n\n            # or, use it as a decorator\n            @HFlipTransform.register_type(\"voxel\")\n            def func(flip_transform, voxel_data):\n                return transformed_voxel_data\n\n            # ...\n            transform = HFlipTransform(...)\n            transform.apply_voxel(voxel_data)  # func will be called\n        \"\"\"", "\n", "if", "func", "is", "None", ":", "# the decorator style", "\n", "\n", "            ", "def", "wrapper", "(", "decorated_func", ")", ":", "\n", "                ", "assert", "decorated_func", "is", "not", "None", "\n", "cls", ".", "register_type", "(", "data_type", ",", "decorated_func", ")", "\n", "return", "decorated_func", "\n", "\n", "", "return", "wrapper", "\n", "\n", "", "assert", "callable", "(", "\n", "func", "\n", ")", ",", "\"You can only register a callable to a Transform. Got {} instead.\"", ".", "format", "(", "func", ")", "\n", "argspec", "=", "inspect", ".", "getfullargspec", "(", "func", ")", "\n", "assert", "len", "(", "argspec", ".", "args", ")", "==", "2", ",", "(", "\n", "\"You can only register a function that takes two positional \"", "\n", "\"arguments to a Transform! Got a function with spec {}\"", ".", "format", "(", "str", "(", "argspec", ")", ")", "\n", ")", "\n", "setattr", "(", "cls", ",", "\"apply_\"", "+", "data_type", ",", "func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform.apply_image": [[101, 113], ["None"], "methods", ["None"], ["", "def", "apply_image", "(", "self", ",", "img", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Apply the transform on an image.\n\n        Args:\n            img (ndarray): of shape NxHxWxC, or HxWxC or HxW. The array can be\n                of type uint8 in range [0, 255], or floating point in range\n                [0, 1] or [0, 255].\n        Returns:\n            ndarray: image after apply the transformation.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform.apply_maps": [[114, 116], ["transform.Transform.apply_image"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image"], ["", "def", "apply_maps", "(", "self", ",", "maps", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "self", ".", "apply_image", "(", "maps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform.inverse": [[117, 130], ["None"], "methods", ["None"], ["", "def", "inverse", "(", "self", ")", "->", "\"Transform\"", ":", "\n", "        ", "\"\"\"\n        Create a transform that inverts the geometric changes (i.e. change of\n        coordinates) of this transform.\n\n        Note that the inverse is meant for geometric changes only.\n        The inverse of photometric transforms that do not change coordinates\n        is defined to be a no-op, even if they may be invertible.\n\n        Returns:\n            Transform:\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform.__repr__": [[131, 138], ["transform.Transform.__dict__.items", "type", "k.startswith", "isinstance", "attrs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "attrs", "=", "{", "\n", "k", ":", "v", "\n", "for", "k", ",", "v", "in", "self", ".", "__dict__", ".", "items", "(", ")", "\n", "if", "not", "k", ".", "startswith", "(", "\"_\"", ")", "and", "not", "isinstance", "(", "v", ",", "Callable", ")", "\n", "}", "\n", "return", "\"{}({})\"", ".", "format", "(", "type", "(", "self", ")", ".", "__name__", ",", "\", \"", ".", "join", "(", "f\"{k}={v}\"", "for", "k", ",", "v", "in", "attrs", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform.__str__": [[139, 141], ["transform.Transform.__repr__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.__repr__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__repr__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform._eq_attrs": [[142, 144], ["None"], "methods", ["None"], ["", "def", "_eq_attrs", "(", "self", ")", "->", "Tuple", "[", "str", "]", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform.__eq__": [[145, 161], ["transform.Transform._eq_attrs", "all", "isinstance", "type", "getattr", "getattr", "isinstance", "torch.all", "isinstance", "numpy.all", "isinstance", "all"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform._eq_attrs"], ["", "def", "__eq__", "(", "self", ",", "o", ":", "object", ")", "->", "bool", ":", "\n", "        ", "if", "not", "isinstance", "(", "o", ",", "type", "(", "self", ")", ")", ":", "\n", "            ", "return", "False", "\n", "", "attrs", "=", "self", ".", "_eq_attrs", "(", ")", "\n", "vals", "=", "[", "getattr", "(", "self", ",", "a", ")", "==", "getattr", "(", "o", ",", "a", ")", "for", "a", "in", "attrs", "]", "\n", "vals", "=", "[", "\n", "torch", ".", "all", "(", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", "\n", "else", "np", ".", "all", "(", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "(", "np", ".", "ndarray", ",", "list", ",", "tuple", ")", ")", "\n", "else", "all", "(", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "Iterable", ")", "\n", "else", "v", "\n", "for", "v", "in", "vals", "\n", "]", "\n", "return", "all", "(", "vals", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.NoOpTransform.apply_image": [[164, 166], ["None"], "methods", ["None"], ["    ", "def", "apply_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.NoOpTransform.inverse": [[167, 169], ["transform.NoOpTransform"], "methods", ["None"], ["", "def", "inverse", "(", "self", ")", ":", "\n", "        ", "return", "NoOpTransform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__init__": [[182, 195], ["super().__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "transforms", ":", "List", "[", "Transform", "]", ",", "ignore_no_op", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            transforms (list[Transform]): list of transforms to perform.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "for", "t", "in", "transforms", ":", "\n", "            ", "assert", "isinstance", "(", "t", ",", "Transform", ")", ",", "t", "\n", "\n", "", "self", ".", "ignore_no_op", "=", "ignore_no_op", "\n", "if", "ignore_no_op", ":", "\n", "            ", "transforms", "=", "[", "t", "for", "t", "in", "transforms", "if", "t", "not", "in", "(", "None", ",", "NoOpTransform", ")", "]", "\n", "", "self", ".", "transforms", "=", "transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList._apply": [[196, 208], ["getattr"], "methods", ["None"], ["", "def", "_apply", "(", "self", ",", "x", ":", "_T", ",", "meth", ":", "str", ")", "->", "_T", ":", "\n", "        ", "\"\"\"\n        Apply the transforms on the input.\n        Args:\n            x: input to apply the transform operations.\n            meth (str): meth.\n        Returns:\n            x: after apply the transformation.\n        \"\"\"", "\n", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "x", "=", "getattr", "(", "t", ",", "meth", ")", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__getattribute__": [[209, 214], ["name.startswith", "super().__getattribute__", "transform.TransformList._apply"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__getattribute__", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList._apply"], ["", "def", "__getattribute__", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "# use __getattribute__ to win priority over any registered dtypes", "\n", "        ", "if", "name", ".", "startswith", "(", "\"apply_\"", ")", ":", "\n", "            ", "return", "lambda", "x", ":", "self", ".", "_apply", "(", "x", ",", "name", ")", "\n", "", "return", "super", "(", ")", ".", "__getattribute__", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__add__": [[215, 227], ["transform.TransformList", "transform.TransformList", "isinstance"], "methods", ["None"], ["", "def", "__add__", "(", "self", ",", "other", ":", "\"TransformList\"", ")", "->", "\"TransformList\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            other (TransformList): transformation to add.\n        Returns:\n            TransformList: list of transforms.\n        \"\"\"", "\n", "ignore_no_op", "=", "self", ".", "ignore_no_op", "or", "other", ".", "ignore_no_op", "\n", "if", "not", "other", ":", "\n", "            ", "return", "TransformList", "(", "self", ".", "transforms", ",", "ignore_no_op", "=", "ignore_no_op", ")", "\n", "", "others", "=", "other", ".", "transforms", "if", "isinstance", "(", "other", ",", "TransformList", ")", "else", "[", "other", "]", "\n", "return", "TransformList", "(", "self", ".", "transforms", "+", "others", ",", "ignore_no_op", "=", "ignore_no_op", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__iadd__": [[228, 240], ["transform.TransformList.transforms.extend", "isinstance"], "methods", ["None"], ["", "def", "__iadd__", "(", "self", ",", "other", ":", "\"TransformList\"", ")", "->", "\"TransformList\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            other (TransformList): transformation to add.\n        Returns:\n            TransformList: list of transforms.\n        \"\"\"", "\n", "others", "=", "other", ".", "transforms", "if", "isinstance", "(", "other", ",", "TransformList", ")", "else", "[", "other", "]", "\n", "if", "self", ".", "ignore_no_op", ":", "\n", "            ", "others", "=", "[", "t", "for", "t", "in", "others", "if", "t", "not", "in", "(", "None", ",", "NoOpTransform", ")", "]", "\n", "", "self", ".", "transforms", ".", "extend", "(", "others", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__radd__": [[241, 251], ["transform.TransformList", "isinstance"], "methods", ["None"], ["", "def", "__radd__", "(", "self", ",", "other", ":", "\"TransformList\"", ")", "->", "\"TransformList\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            other (TransformList): transformation to add.\n        Returns:\n            TransformList: list of transforms.\n        \"\"\"", "\n", "ignore_no_op", "=", "self", ".", "ignore_no_op", "or", "other", ".", "ignore_no_op", "\n", "others", "=", "other", ".", "transforms", "if", "isinstance", "(", "other", ",", "TransformList", ")", "else", "[", "other", "]", "\n", "return", "TransformList", "(", "others", "+", "self", ".", "transforms", ",", "ignore_no_op", "=", "ignore_no_op", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__len__": [[252, 258], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Number of transforms contained in the TransformList.\n        \"\"\"", "\n", "return", "len", "(", "self", ".", "transforms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__getitem__": [[259, 261], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", "->", "Transform", ":", "\n", "        ", "return", "self", ".", "transforms", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__contains__": [[262, 264], ["None"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "in", "self", ".", "transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.inverse": [[265, 270], ["transform.TransformList", "x.inverse"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.inverse"], ["", "def", "inverse", "(", "self", ")", "->", "\"TransformList\"", ":", "\n", "        ", "\"\"\"\n        Invert each transform in reversed order.\n        \"\"\"", "\n", "return", "TransformList", "(", "[", "x", ".", "inverse", "(", ")", "for", "x", "in", "self", ".", "transforms", "[", ":", ":", "-", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__repr__": [[271, 274], ["type", "t.__repr__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}(\\n\\t{}\\n)\"", ".", "format", "(", "\n", "type", "(", "self", ")", ".", "__name__", ",", "\"\\n\\t\"", ".", "join", "(", "t", ".", "__repr__", "(", ")", "for", "t", "in", "self", ".", "transforms", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TransformList.__str__": [[276, 278], ["transform.TransformList.__repr__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.__repr__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__repr__", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noise.NoiseModel.__init__": [[49, 87], ["torch.Generator", "isinstance", "g.manual_seed.manual_seed.manual_seed", "len", "ValueError"], "methods", ["None"], ["if", "gen", "is", "None", "or", "gen", ".", "device", "!=", "input", ".", "device", ":", "\n", "            ", "gen", "=", "torch", ".", "Generator", "(", "device", "=", "input", ".", "device", ")", ".", "manual_seed", "(", "int", "(", "self", ".", "_rand", "(", ")", "*", "1e10", ")", ")", "\n", "", "return", "NoiseTransform", "(", "std_dev", "=", "std_dev", ",", "use_mask", "=", "self", ".", "use_mask", ",", "rho", "=", "rho", ",", "generator", "=", "gen", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noise.NoiseModel.choose_std_dev": [[88, 110], ["isinstance", "len", "meddlr.utils.events.get_event_storage", "ValueError", "torch.rand().item", "min", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noise.NoiseModel.__call__": [[111, 113], ["noise.NoiseModel.forward"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MultiplyModule.forward"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noise.NoiseModel.forward": [[114, 138], ["meddlr.ops.complex.get_mask", "torch.view_as_complex.NoiseModel.choose_std_dev", "meddlr.ops.complex.is_complex", "kspace.clone.clone.clone", "torch.Generator().manual_seed", "torch.view_as_complex", "torch.view_as_complex.NoiseModel.subsample_mask", "torch.randn", "torch.randn", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.choose_std_dev", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.subsample_mask"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noise.NoiseModel.subsample_mask": [[139, 158], ["mask.view.view.view", "torch.sum", "int", "torch.multinomial", "mask.view.view.view"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noise.NoiseModel.from_cfg": [[159, 163], ["cls"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.motion.MotionModel.__init__": [[42, 65], ["isinstance", "torch.Generator", "g.manual_seed.manual_seed.manual_seed", "len", "ValueError"], "methods", ["None"], ["", "elif", "len", "(", "std_devs", ")", ">", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"`motion_range` must have 2 or fewer values\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "params", "=", "{", "\"std_devs\"", ":", "std_devs", "}", ",", "p", "=", "p", ")", "\n", "\n", "", "def", "get_transform", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "params", "[", "\"p\"", "]", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "std_dev", "=", "self", ".", "_rand_range", "(", "*", "params", "[", "\"std_devs\"", "]", ")", "\n", "gen", "=", "self", ".", "_generator", "\n", "if", "gen", "is", "None", "or", "gen", ".", "device", "!=", "input", ".", "device", ":", "\n", "            ", "gen", "=", "torch", ".", "Generator", "(", "device", "=", "input", ".", "device", ")", ".", "manual_seed", "(", "int", "(", "self", ".", "_rand", "(", ")", "*", "1e10", ")", ")", "\n", "", "return", "MRIMotionTransform", "(", "std_dev", "=", "std_dev", ",", "generator", "=", "gen", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.motion.MotionModel.choose_motion_range": [[66, 90], ["isinstance", "len", "meddlr.utils.events.get_event_storage", "ValueError", "torch.rand().item", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.motion.MotionModel.__call__": [[91, 93], ["motion.MotionModel.forward"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MultiplyModule.forward"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.motion.MotionModel.forward": [[94, 129], ["torch.zeros", "motion.MotionModel.choose_motion_range", "range", "kspace.clone.clone.clone", "torch.Generator().manual_seed", "torch.from_numpy", "torch.rand().numpy", "torch.rand().numpy", "numpy.exp", "torch.Generator", "torch.rand", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.choose_motion_range"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.motion.MotionModel.from_cfg": [[130, 134], ["cls"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Normalizer.__init__": [[46, 51], ["tuple"], "methods", ["None"], ["\n", "\n", "if", "params", ":", "\n", "            ", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "!=", "\"self\"", "and", "not", "k", ".", "startswith", "(", "\"_\"", ")", ":", "\n", "                    ", "setattr", "(", "self", ",", "k", ",", "v", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Normalizer.normalize": [[52, 54], ["None"], "methods", ["None"], ["\n", "", "", "", "", "@", "classmethod", "\n", "def", "register_type", "(", "cls", ",", "data_type", ":", "str", ",", "func", ":", "Optional", "[", "Callable", "]", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Normalizer.undo": [[55, 57], ["None"], "methods", ["None"], ["        "]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.NoOpNormalizer.normalize": [[61, 70], ["outputs.update", "kwargs.items", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.NoOpNormalizer.undo": [[71, 73], ["kwargs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.AffineNormalizer.normalize": [[77, 84], ["kwargs.items", "outputs.update"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["\n", "if", "func", "is", "None", ":", "# the decorator style", "\n", "\n", "            ", "def", "wrapper", "(", "decorated_func", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.AffineNormalizer.undo": [[85, 100], ["transform.AffineNormalizer._reshape_params().to", "transform.AffineNormalizer._reshape_params().to", "any", "outputs.update", "ValueError", "transform.AffineNormalizer._reshape_params", "transform.AffineNormalizer._reshape_params", "transform.unnormalize_affine", "kwargs.keys", "kwargs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.AffineNormalizer._reshape_params", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.AffineNormalizer._reshape_params", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.unnormalize_affine", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["                ", "assert", "decorated_func", "is", "not", "None", "\n", "cls", ".", "register_type", "(", "data_type", ",", "decorated_func", ")", "\n", "return", "decorated_func", "\n", "\n", "", "return", "wrapper", "\n", "\n", "", "assert", "callable", "(", "\n", "func", "\n", ")", ",", "\"You can only register a callable to a Transform. Got {} instead.\"", ".", "format", "(", "func", ")", "\n", "argspec", "=", "inspect", ".", "getfullargspec", "(", "func", ")", "\n", "assert", "len", "(", "argspec", ".", "args", ")", "==", "2", ",", "(", "\n", "\"You can only register a function that takes two positional \"", "\n", "\"arguments to a Transform! Got a function with spec {}\"", ".", "format", "(", "str", "(", "argspec", ")", ")", "\n", ")", "\n", "setattr", "(", "cls", ",", "\"apply_\"", "+", "data_type", ",", "func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.AffineNormalizer._reshape_params": [[101, 106], ["param.reshape", "param.view"], "methods", ["None"], ["", "def", "apply_image", "(", "self", ",", "img", ":", "torch", ".", "Tensor", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TopMagnitudeNormalizer.__init__": [[112, 117], ["transform.Normalizer.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["raise", "NotImplementedError", "\n", "\n", "", "def", "apply_maps", "(", "self", ",", "maps", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "self", ".", "apply_image", "(", "maps", ")", "\n", "\n", "", "def", "inverse", "(", "self", ")", "->", "\"Transform\"", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TopMagnitudeNormalizer.normalize": [[118, 136], ["meddlr.ops.complex.abs().reshape", "int", "torch.min", "torch.tensor", "torch.min.unsqueeze", "outputs.update", "outputs.update", "round", "meddlr.ops.complex.abs", "torch.topk", "meddlr.ops.complex.abs().reshape.numel", "kwargs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["        ", "\"\"\"\n        Create a transform that inverts the geometric changes (i.e. change of\n        coordinates) of this transform.\n\n        Note that the inverse is meant for geometric changes only.\n        The inverse of photometric transforms that do not change coordinates\n        is defined to be a no-op, even if they may be invertible.\n\n        Returns:\n            Transform:\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "attrs", "=", "{", "\n", "k", ":", "v", "\n", "for", "k", ",", "v", "in", "self", ".", "__dict__", ".", "items", "(", ")", "\n", "if", "not", "k", ".", "startswith", "(", "\"_\"", ")", "and", "not", "isinstance", "(", "v", ",", "Callable", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Subsampler.__init__": [[139, 142], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__repr__", "(", ")", "\n", "\n", "", "def", "_eq_attrs", "(", "self", ")", "->", "Tuple", "[", "str", "]", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Subsampler._get_mask_shape": [[143, 159], ["len", "ValueError", "len"], "methods", ["None"], ["        ", "raise", "NotImplementedError", "\n", "\n", "", "def", "__eq__", "(", "self", ",", "o", ":", "object", ")", "->", "bool", ":", "\n", "        ", "if", "not", "isinstance", "(", "o", ",", "type", "(", "self", ")", ")", ":", "\n", "            ", "return", "False", "\n", "", "attrs", "=", "self", ".", "_eq_attrs", "(", ")", "\n", "vals", "=", "[", "getattr", "(", "self", ",", "a", ")", "==", "getattr", "(", "o", ",", "a", ")", "for", "a", "in", "attrs", "]", "\n", "vals", "=", "[", "\n", "torch", ".", "all", "(", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", "\n", "else", "np", ".", "all", "(", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "(", "np", ".", "ndarray", ",", "list", ",", "tuple", ")", ")", "\n", "else", "all", "(", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "Iterable", ")", "\n", "else", "v", "\n", "for", "v", "in", "vals", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Subsampler.__call__": [[160, 180], ["tuple", "transform.Subsampler._get_mask_shape", "transform.Subsampler.mask_func", "transform.Subsampler._get_mask_shape", "meddlr.utils.transforms.zero_pad", "torch.where", "tuple", "torch.tensor", "tuple", "len", "len", "zip"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Subsampler._get_mask_shape", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Subsampler._get_mask_shape", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.zero_pad"], ["return", "all", "(", "vals", ")", "\n", "\n", "\n", "", "", "class", "NoOpTransform", "(", "Transform", ")", ":", "\n", "    ", "def", "apply_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "return", "image", "\n", "\n", "", "def", "inverse", "(", "self", ")", ":", "\n", "        ", "return", "NoOpTransform", "(", ")", "\n", "\n", "\n", "", "", "_T", "=", "TypeVar", "(", "\"_T\"", ")", "\n", "\n", "\n", "# pyre-ignore-all-errors", "\n", "class", "TransformList", ":", "\n", "    ", "\"\"\"\n    Maintain a list of transform operations which will be applied in sequence.\n    Attributes:\n        transforms (list[Transform])\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.DataTransform.__init__": [[189, 234], ["transform.Subsampler", "numpy.random.RandomState", "transform.build_normalizer", "noise.NoiseModel", "motion.MotionModel", "noise.NoiseModel.from_cfg", "motion.MotionModel.from_cfg", "MRIReconAugmentor.from_cfg"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.build_normalizer", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg"], ["            ", "assert", "isinstance", "(", "t", ",", "Transform", ")", ",", "t", "\n", "\n", "", "self", ".", "ignore_no_op", "=", "ignore_no_op", "\n", "if", "ignore_no_op", ":", "\n", "            ", "transforms", "=", "[", "t", "for", "t", "in", "transforms", "if", "t", "not", "in", "(", "None", ",", "NoOpTransform", ")", "]", "\n", "", "self", ".", "transforms", "=", "transforms", "\n", "\n", "", "def", "_apply", "(", "self", ",", "x", ":", "_T", ",", "meth", ":", "str", ")", "->", "_T", ":", "\n", "        ", "\"\"\"\n        Apply the transforms on the input.\n        Args:\n            x: input to apply the transform operations.\n            meth (str): meth.\n        Returns:\n            x: after apply the transformation.\n        \"\"\"", "\n", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "x", "=", "getattr", "(", "t", ",", "meth", ")", "(", "x", ")", "\n", "", "return", "x", "\n", "\n", "", "def", "__getattribute__", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "# use __getattribute__ to win priority over any registered dtypes", "\n", "        ", "if", "name", ".", "startswith", "(", "\"apply_\"", ")", ":", "\n", "            ", "return", "lambda", "x", ":", "self", ".", "_apply", "(", "x", ",", "name", ")", "\n", "", "return", "super", "(", ")", ".", "__getattribute__", "(", "name", ")", "\n", "\n", "", "def", "__add__", "(", "self", ",", "other", ":", "\"TransformList\"", ")", "->", "\"TransformList\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            other (TransformList): transformation to add.\n        Returns:\n            TransformList: list of transforms.\n        \"\"\"", "\n", "ignore_no_op", "=", "self", ".", "ignore_no_op", "or", "other", ".", "ignore_no_op", "\n", "if", "not", "other", ":", "\n", "            ", "return", "TransformList", "(", "self", ".", "transforms", ",", "ignore_no_op", "=", "ignore_no_op", ")", "\n", "", "others", "=", "other", ".", "transforms", "if", "isinstance", "(", "other", ",", "TransformList", ")", "else", "[", "other", "]", "\n", "return", "TransformList", "(", "self", ".", "transforms", "+", "others", ",", "ignore_no_op", "=", "ignore_no_op", ")", "\n", "\n", "", "def", "__iadd__", "(", "self", ",", "other", ":", "\"TransformList\"", ")", "->", "\"TransformList\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            other (TransformList): transformation to add.\n        Returns:\n            TransformList: list of transforms.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.DataTransform._call_augmentor": [[235, 276], ["meddlr.ops.complex.to_tensor().unsqueeze", "meddlr.ops.complex.to_tensor().unsqueeze", "meddlr.ops.complex.to_tensor().unsqueeze", "torch.sqrt", "functools.partial", "transform.DataTransform.augmentor", "masked_kspace.squeeze.squeeze.squeeze", "maps.squeeze.squeeze.squeeze", "target.squeeze.squeeze.squeeze", "torch.complex().unsqueeze", "torch.mean", "sum", "meddlr.ops.complex.to_tensor", "meddlr.ops.complex.to_tensor", "meddlr.ops.complex.to_tensor", "torch.is_complex", "tuple", "torch.complex", "meddlr.ops.complex.abs", "map", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["others", "=", "other", ".", "transforms", "if", "isinstance", "(", "other", ",", "TransformList", ")", "else", "[", "other", "]", "\n", "if", "self", ".", "ignore_no_op", ":", "\n", "            ", "others", "=", "[", "t", "for", "t", "in", "others", "if", "t", "not", "in", "(", "None", ",", "NoOpTransform", ")", "]", "\n", "", "self", ".", "transforms", ".", "extend", "(", "others", ")", "\n", "return", "self", "\n", "\n", "", "def", "__radd__", "(", "self", ",", "other", ":", "\"TransformList\"", ")", "->", "\"TransformList\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            other (TransformList): transformation to add.\n        Returns:\n            TransformList: list of transforms.\n        \"\"\"", "\n", "ignore_no_op", "=", "self", ".", "ignore_no_op", "or", "other", ".", "ignore_no_op", "\n", "others", "=", "other", ".", "transforms", "if", "isinstance", "(", "other", ",", "TransformList", ")", "else", "[", "other", "]", "\n", "return", "TransformList", "(", "others", "+", "self", ".", "transforms", ",", "ignore_no_op", "=", "ignore_no_op", ")", "\n", "\n", "", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Number of transforms contained in the TransformList.\n        \"\"\"", "\n", "return", "len", "(", "self", ".", "transforms", ")", "\n", "\n", "", "def", "__getitem__", "(", "self", ",", "idx", ")", "->", "Transform", ":", "\n", "        ", "return", "self", ".", "transforms", "[", "idx", "]", "\n", "\n", "", "def", "__contains__", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "in", "self", ".", "transforms", "\n", "\n", "", "def", "inverse", "(", "self", ")", "->", "\"TransformList\"", ":", "\n", "        ", "\"\"\"\n        Invert each transform in reversed order.\n        \"\"\"", "\n", "return", "TransformList", "(", "[", "x", ".", "inverse", "(", ")", "for", "x", "in", "self", ".", "transforms", "[", ":", ":", "-", "1", "]", "]", ")", "\n", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}(\\n\\t{}\\n)\"", ".", "format", "(", "\n", "type", "(", "self", ")", ".", "__name__", ",", "\"\\n\\t\"", ".", "join", "(", "t", ".", "__repr__", "(", ")", "for", "t", "in", "self", ".", "transforms", ")", "\n", ")", "\n", "\n", "", "def", "__str__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.DataTransform.__call__": [[277, 367], ["meddlr.ops.complex.to_tensor().unsqueeze", "meddlr.ops.complex.to_tensor().unsqueeze", "meddlr.ops.complex.to_tensor().unsqueeze", "torch.sqrt", "transform.DataTransform._subsampler", "torch.is_complex", "transform.DataTransform._normalizer.normalize", "transform.DataTransform.squeeze", "maps.squeeze.squeeze.squeeze", "target.squeeze.squeeze.squeeze", "ValueError", "transform.DataTransform._call_augmentor", "torch.complex().unsqueeze", "torch.mean", "sum", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel.", "meddlr.utils.transforms.ifft2", "torch.sqrt", "torch.complex().unsqueeze", "transform.DataTransform.noiser", "transform.DataTransform.motion_simulator", "meddlr.ops.complex.to_tensor", "meddlr.ops.complex.to_tensor", "meddlr.ops.complex.to_tensor", "torch.is_complex", "tuple", "torch.sum", "torch.complex", "meddlr.ops.complex.abs", "map", "torch.complex", "torch.zeros_like", "meddlr.ops.complex.abs", "torch.zeros_like", "transform.DataTransform.rng.uniform", "transform.DataTransform.rng.uniform"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TopMagnitudeNormalizer.normalize", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.DataTransform._call_augmentor", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["        ", "return", "self", ".", "__repr__", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.build_normalizer": [[22, 27], ["NORMALIZER_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.normalize_affine": [[29, 31], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.unnormalize_affine": [[33, 35], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.MaskFunc.__init__": [[44, 51], ["numpy.random.RandomState"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "accelerations", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            accelerations (List[int]): Range of acceleration rates to simulate.\n        \"\"\"", "\n", "self", ".", "accelerations", "=", "accelerations", "\n", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.MaskFunc.choose_acceleration": [[52, 65], ["isinstance", "len", "subsample.MaskFunc.rng.rand"], "methods", ["None"], ["", "def", "choose_acceleration", "(", "self", ")", ":", "\n", "        ", "\"\"\"Chooses a random acceleration rate given a range.\n\n        If self.accelerations is a constant, it will be returned\n\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "self", ".", "accelerations", ",", "Sequence", ")", ":", "\n", "            ", "return", "self", ".", "accelerations", "\n", "", "elif", "len", "(", "self", ".", "accelerations", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "accelerations", "[", "0", "]", "\n", "", "accel_range", "=", "self", ".", "accelerations", "[", "1", "]", "-", "self", ".", "accelerations", "[", "0", "]", "\n", "acceleration", "=", "self", ".", "accelerations", "[", "0", "]", "+", "accel_range", "*", "self", ".", "rng", ".", "rand", "(", ")", "\n", "return", "acceleration", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.CacheableMaskMixin.get_filename": [[68, 70], ["None"], "methods", ["None"], ["    ", "def", "get_filename", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.RandomMaskFunc.__init__": [[78, 83], ["subsample.MaskFunc.__init__", "ValueError", "type"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "accelerations", ",", "calib_size", ",", "center_fractions", "=", "None", ")", ":", "\n", "        ", "if", "center_fractions", ":", "\n", "            ", "raise", "ValueError", "(", "f\"center_fractions not yet supported for class {type(self)}.\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "accelerations", ")", "\n", "self", ".", "calib_size", "=", "calib_size", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.RandomMaskFunc.__call__": [[84, 109], ["torch.rand", "torch.where", "torch.Tensor", "torch.where.reshape", "subsample.RandomMaskFunc.choose_acceleration", "torch.Generator().manual_seed", "torch.Tensor", "torch.Tensor", "torch.Generator", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.MaskFunc.choose_acceleration"], ["", "def", "__call__", "(", "self", ",", "out_shape", ",", "seed", "=", "None", ",", "acceleration", "=", "None", ")", ":", "\n", "# Design parameters for mask", "\n", "        ", "nky", "=", "out_shape", "[", "1", "]", "\n", "nkz", "=", "out_shape", "[", "2", "]", "\n", "\n", "if", "not", "acceleration", ":", "\n", "            ", "acceleration", "=", "self", ".", "choose_acceleration", "(", ")", "\n", "", "prob", "=", "1.0", "/", "acceleration", "\n", "\n", "# Generate undersampling mask.", "\n", "rand_kwargs", "=", "{", "\"dtype\"", ":", "torch", ".", "float32", "}", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "rand_kwargs", "[", "\"generator\"", "]", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "seed", ")", "\n", "\n", "", "mask", "=", "torch", ".", "rand", "(", "[", "nky", ",", "nkz", "]", ",", "**", "rand_kwargs", ")", "\n", "mask", "=", "torch", ".", "where", "(", "mask", "<", "prob", ",", "torch", ".", "Tensor", "(", "[", "1", "]", ")", ",", "torch", ".", "Tensor", "(", "[", "0", "]", ")", ")", "\n", "\n", "# Add calibration region", "\n", "calib", "=", "[", "self", ".", "calib_size", ",", "self", ".", "calib_size", "]", "\n", "mask", "[", "\n", "int", "(", "nky", "/", "2", "-", "calib", "[", "-", "2", "]", "/", "2", ")", ":", "int", "(", "nky", "/", "2", "+", "calib", "[", "-", "2", "]", "/", "2", ")", ",", "\n", "int", "(", "nkz", "/", "2", "-", "calib", "[", "-", "1", "]", "/", "2", ")", ":", "int", "(", "nkz", "/", "2", "+", "calib", "[", "-", "1", "]", "/", "2", ")", ",", "\n", "]", "=", "torch", ".", "Tensor", "(", "[", "1", "]", ")", "\n", "\n", "return", "mask", ".", "reshape", "(", "out_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.PoissonDiskMaskFunc.__init__": [[117, 137], ["subsample.MaskFunc.__init__", "isinstance", "ValueError", "ValueError", "type"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "accelerations", ",", "\n", "calib_size", ",", "\n", "center_fractions", "=", "None", ",", "\n", "max_attempts", "=", "30", ",", "\n", "crop_corner", "=", "True", ",", "\n", "module", "=", "\"internal\"", ",", "\n", ")", ":", "\n", "        ", "if", "center_fractions", ":", "\n", "            ", "raise", "ValueError", "(", "f\"center_fractions not yet supported for class {type(self)}.\"", ")", "\n", "", "if", "module", "not", "in", "(", "\"internal\"", ",", "\"sigpy\"", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"`module` must be one of ('internal', 'sigpy')\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "accelerations", ")", "\n", "if", "isinstance", "(", "calib_size", ",", "int", ")", ":", "\n", "            ", "calib_size", "=", "(", "calib_size", ",", "calib_size", ")", "\n", "", "self", ".", "calib_size", "=", "calib_size", "\n", "self", ".", "max_attempts", "=", "max_attempts", "\n", "self", ".", "crop_corner", "=", "crop_corner", "\n", "self", ".", "module", "=", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.PoissonDiskMaskFunc.__call__": [[138, 185], ["torch.from_numpy", "subsample.PoissonDiskMaskFunc.choose_acceleration", "subsample.poisson", "sigpy.mri.poisson.transpose", "sigpy.mri.poisson.reshape", "sigpy.mri.poisson"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.MaskFunc.choose_acceleration", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.poisson", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.poisson"], ["", "def", "__call__", "(", "self", ",", "out_shape", ",", "seed", "=", "None", ",", "acceleration", "=", "None", ")", ":", "\n", "# Design parameters for mask", "\n", "        ", "nky", "=", "out_shape", "[", "1", "]", "\n", "nkz", "=", "out_shape", "[", "2", "]", "\n", "if", "not", "acceleration", ":", "\n", "            ", "acceleration", "=", "self", ".", "choose_acceleration", "(", ")", "\n", "\n", "# From empirical results, larger dimension should be first", "\n", "# for optimal speed.", "\n", "", "if", "nky", "<", "nkz", ":", "\n", "            ", "shape", "=", "(", "nkz", ",", "nky", ")", "\n", "transpose", "=", "True", "\n", "", "else", ":", "\n", "            ", "shape", "=", "(", "nky", ",", "nkz", ")", "\n", "transpose", "=", "False", "\n", "\n", "# Issue #2: Due to some optimization reasons, using the internal", "\n", "# poisson disc module has been faster than using sigpy's", "\n", "# default one. In many cases, the call to sigpy hangs.", "\n", "", "module", "=", "self", ".", "module", "\n", "if", "module", "==", "\"internal\"", ":", "\n", "            ", "mask", "=", "poisson", "(", "\n", "shape", ",", "\n", "acceleration", ",", "\n", "calib", "=", "self", ".", "calib_size", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", "seed", "=", "seed", ",", "\n", "K", "=", "self", ".", "max_attempts", ",", "\n", "crop_corner", "=", "self", ".", "crop_corner", ",", "\n", ")", "\n", "", "elif", "module", "==", "\"sigpy\"", ":", "\n", "            ", "mask", "=", "sigpy", ".", "mri", ".", "poisson", "(", "\n", "shape", ",", "\n", "acceleration", ",", "\n", "calib", "=", "self", ".", "calib_size", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", "seed", "=", "seed", ",", "\n", "max_attempts", "=", "self", ".", "max_attempts", ",", "\n", "crop_corner", "=", "self", ".", "crop_corner", ",", "\n", ")", "\n", "", "if", "transpose", ":", "\n", "            ", "mask", "=", "mask", ".", "transpose", "(", ")", "\n", "\n", "# Reshape the mask", "\n", "", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ".", "reshape", "(", "out_shape", ")", ")", "\n", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.PoissonDiskMaskFunc._get_args": [[186, 192], ["None"], "methods", ["None"], ["", "def", "_get_args", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "\"accelerations\"", ":", "self", ".", "accelerations", ",", "\n", "\"calib_size\"", ":", "self", ".", "calib_size", ",", "\n", "\"max_attempts\"", ":", "self", ".", "max_attempts", ",", "\n", "\"crop_corner\"", ":", "self", ".", "crop_corner", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.PoissonDiskMaskFunc.get_str_name": [[194, 197], ["subsample.PoissonDiskMaskFunc._get_args", "type", "subsample.PoissonDiskMaskFunc.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.PoissonDiskMaskFunc._get_args", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "get_str_name", "(", "self", ")", ":", "\n", "        ", "args", "=", "self", ".", "_get_args", "(", ")", "\n", "return", "f\"{type(self).__name__}-\"", "+", "\"-\"", ".", "join", "(", "f\"{k}={v}\"", "for", "k", ",", "v", "in", "args", ".", "items", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.PoissonDiskMaskFunc.__str__": [[198, 202], ["subsample.PoissonDiskMaskFunc._get_args", "type", "subsample.PoissonDiskMaskFunc.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.PoissonDiskMaskFunc._get_args", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "args", "=", "self", ".", "_get_args", "(", ")", "\n", "args_str", "=", "\"\\n\\t\"", "+", "\"\\n\\t\"", ".", "join", "(", "f\"{k}={v}\"", "for", "k", ",", "v", "in", "args", ".", "items", "(", ")", ")", "+", "\"\\n\\t\"", "\n", "return", "f\"{type(self)}({args_str})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.RandomMaskFunc1D.__init__": [[226, 246], ["subsample.MaskFunc.__init__", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "accelerations", ",", "calib_size", "=", "None", ",", "center_fractions", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            center_fractions (List[float]): Fraction of low-frequency columns to be retained.\n                If multiple values are provided, then one of these numbers is chosen uniformly\n                each time.\n            accelerations (List[int]): Amount of under-sampling. This should have the same length\n                as center_fractions. If multiple values are provided, then one of these is chosen\n                uniformly each time. An acceleration of 4 retains 25% of the columns, but they may\n                not be spaced evenly.\n            calib_size (List[int]): Calibration size for scans.\n        \"\"\"", "\n", "if", "not", "calib_size", "and", "not", "center_fractions", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either calib_size or center_fractions must be specified.\"", ")", "\n", "", "if", "calib_size", "and", "center_fractions", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only one of calib_size or center_fractions can be specified\"", ")", "\n", "\n", "", "self", ".", "center_fractions", "=", "center_fractions", "\n", "self", ".", "calib_size", "=", "calib_size", "\n", "super", "(", ")", ".", "__init__", "(", "accelerations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.RandomMaskFunc1D.__call__": [[247, 295], ["int", "torch.from_numpy.reshape().astype", "numpy.concatenate", "torch.from_numpy", "len", "ValueError", "numpy.random.get_state", "numpy.random.RandomState", "isinstance", "subsample.RandomMaskFunc1D.choose_acceleration", "round", "rng.uniform", "numpy.random.set_state", "rng.randint", "torch.from_numpy.reshape", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.MaskFunc.choose_acceleration"], ["", "def", "__call__", "(", "self", ",", "shape", ",", "seed", "=", "None", ",", "acceleration", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            shape (iterable[int]): The shape of the mask to be created. The shape should have\n                at least 3 dimensions. Samples are drawn along the second last dimension.\n            seed (int, optional): Seed for the random number generator. Setting the seed\n                ensures the same mask is generated each time for the same shape.\n        Returns:\n            torch.Tensor: A mask of the specified shape.\n        \"\"\"", "\n", "if", "len", "(", "shape", ")", "<", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\"Shape should have 3 or more dimensions\"", ")", "\n", "\n", "", "if", "seed", "is", "not", "None", ":", "\n", "            ", "np_state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "if", "seed", "is", "not", "None", "else", "self", ".", "rng", "\n", "\n", "num_rows", "=", "shape", "[", "1", "]", "\n", "num_cols", "=", "shape", "[", "2", "]", "\n", "if", "self", ".", "center_fractions", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "center_fractions", ",", "Sequence", ")", ":", "\n", "                ", "choice", "=", "rng", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "center_fractions", ")", ")", "\n", "center_fraction", "=", "self", ".", "center_fractions", "[", "choice", "]", "\n", "", "else", ":", "\n", "                ", "center_fraction", "=", "self", ".", "center_fractions", "\n", "", "", "else", ":", "\n", "            ", "center_fraction", "=", "self", ".", "calib_size", "/", "num_cols", "\n", "", "if", "acceleration", "is", "None", ":", "\n", "            ", "acceleration", "=", "self", ".", "choose_acceleration", "(", ")", "\n", "\n", "# Create the mask", "\n", "", "num_low_freqs", "=", "int", "(", "round", "(", "num_cols", "*", "center_fraction", ")", ")", "\n", "prob", "=", "(", "num_cols", "/", "acceleration", "-", "num_low_freqs", ")", "/", "(", "num_cols", "-", "num_low_freqs", ")", "\n", "mask", "=", "rng", ".", "uniform", "(", "size", "=", "num_cols", ")", "<", "prob", "\n", "pad", "=", "(", "num_cols", "-", "num_low_freqs", "+", "1", ")", "//", "2", "\n", "mask", "[", "pad", ":", "pad", "+", "num_low_freqs", "]", "=", "True", "\n", "\n", "# Reshape the mask", "\n", "mask_shape", "=", "[", "1", "for", "_", "in", "shape", "]", "\n", "mask_shape", "[", "2", "]", "=", "num_cols", "\n", "mask", "=", "mask", ".", "reshape", "(", "*", "mask_shape", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "mask", "=", "np", ".", "concatenate", "(", "[", "mask", "]", "*", "num_rows", ",", "axis", "=", "1", ")", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", "\n", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "set_state", "(", "np_state", ")", "\n", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.MaskLoader.__init__": [[300, 312], ["isinstance", "subsample.MaskFunc.__init__", "float", "torch.load", "isinstance", "os.path.join", "numpy.load", "len", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "accelerations", ",", "masks_path", ",", "mask_type", ":", "str", "=", "\"poisson\"", ",", "mode", "=", "\"train\"", ")", ":", "\n", "        ", "assert", "isinstance", "(", "accelerations", ",", "(", "int", ",", "float", ")", ")", "or", "len", "(", "accelerations", ")", "==", "1", "\n", "assert", "mode", "in", "[", "\"train\"", ",", "\"eval\"", "]", "\n", "if", "isinstance", "(", "accelerations", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "accelerations", "=", "(", "accelerations", ",", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "accelerations", ")", "\n", "\n", "accel", "=", "float", "(", "self", ".", "accelerations", "[", "0", "]", ")", "\n", "self", ".", "train_masks", "=", "None", "\n", "self", ".", "eval_data", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "masks_path", ",", "f\"{mask_type}_{accel}x_eval.pt\"", ")", ")", "\n", "if", "mode", "==", "\"train\"", ":", "\n", "            ", "self", ".", "train_masks", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "masks_path", ",", "f\"{mask_type}_{accel}x.npy\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.MaskLoader.__call__": [[313, 330], ["mask.reshape.reshape.reshape", "torch.from_numpy", "RuntimeError", "numpy.random.choice", "len", "data[].index"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "out_shape", ",", "seed", "=", "None", ",", "acceleration", "=", "None", ")", ":", "\n", "        ", "if", "acceleration", "is", "not", "None", "and", "acceleration", "not", "in", "self", ".", "accelerations", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"MaskLoader.__call__ does not currently support ``acceleration`` argument\"", "\n", ")", "\n", "\n", "", "if", "seed", "is", "None", ":", "\n", "# Randomly select from the masks we have", "\n", "            ", "idx", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "train_masks", ")", ")", "\n", "mask", "=", "self", ".", "train_masks", "[", "idx", "]", "\n", "", "else", ":", "\n", "            ", "data", "=", "self", ".", "eval_data", "\n", "masks", "=", "self", ".", "eval_data", "[", "\"masks\"", "]", "\n", "mask", "=", "masks", "[", "data", "[", "\"seeds\"", "]", ".", "index", "(", "seed", ")", "]", "\n", "\n", "", "mask", "=", "mask", ".", "reshape", "(", "out_shape", ")", "\n", "return", "torch", ".", "from_numpy", "(", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.build_mask_func": [[18, 35], ["MASK_FUNC_REGISTRY.get", "kwargs.copy.copy", "mapping.items", "MASK_FUNC_REGISTRY.get.", "inspect.signature"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["def", "build_mask_func", "(", "cfg", ",", "**", "kwargs", ")", ":", "\n", "    ", "name", "=", "cfg", ".", "UNDERSAMPLE", ".", "NAME", "\n", "accelerations", "=", "cfg", ".", "UNDERSAMPLE", ".", "ACCELERATIONS", "\n", "calibration_size", "=", "cfg", ".", "UNDERSAMPLE", ".", "CALIBRATION_SIZE", "\n", "center_fractions", "=", "cfg", ".", "UNDERSAMPLE", ".", "CENTER_FRACTIONS", "\n", "\n", "klass", "=", "MASK_FUNC_REGISTRY", ".", "get", "(", "name", ")", "\n", "parameters", "=", "inspect", ".", "signature", "(", "klass", ")", ".", "parameters", "\n", "\n", "# Optional args", "\n", "kwargs", "=", "kwargs", ".", "copy", "(", ")", "\n", "mapping", "=", "{", "\"max_attempts\"", ":", "cfg", ".", "UNDERSAMPLE", ".", "MAX_ATTEMPTS", "}", "\n", "for", "param", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "        ", "if", "param", "in", "parameters", ":", "\n", "            ", "kwargs", "[", "param", "]", "=", "value", "\n", "\n", "", "", "return", "klass", "(", "accelerations", ",", "calibration_size", ",", "center_fractions", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.poisson": [[338, 404], ["numpy.maximum", "np.maximum.max", "numpy.maximum", "np.maximum.max", "numpy.sqrt", "_poisson.reshape().astype", "numpy.random.get_state", "subsample._poisson", "numpy.random.set_state", "abs", "abs", "numpy.sum", "abs", "_poisson.reshape"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample._poisson", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "", "def", "poisson", "(", "\n", "img_shape", ",", "\n", "accel", ",", "\n", "K", "=", "30", ",", "\n", "calib", "=", "(", "0", ",", "0", ")", ",", "\n", "dtype", "=", "np", ".", "complex", ",", "\n", "crop_corner", "=", "True", ",", "\n", "return_density", "=", "False", ",", "\n", "seed", "=", "0", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Generate Poisson-disc sampling pattern\n\n    Args:\n        img_shape (tuple of ints): length-2 image shape.\n        accel (float): Target acceleration factor. Greater than 1.\n        K (float): maximum number of samples to reject.\n        calib (tuple of ints): length-2 calibration shape.\n        dtype (Dtype): data type.\n        crop_corner (bool): Toggle whether to crop sampling corners.\n        return_density (bool): Toggle whether to return sampling density.\n        seed (int): Random seed.\n\n    Returns:\n        array: Poisson-disc sampling mask.\n\n    References:\n        Bridson, Robert. \"Fast Poisson disk sampling in arbitrary dimensions.\"\n        SIGGRAPH sketches. 2007.\n\n    \"\"\"", "\n", "y", ",", "x", "=", "np", ".", "mgrid", "[", ":", "img_shape", "[", "-", "2", "]", ",", ":", "img_shape", "[", "-", "1", "]", "]", "\n", "x", "=", "np", ".", "maximum", "(", "abs", "(", "x", "-", "img_shape", "[", "-", "1", "]", "/", "2", ")", "-", "calib", "[", "-", "1", "]", "/", "2", ",", "0", ")", "\n", "x", "/=", "x", ".", "max", "(", ")", "\n", "y", "=", "np", ".", "maximum", "(", "abs", "(", "y", "-", "img_shape", "[", "-", "2", "]", "/", "2", ")", "-", "calib", "[", "-", "2", "]", "/", "2", ",", "0", ")", "\n", "y", "/=", "y", ".", "max", "(", ")", "\n", "r", "=", "np", ".", "sqrt", "(", "x", "**", "2", "+", "y", "**", "2", ")", "\n", "\n", "slope_max", "=", "40", "\n", "slope_min", "=", "0", "\n", "if", "seed", "is", "not", "None", ":", "\n", "        ", "rand_state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "", "else", ":", "\n", "        ", "seed", "=", "-", "1", "# numba does not play nicely with None types", "\n", "", "while", "slope_min", "<", "slope_max", ":", "\n", "        ", "slope", "=", "(", "slope_max", "+", "slope_min", ")", "/", "2.0", "\n", "R", "=", "1.0", "+", "r", "*", "slope", "\n", "mask", "=", "_poisson", "(", "img_shape", "[", "-", "1", "]", ",", "img_shape", "[", "-", "2", "]", ",", "K", ",", "R", ",", "calib", ",", "seed", ")", "\n", "if", "crop_corner", ":", "\n", "            ", "mask", "*=", "r", "<", "1", "\n", "\n", "", "est_accel", "=", "img_shape", "[", "-", "1", "]", "*", "img_shape", "[", "-", "2", "]", "/", "np", ".", "sum", "(", "mask", "[", ":", "]", ")", "\n", "\n", "if", "abs", "(", "est_accel", "-", "accel", ")", "<", "0.1", ":", "\n", "            ", "break", "\n", "", "if", "est_accel", "<", "accel", ":", "\n", "            ", "slope_min", "=", "slope", "\n", "", "else", ":", "\n", "            ", "slope_max", "=", "slope", "\n", "\n", "", "", "if", "seed", "is", "not", "None", "and", "seed", ">", "0", ":", "\n", "        ", "np", ".", "random", ".", "set_state", "(", "rand_state", ")", "\n", "", "mask", "=", "mask", ".", "reshape", "(", "img_shape", ")", ".", "astype", "(", "dtype", ")", "\n", "if", "return_density", ":", "\n", "        ", "return", "mask", ",", "r", "\n", "", "else", ":", "\n", "        ", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample._poisson": [[406, 478], ["numba.jit", "numpy.zeros", "numpy.empty", "numpy.empty", "numpy.random.randint", "numpy.random.randint", "numpy.random.seed", "numpy.random.randint", "int", "numpy.random.random", "max", "min", "max", "min", "range", "int", "int", "int", "int", "numpy.cos", "numpy.sin", "int", "int", "int", "int", "range", "int", "int", "numpy.random.random"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed"], ["", "", "@", "nb", ".", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ")", "# pragma: no cover", "\n", "def", "_poisson", "(", "nx", ",", "ny", ",", "K", ",", "R", ",", "calib", ",", "seed", "=", "None", ")", ":", "\n", "\n", "    ", "mask", "=", "np", ".", "zeros", "(", "(", "ny", ",", "nx", ")", ")", "\n", "f", "=", "ny", "/", "nx", "\n", "\n", "if", "seed", "is", "not", "None", "and", "seed", ">", "0", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "int", "(", "seed", ")", ")", "\n", "\n", "", "pxs", "=", "np", ".", "empty", "(", "nx", "*", "ny", ",", "np", ".", "int32", ")", "\n", "pys", "=", "np", ".", "empty", "(", "nx", "*", "ny", ",", "np", ".", "int32", ")", "\n", "pxs", "[", "0", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "nx", ")", "\n", "pys", "[", "0", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "ny", ")", "\n", "m", "=", "1", "\n", "while", "m", ">", "0", ":", "\n", "\n", "        ", "i", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "m", ")", "\n", "px", "=", "pxs", "[", "i", "]", "\n", "py", "=", "pys", "[", "i", "]", "\n", "rad", "=", "R", "[", "py", ",", "px", "]", "\n", "\n", "# Attempt to generate point", "\n", "done", "=", "False", "\n", "k", "=", "0", "\n", "while", "not", "done", "and", "k", "<", "K", ":", "\n", "\n", "# Generate point randomly from R and 2R", "\n", "            ", "rd", "=", "rad", "*", "(", "np", ".", "random", ".", "random", "(", ")", "*", "3", "+", "1", ")", "**", "0.5", "\n", "t", "=", "2", "*", "np", ".", "pi", "*", "np", ".", "random", ".", "random", "(", ")", "\n", "qx", "=", "px", "+", "rd", "*", "np", ".", "cos", "(", "t", ")", "\n", "qy", "=", "py", "+", "rd", "*", "f", "*", "np", ".", "sin", "(", "t", ")", "\n", "\n", "# Reject if outside grid or close to other points", "\n", "if", "qx", ">=", "0", "and", "qx", "<", "nx", "and", "qy", ">=", "0", "and", "qy", "<", "ny", ":", "\n", "\n", "                ", "startx", "=", "max", "(", "int", "(", "qx", "-", "rad", ")", ",", "0", ")", "\n", "endx", "=", "min", "(", "int", "(", "qx", "+", "rad", "+", "1", ")", ",", "nx", ")", "\n", "starty", "=", "max", "(", "int", "(", "qy", "-", "rad", "*", "f", ")", ",", "0", ")", "\n", "endy", "=", "min", "(", "int", "(", "qy", "+", "rad", "*", "f", "+", "1", ")", ",", "ny", ")", "\n", "\n", "done", "=", "True", "\n", "for", "x", "in", "range", "(", "startx", ",", "endx", ")", ":", "\n", "                    ", "for", "y", "in", "range", "(", "starty", ",", "endy", ")", ":", "\n", "                        ", "if", "mask", "[", "y", ",", "x", "]", "==", "1", "and", "(", "\n", "(", "(", "qx", "-", "x", ")", "/", "R", "[", "y", ",", "x", "]", ")", "**", "2", "+", "(", "(", "qy", "-", "y", ")", "/", "(", "R", "[", "y", ",", "x", "]", "*", "f", ")", ")", "**", "2", "<", "1", "\n", ")", ":", "\n", "                            ", "done", "=", "False", "\n", "break", "\n", "\n", "", "", "if", "not", "done", ":", "\n", "                        ", "break", "\n", "\n", "", "", "", "k", "+=", "1", "\n", "\n", "# Add point if done else remove active", "\n", "", "if", "done", ":", "\n", "            ", "pxs", "[", "m", "]", "=", "qx", "\n", "pys", "[", "m", "]", "=", "qy", "\n", "mask", "[", "int", "(", "qy", ")", ",", "int", "(", "qx", ")", "]", "=", "1", "\n", "m", "+=", "1", "\n", "", "else", ":", "\n", "            ", "pxs", "[", "i", "]", "=", "pxs", "[", "m", "-", "1", "]", "\n", "pys", "[", "i", "]", "=", "pys", "[", "m", "-", "1", "]", "\n", "m", "-=", "1", "\n", "\n", "# Add calibration region", "\n", "", "", "mask", "[", "\n", "int", "(", "ny", "/", "2", "-", "calib", "[", "-", "2", "]", "/", "2", ")", ":", "int", "(", "ny", "/", "2", "+", "calib", "[", "-", "2", "]", "/", "2", ")", ",", "\n", "int", "(", "nx", "/", "2", "-", "calib", "[", "-", "1", "]", "/", "2", ")", ":", "int", "(", "nx", "/", "2", "+", "calib", "[", "-", "1", "]", "/", "2", ")", ",", "\n", "]", "=", "1", "\n", "\n", "return", "mask", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.__init__": [[17, 47], ["isinstance", "torch.Generator", "isinstance", "g.manual_seed.manual_seed.manual_seed", "len", "ValueError", "len", "ValueError"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "std_devs", ":", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", ",", "\n", "motion_range", ":", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", ",", "\n", "scheduler", "=", "None", ",", "\n", "seed", "=", "None", ",", "\n", "device", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "std_devs", ",", "Sequence", ")", ":", "\n", "            ", "std_devs", "=", "(", "std_devs", ",", ")", "\n", "", "if", "isinstance", "(", "motion_range", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "            ", "motion_range", "=", "(", "motion_range", ",", ")", "\n", "", "elif", "len", "(", "std_devs", ")", ">", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"`std_devs` must have 2 or fewer values\"", ")", "\n", "", "elif", "len", "(", "motion_range", ")", ">", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"`motion_range` must have 2 or fewer values\"", ")", "\n", "", "self", ".", "std_devs", "=", "std_devs", "\n", "self", ".", "motion_range", "=", "motion_range", "\n", "\n", "self", ".", "warmup_method", "=", "None", "\n", "self", ".", "warmup_iters", "=", "0", "\n", "if", "scheduler", "is", "not", "None", ":", "\n", "            ", "self", ".", "warmup_method", "=", "scheduler", ".", "WARMUP_METHOD", "\n", "self", ".", "warmup_iters", "=", "scheduler", ".", "WARMUP_ITERS", "\n", "\n", "# For reproducibility.", "\n", "", "g", "=", "torch", ".", "Generator", "(", "device", "=", "device", ")", "\n", "if", "seed", ":", "\n", "            ", "g", "=", "g", ".", "manual_seed", "(", "seed", ")", "\n", "", "self", ".", "generator", "=", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.choose_std_dev": [[48, 68], ["isinstance", "len", "meddlr.utils.events.get_event_storage", "ValueError", "torch.rand().item", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage"], ["", "def", "choose_std_dev", "(", "self", ")", ":", "\n", "        ", "\"\"\"Chooses std range based on warmup.\"\"\"", "\n", "if", "not", "isinstance", "(", "self", ".", "std_devs", ",", "Sequence", ")", ":", "\n", "            ", "return", "self", ".", "std_devs", "\n", "", "elif", "len", "(", "self", ".", "std_devs", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "std_devs", "[", "0", "]", "\n", "\n", "", "if", "self", ".", "warmup_method", ":", "\n", "            ", "curr_iter", "=", "get_event_storage", "(", ")", ".", "iter", "\n", "warmup_iters", "=", "self", ".", "warmup_iters", "\n", "if", "self", ".", "warmup_method", "==", "\"linear\"", ":", "\n", "                ", "std_range", "=", "curr_iter", "/", "warmup_iters", "*", "(", "self", ".", "std_devs", "[", "1", "]", "-", "self", ".", "std_devs", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f\"`warmup_method={self.warmup_method}` not supported\"", ")", "\n", "", "", "else", ":", "\n", "            ", "std_range", "=", "self", ".", "std_devs", "[", "1", "]", "-", "self", ".", "std_devs", "[", "0", "]", "\n", "\n", "", "g", "=", "self", ".", "generator", "\n", "std_dev", "=", "self", ".", "std_devs", "[", "0", "]", "+", "std_range", "*", "torch", ".", "rand", "(", "1", ",", "generator", "=", "g", ",", "device", "=", "g", ".", "device", ")", ".", "item", "(", ")", "\n", "return", "std_dev", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.choose_motion_range": [[69, 93], ["isinstance", "len", "meddlr.utils.events.get_event_storage", "ValueError", "torch.rand().item", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.get_event_storage"], ["", "def", "choose_motion_range", "(", "self", ")", ":", "\n", "        ", "\"\"\"Chooses motion range based on warmup.\"\"\"", "\n", "if", "not", "isinstance", "(", "self", ".", "motion_range", ",", "Sequence", ")", ":", "\n", "            ", "return", "self", ".", "motion_range", "\n", "", "elif", "len", "(", "self", ".", "motion_range", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "motion_range", "[", "0", "]", "\n", "\n", "", "if", "self", ".", "warmup_method", ":", "\n", "            ", "curr_iter", "=", "get_event_storage", "(", ")", ".", "iter", "\n", "warmup_iters", "=", "self", ".", "warmup_iters", "\n", "if", "self", ".", "warmup_method", "==", "\"linear\"", ":", "\n", "                ", "motion_range", "=", "(", "\n", "curr_iter", "/", "warmup_iters", "*", "(", "self", ".", "motion_range", "[", "1", "]", "-", "self", ".", "motion_range", "[", "0", "]", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f\"`warmup_method={self.warmup_method}` not supported\"", ")", "\n", "", "", "else", ":", "\n", "            ", "motion_range", "=", "self", ".", "motion_range", "[", "1", "]", "-", "self", ".", "motion_range", "[", "0", "]", "\n", "\n", "", "g", "=", "self", ".", "generator", "\n", "motion_range", "=", "(", "\n", "self", ".", "motion_range", "[", "0", "]", "+", "motion_range", "*", "torch", ".", "rand", "(", "1", ",", "generator", "=", "g", ",", "device", "=", "g", ".", "device", ")", ".", "item", "(", ")", "\n", ")", "\n", "return", "motion_range", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.__call__": [[94, 96], ["noiseandmotion.NoiseAndMotionModel.forward"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MultiplyModule.forward"], ["", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "forward", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.forward": [[97, 138], ["meddlr.ops.complex.get_mask", "torch.zeros", "noiseandmotion.NoiseAndMotionModel.choose_std_dev", "noiseandmotion.NoiseAndMotionModel.choose_motion_range", "range", "meddlr.ops.complex.is_complex", "kspace.clone.clone.clone", "torch.Generator().manual_seed", "torch.from_numpy", "torch.view_as_complex", "torch.rand().numpy", "torch.rand().numpy", "numpy.exp", "torch.randn", "torch.randn", "torch.Generator", "torch.rand", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.choose_std_dev", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.choose_motion_range", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex"], ["", "def", "forward", "(", "self", ",", "kspace", ",", "mask", "=", "None", ",", "seed", "=", "None", ",", "clone", "=", "True", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"Performs noise augmentation followed by motion simulation on undersampled kspace mask.\"\"\"", "\n", "if", "clone", ":", "\n", "            ", "kspace", "=", "kspace", ".", "clone", "(", ")", "\n", "", "mask", "=", "cplx", ".", "get_mask", "(", "kspace", ")", "\n", "\n", "g", "=", "(", "\n", "self", ".", "generator", "\n", "if", "seed", "is", "None", "\n", "else", "torch", ".", "Generator", "(", "device", "=", "kspace", ".", "device", ")", ".", "manual_seed", "(", "seed", ")", "\n", ")", "\n", "\n", "phase_matrix", "=", "torch", ".", "zeros", "(", "kspace", ".", "shape", ",", "dtype", "=", "torch", ".", "complex64", ")", "\n", "width", "=", "kspace", ".", "shape", "[", "2", "]", "\n", "\n", "noise_std", "=", "self", ".", "choose_std_dev", "(", ")", "\n", "scale", "=", "self", ".", "choose_motion_range", "(", ")", "\n", "\n", "odd_err", "=", "(", "2", "*", "np", ".", "pi", "*", "scale", ")", "*", "torch", ".", "rand", "(", "1", ",", "generator", "=", "g", ")", ".", "numpy", "(", ")", "-", "np", ".", "pi", "*", "scale", "\n", "even_err", "=", "(", "2", "*", "np", ".", "pi", "*", "scale", ")", "*", "torch", ".", "rand", "(", "1", ",", "generator", "=", "g", ")", ".", "numpy", "(", ")", "-", "np", ".", "pi", "*", "scale", "\n", "\n", "for", "line", "in", "range", "(", "width", ")", ":", "\n", "            ", "if", "line", "%", "2", "==", "0", ":", "\n", "                ", "rand_err", "=", "even_err", "\n", "", "else", ":", "\n", "                ", "rand_err", "=", "odd_err", "\n", "", "phase_error", "=", "torch", ".", "from_numpy", "(", "np", ".", "exp", "(", "-", "1j", "*", "rand_err", ")", ")", "\n", "phase_matrix", "[", ":", ",", ":", ",", "line", "]", "=", "phase_error", "\n", "", "aug_kspace", "=", "kspace", "*", "phase_matrix", "\n", "\n", "if", "cplx", ".", "is_complex", "(", "aug_kspace", ")", ":", "\n", "            ", "noise", "=", "noise_std", "*", "torch", ".", "randn", "(", "\n", "aug_kspace", ".", "shape", "+", "(", "2", ",", ")", ",", "generator", "=", "g", ",", "device", "=", "aug_kspace", ".", "device", "\n", ")", "\n", "noise", "=", "torch", ".", "view_as_complex", "(", "noise", ")", "\n", "", "else", ":", "\n", "            ", "noise", "=", "noise_std", "*", "torch", ".", "randn", "(", "aug_kspace", ".", "shape", ",", "generator", "=", "g", ",", "device", "=", "aug_kspace", ".", "device", ")", "\n", "", "masked_noise", "=", "noise", "*", "mask", "\n", "noised_aug_kspace", "=", "aug_kspace", "+", "masked_noise", "\n", "\n", "return", "noised_aug_kspace", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.noiseandmotion.NoiseAndMotionModel.from_cfg": [[139, 144], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_cfg", "(", "cls", ",", "cfg", ",", "seed", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "cfg", "=", "cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", "\n", "return", "cls", "(", "\n", "cfg", ".", "NOISE", ".", "STD_DEV", ",", "cfg", ".", "MOTION", ".", "RANGE", ",", "scheduler", "=", "cfg", ".", "NOISE", ".", "SCHEDULER", ",", "seed", "=", "seed", ",", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler.TestWarmupTF.test_init": [[31, 37], ["multiprocessing.Pool", "p.apply", "pytest.raises", "meddlr.transforms.tf_scheduler.WarmupTF", "mock.MockSchedulable"], "methods", ["None"], ["    ", "def", "test_init", "(", "self", ")", ":", "\n", "        ", "with", "mp", ".", "Pool", "(", "1", ")", "as", "p", ":", "\n", "            ", "p", ".", "apply", "(", "_assert_fails_build_scheduler_mp", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "WarmupTF", "(", "tfm", "=", "MockSchedulable", "(", "a", "=", "0.5", ")", ",", "warmup_iters", "=", "100", ",", "params", "=", "\"foo\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler.TestWarmupTF.test_warmup_basic": [[38, 76], ["mock.MockSchedulable", "meddlr.transforms.tf_scheduler.WarmupTF", "test_tf_scheduler._run_simulation", "numpy.allclose", "meddlr.transforms.tf_scheduler.WarmupTF", "test_tf_scheduler._run_simulation", "numpy.allclose", "meddlr.transforms.tf_scheduler.WarmupTF", "test_tf_scheduler._run_simulation", "numpy.allclose", "numpy.allclose", "len", "len", "len", "_run_simulation.keys", "_run_simulation.keys", "_run_simulation.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._run_simulation", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._run_simulation", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._run_simulation"], ["", "", "def", "test_warmup_basic", "(", "self", ")", ":", "\n", "        ", "a", "=", "0.5", "\n", "b", "=", "(", "0.0", ",", "0.5", ")", "\n", "schedulable", "=", "MockSchedulable", "(", "a", "=", "a", ",", "b", "=", "b", ")", "\n", "\n", "warmup_iters", "=", "5", "\n", "method", "=", "\"linear\"", "\n", "total_iters", "=", "warmup_iters", "+", "2", "\n", "a_expected", "=", "[", "0", ",", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", ",", "0.5", ",", "0.5", "]", "\n", "b_expected", "=", "[", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0.1", ")", ",", "(", "0", ",", "0.2", ")", ",", "(", "0", ",", "0.3", ")", ",", "(", "0", ",", "0.4", ")", ",", "(", "0", ",", "0.5", ")", ",", "(", "0", ",", "0.5", ")", "]", "\n", "\n", "# Scalar", "\n", "scheduler", "=", "WarmupTF", "(", "\n", "tfm", "=", "schedulable", ",", "warmup_iters", "=", "warmup_iters", ",", "params", "=", "\"a\"", ",", "warmup_method", "=", "method", "\n", ")", "\n", "params", "=", "_run_simulation", "(", "scheduler", ",", "total_iters", ")", "\n", "assert", "len", "(", "params", ".", "keys", "(", ")", ")", "==", "1", "\n", "assert", "\"a\"", "in", "params", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"a\"", "]", ",", "a_expected", ")", "\n", "assert", "params", "[", "\"a\"", "]", "\n", "\n", "# Range", "\n", "scheduler", "=", "WarmupTF", "(", "\n", "tfm", "=", "schedulable", ",", "warmup_iters", "=", "warmup_iters", ",", "params", "=", "\"b\"", ",", "warmup_method", "=", "method", "\n", ")", "\n", "params", "=", "_run_simulation", "(", "scheduler", ",", "total_iters", ")", "\n", "assert", "len", "(", "params", ".", "keys", "(", ")", ")", "==", "1", "\n", "assert", "\"b\"", "in", "params", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"b\"", "]", ",", "b_expected", ")", "\n", "\n", "# Both", "\n", "scheduler", "=", "WarmupTF", "(", "\n", "tfm", "=", "schedulable", ",", "warmup_iters", "=", "warmup_iters", ",", "params", "=", "(", "\"a\"", ",", "\"b\"", ")", ",", "warmup_method", "=", "method", "\n", ")", "\n", "params", "=", "_run_simulation", "(", "scheduler", ",", "total_iters", ")", "\n", "assert", "len", "(", "params", ".", "keys", "(", ")", ")", "==", "2", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"a\"", "]", ",", "a_expected", ")", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"b\"", "]", ",", "b_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler.TestWarmupTF.test_warmup_nested_dict": [[77, 103], ["mock.MockSchedulable", "meddlr.transforms.tf_scheduler.WarmupTF", "test_tf_scheduler._run_simulation", "numpy.allclose", "numpy.allclose", "numpy.allclose", "len", "_run_simulation.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._run_simulation"], ["", "def", "test_warmup_nested_dict", "(", "self", ")", ":", "\n", "        ", "a", "=", "0.5", "\n", "b", "=", "{", "\"v1\"", ":", "0.5", ",", "\"v2\"", ":", "(", "0", ",", "0.5", ")", "}", "\n", "schedulable", "=", "MockSchedulable", "(", "a", "=", "a", ",", "b", "=", "b", ")", "\n", "\n", "warmup_iters", "=", "5", "\n", "method", "=", "\"linear\"", "\n", "total_iters", "=", "warmup_iters", "+", "2", "\n", "a_expected", "=", "[", "0", ",", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", ",", "0.5", ",", "0.5", "]", "\n", "b_v1_expected", "=", "[", "0", ",", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", ",", "0.5", ",", "0.5", "]", "\n", "b_v2_expected", "=", "[", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0.1", ")", ",", "(", "0", ",", "0.2", ")", ",", "(", "0", ",", "0.3", ")", ",", "(", "0", ",", "0.4", ")", ",", "(", "0", ",", "0.5", ")", ",", "(", "0", ",", "0.5", ")", "]", "\n", "\n", "scheduler", "=", "WarmupTF", "(", "\n", "tfm", "=", "schedulable", ",", "\n", "warmup_iters", "=", "warmup_iters", ",", "\n", "params", "=", "(", "\"a\"", ",", "\"b.v1\"", ",", "\"b.v2\"", ")", ",", "\n", "warmup_method", "=", "method", ",", "\n", ")", "\n", "params", "=", "_run_simulation", "(", "scheduler", ",", "total_iters", ")", "\n", "a_val", "=", "params", "[", "\"a\"", "]", "\n", "b_v1_val", "=", "[", "x", "[", "\"v1\"", "]", "for", "x", "in", "params", "[", "\"b\"", "]", "]", "\n", "b_v2_val", "=", "[", "x", "[", "\"v2\"", "]", "for", "x", "in", "params", "[", "\"b\"", "]", "]", "\n", "assert", "len", "(", "params", ".", "keys", "(", ")", ")", "==", "2", "\n", "assert", "np", ".", "allclose", "(", "a_val", ",", "a_expected", ")", "\n", "assert", "np", ".", "allclose", "(", "b_v1_val", ",", "b_v1_expected", ")", "\n", "assert", "np", ".", "allclose", "(", "b_v2_val", ",", "b_v2_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler.TestWarmupTF.test_warmup_delay": [[104, 132], ["mock.MockSchedulable", "meddlr.transforms.tf_scheduler.WarmupTF", "test_tf_scheduler._run_simulation", "numpy.allclose", "numpy.allclose", "len", "_run_simulation.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._run_simulation"], ["", "def", "test_warmup_delay", "(", "self", ")", ":", "\n", "        ", "a", "=", "0.5", "\n", "b", "=", "(", "0.0", ",", "0.5", ")", "\n", "schedulable", "=", "MockSchedulable", "(", "a", "=", "a", ",", "b", "=", "b", ")", "\n", "\n", "warmup_iters", "=", "10", "\n", "delay_iters", "=", "5", "\n", "method", "=", "\"linear\"", "\n", "total_iters", "=", "warmup_iters", "+", "2", "\n", "# fmt: off", "\n", "a_expected", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", ",", "0.5", ",", "0.5", "]", "\n", "b_expected", "=", "[", "\n", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "\n", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0.1", ")", ",", "(", "0", ",", "0.2", ")", ",", "(", "0", ",", "0.3", ")", ",", "(", "0", ",", "0.4", ")", ",", "(", "0", ",", "0.5", ")", ",", "(", "0", ",", "0.5", ")", ",", "\n", "]", "\n", "# fmt: on", "\n", "\n", "scheduler", "=", "WarmupTF", "(", "\n", "tfm", "=", "schedulable", ",", "\n", "warmup_iters", "=", "warmup_iters", ",", "\n", "params", "=", "(", "\"a\"", ",", "\"b\"", ")", ",", "\n", "warmup_method", "=", "method", ",", "\n", "delay_iters", "=", "delay_iters", ",", "\n", ")", "\n", "params", "=", "_run_simulation", "(", "scheduler", ",", "total_iters", ")", "\n", "assert", "len", "(", "params", ".", "keys", "(", ")", ")", "==", "2", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"a\"", "]", ",", "a_expected", ")", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"b\"", "]", ",", "b_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler.TestWarmupTF.test_unregister_params": [[133, 150], ["mock.MockSchedulable", "meddlr.transforms.tf_scheduler.WarmupTF", "meddlr.transforms.tf_scheduler.WarmupTF._unregister_parameters", "test_tf_scheduler._run_simulation", "numpy.allclose", "len", "_run_simulation.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._unregister_parameters", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._run_simulation"], ["", "def", "test_unregister_params", "(", "self", ")", ":", "\n", "        ", "a", "=", "0.5", "\n", "b", "=", "(", "0.0", ",", "0.5", ")", "\n", "schedulable", "=", "MockSchedulable", "(", "a", "=", "a", ",", "b", "=", "b", ")", "\n", "\n", "warmup_iters", "=", "5", "\n", "method", "=", "\"linear\"", "\n", "total_iters", "=", "warmup_iters", "+", "2", "\n", "a_expected", "=", "[", "0", ",", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", ",", "0.5", ",", "0.5", "]", "\n", "\n", "scheduler", "=", "WarmupTF", "(", "\n", "tfm", "=", "schedulable", ",", "warmup_iters", "=", "warmup_iters", ",", "params", "=", "[", "\"a\"", ",", "\"b\"", "]", ",", "warmup_method", "=", "method", "\n", ")", "\n", "scheduler", ".", "_unregister_parameters", "(", "[", "\"b\"", "]", ")", "\n", "params", "=", "_run_simulation", "(", "scheduler", ",", "total_iters", ")", "\n", "assert", "len", "(", "params", ".", "keys", "(", ")", ")", "==", "1", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"a\"", "]", ",", "a_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler.TestWarmupMultiStepTF.test_warmup_basic": [[153, 179], ["mock.MockSchedulable", "meddlr.transforms.tf_scheduler.WarmupMultiStepTF", "test_tf_scheduler._run_simulation", "numpy.allclose", "numpy.allclose", "max", "len", "_run_simulation.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._run_simulation"], ["    ", "def", "test_warmup_basic", "(", "self", ")", ":", "\n", "        ", "a", "=", "1.0", "\n", "b", "=", "(", "0.0", ",", "1.0", ")", "\n", "schedulable", "=", "MockSchedulable", "(", "a", "=", "a", ",", "b", "=", "b", ")", "\n", "\n", "warmup_milestones", "=", "(", "2", ",", "4", ",", "6", ",", "8", ")", "\n", "method", "=", "\"linear\"", "\n", "total_iters", "=", "max", "(", "warmup_milestones", ")", "+", "2", "\n", "# fmt: off", "\n", "a_expected", "=", "[", "0", ",", "0", ",", "0.25", ",", "0.25", ",", "0.5", ",", "0.5", ",", "0.75", ",", "0.75", ",", "1.0", ",", "1.0", "]", "\n", "b_expected", "=", "[", "\n", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0.25", ")", ",", "(", "0", ",", "0.25", ")", ",", "(", "0", ",", "0.5", ")", ",", "(", "0", ",", "0.5", ")", ",", "\n", "(", "0", ",", "0.75", ")", ",", "(", "0", ",", "0.75", ")", ",", "(", "0", ",", "1.0", ")", ",", "(", "0", ",", "1.0", ")", ",", "\n", "]", "\n", "# fmt: on", "\n", "\n", "scheduler", "=", "WarmupMultiStepTF", "(", "\n", "tfm", "=", "schedulable", ",", "\n", "warmup_milestones", "=", "warmup_milestones", ",", "\n", "params", "=", "(", "\"a\"", ",", "\"b\"", ")", ",", "\n", "warmup_method", "=", "method", ",", "\n", ")", "\n", "params", "=", "_run_simulation", "(", "scheduler", ",", "total_iters", ")", "\n", "assert", "len", "(", "params", ".", "keys", "(", ")", ")", "==", "2", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"a\"", "]", ",", "a_expected", ")", "\n", "assert", "np", ".", "allclose", "(", "params", "[", "\"b\"", "]", ",", "b_expected", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._run_simulation": [[13, 22], ["mock.MockIterTracker", "collections.defaultdict", "range", "scheduler.get_params().items", "mock.MockIterTracker.step", "params[].append", "scheduler.get_params"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler.get_params"], ["def", "_run_simulation", "(", "scheduler", ":", "TFScheduler", ",", "iters", ")", ":", "\n", "    ", "iter_tracker", "=", "MockIterTracker", "(", ")", "\n", "scheduler", ".", "get_iteration", "=", "iter_tracker", ".", "get_iter", "\n", "params", "=", "defaultdict", "(", "list", ")", "\n", "for", "_", "in", "range", "(", "iters", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "scheduler", ".", "get_params", "(", ")", ".", "items", "(", ")", ":", "\n", "            ", "params", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "", "iter_tracker", ".", "step", "(", ")", "\n", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_tf_scheduler._assert_fails_build_scheduler_mp": [[24, 28], ["pytest.raises", "meddlr.transforms.tf_scheduler.WarmupTF", "mock.MockSchedulable"], "function", ["None"], ["", "def", "_assert_fails_build_scheduler_mp", "(", ")", ":", "\n", "# Fail when initializing on worker thread.", "\n", "    ", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "WarmupTF", "(", "tfm", "=", "MockSchedulable", "(", "a", "=", "1.0", ",", "b", "=", "(", "0.0", ",", "0.5", ")", ")", ",", "params", "=", "\"a\"", ",", "warmup_iters", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.MockSchedulable.__init__": [[19, 23], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "a", "=", "0.5", ",", "b", "=", "(", "0.2", ",", "1.0", ")", ")", "->", "None", ":", "\n", "        ", "self", ".", "_params", "=", "{", "\"a\"", ":", "a", ",", "\"b\"", ":", "b", "}", "\n", "self", ".", "_param_kinds", "=", "{", "}", "\n", "self", ".", "_schedulers", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.MockIterTracker.__init__": [[26, 28], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "start", "=", "0", ")", "->", "None", ":", "\n", "        ", "self", ".", "_iter", "=", "start", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.MockIterTracker.step": [[29, 31], ["None"], "methods", ["None"], ["", "def", "step", "(", "self", ",", "num", "=", "1", ")", ":", "\n", "        ", "self", ".", "_iter", "+=", "num", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.MockIterTracker.get_iter": [[32, 34], ["None"], "methods", ["None"], ["", "def", "get_iter", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_iter", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data": [[8, 16], ["getattr", "torch.view_as_complex", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel.", "torch.view_as_complex", "getattr.", "meddlr.rss().unsqueeze", "getattr.", "meddlr.rss"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.rss"], ["def", "generate_mock_mri_data", "(", "ky", "=", "20", ",", "kz", "=", "20", ",", "nc", "=", "8", ",", "nm", "=", "1", ",", "bsz", "=", "1", ",", "scale", "=", "1.0", ",", "rand_func", "=", "\"randn\"", ")", ":", "\n", "    ", "func", "=", "getattr", "(", "torch", ",", "rand_func", ")", "\n", "kspace", "=", "torch", ".", "view_as_complex", "(", "func", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "2", ")", ")", "*", "scale", "\n", "maps", "=", "torch", ".", "view_as_complex", "(", "func", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "nm", ",", "2", ")", ")", "\n", "maps", "=", "maps", "/", "cplx", ".", "rss", "(", "maps", ",", "dim", "=", "-", "2", ")", ".", "unsqueeze", "(", "-", "2", ")", "\n", "A", "=", "SenseModel", "(", "maps", ")", "\n", "target", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "return", "kspace", ",", "maps", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_build.TestBuildTransforms.test_build_single": [[16, 38], ["meddlr.config.get_cfg", "meddlr.transforms.gen.RandomRot90().seed", "meddlr.transforms.build.build_transforms().seed", "torch.all", "meddlr.transforms.base.Rot90Transform", "meddlr.transforms.build.build_transforms", "meddlr.transforms.gen.RandomRot90", "meddlr.transforms.build.build_transforms", "meddlr.transforms.build.build_transforms._generator.get_state", "meddlr.transforms.base.Rot90Transform._generator.get_state"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_transforms", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_transforms"], ["model", ",", "initializers", "=", "{", "\"kind\"", ":", "\"conv\"", ",", "\"patterns\"", ":", "\".*bias\"", ",", "\"initializers\"", ":", "\"zeros_\"", "}", "\n", ")", "\n", "\n", "layers_by_kind", "=", "_get_model_layers", "(", "model", ",", "by_kind", "=", "True", ")", "\n", "for", "layer", "in", "layers_by_kind", "[", "\"conv\"", "]", ":", "\n", "        ", "assert", "torch", ".", "all", "(", "layer", ".", "bias", "==", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_build.TestBuildTransforms.test_build_with_scheduler": [[39, 70], ["meddlr.config.get_cfg", "meddlr.transforms.gen.RandomRot90().seed", "meddlr.transforms.build.build_transforms().seed", "torch.all", "isinstance", "len", "tuple", "meddlr.transforms.gen.RandomRot90", "meddlr.transforms.build.build_transforms", "tfm._generator.get_state", "meddlr.transforms.gen.RandomRot90().seed._generator.get_state", "scheduler._parameter_names"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_transforms", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.TFScheduler._parameter_names"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_build.TestBuildTransforms.test_build_complex": [[71, 132], ["meddlr.config.get_cfg", "meddlr.transforms.build.build_transforms", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "len", "tuple", "len", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_transforms"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_build.TestBuildTransforms.test_to_iter": [[133, 177], ["meddlr.config.get_cfg", "meddlr.engine.trainer.convert_cfg_time_to_iter"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.convert_cfg_time_to_iter"], []], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_subsample.test_poisson_disc": [[8, 22], ["meddlr.data.transforms.subsample.PoissonDiskMaskFunc", "meddlr.data.transforms.subsample.PoissonDiskMaskFunc.", "numpy.allclose", "torch.sum().item", "numpy.prod", "torch.sum"], "function", ["None"], ["def", "test_poisson_disc", "(", ")", ":", "\n", "    ", "\"\"\"\n    Verify that built-in Poisson Disc generator returns same value as SigPy.\n    \"\"\"", "\n", "acc", "=", "6", "\n", "calib_size", "=", "20", "\n", "shape", "=", "(", "1", ",", "320", ",", "256", ")", "# (batch, height, width)", "\n", "seed", "=", "49", "\n", "\n", "pd_builtin", "=", "PoissonDiskMaskFunc", "(", "acc", ",", "calib_size", ")", "\n", "builtin_mask", "=", "pd_builtin", "(", "shape", ",", "seed", "=", "seed", ",", "acceleration", "=", "acc", ")", "\n", "\n", "# assert all close with 5% tolerance.", "\n", "assert", "np", ".", "allclose", "(", "torch", ".", "sum", "(", "builtin_mask", ")", ".", "item", "(", ")", "/", "np", ".", "prod", "(", "shape", ")", ",", "1", "/", "acc", ",", "atol", "=", "5e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_subsample.test_random1d_reproducibility": [[24, 44], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "meddlr.data.transforms.subsample.RandomMaskFunc1D", "meddlr.data.transforms.subsample.RandomMaskFunc1D", "meddlr.data.transforms.subsample.RandomMaskFunc1D.", "meddlr.data.transforms.subsample.RandomMaskFunc1D.", "meddlr.data.transforms.subsample.RandomMaskFunc1D.", "torch.all", "torch.all", "meddlr.data.transforms.subsample.RandomMaskFunc1D.", "numpy.random.seed", "meddlr.data.transforms.subsample.RandomMaskFunc1D.", "torch.all"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"acc\"", ",", "[", "4", ",", "8", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"cf\"", ",", "[", "0.04", ",", "0.08", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"shape\"", ",", "[", "(", "100", ",", "100", ")", ",", "(", "100", ",", "200", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"seed\"", ",", "[", "0", ",", "10000", "]", ")", "\n", "def", "test_random1d_reproducibility", "(", "acc", ",", "cf", ",", "shape", ",", "seed", ")", ":", "\n", "    ", "shape", "=", "(", "1", ",", "*", "shape", ")", "\n", "a", "=", "RandomMaskFunc1D", "(", "acc", ",", "center_fractions", "=", "(", "cf", ",", ")", ")", "\n", "b", "=", "RandomMaskFunc1D", "(", "acc", ",", "center_fractions", "=", "(", "cf", ",", ")", ")", "\n", "\n", "a_mask", "=", "a", "(", "shape", ",", "seed", "=", "seed", ",", "acceleration", "=", "acc", ")", "\n", "a_mask2", "=", "a", "(", "shape", ",", "seed", "=", "seed", ",", "acceleration", "=", "acc", ")", "\n", "b_mask", "=", "b", "(", "shape", ",", "seed", "=", "seed", ",", "acceleration", "=", "acc", ")", "\n", "\n", "assert", "torch", ".", "all", "(", "a_mask", "==", "a_mask2", ")", "\n", "assert", "torch", ".", "all", "(", "a_mask", "==", "b_mask", ")", "\n", "\n", "a_mask", "=", "a", "(", "shape", ",", "seed", "=", "seed", ",", "acceleration", "=", "acc", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", "*", "2", "+", "1", ")", "\n", "a_mask2", "=", "a", "(", "shape", ",", "seed", "=", "seed", ",", "acceleration", "=", "acc", ")", "\n", "assert", "torch", ".", "all", "(", "a_mask", "==", "a_mask2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.transforms.test_subsample.test_random1d_randomness": [[46, 64], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "numpy.random.seed", "meddlr.data.transforms.subsample.RandomMaskFunc1D", "numpy.random.randint", "meddlr.data.transforms.subsample.RandomMaskFunc1D.", "meddlr.data.transforms.subsample.RandomMaskFunc1D.", "torch.any"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"acc\"", ",", "[", "4", ",", "8", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"cf\"", ",", "[", "0.04", ",", "0.08", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"shape\"", ",", "[", "(", "100", ",", "100", ")", ",", "(", "100", ",", "200", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"seed\"", ",", "[", "0", "]", ")", "\n", "def", "test_random1d_randomness", "(", "acc", ",", "cf", ",", "shape", ",", "seed", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "shape", "=", "(", "1", ",", "*", "shape", ")", "\n", "a", "=", "RandomMaskFunc1D", "(", "acc", ",", "center_fractions", "=", "(", "cf", ",", ")", ")", "\n", "seeds", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "2", "**", "32", ",", "size", "=", "100", ")", "\n", "\n", "a_mask", "=", "a", "(", "shape", ",", "seed", "=", "seed", ",", "acceleration", "=", "acc", ")", "\n", "for", "s", "in", "seeds", ":", "\n", "        ", "a_mask2", "=", "a", "(", "shape", ",", "seed", "=", "s", ",", "acceleration", "=", "acc", ")", "\n", "if", "torch", ".", "any", "(", "a_mask", "!=", "a_mask2", ")", ":", "\n", "            ", "return", "\n", "\n", "", "", "assert", "False", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.mri.add_even_odd_motion": [[7, 38], ["torch.zeros", "range", "meddlr.is_complex", "meddlr.is_complex_as_real", "torch.Generator().manual_seed", "torch.from_numpy().item", "torch.rand().cpu().numpy", "torch.rand().cpu().numpy", "torch.Generator", "torch.from_numpy", "torch.rand().cpu", "torch.rand().cpu", "numpy.exp", "torch.rand", "torch.rand"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["__all__", "=", "[", "\"SenseModel\"", "]", "\n", "\n", "\n", "class", "SenseModel", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    A module that computes forward and adjoint SENSE operations.\n\n    The forward operation converts a complex image -> multi-coil kspace.\n    The adjoint operation converts multi-coil kspace -> a complex image.\n\n    This module also supports multiple sensitivity maps. This is useful if\n    you would like to generate images from multiple estimated sensitivity maps.\n    This module also works with single coil inputs as long as the #coils dimension\n    is set to 1.\n\n    Attributes:\n        maps (torch.Tensor): Sensitivity maps. Shape ``(B, H, W, #coils, #maps, [2])``.\n        weights (torch.Tensor, optional): Undersampling masks (if applicable).\n            Shape ``(B, H, W)`` or ``(B, H, W, #coils, #coils)``.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "maps", ":", "torch", ".", "Tensor", ",", "weights", ":", "torch", ".", "Tensor", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            maps (torch.Tensor): Sensitivity maps.\n            weights (torch.Tensor): Undersampling masks.\n                If ``None``, it is assumed that inputs are fully-sampled.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "maps", "=", "maps", "\n", "if", "weights", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg.dice_score": [[36, 60], ["isinstance", "meddlr.metrics.functional.util.to_bool", "meddlr.metrics.functional.util.to_bool", "meddlr.metrics.functional.util.flatten_other_dims", "count_nonzero", "count_nonzero", "count_nonzero"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_other_dims"], ["process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "dice_score", "(", "y_pred", "=", "preds", ",", "y_true", "=", "targets", ")", "\n", "\n", "\n", "", "", "Dice", "=", "DSC", "\n", "\n", "\n", "class", "CV", "(", "Metric", ")", ":", "\n", "    ", "\"\"\"Coefficient of variation.\n\n    Attributes:\n        channel_names (Sequence[str]): Category names corresponding to the channels.\n    \"\"\"", "\n", "\n", "is_differentiable", "=", "True", "\n", "higher_is_better", "=", "False", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg.volumetric_overlap_error": [[62, 86], ["isinstance", "meddlr.metrics.functional.util.to_bool", "meddlr.metrics.functional.util.to_bool", "meddlr.metrics.functional.util.flatten_other_dims", "count_nonzero", "count_nonzero", "count_nonzero.type", "count_nonzero.astype"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_other_dims"], ["dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "coefficient_variation", "(", "y_pred", "=", "preds", ",", "y_true", "=", "targets", ")", "\n", "\n", "\n", "", "", "class", "VOE", "(", "Metric", ")", ":", "\n", "    ", "\"\"\"Volumetric overlap error.\n\n    Attributes:\n        channel_names (Sequence[str]): Category names corresponding to the channels.\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg.coefficient_variation": [[88, 119], ["isinstance", "meddlr.metrics.functional.util.to_bool", "meddlr.metrics.functional.util.to_bool", "meddlr.metrics.functional.util.flatten_other_dims", "count_nonzero", "count_nonzero", "torch.stack().type", "torch.std", "torch.mean", "numpy.std", "numpy.mean", "torch.stack"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_other_dims"], ["higher_is_better", "=", "False", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "volumetric_overlap_error", "(", "y_pred", "=", "preds", ",", "y_true", "=", "targets", ")", "\n", "\n", "\n", "", "", "class", "ASSD", "(", "Metric", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg.average_symmetric_surface_distance": [[121, 167], ["isinstance", "range", "ModuleNotFoundError", "y_pred.detach().cpu().numpy.detach().cpu().numpy", "y_true.detach().cpu().numpy.detach().cpu().numpy", "torch.zeros", "numpy.zeros", "range", "logger.warning", "_assd", "y_pred.detach().cpu().numpy.detach().cpu", "y_true.detach().cpu().numpy.detach().cpu", "sem_seg._crop_to_joint_roi", "y_pred.detach().cpu().numpy.detach", "y_true.detach().cpu().numpy.detach"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu", "home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg._crop_to_joint_roi"], ["\n", "\n", "is_differentiable", "=", "False", "\n", "higher_is_better", "=", "False", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "connectivity", ":", "int", "=", "1", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            connectivity (int): The neighbourhood/connectivity considered when determining\n                the surface of the binary objects. If in doubt, leave it as it is.\n            channel_names (Sequence[str]): Category names corresponding to the channels.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "self", ".", "connectivity", "=", "connectivity", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ",", "spacing", "=", "None", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "assd", "(", "\n", "y_pred", "=", "preds", ",", "y_true", "=", "targets", ",", "spacing", "=", "spacing", ",", "connectivity", "=", "self", ".", "connectivity", "\n", ")", "\n", "\n", "", "def", "update", "(", "self", ",", "preds", ",", "targets", ",", "spacing", "=", "None", ",", "ids", "=", "None", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "update", "(", "preds", ",", "targets", ",", "spacing", "=", "spacing", ",", "ids", "=", "ids", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg._crop_to_joint_roi": [[169, 185], ["numpy.asarray", "itertools.combinations", "tuple", "numpy.any", "reversed", "numpy.any", "max", "tuple.append", "range", "numpy.where", "slice", "np.any.max"], "function", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.Reductions.__new__": [[152, 168], ["object.__new__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.util.Reductions.__new__"], []], "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool": [[13, 34], ["isinstance", "np.asarray.type", "isinstance", "numpy.asarray", "np.asarray.astype"], "function", ["None"], [")", "->", "List", "[", "Dict", "]", ":", "\n", "    ", "\"\"\"Unroll parameters into a list of configurations.\n\n    Args:\n        params (Dict[Sequence]): Config keys and potential values they can take on.\n            These parameters will be mixed and matched to create configs.\n            Order is ``{\"param1\": [valA, valB, ...], \"param2\": [val1, val2, ...]}``\n        fixed (Dict[str, Any]): Fixed parameters to apply to every configuration.\n\n    Returns:\n        List[Dict] | List[CfgNode]: Different configurations. If ``base_cfg`` provided,\n            the different configurations are merged into the config.\n    \"\"\"", "\n", "\n", "def", "_dict_to_list", "(", "d", ")", ":", "\n", "        ", "return", "[", "x", "for", "key_value", "in", "d", ".", "items", "(", ")", "for", "x", "in", "key_value", "]", "\n", "\n", "", "configs", "=", "itertools", ".", "product", "(", "*", "list", "(", "params", ".", "values", "(", ")", ")", ")", "\n", "configs", "=", "[", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "params", ".", "keys", "(", ")", ",", "cfg", ")", "}", "for", "cfg", "in", "configs", "]", "\n", "if", "fixed", "is", "not", "None", ":", "\n", "        ", "for", "c", "in", "configs", ":", "\n", "            ", "c", ".", "update", "(", "fixed", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_other_dims": [[36, 75], ["isinstance", "type", "type.", "isinstance", "isinstance", "isinstance", "tuple", "tuple", "tuple", "x.reshape", "x.flatten", "x.permute", "x.transpose", "range"], "function", ["None"], ["        ", "configs", "=", "[", "\n", "base_cfg", ".", "clone", "(", ")", ".", "defrost", "(", ")", ".", "merge_from_list", "(", "_dict_to_list", "(", "c", ")", ")", ".", "freeze", "(", ")", "for", "c", "in", "configs", "\n", "]", "\n", "", "return", "configs", "\n", "\n", "\n", "", "def", "stringify", "(", "cfg", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "    ", "\"\"\"Convert param/value pairs into a command-line compatible string.\n\n    Args:\n        cfg (Dict[str, Any]): The configuration to stringify.\n\n    Return:\n        str: A command line compatible string.\n    \"\"\"", "\n", "cfg", "=", "{", "k", ":", "f\"'{v}'\"", "if", "isinstance", "(", "v", ",", "str", ")", "else", "v", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", "}", "\n", "cfg", "=", "{", "k", ":", "_stringify_value", "(", "v", ")", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", "}", "\n", "return", "\" \"", ".", "join", "(", "f'{k} \"{v}\"'", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", ")", "\n", "\n", "\n", "", "def", "check_dependencies", "(", "\n", "cfg_file_or_lines", ",", "return_failed_deps", ":", "bool", "=", "False", "\n", ")", "->", "Union", "[", "bool", ",", "List", "[", "str", "]", "]", ":", "\n", "    ", "\"\"\"Check that module dependencies are met for the config file.\n\n    Dependencies are specified as comments in the config file starting\n    with ``\"# DEPENDENCY:\"``.\n\n    Args:\n        cfg_file (str): The path to the config file.\n        return_failed_deps (bool, optional): Whether to return the list of\n            dependencies that are not met. Defaults to ``False``.\n\n    Returns:\n        bool | List[str]: If ``return_failed_deps=True``, returns the list of\n        dependencies that are not met. Else returns boolean of whether all\n        dependencies are met.\n    \"\"\"", "\n", "keyword", "=", "\"# DEPENDENCY:\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_non_category_dims": [[77, 89], ["util.flatten_other_dims"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_other_dims"], ["        ", "with", "open", "(", "cfg_file_or_lines", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "lines", "=", "cfg_file_or_lines", "\n", "", "lines", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "lines", "if", "keyword", "in", "line", "]", "\n", "dependencies", "=", "[", "\n", "dep", ".", "strip", "(", ")", "for", "line", "in", "lines", "for", "dep", "in", "line", ".", "split", "(", "keyword", ")", "[", "-", "1", "]", ".", "strip", "(", ")", ".", "split", "(", "\";\"", ")", "\n", "]", "\n", "\n", "missing_deps", "=", "[", "]", "\n", "for", "dep", "in", "dependencies", ":", "\n", "        ", "if", "not", "env", ".", "is_package_installed", "(", "dep", ")", ":", "\n", "            ", "missing_deps", ".", "append", "(", "dep", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.rms_cv": [[91, 122], ["isinstance", "torch.stack().type", "torch.std", "torch.mean", "torch.sqrt", "numpy.std", "numpy.mean", "numpy.sqrt", "torch.mean", "numpy.mean", "torch.stack"], "function", ["None"], ["", "", "return", "missing_deps", "if", "return_failed_deps", "else", "len", "(", "missing_deps", ")", "==", "0", "\n", "\n", "\n", "", "def", "_stringify_value", "(", "value", ",", "depth", "=", "0", ")", "->", "str", ":", "\n", "    ", "\"\"\"Convert value into command-line comaptible string.\n\n    The string representations of certain types (e.g. list, tuple)\n    are not command-line compatible. We have to add extra ``\"\"``\n    around the string for proper formatting. This function\n    formats values of primitive types (numbers, strs, collections, dicts).\n\n    Args:\n        value (Number | str | Collection | Dict): The value to convert\n            to a command-line compatible string.\n\n    Returns:\n        str: The stringified value.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "value", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", ":", "\n", "        ", "return", "value", "\n", "", "if", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "        ", "keys", "=", "list", "(", "value", ".", "keys", "(", ")", ")", "\n", "values", "=", "[", "value", "[", "k", "]", "for", "k", "in", "keys", "]", "\n", "keys_str", "=", "[", "_stringify_value", "(", "k", ",", "depth", "=", "depth", "+", "1", ")", "for", "k", "in", "keys", "]", "\n", "values_str", "=", "[", "_stringify_value", "(", "v", ",", "depth", "=", "depth", "+", "1", ")", "for", "v", "in", "values", "]", "\n", "keys_str", "=", "_to_str", "(", "keys_str", ",", "keys", ")", "\n", "values_str", "=", "_to_str", "(", "values_str", ",", "values", ")", "\n", "val_dict_str", "=", "{", "f\"{k}:{v}\"", "for", "k", ",", "v", "in", "zip", "(", "keys_str", ",", "values_str", ")", "}", "\n", "value_str", "=", "\"\\{\"", "\n", "value_str", "+=", "\",\"", ".", "join", "(", "val_dict_str", ")", "\n", "value_str", "+=", "\"\\}\"", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.rmse_cv": [[124, 146], ["isinstance", "torch.sqrt", "torch.abs", "numpy.sqrt", "numpy.absolute", "torch.mean", "torch.mean", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["value_str", "=", "\",\"", ".", "join", "(", "\n", "str", "(", "v", ")", "\n", "if", "not", "isinstance", "(", "v", ",", "str", ")", "or", "isinstance", "(", "ov", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", "\n", "else", "f\"'\\\"'\\\"'{v}'\\\"'\\\"'\"", "\n", "for", "v", ",", "ov", "in", "zip", "(", "all_vals", ",", "value", ")", "\n", ")", "\n", "if", "isinstance", "(", "value", ",", "tuple", ")", ":", "\n", "            ", "value_str", "=", "f\"\\({value_str},\\)\"", "if", "len", "(", "value", ")", ">", "0", "else", "\"\\(\\)\"", "\n", "", "else", ":", "\n", "            ", "value_str", "=", "f\"[{value_str}]\"", "\n", "\n", "", "", "return", "value_str", "\n", "\n", "\n", "", "def", "_to_str", "(", "all_vals", ",", "value", ")", ":", "\n", "    ", "return", "[", "\n", "str", "(", "v", ")", "\n", "if", "not", "isinstance", "(", "v", ",", "str", ")", "or", "isinstance", "(", "ov", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", "\n", "else", "f\"'\\\"'\\\"'{v}'\\\"'\\\"'\"", "\n", "for", "v", ",", "ov", "in", "zip", "(", "all_vals", ",", "value", ")", "\n", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._check_consistent_type": [[37, 44], ["all", "all", "ValueError", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real"], []], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.mae": [[46, 62], ["image._mean_error"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image._mean_error"], ["\n", "\n", "is_differentiable", "=", "True", "\n", "higher_is_better", "=", "True", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.mse": [[64, 80], ["image._mean_error"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image._mean_error"], [")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"dB\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "psnr", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._mean_error": [[82, 110], ["torch.mean", "torch.mean", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real", "meddlr.ops.complex.abs", "torch.abs", "torch.abs", "torch.abs.view"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["    ", "\"\"\"Mean absolute error with complex-valued support.\n\n    :math:`MAE = \\\\frac{1}{N} \\sum_{i=1}^{N} |x_{pred} - x_{gt}|`.\n\n    This implementation supports complex tensors.\n    ``im_type`` controls how the complex tensor should be processed:\n\n        - ``'magnitude'``: :math:`x_{pred}` and :math:`x_{gt}` are converted to magnitude images.\n        - ``'phase'``: :math:`x_{pred}` and :math:`x_{gt}` are converted to phase images.\n        - ``'real'``: Real components of :math:`x_{pred}` and :math:`x_{gt}` are used.\n        - ``'imag'``: Imaginary components of :math:`x_{pred}` and :math:`x_{gt}` are used.\n\n    Attributes:\n        im_type (str): The type of the complex image to compute the metric on.\n            This only applies to complex tensors.\n        channel_names (Sequence[str]): The names of the channels in the input.\n    \"\"\"", "\n", "\n", "is_differentiable", "=", "True", "\n", "higher_is_better", "=", "False", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.rmse": [[112, 128], ["torch.sqrt", "torch.sqrt", "image.mse"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.mse"], [")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "mae", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.psnr": [[130, 152], ["image.rmse", "torch.amax", "torch.amax", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real", "abs_func().view", "torch.log10", "torch.log10", "abs_func"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.rmse", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real"], ["    ", "\"\"\"Mean squared error with complex-valued support.\n\n    :math:`MSE = ||x_{pred} - x_{gt}||_2^2`.\n\n    This implementation supports complex tensors.\n    ``im_type`` controls how the complex tensor should be processed:\n\n        - ``'magnitude'``: :math:`x_{pred}` and :math:`x_{gt}` are converted to magnitude images.\n        - ``'phase'``: :math:`x_{pred}` and :math:`x_{gt}` are converted to phase images.\n        - ``'real'``: Real components of :math:`x_{pred}` and :math:`x_{gt}` are used.\n        - ``'imag'``: Imaginary components of :math:`x_{pred}` and :math:`x_{gt}` are used.\n\n    Attributes:\n        im_type (str): The type of the complex image to compute the metric on.\n            This only applies to complex tensors.\n        channel_names (Sequence[str]): The names of the channels in the input.\n    \"\"\"", "\n", "\n", "is_differentiable", "=", "True", "\n", "higher_is_better", "=", "False", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.nrmse": [[154, 178], ["image.rmse", "torch.sqrt", "torch.sqrt", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real", "torch.mean", "torch.mean", "abs_func"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.rmse", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real"], ["channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "mse", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n", "\n", "", "", "class", "NRMSE", "(", "Metric", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.l2_norm": [[180, 202], ["torch.sum", "torch.sum", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real", "abs_func().view", "abs_func"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real"], ["\n", "\n", "is_differentiable", "=", "True", "\n", "higher_is_better", "=", "False", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.ssim": [[204, 259], ["image._ssim_compute", "tuple", "_ssim_compute.mean", "range", "method.lower", "ValueError", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image._ssim_compute", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real"], ["compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "nrmse", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n", "\n", "", "", "nRMSE", "=", "NRMSE", "\n", "\n", "\n", "class", "RMSE", "(", "Metric", ")", ":", "\n", "    ", "\"\"\"Root-mean-squared error with complex-valued support.\n\n    :math:`RMSE = ||x_{pred} - x_{gt}||_2`.\n\n    This implementation supports complex tensors.\n    ``im_type`` controls how the complex tensor should be processed:\n\n        - ``'magnitude'``: :math:`x_{pred}` and :math:`x_{gt}` are converted to magnitude images.\n        - ``'phase'``: :math:`x_{pred}` and :math:`x_{gt}` are converted to phase images.\n        - ``'real'``: Real components of :math:`x_{pred}` and :math:`x_{gt}` are used.\n        - ``'imag'``: Imaginary components of :math:`x_{pred}` and :math:`x_{gt}` are used.\n\n    Attributes:\n        im_type (str): The type of the complex image to compute the metric on.\n            This only applies to complex tensors.\n        channel_names (Sequence[str]): The names of the channels in the input.\n    \"\"\"", "\n", "\n", "is_differentiable", "=", "True", "\n", "higher_is_better", "=", "False", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._ssim_compute": [[261, 371], ["isinstance", "isinstance", "any", "any", "tuple", "len", "c1.view.view", "c2.view.view", "_pad.size", "image._gaussian_kernel", "tuple", "image._pad", "image._pad", "torch.cat", "torch.cat", "output_list[].pow", "output_list[].pow", "len", "ValueError", "len", "ValueError", "ValueError", "ValueError", "range", "isinstance", "torch.as_tensor", "torch.as_tensor", "torch.conv2d", "torch.conv3d", "torch.amax", "torch.amax", "torch.amin", "torch.amin", "torch.amax", "torch.amax", "range", "len", "torch.amax", "torch.amax", "torch.amin", "torch.amin", "torch.amax", "torch.amax", "_pad.size", "_pad.size", "torch.amax", "torch.amax", "torch.cat", "torch.cat", "torch.amax", "torch.amax", "torch.amin", "torch.amin", "torch.amax", "torch.amax", "torch.amin", "torch.amin"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image._gaussian_kernel", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._pad", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._pad"], ["channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "rmse", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n", "\n", "", "", "class", "SSIM", "(", "Metric", ")", ":", "\n", "    ", "\"\"\"Structural similarity index measure with complex-valued support.\n\n    This implementation of pSNR supports complex tensors.\n    ``im_type`` controls how the complex tensor should be processed:\n\n        - ``'magnitude'``: :math:`x_{pred}` and :math:`x_{gt}` are converted to magnitude images.\n        - ``'phase'``: :math:`x_{pred}` and :math:`x_{gt}` are converted to phase images.\n        - ``'real'``: Real components of :math:`x_{pred}` and :math:`x_{gt}` are used.\n        - ``'imag'``: Imaginary components of :math:`x_{pred}` and :math:`x_{gt}` are used.\n\n    Attributes:\n        method (str): The method to use for computing the SSIM.\n            Defaults to ``'wang'``.\n        im_type (str): The type of the complex image to compute the metric on.\n            This only applies to complex tensors.\n        channel_names (Sequence[str]): The names of the channels in the input.\n    \"\"\"", "\n", "\n", "is_differentiable", "=", "True", "\n", "higher_is_better", "=", "True", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "method", ":", "str", "=", "\"wang\"", ",", "\n", "im_type", ":", "str", "=", "\"magnitude\"", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "self", ".", "method", "=", "method", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n", "", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "ssim", "(", "\n", "preds", ",", "\n", "targets", ",", "\n", "method", "=", "self", ".", "method", ",", "\n", "im_type", "=", "self", ".", "im_type", ",", "\n", ")", "\n", "\n", "\n", "", "", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"metrics.functional.mse\"", ")", "\n", "def", "compute_mse", "(", "ref", ":", "torch", ".", "Tensor", ",", "x", ":", "torch", ".", "Tensor", ",", "is_batch", "=", "False", ",", "magnitude", "=", "False", ")", ":", "\n", "    ", "if", "cplx", ".", "is_complex", "(", "ref", ")", ":", "\n", "        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "if", "magnitude", ":", "\n", "        ", "squared_err", "=", "torch", ".", "abs", "(", "cplx", ".", "abs", "(", "x", ")", "-", "cplx", ".", "abs", "(", "ref", ")", ")", "**", "2", "\n", "", "else", ":", "\n", "        ", "squared_err", "=", "cplx", ".", "abs", "(", "x", "-", "ref", ")", "**", "2", "\n", "", "shape", "=", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "if", "is_batch", "else", "-", "1", "\n", "return", "torch", ".", "mean", "(", "squared_err", ".", "view", "(", "shape", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "\n", "", "def", "compute_l2", "(", "ref", ":", "torch", ".", "Tensor", ",", "x", ":", "torch", ".", "Tensor", ",", "is_batch", "=", "False", ",", "magnitude", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        ref (torch.Tensor): The target. Shape (...)x2\n        x (torch.Tensor): The prediction. Same shape as `ref`.\n    \"\"\"", "\n", "if", "cplx", ".", "is_complex", "(", "ref", ")", ":", "\n", "        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "return", "torch", ".", "sqrt", "(", "compute_mse", "(", "ref", ",", "x", ",", "is_batch", "=", "is_batch", ",", "magnitude", "=", "magnitude", ")", ")", "\n", "\n", "\n", "", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"metrics.functional.psnr\"", ")", "\n", "def", "compute_psnr", "(", "ref", ":", "torch", ".", "Tensor", ",", "x", ":", "torch", ".", "Tensor", ",", "is_batch", "=", "False", ",", "magnitude", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute peak to signal to noise ratio of magnitude image.\n\n    Args:\n        ref (torch.Tensor): The target. Shape (...)x2\n        x (torch.Tensor): The prediction. Same shape as `ref`.\n\n    Returns:\n        Tensor: Scalar in db\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._gaussian_kernel": [[373, 392], ["len", "_gaussian", "_gaussian", "torch.matmul", "torch.matmul", "torch.matmul.expand", "_gaussian.t", "_gaussian", "torch.matmul.unsqueeze", "_gaussian.t().unsqueeze", "_gaussian.t"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul"], ["        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "not", "is_batch", ",", "\"is_batch not supported\"", "\n", "l2", "=", "compute_l2", "(", "ref", ",", "x", ",", "magnitude", "=", "magnitude", ",", "is_batch", "=", "False", ")", "\n", "# shape = (x.shape[0], -1) if is_batch else -1", "\n", "return", "20", "*", "torch", ".", "log10", "(", "cplx", ".", "abs", "(", "ref", ")", ".", "max", "(", ")", "/", "l2", ")", "\n", "\n", "\n", "", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"metrics.functional.nrmse\"", ")", "\n", "def", "compute_nrmse", "(", "ref", ",", "x", ",", "is_batch", "=", "False", ",", "magnitude", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute normalized root mean square error.\n    The norm of reference is used to normalize the metric.\n\n    Args:\n        ref (torch.Tensor): The target. Shape (...)x2\n        x (torch.Tensor): The prediction. Same shape as `ref`.\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._pad": [[394, 412], ["image._pad_3d_tensor_with_2d_padding", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.cat", "torch.cat", "torch.pad"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image._pad_3d_tensor_with_2d_padding", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad"], ["        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "rmse", "=", "compute_l2", "(", "ref", ",", "x", ",", "is_batch", "=", "is_batch", ",", "magnitude", "=", "magnitude", ")", "\n", "shape", "=", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "if", "is_batch", "else", "-", "1", "\n", "norm", "=", "torch", ".", "sqrt", "(", "torch", ".", "mean", "(", "(", "cplx", ".", "abs", "(", "ref", ")", "**", "2", ")", ".", "view", "(", "shape", ")", ",", "dim", "=", "-", "1", ")", ")", "\n", "\n", "return", "rmse", "/", "norm", "\n", "\n", "\n", "", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"metrics.functional.ssim\"", ")", "\n", "def", "compute_ssim", "(", "\n", "ref", ":", "torch", ".", "Tensor", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "multichannel", ":", "bool", "=", "False", ",", "\n", "data_range", "=", "None", ",", "\n", "**", "kwargs", ",", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._pad_3d_tensor_with_2d_padding": [[414, 420], ["x.reshape.reshape", "torch.pad", "x.reshape.reshape", "numpy.prod"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad"], ["    "]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_util.test_to_bool": [[7, 16], ["numpy.all", "numpy.array", "numpy.all", "torch.tensor", "torch.all", "meddlr.metrics.functional.util.to_bool", "numpy.asarray", "meddlr.metrics.functional.util.to_bool", "numpy.asarray", "meddlr.metrics.functional.util.to_bool", "torch.as_tensor"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.to_bool"], ["\n", "\n", "def", "test_check_dependencies", "(", ")", ":", "\n", "    ", "cfg_file", "=", "util", ".", "get_cfg_path", "(", "\"tests/basic-with-deps.yaml\"", ")", "\n", "assert", "check_dependencies", "(", "cfg_file", ")", "\n", "\n", "\n", "", "def", "test_configure_params", "(", ")", ":", "\n", "    ", "params", "=", "{", "\"DESCRIPTION.BRIEF\"", ":", "[", "\"foo\"", ",", "\"bar\"", ",", "\"foobar\"", "]", "}", "\n", "fixed", "=", "{", "\"DESCRIPTION.PROJECT_NAME\"", ":", "\"test\"", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_util.test_flatten_other_dims": [[18, 26], ["numpy.random.rand", "meddlr.metrics.functional.util.flatten_other_dims", "numpy.all", "torch.rand", "meddlr.metrics.functional.util.flatten_other_dims", "torch.all", "torch.rand.flatten", "torch.rand.flatten"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_other_dims", "home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_other_dims"], ["\n", "cfgs", "=", "configure_params", "(", "params", ")", "\n", "assert", "len", "(", "cfgs", ")", "==", "3", "\n", "for", "cfg", ",", "val", "in", "zip", "(", "cfgs", ",", "params", "[", "\"DESCRIPTION.BRIEF\"", "]", ")", ":", "\n", "        ", "assert", "cfg", "[", "\"DESCRIPTION.BRIEF\"", "]", "==", "val", "\n", "\n", "", "cfgs", "=", "configure_params", "(", "params", ",", "base_cfg", "=", "base_cfg", ")", "\n", "assert", "len", "(", "cfgs", ")", "==", "3", "\n", "for", "cfg", ",", "val", "in", "zip", "(", "cfgs", ",", "params", "[", "\"DESCRIPTION.BRIEF\"", "]", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_util.test_flatten_non_category_dims": [[28, 32], ["torch.rand", "meddlr.metrics.functional.util.flatten_non_category_dims", "torch.all", "torch.rand.flatten"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.util.flatten_non_category_dims"], ["\n", "", "cfgs", "=", "configure_params", "(", "params", ",", "fixed", "=", "fixed", ",", "base_cfg", "=", "base_cfg", ")", "\n", "assert", "len", "(", "cfgs", ")", "==", "3", "\n", "for", "cfg", ",", "val", "in", "zip", "(", "cfgs", ",", "params", "[", "\"DESCRIPTION.BRIEF\"", "]", ")", ":", "\n", "        ", "assert", "cfg", ".", "DESCRIPTION", ".", "BRIEF", "==", "val", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_mse_legacy": [[27, 44], ["torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor.unsqueeze().unsqueeze", "torch.as_tensor.unsqueeze().unsqueeze", "torch.as_tensor", "torch.as_tensor", "meddlr.metrics.functional.image.mse", "torch.allclose", "torch.allclose", "torch.as_tensor", "torch.as_tensor", "meddlr.metrics.functional.image.mse", "torch.allclose", "torch.allclose", "meddlr.metrics.image.compute_mse().item", "meddlr.metrics.image.compute_mse().item", "skimage.data.cells3d().astype", "numpy.random.randn().astype", "torch.as_tensor.mean", "torch.as_tensor.unsqueeze", "torch.as_tensor.unsqueeze", "meddlr.metrics.image.compute_mse", "meddlr.metrics.image.compute_mse", "skimage.data.cells3d", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.mse", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.mse", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_mse", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_mse"], ["", "def", "test_mse_legacy", "(", ")", ":", "\n", "    ", "target", "=", "data", ".", "cells3d", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "22", ":", "37", ",", ":", ",", "75", ":", "150", ",", "75", ":", "150", "]", "[", ":", ",", "0", "]", "# D x H x W", "\n", "target", "=", "target", "+", "1j", "*", "target", "\n", "pred", "=", "target", "+", "np", ".", "random", ".", "randn", "(", "*", "target", ".", "shape", ")", ".", "astype", "(", "np", ".", "complex64", ")", "*", "target", ".", "mean", "(", ")", "\n", "\n", "target", "=", "torch", ".", "as_tensor", "(", "target", ")", "\n", "pred", "=", "torch", ".", "as_tensor", "(", "pred", ")", "\n", "pred_tensor", "=", "pred", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "# BxCxDxHxW", "\n", "target_tensor", "=", "target", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "# BxCxDxHxW", "\n", "\n", "legacy_value", "=", "torch", ".", "as_tensor", "(", "compute_mse", "(", "target", ",", "pred", ")", ".", "item", "(", ")", ")", "\n", "out", "=", "mse", "(", "pred_tensor", ",", "target_tensor", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "legacy_value", ")", "\n", "\n", "legacy_value", "=", "torch", ".", "as_tensor", "(", "compute_mse", "(", "target", ",", "pred", ",", "magnitude", "=", "True", ")", ".", "item", "(", ")", ")", "\n", "out", "=", "mse", "(", "pred_tensor", ",", "target_tensor", ",", "im_type", "=", "\"magnitude\"", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "legacy_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_psnr_legacy": [[46, 63], ["torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor.unsqueeze().unsqueeze", "torch.as_tensor.unsqueeze().unsqueeze", "torch.as_tensor", "torch.as_tensor", "meddlr.metrics.functional.image.psnr", "torch.allclose", "torch.allclose", "torch.as_tensor", "torch.as_tensor", "meddlr.metrics.functional.image.psnr", "torch.allclose", "torch.allclose", "meddlr.metrics.image.compute_psnr().item", "meddlr.metrics.image.compute_psnr().item", "skimage.data.cells3d().astype", "numpy.random.randn().astype", "torch.as_tensor.mean", "torch.as_tensor.unsqueeze", "torch.as_tensor.unsqueeze", "meddlr.metrics.image.compute_psnr", "meddlr.metrics.image.compute_psnr", "skimage.data.cells3d", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.psnr", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.psnr", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_psnr", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_psnr"], ["", "def", "test_psnr_legacy", "(", ")", ":", "\n", "    ", "target", "=", "data", ".", "cells3d", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "22", ":", "37", ",", ":", ",", "75", ":", "150", ",", "75", ":", "150", "]", "[", ":", ",", "0", "]", "# D x H x W", "\n", "target", "=", "target", "+", "1j", "*", "target", "\n", "pred", "=", "target", "+", "np", ".", "random", ".", "randn", "(", "*", "target", ".", "shape", ")", ".", "astype", "(", "np", ".", "complex64", ")", "*", "target", ".", "mean", "(", ")", "\n", "\n", "target", "=", "torch", ".", "as_tensor", "(", "target", ")", "\n", "pred", "=", "torch", ".", "as_tensor", "(", "pred", ")", "\n", "pred_tensor", "=", "pred", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "# BxCxDxHxW", "\n", "target_tensor", "=", "target", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "# BxCxDxHxW", "\n", "\n", "legacy_value", "=", "torch", ".", "as_tensor", "(", "compute_psnr", "(", "target", ",", "pred", ")", ".", "item", "(", ")", ")", "\n", "out", "=", "psnr", "(", "pred_tensor", ",", "target_tensor", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "legacy_value", ")", "\n", "\n", "legacy_value", "=", "torch", ".", "as_tensor", "(", "compute_psnr", "(", "target", ",", "pred", ",", "magnitude", "=", "True", ")", ".", "item", "(", ")", ")", "\n", "out", "=", "psnr", "(", "pred_tensor", ",", "target_tensor", ",", "im_type", "=", "\"magnitude\"", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "legacy_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_nrmse_legacy": [[65, 82], ["torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor.unsqueeze().unsqueeze", "torch.as_tensor.unsqueeze().unsqueeze", "torch.as_tensor", "torch.as_tensor", "meddlr.metrics.functional.image.nrmse", "torch.allclose", "torch.allclose", "torch.as_tensor", "torch.as_tensor", "meddlr.metrics.functional.image.nrmse", "torch.allclose", "torch.allclose", "meddlr.metrics.image.compute_nrmse().item", "meddlr.metrics.image.compute_nrmse().item", "skimage.data.cells3d().astype", "numpy.random.randn().astype", "torch.as_tensor.mean", "torch.as_tensor.unsqueeze", "torch.as_tensor.unsqueeze", "meddlr.metrics.image.compute_nrmse", "meddlr.metrics.image.compute_nrmse", "skimage.data.cells3d", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.nrmse", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.nrmse", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_nrmse", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_nrmse"], ["", "def", "test_nrmse_legacy", "(", ")", ":", "\n", "    ", "target", "=", "data", ".", "cells3d", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "22", ":", "37", ",", ":", ",", "75", ":", "150", ",", "75", ":", "150", "]", "[", ":", ",", "0", "]", "# D x H x W", "\n", "target", "=", "target", "+", "1j", "*", "target", "\n", "pred", "=", "target", "+", "np", ".", "random", ".", "randn", "(", "*", "target", ".", "shape", ")", ".", "astype", "(", "np", ".", "complex64", ")", "*", "target", ".", "mean", "(", ")", "\n", "\n", "target", "=", "torch", ".", "as_tensor", "(", "target", ")", "\n", "pred", "=", "torch", ".", "as_tensor", "(", "pred", ")", "\n", "pred_tensor", "=", "pred", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "# BxCxDxHxW", "\n", "target_tensor", "=", "target", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "# BxCxDxHxW", "\n", "\n", "legacy_value", "=", "torch", ".", "as_tensor", "(", "compute_nrmse", "(", "target", ",", "pred", ")", ".", "item", "(", ")", ")", "\n", "out", "=", "nrmse", "(", "pred_tensor", ",", "target_tensor", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "legacy_value", ")", "\n", "\n", "legacy_value", "=", "torch", ".", "as_tensor", "(", "compute_nrmse", "(", "target", ",", "pred", ",", "magnitude", "=", "True", ")", ".", "item", "(", ")", ")", "\n", "out", "=", "nrmse", "(", "pred_tensor", ",", "target_tensor", ",", "im_type", "=", "\"magnitude\"", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "legacy_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_ssim_torchmetrics_reproducibility": [[84, 124], ["[].astype", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "tm_ssim().mean", "meddlr.metrics.functional.image.ssim().mean", "torch.allclose", "torch.allclose", "[].astype.max", "[].astype.min", "numpy.random.randn().astype", "[].astype.mean", "tm_ssim", "meddlr.metrics.functional.image.ssim", "skimage.data.brain", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.ssim"], ["", "def", "test_ssim_torchmetrics_reproducibility", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test reproducibility between SSIM implementations in meddlr and torchmetrics.\n\n    Torchmetrics only supports 2D SSIM, which is what we test here.\n    \"\"\"", "\n", "img", "=", "data", ".", "brain", "(", ")", "[", ":", ",", "np", ".", "newaxis", ",", "...", "]", ".", "astype", "(", "np", ".", "float32", ")", "# B x C x H x W", "\n", "img_noise", "=", "img", "+", "np", ".", "random", ".", "randn", "(", "*", "img", ".", "shape", ")", ".", "astype", "(", "np", ".", "float32", ")", "*", "img", ".", "mean", "(", ")", "\n", "img_noise", "[", "img_noise", "<", "0.0", "]", "=", "0.0", "\n", "data_range", "=", "img", ".", "max", "(", ")", "-", "img", ".", "min", "(", ")", "\n", "\n", "tensor_noise", "=", "torch", ".", "from_numpy", "(", "img_noise", ")", "\n", "tensor_base", "=", "torch", ".", "from_numpy", "(", "img", ")", "\n", "\n", "ks", "=", "11", "\n", "sigma", "=", "1.5", "\n", "k1", "=", "0.01", "\n", "k2", "=", "0.03", "\n", "\n", "expected_ssim_val", "=", "tm_ssim", "(", "\n", "tensor_noise", ",", "\n", "tensor_base", ",", "\n", "data_range", "=", "data_range", ",", "\n", "kernel_size", "=", "(", "ks", ",", "ks", ")", ",", "\n", "sigma", "=", "(", "sigma", ",", "sigma", ")", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "k1", "=", "k1", ",", "\n", "k2", "=", "k2", ",", "\n", ")", ".", "mean", "(", ")", "\n", "\n", "ssim_val", "=", "ssim", "(", "\n", "tensor_noise", ",", "\n", "tensor_base", ",", "\n", "data_range", "=", "data_range", ",", "\n", "kernel_size", "=", "ks", ",", "\n", "sigma", "=", "sigma", ",", "\n", "k1", "=", "k1", ",", "\n", "k2", "=", "k2", ",", "\n", ")", ".", "mean", "(", ")", "\n", "assert", "torch", ".", "allclose", "(", "ssim_val", ",", "expected_ssim_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_ssim_scikit_image_reproducibility": [[126, 193], ["torch.from_numpy().permute().unsqueeze", "torch.from_numpy().permute().unsqueeze", "torch.from_numpy().permute().unsqueeze", "torch.from_numpy().permute().unsqueeze", "range", "skimage.metrics.structural_similarity", "meddlr.metrics.functional.image.ssim().mean", "torch.allclose", "torch.allclose", "skimage.data.cells3d().astype", "img3d.max", "img3d.min", "skimage.metrics.structural_similarity", "meddlr.metrics.functional.image.ssim().mean", "torch.allclose", "torch.allclose", "img3d.transpose", "img3d_noise.transpose", "torch.as_tensor", "torch.as_tensor", "numpy.random.randn().astype", "img3d.mean", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.as_tensor", "torch.as_tensor", "meddlr.metrics.functional.image.ssim", "skimage.metrics.structural_similarity.item", "skimage.data.cells3d", "img3d.transpose", "img3d_noise.transpose", "meddlr.metrics.functional.image.ssim", "skimage.metrics.structural_similarity.item", "numpy.random.randn", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.ssim", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.ssim"], ["", "def", "test_ssim_scikit_image_reproducibility", "(", ")", ":", "\n", "    ", "\"\"\"Test reproducibility between SSIM implementations in meddlr and scikit-image.\n\n    Scikit-image supports 3D multichannel SSIM.\n    We test 2D, 2D multichannel, 3D, and 3D multichannel.\n    \"\"\"", "\n", "img3d", "=", "data", ".", "cells3d", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "22", ":", "37", ",", ":", ",", "75", ":", "150", ",", "75", ":", "150", "]", "# D x C x H x W", "\n", "img3d_noise", "=", "img3d", "+", "np", ".", "random", ".", "randn", "(", "*", "img3d", ".", "shape", ")", ".", "astype", "(", "np", ".", "float32", ")", "*", "img3d", ".", "mean", "(", ")", "\n", "img3d_noise", "[", "img3d_noise", "<", "0.0", "]", "=", "0.0", "\n", "data_range", "=", "img3d", ".", "max", "(", ")", "-", "img3d", ".", "min", "(", ")", "\n", "\n", "tensor_base", "=", "torch", ".", "from_numpy", "(", "img3d", ")", ".", "permute", "(", "1", ",", "0", ",", "2", ",", "3", ")", ".", "unsqueeze", "(", "0", ")", "# B x C x D x H x W", "\n", "tensor_noise", "=", "(", "\n", "torch", ".", "from_numpy", "(", "img3d_noise", ")", ".", "permute", "(", "1", ",", "0", ",", "2", ",", "3", ")", ".", "unsqueeze", "(", "0", ")", "\n", ")", "# B x C x D x H x W", "\n", "\n", "ks", "=", "11", "\n", "sigma", "=", "1.5", "\n", "k1", "=", "0.01", "\n", "k2", "=", "0.03", "\n", "\n", "# 2D", "\n", "for", "sl", "in", "range", "(", "img3d", ".", "shape", "[", "0", "]", "//", "2", "-", "3", ",", "img3d", ".", "shape", "[", "0", "]", "//", "2", "+", "3", ")", ":", "\n", "        ", "expected_ssim_val", "=", "structural_similarity", "(", "\n", "img3d", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", "[", "sl", "]", ",", "# H x W x C", "\n", "img3d_noise", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", "[", "sl", "]", ",", "# H x W x C", "\n", "multichannel", "=", "True", ",", "\n", "win_size", "=", "ks", ",", "\n", "data_range", "=", "data_range", ",", "\n", "gaussian_weights", "=", "True", ",", "\n", "use_sample_covariance", "=", "False", ",", "\n", ")", "\n", "\n", "ssim_val", "=", "ssim", "(", "\n", "tensor_noise", "[", ":", ",", ":", ",", "sl", ",", "...", "]", ",", "\n", "tensor_base", "[", ":", ",", ":", ",", "sl", ",", "...", "]", ",", "\n", "data_range", "=", "data_range", ",", "\n", "kernel_size", "=", "ks", ",", "\n", "sigma", "=", "sigma", ",", "\n", "k1", "=", "k1", ",", "\n", "k2", "=", "k2", ",", "\n", ")", ".", "mean", "(", ")", "\n", "assert", "torch", ".", "allclose", "(", "ssim_val", ",", "torch", ".", "as_tensor", "(", "expected_ssim_val", ".", "item", "(", ")", ")", ")", "\n", "\n", "# 3D", "\n", "", "expected_ssim_val", "=", "structural_similarity", "(", "\n", "img3d", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", ",", "# D x H x W x C", "\n", "img3d_noise", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", ",", "# D x H x W x C", "\n", "multichannel", "=", "True", ",", "\n", "win_size", "=", "ks", ",", "\n", "data_range", "=", "data_range", ",", "\n", "gaussian_weights", "=", "True", ",", "\n", "use_sample_covariance", "=", "False", ",", "\n", "K1", "=", "k1", ",", "\n", "K2", "=", "k2", ",", "\n", ")", "\n", "\n", "ssim_val", "=", "ssim", "(", "\n", "tensor_noise", ",", "\n", "tensor_base", ",", "\n", "data_range", "=", "data_range", ",", "\n", "kernel_size", "=", "ks", ",", "\n", "sigma", "=", "sigma", ",", "\n", "k1", "=", "k1", ",", "\n", "k2", "=", "k2", ",", "\n", ")", ".", "mean", "(", ")", "\n", "assert", "torch", ".", "allclose", "(", "ssim_val", ",", "torch", ".", "as_tensor", "(", "expected_ssim_val", ".", "item", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_ssim_legacy": [[195, 220], ["torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "meddlr.metrics.image.compute_ssim", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor.unsqueeze().unsqueeze", "torch.as_tensor.unsqueeze().unsqueeze", "meddlr.metrics.functional.image.ssim().mean", "meddlr.metrics.functional.image.ssim().mean", "torch.allclose", "torch.allclose", "torch.allclose", "torch.allclose", "torch.as_tensor.item", "skimage.data.cells3d().astype", "numpy.random.randn().astype", "torch.as_tensor.mean", "torch.as_tensor.unsqueeze", "torch.as_tensor.unsqueeze", "meddlr.metrics.functional.image.ssim", "meddlr.metrics.functional.image.ssim", "skimage.data.cells3d", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_ssim", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.ssim", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image.ssim"], ["", "def", "test_ssim_legacy", "(", ")", ":", "\n", "    ", "\"\"\"Test SSIM is equivalent to legacy function ``compute_ssim``.\"\"\"", "\n", "target", "=", "data", ".", "cells3d", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "22", ":", "37", ",", ":", ",", "75", ":", "150", ",", "75", ":", "150", "]", "[", ":", ",", "0", "]", "# D x H x W", "\n", "target", "=", "target", "+", "1j", "*", "target", "\n", "pred", "=", "target", "+", "np", ".", "random", ".", "randn", "(", "*", "target", ".", "shape", ")", ".", "astype", "(", "np", ".", "complex64", ")", "*", "target", ".", "mean", "(", ")", "\n", "\n", "target", "=", "torch", ".", "as_tensor", "(", "target", ")", "\n", "pred", "=", "torch", ".", "as_tensor", "(", "pred", ")", "\n", "\n", "legacy_value", "=", "compute_ssim", "(", "\n", "target", ",", "\n", "pred", ",", "\n", "data_range", "=", "\"ref-maxval\"", ",", "\n", "gaussian_weights", "=", "True", ",", "\n", "use_sample_covariance", "=", "False", ",", "\n", ")", "\n", "legacy_value", "=", "torch", ".", "as_tensor", "(", "legacy_value", ".", "item", "(", ")", ")", "\n", "\n", "pred_tensor", "=", "pred", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "# BxCxDxHxW", "\n", "target_tensor", "=", "target", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "# BxCxDxHxW", "\n", "out", "=", "ssim", "(", "pred_tensor", ",", "target_tensor", ",", "data_range", "=", "\"ref-maxval\"", ")", ".", "mean", "(", ")", "\n", "out2", "=", "ssim", "(", "pred_tensor", ",", "target_tensor", ",", "method", "=", "\"Wang\"", ")", ".", "mean", "(", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "legacy_value", ")", "\n", "assert", "torch", ".", "allclose", "(", "out2", ",", "legacy_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_pad_reflect": [[222, 244], ["torch.randn", "torch.randn", "torch.pad", "meddlr.metrics.functional.image._pad", "torch.all", "torch.all", "test_image.check_reflection_per_spatial_dim", "torch.randn", "torch.randn", "meddlr.metrics.functional.image._pad", "test_image.check_reflection_per_spatial_dim"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._pad", "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.check_reflection_per_spatial_dim", "home.repos.pwc.inspect_result.ad12_meddlr.functional.image._pad", "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.check_reflection_per_spatial_dim"], ["", "def", "test_pad_reflect", "(", ")", ":", "\n", "    ", "mode", "=", "\"reflect\"", "\n", "\n", "# 2D Reflection padding", "\n", "# This should match torch.nn.functional padding.", "\n", "shape", ",", "padding", "=", "(", "10", ",", "3", ",", "20", ",", "20", ")", ",", "(", "1", ",", "1", ",", "2", ",", "2", ")", "\n", "x", "=", "torch", ".", "randn", "(", "*", "shape", ")", "\n", "expected_shape", "=", "(", "10", ",", "3", ",", "24", ",", "22", ")", "\n", "xpad_expected", "=", "F", ".", "pad", "(", "x", ",", "padding", ",", "mode", "=", "mode", ")", "\n", "xpad", "=", "_pad", "(", "x", ",", "padding", ",", "mode", "=", "mode", ")", "\n", "assert", "torch", ".", "all", "(", "xpad", "==", "xpad_expected", ")", "\n", "assert", "xpad", ".", "shape", "==", "expected_shape", "\n", "check_reflection_per_spatial_dim", "(", "xpad", ",", "padding", ")", "\n", "\n", "# 3D Reflection padding", "\n", "# Verify that along each dimension we see reflection like property", "\n", "shape", ",", "padding", "=", "(", "2", ",", "3", ",", "20", ",", "30", ",", "40", ")", ",", "(", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ")", "\n", "x", "=", "torch", ".", "randn", "(", "*", "shape", ")", "\n", "expected_shape", "=", "(", "2", ",", "3", ",", "31", ",", "37", ",", "43", ")", "\n", "xpad", "=", "_pad", "(", "x", ",", "padding", ",", "mode", "=", "mode", ")", "\n", "assert", "xpad", ".", "shape", "==", "expected_shape", "\n", "check_reflection_per_spatial_dim", "(", "xpad", ",", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.check_reflection_per_spatial_dim": [[246, 259], ["range", "zip", "len", "xpad.permute", "x_flat.reshape.reshape", "torch.all", "torch.all", "torch.all", "torch.all", "len", "range", "tuple", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "len", "range"], "function", ["None"], ["", "def", "check_reflection_per_spatial_dim", "(", "xpad", ":", "torch", ".", "Tensor", ",", "padding", ")", ":", "\n", "    ", "spatial_dims", "=", "range", "(", "2", ",", "xpad", ".", "ndim", ")", "\n", "assert", "len", "(", "padding", ")", "==", "len", "(", "spatial_dims", ")", "*", "2", "\n", "padding", "=", "[", "(", "padding", "[", "2", "*", "i", "]", ",", "padding", "[", "2", "*", "i", "+", "1", "]", ")", "for", "i", "in", "range", "(", "len", "(", "padding", ")", "//", "2", ")", "]", "[", ":", ":", "-", "1", "]", "\n", "\n", "for", "dim", ",", "pad", "in", "zip", "(", "spatial_dims", ",", "padding", ")", ":", "\n", "        ", "x_flat", "=", "xpad", ".", "permute", "(", "(", "dim", ",", ")", "+", "tuple", "(", "d", "for", "d", "in", "range", "(", "xpad", ".", "ndim", ")", "if", "d", "!=", "dim", ")", ")", "\n", "x_flat", "=", "x_flat", ".", "reshape", "(", "x_flat", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "x_nopad", "=", "x_flat", "[", "pad", "[", "0", "]", ":", "-", "pad", "[", "1", "]", "]", "\n", "xtop", ",", "xbottom", "=", "x_flat", "[", ":", "pad", "[", "0", "]", "]", ",", "x_flat", "[", "-", "pad", "[", "1", "]", ":", "]", "\n", "assert", "torch", ".", "all", "(", "torch", ".", "flip", "(", "x_nopad", "[", "1", ":", "1", "+", "pad", "[", "0", "]", "]", ",", "dims", "=", "(", "0", ",", ")", ")", "==", "xtop", ")", "\n", "assert", "torch", ".", "all", "(", "torch", ".", "flip", "(", "x_nopad", "[", "-", "pad", "[", "1", "]", "-", "1", ":", "-", "1", "]", ",", "dims", "=", "(", "0", ",", ")", ")", "==", "xbottom", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_pad_3d_tensor_with_2d_padding_reflect": [[261, 271], ["torch.randn", "torch.randn", "torch.stack", "torch.stack", "meddlr.metrics.functional.image._pad_3d_tensor_with_2d_padding", "torch.all", "torch.all", "torch.pad", "range"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image._pad_3d_tensor_with_2d_padding", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad"], ["", "", "def", "test_pad_3d_tensor_with_2d_padding_reflect", "(", ")", ":", "\n", "    ", "shape", ",", "padding", "=", "(", "10", ",", "3", ",", "5", ",", "20", ",", "30", ")", ",", "(", "2", ",", "4", ",", "5", ",", "6", ")", "\n", "x", "=", "torch", ".", "randn", "(", "*", "shape", ")", "\n", "mode", "=", "\"reflect\"", "\n", "\n", "expected_out", "=", "torch", ".", "stack", "(", "[", "F", ".", "pad", "(", "x", "[", ":", ",", "i", "]", ",", "padding", ",", "mode", ")", "for", "i", "in", "range", "(", "shape", "[", "1", "]", ")", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "_pad_3d_tensor_with_2d_padding", "(", "x", ",", "padding", ",", "mode", "=", "mode", ")", "\n", "\n", "assert", "out", ".", "shape", "==", "expected_out", ".", "shape", "\n", "assert", "torch", ".", "all", "(", "out", "==", "expected_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_image.test_mae_accuracy": [[273, 285], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "meddlr.metrics.functional.image.mae", "torch.allclose", "torch.allclose", "torch.abs().reshape().mean", "torch.abs().reshape().mean", "torch.abs().reshape", "torch.abs().reshape", "torch.abs", "torch.abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.mae", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"ndim\"", ",", "[", "2", ",", "3", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"nchannels\"", ",", "[", "1", ",", "3", ",", "10", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"dtype\"", ",", "[", "torch", ".", "float32", ",", "torch", ".", "complex64", "]", ")", "\n", "def", "test_mae_accuracy", "(", "ndim", ",", "nchannels", ",", "dtype", ")", ":", "\n", "    ", "\"\"\"Test MAE accuracy.\"\"\"", "\n", "bsz", "=", "10", "\n", "shape", "=", "(", "bsz", ",", "nchannels", ")", "+", "(", "20", ",", ")", "*", "ndim", "\n", "x", "=", "torch", ".", "randn", "(", "*", "shape", ",", "dtype", "=", "dtype", ")", "\n", "y", "=", "torch", ".", "randn", "(", "*", "shape", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "mae", "(", "x", ",", "y", ")", "\n", "assert", "out", ".", "shape", "==", "(", "bsz", ",", "nchannels", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "torch", ".", "abs", "(", "x", "-", "y", ")", ".", "reshape", "(", "bsz", ",", "nchannels", ",", "-", "1", ")", ".", "mean", "(", "-", "1", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_sem_seg._generate_3d_mock_masks": [[8, 27], ["range", "torch.stack().unsqueeze().float", "torch.stack().unsqueeze().float", "torch.randn", "torch.randn", "torch.conv3d", "torch.meshgrid", "torch.meshgrid", "tuple", "torch.stack().unsqueeze().float.append", "torch.randn.sum", "torch.sqrt", "torch.sqrt", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.arange", "torch.arange", "g.float", "zip", "torch.stack", "torch.stack", "range"], "function", ["None"], ["def", "_generate_3d_mock_masks", "(", "num_classes", "=", "4", ")", ":", "\n", "    ", "k", "=", "5", "\n", "ndim", "=", "3", "\n", "shape", "=", "(", "20", ",", ")", "*", "ndim", "\n", "\n", "y_true", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "r", "=", "(", "num_classes", "+", "1", ")", "*", "6", "\n", "grids", "=", "torch", ".", "meshgrid", "(", "*", "[", "torch", ".", "arange", "(", "s", ")", "for", "s", "in", "shape", "]", ")", "\n", "x", ",", "y", ",", "z", "=", "tuple", "(", "g", ".", "float", "(", ")", "-", "s", "//", "2", "for", "g", ",", "s", "in", "zip", "(", "grids", ",", "shape", ")", ")", "\n", "mask", "=", "torch", ".", "sqrt", "(", "x", "**", "2", "+", "y", "**", "2", "+", "z", "**", "2", ")", "<=", "r", "\n", "y_true", ".", "append", "(", "mask", ")", "\n", "", "y_true", "=", "torch", ".", "stack", "(", "y_true", ",", "dim", "=", "0", ")", ".", "unsqueeze", "(", "0", ")", ".", "float", "(", ")", "\n", "\n", "kernel", "=", "torch", ".", "randn", "(", "num_classes", ",", "num_classes", ",", "k", ",", "k", ",", "k", ")", "\n", "kernel", "=", "kernel", "/", "kernel", ".", "sum", "(", "(", "-", "1", ",", "-", "2", ",", "-", "3", ")", ",", "keepdim", "=", "True", ")", "\n", "y_pred", "=", "F", ".", "conv3d", "(", "y_true", ",", "weight", "=", "kernel", ",", "padding", "=", "[", "k", "//", "2", "for", "_", "in", "range", "(", "ndim", ")", "]", ")", "\n", "y_pred", "=", "y_pred", ">", "0.5", "\n", "return", "y_pred", ",", "y_true", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.functional.test_sem_seg.test_assd_crop": [[29, 41], ["test_sem_seg._generate_3d_mock_masks", "meddlr.metrics.functional.sem_seg.assd", "meddlr.metrics.functional.sem_seg.assd", "numpy.allclose", "meddlr.metrics.functional.sem_seg.assd", "meddlr.metrics.functional.sem_seg.assd", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.test_sem_seg._generate_3d_mock_masks"], ["", "def", "test_assd_crop", "(", ")", ":", "\n", "    ", "\"\"\"Test that cropping method to speed up computation gives same result.\"\"\"", "\n", "y_pred", ",", "y_true", "=", "_generate_3d_mock_masks", "(", ")", "\n", "\n", "expected", "=", "assd", "(", "y_pred", ",", "y_true", ",", "crop", "=", "False", ")", "\n", "out", "=", "assd", "(", "y_pred", ",", "y_true", ",", "crop", "=", "True", ")", "\n", "assert", "np", ".", "allclose", "(", "out", ",", "expected", ")", "\n", "\n", "spacing", "=", "(", "0.4", ",", "1.0", ",", "2.0", ")", "\n", "expected", "=", "assd", "(", "y_pred", ",", "y_true", ",", "crop", "=", "False", ",", "spacing", "=", "spacing", ")", "\n", "out", "=", "assd", "(", "y_pred", ",", "y_true", ",", "crop", "=", "True", ",", "spacing", "=", "spacing", ")", "\n", "assert", "np", ".", "allclose", "(", "out", ",", "expected", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.noise.RandomNoise.__init__": [[20, 35], ["locals", "meddlr.transforms.transform_gen.TransformGen.__init__", "isinstance", "isinstance", "list"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "float", "=", "0.0", ",", "\n", "std_devs", ":", "Tuple", "[", "float", ",", "float", "]", "=", "None", ",", "\n", "rhos", ":", "Tuple", "[", "float", ",", "float", "]", "=", "None", ",", "\n", "use_mask", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "std_devs", "=", "(", "std_devs", ",", "std_devs", ")", "if", "not", "isinstance", "(", "std_devs", ",", "Sequence", ")", "else", "std_devs", "\n", "if", "rhos", "is", "not", "None", ":", "\n", "            ", "rhos", "=", "(", "rhos", ",", "rhos", ")", "if", "not", "isinstance", "(", "rhos", ",", "Sequence", ")", "else", "rhos", "\n", "\n", "", "params", "=", "locals", "(", ")", "\n", "params", "=", "{", "k", ":", "params", "[", "k", "]", "for", "k", "in", "list", "(", "self", ".", "_param_names", ")", "+", "[", "\"p\"", "]", "}", "\n", "self", ".", "use_mask", "=", "use_mask", "\n", "super", "(", ")", ".", "__init__", "(", "params", "=", "params", ",", "p", "=", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.noise.RandomNoise.get_transform": [[36, 52], ["noise.RandomNoise._get_param_values", "noise.RandomNoise._rand_range", "meddlr.transforms.base.noise.NoiseTransform", "noise.RandomNoise._rand", "meddlr.transforms.transform.NoOpTransform", "noise.RandomNoise._rand_range", "torch.Generator().manual_seed", "int", "torch.Generator", "noise.RandomNoise._rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand"], ["", "def", "get_transform", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "std_devs", "=", "params", "[", "\"std_devs\"", "]", "\n", "rho", "=", "params", "[", "\"rhos\"", "]", "\n", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "params", "[", "\"p\"", "]", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "std_dev", "=", "self", ".", "_rand_range", "(", "*", "std_devs", ")", "\n", "if", "rho", "is", "not", "None", ":", "\n", "            ", "rho", "=", "self", ".", "_rand_range", "(", "*", "rho", ")", "\n", "\n", "", "gen", "=", "self", ".", "_generator", "\n", "if", "gen", "is", "None", "or", "gen", ".", "device", "!=", "input", ".", "device", ":", "\n", "            ", "gen", "=", "torch", ".", "Generator", "(", "device", "=", "input", ".", "device", ")", ".", "manual_seed", "(", "int", "(", "self", ".", "_rand", "(", ")", "*", "1e10", ")", ")", "\n", "", "return", "NoiseTransform", "(", "std_dev", "=", "std_dev", ",", "use_mask", "=", "self", ".", "use_mask", ",", "rho", "=", "rho", ",", "generator", "=", "gen", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomAffine.__init__": [[27, 52], ["isinstance", "locals", "meddlr.transforms.transform_gen.TransformGen.__init__", "isinstance", "len", "p.copy.copy.copy", "p.copy.copy.update", "set", "set", "ValueError", "list", "p.copy.copy.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", "=", "0.0", ",", "\n", "angle", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "translate", ":", "SPATIAL_RANGE_OR_VAL", "=", "None", ",", "\n", "scale", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "shear", ":", "SPATIAL_RANGE_OR_VAL", "=", "None", ",", "\n", "pad_like", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "isinstance", "(", "p", ",", "Number", ")", ":", "\n", "            ", "p", "=", "{", "n", ":", "p", "for", "n", "in", "self", ".", "_param_names", "}", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "p", ",", "dict", ")", "\n", "unknown_keys", "=", "set", "(", "p", ".", "keys", "(", ")", ")", "-", "set", "(", "self", ".", "_param_names", ")", "\n", "if", "len", "(", "unknown_keys", ")", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Unknown keys for `p`: {unknown_keys}\"", ")", "\n", "", "p", "=", "p", ".", "copy", "(", ")", "\n", "p", ".", "update", "(", "{", "k", ":", "0.0", "for", "k", "in", "self", ".", "_param_names", "if", "k", "not", "in", "p", "}", ")", "\n", "", "params", "=", "locals", "(", ")", "\n", "params", "=", "{", "k", ":", "params", "[", "k", "]", "for", "k", "in", "list", "(", "self", ".", "_param_names", ")", "}", "\n", "self", ".", "pad_like", "=", "pad_like", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "params", "=", "params", ",", "\n", "p", "=", "p", ",", "\n", "param_kinds", "=", "{", "\"translate\"", ":", "ParamKind", ".", "MULTI_ARG", ",", "\"shear\"", ":", "ParamKind", ".", "MULTI_ARG", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomAffine._get_params": [[54, 88], ["len", "spatial.RandomAffine._get_param_values", "isinstance", "isinstance", "isinstance", "isinstance", "spatial.RandomAffine._format_param", "spatial.RandomAffine._format_param", "tuple", "spatial.RandomAffine._rand_range", "spatial.RandomAffine._rand_range", "sorted", "spatial.RandomAffine._rand", "spatial.RandomAffine._rand", "int", "spatial.RandomAffine._rand", "spatial.RandomAffine._rand", "spatial.RandomAffine._rand_range", "zip", "spatial.RandomAffine._rand_range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._format_param", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._format_param", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range"], ["", "def", "_get_params", "(", "self", ",", "shape", ")", ":", "\n", "        ", "ndim", "=", "len", "(", "shape", ")", "\n", "params", "=", "self", ".", "_get_param_values", "(", ")", "\n", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "param_angle", "=", "params", "[", "\"angle\"", "]", "\n", "param_translate", "=", "params", "[", "\"translate\"", "]", "\n", "param_scale", "=", "params", "[", "\"scale\"", "]", "\n", "param_shear", "=", "params", "[", "\"shear\"", "]", "\n", "\n", "if", "isinstance", "(", "param_angle", ",", "Number", ")", ":", "\n", "            ", "param_angle", "=", "(", "-", "param_angle", ",", "param_angle", ")", "\n", "", "if", "isinstance", "(", "param_translate", ",", "Number", ")", ":", "\n", "            ", "param_translate", "=", "(", "(", "-", "param_translate", ",", "param_translate", ")", ",", ")", "\n", "", "if", "isinstance", "(", "param_scale", ",", "Number", ")", ":", "\n", "            ", "param_scale", "=", "tuple", "(", "sorted", "(", "[", "1.0", "-", "param_scale", ",", "1.0", "+", "param_scale", "]", ")", ")", "\n", "", "if", "isinstance", "(", "param_shear", ",", "Number", ")", ":", "\n", "            ", "param_shear", "=", "(", "(", "-", "param_shear", ",", "param_shear", ")", ",", ")", "\n", "\n", "", "param_translate", "=", "self", ".", "_format_param", "(", "param_translate", ",", "ParamKind", ".", "MULTI_ARG", ",", "ndim", ")", "\n", "param_shear", "=", "self", ".", "_format_param", "(", "param_shear", ",", "ParamKind", ".", "MULTI_ARG", ",", "ndim", ")", "\n", "\n", "angle", ",", "translate", ",", "scale", ",", "shear", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "\n", "if", "param_angle", "is", "not", "None", "and", "self", ".", "_rand", "(", ")", "<", "p", "[", "\"angle\"", "]", ":", "\n", "            ", "angle", "=", "self", ".", "_rand_range", "(", "*", "param_angle", ")", "\n", "", "if", "param_translate", "is", "not", "None", "and", "self", ".", "_rand", "(", ")", "<", "p", "[", "\"translate\"", "]", ":", "\n", "            ", "translate", "=", "[", "int", "(", "self", ".", "_rand_range", "(", "*", "x", ")", "*", "s", ")", "for", "x", ",", "s", "in", "zip", "(", "param_translate", ",", "shape", ")", "]", "\n", "", "if", "param_scale", "is", "not", "None", "and", "self", ".", "_rand", "(", ")", "<", "p", "[", "\"scale\"", "]", ":", "\n", "            ", "scale", "=", "self", ".", "_rand_range", "(", "*", "param_scale", ")", "\n", "", "if", "param_shear", "is", "not", "None", "and", "self", ".", "_rand", "(", ")", "<", "p", "[", "\"shear\"", "]", ":", "\n", "            ", "shear", "=", "[", "self", ".", "_rand_range", "(", "*", "x", ")", "for", "x", "in", "param_shear", "]", "\n", "\n", "", "return", "angle", ",", "translate", ",", "scale", ",", "shear", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomAffine.get_transform": [[89, 99], ["spatial.RandomAffine._get_params", "all", "meddlr.transforms.base.spatial.AffineTransform", "meddlr.transforms.transform.NoOpTransform"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomAffine._get_params"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "# Affine only supports 2D spatial transforms", "\n", "        ", "spatial_shape", "=", "image", ".", "shape", "[", "-", "2", ":", "]", "\n", "\n", "out", "=", "self", ".", "_get_params", "(", "spatial_shape", ")", "\n", "if", "all", "(", "x", "is", "None", "for", "x", "in", "out", ")", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "angle", ",", "translate", ",", "scale", ",", "shear", "=", "out", "\n", "return", "AffineTransform", "(", "angle", "=", "angle", ",", "translate", "=", "translate", ",", "scale", "=", "scale", ",", "shear", "=", "shear", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomTranslation.__init__": [[105, 118], ["meddlr.transforms.transform_gen.TransformGen.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", "=", "0.0", ",", "\n", "translate", ":", "SPATIAL_RANGE_OR_VAL", "=", "None", ",", "\n", "pad_mode", "=", "None", ",", "\n", "pad_value", "=", "0", ",", "\n", "ndim", "=", "2", ",", "\n", ")", ":", "\n", "        ", "params", "=", "{", "\"translate\"", ":", "translate", "}", "\n", "self", ".", "pad_mode", "=", "pad_mode", "\n", "self", ".", "pad_value", "=", "pad_value", "\n", "self", ".", "ndim", "=", "ndim", "\n", "super", "(", ")", ".", "__init__", "(", "params", "=", "params", ",", "p", "=", "p", ",", "param_kinds", "=", "{", "\"translate\"", ":", "ParamKind", ".", "MULTI_ARG", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomTranslation.get_transform": [[119, 132], ["len", "spatial.RandomTranslation._get_param_values", "spatial.RandomTranslation._format_param", "meddlr.transforms.base.spatial.TranslationTransform", "spatial.RandomTranslation._rand", "meddlr.transforms.transform.NoOpTransform", "int", "zip", "spatial.RandomTranslation._rand_range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._format_param", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "shape", "=", "image", ".", "shape", "[", "-", "self", ".", "ndim", ":", "]", "\n", "ndim", "=", "len", "(", "shape", ")", "\n", "\n", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "param_translate", "=", "params", "[", "\"translate\"", "]", "\n", "translate", "=", "self", ".", "_format_param", "(", "param_translate", ",", "ParamKind", ".", "MULTI_ARG", ",", "ndim", ")", "\n", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "p", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "", "translate", "=", "[", "int", "(", "self", ".", "_rand_range", "(", "*", "x", ")", "*", "s", ")", "for", "x", ",", "s", "in", "zip", "(", "translate", ",", "shape", ")", "]", "\n", "return", "TranslationTransform", "(", "translate", ",", "pad_mode", "=", "self", ".", "pad_mode", ",", "pad_value", "=", "self", ".", "pad_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomFlip.__init__": [[138, 148], ["all", "isinstance", "meddlr.transforms.transform_gen.TransformGen.__init__", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "dims", "=", "None", ",", "ndim", "=", "None", ",", "p", ":", "Union", "[", "float", ",", "Dict", "[", "int", ",", "float", "]", "]", "=", "0.0", ")", "->", "None", ":", "\n", "        ", "if", "dims", "is", "None", "and", "ndim", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either `dims` or `ndim` must be specified\"", ")", "\n", "", "if", "all", "(", "x", "is", "not", "None", "for", "x", "in", "(", "dims", ",", "ndim", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only one of `dims` or `ndim` can be specified.\"", ")", "\n", "", "if", "isinstance", "(", "dims", ",", "int", ")", ":", "\n", "            ", "dims", "=", "(", "dims", ",", ")", "\n", "", "self", ".", "dims", "=", "dims", "\n", "self", ".", "ndim", "=", "ndim", "\n", "super", "(", ")", ".", "__init__", "(", "p", "=", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomFlip.get_transform": [[149, 161], ["spatial.RandomFlip._get_param_values", "tuple", "isinstance", "meddlr.transforms.base.spatial.FlipTransform", "meddlr.transforms.transform.NoOpTransform", "tuple", "tuple", "spatial.RandomFlip._rand", "p.items", "range", "spatial.RandomFlip._rand", "spatial.RandomFlip._rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand"], ["", "def", "get_transform", "(", "self", ",", "input", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "if", "self", ".", "dims", "is", "not", "None", ":", "\n", "            ", "dims", "=", "tuple", "(", "d", "for", "d", "in", "self", ".", "dims", "if", "self", ".", "_rand", "(", ")", "<", "p", ")", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "p", ",", "Dict", ")", ":", "\n", "                ", "dims", "=", "tuple", "(", "k", "for", "k", ",", "v", "in", "p", ".", "items", "(", ")", "if", "self", ".", "_rand", "(", ")", "<", "v", ")", "\n", "", "else", ":", "\n", "                ", "dims", "=", "tuple", "(", "d", "for", "d", "in", "range", "(", "-", "self", ".", "ndim", ",", "0", ")", "if", "self", ".", "_rand", "(", ")", "<", "p", ")", "\n", "\n", "", "", "return", "FlipTransform", "(", "dims", ")", "if", "dims", "else", "NoOpTransform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomRot90.__init__": [[167, 170], ["meddlr.transforms.transform_gen.TransformGen.__init__", "list", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["def", "__init__", "(", "self", ",", "ks", "=", "None", ",", "p", "=", "0.0", ")", "->", "None", ":", "\n", "        ", "self", ".", "ks", "=", "ks", "if", "ks", "is", "not", "None", "else", "list", "(", "range", "(", "1", ",", "4", ")", ")", "\n", "super", "(", ")", ".", "__init__", "(", "p", "=", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial.RandomRot90.get_transform": [[171, 177], ["spatial.RandomRot90._get_param_values", "meddlr.transforms.base.spatial.Rot90Transform", "spatial.RandomRot90._rand", "meddlr.transforms.transform.NoOpTransform", "[].item", "torch.randperm", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand"], ["", "def", "get_transform", "(", "self", ",", "input", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "params", "[", "\"p\"", "]", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "", "k", "=", "self", ".", "ks", "[", "torch", ".", "randperm", "(", "len", "(", "self", ".", "ks", ")", ")", "[", "0", "]", ".", "item", "(", ")", "]", "\n", "return", "Rot90Transform", "(", "k", "=", "k", ",", "dims", "=", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.spatial._duplicate_ndim": [[179, 191], ["isinstance", "isinstance", "isinstance", "len", "len"], "function", ["None"], ["", "", "def", "_duplicate_ndim", "(", "param", ",", "ndim", ")", ":", "\n", "    ", "if", "param", "is", "None", ":", "\n", "        ", "return", "None", "\n", "\n", "", "if", "isinstance", "(", "param", ",", "Sequence", ")", "and", "isinstance", "(", "param", "[", "0", "]", ",", "Sequence", ")", ":", "\n", "        ", "return", "[", "[", "x", "if", "len", "(", "x", ")", ">", "1", "else", "(", "-", "x", "[", "0", "]", ",", "x", "[", "0", "]", ")", "for", "x", "in", "y", "]", "for", "y", "in", "param", "]", "\n", "\n", "", "if", "isinstance", "(", "param", ",", "Sequence", ")", ":", "\n", "        ", "param", "=", "(", "-", "param", "[", "0", "]", ",", "param", "[", "0", "]", ")", "if", "len", "(", "param", ")", "==", "1", "else", "param", "\n", "", "else", ":", "\n", "        ", "param", "=", "(", "-", "param", ",", "param", ")", "\n", "", "return", "[", "param", "]", "*", "ndim", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.motion.RandomMRIMotion.__init__": [[39, 45], ["isinstance", "meddlr.transforms.transform_gen.TransformGen.__init__", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "self", ",", "std_devs", ":", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", ",", "p", ":", "float", "=", "0.0", ")", ":", "\n", "        ", "if", "isinstance", "(", "std_devs", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "            ", "std_devs", "=", "(", "std_devs", ",", "std_devs", ")", "\n", "", "elif", "len", "(", "std_devs", ")", ">", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"`motion_range` must have 2 or fewer values\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "params", "=", "{", "\"std_devs\"", ":", "std_devs", "}", ",", "p", "=", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.motion.RandomMRIMotion.get_transform": [[46, 56], ["motion.RandomMRIMotion._get_param_values", "motion.RandomMRIMotion._rand_range", "meddlr.transforms.base.motion.MRIMotionTransform", "motion.RandomMRIMotion._rand", "meddlr.transforms.transform.NoOpTransform", "torch.Generator().manual_seed", "int", "torch.Generator", "motion.RandomMRIMotion._rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand"], ["", "def", "get_transform", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "params", "[", "\"p\"", "]", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "std_dev", "=", "self", ".", "_rand_range", "(", "*", "params", "[", "\"std_devs\"", "]", ")", "\n", "gen", "=", "self", ".", "_generator", "\n", "if", "gen", "is", "None", "or", "gen", ".", "device", "!=", "input", ".", "device", ":", "\n", "            ", "gen", "=", "torch", ".", "Generator", "(", "device", "=", "input", ".", "device", ")", ".", "manual_seed", "(", "int", "(", "self", ".", "_rand", "(", ")", "*", "1e10", ")", ")", "\n", "", "return", "MRIMotionTransform", "(", "std_dev", "=", "std_dev", ",", "generator", "=", "gen", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.__init__": [[19, 32], ["len", "torch.allclose", "meddlr.transforms.transform_gen.TransformGen.__init__", "torch.as_tensor", "torch.sum", "torch.as_tensor", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "tfms_or_gens", ":", "Sequence", "[", "Union", "[", "Transform", ",", "TransformGen", "]", "]", ",", "tfm_ps", "=", "\"uniform\"", ",", "p", "=", "0.0", "\n", ")", "->", "None", ":", "\n", "        ", "N", "=", "len", "(", "tfms_or_gens", ")", "\n", "if", "tfm_ps", "==", "\"uniform\"", ":", "\n", "            ", "tfm_ps", "=", "torch", ".", "ones", "(", "N", ")", "/", "N", "\n", "", "else", ":", "\n", "            ", "tfm_ps", "=", "torch", ".", "as_tensor", "(", "tfm_ps", ")", "\n", "", "assert", "torch", ".", "allclose", "(", "torch", ".", "sum", "(", "tfm_ps", ")", ",", "torch", ".", "as_tensor", "(", "1.0", ")", ")", "\n", "self", ".", "tfm_ps", "=", "tfm_ps", "\n", "self", ".", "tfms_or_gens", "=", "tfms_or_gens", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "p", "=", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.get_transform": [[33, 40], ["choice.RandomTransformChoice._get_param_values", "choice.RandomTransformChoice._rand", "meddlr.transforms.transform.NoOpTransform", "choice.RandomTransformChoice._rand_choice"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_choice"], ["", "def", "get_transform", "(", "self", ",", "input", "=", "None", ")", "->", "Union", "[", "_TRANSFORM_OR_GEN", ",", "Sequence", "[", "_TRANSFORM_OR_GEN", "]", "]", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "p", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "return", "self", ".", "tfms_or_gens", "[", "self", ".", "_rand_choice", "(", "probs", "=", "self", ".", "tfm_ps", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.schedulers": [[41, 46], ["choice.RandomTransformChoice._get_tfm_by_type", "list", "list.extend", "tfm.schedulers"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice._get_tfm_by_type", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.schedulers"], ["", "def", "schedulers", "(", "self", ")", ":", "\n", "        ", "tfms", ":", "List", "[", "SchedulableMixin", "]", "=", "self", ".", "_get_tfm_by_type", "(", "SchedulableMixin", ")", "\n", "schedulers", "=", "list", "(", "self", ".", "_schedulers", ")", "\n", "schedulers", ".", "extend", "(", "[", "sch", "for", "tfm", "in", "tfms", "for", "sch", "in", "tfm", ".", "schedulers", "(", ")", "]", ")", "\n", "return", "schedulers", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed": [[47, 53], ["torch.Generator().manual_seed", "choice.RandomTransformChoice._get_tfm_by_type", "t.seed", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice._get_tfm_by_type", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed"], ["", "def", "seed", "(", "self", ",", "value", ":", "int", ")", ":", "\n", "        ", "self", ".", "_generator", "=", "torch", ".", "Generator", "(", "device", "=", "self", ".", "_device", ")", ".", "manual_seed", "(", "value", ")", "\n", "tfms", ":", "List", "[", "TransformGen", "]", "=", "self", ".", "_get_tfm_by_type", "(", "TransformGen", ")", "\n", "for", "t", "in", "tfms", ":", "\n", "            ", "t", ".", "seed", "(", "value", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.to": [[54, 60], ["super().to", "choice.RandomTransformChoice._get_tfm_by_type", "t.to"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice._get_tfm_by_type", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "super", "(", ")", ".", "to", "(", "device", ")", "\n", "tfms", ":", "List", "[", "DeviceMixin", "]", "=", "self", ".", "_get_tfm_by_type", "(", "DeviceMixin", ")", "\n", "for", "t", "in", "tfms", ":", "\n", "            ", "t", ".", "to", "(", "device", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice._get_tfm_by_type": [[61, 69], ["isinstance", "tfms.extend", "isinstance", "tfms.append", "isinstance"], "methods", ["None"], ["", "def", "_get_tfm_by_type", "(", "self", ",", "klass", ")", ":", "\n", "        ", "tfms", "=", "[", "]", "\n", "for", "tfm", "in", "self", ".", "tfms_or_gens", ":", "\n", "            ", "if", "isinstance", "(", "tfm", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "                ", "tfms", ".", "extend", "(", "t", "for", "t", "in", "tfm", "if", "isinstance", "(", "t", ",", "klass", ")", ")", "\n", "", "elif", "isinstance", "(", "tfm", ",", "klass", ")", ":", "\n", "                ", "tfms", ".", "append", "(", "tfm", ")", "\n", "", "", "return", "tfms", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.__repr__": [[70, 76], ["type", "repr", "zip"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "classname", "=", "type", "(", "self", ")", ".", "__name__", "\n", "argstr", "=", "\",\\n  \"", ".", "join", "(", "\n", "\"(p={:0.2f}) {}\"", ".", "format", "(", "p", ",", "repr", "(", "t", ")", ")", "for", "t", ",", "p", "in", "zip", "(", "self", ".", "tfms_or_gens", ",", "self", ".", "tfm_ps", ")", "\n", ")", "\n", "return", "\"{}(\\n  {}\\n)\"", ".", "format", "(", "classname", ",", "argstr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.from_dict": [[77, 85], ["init_kwargs.copy.copy.copy", "init_kwargs.copy.copy.pop", "cls", "tfms_or_gens.append", "meddlr.transforms.build.build_transforms"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_transforms"], ["", "@", "classmethod", "\n", "def", "from_dict", "(", "cls", ",", "cfg", ":", "CfgNode", ",", "init_kwargs", ":", "Mapping", "[", "str", ",", "Any", "]", ",", "**", "kwargs", ")", ":", "\n", "        ", "init_kwargs", "=", "init_kwargs", ".", "copy", "(", ")", "\n", "tfms_or_gens", "=", "[", "]", "\n", "for", "tfm_cfg", "in", "init_kwargs", ".", "pop", "(", "\"tfms_or_gens\"", ")", ":", "\n", "            ", "tfms_or_gens", ".", "append", "(", "build_transforms", "(", "cfg", ",", "tfm_cfg", ",", "**", "kwargs", ")", ")", "\n", "\n", "", "return", "cls", "(", "tfms_or_gens", ",", "**", "init_kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.__init__": [[20, 40], ["locals", "meddlr.transforms.transform_gen.TransformGen.__init__", "isinstance", "len", "list"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "float", "=", "0.0", ",", "\n", "rhos", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "kind", ":", "str", "=", "\"uniform\"", ",", "\n", "std_scale", ":", "float", "=", "None", ",", "\n", "per_example", "=", "False", ",", "\n", "calib_size", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "isinstance", "(", "rhos", ",", "Sequence", ")", "and", "len", "(", "rhos", ")", "==", "1", ":", "\n", "            ", "rhos", "=", "rhos", "[", "0", "]", "\n", "\n", "", "params", "=", "locals", "(", ")", "\n", "params", "=", "{", "k", ":", "params", "[", "k", "]", "for", "k", "in", "list", "(", "self", ".", "_param_names", ")", "+", "[", "\"p\"", "]", "}", "\n", "super", "(", ")", ".", "__init__", "(", "params", "=", "params", ",", "p", "=", "p", ")", "\n", "\n", "self", ".", "kind", "=", "kind", "\n", "self", ".", "per_example", "=", "per_example", "\n", "self", ".", "calib_size", "=", "calib_size", "\n", "self", ".", "std_scale", "=", "std_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform": [[41, 63], ["mask.RandomKspaceMask._get_param_values", "isinstance", "meddlr.transforms.base.mask.KspaceMaskTransform", "mask.RandomKspaceMask._rand", "meddlr.transforms.transform.NoOpTransform", "mask.RandomKspaceMask._rand_range", "torch.Generator().manual_seed", "int", "torch.Generator", "mask.RandomKspaceMask._rand"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand_range", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._rand"], ["", "def", "get_transform", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "rhos", "=", "params", "[", "\"rhos\"", "]", "\n", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "params", "[", "\"p\"", "]", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "if", "isinstance", "(", "rhos", ",", "Sequence", ")", ":", "\n", "            ", "rho", "=", "self", ".", "_rand_range", "(", "*", "rhos", ")", "\n", "", "else", ":", "\n", "            ", "rho", "=", "rhos", "\n", "\n", "", "gen", "=", "self", ".", "_generator", "\n", "if", "gen", "is", "None", "or", "gen", ".", "device", "!=", "input", ".", "device", ":", "\n", "            ", "gen", "=", "torch", ".", "Generator", "(", "device", "=", "input", ".", "device", ")", ".", "manual_seed", "(", "int", "(", "self", ".", "_rand", "(", ")", "*", "1e10", ")", ")", "\n", "", "return", "KspaceMaskTransform", "(", "\n", "rho", "=", "rho", ",", "\n", "kind", "=", "self", ".", "kind", ",", "\n", "per_example", "=", "self", ".", "per_example", ",", "\n", "calib_size", "=", "self", ".", "calib_size", ",", "\n", "generator", "=", "gen", ",", "\n", "std_scale", "=", "self", ".", "std_scale", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_noise.TestRandomNoise.test_randomness": [[11, 23], ["mock.generate_mock_mri_data", "meddlr.transforms.gen.RandomNoise", "meddlr.transforms.gen.RandomNoise.get_transform", "meddlr.transforms.gen.RandomNoise.get_transform.apply_kspace", "meddlr.transforms.gen.RandomNoise.get_transform", "meddlr.transforms.gen.RandomNoise.get_transform.apply_kspace", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace"], ["    ", "def", "test_randomness", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test if there is randomness in the generation process.\"\"\"", "\n", "kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", ")", "\n", "noiser", "=", "RandomNoise", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "\n", "tfm", "=", "noiser", ".", "get_transform", "(", "kspace", ")", "\n", "out1", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "\n", "tfm", "=", "noiser", ".", "get_transform", "(", "kspace", ")", "\n", "out2", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "\n", "assert", "not", "torch", ".", "allclose", "(", "out1", ",", "out2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_noise.TestRandomNoise.test_reproducibility": [[24, 50], ["mock.generate_mock_mri_data", "meddlr.transforms.gen.RandomNoise", "meddlr.transforms.gen.RandomNoise.seed", "meddlr.transforms.gen.RandomNoise", "meddlr.transforms.gen.RandomNoise.seed", "torch.all", "meddlr.transforms.gen.RandomNoise.get_transform", "meddlr.transforms.gen.RandomNoise.get_transform", "torch.all", "meddlr.transforms.gen.RandomNoise.get_transform.apply_kspace", "meddlr.transforms.gen.RandomNoise.get_transform.apply_kspace", "torch.all", "meddlr.transforms.gen.RandomNoise", "meddlr.transforms.gen.RandomNoise.seed", "meddlr.transforms.gen.RandomNoise.get_transform", "meddlr.transforms.gen.RandomNoise.get_transform.apply_kspace", "meddlr.transforms.gen.RandomNoise.seed", "meddlr.transforms.gen.RandomNoise.get_transform", "meddlr.transforms.gen.RandomNoise.get_transform.apply_kspace", "torch.all", "meddlr.transforms.gen.RandomNoise._generator.get_state", "meddlr.transforms.gen.RandomNoise._generator.get_state"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace"], ["", "def", "test_reproducibility", "(", "self", ")", ":", "\n", "        ", "kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", ")", "\n", "seed", "=", "42", "\n", "\n", "noiser1", "=", "RandomNoise", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "noiser1", ".", "seed", "(", "seed", ")", "\n", "noiser2", "=", "RandomNoise", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "noiser2", ".", "seed", "(", "seed", ")", "\n", "assert", "torch", ".", "all", "(", "noiser1", ".", "_generator", ".", "get_state", "(", ")", "==", "noiser2", ".", "_generator", ".", "get_state", "(", ")", ")", "\n", "\n", "tfm1", "=", "noiser1", ".", "get_transform", "(", "kspace", ")", "\n", "tfm2", "=", "noiser2", ".", "get_transform", "(", "kspace", ")", "\n", "assert", "torch", ".", "all", "(", "tfm1", ".", "_generator_state", "==", "tfm2", ".", "_generator_state", ")", "\n", "\n", "out1", "=", "tfm1", ".", "apply_kspace", "(", "kspace", ")", "\n", "out2", "=", "tfm2", ".", "apply_kspace", "(", "kspace", ")", "\n", "assert", "torch", ".", "all", "(", "out1", "==", "out2", ")", "\n", "\n", "noiser", "=", "RandomNoise", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "noiser", ".", "seed", "(", "seed", ")", "\n", "tfm", "=", "noiser", ".", "get_transform", "(", "kspace", ")", "\n", "out1", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "noiser", ".", "seed", "(", "seed", ")", "\n", "tfm", "=", "noiser", ".", "get_transform", "(", "kspace", ")", "\n", "out2", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "assert", "torch", ".", "all", "(", "out1", "==", "out2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_motion.TestRandomMRIMotion.test_randomness": [[11, 25], ["mock.generate_mock_mri_data", "kspace.permute.permute.permute", "meddlr.transforms.gen.RandomMRIMotion", "meddlr.transforms.gen.RandomMRIMotion.get_transform", "meddlr.transforms.gen.RandomMRIMotion.get_transform.apply_kspace", "meddlr.transforms.gen.RandomMRIMotion.get_transform", "meddlr.transforms.gen.RandomMRIMotion.get_transform.apply_kspace", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace"], ["    ", "def", "test_randomness", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test if there is randomness in the generation process.\"\"\"", "\n", "kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", ")", "\n", "kspace", "=", "kspace", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "# BxCxHxW", "\n", "\n", "motion_aug", "=", "RandomMRIMotion", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "\n", "tfm", "=", "motion_aug", ".", "get_transform", "(", "kspace", ")", "\n", "out1", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "\n", "tfm", "=", "motion_aug", ".", "get_transform", "(", "kspace", ")", "\n", "out2", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "\n", "assert", "not", "torch", ".", "allclose", "(", "out1", ",", "out2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_motion.TestRandomMRIMotion.test_reproducibility": [[26, 53], ["mock.generate_mock_mri_data", "kspace.permute.permute.permute", "meddlr.transforms.gen.RandomMRIMotion", "meddlr.transforms.gen.RandomMRIMotion.seed", "meddlr.transforms.gen.RandomMRIMotion", "meddlr.transforms.gen.RandomMRIMotion.seed", "torch.all", "meddlr.transforms.gen.RandomMRIMotion.get_transform", "meddlr.transforms.gen.RandomMRIMotion.get_transform", "torch.all", "meddlr.transforms.gen.RandomMRIMotion.get_transform.apply_kspace", "meddlr.transforms.gen.RandomMRIMotion.get_transform.apply_kspace", "torch.all", "meddlr.transforms.gen.RandomMRIMotion", "meddlr.transforms.gen.RandomMRIMotion.seed", "meddlr.transforms.gen.RandomMRIMotion.get_transform", "meddlr.transforms.gen.RandomMRIMotion.get_transform.apply_kspace", "meddlr.transforms.gen.RandomMRIMotion.seed", "meddlr.transforms.gen.RandomMRIMotion.get_transform", "meddlr.transforms.gen.RandomMRIMotion.get_transform.apply_kspace", "torch.all", "meddlr.transforms.gen.RandomMRIMotion._generator.get_state", "meddlr.transforms.gen.RandomMRIMotion._generator.get_state"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace"], ["", "def", "test_reproducibility", "(", "self", ")", ":", "\n", "        ", "kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", ")", "\n", "kspace", "=", "kspace", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "# BxCxHxW", "\n", "seed", "=", "42", "\n", "\n", "aug1", "=", "RandomMRIMotion", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "aug1", ".", "seed", "(", "seed", ")", "\n", "aug2", "=", "RandomMRIMotion", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "aug2", ".", "seed", "(", "seed", ")", "\n", "assert", "torch", ".", "all", "(", "aug1", ".", "_generator", ".", "get_state", "(", ")", "==", "aug2", ".", "_generator", ".", "get_state", "(", ")", ")", "\n", "\n", "tfm1", "=", "aug1", ".", "get_transform", "(", "kspace", ")", "\n", "tfm2", "=", "aug2", ".", "get_transform", "(", "kspace", ")", "\n", "assert", "torch", ".", "all", "(", "tfm1", ".", "_generator_state", "==", "tfm2", ".", "_generator_state", ")", "\n", "\n", "out1", "=", "tfm1", ".", "apply_kspace", "(", "kspace", ")", "\n", "out2", "=", "tfm2", ".", "apply_kspace", "(", "kspace", ")", "\n", "assert", "torch", ".", "all", "(", "out1", "==", "out2", ")", "\n", "\n", "aug", "=", "RandomMRIMotion", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "aug", ".", "seed", "(", "seed", ")", "\n", "tfm", "=", "aug", ".", "get_transform", "(", "kspace", ")", "\n", "out1", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "aug", ".", "seed", "(", "seed", ")", "\n", "tfm", "=", "aug", ".", "get_transform", "(", "kspace", ")", "\n", "out2", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "assert", "torch", ".", "all", "(", "out1", "==", "out2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_choice.TestRandomTransformChoice.test_basic": [[13, 24], ["meddlr.transforms.gen.RandomTransformChoice", "meddlr.transforms.gen.RandomTransformChoice.seed", "numpy.unique", "all", "meddlr.transforms.gen.RandomRot90", "meddlr.transforms.base.AffineTransform", "len", "len", "type", "range", "meddlr.transforms.gen.RandomTransformChoice.schedulers", "meddlr.transforms.gen.RandomTransformChoice.get_transform"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform"], ["    ", "def", "test_basic", "(", "self", ")", ":", "\n", "        ", "tfms_or_gens", "=", "[", "RandomRot90", "(", "p", "=", "1.0", ")", ",", "AffineTransform", "(", "angle", "=", "12", ")", "]", "\n", "choice", "=", "RandomTransformChoice", "(", "tfms_or_gens", "=", "tfms_or_gens", ",", "tfm_ps", "=", "\"uniform\"", ",", "p", "=", "1.0", ")", "\n", "choice", ".", "seed", "(", "1", ")", "\n", "\n", "num_samples", "=", "200", "\n", "tfms", "=", "[", "type", "(", "choice", ".", "get_transform", "(", ")", ")", ".", "__name__", "for", "_", "in", "range", "(", "num_samples", ")", "]", "\n", "unique", ",", "counts", "=", "np", ".", "unique", "(", "tfms", ",", "return_counts", "=", "True", ")", "\n", "assert", "len", "(", "unique", ")", "==", "2", "\n", "assert", "all", "(", "0.45", "*", "num_samples", "<=", "x", "<=", "0.55", "*", "num_samples", "for", "x", "in", "counts", ")", "\n", "assert", "len", "(", "choice", ".", "schedulers", "(", ")", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_choice.TestRandomTransformChoice.test_schedulers": [[25, 38], ["meddlr.transforms.gen.RandomRot90", "meddlr.transforms.base.AffineTransform", "meddlr.transforms.gen.RandomTransformChoice", "meddlr.transforms.tf_scheduler.WarmupTF", "meddlr.transforms.gen.RandomRot90.register_schedulers", "meddlr.transforms.tf_scheduler.WarmupTF", "meddlr.transforms.gen.RandomTransformChoice.register_schedulers", "meddlr.transforms.gen.RandomTransformChoice.schedulers"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.schedulers"], ["", "def", "test_schedulers", "(", "self", ")", ":", "\n", "        ", "tfm_rand_rot", "=", "RandomRot90", "(", "p", "=", "1.0", ")", "\n", "tfm_aff", "=", "AffineTransform", "(", "angle", "=", "12", ")", "\n", "tfms_or_gens", "=", "[", "tfm_rand_rot", ",", "tfm_aff", "]", "\n", "choice", "=", "RandomTransformChoice", "(", "tfms_or_gens", "=", "tfms_or_gens", ",", "tfm_ps", "=", "\"uniform\"", ",", "p", "=", "1.0", ")", "\n", "sch1", "=", "WarmupTF", "(", "tfm_rand_rot", ",", "params", "=", "[", "\"p\"", "]", ",", "warmup_iters", "=", "100", ")", "\n", "tfm_rand_rot", ".", "register_schedulers", "(", "sch1", ")", "\n", "sch2", "=", "WarmupTF", "(", "choice", ",", "params", "=", "[", "\"p\"", "]", ",", "warmup_iters", "=", "200", ")", "\n", "choice", ".", "register_schedulers", "(", "sch2", ")", "\n", "\n", "schedulers", "=", "choice", ".", "schedulers", "(", ")", "\n", "assert", "sch1", "in", "schedulers", "\n", "assert", "sch2", "in", "schedulers", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_choice.TestRandomTransformChoice.test_nested": [[39, 62], ["meddlr.transforms.gen.RandomTransformChoice", "meddlr.transforms.gen.RandomTransformChoice.seed", "meddlr.transforms.tf_scheduler.WarmupTF", "[].register_schedulers", "meddlr.transforms.tf_scheduler.WarmupTF", "tfms_or_gens[].register_schedulers", "meddlr.transforms.gen.RandomTransformChoice.schedulers", "numpy.unique", "all", "meddlr.transforms.gen.RandomRot90", "meddlr.utils.events.EventStorage", "len", "meddlr.transforms.gen.spatial.RandomFlip", "meddlr.transforms.gen.spatial.RandomTranslation", "type", "range", "meddlr.transforms.gen.RandomTransformChoice.get_transform"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform"], ["", "def", "test_nested", "(", "self", ")", ":", "\n", "        ", "tfms_or_gens", "=", "[", "\n", "RandomRot90", "(", "p", "=", "1.0", ")", ",", "\n", "[", "RandomFlip", "(", "ndim", "=", "2", ",", "p", "=", "1.0", ")", ",", "RandomTranslation", "(", "p", "=", "1.0", ",", "translate", "=", "[", "0.1", ",", "0.2", "]", ")", "]", ",", "\n", "]", "\n", "choice", "=", "RandomTransformChoice", "(", "tfms_or_gens", "=", "tfms_or_gens", ",", "tfm_ps", "=", "\"uniform\"", ",", "p", "=", "1.0", ")", "\n", "choice", ".", "seed", "(", "1", ")", "\n", "\n", "sch1", "=", "WarmupTF", "(", "tfms_or_gens", "[", "-", "1", "]", "[", "0", "]", ",", "params", "=", "[", "\"p\"", "]", ",", "warmup_iters", "=", "100", ")", "\n", "tfms_or_gens", "[", "-", "1", "]", "[", "0", "]", ".", "register_schedulers", "(", "sch1", ")", "\n", "sch2", "=", "WarmupTF", "(", "tfms_or_gens", "[", "0", "]", ",", "params", "=", "[", "\"p\"", "]", ",", "warmup_iters", "=", "200", ")", "\n", "tfms_or_gens", "[", "0", "]", ".", "register_schedulers", "(", "sch2", ")", "\n", "\n", "schedulers", "=", "choice", ".", "schedulers", "(", ")", "\n", "assert", "sch1", "in", "schedulers", "\n", "assert", "sch2", "in", "schedulers", "\n", "\n", "with", "EventStorage", "(", ")", ":", "\n", "            ", "num_samples", "=", "200", "\n", "tfms", "=", "[", "type", "(", "choice", ".", "get_transform", "(", ")", ")", ".", "__name__", "for", "_", "in", "range", "(", "num_samples", ")", "]", "\n", "", "unique", ",", "counts", "=", "np", ".", "unique", "(", "tfms", ",", "return_counts", "=", "True", ")", "\n", "assert", "len", "(", "unique", ")", "==", "2", "\n", "assert", "all", "(", "0.45", "*", "num_samples", "<=", "x", "<=", "0.55", "*", "num_samples", "for", "x", "in", "counts", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_spatial.TestRandomAffine.test_scheduler_basic": [[15, 27], ["mock.MockIterTracker", "meddlr.transforms.gen.RandomAffine", "meddlr.transforms.tf_scheduler.WarmupTF", "meddlr.transforms.gen.RandomAffine.register_schedulers", "mock.MockIterTracker.step", "meddlr.transforms.gen.RandomAffine._get_param_values"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values"], ["    ", "def", "test_scheduler_basic", "(", "self", ")", ":", "\n", "        ", "iter_tracker", "=", "MockIterTracker", "(", ")", "\n", "affine", "=", "RandomAffine", "(", "angle", "=", "10", ",", "translate", "=", "1.0", ",", "scale", "=", "2.0", ")", "\n", "scheduler", "=", "WarmupTF", "(", "affine", ",", "warmup_iters", "=", "400", ",", "params", "=", "[", "\"angle\"", ",", "\"translate\"", "]", ")", "\n", "scheduler", ".", "get_iteration", "=", "iter_tracker", ".", "get_iter", "\n", "affine", ".", "register_schedulers", "(", "[", "scheduler", "]", ")", "\n", "\n", "iter_tracker", ".", "step", "(", "100", ")", "\n", "params", "=", "affine", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "assert", "params", "[", "\"angle\"", "]", "==", "2.5", "\n", "assert", "params", "[", "\"translate\"", "]", "==", "0.25", "\n", "assert", "params", "[", "\"scale\"", "]", "==", "2.0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_spatial.TestRandomAffine.test_scheduler_p": [[28, 63], ["mock.MockIterTracker", "meddlr.transforms.gen.RandomAffine", "meddlr.transforms.tf_scheduler.WarmupTF", "meddlr.transforms.gen.RandomAffine.register_schedulers", "mock.MockIterTracker.step", "meddlr.transforms.gen.RandomAffine._get_param_values", "all", "mock.MockIterTracker", "meddlr.transforms.gen.RandomAffine", "meddlr.transforms.tf_scheduler.WarmupTF", "meddlr.transforms.gen.RandomAffine.register_schedulers", "mock.MockIterTracker.step", "meddlr.transforms.gen.RandomAffine._get_param_values", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "p.values"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "test_scheduler_p", "(", "self", ")", ":", "\n", "        ", "iter_tracker", "=", "MockIterTracker", "(", ")", "\n", "affine", "=", "RandomAffine", "(", "p", "=", "1.0", ",", "angle", "=", "10", ",", "translate", "=", "1.0", ",", "scale", "=", "2.0", ")", "\n", "\n", "scheduler", "=", "WarmupTF", "(", "affine", ",", "warmup_iters", "=", "400", ",", "params", "=", "[", "\"p\"", "]", ")", "\n", "scheduler", ".", "get_iteration", "=", "iter_tracker", ".", "get_iter", "\n", "affine", ".", "register_schedulers", "(", "[", "scheduler", "]", ")", "\n", "\n", "iter_tracker", ".", "step", "(", "100", ")", "\n", "params", "=", "affine", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "assert", "all", "(", "v", "==", "0.25", "for", "v", "in", "p", ".", "values", "(", ")", ")", "\n", "\n", "# Different probability for each.", "\n", "iter_tracker", "=", "MockIterTracker", "(", ")", "\n", "affine", "=", "RandomAffine", "(", "\n", "p", "=", "{", "\"angle\"", ":", "1.0", ",", "\"translate\"", ":", "0.5", ",", "\"scale\"", ":", "0.2", "}", ",", "angle", "=", "10", ",", "translate", "=", "1.0", ",", "scale", "=", "2.0", "\n", ")", "\n", "p", "=", "affine", ".", "p", "\n", "assert", "p", "[", "\"angle\"", "]", "==", "1.0", "\n", "assert", "p", "[", "\"translate\"", "]", "==", "0.5", "\n", "assert", "p", "[", "\"scale\"", "]", "==", "0.2", "\n", "assert", "p", "[", "\"shear\"", "]", "==", "0", "\n", "\n", "scheduler", "=", "WarmupTF", "(", "affine", ",", "warmup_iters", "=", "500", ",", "params", "=", "[", "\"p\"", "]", ")", "\n", "scheduler", ".", "get_iteration", "=", "iter_tracker", ".", "get_iter", "\n", "affine", ".", "register_schedulers", "(", "[", "scheduler", "]", ")", "\n", "\n", "iter_tracker", ".", "step", "(", "100", ")", "\n", "params", "=", "affine", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "assert", "np", ".", "allclose", "(", "p", "[", "\"angle\"", "]", ",", "0.2", ")", "\n", "assert", "np", ".", "allclose", "(", "p", "[", "\"translate\"", "]", ",", "0.1", ")", "\n", "assert", "np", ".", "allclose", "(", "p", "[", "\"scale\"", "]", ",", "0.04", ")", "\n", "assert", "np", ".", "allclose", "(", "p", "[", "\"shear\"", "]", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_spatial.TestRandomAffine.test_multi_arg_param_translate": [[64, 114], ["torch.randn", "meddlr.transforms.gen.RandomAffine", "range", "all", "all", "meddlr.transforms.gen.RandomAffine", "range", "all", "all", "all", "all", "meddlr.transforms.gen.RandomAffine", "range", "all", "all", "all", "meddlr.transforms.gen.RandomAffine.get_transform", "tuple", "h_translate.append", "w_translate.append", "any", "any", "any", "any", "meddlr.transforms.gen.RandomAffine.get_transform", "tuple", "h_translate.append", "w_translate.append", "meddlr.transforms.gen.RandomAffine.get_transform", "tuple", "h_translate.append", "w_translate.append", "any", "any", "abs", "abs", "abs"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "test_multi_arg_param_translate", "(", "self", ")", ":", "\n", "        ", "h", ",", "w", "=", "100", ",", "100", "\n", "img", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "h", ",", "w", ")", "\n", "\n", "t_h", ",", "t_w", "=", "0.1", ",", "0.8", "\n", "affine", "=", "RandomAffine", "(", "translate", "=", "(", "t_h", ",", "t_w", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_translate", ",", "w_translate", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n", "h_translate", ".", "append", "(", "h_t", ")", "\n", "w_translate", ".", "append", "(", "w_t", ")", "\n", "\n", "", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "h_translate", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "h_translate", ")", "\n", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "w_translate", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "w_translate", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "h", "*", "t_h", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "w", "*", "t_w", "for", "x", "in", "w_translate", ")", "\n", "\n", "# Fixed range of values.", "\n", "t_h1", ",", "t_h2", ",", "t_w1", ",", "t_w2", "=", "0.1", ",", "0.2", ",", "-", "0.8", ",", "-", "0.6", "\n", "affine", "=", "RandomAffine", "(", "translate", "=", "(", "(", "t_h1", ",", "t_h2", ")", ",", "(", "t_w1", ",", "t_w2", ")", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_translate", ",", "w_translate", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n", "h_translate", ".", "append", "(", "h_t", ")", "\n", "w_translate", ".", "append", "(", "w_t", ")", "\n", "\n", "", "assert", "all", "(", "x", ">", "0", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "x", "<", "0", "for", "x", "in", "w_translate", ")", "\n", "assert", "all", "(", "h", "*", "t_h1", "<=", "x", "<=", "h", "*", "t_h2", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "w", "*", "t_w1", "<=", "x", "<=", "w", "*", "t_w2", "for", "x", "in", "w_translate", ")", "\n", "\n", "# Mix of range and single value", "\n", "t_h", ",", "t_w1", ",", "t_w2", "=", "0.1", ",", "-", "0.8", ",", "-", "0.6", "\n", "affine", "=", "RandomAffine", "(", "translate", "=", "(", "t_h", ",", "(", "t_w1", ",", "t_w2", ")", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_translate", ",", "w_translate", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n", "h_translate", ".", "append", "(", "h_t", ")", "\n", "w_translate", ".", "append", "(", "w_t", ")", "\n", "\n", "", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "h_translate", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "x", "<", "0", "for", "x", "in", "w_translate", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "h", "*", "t_h", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "w", "*", "t_w1", "<=", "x", "<=", "w", "*", "t_w2", "for", "x", "in", "w_translate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_spatial.TestRandomAffine.test_multi_arg_param_shear": [[115, 165], ["torch.randn", "meddlr.transforms.gen.RandomAffine", "range", "all", "all", "meddlr.transforms.gen.RandomAffine", "range", "all", "all", "all", "all", "meddlr.transforms.gen.RandomAffine", "range", "all", "all", "all", "meddlr.transforms.gen.RandomAffine.get_transform", "tuple", "h_shear.append", "w_shear.append", "any", "any", "any", "any", "meddlr.transforms.gen.RandomAffine.get_transform", "tuple", "h_shear.append", "w_shear.append", "meddlr.transforms.gen.RandomAffine.get_transform", "tuple", "h_shear.append", "w_shear.append", "any", "any", "abs", "abs", "abs"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "test_multi_arg_param_shear", "(", "self", ")", ":", "\n", "        ", "h", ",", "w", "=", "100", ",", "100", "\n", "img", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "h", ",", "w", ")", "\n", "\n", "s_h", ",", "s_w", "=", "10", ",", "80", "\n", "affine", "=", "RandomAffine", "(", "shear", "=", "(", "s_h", ",", "s_w", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_shear", ",", "w_shear", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_s", ",", "w_s", "=", "tuple", "(", "tfm", ".", "shear", ")", "\n", "h_shear", ".", "append", "(", "h_s", ")", "\n", "w_shear", ".", "append", "(", "w_s", ")", "\n", "\n", "", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "h_shear", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "h_shear", ")", "\n", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "w_shear", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "w_shear", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "s_h", "for", "x", "in", "h_shear", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "s_w", "for", "x", "in", "w_shear", ")", "\n", "\n", "# Fixed range of values.", "\n", "s_h1", ",", "s_h2", ",", "s_w1", ",", "s_w2", "=", "10", ",", "20", ",", "-", "80", ",", "-", "60", "\n", "affine", "=", "RandomAffine", "(", "shear", "=", "(", "(", "s_h1", ",", "s_h2", ")", ",", "(", "s_w1", ",", "s_w2", ")", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_shear", ",", "w_shear", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_s", ",", "w_s", "=", "tuple", "(", "tfm", ".", "shear", ")", "\n", "h_shear", ".", "append", "(", "h_s", ")", "\n", "w_shear", ".", "append", "(", "w_s", ")", "\n", "\n", "", "assert", "all", "(", "x", ">", "0", "for", "x", "in", "h_shear", ")", "\n", "assert", "all", "(", "x", "<", "0", "for", "x", "in", "w_shear", ")", "\n", "assert", "all", "(", "s_h1", "<=", "x", "<=", "s_h2", "for", "x", "in", "h_shear", ")", "\n", "assert", "all", "(", "s_w1", "<=", "x", "<=", "s_w2", "for", "x", "in", "w_shear", ")", "\n", "\n", "# Mix of range and single value", "\n", "s_h", ",", "s_w1", ",", "s_w2", "=", "10", ",", "-", "80", ",", "-", "60", "\n", "affine", "=", "RandomAffine", "(", "shear", "=", "(", "s_h", ",", "(", "s_w1", ",", "s_w2", ")", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_shear", ",", "w_shear", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_s", ",", "w_s", "=", "tuple", "(", "tfm", ".", "shear", ")", "\n", "h_shear", ".", "append", "(", "h_s", ")", "\n", "w_shear", ".", "append", "(", "w_s", ")", "\n", "\n", "", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "h_shear", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "h_shear", ")", "\n", "assert", "all", "(", "x", "<", "0", "for", "x", "in", "w_shear", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "s_h", "for", "x", "in", "h_shear", ")", "\n", "assert", "all", "(", "s_w1", "<=", "x", "<=", "s_w2", "for", "x", "in", "w_shear", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_spatial.TestRandomTranslation.test_scheduler_basic": [[168, 178], ["mock.MockIterTracker", "meddlr.transforms.gen.spatial.RandomTranslation", "meddlr.transforms.tf_scheduler.WarmupTF", "meddlr.transforms.gen.spatial.RandomTranslation.register_schedulers", "mock.MockIterTracker.step", "meddlr.transforms.gen.spatial.RandomTranslation._get_param_values", "tuple"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values"], ["    ", "def", "test_scheduler_basic", "(", "self", ")", ":", "\n", "        ", "iter_tracker", "=", "MockIterTracker", "(", ")", "\n", "affine", "=", "RandomTranslation", "(", "translate", "=", "(", "0.1", ",", "0.8", ")", ")", "\n", "scheduler", "=", "WarmupTF", "(", "affine", ",", "warmup_iters", "=", "400", ",", "params", "=", "[", "\"translate\"", "]", ")", "\n", "scheduler", ".", "get_iteration", "=", "iter_tracker", ".", "get_iter", "\n", "affine", ".", "register_schedulers", "(", "[", "scheduler", "]", ")", "\n", "\n", "iter_tracker", ".", "step", "(", "100", ")", "\n", "params", "=", "affine", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "assert", "tuple", "(", "params", "[", "\"translate\"", "]", ")", "==", "(", "0.025", ",", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.gen.test_spatial.TestRandomTranslation.test_multi_arg_param_translate": [[179, 229], ["torch.randn", "meddlr.transforms.gen.spatial.RandomTranslation", "range", "all", "all", "meddlr.transforms.gen.spatial.RandomTranslation", "range", "all", "all", "all", "all", "meddlr.transforms.gen.spatial.RandomTranslation", "range", "all", "all", "all", "meddlr.transforms.gen.spatial.RandomTranslation.get_transform", "tuple", "h_translate.append", "w_translate.append", "any", "any", "any", "any", "meddlr.transforms.gen.spatial.RandomTranslation.get_transform", "tuple", "h_translate.append", "w_translate.append", "meddlr.transforms.gen.spatial.RandomTranslation.get_transform", "tuple", "h_translate.append", "w_translate.append", "any", "any", "abs", "abs", "abs"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "test_multi_arg_param_translate", "(", "self", ")", ":", "\n", "        ", "h", ",", "w", "=", "100", ",", "100", "\n", "img", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "h", ",", "w", ")", "\n", "\n", "t_h", ",", "t_w", "=", "0.1", ",", "0.8", "\n", "affine", "=", "RandomTranslation", "(", "translate", "=", "(", "t_h", ",", "t_w", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_translate", ",", "w_translate", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "TranslationTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n", "h_translate", ".", "append", "(", "h_t", ")", "\n", "w_translate", ".", "append", "(", "w_t", ")", "\n", "\n", "", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "h_translate", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "h_translate", ")", "\n", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "w_translate", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "w_translate", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "h", "*", "t_h", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "w", "*", "t_w", "for", "x", "in", "w_translate", ")", "\n", "\n", "# Fixed range of values.", "\n", "t_h1", ",", "t_h2", ",", "t_w1", ",", "t_w2", "=", "0.1", ",", "0.2", ",", "-", "0.8", ",", "-", "0.6", "\n", "affine", "=", "RandomTranslation", "(", "translate", "=", "(", "(", "t_h1", ",", "t_h2", ")", ",", "(", "t_w1", ",", "t_w2", ")", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_translate", ",", "w_translate", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "TranslationTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n", "h_translate", ".", "append", "(", "h_t", ")", "\n", "w_translate", ".", "append", "(", "w_t", ")", "\n", "\n", "", "assert", "all", "(", "x", ">", "0", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "x", "<", "0", "for", "x", "in", "w_translate", ")", "\n", "assert", "all", "(", "h", "*", "t_h1", "<=", "x", "<=", "h", "*", "t_h2", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "w", "*", "t_w1", "<=", "x", "<=", "w", "*", "t_w2", "for", "x", "in", "w_translate", ")", "\n", "\n", "# Mix of range and single value", "\n", "t_h", ",", "t_w1", ",", "t_w2", "=", "0.1", ",", "-", "0.8", ",", "-", "0.6", "\n", "affine", "=", "RandomTranslation", "(", "translate", "=", "(", "t_h", ",", "(", "t_w1", ",", "t_w2", ")", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_translate", ",", "w_translate", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "TranslationTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n", "h_translate", ".", "append", "(", "h_t", ")", "\n", "w_translate", ".", "append", "(", "w_t", ")", "\n", "\n", "", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "h_translate", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "x", "<", "0", "for", "x", "in", "w_translate", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "h", "*", "t_h", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "w", "*", "t_w1", "<=", "x", "<=", "w", "*", "t_w2", "for", "x", "in", "w_translate", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.__init__": [[28, 49], ["isinstance", "mri.MRIReconAugmentor.to", "meddlr.transforms.build.seed_tfm_gens"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.seed_tfm_gens"], ["def", "__init__", "(", "self", ",", "maps", ":", "torch", ".", "Tensor", ",", "weights", ":", "torch", ".", "Tensor", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            maps (torch.Tensor): Sensitivity maps.\n            weights (torch.Tensor): Undersampling masks.\n                If ``None``, it is assumed that inputs are fully-sampled.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "maps", "=", "maps", "\n", "if", "weights", "is", "None", ":", "\n", "            ", "self", ".", "weights", "=", "1.0", "\n", "", "else", ":", "\n", "            ", "self", ".", "weights", "=", "weights", "\n", "\n", "", "", "def", "_adjoint_op", "(", "self", ",", "kspace", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            kspace: Shape (B,H,W,#coils,[2])\n        Returns:\n            image: Shape (B,H,W,#maps,[2])\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.__call__": [[50, 129], ["mri.MRIReconAugmentor.schedulers", "any", "mri.MRIReconAugmentor._classify_transforms", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel.", "len", "mri.MRIReconAugmentor._permute_data", "mri.MRIReconAugmentor._apply_te", "mri.MRIReconAugmentor._permute_data", "len", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel.", "mask_gen", "normalizer.normalize", "len", "mri.MRIReconAugmentor._permute_data", "mri.MRIReconAugmentor._apply_ti", "mri.MRIReconAugmentor._permute_data", "s.step", "len", "meddlr.get_mask", "meddlr.forward.SenseModel", "isinstance", "x.get_transform", "isinstance", "isinstance", "_temp.extend", "_temp.append"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.schedulers", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._classify_transforms", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._permute_data", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._apply_te", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._permute_data", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.TopMagnitudeNormalizer.normalize", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._permute_data", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._apply_ti", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._permute_data", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform"], ["image", "=", "oF", ".", "ifft2c", "(", "self", ".", "weights", "*", "kspace", ",", "channels_last", "=", "True", ")", "\n", "if", "cplx", ".", "is_complex_as_real", "(", "kspace", ")", ":", "\n", "            ", "image", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "2", ")", ",", "cplx", ".", "conj", "(", "self", ".", "maps", ")", ")", "# [B,...,#coils,#maps,2]", "\n", "return", "image", ".", "sum", "(", "-", "3", ")", "\n", "", "else", ":", "\n", "# This is a hacky solution managing multi-channel inputs.", "\n", "# Note multi-channel inputs are only supported in complex tensors.", "\n", "# TODO (arjundd, issue #18): Fix with tensor ordering.", "\n", "            ", "if", "image", ".", "ndim", "!=", "self", ".", "maps", ".", "ndim", ":", "\n", "                ", "image", "=", "image", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "", "image", "=", "cplx", ".", "mul", "(", "image", ",", "cplx", ".", "conj", "(", "self", ".", "maps", ")", ")", "# [B,...,#coils,#maps,1]", "\n", "return", "image", ".", "sum", "(", "-", "2", ")", "\n", "\n", "", "", "def", "_forward_op", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image: Shape (B,H,W,#maps,[2])\n        Returns:\n            kspace: Shape (B,H,W,#coils,[2])\n        \"\"\"", "\n", "if", "cplx", ".", "is_complex_as_real", "(", "image", ")", ":", "\n", "            ", "kspace", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "3", ")", ",", "self", ".", "maps", ")", "# [B,...,1,#maps,2]", "\n", "kspace", "=", "self", ".", "weights", "*", "oF", ".", "fft2c", "(", "kspace", ".", "sum", "(", "-", "2", ")", ",", "channels_last", "=", "True", ")", "# [B,...,#coils,2]", "\n", "", "else", ":", "\n", "            ", "kspace", "=", "cplx", ".", "mul", "(", "image", ".", "unsqueeze", "(", "-", "2", ")", ",", "self", ".", "maps", ")", "\n", "# This is a hacky solution managing multi-channel inputs.", "\n", "# Note this change means that multiple maps with multi-channel inputs", "\n", "# is not supported for forward operations. This will change in future updates.", "\n", "# TODO (arjundd, issue #18): Fix with tensor ordering.", "\n", "if", "image", ".", "shape", "[", "-", "1", "]", "==", "self", ".", "maps", ".", "shape", "[", "-", "1", "]", ":", "\n", "                ", "kspace", "=", "kspace", ".", "sum", "(", "-", "1", ")", "\n", "", "kspace", "=", "self", ".", "weights", "*", "oF", ".", "fft2c", "(", "kspace", ",", "channels_last", "=", "True", ")", "\n", "", "return", "kspace", "\n", "\n", "", "def", "forward", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ",", "adjoint", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Run forward or adjoint SENSE operation on the input.\n\n        Depending on if ``adjoint=True``, the input should either be the\n        k-space or the complex image. The shapes for these are as follows:\n            - kspace: ``(B, H, W, #coils, [2])\n            - image: ``(B, H, W, #maps, [2])``\n\n        Args:\n            input (torch.Tensor): If ``adjoint=True``, this is the multi-coil k-space,\n                else it is the image.\n            adjoint (bool, optional): If ``True``, use adjoint operation.\n\n        Returns:\n            torch.Tensor: If ``adjoint=True``, the image, else multi-coil k-space.\n        \"\"\"", "\n", "if", "adjoint", ":", "\n", "            ", "output", "=", "self", ".", "_adjoint_op", "(", "input", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "self", ".", "_forward_op", "(", "input", ")", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.schedulers": [[130, 135], ["tfm.schedulers", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.schedulers"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.get_tfm_gen_params": [[136, 152], ["schedulers.items", "tfm._get_param_values", "meddlr.evaluation.testing.flatten_results_dict", "params.update", "type", "isinstance", "meddlr.evaluation.testing.flatten_results_dict.items", "meddlr.evaluation.testing.flatten_results_dict.items", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform_gen.TransformGen._get_param_values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.flatten_results_dict", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._classify_transforms": [[153, 168], ["isinstance", "issubclass", "issubclass", "type", "tfms_equivariant.append", "tfms_invariant.append"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._permute_data": [[169, 180], ["tuple", "out.append", "out.append", "len", "x.permute", "tuple", "x.permute", "tuple", "range", "range"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._apply_te": [[181, 198], ["isinstance", "tfm.apply_image", "tfms.append", "meddlr.transforms.transform.TransformList", "isinstance", "g.get_transform", "tfm.apply_image", "tfm.apply_maps"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.TranslationTransform.apply_maps"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor._apply_ti": [[199, 212], ["isinstance", "tfm.apply_kspace", "tfms.append", "meddlr.transforms.transform.TransformList", "isinstance", "g.get_transform"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.gen.mask.RandomKspaceMask.get_transform"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.reset": [[213, 217], ["isinstance", "g.reset"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to": [[218, 223], ["t.to", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.from_cfg": [[224, 258], ["meddlr.transforms.build.build_transforms", "dict", "dict.pop", "cls", "meddlr.utils.env.is_repro", "len", "meddlr.transforms.build.build_iter_func", "meddlr.transforms.build.build_scheduler", "tfm.register_schedulers", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_transforms", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_repro", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_iter_func", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.build.build_scheduler", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.tf_scheduler.SchedulableMixin.register_schedulers"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.test_mri.TestMRIReconAugmentor.test_transform_separation": [[23, 34], ["meddlr.transforms.base.Rot90Transform", "meddlr.transforms.base.NoiseTransform", "meddlr.transforms.builtin.mri.MRIReconAugmentor", "mock.generate_mock_mri_data", "meddlr.transforms.builtin.mri.MRIReconAugmentor."], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data"], ["maps", "=", "torch", ".", "view_as_complex", "(", "torch", ".", "randn", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "nm", ",", "2", ")", ")", "\n", "maps", "=", "maps", "/", "cplx", ".", "rss", "(", "maps", ",", "dim", "=", "-", "2", ")", ".", "unsqueeze", "(", "-", "2", ")", "\n", "\n", "A", "=", "T", ".", "SenseModel", "(", "maps", ")", "\n", "A_new", "=", "SenseModel", "(", "maps", ")", "\n", "expected", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "out", "=", "A_new", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "expected", ")", "\n", "assert", "torch", ".", "allclose", "(", "A_new", "(", "out", ",", "adjoint", "=", "False", ")", ",", "A", "(", "expected", ",", "adjoint", "=", "False", ")", ")", "\n", "\n", "# With mask.", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "kspace", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.test_mri.TestMRIReconAugmentor.test_forward": [[35, 52], ["mock.generate_mock_mri_data", "meddlr.transforms.builtin.mri.MRIReconAugmentor", "meddlr.transforms.builtin.mri.MRIReconAugmentor.", "meddlr.transforms.builtin.mri.MRIReconAugmentor", "meddlr.transforms.builtin.mri.MRIReconAugmentor.", "torch.allclose", "torch.allclose", "torch.allclose", "meddlr.transforms.base.Rot90Transform", "meddlr.transforms.base.FlipTransform", "meddlr.transforms.base.AffineTransform"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data"], ["A", "=", "T", ".", "SenseModel", "(", "maps", ",", "weights", "=", "mask", ")", "\n", "A_new", "=", "SenseModel", "(", "maps", ",", "weights", "=", "mask", ")", "\n", "expected", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "out", "=", "A_new", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "expected", ")", "\n", "assert", "torch", ".", "allclose", "(", "A_new", "(", "out", ",", "adjoint", "=", "False", ")", ",", "A", "(", "expected", ",", "adjoint", "=", "False", ")", ")", "\n", "\n", "# Complex tensor as real view.", "\n", "kspace", "=", "torch", ".", "view_as_real", "(", "kspace", ")", "\n", "maps", "=", "torch", ".", "view_as_real", "(", "maps", ")", "\n", "\n", "A", "=", "T", ".", "SenseModel", "(", "maps", ")", "\n", "A_new", "=", "SenseModel", "(", "maps", ")", "\n", "expected", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "out", "=", "A_new", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "assert", "torch", ".", "allclose", "(", "out", ",", "expected", ")", "\n", "assert", "torch", ".", "allclose", "(", "A_new", "(", "out", ",", "adjoint", "=", "False", ")", ",", "A", "(", "expected", ",", "adjoint", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.test_mri.TestMRIReconAugmentor.test_random": [[75, 103], ["mock.generate_mock_mri_data", "meddlr.transforms.builtin.mri.MRIReconAugmentor", "meddlr.transforms.builtin.mri.MRIReconAugmentor.", "meddlr.transforms.builtin.mri.MRIReconAugmentor", "meddlr.transforms.builtin.mri.MRIReconAugmentor.", "zip", "zip", "torch.allclose", "torch.allclose", "torch.allclose", "meddlr.transforms.gen.RandomRot90", "meddlr.transforms.gen.RandomFlip", "meddlr.transforms.gen.RandomAffine", "meddlr.transforms.gen.RandomNoise", "meddlr.transforms.gen.RandomMRIMotion", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data"], ["expected", "=", "[", "]", "\n", "for", "c", "in", "range", "(", "num_channels", ")", ":", "\n", "            ", "expected", ".", "append", "(", "A", "(", "out_image", "[", "...", ",", "c", ":", "c", "+", "1", "]", ",", "adjoint", "=", "False", ")", ")", "\n", "", "expected", "=", "torch", ".", "stack", "(", "expected", ",", "dim", "=", "-", "1", ")", "\n", "out_kspace", "=", "A", "(", "out_image", ",", "adjoint", "=", "False", ")", "\n", "# both clauses required for CI to pass on python 3.7 - torch.allclose does not work", "\n", "assert", "torch", ".", "allclose", "(", "out_kspace", ",", "expected", ",", "atol", "=", "1e-5", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.test_mri.TestMRIReconAugmentor.test_get_scheduler_params": [[104, 171], ["meddlr.config.config.get_cfg", "meddlr.transforms.builtin.mri.MRIReconAugmentor.from_cfg", "meddlr.utils.events.EventStorage", "meddlr.transforms.builtin.mri.MRIReconAugmentor.from_cfg.get_tfm_gen_params", "meddlr.transforms.builtin.mri.MRIReconAugmentor.from_cfg.get_tfm_gen_params", "numpy.allclose", "numpy.allclose"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.get_tfm_gen_params", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.get_tfm_gen_params"], []], "home.repos.pwc.inspect_result.ad12_meddlr.builtin.test_mri.TestMRIReconAugmentor.test_from_cfg": [[173, 244], ["meddlr.config.config.get_cfg", "meddlr.transforms.builtin.mri.MRIReconAugmentor.from_cfg", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "len", "tuple", "len", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.__init__": [[14, 33], ["ValueError", "generator.get_state"], "methods", ["None"], ["class", "RandomNoise", "(", "TransformGen", ")", ":", "\n", "    ", "\"\"\"A model that adds additive white noise.\"\"\"", "\n", "\n", "_base_transform", "=", "NoiseTransform", "\n", "_param_names", "=", "[", "\"std_devs\"", ",", "\"rhos\"", "]", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "float", "=", "0.0", ",", "\n", "std_devs", ":", "Tuple", "[", "float", ",", "float", "]", "=", "None", ",", "\n", "rhos", ":", "Tuple", "[", "float", ",", "float", "]", "=", "None", ",", "\n", "use_mask", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "std_devs", "=", "(", "std_devs", ",", "std_devs", ")", "if", "not", "isinstance", "(", "std_devs", ",", "Sequence", ")", "else", "std_devs", "\n", "if", "rhos", "is", "not", "None", ":", "\n", "            ", "rhos", "=", "(", "rhos", ",", "rhos", ")", "if", "not", "isinstance", "(", "rhos", ",", "Sequence", ")", "else", "rhos", "\n", "\n", "", "params", "=", "locals", "(", ")", "\n", "params", "=", "{", "k", ":", "params", "[", "k", "]", "for", "k", "in", "list", "(", "self", ".", "_param_names", ")", "+", "[", "\"p\"", "]", "}", "\n", "self", ".", "use_mask", "=", "use_mask", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.apply_kspace": [[34, 36], ["noise.NoiseTransform._add_noise"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform._add_noise"], ["super", "(", ")", ".", "__init__", "(", "params", "=", "params", ",", "p", "=", "p", ")", "\n", "\n", "", "def", "get_transform", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform._generator": [[37, 46], ["torch.Generator", "g.manual_seed.manual_seed.set_state", "g.manual_seed.manual_seed.manual_seed"], "methods", ["None"], ["        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "std_devs", "=", "params", "[", "\"std_devs\"", "]", "\n", "rho", "=", "params", "[", "\"rhos\"", "]", "\n", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "params", "[", "\"p\"", "]", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "std_dev", "=", "self", ".", "_rand_range", "(", "*", "std_devs", ")", "\n", "if", "rho", "is", "not", "None", ":", "\n", "            ", "rho", "=", "self", ".", "_rand_range", "(", "*", "rho", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform._add_noise": [[47, 71], ["torch.view_as_complex.NoiseTransform._generator", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.get_mask", "torch.ones", "torch.view_as_complex", "torch.view_as_complex.NoiseTransform.subsample_mask", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform._generator", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.subsample_mask"], ["\n", "", "gen", "=", "self", ".", "_generator", "\n", "if", "gen", "is", "None", "or", "gen", ".", "device", "!=", "input", ".", "device", ":", "\n", "            ", "gen", "=", "torch", ".", "Generator", "(", "device", "=", "input", ".", "device", ")", ".", "manual_seed", "(", "int", "(", "self", ".", "_rand", "(", ")", "*", "1e10", ")", ")", "\n", "", "return", "NoiseTransform", "(", "std_dev", "=", "std_dev", ",", "use_mask", "=", "self", ".", "use_mask", ",", "rho", "=", "rho", ",", "generator", "=", "gen", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.subsample_mask": [[72, 91], ["mask.view.view.view", "torch.sum", "int", "torch.multinomial", "mask.view.view.view"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform.from_cfg": [[92, 96], ["cls"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.noise.NoiseTransform._eq_attrs": [[97, 99], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.AffineTransform.__init__": [[18, 45], ["meddlr.transforms.mixins.GeometricMixin.__init__", "logging.getLogger", "spatial.AffineTransform._set_attributes", "ValueError", "logging.getLogger.warning", "locals", "type"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.Transform._set_attributes"], ["\n", "SPATIAL_RANGE_OR_VAL", "=", "Union", "[", "float", ",", "Sequence", "[", "float", "]", ",", "Sequence", "[", "Tuple", "[", "float", ",", "float", "]", "]", "]", "\n", "\n", "\n", "@", "TRANSFORM_REGISTRY", ".", "register", "(", ")", "\n", "class", "RandomAffine", "(", "TransformGen", ")", ":", "\n", "    ", "_base_transform", "=", "AffineTransform", "\n", "_param_names", "=", "(", "\"angle\"", ",", "\"translate\"", ",", "\"scale\"", ",", "\"shear\"", ")", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", "=", "0.0", ",", "\n", "angle", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "translate", ":", "SPATIAL_RANGE_OR_VAL", "=", "None", ",", "\n", "scale", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "shear", ":", "SPATIAL_RANGE_OR_VAL", "=", "None", ",", "\n", "pad_like", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "isinstance", "(", "p", ",", "Number", ")", ":", "\n", "            ", "p", "=", "{", "n", ":", "p", "for", "n", "in", "self", ".", "_param_names", "}", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "p", ",", "dict", ")", "\n", "unknown_keys", "=", "set", "(", "p", ".", "keys", "(", ")", ")", "-", "set", "(", "self", ".", "_param_names", ")", "\n", "if", "len", "(", "unknown_keys", ")", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Unknown keys for `p`: {unknown_keys}\"", ")", "\n", "", "p", "=", "p", ".", "copy", "(", ")", "\n", "p", ".", "update", "(", "{", "k", ":", "0.0", "for", "k", "in", "self", ".", "_param_names", "if", "k", "not", "in", "p", "}", ")", "\n", "", "params", "=", "locals", "(", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.AffineTransform._apply_affine": [[46, 104], ["meddlr.is_complex", "torchvision.affine", "meddlr.is_complex_as_real", "torch.view_as_real", "torch.view_as_real", "torch.view_as_real", "torch.view_as_real", "img.reshape.reshape.permute", "img.reshape.reshape.is_contiguous", "torchvision.resize", "spatial._get_mraugment_affine_pad", "torchvision.pad", "torchvision.center_crop", "torchvision.resize", "img.reshape.reshape.view", "img.reshape.reshape.permute", "torch.view_as_complex", "torch.view_as_complex", "torch.view_as_complex", "torch.view_as_complex", "img.reshape.reshape.view", "img.reshape.reshape.reshape", "img.reshape.reshape.contiguous", "tuple", "tuple", "range", "range", "numpy.product", "numpy.product"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial._get_mraugment_affine_pad", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.center_crop"], ["params", "=", "{", "k", ":", "params", "[", "k", "]", "for", "k", "in", "list", "(", "self", ".", "_param_names", ")", "}", "\n", "self", ".", "pad_like", "=", "pad_like", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "params", "=", "params", ",", "\n", "p", "=", "p", ",", "\n", "param_kinds", "=", "{", "\"translate\"", ":", "ParamKind", ".", "MULTI_ARG", ",", "\"shear\"", ":", "ParamKind", ".", "MULTI_ARG", "}", ",", "\n", ")", "\n", "\n", "", "def", "_get_params", "(", "self", ",", "shape", ")", ":", "\n", "        ", "ndim", "=", "len", "(", "shape", ")", "\n", "params", "=", "self", ".", "_get_param_values", "(", ")", "\n", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "param_angle", "=", "params", "[", "\"angle\"", "]", "\n", "param_translate", "=", "params", "[", "\"translate\"", "]", "\n", "param_scale", "=", "params", "[", "\"scale\"", "]", "\n", "param_shear", "=", "params", "[", "\"shear\"", "]", "\n", "\n", "if", "isinstance", "(", "param_angle", ",", "Number", ")", ":", "\n", "            ", "param_angle", "=", "(", "-", "param_angle", ",", "param_angle", ")", "\n", "", "if", "isinstance", "(", "param_translate", ",", "Number", ")", ":", "\n", "            ", "param_translate", "=", "(", "(", "-", "param_translate", ",", "param_translate", ")", ",", ")", "\n", "", "if", "isinstance", "(", "param_scale", ",", "Number", ")", ":", "\n", "            ", "param_scale", "=", "tuple", "(", "sorted", "(", "[", "1.0", "-", "param_scale", ",", "1.0", "+", "param_scale", "]", ")", ")", "\n", "", "if", "isinstance", "(", "param_shear", ",", "Number", ")", ":", "\n", "            ", "param_shear", "=", "(", "(", "-", "param_shear", ",", "param_shear", ")", ",", ")", "\n", "\n", "", "param_translate", "=", "self", ".", "_format_param", "(", "param_translate", ",", "ParamKind", ".", "MULTI_ARG", ",", "ndim", ")", "\n", "param_shear", "=", "self", ".", "_format_param", "(", "param_shear", ",", "ParamKind", ".", "MULTI_ARG", ",", "ndim", ")", "\n", "\n", "angle", ",", "translate", ",", "scale", ",", "shear", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "\n", "if", "param_angle", "is", "not", "None", "and", "self", ".", "_rand", "(", ")", "<", "p", "[", "\"angle\"", "]", ":", "\n", "            ", "angle", "=", "self", ".", "_rand_range", "(", "*", "param_angle", ")", "\n", "", "if", "param_translate", "is", "not", "None", "and", "self", ".", "_rand", "(", ")", "<", "p", "[", "\"translate\"", "]", ":", "\n", "            ", "translate", "=", "[", "int", "(", "self", ".", "_rand_range", "(", "*", "x", ")", "*", "s", ")", "for", "x", ",", "s", "in", "zip", "(", "param_translate", ",", "shape", ")", "]", "\n", "", "if", "param_scale", "is", "not", "None", "and", "self", ".", "_rand", "(", ")", "<", "p", "[", "\"scale\"", "]", ":", "\n", "            ", "scale", "=", "self", ".", "_rand_range", "(", "*", "param_scale", ")", "\n", "", "if", "param_shear", "is", "not", "None", "and", "self", ".", "_rand", "(", ")", "<", "p", "[", "\"shear\"", "]", ":", "\n", "            ", "shear", "=", "[", "self", ".", "_rand_range", "(", "*", "x", ")", "for", "x", "in", "param_shear", "]", "\n", "\n", "", "return", "angle", ",", "translate", ",", "scale", ",", "shear", "\n", "\n", "", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "# Affine only supports 2D spatial transforms", "\n", "        ", "spatial_shape", "=", "image", ".", "shape", "[", "-", "2", ":", "]", "\n", "\n", "out", "=", "self", ".", "_get_params", "(", "spatial_shape", ")", "\n", "if", "all", "(", "x", "is", "None", "for", "x", "in", "out", ")", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "angle", ",", "translate", ",", "scale", ",", "shear", "=", "out", "\n", "return", "AffineTransform", "(", "angle", "=", "angle", ",", "translate", "=", "translate", ",", "scale", "=", "scale", ",", "shear", "=", "shear", ")", "\n", "\n", "\n", "", "", "@", "TRANSFORM_REGISTRY", ".", "register", "(", ")", "\n", "class", "RandomTranslation", "(", "TransformGen", ")", ":", "\n", "    ", "_base_transform", "=", "TranslationTransform", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.AffineTransform.apply_image": [[105, 107], ["spatial.AffineTransform._apply_affine"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.AffineTransform._apply_affine"], ["def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", "=", "0.0", ",", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.AffineTransform.apply_maps": [[108, 114], ["spatial.AffineTransform._apply_affine", "meddlr.rss().unsqueeze", "meddlr.rss"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.AffineTransform._apply_affine", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.rss"], ["translate", ":", "SPATIAL_RANGE_OR_VAL", "=", "None", ",", "\n", "pad_mode", "=", "None", ",", "\n", "pad_value", "=", "0", ",", "\n", "ndim", "=", "2", ",", "\n", ")", ":", "\n", "        ", "params", "=", "{", "\"translate\"", ":", "translate", "}", "\n", "self", ".", "pad_mode", "=", "pad_mode", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.AffineTransform._eq_attrs": [[115, 117], ["None"], "methods", ["None"], ["self", ".", "pad_value", "=", "pad_value", "\n", "self", ".", "ndim", "=", "ndim", "\n", "super", "(", ")", ".", "__init__", "(", "params", "=", "params", ",", "p", "=", "p", ",", "param_kinds", "=", "{", "\"translate\"", ":", "ParamKind", ".", "MULTI_ARG", "}", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.TranslationTransform.__init__": [[121, 126], ["meddlr.transforms.mixins.GeometricMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["ndim", "=", "len", "(", "shape", ")", "\n", "\n", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "param_translate", "=", "params", "[", "\"translate\"", "]", "\n", "translate", "=", "self", ".", "_format_param", "(", "param_translate", ",", "ParamKind", ".", "MULTI_ARG", ",", "ndim", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.TranslationTransform.apply_image": [[127, 161], ["meddlr.is_complex", "spatial._get_mraugment_translate_pad", "torch.pad", "torch.pad", "len", "meddlr.is_complex_as_real", "torch.view_as_real", "torch.view_as_real", "torch.view_as_real", "torch.view_as_real", "img.reshape.reshape.permute", "img.reshape.reshape.is_contiguous", "img.reshape.reshape.view", "img.reshape.reshape.permute", "torch.view_as_complex", "torch.view_as_complex", "torch.view_as_complex", "torch.view_as_complex", "img.reshape.reshape.view", "img.reshape.reshape.reshape", "img.reshape.reshape.contiguous", "tuple", "tuple", "range", "range", "numpy.product", "numpy.product"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial._get_mraugment_translate_pad", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad", "home.repos.pwc.inspect_result.ad12_meddlr.ops.utils.pad", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real"], ["\n", "if", "self", ".", "_rand", "(", ")", ">=", "p", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "", "translate", "=", "[", "int", "(", "self", ".", "_rand_range", "(", "*", "x", ")", "*", "s", ")", "for", "x", ",", "s", "in", "zip", "(", "translate", ",", "shape", ")", "]", "\n", "return", "TranslationTransform", "(", "translate", ",", "pad_mode", "=", "self", ".", "pad_mode", ",", "pad_value", "=", "self", ".", "pad_value", ")", "\n", "\n", "\n", "", "", "@", "TRANSFORM_REGISTRY", ".", "register", "(", ")", "\n", "class", "RandomFlip", "(", "TransformGen", ")", ":", "\n", "    ", "_base_transform", "=", "FlipTransform", "\n", "\n", "def", "__init__", "(", "self", ",", "dims", "=", "None", ",", "ndim", "=", "None", ",", "p", ":", "Union", "[", "float", ",", "Dict", "[", "int", ",", "float", "]", "]", "=", "0.0", ")", "->", "None", ":", "\n", "        ", "if", "dims", "is", "None", "and", "ndim", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either `dims` or `ndim` must be specified\"", ")", "\n", "", "if", "all", "(", "x", "is", "not", "None", "for", "x", "in", "(", "dims", ",", "ndim", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only one of `dims` or `ndim` can be specified.\"", ")", "\n", "", "if", "isinstance", "(", "dims", ",", "int", ")", ":", "\n", "            ", "dims", "=", "(", "dims", ",", ")", "\n", "", "self", ".", "dims", "=", "dims", "\n", "self", ".", "ndim", "=", "ndim", "\n", "super", "(", ")", ".", "__init__", "(", "p", "=", "p", ")", "\n", "\n", "", "def", "get_transform", "(", "self", ",", "input", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "if", "self", ".", "dims", "is", "not", "None", ":", "\n", "            ", "dims", "=", "tuple", "(", "d", "for", "d", "in", "self", ".", "dims", "if", "self", ".", "_rand", "(", ")", "<", "p", ")", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "p", ",", "Dict", ")", ":", "\n", "                ", "dims", "=", "tuple", "(", "k", "for", "k", ",", "v", "in", "p", ".", "items", "(", ")", "if", "self", ".", "_rand", "(", ")", "<", "v", ")", "\n", "", "else", ":", "\n", "                ", "dims", "=", "tuple", "(", "d", "for", "d", "in", "range", "(", "-", "self", ".", "ndim", ",", "0", ")", "if", "self", ".", "_rand", "(", ")", "<", "p", ")", "\n", "\n", "", "", "return", "FlipTransform", "(", "dims", ")", "if", "dims", "else", "NoOpTransform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.TranslationTransform.apply_maps": [[162, 168], ["spatial.TranslationTransform.apply_image", "meddlr.rss().unsqueeze", "meddlr.rss"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.rss"], ["\n", "", "", "@", "TRANSFORM_REGISTRY", ".", "register", "(", ")", "\n", "class", "RandomRot90", "(", "TransformGen", ")", ":", "\n", "    ", "_base_transform", "=", "Rot90Transform", "\n", "\n", "def", "__init__", "(", "self", ",", "ks", "=", "None", ",", "p", "=", "0.0", ")", "->", "None", ":", "\n", "        ", "self", ".", "ks", "=", "ks", "if", "ks", "is", "not", "None", "else", "list", "(", "range", "(", "1", ",", "4", ")", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.FlipTransform.__init__": [[172, 177], ["meddlr.transforms.mixins.GeometricMixin.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "if", "self", ".", "_rand", "(", ")", ">=", "params", "[", "\"p\"", "]", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "", "k", "=", "self", ".", "ks", "[", "torch", ".", "randperm", "(", "len", "(", "self", ".", "ks", ")", ")", "[", "0", "]", ".", "item", "(", ")", "]", "\n", "return", "Rot90Transform", "(", "k", "=", "k", ",", "dims", "=", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.FlipTransform.apply_image": [[178, 182], ["meddlr.is_complex_as_real", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.view_as_complex", "torch.view_as_complex", "torch.view_as_complex", "torch.view_as_complex"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real"], ["\n", "", "", "def", "_duplicate_ndim", "(", "param", ",", "ndim", ")", ":", "\n", "    ", "if", "param", "is", "None", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.FlipTransform.apply_kspace": [[183, 185], ["spatial.FlipTransform.apply_image"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image"], ["", "if", "isinstance", "(", "param", ",", "Sequence", ")", "and", "isinstance", "(", "param", "[", "0", "]", ",", "Sequence", ")", ":", "\n", "        ", "return", "[", "[", "x", "if", "len", "(", "x", ")", ">", "1", "else", "(", "-", "x", "[", "0", "]", ",", "x", "[", "0", "]", ")", "for", "x", "in", "y", "]", "for", "y", "in", "param", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.FlipTransform.inverse": [[186, 188], ["spatial.FlipTransform"], "methods", ["None"], ["", "if", "isinstance", "(", "param", ",", "Sequence", ")", ":", "\n", "        ", "param", "=", "(", "-", "param", "[", "0", "]", ",", "param", "[", "0", "]", ")", "if", "len", "(", "param", ")", "==", "1", "else", "param", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.FlipTransform._eq_attrs": [[189, 191], ["None"], "methods", ["None"], ["        ", "param", "=", "(", "-", "param", ",", "param", ")", "\n", "", "return", "[", "param", "]", "*", "ndim", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.__init__": [[195, 199], ["meddlr.transforms.mixins.GeometricMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image": [[200, 202], ["torch.rot90", "torch.rot90", "torch.rot90", "torch.rot90"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_kspace": [[203, 205], ["spatial.Rot90Transform.apply_image"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.inverse": [[206, 208], ["spatial.Rot90Transform"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform._eq_attrs": [[209, 211], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial._get_mraugment_affine_pad": [[213, 248], ["torch.tensor().reshape", "torch.tensor().reshape", "torch.cat", "torch.cat", "torch.matmul", "torch.matmul", "torch.cat", "torch.cat", "torch.clip", "torch.clip", "torch.clip", "torch.clip", "torch.cat.amax", "torch.cat.amin", "torch.floor", "torch.floor", "torch.floor", "torch.floor", "int", "int", "torch.tensor", "torch.tensor", "torch.tensor().reshape", "torch.tensor().reshape", "torch.clip.item", "torch.clip.item", "torchvision._get_inverse_affine_matrix", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial._get_mraugment_translate_pad": [[250, 266], ["zip", "sl.insert", "pad.append", "sl.append", "pad.append", "sl.append", "len", "slice", "slice", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.motion.MRIMotionTransform.__init__": [[34, 47], ["generator.get_state"], "methods", ["None"], ["\n", "\n", "_base_transform", "=", "MRIMotionTransform", "\n", "\n", "def", "__init__", "(", "self", ",", "std_devs", ":", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", ",", "p", ":", "float", "=", "0.0", ")", ":", "\n", "        ", "if", "isinstance", "(", "std_devs", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "            ", "std_devs", "=", "(", "std_devs", ",", "std_devs", ")", "\n", "", "elif", "len", "(", "std_devs", ")", ">", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"`motion_range` must have 2 or fewer values\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "params", "=", "{", "\"std_devs\"", ":", "std_devs", "}", ",", "p", "=", "p", ")", "\n", "\n", "", "def", "get_transform", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.motion.MRIMotionTransform._generator": [[48, 57], ["torch.Generator", "g.manual_seed.manual_seed.set_state", "g.manual_seed.manual_seed.manual_seed"], "methods", ["None"], ["if", "self", ".", "_rand", "(", ")", ">=", "params", "[", "\"p\"", "]", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "std_dev", "=", "self", ".", "_rand_range", "(", "*", "params", "[", "\"std_devs\"", "]", ")", "\n", "gen", "=", "self", ".", "_generator", "\n", "if", "gen", "is", "None", "or", "gen", ".", "device", "!=", "input", ".", "device", ":", "\n", "            ", "gen", "=", "torch", ".", "Generator", "(", "device", "=", "input", ".", "device", ")", ".", "manual_seed", "(", "int", "(", "self", ".", "_rand", "(", ")", "*", "1e10", ")", ")", "\n", "", "return", "MRIMotionTransform", "(", "std_dev", "=", "std_dev", ",", "generator", "=", "gen", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.base.motion.MRIMotionTransform.apply_kspace": [[58, 77], ["motion.MRIMotionTransform._generator", "meddlr.add_even_odd_motion"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform._generator", "home.repos.pwc.inspect_result.ad12_meddlr.functional.mri.add_even_odd_motion"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.motion.MRIMotionTransform._eq_attrs": [[79, 81], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.__init__": [[50, 86], ["ValueError", "generator.get_state"], "methods", ["None"], ["", "else", ":", "\n", "            ", "rho", "=", "rhos", "\n", "\n", "", "gen", "=", "self", ".", "_generator", "\n", "if", "gen", "is", "None", "or", "gen", ".", "device", "!=", "input", ".", "device", ":", "\n", "            ", "gen", "=", "torch", ".", "Generator", "(", "device", "=", "input", ".", "device", ")", ".", "manual_seed", "(", "int", "(", "self", ".", "_rand", "(", ")", "*", "1e10", ")", ")", "\n", "", "return", "KspaceMaskTransform", "(", "\n", "rho", "=", "rho", ",", "\n", "kind", "=", "self", ".", "kind", ",", "\n", "per_example", "=", "self", ".", "per_example", ",", "\n", "calib_size", "=", "self", ".", "calib_size", ",", "\n", "generator", "=", "gen", ",", "\n", "std_scale", "=", "self", ".", "std_scale", ",", "\n", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.generate_mask": [[87, 137], ["mask.permute.KspaceMaskTransform._generator", "meddlr.ops.complex.channels_first", "isinstance", "torch.cat", "func", "mask.permute.permute.permute", "mask.permute.permute.permute", "tuple", "func", "tuple", "range", "range", "range", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform._generator", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.channels_first", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace": [[138, 151], ["mask.KspaceMaskTransform.KspaceMaskTransform.generate_mask"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.generate_mask"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform._generator": [[152, 161], ["torch.Generator", "g.manual_seed.manual_seed.set_state", "g.manual_seed.manual_seed.manual_seed"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform._subsample": [[162, 171], ["warnings.warn", "mask.KspaceMaskTransform.KspaceMaskTransform.generate_mask", "type"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.generate_mask"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform._eq_attrs": [[172, 174], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.mask._uniform_mask": [[176, 212], ["orig_mask.clone", "torch.sum", "int", "torch.multinomial", "mask.view.view", "meddlr.ops.complex.get_mask", "tuple", "mask.view.is_contiguous", "mask.view.view", "mask.view.reshape", "isinstance", "tuple", "slice", "len", "zip"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.mask._gaussian_mask": [[214, 272], ["cplx.get_mask.clone", "tuple", "torch.sum", "int", "torch.zeros_like", "mask.view.view", "meddlr.ops.complex.get_mask", "tuple", "idxs.insert", "isinstance", "torch.round().type", "any", "any", "torch.all", "torch.all", "slice", "zip", "zip", "torch.round", "torch.normal", "zip", "float", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask"], []], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_motion.TestMRIMotionTransform.test_reproducibility": [[13, 25], ["mock.generate_mock_mri_data", "itertools.product", "meddlr.data.transforms.motion.MotionModel", "meddlr.transforms.base.motion.MRIMotionTransform", "meddlr.data.transforms.motion.MotionModel.", "meddlr.transforms.base.motion.MRIMotionTransform.apply_kspace", "torch.equal"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace"], ["kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", ")", "\n", "kspace", "=", "kspace", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "# BxCxHxW", "\n", "\n", "motion_aug", "=", "RandomMRIMotion", "(", "p", "=", "1.0", ",", "std_devs", "=", "(", "0.6", ",", "0.6", ")", ")", "\n", "\n", "tfm", "=", "motion_aug", ".", "get_transform", "(", "kspace", ")", "\n", "out1", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "\n", "tfm", "=", "motion_aug", ".", "get_transform", "(", "kspace", ")", "\n", "out2", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "\n", "assert", "not", "torch", ".", "allclose", "(", "out1", ",", "out2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_mask.TestKspaceMaskTransform.test_basic": [[13, 34], ["mock.generate_mock_mri_data", "kspace.permute.permute.permute", "meddlr.transforms.base.KspaceMaskTransform", "meddlr.transforms.base.KspaceMaskTransform.apply_kspace", "meddlr.get_mask", "numpy.allclose", "meddlr.transforms.base.KspaceMaskTransform", "meddlr.transforms.base.KspaceMaskTransform.apply_kspace", "meddlr.get_mask", "numpy.allclose", "test_mask.TestKspaceMaskTransform.assertRaises", "meddlr.transforms.base.KspaceMaskTransform", "torch.sum", "numpy.prod", "torch.sum", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask"], ["    ", "def", "test_basic", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test basic functionality.\"\"\"", "\n", "rho", "=", "0.1", "\n", "ky", "=", "20", "\n", "kz", "=", "20", "\n", "\n", "kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", "ky", "=", "ky", ",", "kz", "=", "kz", ",", "rand_func", "=", "\"rand\"", ")", "\n", "kspace", "=", "kspace", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "# B x Nc x H x W", "\n", "\n", "tfm", "=", "KspaceMaskTransform", "(", "rho", "=", "rho", ",", "seed", "=", "40", ")", "\n", "masked_kspace", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "masked_kspace", ")", "\n", "assert", "np", ".", "allclose", "(", "torch", ".", "sum", "(", "mask", ")", "/", "np", ".", "prod", "(", "mask", ".", "shape", ")", ",", "1", "-", "rho", ")", "\n", "\n", "tfm", "=", "KspaceMaskTransform", "(", "rho", "=", "rho", ",", "kind", "=", "\"gaussian\"", ",", "seed", "=", "40", ")", "\n", "masked_kspace", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "masked_kspace", ")", "\n", "assert", "np", ".", "allclose", "(", "torch", ".", "sum", "(", "mask", ")", "/", "np", ".", "prod", "(", "mask", ".", "shape", ")", ",", "1", "-", "rho", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "KspaceMaskTransform", "(", "rho", "=", "rho", ",", "seed", "=", "40", ",", "kind", "=", "\"invalid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_mask.TestKspaceMaskTransform.test_calib_size": [[35, 63], ["mock.generate_mock_mri_data", "kspace.permute.permute.permute", "meddlr.transforms.base.KspaceMaskTransform", "meddlr.transforms.base.KspaceMaskTransform.apply_kspace", "meddlr.get_mask", "torch.all", "meddlr.transforms.base.KspaceMaskTransform", "meddlr.transforms.base.KspaceMaskTransform.apply_kspace", "meddlr.get_mask", "torch.all", "slice", "slice", "slice", "slice"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask"], ["", "", "def", "test_calib_size", "(", "self", ")", ":", "\n", "        ", "rho", "=", "0.1", "\n", "ky", "=", "20", "\n", "kz", "=", "20", "\n", "csize", "=", "4", "\n", "\n", "kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", "ky", "=", "ky", ",", "kz", "=", "kz", ",", "rand_func", "=", "\"rand\"", ")", "\n", "kspace", "=", "kspace", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "# B x Nc x H x W", "\n", "\n", "tfm", "=", "KspaceMaskTransform", "(", "rho", "=", "rho", ",", "seed", "=", "40", ",", "calib_size", "=", "(", "csize", ",", "csize", ")", ")", "\n", "masked_kspace", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "masked_kspace", ")", "\n", "sl", "=", "(", "\n", "Ellipsis", ",", "\n", "slice", "(", "ky", "//", "2", "-", "csize", "//", "2", ",", "ky", "//", "2", "+", "csize", "//", "2", ")", ",", "\n", "slice", "(", "kz", "//", "2", "-", "csize", "//", "2", ",", "kz", "//", "2", "+", "csize", "//", "2", ")", ",", "\n", ")", "\n", "assert", "torch", ".", "all", "(", "mask", "[", "sl", "]", "==", "1", ")", "\n", "\n", "tfm", "=", "KspaceMaskTransform", "(", "rho", "=", "rho", ",", "kind", "=", "\"gaussian\"", ",", "seed", "=", "40", ",", "calib_size", "=", "(", "csize", ",", "csize", ")", ")", "\n", "masked_kspace", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "masked_kspace", ")", "\n", "sl", "=", "(", "\n", "Ellipsis", ",", "\n", "slice", "(", "ky", "//", "2", "-", "csize", "//", "2", ",", "ky", "//", "2", "+", "csize", "//", "2", ")", ",", "\n", "slice", "(", "kz", "//", "2", "-", "csize", "//", "2", ",", "kz", "//", "2", "+", "csize", "//", "2", ")", ",", "\n", ")", "\n", "assert", "torch", ".", "all", "(", "mask", "[", "sl", "]", "==", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_mask.TestKspaceMaskTransform.test_per_example": [[69, 84], ["mock.generate_mock_mri_data", "kspace.permute.permute.permute", "meddlr.transforms.base.KspaceMaskTransform", "meddlr.transforms.base.KspaceMaskTransform.apply_kspace", "meddlr.get_mask", "mask.view.view.view", "numpy.allclose", "torch.all", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask"], ["", "def", "test_per_example", "(", "self", ")", ":", "\n", "        ", "rho", "=", "0.1", "\n", "\n", "kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", "bsz", "=", "10", ",", "rand_func", "=", "\"rand\"", ")", "\n", "kspace", "=", "kspace", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "# B x Nc x H x W", "\n", "\n", "tfm", "=", "KspaceMaskTransform", "(", "rho", "=", "rho", ",", "per_example", "=", "True", ",", "seed", "=", "40", ")", "\n", "masked_kspace", "=", "tfm", ".", "apply_kspace", "(", "kspace", ")", "\n", "mask", "=", "cplx", ".", "get_mask", "(", "masked_kspace", ")", "\n", "\n", "# All masks should not be equal", "\n", "assert", "not", "torch", ".", "all", "(", "mask", "==", "mask", "[", "0", ":", "1", "]", ")", "\n", "\n", "mask", "=", "mask", ".", "view", "(", "(", "mask", ".", "shape", "[", "-", "1", "]", ",", "-", "1", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "torch", ".", "sum", "(", "mask", ",", "-", "1", ")", "/", "mask", ".", "shape", "[", "-", "1", "]", ",", "1", "-", "rho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_mask.TestKspaceMaskTransform.test_channels_last": [[85, 98], ["mock.generate_mock_mri_data", "kspace.permute", "meddlr.transforms.base.KspaceMaskTransform", "meddlr.transforms.base.KspaceMaskTransform.apply_kspace", "meddlr.transforms.base.KspaceMaskTransform.apply_kspace", "masked_kspace.permute.permute.permute", "torch.all"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.mock.generate_mock_mri_data", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace", "home.repos.pwc.inspect_result.ad12_meddlr.base.mask.KspaceMaskTransform.apply_kspace"], ["", "def", "test_channels_last", "(", "self", ")", ":", "\n", "        ", "rho", "=", "0.1", "\n", "ky", "=", "20", "\n", "kz", "=", "20", "\n", "\n", "kspace", ",", "_", ",", "_", "=", "generate_mock_mri_data", "(", "ky", "=", "ky", ",", "kz", "=", "kz", ",", "rand_func", "=", "\"rand\"", ")", "\n", "kspace_permuted", "=", "kspace", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "\n", "tfm", "=", "KspaceMaskTransform", "(", "rho", "=", "rho", ",", "seed", "=", "40", ")", "\n", "expected", "=", "tfm", ".", "apply_kspace", "(", "kspace_permuted", ",", "channels_last", "=", "False", ")", "\n", "masked_kspace", "=", "tfm", ".", "apply_kspace", "(", "kspace", ",", "channels_last", "=", "True", ")", "\n", "masked_kspace", "=", "masked_kspace", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "assert", "torch", ".", "all", "(", "masked_kspace", "==", "expected", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_spatial.TestAffineTransform.test_func": [[15, 27], ["torch.randn", "torchvision.affine", "meddlr.transforms.base.spatial.AffineTransform", "meddlr.transforms.base.spatial.AffineTransform.apply_image", "torch.all"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image"], ["    ", "def", "test_scheduler_basic", "(", "self", ")", ":", "\n", "        ", "iter_tracker", "=", "MockIterTracker", "(", ")", "\n", "affine", "=", "RandomAffine", "(", "angle", "=", "10", ",", "translate", "=", "1.0", ",", "scale", "=", "2.0", ")", "\n", "scheduler", "=", "WarmupTF", "(", "affine", ",", "warmup_iters", "=", "400", ",", "params", "=", "[", "\"angle\"", ",", "\"translate\"", "]", ")", "\n", "scheduler", ".", "get_iteration", "=", "iter_tracker", ".", "get_iter", "\n", "affine", ".", "register_schedulers", "(", "[", "scheduler", "]", ")", "\n", "\n", "iter_tracker", ".", "step", "(", "100", ")", "\n", "params", "=", "affine", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "assert", "params", "[", "\"angle\"", "]", "==", "2.5", "\n", "assert", "params", "[", "\"translate\"", "]", "==", "0.25", "\n", "assert", "params", "[", "\"scale\"", "]", "==", "2.0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_spatial.TestTranslationTransform.test_func": [[30, 54], ["torch.randn", "torchvision.affine", "meddlr.transforms.base.spatial.TranslationTransform", "meddlr.transforms.base.spatial.TranslationTransform.apply_image", "torch.all", "torch.all", "torch.all", "torchvision.affine", "meddlr.transforms.base.spatial.TranslationTransform", "meddlr.transforms.base.spatial.TranslationTransform.apply_image", "torch.all", "torch.all", "torch.all"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image"], ["affine", "=", "RandomAffine", "(", "p", "=", "1.0", ",", "angle", "=", "10", ",", "translate", "=", "1.0", ",", "scale", "=", "2.0", ")", "\n", "\n", "scheduler", "=", "WarmupTF", "(", "affine", ",", "warmup_iters", "=", "400", ",", "params", "=", "[", "\"p\"", "]", ")", "\n", "scheduler", ".", "get_iteration", "=", "iter_tracker", ".", "get_iter", "\n", "affine", ".", "register_schedulers", "(", "[", "scheduler", "]", ")", "\n", "\n", "iter_tracker", ".", "step", "(", "100", ")", "\n", "params", "=", "affine", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "assert", "all", "(", "v", "==", "0.25", "for", "v", "in", "p", ".", "values", "(", ")", ")", "\n", "\n", "# Different probability for each.", "\n", "iter_tracker", "=", "MockIterTracker", "(", ")", "\n", "affine", "=", "RandomAffine", "(", "\n", "p", "=", "{", "\"angle\"", ":", "1.0", ",", "\"translate\"", ":", "0.5", ",", "\"scale\"", ":", "0.2", "}", ",", "angle", "=", "10", ",", "translate", "=", "1.0", ",", "scale", "=", "2.0", "\n", ")", "\n", "p", "=", "affine", ".", "p", "\n", "assert", "p", "[", "\"angle\"", "]", "==", "1.0", "\n", "assert", "p", "[", "\"translate\"", "]", "==", "0.5", "\n", "assert", "p", "[", "\"scale\"", "]", "==", "0.2", "\n", "assert", "p", "[", "\"shear\"", "]", "==", "0", "\n", "\n", "scheduler", "=", "WarmupTF", "(", "affine", ",", "warmup_iters", "=", "500", ",", "params", "=", "[", "\"p\"", "]", ")", "\n", "scheduler", ".", "get_iteration", "=", "iter_tracker", ".", "get_iter", "\n", "affine", ".", "register_schedulers", "(", "[", "scheduler", "]", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_spatial.TestFlipTransform.test_func": [[57, 77], ["torch.randn", "torch.flip", "meddlr.transforms.base.spatial.FlipTransform", "meddlr.transforms.base.spatial.FlipTransform.apply_image", "torch.all", "torch.flip", "meddlr.transforms.base.spatial.FlipTransform", "meddlr.transforms.base.spatial.FlipTransform.apply_image", "torch.all", "torch.flip", "meddlr.transforms.base.spatial.FlipTransform", "meddlr.transforms.base.spatial.FlipTransform.apply_image", "torch.all"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image"], ["params", "=", "affine", ".", "_get_param_values", "(", "use_schedulers", "=", "True", ")", "\n", "p", "=", "params", "[", "\"p\"", "]", "\n", "assert", "np", ".", "allclose", "(", "p", "[", "\"angle\"", "]", ",", "0.2", ")", "\n", "assert", "np", ".", "allclose", "(", "p", "[", "\"translate\"", "]", ",", "0.1", ")", "\n", "assert", "np", ".", "allclose", "(", "p", "[", "\"scale\"", "]", ",", "0.04", ")", "\n", "assert", "np", ".", "allclose", "(", "p", "[", "\"shear\"", "]", ",", "0.0", ")", "\n", "\n", "", "def", "test_multi_arg_param_translate", "(", "self", ")", ":", "\n", "        ", "h", ",", "w", "=", "100", ",", "100", "\n", "img", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "h", ",", "w", ")", "\n", "\n", "t_h", ",", "t_w", "=", "0.1", ",", "0.8", "\n", "affine", "=", "RandomAffine", "(", "translate", "=", "(", "t_h", ",", "t_w", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_translate", ",", "w_translate", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n", "h_translate", ".", "append", "(", "h_t", ")", "\n", "w_translate", ".", "append", "(", "w_t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_spatial.TestFlipTransform.test_inverse": [[78, 85], ["torch.randn", "meddlr.transforms.base.spatial.FlipTransform", "meddlr.transforms.base.spatial.FlipTransform.inverse().apply_image", "torch.all", "meddlr.transforms.base.spatial.FlipTransform.apply_image", "meddlr.transforms.base.spatial.FlipTransform.inverse"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.inverse"], ["", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "h_translate", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "h_translate", ")", "\n", "assert", "any", "(", "x", "<", "0", "for", "x", "in", "w_translate", ")", "and", "any", "(", "x", ">", "0", "for", "x", "in", "w_translate", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "h", "*", "t_h", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "abs", "(", "x", ")", "<=", "w", "*", "t_w", "for", "x", "in", "w_translate", ")", "\n", "\n", "# Fixed range of values.", "\n", "t_h1", ",", "t_h2", ",", "t_w1", ",", "t_w2", "=", "0.1", ",", "0.2", ",", "-", "0.8", ",", "-", "0.6", "\n", "affine", "=", "RandomAffine", "(", "translate", "=", "(", "(", "t_h1", ",", "t_h2", ")", ",", "(", "t_w1", ",", "t_w2", ")", ")", ",", "p", "=", "1.0", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_spatial.TestRot90Transform.test_func": [[88, 97], ["torch.randn", "torch.rot90", "meddlr.transforms.base.spatial.Rot90Transform", "meddlr.transforms.base.spatial.Rot90Transform.apply_image", "torch.all"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image"], ["for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n", "h_translate", ".", "append", "(", "h_t", ")", "\n", "w_translate", ".", "append", "(", "w_t", ")", "\n", "\n", "", "assert", "all", "(", "x", ">", "0", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "x", "<", "0", "for", "x", "in", "w_translate", ")", "\n", "assert", "all", "(", "h", "*", "t_h1", "<=", "x", "<=", "h", "*", "t_h2", "for", "x", "in", "h_translate", ")", "\n", "assert", "all", "(", "w", "*", "t_w1", "<=", "x", "<=", "w", "*", "t_w2", "for", "x", "in", "w_translate", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.base.test_spatial.TestRot90Transform.test_inverse": [[98, 106], ["torch.randn", "meddlr.transforms.base.spatial.Rot90Transform", "meddlr.transforms.base.spatial.Rot90Transform.inverse().apply_image", "torch.all", "meddlr.transforms.base.spatial.Rot90Transform.apply_image", "meddlr.transforms.base.spatial.Rot90Transform.inverse"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.apply_image", "home.repos.pwc.inspect_result.ad12_meddlr.base.spatial.Rot90Transform.inverse"], ["\n", "# Mix of range and single value", "\n", "t_h", ",", "t_w1", ",", "t_w2", "=", "0.1", ",", "-", "0.8", ",", "-", "0.6", "\n", "affine", "=", "RandomAffine", "(", "translate", "=", "(", "t_h", ",", "(", "t_w1", ",", "t_w2", ")", ")", ",", "p", "=", "1.0", ")", "\n", "\n", "h_translate", ",", "w_translate", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "100", ")", ":", "\n", "            ", "tfm", ":", "AffineTransform", "=", "affine", ".", "get_transform", "(", "img", ")", "\n", "h_t", ",", "w_t", "=", "tuple", "(", "tfm", ".", "translate", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.__init__": [[16, 25], ["torchmetrics.collections.MetricCollection.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "metrics", ":", "Union", "[", "Metric", ",", "Sequence", "[", "Metric", "]", ",", "Dict", "[", "str", ",", "Metric", "]", "]", ",", "\n", "*", "additional_metrics", ":", "Metric", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "postfix", ":", "Optional", "[", "str", "]", "=", "None", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "metrics", ",", "*", "additional_metrics", ",", "prefix", "=", "prefix", ",", "postfix", "=", "postfix", ")", "\n", "self", ".", "_is_data_stale", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.scans": [[26, 28], ["list", "collection.MetricCollection._scan_data.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "def", "scans", "(", "self", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "return", "list", "(", "self", ".", "_scan_data", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.scan_summary": [[29, 44], ["scan_data.mean", "delimiter.join", "scan_data.mean.index.tolist"], "methods", ["None"], ["", "def", "scan_summary", "(", "self", ",", "scan_id", ",", "delimiter", ":", "str", "=", "\", \"", ")", "->", "str", ":", "\n", "        ", "\"\"\"Get summary of results for a scan.\n        Args:\n            scan_id: Scan id for which to summarize results.\n            delimiter (`str`, optional): Delimiter between different metrics.\n        Returns:\n            str: A summary of metrics for the scan. Values are averaged across\n                all categories.\n        \"\"\"", "\n", "scan_data", "=", "self", ".", "_scan_data", "[", "scan_id", "]", "\n", "avg_data", "=", "scan_data", ".", "mean", "(", "axis", "=", "1", ")", "\n", "\n", "strs", "=", "[", "\"{}: {:0.3f}\"", ".", "format", "(", "n", ",", "avg_data", "[", "n", "]", ")", "for", "n", "in", "avg_data", ".", "index", ".", "tolist", "(", ")", "]", "\n", "\n", "return", "delimiter", ".", "join", "(", "strs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.to_pandas": [[45, 54], ["collection.MetricCollection.items", "pandas.concat", "metric.to_pandas", "frames.append"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas"], ["", "def", "to_pandas", "(", "self", ",", "sync_dist", ":", "bool", "=", "True", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "frames", "=", "[", "]", "\n", "metric", ":", "Metric", "\n", "for", "name", ",", "metric", "in", "self", ".", "items", "(", ")", ":", "\n", "            ", "df", ":", "pd", ".", "DataFrame", "=", "metric", ".", "to_pandas", "(", "sync_dist", "=", "sync_dist", ")", "\n", "df", "[", "\"Metric\"", "]", "=", "name", "\n", "frames", ".", "append", "(", "df", ")", "\n", "\n", "", "return", "pd", ".", "concat", "(", "frames", ",", "ignore_index", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.to_dict": [[55, 63], ["collection.MetricCollection.to_pandas", "df.drop.drop.melt", "df.drop.drop.drop", "df.drop.drop.groupby().mean", "len", "df.drop.groupby().mean.to_dict", "numpy.unique", "df.drop.drop.groupby"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict"], ["", "def", "to_dict", "(", "self", ",", "group_by", "=", "\"Metric\"", ",", "sync_dist", ":", "bool", "=", "True", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "df", "=", "self", ".", "to_pandas", "(", "sync_dist", "=", "sync_dist", ")", "\n", "df", "=", "df", ".", "melt", "(", "id_vars", "=", "[", "\"Metric\"", ",", "\"id\"", "]", ",", "var_name", "=", "\"category\"", ",", "value_name", "=", "\"value\"", ")", "\n", "if", "len", "(", "np", ".", "unique", "(", "df", "[", "\"category\"", "]", ")", ")", ">", "1", ":", "\n", "            ", "df", "[", "\"Metric\"", "]", "=", "df", "[", "\"Metric\"", "]", "+", "\"/\"", "+", "df", "[", "\"category\"", "]", "\n", "", "df", "=", "df", ".", "drop", "(", "columns", "=", "\"category\"", ")", "\n", "values", "=", "df", ".", "groupby", "(", "by", "=", "group_by", ")", ".", "mean", "(", ")", "\n", "return", "values", ".", "to_dict", "(", ")", "[", "\"value\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary": [[64, 78], ["collection.MetricCollection.to_pandas", "df.drop.drop.groupby", "df.drop.drop.mean().applymap", "df.drop.drop.std().applymap", "df.drop.drop.drop", "tabulate.tabulate", "df.drop.drop.mean", "df.drop.drop.std"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas"], ["", "def", "summary", "(", "self", ",", "sync_dist", ":", "bool", "=", "True", ")", "->", "str", ":", "\n", "        ", "\"\"\"Get summary of results overall scans.\n        Returns:\n            str: Tabulated summary. Rows=metrics. Columns=classes.\n        \"\"\"", "\n", "df", "=", "self", ".", "to_pandas", "(", "sync_dist", "=", "sync_dist", ")", "\n", "if", "\"id\"", "in", "df", ":", "\n", "            ", "df", "=", "df", ".", "drop", "(", "columns", "=", "\"id\"", ")", "\n", "", "df", "=", "df", ".", "groupby", "(", "by", "=", "\"Metric\"", ")", "\n", "\n", "mean", "=", "df", ".", "mean", "(", ")", ".", "applymap", "(", "lambda", "x", ":", "\"{:0.3f}\"", ".", "format", "(", "x", ")", ")", "\n", "std", "=", "df", ".", "std", "(", ")", ".", "applymap", "(", "lambda", "x", ":", "\"{:0.3f}\"", ".", "format", "(", "x", ")", ")", "\n", "df", "=", "mean", "+", "\" (\"", "+", "std", "+", "\")\"", "\n", "return", "tabulate", ".", "tabulate", "(", "df", ",", "headers", "=", "df", ".", "columns", ")", "+", "\"\\n\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.ids": [[79, 85], ["set", "collection.MetricCollection.items", "set", "[].to_numpy", "metric.to_pandas"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_numpy", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas"], ["", "def", "ids", "(", "self", ",", "sync_dist", "=", "True", ")", "->", "Set", "[", "str", "]", ":", "\n", "        ", "_ids", "=", "set", "(", ")", "\n", "metric", ":", "Metric", "\n", "for", "_", ",", "metric", "in", "self", ".", "items", "(", ")", ":", "\n", "            ", "_ids", "|=", "set", "(", "metric", ".", "to_pandas", "(", "sync_dist", "=", "sync_dist", ")", "[", "\"id\"", "]", ".", "to_numpy", "(", ")", ")", "\n", "", "return", "_ids", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.build.build_metrics": [[62, 90], ["meddlr.metrics.collection.MetricCollection", "inspect.signature", "copy.deepcopy", "copy.deepcopy.update", "klass", "_BUILTIN_METRICS.keys", "ValueError", "copy.deepcopy.keys", "klass_kwargs.keys", "logger.warning", "fmt.format", "kwargs.items", "_BUILTIN_METRICS.keys"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["\n", "# Backwards compatibility with pattern-only initialization.", "\n", "", "if", "isinstance", "(", "initializers", ",", "Sequence", ")", "and", "not", "any", "(", "isinstance", "(", "x", ",", "Dict", ")", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "assert", "len", "(", "initializers", ")", "%", "2", "==", "0", ",", "\"Sequence of regex_to_init must be even\"", "\n", "initializers", "=", "[", "\n", "{", "_pattern_kwd", ":", "k", ",", "_init_kwd", ":", "v", "}", "for", "k", ",", "v", "in", "zip", "(", "initializers", "[", ":", ":", "2", "]", ",", "initializers", "[", "1", ":", ":", "2", "]", ")", "\n", "]", "\n", "\n", "# Convert string values to python literals.", "\n", "", "initializers", "=", "_to_literal", "(", "initializers", ")", "\n", "\n", "if", "not", "all", "(", "\n", "isinstance", "(", "x", ",", "Dict", ")", "or", "(", "isinstance", "(", "x", ",", "Sequence", ")", "and", "len", "(", "x", ")", "==", "2", ")", "for", "x", "in", "initializers", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"All initializers must either be a dict or sequence of 2 elements \"", "\n", "\"(pattern, initializer). Got:\\n\\t{}\"", ".", "format", "(", "initializers", ")", "\n", ")", "\n", "\n", "", "initializers", ":", "List", "[", "Dict", "]", "=", "[", "\n", "{", "_pattern_kwd", ":", "x", "[", "0", "]", ",", "_init_kwd", ":", "x", "[", "1", "]", "}", "if", "isinstance", "(", "x", ",", "Sequence", ")", "else", "x", "\n", "for", "x", "in", "initializers", "\n", "]", "\n", "matched_patterns", "=", "{", "}", "\n", "for", "init_cfg", "in", "initializers", ":", "\n", "        ", "pattern", "=", "init_cfg", ".", "pop", "(", "_pattern_kwd", ",", "None", ")", "\n", "if", "pattern", "is", "None", ":", "\n", "            ", "pattern", "=", "(", "\".*\"", ",", ")", "\n", "", "elif", "not", "isinstance", "(", "pattern", ",", "Sequence", ")", "or", "isinstance", "(", "pattern", ",", "str", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.DSC.__init__": [[21, 38], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.DSC.func": [[40, 42], ["meddlr.dice_score"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg.dice_score"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "dice_score", "(", "y_pred", "=", "preds", ",", "y_true", "=", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.CV.__init__": [[57, 74], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.CV.func": [[76, 78], ["meddlr.coefficient_variation"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg.coefficient_variation"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "coefficient_variation", "(", "y_pred", "=", "preds", ",", "y_true", "=", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.VOE.__init__": [[90, 107], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.VOE.func": [[109, 111], ["meddlr.volumetric_overlap_error"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.sem_seg.volumetric_overlap_error"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "volumetric_overlap_error", "(", "y_pred", "=", "preds", ",", "y_true", "=", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.ASSD.__init__": [[128, 154], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "connectivity", ":", "int", "=", "1", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            connectivity (int): The neighbourhood/connectivity considered when determining\n                the surface of the binary objects. If in doubt, leave it as it is.\n            channel_names (Sequence[str]): Category names corresponding to the channels.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "self", ".", "connectivity", "=", "connectivity", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.ASSD.func": [[155, 158], ["meddlr.assd"], "methods", ["None"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ",", "spacing", "=", "None", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "assd", "(", "\n", "y_pred", "=", "preds", ",", "y_true", "=", "targets", ",", "spacing", "=", "spacing", ",", "connectivity", "=", "self", ".", "connectivity", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.sem_seg.ASSD.update": [[160, 162], ["super().update"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "def", "update", "(", "self", ",", "preds", ",", "targets", ",", "spacing", "=", "None", ",", "ids", "=", "None", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "update", "(", "preds", ",", "targets", ",", "spacing", "=", "spacing", ",", "ids", "=", "ids", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.__init__": [[42, 67], ["torchmetrics.metric.Metric.__init__", "metric.Metric.add_state", "metric.Metric.add_state", "itertools.chain"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "units", ":", "str", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "units", "=", "units", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "channel_names", "=", "channel_names", "\n", "self", ".", "_update_kwargs_aliases", "=", "{", "}", "\n", "\n", "# Identifiers for the examples that are seen.", "\n", "self", ".", "add_state", "(", "\"ids\"", ",", "default", "=", "[", "]", ",", "dist_reduce_fx", "=", "lambda", "x", ":", "itertools", ".", "chain", "(", "*", "x", ")", ")", "\n", "self", ".", "add_state", "(", "\"values\"", ",", "default", "=", "[", "]", ",", "dist_reduce_fx", "=", "\"cat\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.func": [[68, 76], ["None"], "methods", ["None"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ",", "*", "args", ",", "**", "kwargs", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"Computes metrics for each element in the batch.\n\n        Returns:\n            torch.Tensor: A torch Tensor with first dimension being\n                batch dimension (``Bx...``).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update": [[77, 83], ["metric.Metric.func", "metric.Metric.values.append", "metric.Metric._add_ids", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric._add_ids"], ["", "def", "update", "(", "self", ",", "preds", ",", "targets", ",", "*", "args", ",", "ids", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "preds", ".", "shape", "==", "targets", ".", "shape", "\n", "\n", "values", ":", "torch", ".", "Tensor", "=", "self", ".", "func", "(", "preds", ",", "targets", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "values", ".", "append", "(", "values", ")", "\n", "self", ".", "_add_ids", "(", "ids", "=", "ids", ",", "num_samples", "=", "len", "(", "values", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric._generate_ids": [[84, 89], ["sum", "meddlr.utils.comm.get_rank", "len", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank"], ["", "def", "_generate_ids", "(", "self", ",", "num_samples", ")", ":", "\n", "        ", "id_start", "=", "sum", "(", "len", "(", "x", ")", "for", "x", "in", "self", ".", "values", ")", "\n", "rank", "=", "comm", ".", "get_rank", "(", ")", "\n", "ids", "=", "[", "f\"{rank}-{id_start + idx}\"", "for", "idx", "in", "range", "(", "num_samples", ")", "]", "\n", "return", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric._add_ids": [[90, 94], ["metric.Metric.ids.extend", "metric.Metric._generate_ids"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric._generate_ids"], ["", "def", "_add_ids", "(", "self", ",", "ids", ",", "num_samples", ")", ":", "\n", "        ", "if", "ids", "is", "None", ":", "\n", "            ", "ids", "=", "self", ".", "_generate_ids", "(", "num_samples", ")", "\n", "", "self", ".", "ids", ".", "extend", "(", "ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.compute": [[95, 99], ["torchmetrics.utilities.reduce", "torch.cat"], "methods", ["None"], ["", "def", "compute", "(", "self", ",", "reduction", "=", "None", ")", ":", "\n", "        ", "if", "reduction", "is", "None", ":", "\n", "            ", "reduction", "=", "self", ".", "reduction", "\n", "", "return", "reduce", "(", "torch", ".", "cat", "(", "self", ".", "values", ")", ",", "reduction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas": [[100, 102], ["pandas.DataFrame.from_dict", "metric.Metric.to_dict"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.from_dict", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict"], ["", "def", "to_pandas", "(", "self", ",", "sync_dist", ":", "bool", "=", "True", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "return", "pd", ".", "DataFrame", ".", "from_dict", "(", "self", ".", "to_dict", "(", "sync_dist", "=", "sync_dist", ",", "device", "=", "\"cpu\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_dict": [[103, 110], ["metric.Metric._to_dict", "metric.Metric.sync_context", "metric.Metric._to_dict"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric._to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric._to_dict"], ["", "def", "to_dict", "(", "self", ",", "sync_dist", ":", "bool", "=", "True", ",", "device", "=", "None", ")", ":", "\n", "        ", "if", "sync_dist", ":", "\n", "            ", "with", "self", ".", "sync_context", "(", ")", ":", "\n", "                ", "data", "=", "self", ".", "_to_dict", "(", "device", "=", "device", ")", "\n", "", "", "else", ":", "\n", "            ", "data", "=", "self", ".", "_to_dict", "(", "device", "=", "device", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric._to_dict": [[111, 126], ["data.update", "isinstance", "torch.cat", "values.to.to.to", "range", "enumerate"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to"], ["", "def", "_to_dict", "(", "self", ",", "device", "=", "None", ")", ":", "\n", "        ", "if", "not", "self", ".", "values", ":", "\n", "            ", "return", "{", "\"id\"", ":", "self", ".", "ids", "}", "\n", "\n", "", "values", "=", "torch", ".", "cat", "(", "self", ".", "values", ")", "if", "isinstance", "(", "self", ".", "values", ",", "list", ")", "else", "self", ".", "values", "\n", "if", "device", "is", "not", "None", ":", "\n", "            ", "values", "=", "values", ".", "to", "(", "device", ")", "\n", "", "channel_names", "=", "(", "\n", "self", ".", "channel_names", "\n", "if", "self", ".", "channel_names", "\n", "else", "[", "f\"channel_{idx}\"", "for", "idx", "in", "range", "(", "values", ".", "shape", "[", "1", "]", ")", "]", "\n", ")", "\n", "data", "=", "{", "\"id\"", ":", "self", ".", "ids", "}", "\n", "data", ".", "update", "(", "{", "name", ":", "values", "[", ":", ",", "idx", "]", "for", "idx", ",", "name", "in", "enumerate", "(", "channel_names", ")", "}", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric._filter_kwargs": [[127, 143], ["metric.Metric._filter_kwargs"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric._filter_kwargs"], ["", "def", "_filter_kwargs", "(", "self", ",", "**", "kwargs", ":", "Any", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"filter kwargs such that they match the update signature of the metric\"\"\"", "\n", "if", "self", ".", "_update_kwargs_aliases", ":", "\n", "            ", "filtered_kwargs", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "}", "\n", "aliases", "=", "{", "}", "\n", "for", "alias", "in", "self", ".", "_update_kwargs_aliases", ":", "\n", "                ", "if", "alias", "not", "in", "kwargs", "or", "self", ".", "_update_kwargs_aliases", "[", "alias", "]", "in", "aliases", ":", "\n", "                    ", "continue", "\n", "", "aliases", "[", "self", ".", "_update_kwargs_aliases", "[", "alias", "]", "]", "=", "kwargs", ".", "pop", "(", "alias", ")", "\n", "", "filtered_kwargs", ".", "update", "(", "aliases", ")", "\n", "", "else", ":", "\n", "            ", "filtered_kwargs", "=", "kwargs", "\n", "\n", "# Use filtering from torch 0.6.0 where kwargs are preserved and passed along.", "\n", "", "filtered_kwargs", "=", "_filter_kwargs", "(", "self", ".", "_update_signature", ",", "**", "filtered_kwargs", ")", "\n", "return", "filtered_kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.register_update_aliases": [[144, 161], ["tuple", "metric.Metric._update_kwargs_aliases.update", "len", "ValueError", "kwargs.values", "kwargs.items", "_sign_params.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "register_update_aliases", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Register aliases for keyword arguments when calling update.\"\"\"", "\n", "# filter all parameters based on update signature except those of", "\n", "# type VAR_POSITIONAL (*args) and VAR_KEYWORD (**kwargs)", "\n", "_params", "=", "(", "inspect", ".", "Parameter", ".", "VAR_POSITIONAL", ",", "inspect", ".", "Parameter", ".", "VAR_KEYWORD", ")", "\n", "_sign_params", "=", "self", ".", "_update_signature", ".", "parameters", "\n", "supported_kwargs", "=", "tuple", "(", "\n", "k", "for", "k", "in", "_sign_params", ".", "keys", "(", ")", "if", "_sign_params", "[", "k", "]", ".", "kind", "not", "in", "_params", "\n", ")", "\n", "unsupported_kwargs", "=", "[", "v", "for", "v", "in", "kwargs", ".", "values", "(", ")", "if", "v", "not", "in", "supported_kwargs", "]", "\n", "if", "len", "(", "unsupported_kwargs", ")", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Found unsupported kwargs '{unsupported_kwargs}'. \"", "\n", "f\"Supported keyword arguments include:{supported_kwargs}\"", "\n", ")", "\n", "", "aliases", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "}", "\n", "self", ".", "_update_kwargs_aliases", ".", "update", "(", "aliases", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.name": [[162, 164], ["type"], "methods", ["None"], ["", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "type", "(", "self", ")", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.display_name": [[165, 169], ["metric.Metric.name"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.name"], ["", "def", "display_name", "(", "self", ")", ":", "\n", "        ", "\"\"\"Name to use for pretty printing and display purposes.\"\"\"", "\n", "name", "=", "self", ".", "name", "(", ")", "\n", "return", "\"{} ({})\"", ".", "format", "(", "name", ",", "self", ".", "units", ")", "if", "self", ".", "units", "else", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric._filter_kwargs": [[171, 186], ["kwargs.items", "_sign_params.keys"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "def", "_filter_kwargs", "(", "sig", ",", "**", "kwargs", ":", "Any", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "# filter all parameters based on update signature except those of", "\n", "# type VAR_POSITIONAL (*args) and VAR_KEYWORD (**kwargs)", "\n", "    ", "_params", "=", "(", "inspect", ".", "Parameter", ".", "VAR_POSITIONAL", ",", "inspect", ".", "Parameter", ".", "VAR_KEYWORD", ")", "\n", "_sign_params", "=", "sig", ".", "parameters", "\n", "filtered_kwargs", "=", "{", "\n", "k", ":", "v", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "\n", "if", "(", "k", "in", "_sign_params", ".", "keys", "(", ")", "and", "_sign_params", "[", "k", "]", ".", "kind", "not", "in", "_params", ")", "\n", "}", "\n", "\n", "# if no kwargs filtered, return al kwargs as default", "\n", "if", "not", "filtered_kwargs", ":", "\n", "        ", "filtered_kwargs", "=", "kwargs", "\n", "", "return", "filtered_kwargs", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.PSNR.__init__": [[55, 76], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"dB\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.PSNR.func": [[77, 79], ["meddlr.psnr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.psnr"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "psnr", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.MAE.__init__": [[103, 124], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.MAE.func": [[125, 127], ["meddlr.mae"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.mae"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "mae", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.MSE.__init__": [[151, 172], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.MSE.func": [[173, 175], ["meddlr.mse"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.mse"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "mse", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.NRMSE.__init__": [[199, 220], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.NRMSE.func": [[221, 223], ["meddlr.nrmse"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.nrmse"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "nrmse", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.RMSE.__init__": [[250, 271], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.RMSE.func": [[272, 274], ["meddlr.rmse"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.rmse"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "rmse", "(", "preds", ",", "targets", ",", "im_type", "=", "self", ".", "im_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.SSIM.__init__": [[298, 320], ["meddlr.metrics.metric.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "method", ":", "str", "=", "\"wang\"", ",", "\n", "im_type", ":", "str", "=", "\"magnitude\"", ",", "\n", "channel_names", ":", "Sequence", "[", "str", "]", "=", "None", ",", "\n", "reduction", "=", "\"none\"", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "bool", "=", "None", ",", "\n", "dist_sync_fn", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "channel_names", "=", "channel_names", ",", "\n", "units", "=", "\"\"", ",", "\n", "reduction", "=", "reduction", ",", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "self", ".", "method", "=", "method", "\n", "self", ".", "im_type", "=", "im_type", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.SSIM.func": [[321, 327], ["meddlr.ssim"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.functional.image.ssim"], ["", "def", "func", "(", "self", ",", "preds", ",", "targets", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "mF", ".", "ssim", "(", "\n", "preds", ",", "\n", "targets", ",", "\n", "method", "=", "self", ".", "method", ",", "\n", "im_type", "=", "self", ".", "im_type", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_mse": [[330, 344], ["meddlr.utils.deprecated.deprecated", "meddlr.ops.complex.is_complex", "torch.mean", "torch.view_as_real", "torch.view_as_real", "squared_err.view", "torch.abs", "meddlr.ops.complex.abs", "meddlr.ops.complex.abs", "meddlr.ops.complex.abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"metrics.functional.mse\"", ")", "\n", "def", "compute_mse", "(", "ref", ":", "torch", ".", "Tensor", ",", "x", ":", "torch", ".", "Tensor", ",", "is_batch", "=", "False", ",", "magnitude", "=", "False", ")", ":", "\n", "    ", "if", "cplx", ".", "is_complex", "(", "ref", ")", ":", "\n", "        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "if", "magnitude", ":", "\n", "        ", "squared_err", "=", "torch", ".", "abs", "(", "cplx", ".", "abs", "(", "x", ")", "-", "cplx", ".", "abs", "(", "ref", ")", ")", "**", "2", "\n", "", "else", ":", "\n", "        ", "squared_err", "=", "cplx", ".", "abs", "(", "x", "-", "ref", ")", "**", "2", "\n", "", "shape", "=", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "if", "is_batch", "else", "-", "1", "\n", "return", "torch", ".", "mean", "(", "squared_err", ".", "view", "(", "shape", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_l2": [[346, 359], ["meddlr.ops.complex.is_complex", "torch.sqrt", "torch.view_as_real", "torch.view_as_real", "image.compute_mse"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_mse"], ["", "def", "compute_l2", "(", "ref", ":", "torch", ".", "Tensor", ",", "x", ":", "torch", ".", "Tensor", ",", "is_batch", "=", "False", ",", "magnitude", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        ref (torch.Tensor): The target. Shape (...)x2\n        x (torch.Tensor): The prediction. Same shape as `ref`.\n    \"\"\"", "\n", "if", "cplx", ".", "is_complex", "(", "ref", ")", ":", "\n", "        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "return", "torch", ".", "sqrt", "(", "compute_mse", "(", "ref", ",", "x", ",", "is_batch", "=", "is_batch", ",", "magnitude", "=", "magnitude", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_psnr": [[361, 382], ["meddlr.utils.deprecated.deprecated", "meddlr.ops.complex.is_complex", "image.compute_l2", "torch.view_as_real", "torch.view_as_real", "torch.log10", "meddlr.ops.complex.abs().max", "meddlr.ops.complex.abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_l2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"metrics.functional.psnr\"", ")", "\n", "def", "compute_psnr", "(", "ref", ":", "torch", ".", "Tensor", ",", "x", ":", "torch", ".", "Tensor", ",", "is_batch", "=", "False", ",", "magnitude", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute peak to signal to noise ratio of magnitude image.\n\n    Args:\n        ref (torch.Tensor): The target. Shape (...)x2\n        x (torch.Tensor): The prediction. Same shape as `ref`.\n\n    Returns:\n        Tensor: Scalar in db\n    \"\"\"", "\n", "if", "cplx", ".", "is_complex", "(", "ref", ")", ":", "\n", "        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "not", "is_batch", ",", "\"is_batch not supported\"", "\n", "l2", "=", "compute_l2", "(", "ref", ",", "x", ",", "magnitude", "=", "magnitude", ",", "is_batch", "=", "False", ")", "\n", "# shape = (x.shape[0], -1) if is_batch else -1", "\n", "return", "20", "*", "torch", ".", "log10", "(", "cplx", ".", "abs", "(", "ref", ")", ".", "max", "(", ")", "/", "l2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_nrmse": [[384, 404], ["meddlr.utils.deprecated.deprecated", "meddlr.ops.complex.is_complex", "image.compute_l2", "torch.sqrt", "torch.view_as_real", "torch.view_as_real", "torch.mean", "meddlr.ops.complex.abs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_l2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"metrics.functional.nrmse\"", ")", "\n", "def", "compute_nrmse", "(", "ref", ",", "x", ",", "is_batch", "=", "False", ",", "magnitude", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute normalized root mean square error.\n    The norm of reference is used to normalize the metric.\n\n    Args:\n        ref (torch.Tensor): The target. Shape (...)x2\n        x (torch.Tensor): The prediction. Same shape as `ref`.\n    \"\"\"", "\n", "if", "cplx", ".", "is_complex", "(", "ref", ")", ":", "\n", "        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "rmse", "=", "compute_l2", "(", "ref", ",", "x", ",", "is_batch", "=", "is_batch", ",", "magnitude", "=", "magnitude", ")", "\n", "shape", "=", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "if", "is_batch", "else", "-", "1", "\n", "norm", "=", "torch", ".", "sqrt", "(", "torch", ".", "mean", "(", "(", "cplx", ".", "abs", "(", "ref", ")", "**", "2", ")", ".", "view", "(", "shape", ")", ",", "dim", "=", "-", "1", ")", ")", "\n", "\n", "return", "rmse", "/", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_ssim": [[406, 479], ["meddlr.utils.deprecated.deprecated", "kwargs.pop", "kwargs.pop", "kwargs.pop", "meddlr.ops.complex.is_complex", "x.contiguous.squeeze().numpy", "ref.contiguous.squeeze().numpy", "skimage.metrics.structural_similarity", "torch.view_as_real", "torch.view_as_real", "meddlr.ops.complex.abs", "meddlr.ops.complex.abs", "x.contiguous.is_contiguous", "x.contiguous.contiguous", "ref.contiguous.is_contiguous", "ref.contiguous.contiguous", "x.contiguous.squeeze", "ref.contiguous.squeeze", "ref.contiguous.max", "ref.contiguous.min", "ref.contiguous.max", "x.contiguous.max", "x.contiguous.min", "x.contiguous.max"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.deprecated.deprecated", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "@", "deprecated", "(", "vremove", "=", "\"0.1.0\"", ",", "replacement", "=", "\"metrics.functional.ssim\"", ")", "\n", "def", "compute_ssim", "(", "\n", "ref", ":", "torch", ".", "Tensor", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "multichannel", ":", "bool", "=", "False", ",", "\n", "data_range", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Compute structural similarity index metric. Does not preserve autograd.\n\n    Based on implementation of Wang et. al. [1]_\n\n    The image is first converted to magnitude image and normalized\n    before the metric is computed.\n\n    Args:\n        ref (torch.Tensor): The target. Shape (...)x2\n        x (torch.Tensor): The prediction. Same shape as `ref`.\n        multichannel (bool, optional): If `True`, computes ssim for real and\n            imaginary channels separately and then averages the two.\n        data_range(float, optional): The data range of the input image\n        (distance between minimum and maximum possible values). By default,\n        this is estimated from the image data-type.\n\n    References:\n    .. [1] Wang, Z., Bovik, A. C., Sheikh, H. R., & Simoncelli, E. P.\n       (2004). Image quality assessment: From error visibility to\n       structural similarity. IEEE Transactions on Image Processing,\n       13, 600-612.\n       https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf,\n       :DOI:`10.1109/TIP.2003.819861`\n    \"\"\"", "\n", "gaussian_weights", "=", "kwargs", ".", "pop", "(", "\"gaussian_weights\"", ",", "True", ")", "\n", "sigma", "=", "kwargs", ".", "pop", "(", "\"sigma\"", ",", "1.5", ")", "\n", "use_sample_covariance", "=", "kwargs", ".", "pop", "(", "\"use_sample_covariance\"", ",", "False", ")", "\n", "\n", "if", "cplx", ".", "is_complex", "(", "ref", ")", ":", "\n", "        ", "ref", "=", "torch", ".", "view_as_real", "(", "ref", ")", "\n", "x", "=", "torch", ".", "view_as_real", "(", "x", ")", "\n", "\n", "", "assert", "ref", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "\n", "if", "not", "multichannel", ":", "\n", "        ", "ref", "=", "cplx", ".", "abs", "(", "ref", ")", "\n", "x", "=", "cplx", ".", "abs", "(", "x", ")", "\n", "\n", "", "if", "not", "x", ".", "is_contiguous", "(", ")", ":", "\n", "        ", "x", "=", "x", ".", "contiguous", "(", ")", "\n", "", "if", "not", "ref", ".", "is_contiguous", "(", ")", ":", "\n", "        ", "ref", "=", "ref", ".", "contiguous", "(", ")", "\n", "\n", "", "x", "=", "x", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", "\n", "ref", "=", "ref", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "data_range", "in", "(", "\"range\"", ",", "\"ref-range\"", ")", ":", "\n", "        ", "data_range", "=", "ref", ".", "max", "(", ")", "-", "ref", ".", "min", "(", ")", "\n", "", "elif", "data_range", "in", "(", "\"ref-maxval\"", ",", "\"maxval\"", ")", ":", "\n", "        ", "data_range", "=", "ref", ".", "max", "(", ")", "\n", "", "elif", "data_range", "==", "\"x-range\"", ":", "\n", "        ", "data_range", "=", "x", ".", "max", "(", ")", "-", "x", ".", "min", "(", ")", "\n", "", "elif", "data_range", "==", "\"x-maxval\"", ":", "\n", "        ", "data_range", "=", "x", ".", "max", "(", ")", "\n", "\n", "", "return", "structural_similarity", "(", "\n", "ref", ",", "\n", "x", ",", "\n", "data_range", "=", "data_range", ",", "\n", "gaussian_weights", "=", "gaussian_weights", ",", "\n", "sigma", "=", "sigma", ",", "\n", "use_sample_covariance", "=", "use_sample_covariance", ",", "\n", "multichannel", "=", "multichannel", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.image.compute_vifp_mscale": [[482, 568], ["numpy.squeeze", "numpy.squeeze", "range", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real", "meddlr.ops.complex.is_complex", "meddlr.ops.complex.is_complex_as_real", "scp.ndimage.gaussian_filter.numpy", "scp.ndimage.gaussian_filter.numpy", "scp.ndimage.gaussian_filter.max", "scipy.ndimage.gaussian_filter", "scipy.ndimage.gaussian_filter", "numpy.sum", "numpy.sum", "tuple", "scipy.ndimage.gaussian_filter", "scipy.ndimage.gaussian_filter", "scipy.ndimage.gaussian_filter", "scipy.ndimage.gaussian_filter", "scipy.ndimage.gaussian_filter", "numpy.log10", "numpy.log10", "slice", "slice"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real"], ["", "def", "compute_vifp_mscale", "(", "\n", "ref", ":", "torch", ".", "Tensor", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "sigma_nsq", ":", "float", "=", "2.0", ",", "\n", "eps", ":", "float", "=", "1e-10", ",", "\n", "im_type", ":", "str", "=", "None", ",", "\n", ")", ":", "# pragma: no-cover", "\n", "    ", "\"\"\"Compute visual information fidelity (VIF) metric.\n\n    This code is adapted from\n    https://github.com/aizvorski/video-quality/blob/master/vifp.py\n\n    Args:\n        ref (torch.Tensor): The reference image. This can be complex.\n        x (torch.Tensor): The target image. This can be complex.\n        sigma_nsq (float, optional): The visual noise parameter.\n            This may need to be fine-tuned over the dataset of interest.\n        eps (float, optional): The threshold below which data is considered to be 0.\n        im_type (str, optional): The image type to compute metric on.\n            Either ``'magnitude'`` (default) to compute metric on magnitude images\n            or ``'phase'`` to compute metric on phase/angle images.\n\n    Returns:\n        float: The metric value.\n\n    Note:\n        ``im_type`` is only valid if input is complex.\n    \"\"\"", "\n", "if", "cplx", ".", "is_complex", "(", "ref", ")", "or", "cplx", ".", "is_complex_as_real", "(", "ref", ")", ":", "\n", "        ", "ref", "=", "_IM_TYPES_TO_FUNCS", "[", "im_type", "]", "(", "ref", ")", "\n", "", "if", "cplx", ".", "is_complex", "(", "x", ")", "or", "cplx", ".", "is_complex_as_real", "(", "x", ")", ":", "\n", "        ", "x", "=", "_IM_TYPES_TO_FUNCS", "[", "im_type", "]", "(", "x", ")", "\n", "\n", "", "ref", "=", "np", ".", "squeeze", "(", "ref", ".", "numpy", "(", ")", ")", "\n", "x", "=", "np", ".", "squeeze", "(", "x", ".", "numpy", "(", ")", ")", "\n", "\n", "scale_val", "=", "255.0", "/", "ref", ".", "max", "(", ")", "\n", "ref", "*=", "scale_val", "\n", "x", "*=", "scale_val", "\n", "\n", "num", "=", "0.0", "\n", "den", "=", "0.0", "\n", "for", "scale", "in", "range", "(", "1", ",", "5", ")", ":", "\n", "\n", "        ", "N", "=", "2", "**", "(", "4", "-", "scale", "+", "1", ")", "+", "1", "\n", "sd", "=", "N", "/", "5.0", "\n", "\n", "if", "scale", ">", "1", ":", "\n", "            ", "sl", "=", "tuple", "(", "slice", "(", "None", ",", "None", ",", "2", ")", "if", "dim", ">", "1", "else", "slice", "(", "None", ")", "for", "dim", "in", "ref", ".", "shape", ")", "\n", "ref", "=", "scp", ".", "ndimage", ".", "gaussian_filter", "(", "ref", ",", "sd", ")", "\n", "x", "=", "scp", ".", "ndimage", ".", "gaussian_filter", "(", "x", ",", "sd", ")", "\n", "ref", "=", "ref", "[", "sl", "]", "\n", "x", "=", "x", "[", "sl", "]", "\n", "\n", "", "mu1", "=", "scp", ".", "ndimage", ".", "gaussian_filter", "(", "ref", ",", "sd", ")", "\n", "mu2", "=", "scp", ".", "ndimage", ".", "gaussian_filter", "(", "x", ",", "sd", ")", "\n", "mu1_sq", "=", "mu1", "*", "mu1", "\n", "mu2_sq", "=", "mu2", "*", "mu2", "\n", "mu1_mu2", "=", "mu1", "*", "mu2", "\n", "sigma1_sq", "=", "scp", ".", "ndimage", ".", "gaussian_filter", "(", "ref", "*", "ref", ",", "sd", ")", "-", "mu1_sq", "\n", "sigma2_sq", "=", "scp", ".", "ndimage", ".", "gaussian_filter", "(", "x", "*", "x", ",", "sd", ")", "-", "mu2_sq", "\n", "sigma12", "=", "scp", ".", "ndimage", ".", "gaussian_filter", "(", "ref", "*", "x", ",", "sd", ")", "-", "mu1_mu2", "\n", "\n", "sigma1_sq", "[", "sigma1_sq", "<", "0", "]", "=", "0", "\n", "sigma2_sq", "[", "sigma2_sq", "<", "0", "]", "=", "0", "\n", "\n", "g", "=", "sigma12", "/", "(", "sigma1_sq", "+", "eps", ")", "\n", "sv_sq", "=", "sigma2_sq", "-", "g", "*", "sigma12", "\n", "\n", "g", "[", "sigma1_sq", "<", "eps", "]", "=", "0", "\n", "sv_sq", "[", "sigma1_sq", "<", "eps", "]", "=", "sigma2_sq", "[", "sigma1_sq", "<", "eps", "]", "\n", "sigma1_sq", "[", "sigma1_sq", "<", "eps", "]", "=", "0", "\n", "\n", "g", "[", "sigma2_sq", "<", "eps", "]", "=", "0", "\n", "sv_sq", "[", "sigma2_sq", "<", "eps", "]", "=", "0", "\n", "\n", "sv_sq", "[", "g", "<", "0", "]", "=", "sigma2_sq", "[", "g", "<", "0", "]", "\n", "g", "[", "g", "<", "0", "]", "=", "0", "\n", "sv_sq", "[", "sv_sq", "<=", "eps", "]", "=", "eps", "\n", "\n", "num", "+=", "np", ".", "sum", "(", "np", ".", "log10", "(", "1", "+", "g", "*", "g", "*", "sigma1_sq", "/", "(", "sv_sq", "+", "sigma_nsq", ")", ")", ")", "\n", "den", "+=", "np", ".", "sum", "(", "np", ".", "log10", "(", "1", "+", "sigma1_sq", "/", "sigma_nsq", ")", ")", "\n", "\n", "", "vifp", "=", "num", "/", "den", "\n", "\n", "return", "vifp", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func": [[13, 16], ["test_metric.metric_func"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.metric_func"], ["    ", "def", "func", "(", "self", ",", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "0.1", ")", ":", "\n", "# Return a BxC tensor", "\n", "        ", "return", "metric_func", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.TestMetric.test_compute": [[19, 46], ["torch.randn", "torch.randn", "test_metric.metric_func", "test_metric.MockMetric", "MockMetric.", "MockMetric.compute", "torch.all", "test_metric.MockMetric", "MockMetric.", "MockMetric.compute", "torch.all", "test_metric.MockMetric", "MockMetric.", "MockMetric.", "MockMetric.", "MockMetric.compute", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.metric_func", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.compute", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.compute", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.compute"], ["    ", "def", "test_compute", "(", "self", ")", ":", "\n", "        ", "preds", "=", "torch", ".", "randn", "(", "(", "3", ",", "4", ",", "30", ",", "20", ")", ")", "\n", "targets", "=", "torch", ".", "randn", "(", "(", "3", ",", "4", ",", "30", ",", "20", ")", ")", "\n", "\n", "alpha", "=", "0.1", "\n", "beta", "=", "0.1", "\n", "expected_out", "=", "metric_func", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "0.1", ")", "\n", "\n", "metric", "=", "MockMetric", "(", ")", "\n", "metric", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", ")", "\n", "out", "=", "metric", ".", "compute", "(", ")", "\n", "assert", "out", ".", "shape", "==", "(", "3", ",", "4", ")", "\n", "assert", "torch", ".", "all", "(", "out", "==", "expected_out", ")", "\n", "\n", "metric", "=", "MockMetric", "(", ")", "\n", "metric", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "beta", ")", "\n", "out", "=", "metric", ".", "compute", "(", ")", "\n", "assert", "out", ".", "shape", "==", "(", "3", ",", "4", ")", "\n", "assert", "torch", ".", "all", "(", "out", "==", "expected_out", ")", "\n", "\n", "metric", "=", "MockMetric", "(", ")", "\n", "metric", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "beta", ")", "\n", "metric", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "beta", ")", "\n", "metric", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "beta", ")", "\n", "out", "=", "metric", ".", "compute", "(", ")", "\n", "assert", "len", "(", "metric", ".", "ids", ")", "==", "9", "\n", "assert", "out", ".", "shape", "==", "(", "9", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.TestMetric.test_to_pandas": [[47, 60], ["torch.randn", "torch.randn", "test_metric.MockMetric", "MockMetric.", "MockMetric.", "MockMetric.", "MockMetric.to_pandas", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas"], ["", "def", "test_to_pandas", "(", "self", ")", ":", "\n", "        ", "preds", "=", "torch", ".", "randn", "(", "(", "3", ",", "4", ",", "30", ",", "20", ")", ")", "\n", "targets", "=", "torch", ".", "randn", "(", "(", "3", ",", "4", ",", "30", ",", "20", ")", ")", "\n", "alpha", "=", "0.1", "\n", "beta", "=", "0.1", "\n", "\n", "metric", "=", "MockMetric", "(", ")", "\n", "metric", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "beta", ")", "\n", "metric", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "beta", ")", "\n", "metric", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "beta", ")", "\n", "\n", "df", "=", "metric", ".", "to_pandas", "(", ")", "\n", "assert", "len", "(", "df", ")", "==", "9", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.metric_func": [[8, 10], ["tuple", "range", "len"], "function", ["None"], ["def", "metric_func", "(", "preds", ",", "targets", ",", "alpha", ",", "beta", "=", "0.1", ")", ":", "\n", "    ", "return", "(", "alpha", "/", "beta", ")", "*", "(", "targets", "-", "preds", ")", ".", "mean", "(", "dim", "=", "tuple", "(", "range", "(", "2", ",", "len", "(", "preds", ")", "+", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.collate.default_collate": [[8, 32], ["any", "torch.utils.data.dataloader.default_collate", "b.pop"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.collate.default_collate"], ["def", "default_collate", "(", "batch", ":", "List", "[", "Dict", "]", ")", ":", "\n", "    ", "\"\"\"Default collate function for meddlr.\n\n    This collate function handles metadata appropriately by returning\n    metadata as a list of dictionaries instead of a dictionary of tensors.\n    This is done because not all metadata (e.g. string values) can be\n    tensorized.\n\n    Metadata is only handled if at least one example in the batch has\n    a ``'metadata'`` key.\n\n    Args:\n        batch (list): The list of dictionaries.\n\n    Returns:\n        Dict\n    \"\"\"", "\n", "metadata", "=", "None", "\n", "if", "any", "(", "\"metadata\"", "in", "b", "for", "b", "in", "batch", ")", ":", "\n", "        ", "metadata", "=", "[", "b", ".", "pop", "(", "\"metadata\"", ",", "None", ")", "for", "b", "in", "batch", "]", "\n", "", "out_dict", "=", "_default_collate", "(", "batch", ")", "\n", "if", "metadata", "is", "not", "None", ":", "\n", "        ", "out_dict", "[", "\"metadata\"", "]", "=", "metadata", "\n", "", "return", "out_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.collate.collate_by_supervision": [[34, 58], ["len", "torch.utils.data.dataloader.default_collate", "len", "torch.utils.data.dataloader.default_collate", "len", "x.get", "x.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.collate.default_collate", "home.repos.pwc.inspect_result.ad12_meddlr.data.collate.default_collate", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "collate_by_supervision", "(", "batch", ":", "list", ")", ":", "\n", "    ", "\"\"\"Collate supervised/unsupervised batch examples.\n\n    This collate function is required when training with semi-supervised\n    models, such as :cls:`N2RModel` and :cls:`VortexModel`.\n\n    Args:\n        batch (list): The list of dictionaries.\n\n    Returns:\n        Dict[str, Dict]: A dictionary with 2 keys, ``'supervised'`` and ``'unsupervised'``.\n    \"\"\"", "\n", "supervised", "=", "[", "x", "for", "x", "in", "batch", "if", "not", "x", ".", "get", "(", "\"is_unsupervised\"", ",", "False", ")", "]", "\n", "unsupervised", "=", "[", "x", "for", "x", "in", "batch", "if", "x", ".", "get", "(", "\"is_unsupervised\"", ",", "False", ")", "]", "\n", "\n", "out_dict", "=", "{", "}", "\n", "if", "len", "(", "supervised", ")", ">", "0", ":", "\n", "        ", "supervised", "=", "default_collate", "(", "supervised", ")", "\n", "out_dict", "[", "\"supervised\"", "]", "=", "supervised", "\n", "", "if", "len", "(", "unsupervised", ")", ">", "0", ":", "\n", "        ", "unsupervised", "=", "default_collate", "(", "unsupervised", ")", "\n", "out_dict", "[", "\"unsupervised\"", "]", "=", "unsupervised", "\n", "", "assert", "len", "(", "out_dict", ")", ">", "0", "\n", "return", "out_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.__init__": [[39, 56], ["max", "data_utils.HDF5Manager.open"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["def", "__init__", "(", "\n", "self", ",", "files", ":", "Sequence", "[", "str", "]", "=", "None", ",", "cache", "=", "True", ",", "max_attempts", "=", "5", ",", "wait_time", ":", "float", "=", "1.0", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            files (Sequence[str], optional): Filepaths to h5 files the manage.\n            cache (bool, optional): If `True`, keep files files open once accessed.\n            max_attempts (int, optional): Maximum number of attempts to read from a file.\n            wait_time (float, optional): Time to wait between attempts to read from a file.\n        \"\"\"", "\n", "self", ".", "files", ":", "Dict", "[", "str", ",", "h5py", ".", "File", "]", "=", "{", "}", "\n", "self", ".", "cache", "=", "cache", "\n", "self", ".", "max_attempts", "=", "max", "(", "1", ",", "max_attempts", ")", "\n", "self", ".", "wait_time", "=", "wait_time", "\n", "if", "files", "and", "cache", ":", "\n", "            ", "for", "fp", "in", "files", ":", "\n", "                ", "self", ".", "open", "(", "fp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open": [[57, 66], ["h5py.File"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File"], ["", "", "", "def", "open", "(", "self", ",", "filepath", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Open and cache file.\n\n        Args:\n            filepath (str): Path to HDF5 file\n        \"\"\"", "\n", "if", "filepath", "in", "self", ".", "files", ":", "\n", "            ", "return", "\n", "", "self", ".", "files", "[", "filepath", "]", "=", "h5py", ".", "File", "(", "filepath", ",", "mode", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close": [[67, 78], ["data_utils.HDF5Manager.files[].close", "data_utils.HDF5Manager.files.pop"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["", "def", "close", "(", "self", ",", "filepath", ",", "drop", "=", "True", ")", ":", "\n", "        ", "\"\"\"Close the open file.\n\n        Args:\n            filepath (str): Path to HDF5 file\n            drop (bool, optional): If `True`, drop filepath from list of files.\n                If `False`, `self.files` will keep a reference to the closed file.\n        \"\"\"", "\n", "self", ".", "files", "[", "filepath", "]", ".", "close", "(", ")", "\n", "if", "drop", ":", "\n", "            ", "self", ".", "files", ".", "pop", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.get": [[79, 116], ["meddlr.utils.profiler.time_profile", "range", "ValueError", "data_utils.HDF5Manager._load_data", "h5py.File", "data_utils.HDF5Manager._load_data", "re.search", "data_utils.HDF5Manager.close", "time.sleep", "data_utils.HDF5Manager.open", "time.sleep", "str"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.time_profile", "home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils._MockHDF5Manager._load_data", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils._MockHDF5Manager._load_data", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["", "", "@", "profiler", ".", "time_profile", "(", ")", "\n", "def", "get", "(", "self", ",", "filepath", ":", "str", ",", "key", ":", "str", "=", "None", ",", "patch", ":", "Union", "[", "str", ",", "Sequence", "[", "slice", "]", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"Get dataset from h5 file.\n\n        Args:\n            filepath (str): Filepath to fetch data from.\n            key (str, optional): HDF5 key. If `None`, returns open file.\n            patch (str or Sequence[slice], optional): Slice to apply to dataset.\n                If `None`, returns dataset without slicing.\n        \"\"\"", "\n", "if", "patch", "is", "not", "None", "and", "key", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"`key` must be specified to use `patch`.\"", ")", "\n", "\n", "", "for", "idx", "in", "range", "(", "self", ".", "max_attempts", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "if", "filepath", "in", "self", ".", "files", ":", "\n", "                    ", "file", "=", "self", ".", "files", "[", "filepath", "]", "\n", "return", "self", ".", "_load_data", "(", "file", ",", "key", "=", "key", ",", "sl", "=", "patch", ")", "\n", "", "else", ":", "\n", "                    ", "assert", "key", "\n", "with", "h5py", ".", "File", "(", "filepath", ",", "\"r\"", ")", "as", "file", ":", "\n", "                        ", "data", "=", "self", ".", "_load_data", "(", "file", ",", "key", "=", "key", ",", "sl", "=", "patch", ")", "\n", "", "return", "data", "\n", "", "", "except", "OSError", "as", "e", ":", "\n", "# Handle input/output errors by waiting and retrying.", "\n", "# This issue is common for NFS mounted file systems.", "\n", "# https://github.com/theislab/scanpy/issues/1351#issuecomment-668009684", "\n", "                ", "if", "(", "idx", "<", "self", ".", "max_attempts", "-", "1", ")", "and", "(", "re", ".", "search", "(", "\"[Errno 5]\"", ",", "str", "(", "e", ")", ")", "is", "not", "None", ")", ":", "\n", "                    ", "is_cached", "=", "filepath", "in", "self", ".", "files", "\n", "if", "is_cached", ":", "\n", "                        ", "self", ".", "close", "(", "filepath", ")", "\n", "time", ".", "sleep", "(", "self", ".", "wait_time", ")", "\n", "self", ".", "open", "(", "filepath", ")", "\n", "", "else", ":", "\n", "                        ", "time", ".", "sleep", "(", "self", ".", "wait_time", ")", "\n", "", "", "else", ":", "\n", "                    ", "raise", "e", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File": [[117, 145], ["meddlr.utils.profiler.time_profile", "h5py.File", "file.close"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.time_profile", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["", "", "", "", "@", "profiler", ".", "time_profile", "(", ")", "\n", "@", "contextlib", ".", "contextmanager", "\n", "def", "File", "(", "self", ",", "filepath", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Yields HDF5 file.\n\n        Similar to ``with h5py.File(...)`` but with supported caching.\n        If caching is enabled, the file will be opened (if it is not already\n        open) and kept open when the context is exited.\n\n        Example:\n\n        .. code-block:: python\n\n            h5manager = HDF5Manager()\n            fpath = \"file.h5\"\n            with h5manager.File(fpath, \"r\") as h5file:\n                arr = h5file[\"my_array\"][()]\n        \"\"\"", "\n", "is_cached", "=", "filepath", "in", "self", ".", "files", "\n", "file", "=", "self", ".", "files", "[", "filepath", "]", "if", "is_cached", "else", "h5py", ".", "File", "(", "filepath", ",", "mode", ",", "**", "kwargs", ")", "\n", "if", "self", ".", "cache", "and", "not", "is_cached", ":", "\n", "            ", "self", ".", "files", "[", "filepath", "]", "=", "file", "\n", "\n", "", "try", ":", "\n", "            ", "yield", "file", "\n", "", "finally", ":", "\n", "            ", "if", "not", "is_cached", "and", "not", "self", ".", "cache", ":", "\n", "                ", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.temp_open": [[148, 176], ["meddlr.utils.profiler.time_profile", "data_utils.HDF5Manager.open", "data_utils.HDF5Manager.close"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.profiler.time_profile", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["@", "profiler", ".", "time_profile", "(", ")", "\n", "@", "contextlib", ".", "contextmanager", "\n", "def", "temp_open", "(", "self", ",", "filepath", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", "->", "\"HDF5Manager\"", ":", "\n", "        ", "\"\"\"Temporarily opens file in this manager.\n\n        If the file is already opened, this open file will be used.\n\n        Yields:\n            HDF5Manager: This HDF5Manager (i.e. ``self``).\n\n        Example:\n\n        .. code-block:: python\n\n            h5manager = HDF5Manager()\n            fpath = \"file.h5\"\n            with h5manager.temp_open(fpath, \"r\"):\n                arr = h5manager.get(fpath, \"my_array\", ())\n        \"\"\"", "\n", "is_cached", "=", "filepath", "in", "self", ".", "files", "\n", "if", "not", "is_cached", ":", "\n", "            ", "self", ".", "open", "(", "filepath", ",", "mode", ",", "**", "kwargs", ")", "\n", "\n", "", "try", ":", "\n", "            ", "yield", "self", "\n", "", "finally", ":", "\n", "            ", "if", "not", "is_cached", ":", "\n", "                ", "self", ".", "close", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager._load_data": [[177, 202], ["isinstance", "isinstance", "tuple"], "methods", ["None"], ["", "", "", "def", "_load_data", "(", "self", ",", "file", ",", "key", "=", "None", ",", "sl", "=", "None", ")", ":", "\n", "        ", "\"\"\"Load data from HDF5 file.\n\n        If ``key`` and ``sl`` are not passed, the file is returned.\n\n        If ``key`` is passed, the dataset is returned without loading\n        the underlying data into memory. Equivalent to ``file[key]``.\n\n        If ``sl`` is passed, the dataset is returned after slicing.\n        Equivalent to ``file[key][sl]``.\n\n        \"\"\"", "\n", "if", "not", "key", ":", "\n", "            ", "return", "file", "\n", "\n", "", "val", "=", "file", "[", "key", "]", "\n", "if", "sl", "is", "None", ":", "\n", "            ", "return", "val", "\n", "\n", "", "if", "isinstance", "(", "sl", ",", "str", ")", ":", "\n", "            ", "assert", "sl", "in", "[", "\"all\"", ",", "\"load\"", "]", "\n", "sl", "=", "(", ")", "\n", "", "elif", "isinstance", "(", "sl", ",", "Iterable", ")", ":", "\n", "            ", "sl", "=", "tuple", "(", "sl", ")", "\n", "", "return", "val", "[", "sl", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.__del__": [[203, 207], ["list", "data_utils.HDF5Manager.files.keys", "data_utils.HDF5Manager.close"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "# Copy keys to allow modifying self.files dict.", "\n", "        ", "for", "filepath", "in", "list", "(", "self", ".", "files", ".", "keys", "(", ")", ")", ":", "\n", "            ", "self", ".", "close", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.structure_patches": [[209, 265], ["isinstance", "any", "numpy.asarray", "tuple", "numpy.empty", "zip", "any", "struct.tolist.tolist", "data_utils._recursive_stack", "list", "list", "len", "len", "ValueError", "len", "len", "ValueError", "isinstance", "ValueError", "ValueError", "sorted", "out.permute.permute", "list.keys", "list.values", "set", "len", "len", "ValueError", "len", "len", "ValueError", "tuple", "set", "numpy.max().item", "range", "struct.tolist.flatten", "set", "set", "zip", "range", "range", "len", "len", "numpy.max", "sorted", "order_dict.keys"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils._recursive_stack", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "", "", "def", "structure_patches", "(", "\n", "patches", ":", "Sequence", "[", "torch", ".", "Tensor", "]", ",", "\n", "coords", ":", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "Tuple", "[", "int", "]", "]", "]", "=", "None", ",", "\n", "dims", "=", "None", ",", "\n", ")", ":", "\n", "    ", "if", "coords", "is", "None", ":", "\n", "        ", "coords", "=", "list", "(", "patches", ".", "keys", "(", ")", ")", "\n", "patches", "=", "list", "(", "patches", ".", "values", "(", ")", ")", "\n", "\n", "", "if", "len", "(", "patches", ")", "!=", "len", "(", "coords", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Got unknown length for coordinates\"", ")", "\n", "\n", "", "if", "isinstance", "(", "coords", "[", "0", "]", ",", "int", ")", ":", "\n", "        ", "coords", "=", "[", "(", "x", ",", ")", "for", "x", "in", "coords", "]", "\n", "\n", "", "if", "len", "(", "coords", ")", "!=", "len", "(", "set", "(", "coords", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"All coordinates must be unique. \"", "\"Overlapping patches are not currently supported.\"", "\n", ")", "\n", "\n", "", "if", "dims", "is", "not", "None", ":", "\n", "        ", "if", "isinstance", "(", "dims", ",", "int", ")", ":", "\n", "            ", "dims", "=", "(", "dims", ",", ")", "\n", "", "if", "len", "(", "dims", ")", "!=", "len", "(", "coords", "[", "0", "]", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Specified {len(dims)} dimensions, but have {len(coords[0])}-d coordinates\"", "\n", ")", "\n", "", "if", "len", "(", "dims", ")", "!=", "len", "(", "set", "(", "dims", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Duplicate dimensions specified - {dims}\"", ")", "\n", "\n", "", "", "base_shape", "=", "patches", "[", "0", "]", ".", "shape", "\n", "if", "any", "(", "x", ".", "shape", "!=", "base_shape", "for", "x", "in", "patches", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"All patches must have the same shape\"", ")", "\n", "\n", "", "stack_shape", "=", "[", "]", "\n", "coords_arr", "=", "np", ".", "asarray", "(", "coords", ")", "\n", "assert", "coords_arr", ".", "ndim", "==", "2", "\n", "stack_shape", "=", "tuple", "(", "np", ".", "max", "(", "coords_arr", "[", ":", ",", "c", "]", ")", ".", "item", "(", ")", "+", "1", "for", "c", "in", "range", "(", "coords_arr", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "struct", "=", "np", ".", "empty", "(", "stack_shape", ",", "dtype", "=", "np", ".", "object", ")", "\n", "for", "coord", ",", "patch", "in", "zip", "(", "coords", ",", "patches", ")", ":", "\n", "        ", "struct", "[", "coord", "]", "=", "patch", "\n", "", "if", "any", "(", "x", "is", "None", "for", "x", "in", "struct", ".", "flatten", "(", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Did not get dense labels.\"", ")", "\n", "", "struct", "=", "struct", ".", "tolist", "(", ")", "\n", "\n", "out", "=", "_recursive_stack", "(", "struct", ")", "\n", "\n", "if", "dims", "is", "not", "None", ":", "\n", "# Reorder dimensions of the structured tensor.", "\n", "        ", "dims", "=", "[", "out", ".", "ndim", "+", "d", "if", "d", "<", "0", "else", "d", "for", "d", "in", "dims", "]", "\n", "original_dims_new_order", "=", "sorted", "(", "set", "(", "range", "(", "out", ".", "ndim", ")", ")", "-", "set", "(", "dims", ")", ")", "\n", "order_dict", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "zip", "(", "range", "(", "out", ".", "ndim", ")", ",", "dims", "+", "original_dims_new_order", ")", "}", "\n", "out", "=", "out", ".", "permute", "(", "tuple", "(", "order_dict", "[", "k", "]", "for", "k", "in", "sorted", "(", "order_dict", ".", "keys", "(", ")", ")", ")", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.collect_mask": [[267, 304], ["isinstance", "any", "numpy.stack", "numpy.transpose", "isinstance", "o_seg.append", "len", "isinstance", "numpy.sum", "tuple", "range"], "function", ["None"], ["", "def", "collect_mask", "(", "\n", "mask", ":", "np", ".", "ndarray", ",", "\n", "index", ":", "Sequence", "[", "Union", "[", "int", ",", "Sequence", "[", "int", "]", ",", "int", "]", "]", ",", "\n", "out_channel_first", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Collect masks by index.\n\n    Collated indices will be summed. For example, `index=(1,(3,4))` will return\n    `np.stack(mask[...,1], mask[...,3]+mask[...,4])`.\n\n    TODO: Add support for adding background.\n\n    Args:\n        mask (ndarray): A (...)xC array.\n        index (Sequence[int]): The index/indices to select in mask.\n            If sub-indices are collated, they will be summed.\n        out_channel_first (bool, optional): Reorders dimensions of output mask to Cx(...)\n    \"\"\"", "\n", "if", "isinstance", "(", "index", ",", "int", ")", ":", "\n", "        ", "index", "=", "(", "index", ",", ")", "\n", "\n", "", "if", "not", "any", "(", "isinstance", "(", "idx", ",", "Sequence", ")", "for", "idx", "in", "index", ")", ":", "\n", "        ", "mask", "=", "mask", "[", "...", ",", "index", "]", "\n", "", "else", ":", "\n", "        ", "o_seg", "=", "[", "]", "\n", "for", "idx", "in", "index", ":", "\n", "            ", "c_seg", "=", "mask", "[", "...", ",", "idx", "]", "\n", "if", "isinstance", "(", "idx", ",", "Sequence", ")", ":", "\n", "                ", "c_seg", "=", "np", ".", "sum", "(", "c_seg", ",", "axis", "=", "-", "1", ")", "\n", "", "o_seg", ".", "append", "(", "c_seg", ")", "\n", "", "mask", "=", "np", ".", "stack", "(", "o_seg", ",", "axis", "=", "-", "1", ")", "\n", "\n", "", "if", "out_channel_first", ":", "\n", "        ", "last_idx", "=", "len", "(", "mask", ".", "shape", ")", "-", "1", "\n", "mask", "=", "np", ".", "transpose", "(", "mask", ",", "(", "last_idx", ",", ")", "+", "tuple", "(", "range", "(", "0", ",", "last_idx", ")", ")", ")", "\n", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils._recursive_stack": [[306, 314], ["all", "all", "torch.stack", "torch.stack", "ValueError", "isinstance", "isinstance", "data_utils._recursive_stack"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils._recursive_stack"], ["", "def", "_recursive_stack", "(", "tensors", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "if", "all", "(", "isinstance", "(", "x", ",", "torch", ".", "Tensor", ")", "for", "x", "in", "tensors", ")", ":", "\n", "        ", "return", "torch", ".", "stack", "(", "tensors", ",", "dim", "=", "0", ")", "\n", "", "if", "all", "(", "isinstance", "(", "x", ",", "list", ")", "for", "x", "in", "tensors", ")", ":", "\n", "        ", "tensors", "=", "[", "_recursive_stack", "(", "x", ")", "for", "x", "in", "tensors", "]", "\n", "return", "torch", ".", "stack", "(", "tensors", ",", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown stack\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.register": [[40, 63], ["isinstance", "callable", "ValueError", "inspect.signature"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "register", "(", "name", ",", "func_or_name", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            name (str): The name that identifies a dataset,\n                e.g. \"mridata_knee_2019_train\".\n            func_or_name (callable | str): A callable that returns a list of dicts\n                or the name of an existing dataset. If the latter, it will be registered\n                as a soft alias to the underlying dataset.\n        \"\"\"", "\n", "if", "name", "in", "DatasetCatalog", ".", "_REGISTERED", ":", "\n", "            ", "raise", "ValueError", "(", "\"Dataset '{}' is already registered!\"", ".", "format", "(", "name", ")", ")", "\n", "", "if", "isinstance", "(", "func_or_name", ",", "str", ")", ":", "\n", "            ", "assert", "(", "\n", "func_or_name", "in", "DatasetCatalog", ".", "_REGISTERED", "\n", ")", ",", "f\"Target dataset '{func_or_name}' is not registered\"", "\n", "DatasetCatalog", ".", "_ALIASES", "[", "name", "]", "=", "func_or_name", "\n", "return", "\n", "\n", "", "assert", "callable", "(", "\n", "func_or_name", "\n", ")", ",", "\"You must register a function with `DatasetCatalog.register`!\"", "\n", "DatasetCatalog", ".", "_REGISTERED", "[", "name", "]", "=", "(", "func_or_name", ",", "inspect", ".", "signature", "(", "func_or_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.get": [[64, 100], ["logging.getLogger", "any", "f", "DatasetCatalog._ALIASES.get", "KeyError", "logging.getLogger.warning", "parameters.values", "kwargs.items", "DatasetCatalog._REGISTERED.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "@", "staticmethod", "\n", "def", "get", "(", "name", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Call the registered function and return its results.\n\n        Args:\n            name (str): the name that identifies a dataset,\n                e.g. \"coco_2014_train\".\n\n        Returns:\n            list[dict]: dataset annotations.0\n        \"\"\"", "\n", "try", ":", "\n", "            ", "dname", "=", "DatasetCatalog", ".", "_ALIASES", ".", "get", "(", "name", ",", "name", ")", "\n", "f", ",", "sig", "=", "DatasetCatalog", ".", "_REGISTERED", "[", "dname", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "raise", "KeyError", "(", "\n", "\"Dataset '{}' is not registered! \"", "\n", "\"Available datasets are: {}\"", ".", "format", "(", "\n", "name", ",", "\", \"", ".", "join", "(", "DatasetCatalog", ".", "_REGISTERED", ".", "keys", "(", ")", ")", "\n", ")", "\n", ")", "\n", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "parameters", "=", "sig", ".", "parameters", "\n", "has_kwargs", "=", "any", "(", "v", ".", "kind", "==", "inspect", ".", "Parameter", ".", "VAR_KEYWORD", "for", "v", "in", "parameters", ".", "values", "(", ")", ")", "\n", "if", "not", "has_kwargs", ":", "\n", "            ", "missing_kwargs", "=", "[", "k", "for", "k", "in", "kwargs", "if", "k", "not", "in", "parameters", "]", "\n", "valid_kwargs", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "if", "k", "in", "parameters", "}", "\n", "if", "missing_kwargs", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "\"Function to load dataset {} does not support following kwargs. \"", "\n", "\"Ignoring them...\\n\\t{}\"", ".", "format", "(", "name", ",", "missing_kwargs", ")", "\n", ")", "\n", "", "kwargs", "=", "valid_kwargs", "\n", "", "return", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list": [[101, 111], ["catalog.DatasetCatalog.list"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "@", "staticmethod", "\n", "def", "list", "(", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"List all registered datasets (including aliases).\n\n        For a more decorated output, see :func:`DatasetCatalog.__repr__`.\n\n        Returns:\n            list[str]\n        \"\"\"", "\n", "return", "list", "(", "DatasetCatalog", ".", "_REGISTERED", ".", "keys", "(", ")", ")", "+", "list", "(", "DatasetCatalog", ".", "_ALIASES", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear": [[112, 129], ["DatasetCatalog._REGISTERED.pop", "DatasetCatalog._REGISTERED.clear", "DatasetCatalog._ALIASES.clear", "DatasetCatalog._ALIASES.pop", "DatasetCatalog._ALIASES.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "@", "staticmethod", "\n", "def", "clear", "(", "name", "=", "None", ")", ":", "\n", "        ", "\"\"\"Remove the registered dataset and it's aliases.\n\n        Args:\n            name (str): The name of the dataset to be removed.\n                If None, all datasets are removed.\n        \"\"\"", "\n", "if", "name", "is", "None", ":", "\n", "            ", "DatasetCatalog", ".", "_REGISTERED", ".", "clear", "(", ")", "\n", "DatasetCatalog", ".", "_ALIASES", ".", "clear", "(", ")", "\n", "return", "\n", "\n", "", "aliases", "=", "[", "name", "]", "+", "[", "k", "for", "k", ",", "v", "in", "DatasetCatalog", ".", "_ALIASES", ".", "items", "(", ")", "if", "v", "==", "name", "]", "\n", "DatasetCatalog", ".", "_REGISTERED", ".", "pop", "(", "name", ",", "None", ")", "\n", "for", "alias", "in", "aliases", ":", "\n", "            ", "DatasetCatalog", ".", "_ALIASES", ".", "pop", "(", "alias", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.__repr__": [[130, 145], ["collections.defaultdict", "catalog.DatasetCatalog._ALIASES.items", "tabulate.tabulate.tabulate", "base_to_aliases[].append", "collections.defaultdict.get", "catalog.MetadataCatalog.get"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "base_to_aliases", "=", "defaultdict", "(", "list", ")", "\n", "for", "alias", ",", "base", "in", "self", ".", "_ALIASES", ".", "items", "(", ")", ":", "\n", "            ", "base_to_aliases", "[", "base", "]", ".", "append", "(", "alias", ")", "\n", "\n", "", "datasets", "=", "[", "\n", "{", "\n", "\"name\"", ":", "name", ",", "\n", "\"aliases\"", ":", "base_to_aliases", ".", "get", "(", "name", ",", "None", ")", ",", "\n", "**", "MetadataCatalog", ".", "get", "(", "name", ",", "{", "}", ")", ".", "__dict__", ",", "# use protected variable to avoid a copy", "\n", "}", "\n", "for", "name", "in", "self", ".", "_REGISTERED", "\n", "]", "\n", "table", "=", "tabulate", "(", "datasets", ",", "headers", "=", "\"keys\"", ",", "tablefmt", "=", "\"fancy_grid\"", ")", "\n", "return", "\"Cataloged Datasets:\\n{}\"", ".", "format", "(", "table", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.__getattr__": [[175, 187], ["AttributeError", "meddlr.utils.logger.log_first_n", "getattr", "str", "catalog.Metadata.__dict__.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.log_first_n"], ["def", "__getattr__", "(", "self", ",", "key", ")", ":", "\n", "        ", "if", "key", "in", "self", ".", "_RENAMED", ":", "\n", "            ", "log_first_n", "(", "\n", "logging", ".", "WARNING", ",", "\n", "\"Metadata '{}' was renamed to '{}'!\"", ".", "format", "(", "key", ",", "self", ".", "_RENAMED", "[", "key", "]", ")", ",", "\n", "n", "=", "10", ",", "\n", ")", "\n", "return", "getattr", "(", "self", ",", "self", ".", "_RENAMED", "[", "key", "]", ")", "\n", "\n", "", "raise", "AttributeError", "(", "\n", "\"Attribute '{}' does not exist in the metadata of '{}'. \"", "\n", "\"Available keys are {}.\"", ".", "format", "(", "key", ",", "self", ".", "name", ",", "str", "(", "self", ".", "__dict__", ".", "keys", "(", ")", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.__setattr__": [[189, 207], ["meddlr.utils.logger.log_first_n", "setattr", "getattr", "types.SimpleNamespace.__setattr__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.log_first_n", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.__setattr__"], ["", "def", "__setattr__", "(", "self", ",", "key", ",", "val", ")", ":", "\n", "        ", "if", "key", "in", "self", ".", "_RENAMED", ":", "\n", "            ", "log_first_n", "(", "\n", "logging", ".", "WARNING", ",", "\n", "\"Metadata '{}' was renamed to '{}'!\"", ".", "format", "(", "key", ",", "self", ".", "_RENAMED", "[", "key", "]", ")", ",", "\n", "n", "=", "10", ",", "\n", ")", "\n", "setattr", "(", "self", ",", "self", ".", "_RENAMED", "[", "key", "]", ",", "val", ")", "\n", "\n", "# Ensure that metadata of the same name stays consistent", "\n", "", "try", ":", "\n", "            ", "oldval", "=", "getattr", "(", "self", ",", "key", ")", "\n", "assert", "oldval", "==", "val", ",", "(", "\n", "\"Attribute '{}' in the metadata of '{}' cannot be set \"", "\n", "\"to a different value!\\n{} != {}\"", ".", "format", "(", "key", ",", "self", ".", "name", ",", "oldval", ",", "val", ")", "\n", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "super", "(", ")", ".", "__setattr__", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.as_dict": [[208, 215], ["copy.copy"], "methods", ["None"], ["", "", "def", "as_dict", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns all the metadata as a dict.\n        Note that modifications to the returned dict will not reflect on the\n        Metadata object.\n        \"\"\"", "\n", "return", "copy", ".", "copy", "(", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set": [[216, 223], ["kwargs.items", "setattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "set", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Set multiple metadata with kwargs.\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "setattr", "(", "self", ",", "k", ",", "v", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.get": [[224, 233], ["getattr"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "key", ",", "default", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Access an attribute and return its value if exists.\n        Otherwise return default.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "return", "getattr", "(", "self", ",", "key", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "return", "default", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get": [[252, 269], ["len", "catalog.Metadata"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "get", "(", "name", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            name (str): name of a dataset (e.g. coco_2014_train).\n\n        Returns:\n            Metadata: The :class:`Metadata` instance associated with this name,\n            or create an empty one if none is available.\n        \"\"\"", "\n", "assert", "len", "(", "name", ")", "\n", "if", "name", "in", "MetadataCatalog", ".", "_NAME_TO_META", ":", "\n", "            ", "ret", "=", "MetadataCatalog", ".", "_NAME_TO_META", "[", "name", "]", "\n", "return", "ret", "\n", "", "else", ":", "\n", "            ", "m", "=", "MetadataCatalog", ".", "_NAME_TO_META", "[", "name", "]", "=", "Metadata", "(", "name", "=", "name", ")", "\n", "return", "m", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.data.build.get_recon_dataset_dicts": [[20, 126], ["len", "list", "len", "logging.getLogger", "random.Random", "len", "len", "logging.getLogger.info", "max", "logging.getLogger.info", "meddlr.data.catalog.DatasetCatalog.get", "itertools.chain.from_iterable", "isinstance", "bool", "sorted", "random.Random.shuffle", "isinstance", "len", "len", "logging.getLogger.info", "isinstance", "build._limit_data_by_group", "len", "ValueError", "max", "isinstance", "isinstance", "list", "extra_v.append", "isinstance", "tuple", "extra_v.append", "dd.get", "dd.get().get", "list", "dd.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.build._limit_data_by_group", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "\n", "def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "return", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "\n", "\n", "", "def", "initialize_model", "(", "model", ":", "nn", ".", "Module", ",", "initializers", ":", "Union", "[", "Dict", ",", "Tuple", "]", ")", ":", "\n", "    ", "\"\"\"Initialize the model.\n\n    This function initializes the model using the initialization method\n    specified in ``initializers``.\n\n    ``initializers`` should be a sequence of dicts, where each dict\n    defines the layer type (optional), regex pattern of the parameter\n    name (optional), or the dict. The dict has the following keys:\n\n        * 'kind' (str, optional): The layer kind to apply this (e.g. 'conv', 'norm')\n        * 'patterns' (Tuple[str] | str, optional): The regex patterns of the\n                parameters to use initializer on. If not specified, all parameters\n                of\n        * 'initializers' (Sequence[Callable | str]): The initializers to use on the\n                parameters. These should be called as ``initializer(param)``.\n                These values should be 1:1 with the values in ``'patterns'``.\n\n    Args:\n        model (nn.Model): The model to initialize. Parameters will be fetched\n            with ``model.named_parameters()``.\n        initializers (Dict[str, Union[str, Callable]] | Tuple[str]):\n            See above.\n    \"\"\"", "\n", "_kind_kwd", "=", "\"kind\"", "\n", "_pattern_kwd", "=", "\"patterns\"", "\n", "_init_kwd", "=", "\"initializers\"", "\n", "\n", "if", "isinstance", "(", "initializers", ",", "Dict", ")", ":", "\n", "        ", "initializers", "=", "[", "initializers", "]", "\n", "\n", "# Backwards compatibility with pattern-only initialization.", "\n", "", "if", "isinstance", "(", "initializers", ",", "Sequence", ")", "and", "not", "any", "(", "isinstance", "(", "x", ",", "Dict", ")", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "assert", "len", "(", "initializers", ")", "%", "2", "==", "0", ",", "\"Sequence of regex_to_init must be even\"", "\n", "initializers", "=", "[", "\n", "{", "_pattern_kwd", ":", "k", ",", "_init_kwd", ":", "v", "}", "for", "k", ",", "v", "in", "zip", "(", "initializers", "[", ":", ":", "2", "]", ",", "initializers", "[", "1", ":", ":", "2", "]", ")", "\n", "]", "\n", "\n", "# Convert string values to python literals.", "\n", "", "initializers", "=", "_to_literal", "(", "initializers", ")", "\n", "\n", "if", "not", "all", "(", "\n", "isinstance", "(", "x", ",", "Dict", ")", "or", "(", "isinstance", "(", "x", ",", "Sequence", ")", "and", "len", "(", "x", ")", "==", "2", ")", "for", "x", "in", "initializers", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"All initializers must either be a dict or sequence of 2 elements \"", "\n", "\"(pattern, initializer). Got:\\n\\t{}\"", ".", "format", "(", "initializers", ")", "\n", ")", "\n", "\n", "", "initializers", ":", "List", "[", "Dict", "]", "=", "[", "\n", "{", "_pattern_kwd", ":", "x", "[", "0", "]", ",", "_init_kwd", ":", "x", "[", "1", "]", "}", "if", "isinstance", "(", "x", ",", "Sequence", ")", "else", "x", "\n", "for", "x", "in", "initializers", "\n", "]", "\n", "matched_patterns", "=", "{", "}", "\n", "for", "init_cfg", "in", "initializers", ":", "\n", "        ", "pattern", "=", "init_cfg", ".", "pop", "(", "_pattern_kwd", ",", "None", ")", "\n", "if", "pattern", "is", "None", ":", "\n", "            ", "pattern", "=", "(", "\".*\"", ",", ")", "\n", "", "elif", "not", "isinstance", "(", "pattern", ",", "Sequence", ")", "or", "isinstance", "(", "pattern", ",", "str", ")", ":", "\n", "            ", "pattern", "=", "(", "pattern", ",", ")", "\n", "\n", "", "init_method", "=", "init_cfg", ".", "pop", "(", "_init_kwd", ")", "\n", "if", "not", "isinstance", "(", "init_method", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "init_method", "=", "(", "init_method", ",", ")", "\n", "\n", "", "if", "len", "(", "pattern", ")", "!=", "len", "(", "init_method", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Got {} pattern(s) but {} initializer(s):\\n\\t\"", "\n", "\"Patterns: {}\\n\\tInitializers: {}\"", ".", "format", "(", "\n", "len", "(", "pattern", ")", ",", "len", "(", "init_method", ")", ",", "pattern", ",", "init_method", "\n", ")", "\n", ")", "\n", "\n", "", "pattern", "=", "tuple", "(", "\n", "(", "p", ",", ")", "if", "not", "isinstance", "(", "p", ",", "Sequence", ")", "or", "isinstance", "(", "p", ",", "str", ")", "else", "p", "for", "p", "in", "pattern", "\n", ")", "\n", "\n", "init_method", "=", "[", "\n", "getattr", "(", "nn", ".", "init", ",", "v", ")", "\n", "if", "isinstance", "(", "v", ",", "str", ")", "\n", "else", "(", "getattr", "(", "nn", ".", "init", ",", "v", "[", "0", "]", ")", ",", "v", "[", "1", "]", ")", "\n", "if", "isinstance", "(", "v", ",", "Sequence", ")", "\n", "else", "v", "\n", "for", "v", "in", "init_method", "\n", "]", "\n", "init_cfg", "[", "_init_kwd", "]", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "pattern", ",", "init_method", ")", "}", "\n", "for", "pattern_val", "in", "pattern", ":", "\n", "            ", "key", "=", "(", "init_cfg", "[", "_kind_kwd", "]", ",", "pattern_val", ")", "if", "_kind_kwd", "in", "init_cfg", "else", "pattern_val", "\n", "matched_patterns", "[", "key", "]", "=", "False", "\n", "\n", "", "", "model_layers", "=", "{", "}", "\n", "if", "any", "(", "_kind_kwd", "in", "x", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "model_layers", ":", "Dict", "[", "str", ",", "nn", ".", "Module", "]", "=", "_get_model_layers", "(", "model", ",", "by_kind", "=", "True", ")", "\n", "", "named_parameters", "=", "list", "(", "model", ".", "named_parameters", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.build._limit_data_by_group": [[128, 156], ["collections.defaultdict", "len", "ValueError", "isinstance", "dd.get", "new_dataset_dicts.append", "ValueError", "dd.get().get", "new_dataset_dicts.append", "collections.defaultdict.get", "isinstance", "zip", "isinstance", "len", "dd.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["for", "init_cfg", "in", "initializers", ":", "\n", "        ", "layer_kind", "=", "\"\"", "\n", "if", "_kind_kwd", "in", "init_cfg", ":", "\n", "            ", "layer_kind", "=", "init_cfg", "[", "_kind_kwd", "]", "\n", "if", "layer_kind", "not", "in", "model_layers", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "f\"Layer kind '{layer_kind}' not found in model {type(model).__name__}\"", "\n", ")", "\n", "continue", "\n", "", "parameters", "=", "[", "\n", "named_param", "\n", "for", "layer", "in", "model_layers", "[", "layer_kind", "]", "\n", "for", "named_param", "in", "layer", ".", "named_parameters", "(", ")", "\n", "]", "\n", "", "else", ":", "\n", "            ", "parameters", "=", "named_parameters", "\n", "\n", "", "patterns_to_initializers", "=", "init_cfg", "[", "_init_kwd", "]", "\n", "for", "name", ",", "param", "in", "parameters", ":", "\n", "            ", "for", "patterns", ",", "v", "in", "patterns_to_initializers", ".", "items", "(", ")", ":", "\n", "                ", "if", "any", "(", "re", ".", "match", "(", "k", ",", "name", ")", "for", "k", "in", "patterns", ")", ":", "\n", "                    ", "matched_patterns", "[", "(", "layer_kind", ",", "patterns", ")", "if", "layer_kind", "else", "patterns", "]", "=", "True", "\n", "if", "isinstance", "(", "v", ",", "tuple", ")", ":", "\n", "                        ", "v", "[", "0", "]", "(", "param", ",", "**", "v", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                        ", "v", "(", "param", ")", "\n", "\n", "", "", "", "", "", "unmatched_patterns", "=", "[", "k", "for", "k", ",", "v", "in", "matched_patterns", ".", "items", "(", ")", "if", "not", "v", "]", "\n", "if", "unmatched_patterns", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.build._build_dataset": [[158, 170], ["dataset_type", "all", "len"], "function", ["None"], ["\"No matches found for these patterns when initialing model '{}':\"", "\n", "\"\\n\\t- {}\\nCheck the model's named parameters: {}\\n\"", ".", "format", "(", "\n", "type", "(", "model", ")", ".", "__name__", ",", "\n", "\"\\n\\t- \"", ".", "join", "(", "str", "(", "x", ")", "for", "x", "in", "unmatched_patterns", ")", ",", "\n", "[", "x", "[", "0", "]", "for", "x", "in", "model", ".", "named_parameters", "(", ")", "]", ",", "\n", ")", "\n", ")", "\n", "\n", "\n", "", "", "def", "_get_model_layers", "(", "model", ",", "by_kind", "=", "False", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.ad12_meddlr.data.build._get_default_dataset_type": [[173, 179], ["None"], "function", ["None"], ["modules", "=", "model", ".", "modules", "(", ")", "\n", "layers", "=", "[", "]", "\n", "for", "module", "in", "modules", ":", "\n", "        ", "has_children", "=", "False", "\n", "for", "_", "in", "module", ".", "children", "(", ")", ":", "\n", "            ", "has_children", "=", "True", "\n", "break", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_recon_train_loader": [[181, 245], ["build.get_recon_dataset_dicts", "meddlr.data.transforms.subsample.build_mask_func", "meddlr.data.transforms.transform.DataTransform", "build._build_dataset", "meddlr.data.samplers.build.build_train_sampler", "torch.utils.data.DataLoader", "ValueError", "build._get_default_dataset_type", "len", "_build_dataset.get_unsupervised_idxs"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.build.get_recon_dataset_dicts", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.build_mask_func", "home.repos.pwc.inspect_result.ad12_meddlr.data.build._build_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.build.build_train_sampler", "home.repos.pwc.inspect_result.ad12_meddlr.data.build._get_default_dataset_type", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_unsupervised_idxs"], ["            ", "layers", ".", "append", "(", "module", ")", "\n", "\n", "", "", "if", "by_kind", ":", "\n", "        ", "layers_by_kind", "=", "defaultdict", "(", "list", ")", "\n", "for", "layer", "in", "layers", ":", "\n", "            ", "layers_by_kind", "[", "get_layer_kind", "(", "type", "(", "layer", ")", ")", "]", ".", "append", "(", "layer", ")", "\n", "", "return", "layers_by_kind", "\n", "", "return", "layers", "\n", "\n", "\n", "", "def", "_to_literal", "(", "x", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "str", ")", ":", "\n", "        ", "v", "=", "x", "\n", "if", "any", "(", "\n", "x", ".", "startswith", "(", "c1", ")", "and", "x", ".", "endswith", "(", "c2", ")", "for", "c1", ",", "c2", "in", "[", "(", "\"(\"", ",", "\")\"", ")", ",", "(", "\"[\"", ",", "\"]\"", ")", ",", "(", "\"{\"", ",", "\"}\"", ")", "]", "\n", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "v", "=", "ast", ".", "literal_eval", "(", "v", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "pass", "\n", "", "", "return", "v", "\n", "", "elif", "isinstance", "(", "x", ",", "Dict", ")", ":", "\n", "        ", "return", "{", "_to_literal", "(", "k", ")", ":", "_to_literal", "(", "v", ")", "for", "k", ",", "v", "in", "x", ".", "items", "(", ")", "}", "\n", "", "elif", "isinstance", "(", "x", ",", "Sequence", ")", ":", "\n", "        ", "return", "type", "(", "x", ")", "(", "_to_literal", "(", "v", ")", "for", "v", "in", "x", ")", "\n", "", "else", ":", "\n", "        ", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_recon_val_loader": [[247, 308], ["build.get_recon_dataset_dicts", "meddlr.data.transforms.subsample.build_mask_func", "meddlr.data.transforms.transform.DataTransform", "build._build_dataset", "meddlr.data.samplers.build.build_val_sampler", "torch.utils.data.DataLoader", "ValueError", "build._get_default_dataset_type"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.build.get_recon_dataset_dicts", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.build_mask_func", "home.repos.pwc.inspect_result.ad12_meddlr.data.build._build_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.build.build_val_sampler", "home.repos.pwc.inspect_result.ad12_meddlr.data.build._get_default_dataset_type"], []], "home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_data_loaders_per_scan": [[310, 348], ["build.get_recon_dataset_dicts", "collections.defaultdict", "list", "len", "cfg.AUG_TRAIN.clone", "cfg.AUG_TRAIN.clone.defrost", "cfg.AUG_TRAIN.clone.freeze", "numpy.arange", "meddlr.data.transforms.subsample.build_mask_func", "meddlr.data.transforms.transform.DataTransform", "build._build_dataset", "torch.utils.data.DataLoader"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.build.get_recon_dataset_dicts", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.subsample.build_mask_func", "home.repos.pwc.inspect_result.ad12_meddlr.data.build._build_dataset"], []], "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData.__init__": [[43, 76], ["slice_dataset.SliceData._init_examples", "enumerate", "dict", "meddlr.data.data_utils.HDF5Manager", "all", "slice_dataset.SliceData.mapping.update"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData._init_examples", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["def", "__init__", "(", "self", ",", "dataset_dicts", ":", "List", "[", "Dict", "]", ",", "transform", ",", "keys", "=", "None", ",", "include_metadata", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dicts (List[Dict]): List of dictionaries. Each dictionary\n                contains information about a single scan in Meddlr format.\n            transform (callable): A callable object that pre-processes the\n                raw data into appropriate form. The transform function should\n                take 'kspace', 'target', 'attributes', 'filename', and 'slice'\n                as inputs. 'target' may be null for test data.\n            include_metadata (bool, optional): If `True`, includes scan metadata:\n                - \"scan_id\"\n                - \"slice_id\"\n        \"\"\"", "\n", "self", ".", "transform", "=", "transform", "\n", "\n", "# Convert dataset dict into slices.", "\n", "# Each slice is tuple of (file name, slice id, is_unsupervised)", "\n", "self", ".", "examples", "=", "self", ".", "_init_examples", "(", "dataset_dicts", ")", "\n", "\n", "# All examples should have the following keys:", "\n", "#   - fname (str): The file name", "\n", "#   - is_unsupervised (bool): If `True`, the example should be treated as unsupervised", "\n", "#   - fixed_acc (float): The fixed acceleration for unsupervised examples.", "\n", "#   - Any other keys required for data loading.", "\n", "for", "idx", ",", "example", "in", "enumerate", "(", "self", ".", "examples", ")", ":", "\n", "            ", "assert", "all", "(", "k", "in", "example", "for", "k", "in", "self", ".", "_REQUIRED_METADATA", ")", ",", "f\"Example {idx}\"", "\n", "\n", "", "self", ".", "mapping", "=", "dict", "(", "self", ".", "_DEFAULT_MAPPING", ")", "\n", "if", "keys", ":", "\n", "            ", "self", ".", "mapping", ".", "update", "(", "keys", ")", "\n", "", "self", ".", "_include_metadata", "=", "include_metadata", "\n", "\n", "self", ".", "_hdf5_manager", "=", "HDF5Manager", "(", "cache", "=", "False", ",", "max_attempts", "=", "5", ",", "wait_time", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData.groups": [[77, 85], ["collections.defaultdict", "enumerate", "_groups[].append", "KeyError", "example.keys"], "methods", ["None"], ["", "def", "groups", "(", "self", ",", "group_by", ")", ":", "\n", "        ", "_groups", "=", "defaultdict", "(", "list", ")", "\n", "for", "idx", ",", "example", "in", "enumerate", "(", "self", ".", "examples", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "_groups", "[", "example", "[", "group_by", "]", "]", ".", "append", "(", "idx", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "raise", "KeyError", "(", "f\"Key {group_by} not found. Use one of {example.keys()}\"", ")", "\n", "", "", "return", "_groups", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData._init_examples": [[86, 119], ["dd.get", "dd.get", "examples.extend", "h5py.File", "h5py.File", "dd.get", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "_init_examples", "(", "self", ",", "dataset_dicts", ")", ":", "\n", "        ", "examples", "=", "[", "]", "\n", "for", "dd", "in", "dataset_dicts", ":", "\n", "            ", "file_path", "=", "dd", "[", "\"file_name\"", "]", "\n", "is_unsupervised", "=", "dd", ".", "get", "(", "\"_is_unsupervised\"", ",", "False", ")", "\n", "acc", "=", "dd", ".", "get", "(", "\"_acceleration\"", ",", "None", ")", "\n", "\n", "if", "\"kspace_size\"", "in", "dd", ":", "\n", "                ", "num_slices", "=", "dd", "[", "\"kspace_size\"", "]", "[", "0", "]", "\n", "shape", "=", "dd", "[", "\"kspace_size\"", "]", "[", "1", ":", "3", "]", "\n", "", "elif", "\"num_slices\"", "in", "dd", ":", "\n", "                ", "num_slices", "=", "dd", "[", "\"num_slices\"", "]", "\n", "with", "h5py", ".", "File", "(", "file_path", ",", "\"r\"", ")", "as", "f", ":", "\n", "                    ", "shape", "=", "f", "[", "\"kspace\"", "]", ".", "shape", "[", "1", ":", "3", "]", "\n", "", "", "else", ":", "\n", "                ", "with", "h5py", ".", "File", "(", "file_path", ",", "\"r\"", ")", "as", "f", ":", "\n", "                    ", "num_slices", "=", "f", "[", "\"kspace\"", "]", ".", "shape", "[", "0", "]", "\n", "shape", "=", "f", "[", "\"kspace\"", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "", "examples", ".", "extend", "(", "\n", "[", "\n", "{", "\n", "\"file_name\"", ":", "file_path", ",", "\n", "\"slice_id\"", ":", "slice_id", ",", "\n", "\"is_unsupervised\"", ":", "is_unsupervised", ",", "\n", "\"fixed_acc\"", ":", "acc", ",", "\n", "\"_metadata\"", ":", "dd", ".", "get", "(", "\"_metadata\"", ",", "{", "}", ")", ",", "\n", "\"inplane_shape\"", ":", "shape", ",", "\n", "}", "\n", "for", "slice_id", "in", "range", "(", "num_slices", ")", "\n", "]", "\n", ")", "\n", "", "return", "examples", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData._load_data": [[120, 135], ["h5manager.temp_open", "h5manager.get", "h5manager.get", "numpy.zeros_like", "h5manager.get"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.temp_open", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "_load_data", "(", "self", ",", "example", ",", "idx", ")", ":", "\n", "        ", "file_path", "=", "example", "[", "\"file_name\"", "]", "\n", "slice_id", "=", "example", "[", "\"slice_id\"", "]", "\n", "\n", "h5manager", "=", "self", ".", "_hdf5_manager", "\n", "with", "h5manager", ".", "temp_open", "(", "file_path", ",", "\"r\"", ")", ":", "\n", "            ", "kspace", "=", "h5manager", ".", "get", "(", "file_path", ",", "self", ".", "mapping", "[", "\"kspace\"", "]", ",", "slice_id", ")", "\n", "target", "=", "h5manager", ".", "get", "(", "file_path", ",", "self", ".", "mapping", "[", "\"target\"", "]", ",", "slice_id", ")", "\n", "maps", "=", "(", "\n", "np", ".", "zeros_like", "(", "target", ")", "\n", "if", "self", ".", "mapping", "[", "\"target\"", "]", "==", "\"reconstruction_rss\"", "\n", "else", "h5manager", ".", "get", "(", "file_path", ",", "self", ".", "mapping", "[", "\"maps\"", "]", ",", "slice_id", ")", "\n", ")", "\n", "\n", "", "return", "{", "\"kspace\"", ":", "kspace", ",", "\"maps\"", ":", "maps", ",", "\"target\"", ":", "target", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData.__getitem__": [[136, 177], ["tuple", "slice_dataset.SliceData._load_data", "slice_dataset.SliceData.transform", "os.path.splitext", "hasattr", "isinstance", "slice_dataset.SliceData.transform.augmentor.get_tfm_gen_params", "len", "os.path.basename"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils._MockHDF5Manager._load_data", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.get_tfm_gen_params"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "example", "=", "self", ".", "examples", "[", "i", "]", "\n", "file_path", ",", "slice_id", ",", "is_unsupervised", ",", "fixed_acc", "=", "tuple", "(", "\n", "example", "[", "k", "]", "for", "k", "in", "[", "\"file_name\"", ",", "\"slice_id\"", ",", "\"is_unsupervised\"", ",", "\"fixed_acc\"", "]", "\n", ")", "\n", "\n", "# TODO: remove this forced check.", "\n", "if", "not", "is_unsupervised", ":", "\n", "            ", "fixed_acc", "=", "None", "\n", "\n", "", "data", "=", "self", ".", "_load_data", "(", "example", ",", "i", ")", "\n", "kspace", "=", "data", "[", "\"kspace\"", "]", "\n", "maps", "=", "data", "[", "\"maps\"", "]", "\n", "target", "=", "data", "[", "\"target\"", "]", "\n", "\n", "fname", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "file_path", ")", ")", "[", "0", "]", "\n", "masked_kspace", ",", "maps", ",", "target", ",", "mean", ",", "std", ",", "norm", "=", "self", ".", "transform", "(", "\n", "kspace", ",", "maps", ",", "target", ",", "fname", ",", "slice_id", ",", "is_unsupervised", ",", "fixed_acc", "\n", ")", "\n", "\n", "vals", "=", "{", "\n", "\"kspace\"", ":", "masked_kspace", ",", "\n", "\"maps\"", ":", "maps", ",", "\n", "\"mean\"", ":", "mean", ",", "\n", "\"std\"", ":", "std", ",", "\n", "\"norm\"", ":", "norm", ",", "\n", "\"is_unsupervised\"", ":", "is_unsupervised", ",", "\n", "}", "\n", "if", "(", "\n", "hasattr", "(", "self", ".", "transform", ",", "\"augmentor\"", ")", "\n", "and", "isinstance", "(", "self", ".", "transform", ",", "DataTransform", ")", "\n", "and", "self", ".", "transform", ".", "augmentor", "is", "not", "None", "\n", ")", ":", "\n", "            ", "scheduler_params", "=", "self", ".", "transform", ".", "augmentor", ".", "get_tfm_gen_params", "(", ")", "\n", "if", "len", "(", "scheduler_params", ")", ":", "\n", "                ", "vals", "[", "\"metrics\"", "]", "=", "{", "\"scheduler\"", ":", "scheduler_params", "}", "\n", "", "", "if", "self", ".", "_include_metadata", ":", "\n", "            ", "vals", "[", "\"metadata\"", "]", "=", "{", "\"scan_id\"", ":", "fname", ",", "\"slice_id\"", ":", "slice_id", "}", "\n", "", "if", "not", "is_unsupervised", ":", "\n", "            ", "vals", "[", "\"target\"", "]", "=", "target", "\n", "", "return", "vals", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData.__len__": [[178, 180], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "examples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData.get_supervised_idxs": [[181, 191], ["enumerate"], "methods", ["None"], ["", "def", "get_supervised_idxs", "(", "self", ")", "->", "List", "[", "int", "]", ":", "\n", "        ", "\"\"\"Returns indices corresponding to supervised examples.\n\n        These indices can be used with ``__getitem__`` to fetch supervised examples.\n\n        Returns:\n            List[int]: The indices corresponding to supervised examples.\n        \"\"\"", "\n", "idxs", "=", "[", "idx", "for", "idx", ",", "x", "in", "enumerate", "(", "self", ".", "examples", ")", "if", "not", "x", "[", "\"is_unsupervised\"", "]", "]", "\n", "return", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData.get_unsupervised_idxs": [[192, 203], ["slice_dataset.SliceData.get_supervised_idxs", "sorted", "set", "set", "range", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_supervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "def", "get_unsupervised_idxs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns indices corresponding to unsupervised examples.\n\n        These indices can be used with ``__getitem__`` to fetch unsupervised examples.\n\n        Returns:\n            List[int]: The indices corresponding to unsupervised examples.\n        \"\"\"", "\n", "supervised_idxs", "=", "self", ".", "get_supervised_idxs", "(", ")", "\n", "unsupervised_idxs", "=", "set", "(", "range", "(", "len", "(", "self", ")", ")", ")", "-", "set", "(", "supervised_idxs", ")", "\n", "return", "sorted", "(", "unsupervised_idxs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils._MockHDF5Manager.__init__": [[10, 15], ["meddlr.data.data_utils.HDF5Manager.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "test_max_attempts", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "test_max_attempts", "=", "test_max_attempts", "\n", "self", ".", "attempt_count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils._MockHDF5Manager._load_data": [[16, 22], ["super()._load_data", "OSError"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils._MockHDF5Manager._load_data"], ["", "def", "_load_data", "(", "self", ",", "file", ",", "key", "=", "None", ",", "sl", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "attempt_count", "<", "self", ".", "test_max_attempts", ":", "\n", "            ", "self", ".", "attempt_count", "+=", "1", "\n", "raise", "OSError", "(", "\"[Errno 5] Can't read data\"", ")", "\n", "\n", "", "return", "super", "(", ")", ".", "_load_data", "(", "file", ",", "key", ",", "sl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils._MockHDF5Manager.reset": [[23, 25], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "attempt_count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils.test_structuring_patches": [[27, 67], ["tuple", "torch.stack", "meddlr.data.data_utils.structure_patches", "torch.all", "torch.stack", "meddlr.data.data_utils.structure_patches", "torch.all", "torch.stack", "meddlr.data.data_utils.structure_patches", "torch.all", "torch.stack", "meddlr.data.data_utils.structure_patches", "torch.all", "torch.randn", "range", "range", "torch.randn", "range", "range", "range", "torch.stack", "torch.stack", "range"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.structure_patches", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.structure_patches", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.structure_patches", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.structure_patches"], ["", "", "def", "test_structuring_patches", "(", ")", ":", "\n", "# Single dimension", "\n", "    ", "d1", "=", "5", "\n", "shape", "=", "(", "6", ",", "7", ",", "8", ")", "\n", "patches", "=", "[", "torch", ".", "randn", "(", "*", "shape", ")", "for", "_", "in", "range", "(", "d1", ")", "]", "\n", "coords", "=", "tuple", "(", "range", "(", "0", ",", "d1", ")", ")", "\n", "\n", "expected", "=", "torch", ".", "stack", "(", "patches", ",", "dim", "=", "0", ")", "\n", "out", "=", "structure_patches", "(", "patches", ",", "coords", ")", "\n", "assert", "out", ".", "shape", "==", "(", "d1", ",", ")", "+", "shape", "\n", "assert", "torch", ".", "all", "(", "out", "==", "expected", ")", "\n", "\n", "expected", "=", "torch", ".", "stack", "(", "patches", ",", "dim", "=", "1", ")", "\n", "out", "=", "structure_patches", "(", "patches", ",", "coords", ",", "dims", "=", "1", ")", "\n", "assert", "(", "\n", "out", ".", "shape", "\n", "==", "(", "\n", "shape", "[", "0", "]", ",", "\n", "d1", ",", "\n", ")", "\n", "+", "shape", "[", "1", ":", "]", "\n", ")", "\n", "assert", "torch", ".", "all", "(", "out", "==", "expected", ")", "\n", "\n", "# Two dimensions", "\n", "d1", ",", "d2", "=", "2", ",", "5", "\n", "shape", "=", "(", "6", ",", "7", ",", "8", ")", "\n", "base_patches", "=", "[", "[", "torch", ".", "randn", "(", "*", "shape", ")", "for", "_", "in", "range", "(", "d2", ")", "]", "for", "_", "in", "range", "(", "d1", ")", "]", "\n", "patches", "=", "[", "y", "for", "x", "in", "base_patches", "for", "y", "in", "x", "]", "\n", "coords", "=", "[", "(", "x", ",", "y", ")", "for", "x", "in", "range", "(", "d1", ")", "for", "y", "in", "range", "(", "d2", ")", "]", "\n", "\n", "expected", "=", "torch", ".", "stack", "(", "[", "torch", ".", "stack", "(", "y", ",", "dim", "=", "0", ")", "for", "y", "in", "base_patches", "]", ",", "dim", "=", "0", ")", "\n", "out", "=", "structure_patches", "(", "patches", ",", "coords", ")", "\n", "assert", "torch", ".", "all", "(", "out", "==", "expected", ")", "\n", "\n", "expected", "=", "torch", ".", "stack", "(", "[", "torch", ".", "stack", "(", "y", ",", "dim", "=", "1", ")", "for", "y", "in", "base_patches", "]", ",", "dim", "=", "0", ")", "\n", "out", "=", "structure_patches", "(", "patches", ",", "coords", ",", "dims", "=", "(", "0", ",", "2", ")", ")", "\n", "assert", "out", ".", "shape", "==", "expected", ".", "shape", "\n", "assert", "out", ".", "shape", "==", "(", "2", ",", "6", ",", "5", ",", "7", ",", "8", ")", "\n", "assert", "torch", ".", "all", "(", "out", "==", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils.test_hdf5_manager_cache": [[69, 101], ["enumerate", "meddlr.data.data_utils.HDF5Manager", "all", "meddlr.data.data_utils.HDF5Manager.files.copy", "all", "meddlr.data.data_utils.HDF5Manager", "numpy.random.choice", "meddlr.data.data_utils.HDF5Manager.get", "numpy.all", "numpy.random.choice", "meddlr.data.data_utils.HDF5Manager.get", "numpy.all", "numpy.random.randn", "len", "meddlr.data.data_utils.HDF5Manager.get", "slice", "slice", "range", "range", "h5py.File", "f.create_dataset", "isinstance", "meddlr.data.data_utils.HDF5Manager.files.values", "data_manager.files.copy.values"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "test_hdf5_manager_cache", "(", "tmpdir", ")", ":", "\n", "    ", "N", "=", "5", "\n", "\n", "files", "=", "[", "tmpdir", "/", "f\"file_{i:03d}.h5\"", "for", "i", "in", "range", "(", "N", ")", "]", "\n", "data", "=", "[", "np", ".", "random", ".", "randn", "(", "10", ",", "10", ")", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "for", "idx", ",", "fpath", "in", "enumerate", "(", "files", ")", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "fpath", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "create_dataset", "(", "\"data\"", ",", "data", "=", "data", "[", "idx", "]", ")", "\n", "\n", "# Auto file open/close.", "\n", "", "", "data_manager", "=", "HDF5Manager", "(", "files", ")", "\n", "assert", "len", "(", "data_manager", ".", "files", ")", "==", "N", "\n", "assert", "all", "(", "isinstance", "(", "f", ",", "h5py", ".", "File", ")", "for", "f", "in", "data_manager", ".", "files", ".", "values", "(", ")", ")", "\n", "all_files", "=", "data_manager", ".", "files", ".", "copy", "(", ")", "\n", "del", "data_manager", "\n", "assert", "all", "(", "not", "f", ".", "id", "for", "f", "in", "all_files", ".", "values", "(", ")", ")", ",", "\"All files should be closed\"", "\n", "\n", "data_manager", "=", "HDF5Manager", "(", "files", ")", "\n", "for", "fpath", "in", "files", ":", "\n", "        ", "file", "=", "data_manager", ".", "get", "(", "fpath", ")", "\n", "assert", "file", "is", "data_manager", ".", "files", "[", "fpath", "]", "\n", "\n", "", "idx", "=", "np", ".", "random", ".", "choice", "(", "N", ")", "\n", "fpath", "=", "files", "[", "idx", "]", "\n", "out", "=", "data_manager", ".", "get", "(", "fpath", ",", "\"data\"", ")", "\n", "assert", "np", ".", "all", "(", "out", "==", "data", "[", "idx", "]", ")", "\n", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "N", ")", "\n", "sl", "=", "(", "slice", "(", "None", ")", ",", "slice", "(", "5", ")", ")", "\n", "fpath", "=", "files", "[", "idx", "]", "\n", "out", "=", "data_manager", ".", "get", "(", "fpath", ",", "\"data\"", ",", "sl", ")", "\n", "assert", "np", ".", "all", "(", "out", "==", "data", "[", "idx", "]", "[", "sl", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_data_utils.test_hdf5_manager_retry": [[103, 125], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "enumerate", "test_data_utils._MockHDF5Manager", "numpy.random.randn", "_MockHDF5Manager.get", "range", "range", "h5py.File", "f.create_dataset", "pytest.raises", "_MockHDF5Manager.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"test_max_attempts\"", ",", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"max_attempts\"", ",", "[", "1", ",", "2", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"cache_files\"", ",", "[", "False", ",", "True", "]", ")", "\n", "def", "test_hdf5_manager_retry", "(", "tmpdir", ",", "test_max_attempts", ",", "max_attempts", ",", "cache_files", ")", ":", "\n", "    ", "N", "=", "1", "\n", "\n", "files", "=", "[", "tmpdir", "/", "f\"file_{i:03d}.h5\"", "for", "i", "in", "range", "(", "N", ")", "]", "\n", "data", "=", "[", "np", ".", "random", ".", "randn", "(", "10", ",", "10", ")", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "for", "idx", ",", "fpath", "in", "enumerate", "(", "files", ")", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "fpath", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "create_dataset", "(", "\"data\"", ",", "data", "=", "data", "[", "idx", "]", ")", "\n", "\n", "", "", "data_manager", "=", "_MockHDF5Manager", "(", "\n", "files", ",", "test_max_attempts", "=", "test_max_attempts", ",", "max_attempts", "=", "max_attempts", ",", "cache", "=", "cache_files", "\n", ")", "\n", "if", "max_attempts", "<=", "test_max_attempts", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "OSError", ")", ":", "\n", "            ", "data_manager", ".", "get", "(", "files", "[", "0", "]", ",", "key", "=", "\"data\"", ",", "patch", "=", "(", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "arr", "=", "data_manager", ".", "get", "(", "files", "[", "0", "]", ",", "key", "=", "\"data\"", ",", "patch", "=", "(", ")", ")", "\n", "assert", "data_manager", ".", "max_attempts", ">", "0", "\n", "assert", "arr", ".", "shape", "==", "(", "10", ",", "10", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_slice_dataset.MockSliceData.__getitem__": [[10, 17], ["None"], "methods", ["None"], ["    ", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "example", "=", "self", ".", "examples", "[", "i", "]", "\n", "vals", "=", "{", "}", "\n", "vals", "[", "\"file_name\"", "]", "=", "example", "[", "\"file_name\"", "]", "\n", "vals", "[", "\"slice_id\"", "]", "=", "example", "[", "\"slice_id\"", "]", "\n", "vals", "[", "\"is_unsupervised\"", "]", "=", "example", "[", "\"is_unsupervised\"", "]", "\n", "return", "vals", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_slice_dataset.TestBuildTrainLoader.test_dataset": [[24, 41], ["meddlr.config.get_cfg", "meddlr.data.build_recon_train_loader", "collections.defaultdict", "collections.defaultdict.items", "len", "len", "len", "scans_to_slices[].append", "set", "set", "set", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_recon_train_loader", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["def", "test_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test number of examples in the dataset\"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "DATASETS", ".", "TRAIN", "=", "(", "self", ".", "_TRAIN_DATASET", ",", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "data_loader", "=", "build_recon_train_loader", "(", "cfg", ")", "\n", "dataset", ":", "SliceData", "=", "data_loader", ".", "dataset", "\n", "\n", "assert", "len", "(", "dataset", ")", "==", "len", "(", "dataset", ".", "examples", ")", "\n", "scan_names", "=", "[", "x", "[", "\"file_name\"", "]", "for", "x", "in", "dataset", ".", "examples", "]", "\n", "assert", "len", "(", "set", "(", "scan_names", ")", ")", "==", "self", ".", "_NUM_SCANS", "\n", "\n", "scans_to_slices", "=", "defaultdict", "(", "list", ")", "\n", "for", "x", "in", "dataset", ".", "examples", ":", "\n", "            ", "scans_to_slices", "[", "x", "[", "\"file_name\"", "]", "]", ".", "append", "(", "x", "[", "\"slice_id\"", "]", ")", "\n", "", "for", "_x", ",", "slice_nums", "in", "scans_to_slices", ".", "items", "(", ")", ":", "\n", "            ", "assert", "set", "(", "slice_nums", ")", "==", "set", "(", "range", "(", "0", ",", "320", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_slice_dataset.TestBuildTrainLoader.test_data_loader": [[42, 60], ["meddlr.config.get_cfg", "meddlr.data.build_recon_train_loader", "collections.defaultdict", "collections.defaultdict.items", "len", "d[].tolist", "zip", "len", "scans_to_slices[].append", "set", "set", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_recon_train_loader", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "", "def", "test_data_loader", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "DATASETS", ".", "TRAIN", "=", "(", "self", ".", "_TRAIN_DATASET", ",", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "cfg", ".", "SOLVER", ".", "TRAIN_BATCH_SIZE", "=", "1", "\n", "data_loader", "=", "build_recon_train_loader", "(", "cfg", ",", "MockSliceData", ")", "\n", "assert", "len", "(", "data_loader", ")", "==", "self", ".", "_NUM_SCANS", "*", "self", ".", "_NUM_SLICES_PER_SCAN", "\n", "\n", "scans_to_slices", "=", "defaultdict", "(", "list", ")", "\n", "for", "d", "in", "data_loader", ":", "\n", "            ", "fnames", "=", "d", "[", "\"file_name\"", "]", "\n", "slice_ids", "=", "d", "[", "\"slice_id\"", "]", ".", "tolist", "(", ")", "\n", "for", "fname", ",", "s_id", "in", "zip", "(", "fnames", ",", "slice_ids", ")", ":", "\n", "                ", "scans_to_slices", "[", "fname", "]", ".", "append", "(", "s_id", ")", "\n", "\n", "", "", "for", "_x", ",", "slice_nums", "in", "scans_to_slices", ".", "items", "(", ")", ":", "\n", "            ", "assert", "set", "(", "slice_nums", ")", "==", "set", "(", "range", "(", "0", ",", "320", ")", ")", "\n", "", "assert", "len", "(", "scans_to_slices", ")", "==", "self", ".", "_NUM_SCANS", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_build.test_filter_by_metadata": [[7, 13], ["meddlr.data.build.get_recon_dataset_dicts", "all", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.build.get_recon_dataset_dicts"], ["def", "test_initialize_model", "(", ")", ":", "\n", "    ", "model", "=", "GeneralizedUNet", "(", "\n", "dimensions", "=", "2", ",", "\n", "in_channels", "=", "1", ",", "\n", "out_channels", "=", "4", ",", "\n", "channels", "=", "(", "4", ",", "8", ",", "16", ")", ",", "\n", "block_order", "=", "(", "\"conv\"", ",", "\"relu\"", ",", "\"conv\"", ",", "\"relu\"", ",", "\"batchnorm\"", ",", "\"dropout\"", ")", ",", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_build.test_num_scans_total": [[15, 45], ["meddlr.data.catalog.DatasetCatalog.get", "meddlr.data.build.get_recon_dataset_dicts", "meddlr.data.build.get_recon_dataset_dicts", "sorted", "len", "orig_flip_angles_to_count.keys", "zip", "zip", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.build.get_recon_dataset_dicts", "home.repos.pwc.inspect_result.ad12_meddlr.data.build.get_recon_dataset_dicts"], ["initialize_model", "(", "\n", "model", ",", "initializers", "=", "{", "\"kind\"", ":", "\"conv\"", ",", "\"patterns\"", ":", "\".*bias\"", ",", "\"initializers\"", ":", "\"zeros_\"", "}", "\n", ")", "\n", "\n", "layers_by_kind", "=", "_get_model_layers", "(", "model", ",", "by_kind", "=", "True", ")", "\n", "for", "layer", "in", "layers_by_kind", "[", "\"conv\"", "]", ":", "\n", "        ", "assert", "torch", ".", "all", "(", "layer", ".", "bias", "==", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.data.test_build.test_limit_data_by_group": [[47, 76], ["meddlr.data.build._limit_data_by_group", "meddlr.data.build._limit_data_by_group", "meddlr.data.build._limit_data_by_group"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.build._limit_data_by_group", "home.repos.pwc.inspect_result.ad12_meddlr.data.build._limit_data_by_group", "home.repos.pwc.inspect_result.ad12_meddlr.data.build._limit_data_by_group"], []], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.register_mrco.load_mrco_json": [[20, 73], ["_PATH_MANAGER.get_local_path", "time.perf_counter", "logger.info", "open", "json.load", "dict", "any", "_load_metadata.append", "meddlr.data.MetadataCatalog.get", "register_mrco._load_metadata", "_PATH_MANAGER.get_local_path", "_PATH_MANAGER.get_local_path", "time.perf_counter", "os.path.join", "dataset_name.startswith", "h5py.File"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.register_mrco._load_metadata", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File"], ["def", "load_mrco_json", "(", "json_file", ":", "str", ",", "image_root", ":", "str", ",", "dataset_name", ":", "str", ")", ":", "\n", "    ", "\"\"\"Load a json file with MRCO's scan annotation format.\n\n    Currently supports reconstruction.\n\n    Args:\n        json_file (str): Full path to the json file in MRCO scan annotation\n            format.\n        image_root (str): The directory where the images in this json file\n            exist.\n        dataset_name (str): The name of the dataset\n            (e.g. mridata_knee_2019_train).\n        cipher_kwargs (Dict[str, Any]): Keyword arguments for loading metadata from\n            cipher(s). See :func:`merge_ciphers_with_dataset_dicts`.\n\n    Returns:\n        List[Dict]: A list of dicts in meddlr standard format.\n\n    Notes:\n        1. This function does not read the image files.\n           The results do not have the \"kspace\", \"target\", or \"maps\" fields.\n    \"\"\"", "\n", "json_file", "=", "_PATH_MANAGER", ".", "get_local_path", "(", "json_file", ")", "\n", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "with", "open", "(", "json_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "f", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"Loading {} takes {:.2f} seconds\"", ".", "format", "(", "json_file", ",", "time", ".", "perf_counter", "(", ")", "-", "start_time", ")", "\n", ")", "\n", "\n", "# TODO: Add any relevant metadata.", "\n", "dataset_dicts", "=", "[", "]", "\n", "for", "d", "in", "data", "[", "\"images\"", "]", ":", "\n", "        ", "dd", "=", "dict", "(", "d", ")", "\n", "if", "image_root", "is", "not", "None", ":", "\n", "            ", "file_name", "=", "_PATH_MANAGER", ".", "get_local_path", "(", "os", ".", "path", ".", "join", "(", "image_root", ",", "d", "[", "\"file_name\"", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "file_name", "=", "_PATH_MANAGER", ".", "get_local_path", "(", "d", "[", "\"file_path\"", "]", ")", "\n", "", "dd", "[", "\"file_name\"", "]", "=", "file_name", "\n", "\n", "# TODO: Clean this up", "\n", "if", "any", "(", "dataset_name", ".", "startswith", "(", "x", ")", "for", "x", "in", "[", "\"stanford_qDESS_knee_2020\"", "]", ")", ":", "\n", "            ", "with", "h5py", ".", "File", "(", "dd", "[", "\"file_name\"", "]", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "dd", "[", "\"kspace_shape\"", "]", "=", "f", "[", "\"kspace\"", "]", ".", "shape", "\n", "\n", "", "", "dataset_dicts", ".", "append", "(", "dd", ")", "\n", "\n", "# Load metadata from metadata file.", "\n", "", "metadata_file", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "metadata_file", "\n", "if", "metadata_file", ":", "\n", "        ", "dataset_dicts", "=", "_load_metadata", "(", "metadata_file", ",", "dataset_dicts", ")", "\n", "\n", "", "return", "dataset_dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.register_mrco.register_mrco_scans": [[75, 99], ["meddlr.data.DatasetCatalog.register", "meddlr.data.MetadataCatalog.get().set", "register_mrco.load_mrco_json", "meddlr.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.register", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.register_mrco.load_mrco_json", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "register_mrco_scans", "(", "name", ",", "metadata", ",", "json_file", ",", "image_root", ":", "str", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Register a dataset in COCO's json annotation format for\n    instance detection, instance segmentation and keypoint detection.\n    (i.e., Type 1 and 2 in http://cocodataset.org/#format-data.\n    `instances*.json` and `person_keypoints*.json` in the dataset).\n\n    This is an example of how to register a new dataset.\n    You can do something similar to this function, to register new datasets.\n\n    Args:\n        name (str): the name that identifies a dataset, e.g. \"coco_2014_train\".\n        metadata (dict): extra metadata associated with this dataset.  You can\n            leave it as an empty dict.\n        json_file (str): path to the json instance annotation file.\n        image_root (str): directory which contains all the images.\n    \"\"\"", "\n", "# 1. register a function which returns dicts", "\n", "DatasetCatalog", ".", "register", "(", "name", ",", "lambda", ":", "load_mrco_json", "(", "json_file", ",", "image_root", ",", "name", ")", ")", "\n", "\n", "# 2. Optionally, add metadata about this dataset,", "\n", "# since they might be useful in evaluation, visualization or logging", "\n", "MetadataCatalog", ".", "get", "(", "name", ")", ".", "set", "(", "\n", "json_file", "=", "json_file", ",", "image_root", "=", "image_root", ",", "evaluator_type", "=", "\"coco\"", ",", "**", "metadata", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.register_mrco._load_metadata": [[102, 124], ["pandas.read_csv", "_PATH_MANAGER.get_local_path", "dd_metadata.to_dict.to_dict", "len", "pd.read_csv.columns.str.contains", "os.path.basename", "list", "dd_metadata.to_dict.keys"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "def", "_load_metadata", "(", "metadata_file", ",", "dataset_dicts", ")", ":", "\n", "    ", "\"\"\"Loads metadata in csv file into dataset dictionaries.\n\n    Args:\n        metadata_file (str): A csv file with metadata.\n        dataset_dicts (List[Dict]): List of dataset dictionaries.\n\n    Returns:\n        dataset_dicts: The dataset dictionaries with \"_metadata\" key.\n            This key maps to the dictionary of metadata.\n    \"\"\"", "\n", "metadata", "=", "pd", ".", "read_csv", "(", "_PATH_MANAGER", ".", "get_local_path", "(", "metadata_file", ")", ")", "\n", "metadata", "=", "metadata", ".", "loc", "[", ":", ",", "~", "metadata", ".", "columns", ".", "str", ".", "contains", "(", "\"^Unnamed\"", ")", "]", "\n", "\n", "for", "dd", "in", "dataset_dicts", ":", "\n", "        ", "dd_metadata", "=", "metadata", "[", "metadata", "[", "\"fname\"", "]", "==", "os", ".", "path", ".", "basename", "(", "dd", "[", "\"file_name\"", "]", ")", "]", "\n", "assert", "len", "(", "dd_metadata", ")", "==", "1", "\n", "dd_metadata", "=", "dd_metadata", ".", "to_dict", "(", "\"index\"", ")", "\n", "dd_metadata", "=", "dd_metadata", "[", "list", "(", "dd_metadata", ".", "keys", "(", ")", ")", "[", "0", "]", "]", "\n", "dd", "[", "\"_metadata\"", "]", "=", "dd_metadata", "\n", "\n", "", "return", "dataset_dicts", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.builtin.register_all_mrco": [[140, 154], ["_PREDEFINED_SPLITS_MRCO.items", "_METADATA_FILES.get", "splits_per_dataset.items", "register_mrco.register_mrco_scans", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.register_mrco.register_mrco_scans"], ["def", "register_all_mrco", "(", "root", "=", "\"data://\"", ")", ":", "\n", "    ", "for", "dataset_name", ",", "splits_per_dataset", "in", "_PREDEFINED_SPLITS_MRCO", ".", "items", "(", ")", ":", "\n", "        ", "metadata_file", "=", "_METADATA_FILES", ".", "get", "(", "dataset_name", ",", "None", ")", "\n", "for", "key", ",", "data", "in", "splits_per_dataset", ".", "items", "(", ")", ":", "\n", "# Assume pre-defined datasets live in `./datasets`.", "\n", "            ", "image_root", ",", "json_file", "=", "data", "\n", "\n", "json_file", "=", "os", ".", "path", ".", "join", "(", "root", ",", "json_file", ")", "if", "\"://\"", "not", "in", "json_file", "else", "json_file", "\n", "image_root", "=", "os", ".", "path", ".", "join", "(", "root", ",", "image_root", ")", "if", "image_root", "is", "not", "None", "else", "None", "\n", "register_mrco_scans", "(", "\n", "key", ",", "\n", "{", "\"metadata_file\"", ":", "metadata_file", "}", ",", "# TODO: add metadata", "\n", "json_file", ",", "# noqa", "\n", "image_root", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.FastMRIDataset.__init__": [[168, 170], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "files", ")", ":", "\n", "        ", "self", ".", "files", "=", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.FastMRIDataset.__getitem__": [[171, 198], ["numpy.zeros", "range", "h5py.File", "numpy.transpose", "format_fastmri.preprocess_slice", "f.attrs.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.preprocess_slice", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "self", ".", "files", "[", "idx", "]", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "kspace_orig", "=", "f", "[", "\"kspace\"", "]", "[", "(", ")", "]", "\n", "im_rss", "=", "f", "[", "\"reconstruction_rss\"", "]", "[", "(", ")", "]", "\n", "xres", ",", "yres", "=", "im_rss", ".", "shape", "[", "1", ":", "3", "]", "# matrix size", "\n", "attrs", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "f", ".", "attrs", ".", "items", "(", ")", "}", "\n", "ismrmrd_header", "=", "f", "[", "\"ismrmrd_header\"", "]", "[", "(", ")", "]", "\n", "\n", "", "num_slices", ",", "num_coils", ",", "num_kx", ",", "num_ky", "=", "kspace_orig", ".", "shape", "\n", "kspace", "=", "np", ".", "zeros", "(", "(", "num_slices", ",", "xres", ",", "yres", ",", "num_coils", ")", ",", "dtype", "=", "np", ".", "complex64", ")", "\n", "im_shape", "=", "(", "xres", ",", "yres", ")", "\n", "\n", "for", "sl", "in", "range", "(", "num_slices", ")", ":", "\n", "            ", "kspace_slice", "=", "kspace_orig", "[", "sl", "]", "# #coils x H x W", "\n", "kspace_slice", "=", "np", ".", "transpose", "(", "kspace_slice", ",", "(", "1", ",", "2", ",", "0", ")", ")", "# H x W x #coils", "\n", "kspace_slice", "=", "preprocess_slice", "(", "kspace_slice", ",", "im_shape", ")", "# H x W x #coils", "\n", "# kspace_slice = np.transpose(kspace_slice, ())  # H x W x #coils", "\n", "kspace", "[", "sl", "]", "=", "kspace_slice", "\n", "\n", "", "return", "{", "\n", "\"file_path\"", ":", "self", ".", "files", "[", "idx", "]", ",", "\n", "\"kspace_orig\"", ":", "kspace_orig", ",", "\n", "\"kspace\"", ":", "kspace", ",", "\n", "\"im_shape\"", ":", "im_shape", ",", "\n", "\"attrs\"", ":", "attrs", ",", "\n", "\"ismrmrd_header\"", ":", "ismrmrd_header", ",", "\n", "\"reconstruction_rss\"", ":", "im_rss", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.FastMRIDataset.__len__": [[200, 202], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.seed_everything": [[98, 110], ["numpy.random.seed", "torch.manual_seed", "torch.cuda.manual_seed_all", "random.seed", "cp.random.seed", "isinstance", "sigpy.Device", "sp.Device.xp.random.seed"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed", "home.repos.pwc.inspect_result.ad12_meddlr.gen.choice.RandomTransformChoice.seed"], ["def", "seed_everything", "(", "device", "=", "None", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "SEED", ")", "\n", "torch", ".", "manual_seed", "(", "SEED", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "SEED", ")", "\n", "random", ".", "seed", "(", "SEED", ")", "\n", "if", "cp", "is", "not", "None", ":", "\n", "        ", "cp", ".", "random", ".", "seed", "(", "SEED", ")", "\n", "", "if", "device", "is", "not", "None", ":", "\n", "        ", "if", "isinstance", "(", "device", ",", "int", ")", ":", "\n", "            ", "device", "=", "sp", ".", "Device", "(", "device", ")", "\n", "", "with", "device", ":", "\n", "            ", "device", ".", "xp", ".", "random", ".", "seed", "(", "SEED", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.is_valid_file": [[112, 116], ["os.path.basename", "os.path.basename.startswith", "os.path.basename.endswith"], "function", ["None"], ["", "", "", "def", "is_valid_file", "(", "fpath", ")", ":", "\n", "    ", "\"\"\"Returns `True` if file corresponds to a valid fastMRI file.\"\"\"", "\n", "fname", "=", "os", ".", "path", ".", "basename", "(", "fpath", ")", "\n", "return", "fname", ".", "startswith", "(", "\"file\"", ")", "and", "fname", ".", "endswith", "(", "\".h5\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.get_files": [[118, 131], ["os.path.isdir", "os.path.join", "NotADirectoryError", "os.listdir", "format_fastmri.is_valid_file", "os.path.splitext"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.is_valid_file"], ["", "def", "get_files", "(", "dir_path", ":", "str", ",", "ignore_missing_dir", "=", "False", ",", "filenames", "=", "None", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "isdir", "(", "dir_path", ")", ":", "\n", "        ", "if", "ignore_missing_dir", ":", "\n", "            ", "return", "[", "]", "\n", "", "else", ":", "\n", "            ", "raise", "NotADirectoryError", "(", "f\"Directory {dir_path} does not exist\"", ")", "\n", "", "", "files", "=", "[", "\n", "os", ".", "path", ".", "join", "(", "dir_path", ",", "x", ")", "\n", "for", "x", "in", "os", ".", "listdir", "(", "dir_path", ")", "\n", "if", "is_valid_file", "(", "x", ")", "\n", "and", "(", "not", "filenames", "or", "x", "in", "filenames", "or", "os", ".", "path", ".", "splitext", "(", "x", ")", "[", "0", "]", "in", "filenames", ")", "\n", "]", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.preprocess_slice": [[133, 163], ["numpy.expand_dims", "meddlr.ops.complex.to_tensor", "meddlr.ops.complex.is_complex", "meddlr.utils.transforms.ifft2", "image_tensor.permute.permute", "meddlr.utils.transforms.complex_center_crop_2d", "image_tensor.permute.permute", "meddlr.utils.transforms.fft2", "meddlr.ops.complex.to_numpy", "torch.view_as_real", "torch.view_as_real.squeeze"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.ifft2", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.complex_center_crop_2d", "home.repos.pwc.inspect_result.ad12_meddlr.utils.transforms.fft2", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_numpy"], ["", "def", "preprocess_slice", "(", "kspace", ",", "im_shape", ")", ":", "\n", "    ", "\"\"\"Pre-process k-space data.\n\n    Args:\n        kspace: Shape `#coils x H x W`\n        im_shape (tuple): Shape to crop to.\n\n    Returns:\n        ndarray: Shape `#coils x H x W`\n    \"\"\"", "\n", "# Pre-process k-space data (PyTorch)", "\n", "#   1. Reconstruct fully sampled image", "\n", "#   2. Crop to (yres, xres)", "\n", "#   3. Take fourier transform", "\n", "# Note this preprocessing technique does not work for", "\n", "# test/challenge images as scans in these datasets are undersampled.", "\n", "kspace", "=", "np", ".", "expand_dims", "(", "kspace", ",", "0", ")", "\n", "kspace_tensor", "=", "cplx", ".", "to_tensor", "(", "kspace", ")", "# (1, 640, 372, 15, 2)", "\n", "if", "cplx", ".", "is_complex", "(", "kspace_tensor", ")", ":", "\n", "# If using pytorch>=1.7, complex tensors are now supported.", "\n", "# This small fix allows for minimal change in code without", "\n", "# a significant computational overhead.", "\n", "        ", "kspace_tensor", "=", "torch", ".", "view_as_real", "(", "kspace_tensor", ")", "\n", "", "image_tensor", "=", "T", ".", "ifft2", "(", "kspace_tensor", ")", "\n", "image_tensor", "=", "image_tensor", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ",", "4", ")", "# (1, 15, 640, 372, 2)", "\n", "image_tensor", "=", "T", ".", "complex_center_crop_2d", "(", "image_tensor", ",", "im_shape", ")", "\n", "image_tensor", "=", "image_tensor", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ",", "4", ")", "# (1, 640, 372, 15, 2)", "\n", "kspace_tensor", "=", "T", ".", "fft2", "(", "image_tensor", ")", "\n", "kspace_slice", "=", "cplx", ".", "to_numpy", "(", "kspace_tensor", ".", "squeeze", "(", "0", ")", ")", "# (640, 372, 15)", "\n", "return", "kspace_slice", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.collate_simple": [[204, 206], ["None"], "function", ["None"], ["", "", "def", "collate_simple", "(", "batch", ":", "list", ")", ":", "\n", "    ", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.process_slice": [[208, 278], ["format_fastmri.seed_everything", "numpy.transpose", "numpy.reshape", "meddlr.ops.complex.to_tensor().unsqueeze", "meddlr.ops.complex.to_tensor().unsqueeze", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel.", "meddlr.ops.complex.to_numpy", "sigpy.Device", "sigpy.mri.app.EspiritCalib().run", "numpy.transpose", "A.squeeze", "isinstance", "cp.asnumpy", "sigpy.mri.app.JsenseRecon().run", "meddlr.ops.complex.to_tensor", "meddlr.ops.complex.to_tensor", "sigpy.mri.app.EspiritCalib", "sigpy.mri.app.JsenseRecon().run", "sigpy.mri.app.JsenseRecon", "sigpy.mri.app.JsenseRecon().run", "ValueError", "sigpy.mri.app.JsenseRecon", "sigpy.mri.app.JsenseRecon"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.seed_everything", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_numpy", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run"], ["", "def", "process_slice", "(", "\n", "kspace", ",", "calib_method", "=", "\"jsense\"", ",", "calib_size", ":", "int", "=", "20", ",", "device", ":", "int", "=", "-", "1", ",", "nmaps", ":", "int", "=", "NUM_EMAPS", "\n", ")", ":", "\n", "    ", "\"\"\"Process 2D multi-coil kspace slice.\n\n    Args:\n        kspace (np.ndarray): The k-space. Shape ``(Ky, Kz, #coils)\n        calib_method (str): The calibration method.\n        calib_size (int): The calibration size.\n        device (int): The device to perform computation on. ``-1`` indicates CPU.\n        nmaps (int): Number of maps to create.\n\n    Returns:\n        image (np.ndarray): The coil-combined image(s). Shape ``(Ky, Kz, #maps)``.\n        maps (np.ndarray): The maps. Shape ``(Ky, Kz, #coils, #maps)``\n    \"\"\"", "\n", "# get data dimensions", "\n", "nky", ",", "nkz", ",", "ncoils", "=", "kspace", ".", "shape", "\n", "\n", "if", "device", "is", "-", "1", ":", "\n", "        ", "device", "=", "sp", ".", "cpu_device", "\n", "", "else", ":", "\n", "        ", "device", "=", "sp", ".", "Device", "(", "device", ")", "\n", "\n", "# Seed everything before processing the slice.", "\n", "", "seed_everything", "(", "device", ")", "\n", "\n", "# compute sensitivity maps (BART)", "\n", "# cmd = f'ecalib -d 0 -S -m {nmaps} -c {crop_value} -r {calib_size}'", "\n", "# maps = bart.bart(1, cmd, kspace[:,:,0,None,:])", "\n", "# maps = np.reshape(maps, (nky, nkz, 1, ncoils, nmaps))", "\n", "\n", "# compute sensitivity maps (SigPy)", "\n", "# TODO: Add support for espirit bart", "\n", "ksp", "=", "np", ".", "transpose", "(", "kspace", ",", "[", "2", ",", "1", ",", "0", "]", ")", "# #coils x Kz x Ky", "\n", "if", "calib_method", "==", "\"espirit\"", ":", "\n", "        ", "maps", "=", "app", ".", "EspiritCalib", "(", "\n", "ksp", ",", "calib_width", "=", "calib_size", ",", "device", "=", "device", ",", "show_pbar", "=", "False", ",", "crop", "=", "0.1", "\n", ")", ".", "run", "(", ")", "\n", "# import pdb; pdb.set_trace()", "\n", "if", "not", "isinstance", "(", "maps", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "maps", "=", "cp", ".", "asnumpy", "(", "maps", ")", "\n", "", "", "elif", "calib_method", "==", "\"jsense\"", ":", "\n", "        ", "maps", "=", "app", ".", "JsenseRecon", "(", "\n", "ksp", ",", "mps_ker_width", "=", "6", ",", "ksp_calib_width", "=", "calib_size", ",", "device", "=", "device", ",", "show_pbar", "=", "False", "\n", ")", ".", "run", "(", ")", "\n", "", "elif", "calib_method", "==", "\"jsense-8\"", ":", "\n", "        ", "maps", "=", "app", ".", "JsenseRecon", "(", "\n", "ksp", ",", "mps_ker_width", "=", "8", ",", "ksp_calib_width", "=", "calib_size", ",", "device", "=", "device", ",", "show_pbar", "=", "False", "\n", ")", ".", "run", "(", ")", "\n", "", "elif", "calib_method", "==", "\"jsense-12\"", ":", "\n", "        ", "maps", "=", "app", ".", "JsenseRecon", "(", "\n", "ksp", ",", "mps_ker_width", "=", "12", ",", "ksp_calib_width", "=", "calib_size", ",", "device", "=", "device", ",", "show_pbar", "=", "False", "\n", ")", ".", "run", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"%s calibration method not implemented...\"", "%", "calib_method", ")", "\n", "", "maps", "=", "np", ".", "reshape", "(", "np", ".", "transpose", "(", "maps", ",", "[", "2", ",", "1", ",", "0", "]", ")", ",", "(", "nky", ",", "nkz", ",", "ncoils", ",", "nmaps", ")", ")", "\n", "\n", "# Convert everything to tensors", "\n", "kspace_tensor", "=", "cplx", ".", "to_tensor", "(", "kspace", ")", ".", "unsqueeze", "(", "0", ")", "# 1 x Ky x Kz x #coils", "\n", "maps_tensor", "=", "cplx", ".", "to_tensor", "(", "maps", ")", ".", "unsqueeze", "(", "0", ")", "# 1 x Ky x Kz x #coils", "\n", "\n", "# Do coil combination using sensitivity maps (PyTorch)", "\n", "A", "=", "SenseModel", "(", "maps_tensor", ")", "\n", "im_tensor", "=", "A", "(", "kspace_tensor", ",", "adjoint", "=", "True", ")", "\n", "\n", "# Convert tensor back to numpy array", "\n", "image", "=", "cplx", ".", "to_numpy", "(", "im_tensor", ".", "squeeze", "(", "0", ")", ")", "\n", "\n", "return", "image", ",", "maps", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.format_train_file": [[280, 357], ["format_fastmri.seed_everything", "os.path.basename", "os.path.join", "_PATH_MANAGER.isfile", "int", "numpy.zeros", "numpy.zeros", "logger.info", "h5py.File", "attrs.items", "silx.dicttoh5", "int", "h5py.File", "round", "torch.no_grad", "tqdm.tqdm", "silx.dicttoh5", "range", "format_fastmri.process_slice", "f.keys", "f[].keys", "f[].keys"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.seed_everything", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.process_slice"], ["", "def", "format_train_file", "(", "\n", "data", ",", "\n", "save_dir", ":", "str", ",", "\n", "calib_method", "=", "\"jsense\"", ",", "\n", "device", ":", "int", "=", "-", "1", ",", "\n", "center_fraction", "=", "0.04", ",", "\n", "recompute", ":", "bool", "=", "False", ",", "\n", "overwrite", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "# Seed everything before processing the slice.", "\n", "    ", "seed_everything", "(", "device", ")", "\n", "\n", "file_path", "=", "data", "[", "\"file_path\"", "]", "\n", "kspace_orig", "=", "data", "[", "\"kspace_orig\"", "]", "\n", "kspace", "=", "data", "[", "\"kspace\"", "]", "\n", "im_shape", "=", "data", "[", "\"im_shape\"", "]", "\n", "xres", ",", "yres", "=", "im_shape", "\n", "attrs", "=", "data", "[", "\"attrs\"", "]", "\n", "ismrmrd_header", "=", "data", "[", "\"ismrmrd_header\"", "]", "\n", "reconstruction_rss", "=", "data", "[", "\"reconstruction_rss\"", "]", "\n", "\n", "# Fixed data. Only overwritten by overwrite=True.", "\n", "# Not written if only `recompute=True`", "\n", "# Data is fixed because it either originates from", "\n", "# fastMRI h5 files or is a standard operation (fourier transform).", "\n", "fixed_data", "=", "{", "\n", "\"ismrmrd_header\"", ":", "ismrmrd_header", ",", "\n", "\"kspace\"", ":", "kspace", ",", "\n", "\"reconstruction_rss\"", ":", "reconstruction_rss", ",", "\n", "}", "\n", "\n", "file_name", "=", "os", ".", "path", ".", "basename", "(", "file_path", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "file_name", ")", "\n", "group_name", "=", "f\"{calib_method}-cf={int(center_fraction*100)}\"", "\n", "\n", "skip_recon", "=", "False", "\n", "recon_data", "=", "None", "\n", "if", "not", "overwrite", "and", "not", "recompute", "and", "_PATH_MANAGER", ".", "isfile", "(", "out_file", ")", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "out_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "skip_recon", "=", "(", "\n", "group_name", "in", "f", ".", "keys", "(", ")", "\n", "and", "\"maps\"", "in", "f", "[", "group_name", "]", ".", "keys", "(", ")", "\n", "and", "\"target\"", "in", "f", "[", "group_name", "]", ".", "keys", "(", ")", "\n", ")", "\n", "\n", "", "", "if", "not", "skip_recon", ":", "\n", "        ", "num_slices", ",", "num_coils", ",", "ky", ",", "kx", "=", "kspace_orig", ".", "shape", "\n", "# yres, xres = image_rss.shape[1:3]  # matrix size", "\n", "calib_size", "=", "int", "(", "round", "(", "center_fraction", "*", "xres", ")", ")", "\n", "\n", "im_shape", "=", "(", "xres", ",", "yres", ")", "\n", "maps", "=", "np", ".", "zeros", "(", "(", "num_slices", ",", "xres", ",", "yres", ",", "num_coils", ",", "NUM_EMAPS", ")", ",", "dtype", "=", "np", ".", "complex64", ")", "\n", "im_truth", "=", "np", ".", "zeros", "(", "(", "num_slices", ",", "xres", ",", "yres", ",", "NUM_EMAPS", ")", ",", "dtype", "=", "np", ".", "complex64", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# Make this parallelized on the gpu.", "\n", "            ", "for", "sl", "in", "tqdm", "(", "range", "(", "num_slices", ")", ")", ":", "\n", "                ", "kspace_slice", "=", "kspace", "[", "sl", "]", "\n", "\n", "im_slice", ",", "maps_slice", "=", "process_slice", "(", "kspace_slice", ",", "calib_method", ",", "calib_size", ",", "device", ")", "\n", "\n", "maps", "[", "sl", "]", "=", "maps_slice", "\n", "im_truth", "[", "sl", "]", "=", "im_slice", "\n", "\n", "", "", "recon_data", "=", "{", "group_name", ":", "{", "\"maps\"", ":", "maps", ",", "\"target\"", ":", "im_truth", "}", "}", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Skipped: {calib_method} reconstruction found\"", ")", "\n", "\n", "", "mode", "=", "\"w\"", "if", "overwrite", "else", "\"a\"", "\n", "with", "h5py", ".", "File", "(", "out_file", ",", "mode", ")", "as", "f", ":", "\n", "# Attributes are always written because they are light.", "\n", "        ", "for", "k", ",", "v", "in", "attrs", ".", "items", "(", ")", ":", "\n", "            ", "f", ".", "attrs", "[", "k", "]", "=", "v", "\n", "\n", "", "silx_dd", ".", "dicttoh5", "(", "fixed_data", ",", "f", ",", "overwrite_data", "=", "overwrite", ")", "\n", "if", "recon_data", ":", "\n", "            ", "silx_dd", ".", "dicttoh5", "(", "recon_data", ",", "f", ",", "overwrite_data", "=", "recompute", "or", "overwrite", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.filter_files": [[359, 396], ["logger.info", "tqdm.tqdm", "logger.info", "os.path.basename", "os.path.join", "_PATH_MANAGER.isfile", "filtered_files.append", "h5py.File", "len", "len", "len", "len", "f.keys", "f[].keys", "f[].keys"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File"], ["", "", "", "def", "filter_files", "(", "files", ":", "Sequence", "[", "str", "]", ",", "save_dir", ":", "str", ",", "calib_method", ":", "str", ")", ":", "\n", "    ", "\"\"\"Filter out files that have already been processed.\n\n    If the expected output h5df file has keys\n    \"{calib_method}/maps\" and \"{calib_method}/target\",\n    the file is assumed to be processed.\n\n    Args:\n        files: Input files to filter through.\n        save_dir: Output directory to search\n        calib_method: Method used for calibration.\n\n    Returns:\n        Sequence[str]: Files that still need to be processed.\n    \"\"\"", "\n", "logger", ".", "info", "(", "\"Filtering out processed files...\"", ")", "\n", "filtered_files", "=", "[", "]", "\n", "for", "file_path", "in", "tqdm", "(", "files", ")", ":", "\n", "        ", "file_name", "=", "os", ".", "path", ".", "basename", "(", "file_path", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "file_name", ")", "\n", "\n", "skip_recon", "=", "False", "\n", "if", "_PATH_MANAGER", ".", "isfile", "(", "out_file", ")", ":", "\n", "            ", "with", "h5py", ".", "File", "(", "out_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "skip_recon", "=", "(", "\n", "calib_method", "in", "f", ".", "keys", "(", ")", "\n", "and", "\"maps\"", "in", "f", "[", "calib_method", "]", ".", "keys", "(", ")", "\n", "and", "\"target\"", "in", "f", "[", "calib_method", "]", ".", "keys", "(", ")", "\n", ")", "\n", "", "", "if", "not", "skip_recon", ":", "\n", "            ", "filtered_files", ".", "append", "(", "file_path", ")", "\n", "\n", "", "", "logger", ".", "info", "(", "\n", "f\"{len(files) - len(filtered_files)}/{len(files)} files are processed. \"", "\n", "f\"{len(filtered_files)} files remaining\"", "\n", ")", "\n", "return", "filtered_files", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.split_files": [[398, 430], ["logger.info", "tqdm.tqdm", "numpy.median", "logger.info", "len", "len", "h5py.File", "sizes.append", "zip", "zip", "len", "len", "numpy.prod", "set", "set", "len", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "def", "split_files", "(", "files", ":", "Sequence", "[", "str", "]", ")", ":", "\n", "    ", "\"\"\"Split files into regular and oversized files.\n\n    Some files are too large for multiprocessing operations.\n    This method partitions files into regular sized files and\n    files that are too large for multiprocessing.\n\n    Args:\n        files (`str(s)`): Input files (from fastmri data) to partition\n\n    Returns:\n        reg_files, oversized_files\n    \"\"\"", "\n", "logger", ".", "info", "(", "\"Finding oversized files...\"", ")", "\n", "sizes", "=", "[", "]", "\n", "for", "file_path", "in", "tqdm", "(", "files", ")", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "file_path", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "sizes", ".", "append", "(", "np", ".", "prod", "(", "f", "[", "\"kspace\"", "]", ".", "shape", ")", ")", "\n", "\n", "", "", "CONSTANT", "=", "1.7", "\n", "ref_size", "=", "np", ".", "median", "(", "sizes", ")", "\n", "reg_files", "=", "[", "file_path", "for", "size", ",", "file_path", "in", "zip", "(", "sizes", ",", "files", ")", "if", "size", "<=", "CONSTANT", "*", "ref_size", "]", "\n", "oversized_files", "=", "[", "\n", "file_path", "for", "size", ",", "file_path", "in", "zip", "(", "sizes", ",", "files", ")", "if", "size", ">", "CONSTANT", "*", "ref_size", "\n", "]", "\n", "\n", "assert", "len", "(", "set", "(", "reg_files", ")", "&", "set", "(", "oversized_files", ")", ")", "==", "0", "\n", "assert", "len", "(", "reg_files", ")", "+", "len", "(", "oversized_files", ")", "==", "len", "(", "files", ")", "\n", "\n", "logger", ".", "info", "(", "f\"{len(oversized_files)}/{len(files)} files are oversized.\"", ")", "\n", "\n", "return", "reg_files", ",", "oversized_files", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.format_data": [[432, 507], ["list", "enumerate", "logger.warn", "itertools.product", "format_fastmri.seed_everything", "os.path.join", "os.path.join", "_PATH_MANAGER.mkdirs", "logger.info", "logger.info", "format_fastmri.get_files", "format_fastmri.split_files", "zip", "format_fastmri.filter_files", "len", "len", "format_fastmri.FastMRIDataset", "torch.utils.data.DataLoader", "time.perf_counter", "enumerate", "logger.info", "len", "datetime.timedelta", "format_fastmri.format_train_file", "logger.error", "failed_cases.append", "int", "str", "time.perf_counter"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.seed_everything", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.get_files", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.split_files", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.filter_files", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.format_train_file"], ["", "def", "format_data", "(", "args", ",", "raw_root", ",", "formatted_root", ")", ":", "\n", "    ", "input_root", "=", "raw_root", "\n", "output_root", "=", "formatted_root", "\n", "if", "args", ".", "recompute", "and", "args", ".", "overwrite", ":", "\n", "        ", "logger", ".", "warn", "(", "\"Ignorning `--recompute` flag. Overwriting all data\"", ")", "\n", "\n", "", "all_setups", "=", "list", "(", "itertools", ".", "product", "(", "args", ".", "split", ",", "args", ".", "calib_method", ",", "args", ".", "center_fraction", ")", ")", "\n", "\n", "failed_cases", "=", "[", "]", "\n", "for", "idx", ",", "(", "split", ",", "calib_method", ",", "center_fraction", ")", "in", "enumerate", "(", "all_setups", ")", ":", "\n", "# Seed everything before processing the slice.", "\n", "        ", "seed_everything", "(", "args", ".", "device", ")", "\n", "\n", "input_dir", "=", "os", ".", "path", ".", "join", "(", "input_root", ",", "CHALLENGES", "[", "args", ".", "challenge", "]", "[", "split", "]", ")", "\n", "output_dir", "=", "os", ".", "path", ".", "join", "(", "output_root", ",", "split", ")", "\n", "_PATH_MANAGER", ".", "mkdirs", "(", "output_dir", ")", "\n", "\n", "logger", ".", "info", "(", "\n", "f\"({idx}/{len(all_setups)}) Processing {split} split, \"", "\n", "f\"{calib_method} method, {center_fraction} center fraction ...\"", "\n", ")", "\n", "logger", ".", "info", "(", "\"=\"", "*", "90", ")", "\n", "\n", "files", "=", "get_files", "(", "input_dir", ",", "filenames", "=", "args", ".", "files", ")", "\n", "if", "not", "args", ".", "overwrite", "and", "not", "args", ".", "recompute", ":", "\n", "            ", "files", "=", "filter_files", "(", "files", ",", "output_dir", ",", "calib_method", ")", "\n", "", "if", "len", "(", "files", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "reg_files", ",", "oversized_files", "=", "split_files", "(", "files", ")", "\n", "\n", "for", "files", ",", "num_workers", "in", "zip", "(", "[", "reg_files", ",", "oversized_files", "]", ",", "[", "args", ".", "num_workers", ",", "0", "]", ")", ":", "\n", "            ", "num_files", "=", "len", "(", "files", ")", "\n", "if", "num_files", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "dataset", "=", "FastMRIDataset", "(", "files", ")", "\n", "data_loader", "=", "DataLoader", "(", "\n", "dataset", ",", "\n", "shuffle", "=", "False", ",", "\n", "batch_size", "=", "1", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "collate_simple", ",", "\n", ")", "\n", "eta", "=", "None", "\n", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "for", "idx", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "                ", "data", "=", "data", "[", "0", "]", "\n", "if", "idx", ">", "0", ":", "\n", "                    ", "eta", "=", "datetime", ".", "timedelta", "(", "\n", "seconds", "=", "int", "(", "(", "time", ".", "perf_counter", "(", ")", "-", "start_time", ")", "/", "idx", "*", "(", "num_files", "-", "idx", ")", ")", "\n", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"Processing [{}/{}] {} {}\"", ".", "format", "(", "\n", "idx", "+", "1", ",", "\n", "num_files", ",", "\n", "data", "[", "\"file_path\"", "]", ",", "\n", "\"- ETA: {}\"", ".", "format", "(", "str", "(", "eta", ")", ")", "if", "eta", "is", "not", "None", "else", "\"\"", ",", "\n", ")", "\n", ")", "\n", "\n", "try", ":", "\n", "                    ", "format_train_file", "(", "\n", "data", ",", "\n", "output_dir", ",", "\n", "calib_method", "=", "calib_method", ",", "\n", "device", "=", "args", ".", "device", ",", "\n", "center_fraction", "=", "center_fraction", ",", "\n", "recompute", "=", "args", ".", "recompute", ",", "\n", "overwrite", "=", "args", ".", "overwrite", ",", "\n", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                    ", "logger", ".", "error", "(", "\"Failed to format {}\"", ".", "format", "(", "e", ")", ")", "\n", "failed_cases", ".", "append", "(", "data", "[", "\"file_path\"", "]", ")", "\n", "", "", "", "", "return", "failed_cases", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.create_dev_split": [[509, 544], ["collections.defaultdict", "sorted", "utils.data_partition.approximately_split_weighted", "sorted", "sorted", "len", "collections.defaultdict.keys", "len", "list", "len", "len", "h5py.File", "patient_ids[].append", "set", "set", "set", "set"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition.approximately_split_weighted", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "def", "create_dev_split", "(", "files", ",", "seed", ",", "split_percentages", "=", "(", "0.8", ",", "0.2", ")", ")", ":", "\n", "    ", "\"\"\"Split files into two splits (train/val).\n\n    Data is split by patients to avoid overlap of patients between\n    different datasets.\n\n    Returns:\n        Tuple[List, List]: Train and validation files.\n            Both are sorted by filename\n    \"\"\"", "\n", "assert", "len", "(", "split_percentages", ")", "==", "2", "\n", "patient_ids", "=", "defaultdict", "(", "list", ")", "\n", "for", "fpath", "in", "files", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "fpath", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "patient_ids", "[", "f", ".", "attrs", "[", "\"patient_id\"", "]", "]", ".", "append", "(", "fpath", ")", "\n", "\n", "# Weight by the number of files they correspond to.", "\n", "", "", "patient_ids_list", "=", "sorted", "(", "patient_ids", ".", "keys", "(", ")", ")", "\n", "patient_weights", "=", "[", "len", "(", "patient_ids", "[", "pid", "]", ")", "for", "pid", "in", "patient_ids_list", "]", "\n", "\n", "train_patient_ids", ",", "val_patient_ids", "=", "dp", ".", "approximately_split_weighted", "(", "\n", "patient_ids_list", ",", "\n", "list", "(", "split_percentages", ")", ",", "\n", "weights", "=", "patient_weights", ",", "\n", "balance", "=", "\"greedy\"", ",", "\n", "buffer", "=", "0.005", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "assert", "len", "(", "set", "(", "train_patient_ids", ")", "&", "set", "(", "val_patient_ids", ")", ")", "==", "0", "\n", "\n", "train_files", "=", "sorted", "(", "[", "x", "for", "pid", "in", "train_patient_ids", "for", "x", "in", "patient_ids", "[", "pid", "]", "]", ")", "\n", "val_files", "=", "sorted", "(", "[", "x", "for", "pid", "in", "val_patient_ids", "for", "x", "in", "patient_ids", "[", "pid", "]", "]", ")", "\n", "assert", "len", "(", "set", "(", "train_files", ")", "&", "set", "(", "val_files", ")", ")", "==", "0", "\n", "\n", "return", "train_files", ",", "val_files", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.create_mini_split": [[546, 586], ["collections.defaultdict", "sorted", "utils.data_partition.approximately_split_weighted", "sorted", "sorted", "sorted", "len", "collections.defaultdict.keys", "len", "list", "len", "len", "len", "len", "len", "len", "h5py.File", "patient_ids[].append", "set", "set", "set", "set", "set", "set", "set", "set", "set", "set", "set", "set"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.data_partition.approximately_split_weighted", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["", "def", "create_mini_split", "(", "files", ",", "seed", ",", "split_percentages", "=", "(", "0.55", ",", "0.15", ",", "0.3", ")", ")", ":", "\n", "    ", "\"\"\"Split files into three splits (train/val/test).\n\n    Data is split by patients to avoid overlap of patients between\n    different datasets.\n\n    Returns:\n        Tuple[List, List]: Train and validation files.\n            Both are sorted by filename\n    \"\"\"", "\n", "assert", "len", "(", "split_percentages", ")", "==", "3", "\n", "patient_ids", "=", "defaultdict", "(", "list", ")", "\n", "for", "fpath", "in", "files", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "fpath", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "patient_ids", "[", "f", ".", "attrs", "[", "\"patient_id\"", "]", "]", ".", "append", "(", "fpath", ")", "\n", "\n", "# Weight by the number of files they correspond to.", "\n", "", "", "patient_ids_list", "=", "sorted", "(", "patient_ids", ".", "keys", "(", ")", ")", "\n", "patient_weights", "=", "[", "len", "(", "patient_ids", "[", "pid", "]", ")", "for", "pid", "in", "patient_ids_list", "]", "\n", "\n", "train_patient_ids", ",", "val_patient_ids", ",", "test_patient_ids", "=", "dp", ".", "approximately_split_weighted", "(", "\n", "patient_ids_list", ",", "\n", "list", "(", "split_percentages", ")", ",", "\n", "weights", "=", "patient_weights", ",", "\n", "balance", "=", "\"greedy\"", ",", "\n", "buffer", "=", "0.005", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "assert", "len", "(", "set", "(", "train_patient_ids", ")", "&", "set", "(", "val_patient_ids", ")", ")", "==", "0", "\n", "assert", "len", "(", "set", "(", "train_patient_ids", ")", "&", "set", "(", "test_patient_ids", ")", ")", "==", "0", "\n", "assert", "len", "(", "set", "(", "val_patient_ids", ")", "&", "set", "(", "test_patient_ids", ")", ")", "==", "0", "\n", "\n", "train_files", "=", "sorted", "(", "[", "x", "for", "pid", "in", "train_patient_ids", "for", "x", "in", "patient_ids", "[", "pid", "]", "]", ")", "\n", "val_files", "=", "sorted", "(", "[", "x", "for", "pid", "in", "val_patient_ids", "for", "x", "in", "patient_ids", "[", "pid", "]", "]", ")", "\n", "test_files", "=", "sorted", "(", "[", "x", "for", "pid", "in", "test_patient_ids", "for", "x", "in", "patient_ids", "[", "pid", "]", "]", ")", "\n", "assert", "len", "(", "set", "(", "train_files", ")", "&", "set", "(", "val_files", ")", ")", "==", "0", "\n", "assert", "len", "(", "set", "(", "train_files", ")", "&", "set", "(", "test_files", ")", ")", "==", "0", "\n", "assert", "len", "(", "set", "(", "val_files", ")", "&", "set", "(", "test_files", ")", ")", "==", "0", "\n", "\n", "return", "train_files", ",", "val_files", ",", "test_files", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.format_annotations": [[588, 668], ["CHALLENGES[].items", "ann_files.items", "sorted", "format_fastmri.create_dev_split", "getpass.getuser", "time.strftime", "time.strftime", "logger.info", "logger.info", "os.path.join", "os.path.dirname", "_PATH_MANAGER.mkdirs", "dict", "split_info[].format", "len", "len", "sum", "logger.info", "format_fastmri.get_files", "format_fastmri.create_mini_split", "ValueError", "_PATH_MANAGER.get_local_path", "image_data.append", "open", "json.dump", "os.path.join", "h5py.File", "[].split", "os.path.basename", "os.path.basename().split", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.create_dev_split", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.get_files", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.create_mini_split", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.dump", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File"], ["", "def", "format_annotations", "(", "args", ",", "raw_root", ",", "formatted_root", ",", "base_ann_dir", ")", ":", "\n", "    ", "ann_method", "=", "args", ".", "method", "\n", "\n", "# Formatted 1-to-1 files with the original fastMRI repositories.", "\n", "# Sort files to get deterministic behavior.", "\n", "formatted_files", "=", "{", "}", "\n", "formatted_to_raw_files", "=", "{", "}", "# noqa: F841", "\n", "for", "split", ",", "fastmri_subdir", "in", "CHALLENGES", "[", "args", ".", "challenge", "]", ".", "items", "(", ")", ":", "# noqa: B007", "\n", "        ", "if", "ann_method", "in", "(", "\"mini\"", ",", ")", "and", "split", "!=", "\"val\"", ":", "\n", "# only need val split for mini dataset", "\n", "            ", "continue", "\n", "", "formatted_files", "[", "split", "]", "=", "sorted", "(", "\n", "get_files", "(", "os", ".", "path", ".", "join", "(", "formatted_root", ",", "split", ")", ",", "ignore_missing_dir", "=", "True", ")", "\n", ")", "\n", "# for fpath in formatted_files[split]:", "\n", "#     fname = os.path.basename(fpath)", "\n", "#     raw_file = os.path.join(raw_root, fastmri_subdir, fname)", "\n", "#     assert os.path.isfile(raw_file), f\"{raw_file} is not a file\"", "\n", "#     assert raw_file not in formatted_to_raw_files, f\"{raw_file} double occurrence\"", "\n", "#     formatted_to_raw_files[fpath] = raw_file", "\n", "\n", "", "if", "ann_method", "in", "(", "\"dev\"", ",", "\"toy-dev\"", ")", ":", "\n", "# Toy dev dataset takes first 5 scans and splits into train/val datasets", "\n", "        ", "if", "ann_method", "==", "\"toy-dev\"", ":", "\n", "            ", "formatted_files", "[", "\"train\"", "]", "=", "formatted_files", "[", "\"train\"", "]", "[", ":", "5", "]", "\n", "", "train_files", ",", "val_files", "=", "create_dev_split", "(", "formatted_files", "[", "\"train\"", "]", ",", "args", ".", "seed", ")", "\n", "test_files", "=", "formatted_files", "[", "\"val\"", "]", "\n", "ann_files", "=", "{", "\"train\"", ":", "train_files", ",", "\"val\"", ":", "val_files", ",", "\"test\"", ":", "test_files", "}", "\n", "version", "=", "f\"{args.version}-dev\"", "\n", "", "elif", "ann_method", "in", "(", "\"mini\"", ",", ")", ":", "\n", "# Split fastMRI val set into train/val/test. Called the mini split.", "\n", "        ", "train_files", ",", "val_files", ",", "test_files", "=", "create_mini_split", "(", "formatted_files", "[", "\"val\"", "]", ",", "args", ".", "seed", ")", "\n", "ann_files", "=", "{", "\"train\"", ":", "train_files", ",", "\"val\"", ":", "val_files", ",", "\"test\"", ":", "test_files", "}", "\n", "version", "=", "f\"mini-{args.version}\"", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Annotation method {ann_method} is not supported\"", ")", "\n", "\n", "", "info_template", "=", "{", "\n", "\"contributor\"", ":", "getpass", ".", "getuser", "(", ")", ",", "\n", "\"description\"", ":", "\"fastMRI {} Dataset - {}\"", ",", "\n", "\"year\"", ":", "time", ".", "strftime", "(", "\"%Y\"", ")", ",", "\n", "\"date_created\"", ":", "time", ".", "strftime", "(", "\"%Y-%m-%d %H-%M-%S %Z\"", ")", ",", "\n", "\"version\"", ":", "version", ",", "\n", "}", "\n", "\n", "for", "split", ",", "files", "in", "ann_files", ".", "items", "(", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Processing {split} split...\"", ")", "\n", "logger", ".", "info", "(", "\"============================\"", ")", "\n", "\n", "ann_file", "=", "os", ".", "path", ".", "join", "(", "base_ann_dir", ",", "f\"{version}/{split}.json\"", ")", "\n", "ann_dir", "=", "os", ".", "path", ".", "dirname", "(", "_PATH_MANAGER", ".", "get_local_path", "(", "ann_file", ")", ")", "\n", "_PATH_MANAGER", ".", "mkdirs", "(", "ann_dir", ")", "\n", "image_data", "=", "[", "]", "\n", "for", "formatted", "in", "files", ":", "\n", "            ", "with", "h5py", ".", "File", "(", "formatted", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "patient_id", "=", "f", ".", "attrs", "[", "\"patient_id\"", "]", "\n", "acquisition", "=", "f", ".", "attrs", "[", "\"acquisition\"", "]", "\n", "num_slices", "=", "f", "[", "\"kspace\"", "]", ".", "shape", "[", "0", "]", "\n", "", "scan_id", "=", "os", ".", "path", ".", "basename", "(", "formatted", ")", ".", "split", "(", "\".h5\"", ")", "[", "0", "]", ".", "split", "(", "\"file\"", ")", "[", "-", "1", "]", "\n", "image_data", ".", "append", "(", "\n", "{", "\n", "\"file_name\"", ":", "os", ".", "path", ".", "basename", "(", "formatted", ")", ",", "\n", "# \"file_path\": formatted,", "\n", "\"scan_id\"", ":", "scan_id", ",", "\n", "\"patient_id\"", ":", "patient_id", ",", "\n", "\"acquisition\"", ":", "acquisition", ",", "\n", "\"num_slices\"", ":", "num_slices", ",", "\n", "}", "\n", ")", "\n", "\n", "", "split_info", "=", "dict", "(", "info_template", ")", "\n", "split_info", "[", "\"description\"", "]", "=", "split_info", "[", "\"description\"", "]", ".", "format", "(", "args", ".", "challenge", ",", "split", ")", "\n", "data", "=", "{", "\"info\"", ":", "split_info", ",", "\"images\"", ":", "image_data", "}", "\n", "\n", "num_scans", "=", "len", "(", "image_data", ")", "\n", "num_subjects", "=", "len", "(", "{", "x", "[", "\"patient_id\"", "]", "for", "x", "in", "image_data", "}", ")", "\n", "num_slices", "=", "sum", "(", "x", "[", "\"num_slices\"", "]", "for", "x", "in", "image_data", ")", "\n", "logger", ".", "info", "(", "f\"Summary: {num_scans} scans, {num_subjects} subjects, {num_slices} slices\"", ")", "\n", "with", "open", "(", "ann_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "data", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.add_shared_args": [[670, 687], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "tuple", "CHALLENGES.keys"], "function", ["None"], ["", "", "", "def", "add_shared_args", "(", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "    ", "parser", ".", "add_argument", "(", "\n", "\"--challenge\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "tuple", "(", "CHALLENGES", ".", "keys", "(", ")", ")", ",", "\n", "help", "=", "\"FastMRI challenge type\"", ",", "\n", ")", "\n", "# TODO: Update help comments.", "\n", "parser", ".", "add_argument", "(", "\n", "\"--raw\"", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Raw data directory (default: datasets/data/fastmri/raw/{challenge})\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--formatted\"", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Formatted data directory (default: datasets/data/fastmri/{challenge})\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.main": [[690, 773], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_subparsers", "parser.add_subparsers.add_parser", "format_fastmri.add_shared_args", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "parser.add_subparsers.add_parser", "format_fastmri.add_shared_args", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "argparse.ArgumentParser.parse_args", "_PATH_MANAGER.get_local_path", "_PATH_MANAGER.get_local_path", "meddlr.utils.logger.setup_logger", "logger.info", "ValueError", "os.path.join", "os.path.join", "format_fastmri.format_data", "open", "f.writelines", "_PATH_MANAGER.get_local_path", "format_fastmri.format_annotations", "ValueError", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.add_shared_args", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.add_shared_args", "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.setup_logger", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.format_data", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_fastmri.format_annotations"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Data preparation\"", ")", "\n", "subparsers", "=", "parser", ".", "add_subparsers", "(", "title", "=", "\"sub-commands\"", ",", "dest", "=", "\"subcommand\"", ",", "required", "=", "True", ")", "\n", "\n", "format_parser", "=", "subparsers", ".", "add_parser", "(", "\"format\"", ",", "help", "=", "\"Format fastMRI dataset\"", ")", "\n", "add_shared_args", "(", "format_parser", ")", "\n", "format_parser", ".", "add_argument", "(", "\n", "\"--calib-method\"", ",", "\n", "choices", "=", "RECON_METHODS", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "default", "=", "[", "\"jsense-8\"", "]", ",", "\n", "help", "=", "\"Sensitivity map estimation method (default: espirit)\"", ",", "\n", ")", "\n", "format_parser", ".", "add_argument", "(", "\n", "\"--center-fraction\"", ",", "\n", "choices", "=", "[", "0.04", ",", "0.08", ",", "0.3", "]", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "default", "=", "[", "0.04", "]", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "\"Center fraction for computing sensitivity maps\"", ",", "\n", ")", "\n", "format_parser", ".", "add_argument", "(", "\n", "\"--split\"", ",", "\n", "choices", "=", "SPLITS", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "default", "=", "SPLITS", ",", "\n", "help", "=", "f\"Dataset split(s) (default: {SPLITS})\"", ",", "\n", ")", "\n", "format_parser", ".", "add_argument", "(", "\n", "\"--files\"", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Specific files to format. This should be the basename of the file\"", ",", "\n", ")", "\n", "format_parser", ".", "add_argument", "(", "\n", "\"--device\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "-", "1", ",", "\n", "help", "=", "\"Device on which to run sensitivity calibration step.\"", ",", "\n", ")", "\n", "format_parser", ".", "add_argument", "(", "\n", "\"--num-workers\"", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "\"Number of workers to use.\"", "\n", ")", "\n", "format_parser", ".", "add_argument", "(", "\n", "\"--recompute\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"Recompute sensitivity maps and target image. Only overwrites these two fields\"", ",", "\n", ")", "\n", "format_parser", ".", "add_argument", "(", "\"--overwrite\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Overwrite full file.\"", ")", "\n", "\n", "annotate_parser", "=", "subparsers", ".", "add_parser", "(", "\"annotate\"", ",", "help", "=", "\"Create annotation json files\"", ")", "\n", "add_shared_args", "(", "annotate_parser", ")", "\n", "annotate_parser", ".", "add_argument", "(", "\"--version\"", ",", "type", "=", "str", ",", "required", "=", "True", ",", "help", "=", "\"Annotation version\"", ")", "\n", "annotate_parser", ".", "add_argument", "(", "\n", "\"--seed\"", ",", "type", "=", "int", ",", "default", "=", "1000", ",", "help", "=", "\"Random seed (default: 1000)\"", "\n", ")", "\n", "annotate_parser", ".", "add_argument", "(", "\n", "\"--method\"", ",", "required", "=", "True", ",", "choices", "=", "ANN_METHODS", ",", "help", "=", "\"Annotation split method\"", "\n", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "not", "args", ".", "subcommand", ":", "\n", "        ", "raise", "ValueError", "(", "\"No subcommand specified\"", ")", "\n", "\n", "", "if", "not", "args", ".", "raw", ":", "\n", "        ", "args", ".", "raw", "=", "os", ".", "path", ".", "join", "(", "OUTPUT_DIR", ",", "\"raw\"", ",", "args", ".", "challenge", ")", "\n", "", "raw_root", "=", "_PATH_MANAGER", ".", "get_local_path", "(", "args", ".", "raw", ")", "\n", "if", "not", "args", ".", "formatted", ":", "\n", "        ", "args", ".", "formatted", "=", "os", ".", "path", ".", "join", "(", "OUTPUT_DIR", ",", "args", ".", "challenge", ")", "\n", "", "formatted_root", "=", "_PATH_MANAGER", ".", "get_local_path", "(", "args", ".", "formatted", ")", "\n", "\n", "setup_logger", "(", "formatted_root", ",", "name", "=", "_FILE_NAME", ")", "\n", "logger", ".", "info", "(", "\"Args:\\n{}\"", ".", "format", "(", "args", ")", ")", "\n", "\n", "if", "args", ".", "subcommand", "==", "\"format\"", ":", "\n", "        ", "failed_cases", "=", "format_data", "(", "args", ",", "raw_root", ",", "formatted_root", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "formatted_root", ",", "\"failed_cases.txt\"", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "writelines", "(", "\"{}\\n\"", ".", "format", "(", "line", ")", "for", "line", "in", "failed_cases", ")", "\n", "", "", "elif", "args", ".", "subcommand", "==", "\"annotate\"", ":", "\n", "        ", "ann_dir", "=", "_PATH_MANAGER", ".", "get_local_path", "(", "os", ".", "path", ".", "join", "(", "ANN_DIR", ",", "args", ".", "challenge", ")", ")", "\n", "format_annotations", "(", "args", ",", "raw_root", ",", "formatted_root", ",", "ann_dir", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Subcommand {args.subcommand} not valid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.download_mridata_org_dataset": [[56, 76], ["os.path.isdir", "open().read().splitlines", "logger.warning", "os.makedirs", "logger.info", "open().read", "mridata.download", "os.path.exists", "open"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.cfl.read", "home.repos.pwc.inspect_result.ad12_meddlr.utils.path.AnnotationsHandler.download", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["def", "download_mridata_org_dataset", "(", "file_name", ",", "dir_output", ",", "overwrite", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"Download datasets from mridata.org.\n\n    Args:\n        file_name (str): Path to mridata file containing uuids for files to\n            download.\n        dir_output (str): Directory path to save all data.\n    \"\"\"", "\n", "if", "os", ".", "path", ".", "isdir", "(", "dir_output", ")", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"Downloading data mridata.org to existing directory {}...\"", ".", "format", "(", "dir_output", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "os", ".", "makedirs", "(", "dir_output", ")", "\n", "logger", ".", "info", "(", "\"Downloading data from mridata.org to {}...\"", ".", "format", "(", "dir_output", ")", ")", "\n", "\n", "", "uuids", "=", "open", "(", "file_name", ")", ".", "read", "(", ")", ".", "splitlines", "(", ")", "\n", "for", "uuid", "in", "uuids", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "\"{}/{}.h5\"", ".", "format", "(", "dir_output", ",", "uuid", ")", ")", "or", "overwrite", ":", "\n", "            ", "mridata", ".", "download", "(", "uuid", ",", "folder", "=", "dir_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.ismrmrd_to_np": [[78, 111], ["logger.debug", "ismrmrd.Dataset", "ismrmrd.xsd.CreateFromDocument", "numpy.diag", "numpy.zeros", "ismrmrd.Dataset.number_of_acquisitions", "tqdm.tqdm", "ismrmrd.Dataset.close", "utils.fftc.fftc", "fftc.fftc.astype", "ismrmrd.Dataset.read_xml_header", "ismrmrd.Dataset.read_array", "numpy.sqrt", "logger.debug", "range", "ismrmrd.Dataset.read_acquisition", "numpy.matmul", "numpy.ones", "numpy.sum", "numpy.np.complex64"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.close", "home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.fftc", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.matmul"], ["", "", "", "def", "ismrmrd_to_np", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Read ISMRMRD data file to numpy array.\"\"\"", "\n", "logger", ".", "debug", "(", "\"Loading file {}...\"", ".", "format", "(", "filename", ")", ")", "\n", "dataset", "=", "ismrmrd", ".", "Dataset", "(", "filename", ",", "create_if_needed", "=", "False", ")", "\n", "header", "=", "ismrmrd", ".", "xsd", ".", "CreateFromDocument", "(", "dataset", ".", "read_xml_header", "(", ")", ")", "\n", "num_kx", "=", "header", ".", "encoding", "[", "0", "]", ".", "encodedSpace", ".", "matrixSize", ".", "x", "\n", "num_ky", "=", "header", ".", "encoding", "[", "0", "]", ".", "encodingLimits", ".", "kspace_encoding_step_1", ".", "maximum", "\n", "num_slices", "=", "header", ".", "encoding", "[", "0", "]", ".", "encodingLimits", ".", "slice", ".", "maximum", "+", "1", "\n", "num_channels", "=", "header", ".", "acquisitionSystemInformation", ".", "receiverChannels", "\n", "\n", "try", ":", "\n", "        ", "rec_std", "=", "dataset", ".", "read_array", "(", "\"rec_std\"", ",", "0", ")", "\n", "rec_weight", "=", "1.0", "/", "(", "rec_std", "**", "2", ")", "\n", "rec_weight", "=", "np", ".", "sqrt", "(", "rec_weight", "/", "np", ".", "sum", "(", "rec_weight", ")", ")", "\n", "logger", ".", "debug", "(", "\"  Using rec std...\"", ")", "\n", "", "except", "Exception", ":", "\n", "        ", "rec_weight", "=", "np", ".", "ones", "(", "num_channels", ")", "\n", "", "opt_mat", "=", "np", ".", "diag", "(", "rec_weight", ")", "\n", "kspace", "=", "np", ".", "zeros", "(", "[", "num_channels", ",", "num_slices", ",", "num_ky", ",", "num_kx", "]", ",", "dtype", "=", "np", ".", "complex64", ")", "\n", "num_acq", "=", "dataset", ".", "number_of_acquisitions", "(", ")", "\n", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "num_acq", ")", ")", ":", "\n", "        ", "acq", "=", "dataset", ".", "read_acquisition", "(", "i", ")", "\n", "i_ky", "=", "acq", ".", "idx", ".", "kspace_encode_step_1", "# pylint: disable=E1101", "\n", "# i_kz = acq.idx.kspace_encode_step_2 # pylint: disable=E1101", "\n", "i_slice", "=", "acq", ".", "idx", ".", "slice", "# pylint: disable=E1101", "\n", "data", "=", "np", ".", "matmul", "(", "opt_mat", ".", "T", ",", "acq", ".", "data", ")", "\n", "kspace", "[", ":", ",", "i_slice", ",", "i_ky", ",", ":", "]", "=", "data", "*", "(", "(", "-", "1", ")", "**", "i_slice", ")", "\n", "\n", "", "dataset", ".", "close", "(", ")", "\n", "kspace", "=", "fftc", ".", "fftc", "(", "kspace", ",", "axis", "=", "1", ")", "\n", "\n", "return", "kspace", ".", "astype", "(", "np", ".", "complex64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.ismrmrd_to_npy": [[113, 131], ["os.path.isdir", "sorted", "logger.info", "logger.warning", "os.makedirs", "logger.info", "os.listdir", "os.path.join", "os.path.join", "os.path.splitext", "format_mridata_org.ismrmrd_to_np", "numpy.save", "os.path.exists", "ismrmrd_to_np.astype"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.ismrmrd_to_np", "home.repos.pwc.inspect_result.ad12_meddlr.utils.cluster.Cluster.save"], ["", "def", "ismrmrd_to_npy", "(", "dir_input", ",", "dir_output", ",", "overwrite", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"Convert ISMRMRD files to npy files\"\"\"", "\n", "if", "os", ".", "path", ".", "isdir", "(", "dir_output", ")", ":", "\n", "        ", "logger", ".", "warning", "(", "\"Writing npy data to existing directory {}...\"", ".", "format", "(", "dir_output", ")", ")", "\n", "", "else", ":", "\n", "        ", "os", ".", "makedirs", "(", "dir_output", ")", "\n", "logger", ".", "info", "(", "\"Writing npy data to {}...\"", ".", "format", "(", "dir_output", ")", ")", "\n", "\n", "", "filelist", "=", "sorted", "(", "os", ".", "listdir", "(", "dir_input", ")", ")", "\n", "\n", "logger", ".", "info", "(", "\"Converting files from ISMRMD to npy...\"", ")", "\n", "for", "filename", "in", "filelist", ":", "\n", "        ", "file_input", "=", "os", ".", "path", ".", "join", "(", "dir_input", ",", "filename", ")", "\n", "filebase", "=", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "0", "]", "\n", "file_output", "=", "os", ".", "path", ".", "join", "(", "dir_output", ",", "filebase", "+", "\".npy\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "file_output", ")", "or", "overwrite", ":", "\n", "            ", "kspace", "=", "ismrmrd_to_np", "(", "file_input", ")", "\n", "np", ".", "save", "(", "file_output", ",", "kspace", ".", "astype", "(", "np", ".", "complex64", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.process_slice": [[133, 174], ["numpy.transpose", "numpy.reshape", "meddlr.ops.complex.to_tensor().unsqueeze", "meddlr.ops.complex.to_tensor().unsqueeze", "meddlr.forward.SenseModel", "meddlr.forward.SenseModel.", "meddlr.ops.complex.to_numpy", "sigpy.Device", "sigpy.mri.app.EspiritCalib().run", "numpy.transpose", "A.squeeze", "sigpy.mri.app.JsenseRecon().run", "ValueError", "meddlr.ops.complex.to_tensor", "meddlr.ops.complex.to_tensor", "sigpy.mri.app.EspiritCalib", "sigpy.mri.app.JsenseRecon"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_numpy", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run", "home.repos.pwc.inspect_result.ad12_meddlr.None.setup.UploadCommand.run", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.to_tensor"], ["", "", "", "def", "process_slice", "(", "kspace", ",", "calib_method", "=", "\"jsense\"", ",", "calib_size", ":", "int", "=", "20", ",", "device", ":", "int", "=", "-", "1", ")", ":", "\n", "# get data dimensions", "\n", "    ", "nky", ",", "nkz", ",", "ncoils", "=", "kspace", ".", "shape", "\n", "\n", "# ESPIRiT parameters", "\n", "nmaps", "=", "1", "\n", "\n", "if", "device", "is", "-", "1", ":", "\n", "        ", "device", "=", "sp", ".", "cpu_device", "\n", "", "else", ":", "\n", "        ", "device", "=", "sp", ".", "Device", "(", "device", ")", "\n", "\n", "# compute sensitivity maps (BART)", "\n", "# cmd = f'ecalib -d 0 -S -m {nmaps} -c {crop_value} -r {calib_size}'", "\n", "# maps = bart.bart(1, cmd, kspace[:,:,0,None,:])", "\n", "# maps = np.reshape(maps, (nky, nkz, 1, ncoils, nmaps))", "\n", "\n", "# compute sensitivity maps (SigPy)", "\n", "", "ksp", "=", "np", ".", "transpose", "(", "kspace", ",", "[", "2", ",", "1", ",", "0", "]", ")", "# #coils x Kz x Ky", "\n", "if", "calib_method", "==", "\"espirit\"", ":", "\n", "        ", "maps", "=", "app", ".", "EspiritCalib", "(", "ksp", ",", "calib_width", "=", "calib_size", ",", "device", "=", "device", ",", "show_pbar", "=", "False", ")", ".", "run", "(", ")", "\n", "", "elif", "calib_method", "==", "\"jsense\"", ":", "\n", "        ", "maps", "=", "app", ".", "JsenseRecon", "(", "\n", "ksp", ",", "ksp_calib_width", "=", "calib_size", ",", "device", "=", "device", ",", "show_pbar", "=", "False", "\n", ")", ".", "run", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"%s calibration method not implemented...\"", "%", "calib_method", ")", "\n", "", "maps", "=", "np", ".", "reshape", "(", "np", ".", "transpose", "(", "maps", ",", "[", "2", ",", "1", ",", "0", "]", ")", ",", "(", "nky", ",", "nkz", ",", "ncoils", ",", "nmaps", ")", ")", "\n", "\n", "# Convert everything to tensors", "\n", "kspace_tensor", "=", "cplx", ".", "to_tensor", "(", "kspace", ")", ".", "unsqueeze", "(", "0", ")", "# 1 x Ky x Kz x #coils", "\n", "maps_tensor", "=", "cplx", ".", "to_tensor", "(", "maps", ")", ".", "unsqueeze", "(", "0", ")", "# 1 x Ky x Kz x #coils", "\n", "\n", "# Do coil combination using sensitivity maps (PyTorch)", "\n", "A", "=", "SenseModel", "(", "maps_tensor", ")", "\n", "im_tensor", "=", "A", "(", "kspace_tensor", ",", "adjoint", "=", "True", ")", "\n", "\n", "# Convert tensor back to numpy array", "\n", "image", "=", "cplx", ".", "to_numpy", "(", "im_tensor", ".", "squeeze", "(", "0", ")", ")", "\n", "\n", "return", "image", ",", "maps", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.convert_to_h5": [[176, 268], ["time.perf_counter", "len", "os.makedirs", "enumerate", "os.path.join", "logger.info", "utils.fftc.ifftc", "np.squeeze.astype", "numpy.transpose", "numpy.zeros", "numpy.zeros", "os.path.splitext", "os.path.isfile", "logger.info", "datetime.timedelta", "numpy.squeeze", "numpy.squeeze", "torch.no_grad", "h5py.File", "f.create_dataset", "f.create_dataset", "f.create_dataset", "os.path.basename", "len", "numpy.load", "format_mridata_org.ismrmrd_to_np", "functools.partial", "range", "tqdm.tqdm", "len", "int", "multiprocessing.Pool", "pool.imap", "range", "format_mridata_org.process_slice", "str", "range", "time.perf_counter"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.fft.ifftc", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.ismrmrd_to_np", "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.process_slice"], ["", "def", "convert_to_h5", "(", "\n", "file_paths", ",", "\n", "dir_output", ",", "\n", "calib_method", ":", "str", "=", "\"jsense\"", ",", "\n", "calib_size", ":", "int", "=", "20", ",", "\n", "device", ":", "int", "=", "-", "1", ",", "\n", "num_workers", ":", "int", "=", "1", ",", "\n", "is_input_numpy", ":", "bool", "=", "False", ",", "\n", "overwrite", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Convert ismrmrd files to h5 format suitable for meddlr library.\n\n    Currently, sensitivity maps are computed over full volume. Images are\n    reconstructed per slice\n\n    Args:\n        file_paths: Paths to ismrmrd files.\n        dir_output: Output dir where to store data.\n        calib: Calibration region shape in all spatial dimensions.\n        is_input_numpy (bool, optional): If `True`, file paths point to numpy\n            files storing kspace. In this case, data will be loaded from\n            numpy files rather than recomputed.\n        overwrite (bool): Overwrite existing files.\n    \"\"\"", "\n", "eta", "=", "None", "\n", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "num_files", "=", "len", "(", "file_paths", ")", "\n", "os", ".", "makedirs", "(", "dir_output", ",", "exist_ok", "=", "True", ")", "\n", "for", "idx", ",", "fp", "in", "enumerate", "(", "file_paths", ")", ":", "\n", "        ", "fname", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "fp", ")", ")", "[", "0", "]", "\n", "h5_file", "=", "os", ".", "path", ".", "join", "(", "dir_output", ",", "\"{}.h5\"", ".", "format", "(", "fname", ")", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "h5_file", ")", "and", "not", "overwrite", ":", "\n", "            ", "logger", ".", "info", "(", "\n", "\"Skipping [{}/{}] {} - hdf5 file found\"", ".", "format", "(", "idx", "+", "1", ",", "len", "(", "file_paths", ")", ",", "fp", ")", "\n", ")", "\n", "continue", "\n", "\n", "", "if", "idx", ">", "0", ":", "\n", "            ", "eta", "=", "datetime", ".", "timedelta", "(", "\n", "seconds", "=", "int", "(", "(", "time", ".", "perf_counter", "(", ")", "-", "start_time", ")", "/", "idx", "*", "(", "num_files", "-", "idx", ")", ")", "\n", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"Processing [{}/{}] {} {}\"", ".", "format", "(", "\n", "idx", "+", "1", ",", "\n", "len", "(", "file_paths", ")", ",", "\n", "fp", ",", "\n", "\"- ETA: {}\"", ".", "format", "(", "str", "(", "eta", ")", ")", "if", "eta", "is", "not", "None", "else", "\"\"", ",", "\n", ")", "\n", ")", "\n", "if", "is_input_numpy", ":", "\n", "            ", "kspace", "=", "np", ".", "squeeze", "(", "np", ".", "load", "(", "fp", ")", ")", "\n", "", "else", ":", "\n", "            ", "kspace", "=", "np", ".", "squeeze", "(", "ismrmrd_to_np", "(", "fp", ")", ")", "# C x Z x Y x X", "\n", "\n", "", "shape_x", "=", "kspace", ".", "shape", "[", "-", "1", "]", "\n", "shape_y", "=", "kspace", ".", "shape", "[", "-", "2", "]", "\n", "shape_z", "=", "kspace", ".", "shape", "[", "-", "3", "]", "\n", "num_coils", "=", "kspace", ".", "shape", "[", "-", "4", "]", "\n", "num_maps", "=", "1", "\n", "\n", "kspace", "=", "fftc", ".", "ifftc", "(", "kspace", ",", "axis", "=", "-", "1", ")", "\n", "kspace", "=", "kspace", ".", "astype", "(", "np", ".", "complex64", ")", "\n", "\n", "kspace", "=", "np", ".", "transpose", "(", "kspace", ",", "(", "3", ",", "2", ",", "1", ",", "0", ")", ")", "# X x Y x Z x C", "\n", "\n", "images", "=", "np", ".", "zeros", "(", "(", "shape_x", ",", "shape_y", ",", "shape_z", ",", "num_maps", ")", ",", "dtype", "=", "np", ".", "complex64", ")", "\n", "maps", "=", "np", ".", "zeros", "(", "(", "shape_x", ",", "shape_y", ",", "shape_z", ",", "num_coils", ",", "num_maps", ")", ",", "dtype", "=", "np", ".", "complex64", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "num_workers", ">", "0", ":", "\n", "                ", "kspace_sliced", "=", "[", "kspace", "[", "x", "]", "for", "x", "in", "range", "(", "shape_x", ")", "]", "\n", "func", "=", "functools", ".", "partial", "(", "\n", "process_slice", ",", "calib_method", "=", "calib_method", ",", "calib_size", "=", "calib_size", ",", "device", "=", "device", "\n", ")", "\n", "with", "mp", ".", "Pool", "(", "num_workers", ")", "as", "pool", ":", "\n", "                    ", "info", "=", "pool", ".", "imap", "(", "kspace_sliced", ",", "func", ")", "\n", "", "for", "x", "in", "range", "(", "shape_x", ")", ":", "\n", "                    ", "im_slice", ",", "maps_slice", "=", "info", "[", "x", "]", "\n", "images", "[", "x", "]", "=", "im_slice", "\n", "maps", "[", "x", "]", "=", "maps_slice", "\n", "", "", "else", ":", "\n", "                ", "for", "x", "in", "tqdm", "(", "range", "(", "shape_x", ")", ")", ":", "\n", "                    ", "im_slice", ",", "maps_slice", "=", "process_slice", "(", "\n", "kspace", "[", "x", "]", ",", "calib_method", ",", "calib_size", ",", "device", "\n", ")", "\n", "\n", "images", "[", "x", "]", "=", "im_slice", "\n", "maps", "[", "x", "]", "=", "maps_slice", "\n", "\n", "", "", "", "with", "h5py", ".", "File", "(", "h5_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "create_dataset", "(", "\"kspace\"", ",", "data", "=", "kspace", ")", "\n", "f", ".", "create_dataset", "(", "\"maps\"", ",", "data", "=", "maps", ")", "\n", "f", ".", "create_dataset", "(", "\"target\"", ",", "data", "=", "images", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.format_mridata_org.write_ann_file": [[270, 291], ["sorted", "image_data.append", "open", "json.dump", "h5py.File", "getpass.getuser", "time.strftime", "time.strftime", "os.listdir", "x.endswith", "os.path.join"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.dump", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.File"], ["", "", "", "def", "write_ann_file", "(", "ann_file", ",", "h5_dir", ",", "split", ",", "**", "kwargs", ")", ":", "\n", "    ", "files", "=", "sorted", "(", "x", "for", "x", "in", "os", ".", "listdir", "(", "h5_dir", ")", "if", "x", ".", "endswith", "(", "\".h5\"", ")", ")", "\n", "\n", "image_data", "=", "[", "]", "\n", "for", "fname", "in", "files", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "os", ".", "path", ".", "join", "(", "h5_dir", ",", "fname", ")", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "kspace_size", "=", "f", "[", "\"kspace\"", "]", ".", "shape", "\n", "", "image_data", ".", "append", "(", "{", "\"file_name\"", ":", "fname", ",", "\"kspace_size\"", ":", "kspace_size", "}", ")", "\n", "\n", "", "data", "=", "{", "\n", "\"info\"", ":", "{", "\n", "\"contributor\"", ":", "getpass", ".", "getuser", "(", ")", ",", "\n", "\"description\"", ":", "\"2019 MRIData.org Knee Dataset - {}\"", ".", "format", "(", "split", ")", ",", "\n", "\"year\"", ":", "time", ".", "strftime", "(", "\"%Y\"", ")", ",", "\n", "\"date_created\"", ":", "time", ".", "strftime", "(", "\"%Y-%m-%d %H-%M-%S %Z\"", ")", ",", "\n", "\"version\"", ":", "\"v1.0.0\"", ",", "\n", "}", ",", "\n", "\"images\"", ":", "image_data", ",", "\n", "}", "\n", "with", "open", "(", "ann_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "data", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.datasets.test_register_mrco.test_load_metadata_from_csv": [[6, 21], ["meddlr.data.DatasetCatalog.get", "all"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["def", "test_load_metadata_from_csv", "(", ")", ":", "\n", "    ", "\"\"\"\n    Tests that for main datasets, we can load metadata from corresponding csv file.\n    \"\"\"", "\n", "datasets_to_test", "=", "[", "\n", "\"fastMRI_knee_multicoil_v0.0.1\"", ",", "\n", "\"fastMRI_brain_multicoil_dev\"", ",", "\n", "\"mridata_knee_2019\"", ",", "\n", "]", "\n", "\n", "for", "dataset", "in", "datasets_to_test", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"val\"", ",", "\"test\"", "]", ":", "\n", "            ", "dataset_split", "=", "f\"{dataset}_{split}\"", "\n", "dataset_dicts", "=", "DatasetCatalog", ".", "get", "(", "dataset_split", ")", "\n", "assert", "all", "(", "\"_metadata\"", "in", "dd", "for", "dd", "in", "dataset_dicts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.build.build_train_sampler": [[13, 68], ["meddlr.data.samplers.sampler.AlternatingSampler", "meddlr.data.samplers.group_sampler.GroupSampler", "meddlr.data.samplers.group_sampler.AlternatingGroupSampler", "ValueError", "torch.utils.data.DistributedSampler"], "function", ["None"], ["META_ARCH_REGISTRY", ".", "__doc__", "=", "\"\"\"\nRegistry for meta-architectures, i.e. the whole model.\n\nThe registered object will be called with `obj(cfg)`\nand expected to return a `nn.Module` object.\n\"\"\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "\n", "def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "return", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "\n", "\n", "", "def", "initialize_model", "(", "model", ":", "nn", ".", "Module", ",", "initializers", ":", "Union", "[", "Dict", ",", "Tuple", "]", ")", ":", "\n", "    ", "\"\"\"Initialize the model.\n\n    This function initializes the model using the initialization method\n    specified in ``initializers``.\n\n    ``initializers`` should be a sequence of dicts, where each dict\n    defines the layer type (optional), regex pattern of the parameter\n    name (optional), or the dict. The dict has the following keys:\n\n        * 'kind' (str, optional): The layer kind to apply this (e.g. 'conv', 'norm')\n        * 'patterns' (Tuple[str] | str, optional): The regex patterns of the\n                parameters to use initializer on. If not specified, all parameters\n                of\n        * 'initializers' (Sequence[Callable | str]): The initializers to use on the\n                parameters. These should be called as ``initializer(param)``.\n                These values should be 1:1 with the values in ``'patterns'``.\n\n    Args:\n        model (nn.Model): The model to initialize. Parameters will be fetched\n            with ``model.named_parameters()``.\n        initializers (Dict[str, Union[str, Callable]] | Tuple[str]):\n            See above.\n    \"\"\"", "\n", "_kind_kwd", "=", "\"kind\"", "\n", "_pattern_kwd", "=", "\"patterns\"", "\n", "_init_kwd", "=", "\"initializers\"", "\n", "\n", "if", "isinstance", "(", "initializers", ",", "Dict", ")", ":", "\n", "        ", "initializers", "=", "[", "initializers", "]", "\n", "\n", "# Backwards compatibility with pattern-only initialization.", "\n", "", "if", "isinstance", "(", "initializers", ",", "Sequence", ")", "and", "not", "any", "(", "isinstance", "(", "x", ",", "Dict", ")", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "assert", "len", "(", "initializers", ")", "%", "2", "==", "0", ",", "\"Sequence of regex_to_init must be even\"", "\n", "initializers", "=", "[", "\n", "{", "_pattern_kwd", ":", "k", ",", "_init_kwd", ":", "v", "}", "for", "k", ",", "v", "in", "zip", "(", "initializers", "[", ":", ":", "2", "]", ",", "initializers", "[", "1", ":", ":", "2", "]", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.build.build_val_sampler": [[70, 102], ["meddlr.data.samplers.group_sampler.GroupSampler", "meddlr.data.samplers.group_sampler.DistributedGroupSampler"], "function", ["None"], ["# Convert string values to python literals.", "\n", "", "initializers", "=", "_to_literal", "(", "initializers", ")", "\n", "\n", "if", "not", "all", "(", "\n", "isinstance", "(", "x", ",", "Dict", ")", "or", "(", "isinstance", "(", "x", ",", "Sequence", ")", "and", "len", "(", "x", ")", "==", "2", ")", "for", "x", "in", "initializers", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"All initializers must either be a dict or sequence of 2 elements \"", "\n", "\"(pattern, initializer). Got:\\n\\t{}\"", ".", "format", "(", "initializers", ")", "\n", ")", "\n", "\n", "", "initializers", ":", "List", "[", "Dict", "]", "=", "[", "\n", "{", "_pattern_kwd", ":", "x", "[", "0", "]", ",", "_init_kwd", ":", "x", "[", "1", "]", "}", "if", "isinstance", "(", "x", ",", "Sequence", ")", "else", "x", "\n", "for", "x", "in", "initializers", "\n", "]", "\n", "matched_patterns", "=", "{", "}", "\n", "for", "init_cfg", "in", "initializers", ":", "\n", "        ", "pattern", "=", "init_cfg", ".", "pop", "(", "_pattern_kwd", ",", "None", ")", "\n", "if", "pattern", "is", "None", ":", "\n", "            ", "pattern", "=", "(", "\".*\"", ",", ")", "\n", "", "elif", "not", "isinstance", "(", "pattern", ",", "Sequence", ")", "or", "isinstance", "(", "pattern", ",", "str", ")", ":", "\n", "            ", "pattern", "=", "(", "pattern", ",", ")", "\n", "\n", "", "init_method", "=", "init_cfg", ".", "pop", "(", "_init_kwd", ")", "\n", "if", "not", "isinstance", "(", "init_method", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "init_method", "=", "(", "init_method", ",", ")", "\n", "\n", "", "if", "len", "(", "pattern", ")", "!=", "len", "(", "init_method", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Got {} pattern(s) but {} initializer(s):\\n\\t\"", "\n", "\"Patterns: {}\\n\\tInitializers: {}\"", ".", "format", "(", "\n", "len", "(", "pattern", ")", ",", "len", "(", "init_method", ")", ",", "pattern", ",", "init_method", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.sampler.AlternatingSampler.__init__": [[23, 90], ["torch.utils.data.Sampler.__init__", "dataset.get_supervised_idxs", "dataset.get_unsupervised_idxs", "torch.tensor", "torch.tensor", "int", "int", "int", "int", "int", "ValueError", "ValueError", "ValueError", "torch.Generator().set_state", "torch.Generator().manual_seed", "numpy.lcm", "len", "len", "len", "len", "len", "len", "torch.random.get_rng_state", "len", "len", "len", "len", "torch.Generator", "torch.Generator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_supervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_unsupervised_idxs"], ["def", "__init__", "(", "\n", "self", ",", "dataset", ",", "T_s", ":", "int", ",", "T_us", ":", "int", ",", "indices", ":", "Sequence", "[", "int", "]", "=", "None", ",", "seed", ":", "int", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset: dataset to sample from. Must have methods\n                `get_supervised_idxs()` and `get_unsupervised_idxs()`\n            T_s (int): Period for returning supervised examples\n            T_us (int): Period for returning unsupervised examples\n            indices (Sequence[int], optional): Indices in the dataset to consider.\n                If specified, only these indices will be iterated over.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "dataset", ")", "\n", "\n", "supervised_idxs", "=", "dataset", ".", "get_supervised_idxs", "(", ")", "\n", "unsupervised_idxs", "=", "dataset", ".", "get_unsupervised_idxs", "(", ")", "\n", "if", "indices", "is", "not", "None", ":", "\n", "            ", "supervised_idxs", "=", "[", "x", "for", "x", "in", "supervised_idxs", "if", "x", "in", "indices", "]", "\n", "unsupervised_idxs", "=", "[", "x", "for", "x", "in", "unsupervised_idxs", "if", "x", "in", "indices", "]", "\n", "", "self", ".", "_supervised_idxs", "=", "torch", ".", "tensor", "(", "supervised_idxs", ")", "\n", "self", ".", "_unsupervised_idxs", "=", "torch", ".", "tensor", "(", "unsupervised_idxs", ")", "\n", "\n", "if", "len", "(", "self", ".", "_unsupervised_idxs", ")", "==", "0", "or", "len", "(", "self", ".", "_supervised_idxs", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"AlternatingSampler can only be used for \"", "\n", "\"semi-supervised training. \"", "\n", "\"Dataset must have both supervised/unsupervised examples\"", "\n", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "_supervised_idxs", ")", "%", "T_s", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Period T_s must be a perfect divisor of \"", "\n", "\"the number of supervised indices. \"", "\n", "\"Got {} supervised indices, and T_s={}\"", ".", "format", "(", "len", "(", "self", ".", "_supervised_idxs", ")", ",", "T_s", ")", "\n", ")", "\n", "", "if", "len", "(", "self", ".", "_unsupervised_idxs", ")", "%", "T_s", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Period T_us must be a perfect divisor of \"", "\n", "\"the number of unsupervised indices. \"", "\n", "\"Got {} unsupervised indices, and T_us={}\"", ".", "format", "(", "\n", "len", "(", "self", ".", "_unsupervised_idxs", ")", ",", "T_us", "\n", ")", "\n", ")", "\n", "\n", "", "self", ".", "T_s", "=", "T_s", "\n", "self", ".", "T_us", "=", "T_us", "\n", "\n", "if", "seed", "is", "None", ":", "\n", "            ", "rng", "=", "torch", ".", "Generator", "(", ")", ".", "set_state", "(", "torch", ".", "random", ".", "get_rng_state", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "rng", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "seed", ")", "\n", "", "self", ".", "_rng", "=", "rng", "\n", "\n", "# The least common multiple between the number of", "\n", "# supervised block and number of unsupervised blocks in single pass.", "\n", "# num_blocks = num_examples / num_period", "\n", "num_blocks_supervised", "=", "int", "(", "len", "(", "self", ".", "_supervised_idxs", ")", "/", "T_s", ")", "\n", "num_blocks_unsupervised", "=", "int", "(", "len", "(", "self", ".", "_unsupervised_idxs", ")", "/", "T_us", ")", "\n", "self", ".", "_lcm", "=", "int", "(", "np", ".", "lcm", "(", "num_blocks_supervised", ",", "num_blocks_unsupervised", ")", ")", "\n", "# The sampler is determined by how many blocks of each data type", "\n", "# (supervised/unsupervised) are returned.", "\n", "# Number of passes indicates how many times we have to go through", "\n", "# the dataset based on the least common multiple.", "\n", "num_passes_supervised", "=", "int", "(", "self", ".", "_lcm", "/", "num_blocks_supervised", ")", "\n", "num_passes_unsupervised", "=", "int", "(", "self", ".", "_lcm", "/", "num_blocks_unsupervised", ")", "\n", "self", ".", "_num_samples_sup", "=", "num_passes_supervised", "*", "len", "(", "self", ".", "_supervised_idxs", ")", "# noqa", "\n", "self", ".", "_num_samples_unsup", "=", "num_passes_unsupervised", "*", "len", "(", "self", ".", "_unsupervised_idxs", ")", "# noqa", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.sampler.AlternatingSampler.get_indices": [[91, 101], ["sampler.AlternatingSampler._build_idx", "sampler.AlternatingSampler._build_idx", "torch.cat().reshape", "idxs.tolist.tolist.tolist", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.sampler.AlternatingSampler._build_idx", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.sampler.AlternatingSampler._build_idx"], ["", "def", "get_indices", "(", "self", ",", "as_list", "=", "False", ")", ":", "\n", "        ", "s_idxs", "=", "self", ".", "_build_idx", "(", "self", ".", "_supervised_idxs", ",", "self", ".", "T_s", ",", "self", ".", "_num_samples_sup", ")", "\n", "us_idxs", "=", "self", ".", "_build_idx", "(", "self", ".", "_unsupervised_idxs", ",", "self", ".", "T_us", ",", "self", ".", "_num_samples_unsup", ")", "\n", "\n", "# TODO: Add parameter to choose whether to start with supervised or", "\n", "# unsupervised data.", "\n", "idxs", "=", "torch", ".", "cat", "(", "[", "s_idxs", ",", "us_idxs", "]", ",", "dim", "=", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "if", "as_list", ":", "\n", "            ", "idxs", "=", "idxs", ".", "tolist", "(", ")", "\n", "", "return", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.sampler.AlternatingSampler.__len__": [[102, 104], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_num_samples_sup", "+", "self", ".", "_num_samples_unsup", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.sampler.AlternatingSampler.__iter__": [[105, 107], ["iter", "sampler.AlternatingSampler.get_indices"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.sampler.AlternatingSampler.get_indices"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "get_indices", "(", "as_list", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.sampler.AlternatingSampler._build_idx": [[108, 118], ["int", "torch.cat", "idxs[].reshape", "len", "len", "torch.randperm", "len", "range"], "methods", ["None"], ["", "def", "_build_idx", "(", "self", ",", "idxs", ":", "torch", ".", "Tensor", ",", "T", ":", "int", ",", "num_samples", ":", "int", ")", ":", "\n", "        ", "assert", "num_samples", "%", "len", "(", "idxs", ")", "==", "0", "\n", "num_passes", "=", "int", "(", "num_samples", "/", "len", "(", "idxs", ")", ")", "\n", "\n", "perm_idxs", "=", "torch", ".", "cat", "(", "\n", "[", "torch", ".", "randperm", "(", "len", "(", "idxs", ")", ",", "generator", "=", "self", ".", "_rng", ")", "for", "_", "in", "range", "(", "num_passes", ")", "]", "\n", ")", "\n", "\n", "idxs", "=", "idxs", "[", "perm_idxs", "]", ".", "reshape", "(", "-", "1", ",", "T", ")", "\n", "return", "idxs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.GroupSampler.__init__": [[24, 101], ["torch.utils.data.Sampler.__init__", "logging.getLogger", "group_sampler.GroupSampler._build_batches", "ValueError", "logging.getLogger.warning", "group_sampler._build_groups", "torch.Generator().set_state", "torch.Generator().manual_seed", "len", "len", "group_sampler._build_groups", "torch.random.get_rng_state", "torch.cat().tolist", "group_sampler._build_groups", "torch.Generator", "torch.Generator", "_build_groups.items", "_build_groups.items", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._build_batches", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler._build_groups", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler._build_groups", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler._build_groups", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dataset", ",", "\n", "batch_by", ":", "Any", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "None", ",", "\n", "as_batch_sampler", ":", "bool", "=", "False", ",", "\n", "drop_last", ":", "bool", "=", "False", ",", "\n", "shuffle", ":", "bool", "=", "False", ",", "\n", "seed", ":", "int", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset: dataset to sample from.\n                Must have attribute ``.examples``, which returns a list of\n                dictionaries of examples with associated metadata.\n            batch_by (Any, Sequence[Any]): Metadata field(s) to batch by.\n            batch_size (int, optional): The batch size. Required if ``batched_by``\n                specified or ``as_batch_sampler=True``.\n            as_batch_sampler (bool, optional): If ``True``, this instance\n                will behave like :cls:`torch.utils.data.BatchSampler.\n                This is highly recommended if ``batched_by`` if specified.\n            drop_last (bool, optional): If ``True``, drop the last batch for each group.\n                If ``batch_by`` is specified, this will also drop the last batch for each group\n                if it does not meet the specifications.\n            shuffle (bool, optional): If ``True``, shuffles the data.\n            seed (torch.Tensor): Random seed to use for initialization.\n        \"\"\"", "\n", "group_by", "=", "None", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "dataset", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "if", "batch_by", "and", "not", "batch_size", ":", "\n", "            ", "raise", "ValueError", "(", "\"`batch_size` must be specified if `batched=True`\"", ")", "\n", "", "if", "batch_by", "and", "not", "as_batch_sampler", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "\"Using `batch_by` without batch sampling functionality. \"", "\n", "\"To use as a batch sampler, set `as_batch_sampler=True`.\"", "\n", ")", "\n", "\n", "# Configure batch by groups if they exist.", "\n", "", "group_unknown", "=", "False", "\n", "if", "batch_by", ":", "\n", "            ", "groups", "=", "_build_groups", "(", "dataset", ".", "examples", ",", "batch_by", ",", "group_unknown", "=", "group_unknown", ")", "\n", "if", "group_by", ":", "\n", "                ", "groups", "=", "{", "\n", "grp", ":", "_build_groups", "(", "\n", "dataset", ".", "examples", ",", "group_by", ",", "group_unknown", "=", "group_unknown", ",", "indices", "=", "idxs", "\n", ")", "\n", "for", "grp", ",", "idxs", "in", "groups", ".", "items", "(", ")", "\n", "}", "\n", "", "else", ":", "\n", "                ", "groups", "=", "{", "k", ":", "{", "_UNKNOWN_TOKEN", ":", "v", "}", "for", "k", ",", "v", "in", "groups", ".", "items", "(", ")", "}", "\n", "", "", "else", ":", "\n", "            ", "groups", "=", "{", "\n", "_UNKNOWN_TOKEN", ":", "_build_groups", "(", "\n", "dataset", ".", "examples", ",", "group_by", ",", "group_unknown", "=", "group_unknown", "\n", ")", "\n", "}", "\n", "\n", "", "if", "seed", "is", "None", ":", "\n", "            ", "rng", "=", "torch", ".", "Generator", "(", ")", ".", "set_state", "(", "torch", ".", "random", ".", "get_rng_state", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "rng", "=", "torch", ".", "Generator", "(", ")", ".", "manual_seed", "(", "seed", ")", "\n", "\n", "", "self", ".", "group_by", "=", "group_by", "\n", "self", ".", "batch_by", "=", "batch_by", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "as_batch_sampler", "=", "as_batch_sampler", "\n", "self", ".", "drop_last", "=", "drop_last", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "\n", "self", ".", "_rng", "=", "rng", "\n", "self", ".", "_groups", "=", "groups", "\n", "batches", "=", "self", ".", "_build_batches", "(", "shuffle", "=", "False", ")", "\n", "self", ".", "_length", "=", "(", "\n", "len", "(", "batches", ")", "if", "self", ".", "as_batch_sampler", "else", "len", "(", "torch", ".", "cat", "(", "batches", ",", "dim", "=", "0", ")", ".", "tolist", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.GroupSampler.__len__": [[103, 105], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_length", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.GroupSampler.__iter__": [[106, 113], ["group_sampler.GroupSampler._build_batches", "iter", "iter", "torch.cat().tolist", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._build_batches", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "batches", ":", "List", "[", "torch", ".", "Tensor", "]", "=", "self", ".", "_build_batches", "(", ")", "\n", "\n", "if", "self", ".", "as_batch_sampler", ":", "\n", "            ", "return", "iter", "(", "batches", ")", "\n", "", "else", ":", "\n", "            ", "return", "iter", "(", "torch", ".", "cat", "(", "batches", ",", "dim", "=", "0", ")", ".", "tolist", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.GroupSampler._build_batches": [[114, 142], ["group_sampler._shuffle_groups", "torch.split", "group_sampler.GroupSampler._groups.items", "torch.as_tensor", "groups.values", "grp.values", "torch.randperm", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler._shuffle_groups", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "", "def", "_build_batches", "(", "self", ",", "shuffle", ":", "bool", "=", "None", ")", ":", "\n", "        ", "\"\"\"Build batches of examples to sample.\"\"\"", "\n", "# Shuffle indices (if applicable).", "\n", "shuffle", "=", "self", ".", "shuffle", "if", "shuffle", "is", "None", "else", "shuffle", "\n", "if", "shuffle", ":", "\n", "            ", "groups", "=", "{", "k", ":", "_shuffle_groups", "(", "v", ",", "self", ".", "_rng", ")", "for", "k", ",", "v", "in", "self", ".", "_groups", ".", "items", "(", ")", "}", "\n", "", "else", ":", "\n", "            ", "groups", "=", "self", ".", "_groups", "\n", "\n", "# Break into chunks of <= batch_size.", "\n", "", "batch_size", "=", "self", ".", "batch_size", "if", "self", ".", "batch_size", "else", "1", "\n", "if", "batch_size", ":", "\n", "            ", "groups", "=", "[", "\n", "torch", ".", "split", "(", "torch", ".", "as_tensor", "(", "v", ")", ",", "batch_size", ")", "\n", "for", "grp", "in", "groups", ".", "values", "(", ")", "\n", "for", "v", "in", "grp", ".", "values", "(", ")", "\n", "]", "\n", "# Drop last", "\n", "if", "self", ".", "drop_last", ":", "\n", "                ", "groups", "=", "[", "v", "[", ":", "-", "1", "]", "if", "len", "(", "v", "[", "-", "1", "]", ")", "<", "batch_size", "else", "v", "for", "v", "in", "groups", "]", "\n", "\n", "", "", "batches", "=", "[", "batch", "for", "grp", "in", "groups", "for", "batch", "in", "grp", "]", "\n", "\n", "# Reorder groups if shuffle is enabled.", "\n", "if", "shuffle", ":", "\n", "            ", "batches", "=", "[", "batches", "[", "i", "]", "for", "i", "in", "torch", ".", "randperm", "(", "len", "(", "batches", ")", ",", "generator", "=", "self", ".", "_rng", ")", "]", "\n", "\n", "", "return", "batches", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler.__init__": [[147, 210], ["group_sampler.GroupSampler.__init__", "collections.defaultdict", "group_sampler.AlternatingGroupSampler._groups.items", "group_sampler.AlternatingGroupSampler._build_samplers", "len", "isinstance", "tuple", "len", "len", "ValueError", "collections.defaultdict.pop", "list", "counts.items", "counts.pop", "group_sampler.AlternatingGroupSampler._groups.pop", "grp.values", "len", "grp.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._build_samplers", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dataset", ",", "\n", "T_s", ":", "int", "=", "1", ",", "\n", "T_us", ":", "int", "=", "1", ",", "\n", "batch_by", ":", "Any", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "None", ",", "\n", "as_batch_sampler", ":", "bool", "=", "False", ",", "\n", "drop_last", ":", "bool", "=", "False", ",", "\n", "seed", ":", "int", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "T_s", "=", "T_s", "\n", "self", ".", "T_us", "=", "T_us", "\n", "\n", "example", "=", "dataset", ".", "examples", "[", "0", "]", "\n", "key", "=", "[", "k", "for", "k", "in", "(", "\"is_unsupervised\"", ",", "\"_is_unsupervised\"", ")", "if", "k", "in", "example", "]", "\n", "assert", "len", "(", "key", ")", "==", "1", "\n", "key", "=", "key", "[", "0", "]", "\n", "\n", "if", "batch_by", "is", "None", ":", "\n", "            ", "batch_by", "=", "(", ")", "\n", "", "batch_by", "=", "tuple", "(", "batch_by", ")", "if", "isinstance", "(", "batch_by", ",", "(", "list", ",", "tuple", ")", ")", "else", "(", "batch_by", ",", ")", "\n", "batch_by", "+=", "(", "key", ",", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "dataset", ",", "\n", "batch_by", "=", "batch_by", ",", "\n", "batch_size", "=", "batch_size", "if", "batch_size", "else", "1", ",", "\n", "as_batch_sampler", "=", "as_batch_sampler", ",", "\n", "drop_last", "=", "False", ",", "\n", "shuffle", "=", "True", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "\n", "# Groups should only have one subgroup.", "\n", "counts", "=", "{", "}", "\n", "counts_per_group", "=", "defaultdict", "(", "int", ")", "\n", "for", "grp_name", ",", "grp", "in", "self", ".", "_groups", ".", "items", "(", ")", ":", "\n", "            ", "if", "len", "(", "grp", ")", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"All groups should only have 1 subgroup. \"", "\n", "f\"{grp_name} has {len(grp)} - {grp.keys()}\"", "\n", ")", "\n", "", "num", "=", "len", "(", "list", "(", "grp", ".", "values", "(", ")", ")", "[", "0", "]", ")", "\n", "counts_per_group", "[", "grp_name", "[", ":", "-", "1", "]", "]", "+=", "num", "\n", "counts", "[", "grp_name", "]", "=", "num", "\n", "# Drop any groups that will be smaller than the batch size.", "\n", "", "if", "drop_last", ":", "\n", "            ", "drop_keys", "=", "[", "grp_name", "for", "grp_name", ",", "count", "in", "counts", ".", "items", "(", ")", "if", "count", "<", "batch_size", "]", "\n", "for", "k", "in", "drop_keys", ":", "\n", "                ", "counts_per_group", ".", "pop", "(", "k", ")", "\n", "for", "gk", "in", "[", "k", "+", "(", "True", ",", ")", ",", "k", "+", "(", "False", ",", ")", "]", ":", "\n", "                    ", "counts", ".", "pop", "(", "gk", ",", "None", ")", "\n", "self", ".", "_groups", ".", "pop", "(", "gk", ",", "None", ")", "\n", "", "", "", "self", ".", "counts_per_group", "=", "counts_per_group", "\n", "self", ".", "counts", "=", "counts", "\n", "self", ".", "_samplers", "=", "self", ".", "_build_samplers", "(", "seed", "=", "seed", ")", "\n", "\n", "# State variables", "\n", "self", ".", "_iterators", "=", "{", "}", "\n", "self", ".", "_counter", "=", "{", "grp_name", ":", "0", "for", "grp_name", "in", "self", ".", "_samplers", "}", "\n", "self", ".", "_pointer", "=", "0", "\n", "self", ".", "_excess_sampled", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler.__len__": [[211, 219], ["sum", "group_sampler.AlternatingGroupSampler.counts.values"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Note:\n            This property should not be used for any real logic.\n            It is purely to satisfy the requirement that samplers\n            used as BatchSamplers should have a length.\n        \"\"\"", "\n", "return", "sum", "(", "v", "//", "self", ".", "batch_size", "for", "v", "in", "self", ".", "counts", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._batch_by_groups": [[220, 222], ["list", "group_sampler.AlternatingGroupSampler.counts_per_group.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "def", "_batch_by_groups", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "self", ".", "counts_per_group", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._build_samplers": [[223, 234], ["enumerate", "groups.items", "torch.Generator", "torch.utils.data.SubsetRandomSampler", "list", "gen.manual_seed.manual_seed.manual_seed", "grp.values"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "_build_samplers", "(", "self", ",", "seed", "=", "None", ")", "->", "Dict", "[", "Tuple", "[", "Hashable", "]", ",", "SubsetRandomSampler", "]", ":", "\n", "        ", "groups", "=", "self", ".", "_groups", "\n", "samplers", "=", "{", "}", "\n", "for", "grp_idx", ",", "(", "grp_name", ",", "grp", ")", "in", "enumerate", "(", "groups", ".", "items", "(", ")", ")", ":", "\n", "            ", "indices", "=", "list", "(", "grp", ".", "values", "(", ")", ")", "[", "0", "]", "\n", "g_seed", "=", "seed", "+", "grp_idx", "if", "seed", "is", "not", "None", "else", "None", "\n", "gen", "=", "torch", ".", "Generator", "(", ")", "\n", "if", "g_seed", "is", "not", "None", ":", "\n", "                ", "gen", "=", "gen", ".", "manual_seed", "(", "g_seed", ")", "\n", "", "samplers", "[", "grp_name", "]", "=", "SubsetRandomSampler", "(", "indices", ",", "generator", "=", "gen", ")", "\n", "", "return", "samplers", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._sample": [[235, 252], ["iter", "group_sampler.AlternatingGroupSampler._sample._reset_iterator"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "_sample", "(", "self", ",", "group", ":", "Hashable", ",", "unsupervised", ":", "bool", ")", ":", "\n", "        ", "def", "_reset_iterator", "(", "grp", ")", ":", "\n", "            ", "self", ".", "_iterators", "[", "grp", "]", "=", "iter", "(", "self", ".", "_samplers", "[", "grp", "]", ")", "\n", "\n", "", "group", "=", "group", "+", "(", "bool", "(", "unsupervised", ")", ",", ")", "\n", "\n", "if", "group", "not", "in", "self", ".", "_iterators", ":", "\n", "            ", "_reset_iterator", "(", "group", ")", "\n", "\n", "", "try", ":", "\n", "            ", "idx", "=", "next", "(", "self", ".", "_iterators", "[", "group", "]", ")", "\n", "", "except", "StopIteration", ":", "\n", "            ", "_reset_iterator", "(", "group", ")", "\n", "idx", "=", "next", "(", "self", ".", "_iterators", "[", "group", "]", ")", "\n", "\n", "", "self", ".", "_counter", "[", "group", "]", "+=", "1", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._get_group": [[253, 292], ["group_sampler.AlternatingGroupSampler._batch_by_groups", "numpy.asarray", "numpy.asarray", "numpy.sum", "torch.as_tensor", "torch.multinomial().item", "sorted", "numpy.max", "numpy.unique", "numpy.sum", "torch.multinomial", "group_sampler.AlternatingGroupSampler.counts.get", "group_sampler.AlternatingGroupSampler._counter.get", "numpy.min"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._batch_by_groups", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "_get_group", "(", "self", ",", "excess_sample", ",", "to_sample", ":", "List", "[", "bool", "]", ")", ":", "\n", "        ", "\"\"\"Return the group that should be sampled for this batch.\n\n        Args:\n            excess_sample (int): A value ``<0`` indicates that a surplus of supervised\n                examples have previously been sampled. The algorithm will then choose\n                a group with probability based on the remaining number of unsupervised examples.\n                If value is ``>0``, then vice versa.\n        \"\"\"", "\n", "batch_by", "=", "self", ".", "_batch_by_groups", "(", ")", "\n", "sample_by_groups", "=", "(", "\n", "[", "excess_sample", "<", "0", "]", "if", "excess_sample", "!=", "0", "else", "sorted", "(", "np", ".", "unique", "(", "to_sample", ")", ")", "\n", ")", "\n", "\n", "# Find the relative epoch for each iterator.", "\n", "num_examples_by_group", "=", "np", ".", "asarray", "(", "\n", "[", "\n", "[", "self", ".", "counts", ".", "get", "(", "batch_grp", "+", "(", "x", ",", ")", ",", "0", ")", "for", "x", "in", "sample_by_groups", "]", "\n", "for", "batch_grp", "in", "batch_by", "\n", "]", "\n", ")", "\n", "counter", "=", "np", ".", "asarray", "(", "\n", "[", "\n", "[", "self", ".", "_counter", ".", "get", "(", "batch_grp", "+", "(", "x", ",", ")", ",", "0", ")", "for", "x", "in", "sample_by_groups", "]", "\n", "for", "batch_grp", "in", "batch_by", "\n", "]", "\n", ")", "\n", "\n", "epoch_num", "=", "counter", "//", "(", "num_examples_by_group", "+", "(", "num_examples_by_group", "==", "0", ")", ")", "\n", "epoch_num", "[", "num_examples_by_group", "==", "0", "]", "=", "np", ".", "max", "(", "epoch_num", ")", "+", "1", "\n", "remainder", "=", "num_examples_by_group", "-", "counter", "%", "(", "\n", "num_examples_by_group", "+", "(", "num_examples_by_group", "==", "0", ")", "\n", ")", "\n", "remainder", "[", "epoch_num", "!=", "np", ".", "min", "(", "epoch_num", ")", "]", "=", "0", "\n", "weights", "=", "np", ".", "sum", "(", "remainder", ",", "axis", "=", "1", ")", "\n", "p", "=", "torch", ".", "as_tensor", "(", "weights", "/", "np", ".", "sum", "(", "weights", ")", ")", "\n", "\n", "idx", "=", "torch", ".", "multinomial", "(", "p", ",", "1", ",", "generator", "=", "self", ".", "_rng", ")", ".", "item", "(", ")", "\n", "return", "batch_by", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._next_batch": [[293, 340], ["min", "to_sample.extend", "numpy.arange", "to_sample.extend", "group_sampler.AlternatingGroupSampler._get_group", "torch.as_tensor", "abs", "len", "all", "group_sampler.AlternatingGroupSampler._sample", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._get_group", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._sample"], ["", "def", "_next_batch", "(", "self", ")", "->", "List", "[", "int", "]", ":", "\n", "        ", "batch_size", ":", "int", "=", "self", ".", "batch_size", "\n", "# pointer must be in range [0, self.T_s + self.T_us)", "\n", "pointer", "=", "self", ".", "_pointer", "\n", "# False = supervised, True = unsupervised", "\n", "to_sample", ":", "List", "[", "bool", "]", "=", "[", "]", "\n", "\n", "num_excess_sample", "=", "min", "(", "abs", "(", "self", ".", "_excess_sampled", ")", ",", "batch_size", ")", "\n", "to_sample", ".", "extend", "(", "[", "self", ".", "_excess_sampled", "<", "0", "]", "*", "num_excess_sample", ")", "\n", "\n", "num_alt_sample", "=", "batch_size", "-", "len", "(", "to_sample", ")", "\n", "c_range", "=", "np", ".", "arange", "(", "pointer", ",", "pointer", "+", "num_alt_sample", ")", "\n", "to_sample", ".", "extend", "(", "c_range", "%", "(", "self", ".", "T_s", "+", "self", ".", "T_us", ")", ">=", "self", ".", "T_s", ")", "\n", "\n", "# Find group to sample.", "\n", "group", "=", "self", ".", "_get_group", "(", "self", ".", "_excess_sampled", ",", "to_sample", ")", "\n", "\n", "# If sampled group only has supervised or unsupervised examples (but not both),", "\n", "# the batch will be composed of only supervised or only unsupervised examples.", "\n", "# This violates the duty cycle of supervised to unsupervised samples.", "\n", "# We change the self._excess_sampled state variable to indicate that a surplus", "\n", "# of either supervised or unsupervised samples has been selected. In this case,", "\n", "# the next batch will attempt to \"correct\" this sampling by oversampling the", "\n", "# opposite.", "\n", "is_unsupervised_options", "=", "[", "False", ",", "True", "]", "\n", "has_supervised_unsupervised", "=", "[", "\n", "group", "+", "(", "is_unsup", ",", ")", "in", "self", ".", "_groups", "for", "is_unsup", "in", "is_unsupervised_options", "\n", "]", "\n", "# TODO: Check if to_sample is made up of all of same type.", "\n", "if", "not", "all", "(", "has_supervised_unsupervised", ")", ":", "\n", "            ", "idx", "=", "np", ".", "where", "(", "has_supervised_unsupervised", ")", "[", "0", "]", "[", "0", "]", "\n", "is_unsup", "=", "is_unsupervised_options", "[", "idx", "]", "\n", "to_sample", "=", "[", "is_unsup", "]", "*", "batch_size", "\n", "shift_pointer", "=", "0", "\n", "while", "is_unsup", "==", "(", "(", "pointer", "+", "shift_pointer", ")", "%", "(", "self", ".", "T_s", "+", "self", ".", "T_us", ")", ">=", "self", ".", "T_s", ")", ":", "\n", "                ", "shift_pointer", "+=", "1", "\n", "", "self", ".", "_excess_sampled", "+=", "(", "(", "-", "1", ")", "**", "(", "is_unsup", "+", "1", ")", ")", "*", "(", "batch_size", "-", "shift_pointer", ")", "\n", "self", ".", "_pointer", "+=", "shift_pointer", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "_excess_sampled", "<", "0", ":", "\n", "                ", "self", ".", "_excess_sampled", "=", "self", ".", "_excess_sampled", "+", "num_excess_sample", "\n", "", "else", ":", "\n", "                ", "self", ".", "_excess_sampled", "=", "self", ".", "_excess_sampled", "-", "num_excess_sample", "\n", "", "self", ".", "_pointer", "=", "(", "self", ".", "_pointer", "+", "num_alt_sample", ")", "%", "(", "self", ".", "T_s", "+", "self", ".", "T_us", ")", "\n", "\n", "", "samples", "=", "torch", ".", "as_tensor", "(", "[", "self", ".", "_sample", "(", "group", ",", "is_unsup", ")", "for", "is_unsup", "in", "to_sample", "]", ")", "\n", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._build_batches": [[341, 348], ["hasattr", "group_sampler.AlternatingGroupSampler._next_batch", "torch.tensor", "range", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.AlternatingGroupSampler._next_batch"], ["", "def", "_build_batches", "(", "self", ",", "shuffle", ":", "bool", "=", "None", ")", ":", "\n", "        ", "\"\"\"Build batches of examples to sample.\"\"\"", "\n", "# Hacky way of getting around GroupSampler.__init__ _length computation.", "\n", "if", "not", "hasattr", "(", "self", ",", "\"counts\"", ")", ":", "\n", "            ", "return", "[", "torch", ".", "tensor", "(", "[", "]", ")", "]", "\n", "\n", "", "return", "[", "self", ".", "_next_batch", "(", ")", "for", "_", "in", "range", "(", "len", "(", "self", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.DistributedGroupSampler.__init__": [[360, 377], ["group_sampler.DistributedGroupSampler._world_size", "group_sampler.DistributedGroupSampler._rank", "dataset.groups", "numpy.array", "numpy.array_split", "numpy.concatenate", "len", "sorted", "dataset.groups.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.MockGroupSampler._world_size", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.MockGroupSampler._rank", "home.repos.pwc.inspect_result.ad12_meddlr.data.slice_dataset.SliceData.groups"], ["def", "__init__", "(", "self", ",", "dataset", ",", "group_by", ":", "str", ",", "shuffle", ":", "bool", "=", "False", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "world_size", "=", "self", ".", "_world_size", "(", ")", "\n", "self", ".", "rank", "=", "self", ".", "_rank", "(", ")", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "_group_by", "=", "group_by", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "\n", "# All nodes", "\n", "all_groups", "=", "dataset", ".", "groups", "(", "group_by", ")", "\n", "self", ".", "all_groups", "=", "np", ".", "array", "(", "sorted", "(", "all_groups", ".", "keys", "(", ")", ")", ")", "\n", "self", ".", "all_groups_split", "=", "np", ".", "array_split", "(", "self", ".", "all_groups", ",", "self", ".", "world_size", ")", "\n", "\n", "# This node", "\n", "self", ".", "groups", "=", "self", ".", "all_groups_split", "[", "self", ".", "rank", "]", "\n", "self", ".", "indices", "=", "np", ".", "concatenate", "(", "[", "all_groups", "[", "group_id", "]", "for", "group_id", "in", "self", ".", "groups", "]", ")", "\n", "self", ".", "num_samples", "=", "len", "(", "self", ".", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.DistributedGroupSampler._world_size": [[378, 380], ["meddlr.utils.comm.get_world_size"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_world_size"], ["", "def", "_world_size", "(", "self", ")", ":", "\n", "        ", "return", "comm", ".", "get_world_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.DistributedGroupSampler._rank": [[381, 383], ["meddlr.utils.comm.get_rank"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.get_rank"], ["", "def", "_rank", "(", "self", ")", ":", "\n", "        ", "return", "comm", ".", "get_rank", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.DistributedGroupSampler.__iter__": [[384, 394], ["iter", "torch.Generator", "torch.Generator.manual_seed", "torch.randperm().tolist", "indices.tolist", "torch.randperm"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "if", "self", ".", "shuffle", ":", "\n", "            ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", ")", "\n", "ordering", "=", "torch", ".", "randperm", "(", "self", ".", "num_samples", ",", "generator", "=", "g", ")", ".", "tolist", "(", ")", "\n", "indices", "=", "self", ".", "indices", "[", "ordering", "]", "\n", "", "else", ":", "\n", "            ", "indices", "=", "self", ".", "indices", "\n", "", "return", "iter", "(", "indices", ".", "tolist", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.DistributedGroupSampler.__len__": [[395, 397], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler.DistributedGroupSampler.set_epoch": [[398, 400], ["None"], "methods", ["None"], ["", "def", "set_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler._shuffle_groups": [[402, 407], ["isinstance", "group_sampler._shuffle_groups", "torch.as_tensor", "groups.items", "torch.randperm", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler._shuffle_groups", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "def", "_shuffle_groups", "(", "groups", ",", "rng", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "groups", ",", "Mapping", ")", ":", "\n", "        ", "return", "torch", ".", "as_tensor", "(", "groups", ")", "[", "torch", ".", "randperm", "(", "len", "(", "groups", ")", ",", "generator", "=", "rng", ")", "]", "\n", "\n", "", "return", "{", "k", ":", "_shuffle_groups", "(", "v", ",", "rng", ")", "for", "k", ",", "v", "in", "groups", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.group_sampler._build_groups": [[409, 444], ["collections.defaultdict", "zip", "range", "isinstance", "group_by_values.append", "group_to_idxs[].append", "len", "tuple", "values.append", "ex.get", "values.append", "values.append"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "def", "_build_groups", "(", "\n", "examples", ",", "\n", "group_by", ":", "Union", "[", "Any", ",", "Sequence", "[", "Any", "]", "]", "=", "None", ",", "\n", "group_unknown", ":", "bool", "=", "False", ",", "\n", "indices", ":", "Sequence", "[", "int", "]", "=", "None", ",", "\n", ")", ":", "\n", "    ", "if", "not", "indices", ":", "\n", "        ", "indices", "=", "range", "(", "len", "(", "examples", ")", ")", "\n", "\n", "", "if", "group_by", "is", "None", ":", "\n", "        ", "return", "{", "_UNKNOWN_TOKEN", ":", "indices", "}", "\n", "", "elif", "isinstance", "(", "group_by", ",", "str", ")", ":", "\n", "        ", "group_by", "=", "(", "group_by", ",", ")", "\n", "\n", "", "group_by_values", "=", "[", "]", "\n", "for", "idx", "in", "indices", ":", "\n", "        ", "ex", "=", "examples", "[", "idx", "]", "\n", "values", "=", "[", "]", "\n", "for", "gb", "in", "group_by", ":", "\n", "            ", "if", "gb", "in", "ex", ":", "\n", "                ", "values", ".", "append", "(", "ex", "[", "gb", "]", ")", "\n", "", "elif", "gb", "in", "ex", ".", "get", "(", "\"_metadata\"", ",", "{", "}", ")", ":", "\n", "                ", "values", ".", "append", "(", "ex", "[", "\"_metadata\"", "]", "[", "gb", "]", ")", "\n", "", "else", ":", "\n", "                ", "values", ".", "append", "(", "_UNKNOWN_TOKEN", ")", "\n", "\n", "", "", "if", "group_unknown", "and", "_UNKNOWN_TOKEN", "in", "values", ":", "\n", "            ", "values", "=", "[", "_UNKNOWN_TOKEN", "]", "\n", "", "group_by_values", ".", "append", "(", "tuple", "(", "values", ")", ")", "\n", "\n", "", "group_to_idxs", "=", "defaultdict", "(", "list", ")", "\n", "for", "idx", ",", "val", "in", "zip", "(", "indices", ",", "group_by_values", ")", ":", "\n", "        ", "group_to_idxs", "[", "val", "]", ".", "append", "(", "idx", ")", "\n", "\n", "", "return", "group_to_idxs", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.MockGroupSampler.__init__": [[17, 21], ["meddlr.data.samplers.group_sampler.DistributedGroupSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "group_by", ":", "str", ",", "shuffle", "=", "False", ",", "world_size", "=", "1", ",", "rank", "=", "0", ")", ":", "\n", "        ", "self", ".", "_world_size_val", "=", "world_size", "\n", "self", ".", "_rank_val", "=", "rank", "\n", "super", "(", ")", ".", "__init__", "(", "dataset", ",", "group_by", ",", "shuffle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.MockGroupSampler._world_size": [[22, 24], ["None"], "methods", ["None"], ["", "def", "_world_size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_world_size_val", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.MockGroupSampler._rank": [[25, 27], ["None"], "methods", ["None"], ["", "def", "_rank", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_rank_val", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestGroupSampler.test_group_sampler_errors": [[30, 35], ["mock._MockDataset", "test_group_sampler.TestGroupSampler.assertRaises", "meddlr.data.samplers.group_sampler.GroupSampler"], "methods", ["None"], ["    ", "def", "test_group_sampler_errors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test init values that would cause errors.\"\"\"", "\n", "dataset", "=", "_MockDataset", "(", ")", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "GroupSampler", "(", "dataset", ",", "batch_by", "=", "\"letter\"", ",", "shuffle", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestGroupSampler.test_basic_batch_by": [[36, 54], ["mock._MockDataset", "meddlr.data.samplers.group_sampler.GroupSampler", "meddlr.data.samplers.group_sampler.GroupSampler", "len", "len", "len", "isinstance", "len"], "methods", ["None"], ["", "", "def", "test_basic_batch_by", "(", "self", ")", ":", "\n", "        ", "dataset", "=", "_MockDataset", "(", ")", "\n", "\n", "batch_size", "=", "2", "\n", "sampler", "=", "GroupSampler", "(", "\n", "dataset", ",", "batch_by", "=", "\"letter\"", ",", "shuffle", "=", "False", ",", "batch_size", "=", "batch_size", ",", "as_batch_sampler", "=", "True", "\n", ")", "\n", "assert", "len", "(", "sampler", ")", "==", "5", "\n", "for", "batch", "in", "sampler", ":", "\n", "            ", "assert", "len", "(", "batch", ")", "<=", "batch_size", "\n", "\n", "", "batch_size", "=", "2", "\n", "sampler", "=", "GroupSampler", "(", "\n", "dataset", ",", "batch_by", "=", "\"letter\"", ",", "shuffle", "=", "False", ",", "batch_size", "=", "batch_size", ",", "as_batch_sampler", "=", "False", "\n", ")", "\n", "assert", "len", "(", "sampler", ")", "==", "len", "(", "dataset", ".", "examples", ")", "\n", "for", "batch", "in", "sampler", ":", "\n", "            ", "assert", "isinstance", "(", "batch", ",", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestGroupSampler.test_fastmri_brain": [[55, 75], ["meddlr.data.samplers.group_sampler.GroupSampler", "meddlr.data.DatasetCatalog.get", "meddlr.data.slice_dataset.SliceData", "meddlr.data.samplers.group_sampler.GroupSampler._groups.keys", "test_group_sampler.TestGroupSampler.skipTest", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "", "def", "test_fastmri_brain", "(", "self", ")", ":", "\n", "        ", "\"\"\"Utility test for fastmri brain split.\"\"\"", "\n", "try", ":", "\n", "            ", "dataset_dicts", "=", "DatasetCatalog", ".", "get", "(", "\"fastMRI_brain_multicoil_mini_v0.0.1_val\"", ")", "\n", "dataset", "=", "SliceData", "(", "dataset_dicts", ",", "transform", "=", "None", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "            ", "self", ".", "skipTest", "(", "\"fastMRI files not found\"", ")", "\n", "\n", "", "batch_by", "=", "\"receiverChannels\"", "\n", "batch_size", "=", "7", "\n", "\n", "all_channels", "=", "{", "(", "x", "[", "\"_metadata\"", "]", "[", "batch_by", "]", ",", ")", "for", "x", "in", "dataset", ".", "examples", "}", "\n", "sampler", "=", "GroupSampler", "(", "\n", "dataset", ",", "batch_by", "=", "batch_by", ",", "as_batch_sampler", "=", "True", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "assert", "all_channels", "==", "sampler", ".", "_groups", ".", "keys", "(", ")", "\n", "\n", "for", "batch", "in", "sampler", ":", "\n", "            ", "unique_groups", "=", "{", "dataset", ".", "examples", "[", "idx", "]", "[", "\"_metadata\"", "]", "[", "batch_by", "]", "for", "idx", "in", "batch", "}", "\n", "assert", "len", "(", "unique_groups", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle": [[78, 85], ["enumerate", "max", "min", "len"], "methods", ["None"], ["    ", "def", "_validate_duty_cycle", "(", "self", ",", "cycle", ",", "T_s", ",", "T_us", ")", ":", "\n", "        ", "for", "idx", ",", "is_unsup", "in", "enumerate", "(", "cycle", ")", ":", "\n", "            ", "rng", "=", "cycle", "[", "max", "(", "0", ",", "idx", "-", "2", ")", ":", "min", "(", "len", "(", "cycle", ")", "-", "1", ",", "idx", "+", "3", ")", "]", "\n", "if", "idx", "%", "(", "T_s", "+", "T_us", ")", "<", "T_s", ":", "\n", "                ", "assert", "not", "is_unsup", ",", "f\"index {idx}: Expected is_unsup=False, got True - {rng}\"", "\n", "", "else", ":", "\n", "                ", "assert", "is_unsup", ",", "f\"index {idx}: Expected is_unsup=True, got False - {rng}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler.test_basic": [[86, 121], ["mock._MockDataset", "meddlr.data.samplers.group_sampler.AlternatingGroupSampler", "list", "test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "numpy.unique", "meddlr.data.samplers.group_sampler.AlternatingGroupSampler", "test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "meddlr.data.samplers.group_sampler.AlternatingGroupSampler", "test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "iter", "numpy.all", "numpy.max", "numpy.min", "all", "iter", "iter", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "", "", "def", "test_basic", "(", "self", ")", ":", "\n", "        ", "T_s", "=", "T_us", "=", "1", "\n", "dataset", "=", "_MockDataset", "(", "{", "\"A\"", ":", "(", "50", ",", "50", ")", ",", "\"B\"", ":", "(", "20", ",", "20", ")", "}", ")", "\n", "\n", "sampler", "=", "AlternatingGroupSampler", "(", "\n", "dataset", ",", "T_s", "=", "T_s", ",", "T_us", "=", "T_us", ",", "batch_by", "=", "\"field0\"", ",", "batch_size", "=", "1", "\n", ")", "\n", "assert", "sampler", ".", "counts_per_group", "==", "{", "(", "\"A\"", ",", ")", ":", "100", ",", "(", "\"B\"", ",", ")", ":", "40", "}", "\n", "assert", "sampler", ".", "counts", "==", "{", "\n", "(", "\"A\"", ",", "False", ")", ":", "50", ",", "\n", "(", "\"A\"", ",", "True", ")", ":", "50", ",", "\n", "(", "\"B\"", ",", "False", ")", ":", "20", ",", "\n", "(", "\"B\"", ",", "True", ")", ":", "20", ",", "\n", "}", "\n", "\n", "indices", "=", "list", "(", "iter", "(", "sampler", ")", ")", "\n", "sup_unsup_cycle", "=", "[", "dataset", "[", "idx", "]", "[", "\"_is_unsupervised\"", "]", "for", "idx", "in", "indices", "]", "\n", "self", ".", "_validate_duty_cycle", "(", "sup_unsup_cycle", ",", "T_s", ",", "T_us", ")", "\n", "_", ",", "counts", "=", "np", ".", "unique", "(", "indices", ",", "return_counts", "=", "True", ")", "\n", "assert", "np", ".", "max", "(", "counts", ")", "-", "np", ".", "min", "(", "counts", ")", "<=", "1", "\n", "assert", "np", ".", "all", "(", "counts", "==", "1", ")", "or", "(", "\n", "(", "len", "(", "indices", ")", "==", "len", "(", "dataset", ")", ")", "and", "all", "(", "x", "in", "[", "1", ",", "2", "]", "for", "x", "in", "counts", ")", "\n", ")", "\n", "\n", "sampler", "=", "AlternatingGroupSampler", "(", "\n", "dataset", ",", "T_s", "=", "T_s", ",", "T_us", "=", "T_us", ",", "batch_by", "=", "\"field0\"", ",", "batch_size", "=", "2", "\n", ")", "\n", "sup_unsup_cycle", "=", "[", "dataset", "[", "idx", "]", "[", "\"_is_unsupervised\"", "]", "for", "idx", "in", "iter", "(", "sampler", ")", "]", "\n", "self", ".", "_validate_duty_cycle", "(", "sup_unsup_cycle", ",", "T_s", ",", "T_us", ")", "\n", "\n", "sampler", "=", "AlternatingGroupSampler", "(", "\n", "dataset", ",", "T_s", "=", "T_s", ",", "T_us", "=", "T_us", ",", "as_batch_sampler", "=", "True", ",", "batch_by", "=", "\"field0\"", ",", "batch_size", "=", "1", "\n", ")", "\n", "sup_unsup_cycle", "=", "[", "dataset", "[", "idx", "]", "[", "\"_is_unsupervised\"", "]", "for", "x", "in", "iter", "(", "sampler", ")", "for", "idx", "in", "x", "]", "\n", "self", ".", "_validate_duty_cycle", "(", "sup_unsup_cycle", ",", "T_s", ",", "T_us", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler.test_uneven_sizes": [[122, 134], ["mock._MockDataset", "meddlr.data.samplers.group_sampler.AlternatingGroupSampler", "list", "test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "iter"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "test_uneven_sizes", "(", "self", ")", ":", "\n", "        ", "T_s", "=", "T_us", "=", "2", "\n", "dataset", "=", "_MockDataset", "(", "{", "\"A\"", ":", "(", "4", ",", "4", ")", ",", "\"B\"", ":", "(", "4", ",", "0", ")", "}", ")", "\n", "\n", "sampler", "=", "AlternatingGroupSampler", "(", "\n", "dataset", ",", "T_s", "=", "T_s", ",", "T_us", "=", "T_us", ",", "batch_by", "=", "\"field0\"", ",", "batch_size", "=", "2", "\n", ")", "\n", "assert", "sampler", ".", "counts_per_group", "==", "{", "(", "\"A\"", ",", ")", ":", "8", ",", "(", "\"B\"", ",", ")", ":", "4", "}", "\n", "assert", "sampler", ".", "counts", "==", "{", "(", "\"A\"", ",", "False", ")", ":", "4", ",", "(", "\"A\"", ",", "True", ")", ":", "4", ",", "(", "\"B\"", ",", "False", ")", ":", "4", "}", "\n", "indices", "=", "list", "(", "iter", "(", "sampler", ")", ")", "\n", "sup_unsup_cycle", "=", "[", "dataset", "[", "idx", "]", "[", "\"_is_unsupervised\"", "]", "for", "idx", "in", "indices", "]", "\n", "self", ".", "_validate_duty_cycle", "(", "sup_unsup_cycle", ",", "T_s", ",", "T_us", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler.test_uneven_sizes2": [[135, 150], ["mock._MockDataset", "meddlr.data.samplers.group_sampler.AlternatingGroupSampler", "list", "test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "iter"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestAlternatingGroupSampler._validate_duty_cycle", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "test_uneven_sizes2", "(", "self", ")", ":", "\n", "        ", "T_s", "=", "T_us", "=", "2", "\n", "dataset", "=", "_MockDataset", "(", "{", "\"A\"", ":", "(", "2", ",", "4", ")", ",", "\"B\"", ":", "(", "2", ",", "2", ")", ",", "\"C\"", ":", "(", "2", ",", "0", ")", "}", ")", "\n", "sampler", "=", "AlternatingGroupSampler", "(", "\n", "dataset", ",", "\n", "T_s", "=", "T_s", ",", "\n", "T_us", "=", "T_us", ",", "\n", "batch_by", "=", "\"field0\"", ",", "\n", "batch_size", "=", "1", ",", "\n", "seed", "=", "10", ",", "\n", "as_batch_sampler", "=", "True", ",", "\n", ")", "\n", "indices", "=", "list", "(", "iter", "(", "sampler", ")", ")", "\n", "sup_unsup_cycle", "=", "[", "dataset", "[", "idx", "]", "[", "\"_is_unsupervised\"", "]", "for", "idx", "in", "indices", "]", "\n", "self", ".", "_validate_duty_cycle", "(", "sup_unsup_cycle", ",", "T_s", ",", "T_us", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestDistributedGroupSampler._build_mock_dataset": [[153, 165], ["mock.MockSliceDataset", "range"], "methods", ["None"], ["    ", "def", "_build_mock_dataset", "(", "self", ",", "num_scans", "=", "10", ",", "num_slices", "=", "320", ")", "->", "MockSliceDataset", ":", "\n", "        ", "\"\"\"Build mock dataset with unsupervised data.\"\"\"", "\n", "dataset_dicts", "=", "[", "\n", "{", "\n", "\"file_name\"", ":", "\"scan{}\"", ".", "format", "(", "idx", ")", ",", "\n", "\"kspace_size\"", ":", "(", "num_slices", ",", "320", ",", "256", ",", "4", ",", "2", ")", ",", "\n", "\"_is_unsupervised\"", ":", "False", ",", "\n", "}", "\n", "for", "idx", "in", "range", "(", "num_scans", ")", "\n", "]", "\n", "\n", "return", "MockSliceDataset", "(", "dataset_dicts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestDistributedGroupSampler.test_no_distributed": [[166, 172], ["test_group_sampler.TestDistributedGroupSampler._build_mock_dataset", "meddlr.data.samplers.group_sampler.DistributedGroupSampler", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset"], ["", "def", "test_no_distributed", "(", "self", ")", ":", "\n", "        ", "dataset", "=", "self", ".", "_build_mock_dataset", "(", ")", "\n", "sampler", "=", "DistributedGroupSampler", "(", "dataset", ",", "group_by", "=", "\"file_name\"", ")", "\n", "\n", "assert", "len", "(", "sampler", ")", "==", "len", "(", "dataset", ")", ",", "(", "\n", "f\"Expected same size for sampler ({len(sampler)}) and dataset ({len(dataset)}. \"", "\n", "f\"All groups allocated to same sampler\"", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestDistributedGroupSampler.test_distributed_even_partition": [[175, 203], ["range", "test_group_sampler.TestDistributedGroupSampler._build_mock_dataset", "sum", "all", "range", "test_group_sampler.TestDistributedGroupSampler._build_mock_dataset", "test_group_sampler.MockGroupSampler", "samplers.append", "len", "range", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset"], ["", "def", "test_distributed_even_partition", "(", "self", ")", ":", "\n", "        ", "world_size", "=", "4", "\n", "num_scans", "=", "12", "\n", "samplers", "=", "[", "]", "\n", "\n", "# Simulate what happens in DDP", "\n", "for", "i", "in", "range", "(", "world_size", ")", ":", "\n", "            ", "dataset", "=", "self", ".", "_build_mock_dataset", "(", "num_scans", "=", "num_scans", ")", "\n", "sampler", "=", "MockGroupSampler", "(", "dataset", ",", "group_by", "=", "\"file_name\"", ",", "world_size", "=", "world_size", ",", "rank", "=", "i", ")", "\n", "samplers", ".", "append", "(", "sampler", ")", "\n", "\n", "", "expected_dataset", "=", "self", ".", "_build_mock_dataset", "(", "num_scans", "=", "num_scans", ")", "\n", "length", "=", "sum", "(", "len", "(", "sampler", ")", "for", "sampler", "in", "samplers", ")", "\n", "assert", "length", "==", "len", "(", "expected_dataset", ")", ",", "(", "\n", "f\"Sum of lengths of samplers ({length}) != \"", "\n", "f\"length of full dataset ({len(expected_dataset)})\"", "\n", ")", "\n", "\n", "groups", "=", "[", "{", "expected_dataset", "[", "idx", "]", "[", "0", "]", "for", "idx", "in", "sampler", ".", "indices", "}", "for", "sampler", "in", "samplers", "]", "\n", "assert", "all", "(", "len", "(", "grps", ")", "==", "num_scans", "//", "world_size", "for", "grps", "in", "groups", ")", ",", "(", "\n", "f\"Groups not equally divided among {world_size} \"", "\n", "f\"processes ({len(grps) for grps in groups}). \"", "\n", ")", "\n", "for", "i", "in", "range", "(", "world_size", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "world_size", ")", ":", "\n", "                ", "assert", "(", "\n", "len", "(", "groups", "[", "i", "]", "&", "groups", "[", "j", "]", ")", "==", "0", "\n", ")", ",", "f\"Overlapping groups in processes {i} ({groups[i]}) and {j} ({groups[j]})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_group_sampler.TestDistributedGroupSampler.test_distributed_uneven_partition": [[204, 230], ["range", "test_group_sampler.TestDistributedGroupSampler._build_mock_dataset", "sum", "range", "test_group_sampler.TestDistributedGroupSampler._build_mock_dataset", "test_group_sampler.MockGroupSampler", "samplers.append", "len", "len", "len", "range", "len", "len", "sum", "sum", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset"], ["", "", "", "def", "test_distributed_uneven_partition", "(", "self", ")", ":", "\n", "        ", "world_size", "=", "4", "\n", "num_scans", "=", "10", "\n", "samplers", "=", "[", "]", "\n", "\n", "# Simulate what happens in DDP", "\n", "for", "i", "in", "range", "(", "world_size", ")", ":", "\n", "            ", "dataset", "=", "self", ".", "_build_mock_dataset", "(", "num_scans", "=", "num_scans", ")", "\n", "sampler", "=", "MockGroupSampler", "(", "dataset", ",", "group_by", "=", "\"file_name\"", ",", "world_size", "=", "world_size", ",", "rank", "=", "i", ")", "\n", "samplers", ".", "append", "(", "sampler", ")", "\n", "\n", "", "expected_dataset", "=", "self", ".", "_build_mock_dataset", "(", "num_scans", "=", "num_scans", ")", "\n", "length", "=", "sum", "(", "len", "(", "sampler", ")", "for", "sampler", "in", "samplers", ")", "\n", "assert", "length", "==", "len", "(", "expected_dataset", ")", ",", "(", "\n", "f\"Sum of lengths of samplers ({length}) != \"", "\n", "f\"length of full dataset ({len(expected_dataset)})\"", "\n", ")", "\n", "\n", "groups", "=", "[", "{", "expected_dataset", "[", "idx", "]", "[", "0", "]", "for", "idx", "in", "sampler", ".", "indices", "}", "for", "sampler", "in", "samplers", "]", "\n", "num_groups", "=", "[", "len", "(", "grps", ")", "for", "grps", "in", "groups", "]", "\n", "assert", "sum", "(", "x", "==", "2", "for", "x", "in", "num_groups", ")", "==", "2", "and", "sum", "(", "x", "==", "3", "for", "x", "in", "num_groups", ")", "==", "2", "\n", "for", "i", "in", "range", "(", "len", "(", "groups", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "groups", ")", ")", ":", "\n", "                ", "assert", "(", "\n", "len", "(", "groups", "[", "i", "]", "&", "groups", "[", "j", "]", ")", "==", "0", "\n", ")", ",", "f\"Overlapping groups in processes {i} ({groups[i]}) and {j} ({groups[j]})\"", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset": [[11, 26], ["mock.MockSliceDataset", "range"], "methods", ["None"], ["    ", "def", "_build_mock_dataset", "(", "\n", "self", ",", "num_scans", "=", "2", ",", "num_unsupervised", "=", "1", ",", "num_slices", "=", "320", "\n", ")", "->", "MockSliceDataset", ":", "\n", "        ", "\"\"\"Build mock dataset with unsupervised data.\"\"\"", "\n", "assert", "num_unsupervised", "<=", "num_scans", "\n", "dataset_dicts", "=", "[", "\n", "{", "\n", "\"file_name\"", ":", "\"scan{}\"", ".", "format", "(", "idx", ")", ",", "\n", "\"kspace_size\"", ":", "(", "num_slices", ",", "320", ",", "256", ",", "4", ",", "2", ")", ",", "\n", "\"_is_unsupervised\"", ":", "idx", "<", "num_unsupervised", ",", "\n", "}", "\n", "for", "idx", "in", "range", "(", "num_scans", ")", "\n", "]", "\n", "\n", "return", "MockSliceDataset", "(", "dataset_dicts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler.test_basic": [[27, 52], ["test_sampler.TestAlternatingSampler._build_mock_dataset", "set", "set", "meddlr.data.AlternatingSampler", "numpy.asarray", "idxs.reshape.reshape.reshape", "idxs[].flatten", "idxs[].flatten", "numpy.all", "test_sampler.TestAlternatingSampler.get_supervised_idxs", "test_sampler.TestAlternatingSampler.get_unsupervised_idxs", "len", "list", "len", "len", "set", "set", "iter", "numpy.bincount", "idxs.reshape.reshape.flatten"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_supervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_unsupervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "test_basic", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Test with same number of supervised/unsupervised samples and same\n        period.\n        \"\"\"", "\n", "T_s", "=", "T_us", "=", "4", "\n", "dataset", "=", "self", ".", "_build_mock_dataset", "(", "2", ",", "1", ",", "8", ")", "\n", "\n", "expected_supervised_idxs", "=", "set", "(", "dataset", ".", "get_supervised_idxs", "(", ")", ")", "\n", "expected_unsupervised_idxs", "=", "set", "(", "dataset", ".", "get_unsupervised_idxs", "(", ")", ")", "\n", "\n", "sampler", "=", "AlternatingSampler", "(", "dataset", ",", "T_s", ",", "T_us", ",", "seed", "=", "0", ")", "\n", "assert", "len", "(", "sampler", ")", "==", "16", "\n", "\n", "idxs", "=", "np", ".", "asarray", "(", "list", "(", "iter", "(", "sampler", ")", ")", ")", "\n", "assert", "len", "(", "idxs", ")", "==", "len", "(", "sampler", ")", "\n", "idxs", "=", "idxs", ".", "reshape", "(", "(", "-", "1", ",", "T_s", "+", "T_us", ")", ")", "\n", "supervised_idxs", "=", "idxs", "[", ":", ",", "0", ":", "T_s", "]", ".", "flatten", "(", ")", "\n", "unsupervised_idxs", "=", "idxs", "[", ":", ",", "T_s", ":", "]", ".", "flatten", "(", ")", "\n", "\n", "assert", "set", "(", "supervised_idxs", ")", "==", "expected_supervised_idxs", "\n", "assert", "set", "(", "unsupervised_idxs", ")", "==", "expected_unsupervised_idxs", "\n", "\n", "# Verify that each index occurs only once.", "\n", "assert", "np", ".", "all", "(", "np", ".", "bincount", "(", "idxs", ".", "flatten", "(", ")", ")", "==", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler.test_period": [[53, 80], ["test_sampler.TestAlternatingSampler._build_mock_dataset", "set", "set", "meddlr.data.AlternatingSampler", "numpy.asarray", "idxs.reshape.reshape.reshape", "idxs[].flatten", "idxs[].flatten", "numpy.bincount", "numpy.all", "numpy.all", "test_sampler.TestAlternatingSampler.get_supervised_idxs", "test_sampler.TestAlternatingSampler.get_unsupervised_idxs", "len", "list", "len", "len", "set", "set", "idxs.reshape.reshape.flatten", "iter"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_supervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_unsupervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "test_period", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test when periods are not identical.\"\"\"", "\n", "T_s", "=", "4", "\n", "T_us", "=", "2", "\n", "dataset", "=", "self", ".", "_build_mock_dataset", "(", "2", ",", "1", ",", "8", ")", "\n", "\n", "expected_supervised_idxs", "=", "set", "(", "dataset", ".", "get_supervised_idxs", "(", ")", ")", "\n", "expected_unsupervised_idxs", "=", "set", "(", "dataset", ".", "get_unsupervised_idxs", "(", ")", ")", "\n", "\n", "sampler", "=", "AlternatingSampler", "(", "dataset", ",", "T_s", ",", "T_us", ",", "seed", "=", "0", ")", "\n", "assert", "len", "(", "sampler", ")", "==", "24", "\n", "\n", "idxs", "=", "np", ".", "asarray", "(", "list", "(", "iter", "(", "sampler", ")", ")", ")", "\n", "assert", "len", "(", "idxs", ")", "==", "len", "(", "sampler", ")", "\n", "idxs", "=", "idxs", ".", "reshape", "(", "(", "-", "1", ",", "T_s", "+", "T_us", ")", ")", "\n", "supervised_idxs", "=", "idxs", "[", ":", ",", "0", ":", "T_s", "]", ".", "flatten", "(", ")", "\n", "unsupervised_idxs", "=", "idxs", "[", ":", ",", "T_s", ":", "]", ".", "flatten", "(", ")", "\n", "\n", "assert", "set", "(", "supervised_idxs", ")", "==", "expected_supervised_idxs", "\n", "assert", "set", "(", "unsupervised_idxs", ")", "==", "expected_unsupervised_idxs", "\n", "\n", "# Supervised indices repeat twice. Unsupervised indices repeat once.", "\n", "counts", "=", "np", ".", "bincount", "(", "idxs", ".", "flatten", "(", ")", ")", "\n", "unsupervised_counts", "=", "counts", "[", ":", "8", "]", "\n", "supervised_counts", "=", "counts", "[", "8", ":", "]", "\n", "assert", "np", ".", "all", "(", "unsupervised_counts", "==", "1", ")", "\n", "assert", "np", ".", "all", "(", "supervised_counts", "==", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler.test_data_imbalance": [[81, 134], ["test_sampler.TestAlternatingSampler._build_mock_dataset", "set", "set", "meddlr.data.AlternatingSampler", "numpy.asarray", "idxs.reshape.reshape.reshape", "set", "set", "numpy.bincount", "numpy.all", "numpy.all", "test_sampler.TestAlternatingSampler._build_mock_dataset", "set", "set", "meddlr.data.AlternatingSampler", "numpy.asarray", "idxs.reshape.reshape.reshape", "set", "set", "numpy.bincount", "numpy.all", "numpy.all", "test_sampler.TestAlternatingSampler.get_supervised_idxs", "test_sampler.TestAlternatingSampler.get_unsupervised_idxs", "len", "list", "len", "len", "idxs[].flatten", "idxs[].flatten", "idxs.reshape.reshape.flatten", "test_sampler.TestAlternatingSampler.get_supervised_idxs", "test_sampler.TestAlternatingSampler.get_unsupervised_idxs", "len", "list", "len", "len", "idxs[].flatten", "idxs[].flatten", "idxs.reshape.reshape.flatten", "iter", "iter"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_supervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_unsupervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_supervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_unsupervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "test_data_imbalance", "(", "self", ")", ":", "\n", "        ", "\"\"\"Number of supervised/unsupervised examples is imbalanced.\"\"\"", "\n", "T_s", "=", "T_us", "=", "4", "\n", "\n", "# 1 unsupervised, 2 supervised", "\n", "dataset", "=", "self", ".", "_build_mock_dataset", "(", "3", ",", "1", ",", "8", ")", "\n", "\n", "expected_supervised_idxs", "=", "set", "(", "dataset", ".", "get_supervised_idxs", "(", ")", ")", "\n", "expected_unsupervised_idxs", "=", "set", "(", "dataset", ".", "get_unsupervised_idxs", "(", ")", ")", "\n", "\n", "sampler", "=", "AlternatingSampler", "(", "dataset", ",", "T_s", ",", "T_us", ",", "seed", "=", "0", ")", "\n", "assert", "len", "(", "sampler", ")", "==", "32", "\n", "\n", "idxs", "=", "np", ".", "asarray", "(", "list", "(", "iter", "(", "sampler", ")", ")", ")", "\n", "assert", "len", "(", "idxs", ")", "==", "len", "(", "sampler", ")", "\n", "idxs", "=", "idxs", ".", "reshape", "(", "(", "-", "1", ",", "T_s", "+", "T_us", ")", ")", "\n", "supervised_idxs", "=", "set", "(", "idxs", "[", ":", ",", "0", ":", "T_s", "]", ".", "flatten", "(", ")", ")", "\n", "unsupervised_idxs", "=", "set", "(", "idxs", "[", ":", ",", "T_s", ":", "]", ".", "flatten", "(", ")", ")", "\n", "\n", "assert", "supervised_idxs", "==", "expected_supervised_idxs", "\n", "assert", "unsupervised_idxs", "==", "expected_unsupervised_idxs", "\n", "\n", "# Unsupervised indices repeat twice.", "\n", "counts", "=", "np", ".", "bincount", "(", "idxs", ".", "flatten", "(", ")", ")", "\n", "unsupervised_counts", "=", "counts", "[", ":", "8", "]", "\n", "supervised_counts", "=", "counts", "[", "8", ":", "]", "\n", "assert", "np", ".", "all", "(", "unsupervised_counts", "==", "2", ")", "\n", "assert", "np", ".", "all", "(", "supervised_counts", "==", "1", ")", "\n", "\n", "# 2 unsupervised, 1 supervised", "\n", "dataset", "=", "self", ".", "_build_mock_dataset", "(", "3", ",", "2", ",", "8", ")", "\n", "\n", "expected_supervised_idxs", "=", "set", "(", "dataset", ".", "get_supervised_idxs", "(", ")", ")", "\n", "expected_unsupervised_idxs", "=", "set", "(", "dataset", ".", "get_unsupervised_idxs", "(", ")", ")", "\n", "\n", "sampler", "=", "AlternatingSampler", "(", "dataset", ",", "T_s", ",", "T_us", ",", "seed", "=", "0", ")", "\n", "assert", "len", "(", "sampler", ")", "==", "32", "\n", "\n", "idxs", "=", "np", ".", "asarray", "(", "list", "(", "iter", "(", "sampler", ")", ")", ")", "\n", "assert", "len", "(", "idxs", ")", "==", "len", "(", "sampler", ")", "\n", "idxs", "=", "idxs", ".", "reshape", "(", "(", "-", "1", ",", "T_s", "+", "T_us", ")", ")", "\n", "supervised_idxs", "=", "set", "(", "idxs", "[", ":", ",", "0", ":", "T_s", "]", ".", "flatten", "(", ")", ")", "\n", "unsupervised_idxs", "=", "set", "(", "idxs", "[", ":", ",", "T_s", ":", "]", ".", "flatten", "(", ")", ")", "\n", "\n", "assert", "supervised_idxs", "==", "expected_supervised_idxs", "\n", "assert", "unsupervised_idxs", "==", "expected_unsupervised_idxs", "\n", "\n", "# Unsupervised indices repeat twice.", "\n", "counts", "=", "np", ".", "bincount", "(", "idxs", ".", "flatten", "(", ")", ")", "\n", "unsupervised_counts", "=", "counts", "[", ":", "16", "]", "\n", "supervised_counts", "=", "counts", "[", "16", ":", "]", "\n", "assert", "np", ".", "all", "(", "unsupervised_counts", "==", "1", ")", "\n", "assert", "np", ".", "all", "(", "supervised_counts", "==", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler.test_advanced": [[135, 163], ["test_sampler.TestAlternatingSampler._build_mock_dataset", "set", "set", "meddlr.data.AlternatingSampler", "numpy.asarray", "idxs.reshape.reshape.reshape", "set", "set", "numpy.bincount", "numpy.all", "numpy.all", "test_sampler.TestAlternatingSampler.get_supervised_idxs", "test_sampler.TestAlternatingSampler.get_unsupervised_idxs", "len", "list", "len", "len", "idxs[].flatten", "idxs[].flatten", "idxs.reshape.reshape.flatten", "iter"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.test_sampler.TestAlternatingSampler._build_mock_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_supervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_unsupervised_idxs", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.EventStorage.iter"], ["", "def", "test_advanced", "(", "self", ")", ":", "\n", "        ", "\"\"\"Imbalanced data and different periods.\"\"\"", "\n", "T_s", "=", "4", "\n", "T_us", "=", "2", "\n", "# 2 unsupervised, 1 supervised", "\n", "dataset", "=", "self", ".", "_build_mock_dataset", "(", "3", ",", "2", ",", "8", ")", "\n", "\n", "expected_supervised_idxs", "=", "set", "(", "dataset", ".", "get_supervised_idxs", "(", ")", ")", "\n", "expected_unsupervised_idxs", "=", "set", "(", "dataset", ".", "get_unsupervised_idxs", "(", ")", ")", "\n", "\n", "sampler", "=", "AlternatingSampler", "(", "dataset", ",", "T_s", ",", "T_us", ",", "seed", "=", "0", ")", "\n", "assert", "len", "(", "sampler", ")", "==", "16", "+", "32", "\n", "\n", "idxs", "=", "np", ".", "asarray", "(", "list", "(", "iter", "(", "sampler", ")", ")", ")", "\n", "assert", "len", "(", "idxs", ")", "==", "len", "(", "sampler", ")", "\n", "idxs", "=", "idxs", ".", "reshape", "(", "(", "-", "1", ",", "T_s", "+", "T_us", ")", ")", "\n", "supervised_idxs", "=", "set", "(", "idxs", "[", ":", ",", "0", ":", "T_s", "]", ".", "flatten", "(", ")", ")", "\n", "unsupervised_idxs", "=", "set", "(", "idxs", "[", ":", ",", "T_s", ":", "]", ".", "flatten", "(", ")", ")", "\n", "\n", "assert", "supervised_idxs", "==", "expected_supervised_idxs", "\n", "assert", "unsupervised_idxs", "==", "expected_unsupervised_idxs", "\n", "\n", "# Unsupervised indices repeat twice.", "\n", "counts", "=", "np", ".", "bincount", "(", "idxs", ".", "flatten", "(", ")", ")", "\n", "unsupervised_counts", "=", "counts", "[", ":", "16", "]", "\n", "supervised_counts", "=", "counts", "[", "16", ":", "]", "\n", "assert", "np", ".", "all", "(", "unsupervised_counts", "==", "1", ")", "\n", "assert", "np", ".", "all", "(", "supervised_counts", "==", "4", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock.MockSliceDataset.__init__": [[5, 7], ["meddlr.data.slice_dataset.SliceData.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["from", "meddlr", ".", "transforms", ".", "tf_scheduler", "import", "SchedulableMixin", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock.MockSliceDataset.__getitem__": [[8, 11], ["None"], "methods", ["None"], ["def", "generate_mock_mri_data", "(", "ky", "=", "20", ",", "kz", "=", "20", ",", "nc", "=", "8", ",", "nm", "=", "1", ",", "bsz", "=", "1", ",", "scale", "=", "1.0", ",", "rand_func", "=", "\"randn\"", ")", ":", "\n", "    ", "func", "=", "getattr", "(", "torch", ",", "rand_func", ")", "\n", "kspace", "=", "torch", ".", "view_as_complex", "(", "func", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "2", ")", ")", "*", "scale", "\n", "maps", "=", "torch", ".", "view_as_complex", "(", "func", "(", "bsz", ",", "ky", ",", "kz", ",", "nc", ",", "nm", ",", "2", ")", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.__init__": [[14, 27], ["mock._MockDataset.build_examples"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.build_examples"], ["target", "=", "A", "(", "kspace", ",", "adjoint", "=", "True", ")", "\n", "return", "kspace", ",", "maps", ",", "target", "\n", "\n", "\n", "", "class", "MockSchedulable", "(", "SchedulableMixin", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "a", "=", "0.5", ",", "b", "=", "(", "0.2", ",", "1.0", ")", ")", "->", "None", ":", "\n", "        ", "self", ".", "_params", "=", "{", "\"a\"", ":", "a", ",", "\"b\"", ":", "b", "}", "\n", "self", ".", "_param_kinds", "=", "{", "}", "\n", "self", ".", "_schedulers", "=", "[", "]", "\n", "\n", "\n", "", "", "class", "MockIterTracker", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "start", "=", "0", ")", "->", "None", ":", "\n", "        ", "self", ".", "_iter", "=", "start", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.build_examples": [[29, 42], ["groups.items", "examples.extend", "isinstance", "ex.update", "enumerate", "range", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "def", "step", "(", "self", ",", "num", "=", "1", ")", ":", "\n", "        ", "self", ".", "_iter", "+=", "num", "\n", "\n", "", "def", "get_iter", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_iter", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_supervised_idxs": [[43, 45], ["enumerate"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.get_unsupervised_idxs": [[46, 48], ["enumerate"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.__len__": [[49, 51], ["len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.samplers.mock._MockDataset.__getitem__": [[52, 54], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.scan_evaluator.ScanEvaluator.enter_prediction_scope": [[20, 48], ["ValueError", "int", "numpy.asarray", "numpy.where", "len", "scan_evaluator.ScanEvaluator._logger.warning", "ValueError"], "methods", ["None"], ["def", "enter_prediction_scope", "(", "self", ",", "skip_last_scan", ":", "bool", "=", "True", ")", ":", "\n", "        ", "if", "self", ".", "_remaining_state", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You must exit the prediction scope by calling `exit_prediction_scope`.\"", "\n", ")", "\n", "\n", "", "remaining_preds", "=", "[", "]", "\n", "if", "skip_last_scan", ":", "\n", "            ", "try", ":", "\n", "                ", "scan_ids", "=", "np", ".", "asarray", "(", "[", "p", "[", "\"metadata\"", "]", "[", "\"scan_id\"", "]", "for", "p", "in", "self", ".", "_predictions", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Cannot skip last scan. metadata does not contain 'scan_id' keyword.\"", "\n", ")", "\n", "\n", "", "change_idxs", "=", "np", ".", "where", "(", "scan_ids", "[", "1", ":", "]", "!=", "scan_ids", "[", ":", "-", "1", "]", ")", "[", "0", "]", "\n", "if", "len", "(", "change_idxs", ")", "==", "0", ":", "\n", "                ", "self", ".", "_logger", ".", "warning", "(", "\n", "\"Flushing skipped. All current predictions are from the same scan. \"", "\n", "\"To force flush, set `skip_last_scan=False`.\"", "\n", ")", "\n", "return", "False", "\n", "\n", "", "last_idx", "=", "int", "(", "change_idxs", "[", "-", "1", "]", "+", "1", ")", "\n", "remaining_preds", "=", "self", ".", "_predictions", "[", "last_idx", ":", "]", "\n", "self", ".", "_predictions", "=", "self", ".", "_predictions", "[", ":", "last_idx", "]", "\n", "\n", "", "self", ".", "_remaining_state", "=", "{", "\"_predictions\"", ":", "remaining_preds", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.scan_evaluator.ScanEvaluator.exit_prediction_scope": [[49, 59], ["remaining_state.items", "ValueError", "setattr", "scan_evaluator.ScanEvaluator._remaining_state.items", "hasattr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "exit_prediction_scope", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_remaining_state", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You must enter prediction scope first by calling `enter_prediction_scope`\"", "\n", ")", "\n", "\n", "", "remaining_state", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "self", ".", "_remaining_state", ".", "items", "(", ")", "if", "hasattr", "(", "self", ",", "k", ")", "}", "\n", "for", "k", ",", "v", "in", "remaining_state", ".", "items", "(", ")", ":", "\n", "            ", "setattr", "(", "self", ",", "k", ",", "v", ")", "\n", "", "self", ".", "_remaining_state", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.scan_evaluator.ScanEvaluator.flush": [[60, 87], ["scan_evaluator.ScanEvaluator._logger.info", "scan_evaluator.ScanEvaluator.evaluate", "scan_evaluator.ScanEvaluator.enter_prediction_scope", "scan_evaluator.ScanEvaluator.exit_prediction_scope"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.scan_evaluator.ScanEvaluator.enter_prediction_scope", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.exit_prediction_scope"], ["", "def", "flush", "(", "self", ",", "enter_prediction_scope", ":", "bool", "=", "True", ",", "skip_last_scan", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"Clear predictions and computing running metrics.\n\n        Results are added to ``self._running_results``.\n\n        Args:\n            enter_prediction_scope (bool, optional): If ``True``, enter the\n                prediction scope.\n            skip_last_scan (bool, optional): If ``True``, does not flush\n                most recent scan. This avoids prematurely computing metrics\n                before all slices of the scan are available.\n        \"\"\"", "\n", "if", "enter_prediction_scope", ":", "\n", "            ", "success", "=", "self", ".", "enter_prediction_scope", "(", "skip_last_scan", "=", "skip_last_scan", ")", "\n", "# TODO: this means we haven't properly set the state, which is likely because", "\n", "# we dont want to execute this flush. Make the API clearer.", "\n", "if", "success", "is", "False", ":", "\n", "                ", "return", "\n", "\n", "", "", "self", ".", "_logger", ".", "info", "(", "\"Flushing results...\"", ")", "\n", "\n", "self", ".", "_is_flushing", "=", "True", "\n", "self", ".", "evaluate", "(", ")", "\n", "self", ".", "_is_flushing", "=", "False", "\n", "\n", "if", "enter_prediction_scope", ":", "\n", "            ", "self", ".", "exit_prediction_scope", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.scan_evaluator.ScanEvaluator.structure_scans": [[88, 91], ["scan_evaluator.ScanEvaluator.structure_scans"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.structure_scans"], ["", "", "def", "structure_scans", "(", "self", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"Structure scans into volumes to be used to evaluation.\"\"\"", "\n", "return", "structure_scans", "(", "self", ".", "_predictions", ",", "verbose", "=", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.scan_evaluator.structure_scans": [[93, 144], ["collections.defaultdict", "tqdm.tqdm", "bool", "ValueError", "len", "ValueError", "_logger.info", "tuple", "_logger.info", "collections.defaultdict.items", "list", "pred.update", "pred_dict.keys", "meddlr.data.data_utils.structure_patches", "set", "set", "v.contiguous", "sample_dict[].get", "dims.values", "pred.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.structure_patches", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "def", "structure_scans", "(", "\n", "predictions", ",", "\n", "to_struct", "=", "(", "\"pred\"", ",", "\"target\"", ")", ",", "\n", "dims", ":", "Dict", "[", "int", ",", "str", "]", "=", "None", ",", "\n", "metadata", "=", "(", "\"voxel_spacing\"", ",", "\"affine\"", ")", ",", "\n", "contiguous", ":", "bool", "=", "False", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Any", "]", "]", ":", "\n", "    ", "\"\"\"Structure patches into single objects.\n\n    Note:\n        This may not currently be a very fast implementation as stacking occurs multiple times\n        instead of single tensor allocation.\n\n    TODO: Benchmark speeds for future releases.\n    \"\"\"", "\n", "if", "not", "dims", ":", "\n", "        ", "dims", "=", "{", "0", ":", "\"slice_id\"", "}", "\n", "\n", "", "if", "not", "bool", "(", "predictions", "[", "0", "]", "[", "\"metadata\"", "]", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Cannot aggregate scans without metadata\"", ")", "\n", "", "if", "len", "(", "set", "(", "to_struct", ")", "&", "set", "(", "metadata", ")", ")", ">", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Cannot overlap between keys to structure (`to_struct`) \"", "\n", "\"and keys for metadata (`metadata`).\"", "\n", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "_logger", ".", "info", "(", "\"Structuring slices into volumes...\"", ")", "\n", "\n", "", "scan_map", "=", "defaultdict", "(", "dict", ")", "\n", "for", "pred", "in", "predictions", ":", "\n", "        ", "values", "=", "tuple", "(", "pred", "[", "\"metadata\"", "]", "[", "k", "]", "for", "k", "in", "dims", ".", "values", "(", ")", ")", "\n", "scan_map", "[", "pred", "[", "\"metadata\"", "]", "[", "\"scan_id\"", "]", "]", "[", "values", "]", "=", "pred", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "_logger", ".", "info", "(", "\"Structuring slices into volumes...\"", ")", "\n", "\n", "", "scans", "=", "{", "}", "\n", "for", "scan_id", ",", "pred_dict", "in", "tqdm", "(", "scan_map", ".", "items", "(", ")", ")", ":", "\n", "        ", "coords", "=", "list", "(", "pred_dict", ".", "keys", "(", ")", ")", "\n", "pred", "=", "{", "\n", "k", ":", "structure_patches", "(", "[", "pred_dict", "[", "c", "]", "[", "k", "]", "for", "c", "in", "coords", "]", ",", "coords", "=", "coords", ",", "dims", "=", "dims", ")", "\n", "for", "k", "in", "to_struct", "\n", "}", "\n", "if", "contiguous", ":", "\n", "            ", "pred", "=", "{", "k", ":", "v", ".", "contiguous", "(", ")", "for", "k", ",", "v", "in", "pred", ".", "items", "(", ")", "}", "\n", "", "sample_dict", "=", "pred_dict", "[", "coords", "[", "0", "]", "]", "\n", "pred", ".", "update", "(", "{", "k", ":", "sample_dict", "[", "\"metadata\"", "]", ".", "get", "(", "k", ",", "None", ")", "for", "k", "in", "metadata", "}", ")", "\n", "scans", "[", "scan_id", "]", "=", "pred", "\n", "", "return", "scans", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator.__init__": [[34, 119], ["torch.device", "logging.getLogger", "meddlr.data.transforms.transform.build_normalizer", "meddlr.data.transforms.transform.build_normalizer", "ValueError", "any", "seg_evaluation.SemSegEvaluator.default_metrics", "tuple", "x.lower"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.build_normalizer", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.build_normalizer", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.default_metrics"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dataset_name", ",", "\n", "cfg", ",", "\n", "distributed", "=", "False", ",", "\n", "sync_outputs", "=", "False", ",", "\n", "aggregate_scans", "=", "True", ",", "\n", "output_dir", "=", "None", ",", "\n", "group_by_scan", ":", "bool", "=", "False", ",", "\n", "save_seg", ":", "bool", "=", "False", ",", "\n", "metrics", "=", "None", ",", "\n", "flush_period", ":", "bool", "=", "None", ",", "\n", "to_cpu", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n            cfg (CfgNode): config instance\n            output_dir (str): optional, an output directory to dump all\n                results predicted on the dataset. The dump contains two files:\n\n                1. \"instance_predictions.pth\" a file in torch serialization\n                   format that contains all the raw original predictions.\n                2. \"coco_instances_results.json\" a json file in COCO's result\n                   format.\n            distributed (bool, optional): If `True`, collect results from all\n                ranks for evaluation.\n                Otherwise, will evaluate the results in the current process.\n                If using `DistributedDataParallel`, this should likely be `True`.\n            sync_outputs (bool, optional): If `True`, synchronizes all predictions\n                before evaluation.\n                If `False`, synchronizes metrics before reduction.\n                Ignored if `distributed=False`\n            aggregate_scans (bool, optional): If `True`, also computes metrics per\n                scan under the label `'scan_{metric}'` (e.g. scan_l1).\n\n        Not yet supported:\n            running_eval (bool, optional): If `True`, evaluates scans while processing.\n                This reduces the memory overhead. Note if distributed=`True`, sync_outputs\n                must be `False`.\n        \"\"\"", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "self", ".", "_dataset_name", "=", "dataset_name", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "self", ".", "_normalizer", "=", "build_normalizer", "(", "cfg", ")", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_sync_outputs", "=", "sync_outputs", "\n", "self", ".", "_aggregate_scans", "=", "aggregate_scans", "\n", "self", ".", "_group_by_scan", "=", "group_by_scan", "\n", "self", ".", "_save_seg", "=", "save_seg", "\n", "self", ".", "to_cpu", "=", "to_cpu", "\n", "self", ".", "_is_flushing", "=", "False", "\n", "\n", "self", ".", "activation", "=", "cfg", ".", "MODEL", ".", "SEG", ".", "ACTIVATION", "\n", "self", ".", "threshold", "=", "0.5", "\n", "# if self._distributed and self._sync_outputs and running_eval:", "\n", "#     raise ValueError(\"running_eval not possible when outputs must be synced\")", "\n", "\n", "self", ".", "has_bg", "=", "cfg", ".", "MODEL", ".", "SEG", ".", "INCLUDE_BACKGROUND", "or", "cfg", ".", "MODEL", ".", "SEG", ".", "ACTIVATION", "==", "\"softmax\"", "\n", "if", "self", ".", "has_bg", ":", "\n", "# Add \"background\" to class names if desired.", "\n", "            ", "self", ".", "_class_names", "=", "(", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "CLASSES", "\n", "if", "any", "(", "x", ".", "lower", "(", ")", "in", "[", "\"background\"", ",", "\"bg\"", "]", "for", "x", "in", "cfg", ".", "MODEL", ".", "SEG", ".", "CLASSES", ")", "\n", "else", "(", "\"bg\"", ",", ")", "+", "tuple", "(", "cfg", ".", "MODEL", ".", "SEG", ".", "CLASSES", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_class_names", "=", "cfg", ".", "MODEL", ".", "SEG", ".", "CLASSES", "\n", "\n", "", "self", ".", "_metric_names", "=", "[", "]", "\n", "if", "metrics", "is", "not", "False", ":", "\n", "            ", "if", "not", "metrics", ":", "\n", "                ", "metrics", "=", "self", ".", "default_metrics", "(", ")", "\n", "", "self", ".", "_metric_names", "=", "metrics", "\n", "\n", "", "if", "flush_period", "is", "None", ":", "\n", "            ", "flush_period", "=", "cfg", ".", "TEST", ".", "FLUSH_PERIOD", "\n", "", "if", "distributed", "and", "flush_period", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Result flushing is not enabled in distributed mode.\"", ")", "\n", "", "self", ".", "flush_period", "=", "flush_period", "\n", "\n", "self", ".", "_remaining_state", "=", "None", "\n", "self", ".", "_predictions", "=", "[", "]", "\n", "self", ".", "_is_flushing", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator.default_metrics": [[120, 125], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "default_metrics", "(", "cls", ")", ":", "\n", "        ", "\"\"\"The default metrics processed by this class.\"\"\"", "\n", "# TODO: Add support for ASSD_scan", "\n", "return", "_DEFAULT_METRICS", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator.reset": [[126, 141], ["meddlr.metrics.build.build_metrics", "meddlr.metrics.build.build_metrics", "meddlr.metrics.build.build_metrics", "meddlr.metrics.build.build_metrics", "seg_evaluation.SemSegEvaluator.slice_metrics.eval", "seg_evaluation.SemSegEvaluator.scan_metrics.eval", "m.endswith", "m.endswith"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.build.build_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.build.build_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.build.build_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.build.build_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "[", "]", "\n", "self", ".", "_remaining_state", "=", "None", "\n", "self", ".", "_is_flushing", "=", "False", "\n", "\n", "metrics", "=", "self", ".", "_metric_names", "\n", "slice_metrics", "=", "[", "m", "for", "m", "in", "metrics", "if", "not", "m", ".", "endswith", "(", "\"_scan\"", ")", "]", "\n", "scan_metrics", "=", "[", "m", "[", ":", "-", "5", "]", "for", "m", "in", "metrics", "if", "m", ".", "endswith", "(", "\"_scan\"", ")", "]", "\n", "\n", "self", ".", "slice_metrics", "=", "build_metrics", "(", "slice_metrics", ",", "channel_names", "=", "self", ".", "_class_names", ")", "\n", "self", ".", "scan_metrics", "=", "build_metrics", "(", "\n", "scan_metrics", ",", "fmt", "=", "\"{}_scan\"", ",", "channel_names", "=", "self", ".", "_class_names", "\n", ")", "\n", "self", ".", "slice_metrics", ".", "eval", "(", ")", "\n", "self", ".", "scan_metrics", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator.structure_scans": [[142, 146], ["meddlr.evaluation.scan_evaluator.structure_scans", "meddlr.evaluation.scan_evaluator.structure_scans"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.structure_scans", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.structure_scans"], ["", "def", "structure_scans", "(", "self", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"Structure scans into volumes to be used to evaluation.\"\"\"", "\n", "out", "=", "structure_scans", "(", "self", ".", "_predictions", ",", "verbose", "=", "verbose", ",", "dims", "=", "{", "1", ":", "\"slice_id\"", "}", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator.process": [[147, 182], ["seg_evaluation.SemSegEvaluator._parse_sem_seg_label", "seg_evaluation.SemSegEvaluator._parse_sem_seg_pred", "pred.type", "labels.type", "seg_evaluation.SemSegEvaluator._predictions.extend", "preds.to.to.to", "targets.to.to.to", "seg_evaluation.SemSegEvaluator.flush", "len", "len", "abs", "range"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator._parse_sem_seg_label", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator._parse_sem_seg_pred", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a recon model (e.g., GeneralizedRCNN).\n                Currently this should be an empty dictionary.\n            outputs: the outputs of a COCO model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n        \"\"\"", "\n", "labels", ":", "torch", ".", "Tensor", "=", "self", ".", "_parse_sem_seg_label", "(", "inputs", ")", "\n", "pred", ":", "torch", ".", "Tensor", "=", "self", ".", "_parse_sem_seg_pred", "(", "outputs", ")", "\n", "\n", "N", "=", "pred", ".", "shape", "[", "0", "]", "\n", "preds", "=", "pred", ".", "type", "(", "torch", ".", "bool", ")", "\n", "targets", "=", "labels", ".", "type", "(", "torch", ".", "bool", ")", "\n", "if", "self", ".", "to_cpu", ":", "\n", "            ", "preds", "=", "preds", ".", "to", "(", "self", ".", "_cpu_device", ",", "non_blocking", "=", "True", ")", "\n", "targets", "=", "targets", ".", "to", "(", "self", ".", "_cpu_device", ",", "non_blocking", "=", "True", ")", "\n", "\n", "", "self", ".", "_predictions", ".", "extend", "(", "\n", "[", "\n", "{", "\n", "\"pred\"", ":", "preds", "[", "i", "]", ",", "\n", "\"target\"", ":", "targets", "[", "i", "]", ",", "\n", "\"metadata\"", ":", "inputs", "[", "\"metadata\"", "]", "[", "i", "]", "if", "\"metadata\"", "in", "inputs", "else", "{", "}", ",", "\n", "}", "\n", "for", "i", "in", "range", "(", "N", ")", "\n", "]", "\n", ")", "\n", "\n", "has_num_examples", "=", "self", ".", "flush_period", ">", "0", "and", "len", "(", "self", ".", "_predictions", ")", ">=", "self", ".", "flush_period", "\n", "has_num_scans", "=", "self", ".", "flush_period", "<", "0", "and", "len", "(", "\n", "{", "x", "[", "\"metadata\"", "]", "[", "\"scan_id\"", "]", "for", "x", "in", "self", ".", "_predictions", "}", "\n", ")", ">", "abs", "(", "self", ".", "flush_period", ")", "\n", "if", "has_num_examples", "or", "has_num_scans", ":", "\n", "            ", "self", ".", "flush", "(", "enter_prediction_scope", "=", "True", ",", "skip_last_scan", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator.synchronize_predictions": [[183, 189], ["meddlr.synchronize", "meddlr.synchronize", "meddlr.gather", "meddlr.gather", "list", "itertools.chain", "meddlr.is_main_process", "meddlr.is_main_process"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.synchronize", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.synchronize", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.gather", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.gather", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process"], ["", "", "def", "synchronize_predictions", "(", "self", ")", ":", "\n", "        ", "comm", ".", "synchronize", "(", ")", "\n", "self", ".", "_predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "self", ".", "_predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "_predictions", ")", ")", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator.evaluate": [[190, 243], ["enumerate", "seg_evaluation.SemSegEvaluator.slice_metrics.to_dict", "seg_evaluation.SemSegEvaluator.update", "copy.deepcopy", "seg_evaluation.SemSegEvaluator.synchronize_predictions", "len", "seg_evaluation.SemSegEvaluator._logger.warning", "tqdm.tqdm.tqdm", "seg_evaluation.SemSegEvaluator.slice_metrics", "seg_evaluation.SemSegEvaluator.structure_scans", "tqdm.tqdm.tqdm", "seg_evaluation.SemSegEvaluator.scan_metrics.to_dict", "seg_evaluation.SemSegEvaluator.log_summary", "pred[].get", "str", "seg_evaluation.SemSegEvaluator.items", "seg_evaluation.SemSegEvaluator.scan_metrics", "uuid.uuid4", "pred[].unsqueeze", "pred[].unsqueeze", "str", "pred[].unsqueeze", "pred[].unsqueeze", "pred.get", "pred.get", "type", "pred[].get", "uuid.uuid4"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.synchronize_predictions", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.structure_scans", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.log_summary", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "# Sync predictions (if applicable)", "\n", "        ", "if", "self", ".", "_distributed", "and", "self", ".", "_sync_outputs", ":", "\n", "            ", "self", ".", "synchronize_predictions", "(", ")", "\n", "if", "not", "self", ".", "_predictions", ":", "\n", "                ", "return", "{", "}", "\n", "\n", "", "", "if", "len", "(", "self", ".", "_predictions", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "warning", "(", "f\"[{type(self).__name__}] Did not receive valid predictions.\"", ")", "\n", "return", "{", "}", "\n", "\n", "# TODO: Add support in metrics manager for appending metrics to the same scan_id", "\n", "", "for", "_idx", ",", "pred", "in", "enumerate", "(", "tqdm", "(", "self", ".", "_predictions", ",", "desc", "=", "\"Slice Metrics\"", ")", ")", ":", "\n", "            ", "if", "\"metadata\"", "in", "pred", ":", "\n", "                ", "scan_id", "=", "\"/\"", ".", "join", "(", "\n", "str", "(", "pred", "[", "\"metadata\"", "]", ".", "get", "(", "k", ",", "uuid", ".", "uuid4", "(", ")", ")", ")", "for", "k", "in", "[", "\"scan_id\"", ",", "\"slice_id\"", "]", "\n", ")", "\n", "voxel_spacing", "=", "pred", "[", "\"metadata\"", "]", ".", "get", "(", "\"voxel_spacing\"", ",", "None", ")", "\n", "if", "voxel_spacing", ":", "\n", "                    ", "voxel_spacing", "=", "voxel_spacing", "[", "-", "(", "pred", "[", "\"pred\"", "]", ".", "ndim", "-", "1", ")", ":", "]", "\n", "", "", "else", ":", "\n", "                ", "scan_id", "=", "str", "(", "uuid", ".", "uuid4", "(", ")", ")", "\n", "voxel_spacing", "=", "None", "\n", "", "self", ".", "slice_metrics", "(", "\n", "ids", "=", "[", "scan_id", "]", ",", "\n", "preds", "=", "pred", "[", "\"pred\"", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "targets", "=", "pred", "[", "\"target\"", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "voxel_spacing", "=", "voxel_spacing", ",", "\n", "spacing", "=", "voxel_spacing", ",", "\n", ")", "\n", "\n", "# Compute metrics per scan.", "\n", "", "if", "self", ".", "_aggregate_scans", ":", "\n", "            ", "scans", "=", "self", ".", "structure_scans", "(", ")", "\n", "for", "scan_id", ",", "pred", "in", "tqdm", "(", "scans", ".", "items", "(", ")", ",", "desc", "=", "\"Scan Metrics\"", ")", ":", "\n", "                ", "self", ".", "scan_metrics", "(", "\n", "ids", "=", "[", "scan_id", "]", ",", "\n", "preds", "=", "pred", "[", "\"pred\"", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "targets", "=", "pred", "[", "\"target\"", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "category_dim", "=", "0", ",", "\n", "voxel_spacing", "=", "pred", ".", "get", "(", "\"voxel_spacing\"", ",", "None", ")", ",", "\n", "spacing", "=", "pred", ".", "get", "(", "\"voxel_spacing\"", ",", "None", ")", ",", "\n", ")", "\n", "\n", "", "", "pred_vals", "=", "self", ".", "slice_metrics", ".", "to_dict", "(", ")", "\n", "pred_vals", ".", "update", "(", "self", ".", "scan_metrics", ".", "to_dict", "(", ")", ")", "\n", "self", ".", "_results", "=", "pred_vals", "\n", "\n", "if", "not", "self", ".", "_is_flushing", ":", "\n", "            ", "self", ".", "log_summary", "(", ")", "\n", "\n", "# Copy so the caller can do whatever with results", "\n", "", "return", "copy", ".", "deepcopy", "(", "self", ".", "_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator.log_summary": [[244, 289], ["seg_evaluation.SemSegEvaluator._logger.info", "seg_evaluation.SemSegEvaluator._logger.info", "os.makedirs", "os.path.join", "os.path.join", "os.path.join", "seg_evaluation.SemSegEvaluator.slice_metrics.to_pandas", "df.to_csv", "seg_evaluation.SemSegEvaluator.scan_metrics.to_pandas", "df.to_csv", "meddlr.is_main_process", "meddlr.is_main_process", "open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "seg_evaluation.SemSegEvaluator.slice_metrics.summary", "seg_evaluation.SemSegEvaluator.scan_metrics.summary", "seg_evaluation.SemSegEvaluator.slice_metrics.summary", "seg_evaluation.SemSegEvaluator.scan_metrics.summary", "type", "type", "time.strftime"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary"], ["", "def", "log_summary", "(", "self", ")", ":", "\n", "        ", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "return", "\n", "", "output_dir", "=", "self", ".", "_output_dir", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "\"[{}] Slice metrics summary:\\n{}\"", ".", "format", "(", "\n", "type", "(", "self", ")", ".", "__name__", ",", "self", ".", "slice_metrics", ".", "summary", "(", ")", "\n", ")", "\n", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "\"[{}] Scan metrics summary:\\n{}\"", ".", "format", "(", "\n", "type", "(", "self", ")", ".", "__name__", ",", "self", ".", "scan_metrics", ".", "summary", "(", ")", "\n", ")", "\n", ")", "\n", "\n", "if", "not", "output_dir", ":", "\n", "            ", "return", "\n", "\n", "", "dirpath", "=", "output_dir", "\n", "os", ".", "makedirs", "(", "dirpath", ",", "exist_ok", "=", "True", ")", "\n", "test_results_summary_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "\"results.txt\"", ")", "\n", "slice_metrics_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "\"slice_metrics.csv\"", ")", "\n", "scan_metrics_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "\"scan_metrics.csv\"", ")", "\n", "\n", "# Write details to test file", "\n", "with", "open", "(", "test_results_summary_path", ",", "\"w+\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "\"Results generated on %s\\n\"", "%", "time", ".", "strftime", "(", "\"%X %x %Z\"", ")", ")", "\n", "# f.write(\"Weights Loaded: %s\\n\" % os.path.basename(self._config.TEST_WEIGHT_PATH))", "\n", "\n", "f", ".", "write", "(", "\"--\"", "*", "40", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"Slice Metrics:\\n\"", ")", "\n", "f", ".", "write", "(", "self", ".", "slice_metrics", ".", "summary", "(", ")", ")", "\n", "f", ".", "write", "(", "\"--\"", "*", "40", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"Scan Metrics:\\n\"", ")", "\n", "f", ".", "write", "(", "self", ".", "scan_metrics", ".", "summary", "(", ")", ")", "\n", "f", ".", "write", "(", "\"--\"", "*", "40", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "df", ":", "pd", ".", "DataFrame", "=", "self", ".", "slice_metrics", ".", "to_pandas", "(", ")", "\n", "df", ".", "to_csv", "(", "slice_metrics_path", ",", "header", "=", "True", ",", "index", "=", "True", ")", "\n", "\n", "df", ":", "pd", ".", "DataFrame", "=", "self", ".", "scan_metrics", ".", "to_pandas", "(", ")", "\n", "df", ".", "to_csv", "(", "scan_metrics_path", ",", "header", "=", "True", ",", "index", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator._parse_sem_seg_pred": [[290, 325], ["key.endswith", "meddlr.to_onehot.type", "len", "ValueError", "len", "key.endswith", "key.endswith", "input.keys", "torch.sigmoid", "list", "meddlr.pred_to_categorical", "meddlr.pred_to_categorical", "meddlr.to_onehot", "meddlr.to_onehot", "input.keys", "meddlr.to_onehot", "meddlr.to_onehot", "len", "torch.argmax", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.pred_to_categorical", "home.repos.pwc.inspect_result.ad12_meddlr.ops.categorical.pred_to_categorical"], ["", "def", "_parse_sem_seg_pred", "(", "self", ",", "input", ")", ":", "\n", "# TODO: Update these values", "\n", "        ", "num_classes", "=", "1", "\n", "channel_dim", "=", "1", "\n", "\n", "keys", "=", "[", "\"sem_seg_pred\"", ",", "\"sem_seg_probs\"", ",", "\"sem_seg_logits\"", ",", "\"pred\"", ",", "\"probs\"", ",", "\"logits\"", "]", "\n", "existing_keys", "=", "[", "k", "for", "k", "in", "keys", "if", "k", "in", "input", ".", "keys", "(", ")", "]", "\n", "if", "len", "(", "existing_keys", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f\"`input` must have one of keys: {keys}.\\n\\tGot: {list(input.keys())}\"", ")", "\n", "", "key", "=", "existing_keys", "[", "0", "]", "\n", "assert", "input", "[", "key", "]", ".", "shape", "[", "1", "]", "==", "len", "(", "self", ".", "_class_names", ")", ",", "input", "[", "key", "]", ".", "shape", "\n", "\n", "if", "key", ".", "endswith", "(", "\"pred\"", ")", ":", "\n", "            ", "pred", "=", "input", "[", "key", "]", "\n", "", "elif", "key", ".", "endswith", "(", "\"logits\"", ")", ":", "\n", "            ", "logits", "=", "input", "[", "key", "]", "\n", "if", "self", ".", "activation", "==", "\"sigmoid\"", ":", "\n", "                ", "probs", "=", "torch", ".", "sigmoid", "(", "logits", ")", "\n", "pred", "=", "(", "probs", ">=", "self", ".", "threshold", ")", ".", "type", "(", "torch", ".", "long", ")", "\n", "", "elif", "self", ".", "activation", "==", "\"softmax\"", ":", "\n", "                ", "pred", "=", "oF", ".", "pred_to_categorical", "(", "\n", "logits", ",", "activation", "=", "self", ".", "activation", ",", "channel_dim", "=", "1", ",", "threshold", "=", "0.5", "\n", ")", "\n", "pred", "=", "oF", ".", "to_onehot", "(", "pred", ",", "len", "(", "num_classes", ")", "+", "1", ")", "\n", "", "", "elif", "key", ".", "endswith", "(", "\"probs\"", ")", ":", "\n", "            ", "probs", "=", "input", "[", "key", "]", "\n", "if", "self", ".", "activation", "==", "\"sigmoid\"", ":", "\n", "                ", "pred", "=", "probs", ">=", "self", ".", "threshold", "\n", "", "elif", "self", ".", "activation", "==", "\"softmax\"", ":", "\n", "                ", "pred", "=", "oF", ".", "to_onehot", "(", "\n", "torch", ".", "argmax", "(", "probs", ",", "dim", "=", "channel_dim", ")", ",", "\n", "num_classes", "=", "len", "(", "self", ".", "_class_names", ")", "+", "1", ",", "\n", ")", "\n", "\n", "", "", "return", "pred", ".", "type", "(", "torch", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.seg_evaluation.SemSegEvaluator._parse_sem_seg_label": [[326, 336], ["output[].type", "len", "ValueError", "len", "output.keys", "list", "output.keys"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["", "def", "_parse_sem_seg_label", "(", "self", ",", "output", ")", ":", "\n", "        ", "keys", "=", "[", "\"sem_seg\"", ",", "\"sem_seg_labels\"", ",", "\"sem_seg_target\"", ",", "\"labels\"", ",", "\"target\"", "]", "\n", "existing_keys", "=", "[", "k", "for", "k", "in", "keys", "if", "k", "in", "output", ".", "keys", "(", ")", "]", "\n", "if", "len", "(", "existing_keys", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"`output` must have one of keys: {keys}.\\n\\tGot: {list(output.keys())}\"", "\n", ")", "\n", "", "key", "=", "existing_keys", "[", "0", "]", "\n", "assert", "output", "[", "key", "]", ".", "shape", "[", "1", "]", "==", "len", "(", "self", ".", "_class_names", ")", ",", "f\"Key '{key}': {output[key].shape}\"", "\n", "return", "output", "[", "key", "]", ".", "type", "(", "torch", ".", "uint8", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.__init__": [[34, 130], ["torch.device", "logging.getLogger", "meddlr.data.transforms.transform.build_normalizer", "collections.defaultdict", "os.makedirs", "ValueError", "os.path.join", "os.makedirs", "ValueError", "recon_evaluation.ReconEvaluator.default_metrics"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.build_normalizer", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.default_metrics"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dataset_name", ",", "\n", "cfg", ",", "\n", "distributed", "=", "False", ",", "\n", "sync_outputs", "=", "False", ",", "\n", "aggregate_scans", "=", "True", ",", "\n", "group_by_scan", "=", "False", ",", "\n", "output_dir", "=", "None", ",", "\n", "skip_rescale", "=", "False", ",", "\n", "save_scans", "=", "False", ",", "\n", "metrics", "=", "None", ",", "\n", "flush_period", ":", "int", "=", "None", ",", "\n", "to_cpu", "=", "False", ",", "\n", "channel_names", "=", "None", ",", "\n", "eval_in_process", "=", "False", ",", "\n", "structure_channel_by", "=", "None", ",", "\n", "prefix", "=", "\"val\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n            cfg (CfgNode): config instance\n            output_dir (str): optional, an output directory to dump all\n                results predicted on the dataset.\n            distributed (bool, optional): If ``True``, collect results from all\n                ranks for evaluation. Otherwise, will evaluate the results in the\n                current process. \u2202If using ``DistributedDataParallel``, this should likely\n                be ``True``.\n            sync_outputs (bool, optional): If ``True``, synchronizes all predictions\n                before evaluation. If ``False``, synchronizes metrics before reduction.\n                Ignored if ``distributed=False``.\n            aggregate_scans (bool, optional): If ``True``, also computes metrics per\n                scan under the label `'scan_{metric}'` (e.g. scan_l1).\n            group_by_scan (bool, optional): If `True`, groups metrics by scan.\n                `self.evaluate()` will return a dict of scan_id -> dict[metric name, metric value]\n            skip_rescale (bool, optional): If `True`, skips rescaling the output and target\n                by the mean/std.\n            save_scans (bool, optional): If `True`, saves predictions to .npy file.\n            metrics (Sequence[str], optional): To avoid computing metrics, set to ``False``.\n                Defaults to all supported recon metrics. To process metrics on the full scan,\n                append ``'_scan'`` to the metric name (e.g. `'psnr_scan'`).\n            flush_period (int, optional): The approximate period over which predictions\n                are cleared and running results are computed. This parameter helps\n                mitigate OOM errors. The period is equivalent to number of examples\n                (not batches).\n            to_cpu (bool, optional): If ``True``, move all data to the cpu to do computation.\n            eval_in_process (bool, optional): If ``True``, run slice/patch evaluation\n                while processing. This may increase overall throughput.\n        \"\"\"", "\n", "self", ".", "_dataset_name", "=", "dataset_name", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "if", "self", ".", "_output_dir", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "_output_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "self", ".", "_normalizer", "=", "build_normalizer", "(", "cfg", ")", "\n", "self", ".", "_group_by_scan", "=", "group_by_scan", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_sync_outputs", "=", "sync_outputs", "\n", "self", ".", "_aggregate_scans", "=", "aggregate_scans", "\n", "self", ".", "_skip_rescale", "=", "skip_rescale", "\n", "self", ".", "_channel_names", "=", "channel_names", "\n", "self", ".", "_structure_channel_by", "=", "structure_channel_by", "\n", "self", ".", "_prefix", "=", "prefix", "\n", "\n", "if", "save_scans", "and", "(", "not", "output_dir", "or", "not", "aggregate_scans", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"`output_dir` and `aggregate_scans` must be specified to save scans.\"", ")", "\n", "", "self", ".", "_save_scans", "=", "save_scans", "\n", "self", ".", "_save_scan_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"pred\"", ")", "if", "self", ".", "_output_dir", "else", "None", "\n", "if", "self", ".", "_save_scan_dir", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "_save_scan_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "if", "metrics", "is", "False", ":", "\n", "            ", "metrics", "=", "[", "]", "\n", "", "elif", "metrics", "in", "(", "None", ",", "True", ")", ":", "\n", "            ", "metrics", "=", "self", ".", "default_metrics", "(", ")", "\n", "", "self", ".", "_metric_names", "=", "metrics", "\n", "\n", "self", ".", "_results", "=", "None", "\n", "\n", "if", "flush_period", "is", "None", ":", "\n", "            ", "flush_period", "=", "cfg", ".", "TEST", ".", "FLUSH_PERIOD", "\n", "", "if", "distributed", "and", "flush_period", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Result flushing is not enabled in distributed mode.\"", ")", "\n", "", "self", ".", "flush_period", "=", "flush_period", "\n", "self", ".", "to_cpu", "=", "to_cpu", "\n", "self", ".", "eval_in_process", "=", "eval_in_process", "\n", "\n", "self", ".", "_remaining_state", "=", "None", "\n", "self", ".", "_predictions", "=", "[", "]", "\n", "self", ".", "_is_flushing", "=", "False", "\n", "\n", "# Memory", "\n", "self", ".", "_memory", "=", "defaultdict", "(", "list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.default_metrics": [[131, 137], ["metrics.extend"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "default_metrics", "(", "cls", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"The default metrics processed by this class.\"\"\"", "\n", "metrics", "=", "[", "\"psnr\"", ",", "\"psnr_mag\"", ",", "\"ssim (Wang)\"", ",", "\"nrmse\"", ",", "\"nrmse_mag\"", "]", "\n", "metrics", ".", "extend", "(", "[", "f\"{x}_scan\"", "for", "x", "in", "metrics", "]", ")", "\n", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.reset": [[138, 160], ["collections.defaultdict", "meddlr.metrics.build.build_metrics", "meddlr.metrics.build.build_metrics", "recon_evaluation.ReconEvaluator.slice_metrics.eval", "recon_evaluation.ReconEvaluator.scan_metrics.eval", "m.endswith", "m.endswith"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.build.build_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.build.build_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_remaining_state", "=", "None", "\n", "self", ".", "_predictions", "=", "[", "]", "\n", "self", ".", "_is_flushing", "=", "False", "\n", "self", ".", "_memory", "=", "defaultdict", "(", "list", ")", "\n", "\n", "metrics", "=", "self", ".", "_metric_names", "\n", "prefix", "=", "self", ".", "_prefix", "+", "\"_\"", "if", "self", ".", "_prefix", "else", "\"\"", "\n", "slice_metrics", "=", "[", "m", "for", "m", "in", "metrics", "if", "not", "m", ".", "endswith", "(", "\"_scan\"", ")", "]", "\n", "scan_metrics", "=", "[", "m", "[", ":", "-", "5", "]", "for", "m", "in", "metrics", "if", "m", ".", "endswith", "(", "\"_scan\"", ")", "]", "\n", "self", ".", "slice_metrics", "=", "build_metrics", "(", "\n", "slice_metrics", ",", "\n", "fmt", "=", "prefix", "+", "\"{}\"", ",", "\n", "channel_names", "=", "self", ".", "_channel_names", ",", "\n", ")", "\n", "self", ".", "scan_metrics", "=", "build_metrics", "(", "\n", "scan_metrics", ",", "\n", "fmt", "=", "prefix", "+", "\"{}_scan\"", ",", "\n", "channel_names", "=", "self", ".", "_channel_names", ",", "\n", ")", "\n", "self", ".", "slice_metrics", ".", "eval", "(", ")", "\n", "self", ".", "scan_metrics", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.exit_prediction_scope": [[161, 166], ["super().exit_prediction_scope", "torch.cuda.is_available", "torch.cuda.is_initialized", "torch.cuda.empty_cache"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.exit_prediction_scope"], ["", "def", "exit_prediction_scope", "(", "self", ")", ":", "\n", "        ", "ret_val", "=", "super", "(", ")", ".", "exit_prediction_scope", "(", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "torch", ".", "cuda", ".", "is_initialized", "(", ")", ":", "\n", "            ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "", "return", "ret_val", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.process": [[167, 233], ["recon_evaluation.ReconEvaluator._predictions.extend", "recon_evaluation.ReconEvaluator._append_memory", "recon_evaluation.ReconEvaluator._normalizer.undo", "preds.to.to.to", "targets.to.to.to", "recon_evaluation.ReconEvaluator.evaluate_prediction", "recon_evaluation.ReconEvaluator.flush", "recon_evaluation.ReconEvaluator._append_memory", "len", "len", "abs", "range", "str"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator._append_memory", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.transform.AffineNormalizer.undo", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.evaluate_prediction", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator._append_memory", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a recon model (e.g., GeneralizedRCNN).\n                Currently this should be an empty dictionary.\n            outputs: the outputs of a COCO model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n\n        Note:\n            All elements in ``inputs`` and ``outputs`` should already\n            be detached from the computational graph.\n        \"\"\"", "\n", "N", "=", "outputs", "[", "\"pred\"", "]", ".", "shape", "[", "0", "]", "\n", "\n", "preds", ":", "torch", ".", "Tensor", "\n", "targets", ":", "torch", ".", "Tensor", "\n", "\n", "if", "self", ".", "_skip_rescale", ":", "\n", "# Do not rescale the outputs", "\n", "            ", "preds", "=", "outputs", "[", "\"pred\"", "]", "\n", "targets", "=", "outputs", "[", "\"target\"", "]", "\n", "", "else", ":", "\n", "            ", "normalized", "=", "self", ".", "_normalizer", ".", "undo", "(", "\n", "image", "=", "outputs", "[", "\"pred\"", "]", ",", "\n", "target", "=", "outputs", "[", "\"target\"", "]", ",", "\n", "mean", "=", "inputs", "[", "\"mean\"", "]", ",", "\n", "std", "=", "inputs", "[", "\"std\"", "]", ",", "\n", "channels_last", "=", "True", ",", "\n", ")", "\n", "preds", "=", "normalized", "[", "\"image\"", "]", "\n", "targets", "=", "normalized", "[", "\"target\"", "]", "\n", "\n", "", "if", "self", ".", "to_cpu", ":", "\n", "            ", "preds", "=", "preds", ".", "to", "(", "self", ".", "_cpu_device", ",", "non_blocking", "=", "True", ")", "\n", "targets", "=", "targets", ".", "to", "(", "self", ".", "_cpu_device", ",", "non_blocking", "=", "True", ")", "\n", "\n", "", "if", "self", ".", "eval_in_process", ":", "\n", "            ", "self", ".", "evaluate_prediction", "(", "\n", "{", "\"pred\"", ":", "preds", ",", "\"target\"", ":", "targets", "}", ",", "\n", "self", ".", "slice_metrics", ",", "\n", "[", "\n", "\"-\"", ".", "join", "(", "[", "str", "(", "md", "[", "field", "]", ")", "for", "field", "in", "(", "\"scan_id\"", ",", "\"slice_id\"", ")", "]", ")", "\n", "for", "md", "in", "inputs", "[", "\"metadata\"", "]", "\n", "]", ",", "\n", "is_batch", "=", "True", ",", "\n", ")", "\n", "\n", "", "self", ".", "_predictions", ".", "extend", "(", "\n", "[", "\n", "{", "\n", "\"pred\"", ":", "preds", "[", "i", "]", ",", "\n", "\"target\"", ":", "targets", "[", "i", "]", ",", "\n", "\"metadata\"", ":", "inputs", "[", "\"metadata\"", "]", "[", "i", "]", "if", "\"metadata\"", "in", "inputs", "else", "{", "}", ",", "\n", "}", "\n", "for", "i", "in", "range", "(", "N", ")", "\n", "]", "\n", ")", "\n", "self", ".", "_append_memory", "(", "\"after_predictions\"", ")", "\n", "\n", "has_num_examples", "=", "self", ".", "flush_period", ">", "0", "and", "len", "(", "self", ".", "_predictions", ")", ">=", "self", ".", "flush_period", "\n", "has_num_scans", "=", "self", ".", "flush_period", "<", "0", "and", "len", "(", "\n", "{", "x", "[", "\"metadata\"", "]", "[", "\"scan_id\"", "]", "for", "x", "in", "self", ".", "_predictions", "}", "\n", ")", ">", "abs", "(", "self", ".", "flush_period", ")", "\n", "if", "has_num_examples", "or", "has_num_scans", ":", "\n", "            ", "self", ".", "flush", "(", "enter_prediction_scope", "=", "True", ",", "skip_last_scan", "=", "True", ")", "\n", "self", ".", "_append_memory", "(", "\"after_flush\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.structure_scans": [[234, 265], ["meddlr.evaluation.scan_evaluator.structure_scans", "out[].update", "[].squeeze().contiguous", "[].squeeze"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.structure_scans", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["", "", "def", "structure_scans", "(", "self", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"Structure scans into volumes to be used to evaluation.\"\"\"", "\n", "structure_channel_by", "=", "self", ".", "_structure_channel_by", "\n", "structure_by", "=", "{", "0", ":", "\"slice_id\"", "}", "\n", "if", "structure_channel_by", "is", "not", "None", ":", "\n", "# This does not work when predictions are real/imaginary are separate channels", "\n", "# TODO: Fix this.", "\n", "            ", "structure_by", "[", "-", "1", "]", "=", "structure_channel_by", "\n", "", "to_struct", "=", "(", "\"pred\"", ",", "\"target\"", ")", "\n", "\n", "# Making a tensor contiguous can be an expensive operation.", "\n", "# We want to do it as few times as possible. Because we have to", "\n", "# do it anyway when we squeeze the tensor when structuring by channel,", "\n", "# we opt not to do when first structuring the scans.", "\n", "contiguous", "=", "structure_channel_by", "is", "None", "\n", "\n", "out", "=", "structure_scans", "(", "\n", "self", ".", "_predictions", ",", "\n", "to_struct", "=", "to_struct", ",", "\n", "dims", "=", "structure_by", ",", "\n", "contiguous", "=", "contiguous", ",", "\n", "verbose", "=", "verbose", ",", "\n", ")", "\n", "\n", "if", "structure_channel_by", "is", "not", "None", ":", "\n", "            ", "for", "scan_id", "in", "out", ":", "\n", "                ", "out", "[", "scan_id", "]", ".", "update", "(", "\n", "{", "k", ":", "out", "[", "scan_id", "]", "[", "k", "]", ".", "squeeze", "(", "-", "2", ")", ".", "contiguous", "(", ")", "for", "k", "in", "to_struct", "}", "\n", ")", "\n", "\n", "", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.synchronize_predictions": [[266, 272], ["meddlr.synchronize", "meddlr.gather", "list", "itertools.chain", "meddlr.is_main_process"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.synchronize", "home.repos.pwc.inspect_result.ad12_meddlr.utils.comm.gather", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process"], ["", "def", "synchronize_predictions", "(", "self", ")", ":", "\n", "        ", "comm", ".", "synchronize", "(", ")", "\n", "self", ".", "_predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "self", ".", "_predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "_predictions", ")", ")", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.evaluate": [[273, 322], ["bool", "copy.deepcopy", "recon_evaluation.ReconEvaluator.synchronize_predictions", "len", "recon_evaluation.ReconEvaluator._logger.warning", "tqdm.tqdm.tqdm", "recon_evaluation.ReconEvaluator.structure_scans", "tqdm.tqdm.tqdm", "recon_evaluation.ReconEvaluator._group_results_by_scan", "recon_evaluation.ReconEvaluator.slice_metrics.to_dict", "recon_evaluation.ReconEvaluator.update", "recon_evaluation.ReconEvaluator.log_summary", "recon_evaluation.ReconEvaluator.evaluate_prediction", "recon_evaluation.ReconEvaluator.items", "recon_evaluation.ReconEvaluator.evaluate_prediction", "recon_evaluation.ReconEvaluator.scan_metrics.to_dict", "silx.dicttoh5", "meddlr.is_main_process", "meddlr.is_main_process", "os.path.join", "str", "pred[].cpu"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.synchronize_predictions", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.structure_scans", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator._group_results_by_scan", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.log_summary", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.evaluate_prediction", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.evaluate_prediction", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process", "home.repos.pwc.inspect_result.ad12_meddlr.transforms.mixins.DeviceMixin.cpu"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "# Sync predictions (if applicable)", "\n", "        ", "if", "self", ".", "_distributed", "and", "self", ".", "_sync_outputs", ":", "\n", "            ", "self", ".", "synchronize_predictions", "(", ")", "\n", "if", "not", "self", ".", "_predictions", ":", "\n", "                ", "return", "{", "}", "\n", "\n", "", "", "if", "len", "(", "self", ".", "_predictions", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "warning", "(", "\"[ReconEvaluator] Did not receive valid predictions.\"", ")", "\n", "return", "{", "}", "\n", "\n", "# Compute metrics per slice (if not already done during process step).", "\n", "", "if", "not", "self", ".", "eval_in_process", ":", "\n", "            ", "for", "pred", "in", "tqdm", "(", "\n", "self", ".", "_predictions", ",", "desc", "=", "\"Slice metric\"", ",", "disable", "=", "not", "comm", ".", "is_main_process", "(", ")", "\n", ")", ":", "\n", "                ", "self", ".", "evaluate_prediction", "(", "\n", "pred", ",", "\n", "self", ".", "slice_metrics", ",", "\n", "\"-\"", ".", "join", "(", "[", "str", "(", "pred", "[", "\"metadata\"", "]", "[", "x", "]", ")", "for", "x", "in", "(", "\"scan_id\"", ",", "\"slice_id\"", ")", "]", ")", ",", "\n", ")", "\n", "\n", "# Compute metrics per scan.", "\n", "", "", "has_metadata", "=", "bool", "(", "self", ".", "_predictions", "[", "0", "]", "[", "\"metadata\"", "]", ")", "\n", "if", "self", ".", "_aggregate_scans", "and", "has_metadata", ":", "\n", "            ", "scans", "=", "self", ".", "structure_scans", "(", ")", "\n", "for", "scan_id", ",", "pred", "in", "tqdm", "(", "\n", "scans", ".", "items", "(", ")", ",", "desc", "=", "\"Scan Metrics\"", ",", "disable", "=", "not", "comm", ".", "is_main_process", "(", ")", "\n", ")", ":", "\n", "                ", "self", ".", "evaluate_prediction", "(", "pred", ",", "self", ".", "scan_metrics", ",", "scan_id", ")", "\n", "if", "self", ".", "_save_scans", ":", "\n", "                    ", "sio", ".", "dicttoh5", "(", "\n", "{", "\"pred\"", ":", "pred", "[", "\"pred\"", "]", ".", "cpu", "(", ")", "}", ",", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "_save_scan_dir", ",", "f\"{scan_id}.h5\"", ")", ",", "\n", ")", "\n", "\n", "", "", "", "if", "self", ".", "_group_by_scan", ":", "\n", "            ", "pred_vals", "=", "self", ".", "_group_results_by_scan", "(", ")", "\n", "", "else", ":", "\n", "            ", "pred_vals", "=", "self", ".", "slice_metrics", ".", "to_dict", "(", ")", "\n", "pred_vals", ".", "update", "(", "self", ".", "scan_metrics", ".", "to_dict", "(", ")", ")", "\n", "\n", "", "self", ".", "_results", "=", "pred_vals", "\n", "\n", "if", "not", "self", ".", "_is_flushing", ":", "\n", "            ", "self", ".", "log_summary", "(", ")", "\n", "\n", "# Copy so the caller can do whatever with results", "\n", "", "return", "copy", ".", "deepcopy", "(", "self", ".", "_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator._group_results_by_scan": [[323, 340], ["collections.defaultdict", "recon_evaluation.ReconEvaluator.slice_metrics.to_dict", "collections.defaultdict", "recon_evaluation.ReconEvaluator.items", "collections.defaultdict.items", "recon_evaluation.ReconEvaluator.scan_metrics.to_dict", "recon_evaluation.ReconEvaluator.items", "[].append", "metrics_dict.items", "collections.defaultdict", "numpy.mean", "slice_id.rsplit"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "_group_results_by_scan", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get results grouping by scan.\"\"\"", "\n", "pred_vals", "=", "defaultdict", "(", "dict", ")", "\n", "\n", "slice_metrics", "=", "self", ".", "slice_metrics", ".", "to_dict", "(", "group_by", "=", "[", "\"id\"", ",", "\"Metric\"", "]", ")", "\n", "agg_slice_metrics", "=", "defaultdict", "(", "lambda", ":", "defaultdict", "(", "list", ")", ")", "\n", "for", "(", "slice_id", ",", "metric_name", ")", ",", "value", "in", "slice_metrics", ".", "items", "(", ")", ":", "\n", "            ", "agg_slice_metrics", "[", "slice_id", ".", "rsplit", "(", "\"-\"", ",", "1", ")", "[", "0", "]", "]", "[", "metric_name", "]", ".", "append", "(", "value", ")", "\n", "", "for", "scan_id", ",", "metrics_dict", "in", "agg_slice_metrics", ".", "items", "(", ")", ":", "\n", "            ", "for", "metrics_name", ",", "values", "in", "metrics_dict", ".", "items", "(", ")", ":", "\n", "                ", "pred_vals", "[", "scan_id", "]", "[", "metrics_name", "]", "=", "np", ".", "mean", "(", "values", ")", "\n", "\n", "", "", "scan_metrics", "=", "self", ".", "scan_metrics", ".", "to_dict", "(", "group_by", "=", "[", "\"id\"", ",", "\"Metric\"", "]", ")", "\n", "for", "(", "scan_id", ",", "metric_name", ")", ",", "value", "in", "scan_metrics", ".", "items", "(", ")", ":", "\n", "            ", "pred_vals", "[", "scan_id", "]", "[", "metric_name", "]", "=", "value", "\n", "\n", "", "return", "pred_vals", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.log_summary": [[341, 390], ["recon_evaluation.ReconEvaluator._logger.info", "os.makedirs", "os.path.join", "os.path.join", "os.path.join", "recon_evaluation.ReconEvaluator.slice_metrics.to_pandas", "df.to_csv", "recon_evaluation.ReconEvaluator.scan_metrics.to_pandas", "df.to_csv", "meddlr.is_main_process", "recon_evaluation.ReconEvaluator._logger.info", "open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "recon_evaluation.ReconEvaluator.slice_metrics.summary", "recon_evaluation.ReconEvaluator.slice_metrics.summary", "f.write", "f.write", "type", "recon_evaluation.ReconEvaluator.scan_metrics.summary", "time.strftime", "recon_evaluation.ReconEvaluator.scan_metrics.summary", "type"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.to_pandas", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.is_main_process", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.utils.events.WandBWriter.write", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.summary"], ["", "def", "log_summary", "(", "self", ")", ":", "\n", "        ", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "return", "\n", "\n", "", "output_dir", "=", "self", ".", "_output_dir", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "\"[{}] Slice metrics summary:\\n{}\"", ".", "format", "(", "\n", "type", "(", "self", ")", ".", "__name__", ",", "self", ".", "slice_metrics", ".", "summary", "(", ")", "\n", ")", "\n", ")", "\n", "# TODO: Make this based off if metrics has scans", "\n", "if", "self", ".", "_aggregate_scans", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\n", "\"[{}] Scan metrics summary:\\n{}\"", ".", "format", "(", "\n", "type", "(", "self", ")", ".", "__name__", ",", "self", ".", "scan_metrics", ".", "summary", "(", ")", "\n", ")", "\n", ")", "\n", "\n", "", "if", "not", "output_dir", ":", "\n", "            ", "return", "\n", "\n", "", "dirpath", "=", "output_dir", "\n", "os", ".", "makedirs", "(", "dirpath", ",", "exist_ok", "=", "True", ")", "\n", "test_results_summary_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "\"results.txt\"", ")", "\n", "slice_metrics_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "\"slice_metrics.csv\"", ")", "\n", "scan_metrics_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "\"scan_metrics.csv\"", ")", "\n", "\n", "# Write details to test file", "\n", "with", "open", "(", "test_results_summary_path", ",", "\"w+\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "\"Results generated on %s\\n\"", "%", "time", ".", "strftime", "(", "\"%X %x %Z\"", ")", ")", "\n", "# f.write(\"Weights Loaded: %s\\n\" % os.path.basename(self._config.TEST_WEIGHT_PATH))", "\n", "\n", "f", ".", "write", "(", "\"--\"", "*", "40", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"Slice Metrics:\\n\"", ")", "\n", "f", ".", "write", "(", "self", ".", "slice_metrics", ".", "summary", "(", ")", ")", "\n", "f", ".", "write", "(", "\"--\"", "*", "40", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "if", "self", ".", "_aggregate_scans", ":", "\n", "                ", "f", ".", "write", "(", "\"Scan Metrics:\\n\"", ")", "\n", "f", ".", "write", "(", "self", ".", "scan_metrics", ".", "summary", "(", ")", ")", "\n", "", "f", ".", "write", "(", "\"--\"", "*", "40", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "df", ":", "pd", ".", "DataFrame", "=", "self", ".", "slice_metrics", ".", "to_pandas", "(", ")", "\n", "df", ".", "to_csv", "(", "slice_metrics_path", ",", "header", "=", "True", ",", "index", "=", "True", ")", "\n", "\n", "df", ":", "pd", ".", "DataFrame", "=", "self", ".", "scan_metrics", ".", "to_pandas", "(", ")", "\n", "df", ".", "to_csv", "(", "scan_metrics_path", ",", "header", "=", "True", ",", "index", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.evaluate_prediction": [[391, 405], ["metrics", "metrics.to_dict", "meddlr.ops.complex.channel_first", "meddlr.ops.complex.channel_first", "output.unsqueeze", "target.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.channel_first", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.channel_first"], ["", "def", "evaluate_prediction", "(", "\n", "self", ",", "\n", "prediction", ",", "\n", "metrics", ":", "MetricCollection", ",", "\n", "ex_id", ":", "Union", "[", "str", ",", "Sequence", "[", "str", "]", "]", ",", "\n", "is_batch", "=", "False", ",", "\n", ")", ":", "\n", "        ", "output", ",", "target", "=", "prediction", "[", "\"pred\"", "]", ",", "prediction", "[", "\"target\"", "]", "\n", "if", "not", "is_batch", ":", "\n", "            ", "output", ",", "target", "=", "output", ".", "unsqueeze", "(", "0", ")", ",", "target", ".", "unsqueeze", "(", "0", ")", "\n", "ex_id", "=", "[", "ex_id", "]", "\n", "", "output", ",", "target", "=", "cplx", ".", "channel_first", "(", "output", ")", ",", "cplx", ".", "channel_first", "(", "target", ")", "\n", "metrics", "(", "preds", "=", "output", ",", "targets", "=", "target", ",", "ids", "=", "ex_id", ")", "\n", "return", "metrics", ".", "to_dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator._append_memory": [[406, 413], ["recon_evaluation.ReconEvaluator._memory[].append", "torch.cuda.is_available", "recon_evaluation.ReconEvaluator._logger.info", "len", "torch.cuda.max_memory_allocated"], "methods", ["None"], ["", "def", "_append_memory", "(", "self", ",", "key", ")", ":", "\n", "        ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "return", "\n", "", "self", ".", "_memory", "[", "key", "]", ".", "append", "(", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "/", "1024.0", "/", "1024.0", ")", "\n", "mem", "=", "self", ".", "_memory", "[", "key", "]", "\n", "if", "len", "(", "mem", ")", ">", "1", "and", "(", "mem", "[", "-", "1", "]", "-", "mem", "[", "-", "2", "]", ">", "500", ")", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "f\"Memory exceeded '{key}'- previous 5 logs: {mem[-5:]}\"", ")", "\n", "# self._logger.info(torch.cuda.memory_stats())", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.print_csv_format": [[16, 33], ["isinstance", "logging.getLogger", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "results.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["def", "print_csv_format", "(", "results", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Number", "]", "]", ")", ":", "# pragma: no cover", "\n", "    ", "\"\"\"Print metrics for easy copypaste.\n\n    Args:\n        results (OrderedDict[dict]): task_name -> {metric -> score}\n    \"\"\"", "\n", "assert", "isinstance", "(", "results", ",", "Dict", ")", ",", "results", "# unordered results cannot be properly printed", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "important_res", "=", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "results", ".", "items", "(", ")", "if", "\"-\"", "not", "in", "k", "]", "\n", "logger", ".", "info", "(", "\"copypaste: \"", "+", "\",\"", ".", "join", "(", "[", "k", "[", "0", "]", "for", "k", "in", "important_res", "]", ")", ")", "\n", "logger", ".", "info", "(", "\"copypaste: \"", "+", "\",\"", ".", "join", "(", "[", "\"{0:.4f}\"", ".", "format", "(", "k", "[", "1", "]", ")", "for", "k", "in", "important_res", "]", ")", ")", "\n", "\n", "# Additional formatting", "\n", "logger", ".", "info", "(", "\n", "\"Metrics (comma delimited): \\n{}\\n{}\"", ".", "format", "(", "\n", "\",\"", ".", "join", "(", "[", "k", "[", "0", "]", "for", "k", "in", "important_res", "]", ")", ",", "\n", "\",\"", ".", "join", "(", "[", "\"{0:.4f}\"", ".", "format", "(", "k", "[", "1", "]", ")", "for", "k", "in", "important_res", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.verify_results": [[37, 72], ["testing.flatten_results_dict", "logging.getLogger", "len", "abs", "logging.getLogger.error", "logging.getLogger.error", "logging.getLogger.error", "logging.getLogger.info", "numpy.isfinite", "str", "pprint.pformat"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.flatten_results_dict", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "verify_results", "(", "cfg", ":", "CfgNode", ",", "results", ":", "Dict", "[", "str", ",", "Any", "]", ")", "->", "bool", ":", "# pragma: no cover", "\n", "    ", "\"\"\"Verify that the results are consistent with what is expected in the config.\n\n    Adapted from detectron2:\n    https://github.com/facebookresearch/detectron2/blob/main/detectron2/evaluation/testing.py\n\n    Args:\n        results: A mapping from metrics -> scores.\n\n    Returns:\n        bool: Whether the verification succeeds or not\n    \"\"\"", "\n", "expected_results", "=", "cfg", ".", "TEST", ".", "EXPECTED_RESULTS", "\n", "if", "not", "len", "(", "expected_results", ")", ":", "\n", "        ", "return", "True", "\n", "\n", "", "results", "=", "flatten_results_dict", "(", "results", ")", "\n", "\n", "ok", "=", "True", "\n", "for", "metric", ",", "expected", ",", "tolerance", "in", "expected_results", ":", "\n", "        ", "actual", "=", "results", "[", "metric", "]", "\n", "if", "not", "np", ".", "isfinite", "(", "actual", ")", ":", "\n", "            ", "ok", "=", "False", "\n", "", "diff", "=", "abs", "(", "actual", "-", "expected", ")", "\n", "if", "diff", ">", "tolerance", ":", "\n", "            ", "ok", "=", "False", "\n", "\n", "", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "if", "not", "ok", ":", "\n", "        ", "logger", ".", "error", "(", "\"Result verification failed!\"", ")", "\n", "logger", ".", "error", "(", "\"Expected Results: \"", "+", "str", "(", "expected_results", ")", ")", "\n", "logger", ".", "error", "(", "\"Actual Results: \"", "+", "pprint", ".", "pformat", "(", "results", ")", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\"Results verification passed.\"", ")", "\n", "", "return", "ok", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.flatten_results_dict": [[74, 92], ["results.items", "isinstance", "testing.flatten_results_dict", "flatten_results_dict.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.flatten_results_dict", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "flatten_results_dict", "(", "results", ":", "Dict", "[", "str", ",", "Any", "]", ",", "delimiter", ":", "str", "=", "\"/\"", ")", "->", "Dict", "[", "str", ",", "Number", "]", ":", "\n", "    ", "\"\"\"\n    Expand a hierarchical dict of scalars into a flat dict of scalars.\n    If results[k1][k2][k3] = v, the returned dict will have the entry\n    {\"k1/k2/k3\": v}.\n\n    Args:\n        results (dict):\n    \"\"\"", "\n", "r", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "results", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "Mapping", ")", ":", "\n", "            ", "v", "=", "flatten_results_dict", "(", "v", ")", "\n", "for", "kk", ",", "vv", "in", "v", ".", "items", "(", ")", ":", "\n", "                ", "r", "[", "k", "+", "delimiter", "+", "kk", "]", "=", "vv", "\n", "", "", "else", ":", "\n", "            ", "r", "[", "k", "]", "=", "v", "\n", "", "", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.find_weights": [[107, 243], ["logging.getLogger", "logging.getLogger.info", "os.path.join", "numpy.diff", "any", "os.listdir", "ValueError", "int", "ValueError", "testing._metrics_from_x", "sorted", "file_name_fmt.format", "os.path.join", "all_filepaths.append", "all_values.append", "logging.getLogger.info", "len", "ValueError", "len", "ValueError", "ValueError", "numpy.argmax", "len", "ValueError", "len", "len", "ValueError", "os.path.isfile", "ValueError", "abs", "testing.get_iters_per_epoch_eval", "abs", "abs", "_METRICS_TO_OPERATION.items", "re.match", "name.lower", "criterion.lower", "re.match"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing._metrics_from_x", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.get_iters_per_epoch_eval", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["def", "find_weights", "(", "\n", "cfg", ":", "CfgNode", ",", "\n", "criterion", ":", "str", ",", "\n", "operation", ":", "str", "=", "\"auto\"", ",", "\n", "iter_limit", ":", "int", "=", "None", ",", "\n", "file_name_fmt", ":", "str", "=", "\"model_{:07d}.pth\"", ",", "\n", "top_k", ":", "int", "=", "1", ",", "\n", ")", "->", "Tuple", "[", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ",", "str", ",", "Union", "[", "float", ",", "List", "[", "float", "]", "]", "]", ":", "\n", "    ", "\"\"\"Find the best weights based on a metric criterion.\n\n    Args:\n        cfg: The config.\n        criterion (str): The criterion that we use to select weights.\n        operation (str, optional): The operation for the best value of the criterion.\n            One of `'auto'`, `'min'`, `'max'`.\n        iter_limit (int, optional): If specified, all weights will be before\n            this iteration. If this value is negative, it is\n            interpreted as the epoch limit.\n        file_name_fmt (int, optional): The naming format for checkpoint files.\n        top_k (int, optional): The number of top checkpoints to return.\n\n    Returns:\n        Tuple: ``k`` filepath(s), selection criterion, and ``k`` criterion value(s).\n            If ``k=1``, filepath is a string and value is a float.\n\n    Examples:\n        >>> checkpoint_file, criterion, value = find_weights(cfg, \"val_loss\", \"min\")\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "if", "operation", "not", "in", "[", "\"min\"", ",", "\"max\"", ",", "\"auto\"", "]", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Invalid operation: {operation}. Expected one of 'min', 'max', 'auto'.\"", ")", "\n", "\n", "# Negative iter_limit is interpreted as epoch limit.", "\n", "", "if", "iter_limit", "is", "not", "None", "and", "iter_limit", "<", "0", ":", "\n", "        ", "iter_limit", "=", "int", "(", "abs", "(", "iter_limit", ")", "*", "get_iters_per_epoch_eval", "(", "cfg", ")", ")", "\n", "\n", "", "ckpt_period", "=", "cfg", ".", "SOLVER", ".", "CHECKPOINT_PERIOD", "\n", "eval_period", "=", "cfg", ".", "TEST", ".", "EVAL_PERIOD", "\n", "if", "(", "\n", "ckpt_period", "*", "eval_period", "<=", "0", "# same sign (i.e. same time scale)", "\n", "or", "abs", "(", "eval_period", ")", "%", "abs", "(", "ckpt_period", ")", "!=", "0", "# checkpoint period is multiple of eval period", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "# pragma: no cover", "\n", "\"Cannot find weights if checkpoint/eval periods \"", "\n", "\"at different time scales or eval period is not\"", "\n", "\"a multiple of checkpoint period.\"", "\n", ")", "\n", "\n", "", "if", "operation", "==", "\"auto\"", ":", "\n", "        ", "operation", "=", "[", "\n", "op", "for", "name", ",", "op", "in", "_METRICS_TO_OPERATION", ".", "items", "(", ")", "if", "name", ".", "lower", "(", ")", "in", "criterion", ".", "lower", "(", ")", "\n", "]", "\n", "if", "len", "(", "operation", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Could not find operation for criterion '{criterion}'.\"", ")", "\n", "", "if", "len", "(", "operation", ")", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Found multiple operations for criterion '{criterion}': {operation}\"", ")", "\n", "", "operation", "=", "operation", "[", "0", "]", "\n", "", "assert", "operation", "in", "[", "\"min\"", ",", "\"max\"", "]", "\n", "\n", "logger", ".", "info", "(", "\"Finding best weights in {} using {}...\"", ".", "format", "(", "cfg", ".", "OUTPUT_DIR", ",", "criterion", ")", ")", "\n", "\n", "# Filter metrics to find reporting of real validation metrics.", "\n", "# If metric is wrapped (e.g. \"mridata_knee_2019_val/val_l1\"), that means", "\n", "# multiple datasets were validated on.", "\n", "# We filter out metrics from datasets that contain the word \"test\".", "\n", "# The criterion from all other datasets are averaged and used as the", "\n", "# target criterion.", "\n", "metrics_file", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"metrics\"", ")", "\n", "try", ":", "\n", "        ", "metrics", "=", "_metrics_from_x", "(", "metrics_file", ",", "criterion", ")", "\n", "", "except", "IndexError", ":", "\n", "        ", "raise", "ValueError", "(", "f\"No metrics found matching criterion '{criterion}'.\"", ")", "\n", "\n", "# Filter out all metrics calculated above iter limit.", "\n", "", "if", "iter_limit", ":", "\n", "        ", "metrics", "=", "[", "x", "for", "x", "in", "metrics", "if", "x", "[", "0", "]", "<", "iter_limit", "]", "\n", "\n", "", "last_iter", "=", "metrics", "[", "-", "1", "]", "[", "0", "]", "\n", "\n", "# Retraining does not overwrite the metrics file.", "\n", "# We make sure that the metrics correspond only to the most", "\n", "# recent run.", "\n", "metrics_recent_order", "=", "metrics", "[", ":", ":", "-", "1", "]", "\n", "iterations", "=", "[", "m", "[", "0", "]", "for", "m", "in", "metrics_recent_order", "]", "\n", "intervals", "=", "np", ".", "diff", "(", "iterations", ")", "\n", "if", "any", "(", "intervals", ">", "0", ")", ":", "\n", "        ", "stop_idx", "=", "np", ".", "argmax", "(", "intervals", ">", "0", ")", "+", "1", "\n", "metrics_recent_order", "=", "metrics_recent_order", "[", ":", "stop_idx", "]", "\n", "metrics", "=", "metrics_recent_order", "[", ":", ":", "-", "1", "]", "\n", "\n", "# Note that resuming can sometimes report metrics for the same", "\n", "# iteration. We handle this by taking the most recent metric for the", "\n", "# iteration __after__ filtering out old training runs.", "\n", "# metrics = {iteration: value for iteration, value in metrics}", "\n", "", "metrics", "=", "[", "(", "iteration", ",", "value", ")", "for", "iteration", ",", "value", "in", "metrics", "]", "\n", "\n", "best_iter_and_values", "=", "sorted", "(", "metrics", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "operation", "==", "\"max\"", ")", "[", ":", "top_k", "]", "\n", "\n", "all_filepaths", "=", "[", "]", "\n", "all_values", "=", "[", "]", "\n", "potential_ckpt_files", "=", "os", ".", "listdir", "(", "cfg", ".", "OUTPUT_DIR", ")", "\n", "for", "best_iter", ",", "best_value", "in", "best_iter_and_values", ":", "\n", "        ", "file_name", "=", "file_name_fmt", ".", "format", "(", "best_iter", ")", "\n", "\n", "matched_files", "=", "[", "x", "for", "x", "in", "potential_ckpt_files", "if", "re", ".", "match", "(", "file_name", ",", "x", ")", "]", "\n", "if", "len", "(", "matched_files", ")", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Too many potential checkpoint files found for iter={best_iter}, \"", "\n", "f\"criterion={criterion}, value={best_value}:\\n\\t{matched_files}\"", "\n", ")", "\n", "", "if", "len", "(", "matched_files", ")", "==", "0", ":", "\n", "            ", "if", "best_iter", "==", "last_iter", ":", "\n", "                ", "file_name", "=", "\"model_final.pth\"", "\n", "", "matched_files", "=", "[", "file_name", "for", "x", "in", "potential_ckpt_files", "if", "re", ".", "match", "(", "file_name", ",", "x", ")", "]", "\n", "", "if", "len", "(", "matched_files", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Could not find potential checkpoint files for iter={best_iter}, \"", "\n", "f\"criterion={criterion}, value={best_value}.\"", "\n", ")", "\n", "", "file_name", "=", "matched_files", "[", "0", "]", "\n", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "file_name", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_path", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Model for iteration {} does not exist\"", ".", "format", "(", "best_iter", ")", ")", "\n", "\n", "", "all_filepaths", ".", "append", "(", "file_path", ")", "\n", "all_values", ".", "append", "(", "best_value", ")", "\n", "\n", "logger", ".", "info", "(", "\"Weights: {} - {}: {:0.4f}\"", ".", "format", "(", "file_name", ",", "criterion", ",", "best_value", ")", ")", "\n", "\n", "", "if", "top_k", "==", "1", ":", "\n", "        ", "return", "all_filepaths", "[", "0", "]", ",", "criterion", ",", "all_values", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "return", "all_filepaths", ",", "criterion", ",", "all_values", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.check_consistency": [[245, 260], ["model.state_dict", "torch.equal"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.state_dict"], ["", "", "def", "check_consistency", "(", "state_dict", ":", "Dict", "[", "str", ",", "Any", "]", ",", "model", ":", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"Verifies that the proper weights were loaded into the model.\n\n    Related to issue that loading weights from checkpoints of a cuda model\n    does not properly load when model is on cpu. It may also result in\n    warnings for contiguous tensors, but this is not always the case.\n    https://github.com/pytorch/pytorch/issues/42300\n\n    Args:\n        state_dict (Dict): A model state dict.\n        model (nn.Module): A Pytorch model.\n    \"\"\"", "\n", "_state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "for", "k", "in", "state_dict", ":", "\n", "        ", "assert", "torch", ".", "equal", "(", "state_dict", "[", "k", "]", ",", "_state_dict", "[", "k", "]", ")", ",", "f\"Mismatch values: {k}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing._metrics_from_x": [[262, 270], ["os.path.isfile", "os.path.splitext", "testing._metrics_from_json", "os.path.isfile", "testing._metrics_from_csv", "ValueError"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing._metrics_from_json", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing._metrics_from_csv"], ["", "", "def", "_metrics_from_x", "(", "metrics_file", ",", "criterion", ")", ":", "\n", "    ", "metrics_file", "=", "os", ".", "path", ".", "splitext", "(", "metrics_file", ")", "[", "0", "]", "\n", "if", "os", ".", "path", ".", "isfile", "(", "f\"{metrics_file}.json\"", ")", ":", "\n", "        ", "return", "_metrics_from_json", "(", "f\"{metrics_file}.json\"", ",", "criterion", ")", "\n", "", "elif", "os", ".", "path", ".", "isfile", "(", "f\"{metrics_file}.csv\"", ")", ":", "\n", "        ", "return", "_metrics_from_csv", "(", "f\"{metrics_file}.csv\"", ",", "criterion", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"metrics file not found - {metrics_file}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing._metrics_from_json": [[272, 291], ["open", "json.loads", "line.strip", "any", "int", "numpy.mean().item", "k.endswith", "numpy.mean", "m.keys", "k.endswith", "k.split"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["", "", "def", "_metrics_from_json", "(", "metrics_file", ",", "criterion", ")", ":", "\n", "    ", "metrics", "=", "[", "]", "\n", "with", "open", "(", "metrics_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "metrics", "=", "[", "json", ".", "loads", "(", "line", ".", "strip", "(", ")", ")", "for", "line", "in", "f", "]", "\n", "", "metrics", "=", "[", "m", "for", "m", "in", "metrics", "if", "criterion", "in", "m", "or", "any", "(", "k", ".", "endswith", "(", "criterion", ")", "for", "k", "in", "m", ".", "keys", "(", ")", ")", "]", "\n", "is_metric_wrapped", "=", "criterion", "not", "in", "metrics", "[", "0", "]", "\n", "if", "is_metric_wrapped", ":", "\n", "        ", "metrics", "=", "[", "\n", "(", "\n", "int", "(", "m", "[", "\"iteration\"", "]", ")", ",", "\n", "np", ".", "mean", "(", "\n", "[", "m", "[", "k", "]", "for", "k", "in", "m", "if", "k", ".", "endswith", "(", "criterion", ")", "and", "\"test\"", "not", "in", "k", ".", "split", "(", "\"/\"", ")", "[", "0", "]", "]", "\n", ")", ".", "item", "(", ")", ",", "\n", ")", "\n", "for", "m", "in", "metrics", "\n", "]", "\n", "", "else", ":", "\n", "        ", "metrics", "=", "[", "(", "m", "[", "\"iteration\"", "]", ",", "m", "[", "criterion", "]", ")", "for", "m", "in", "metrics", "]", "\n", "", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing._metrics_from_csv": [[293, 302], ["pandas.read_csv", "row.index.tolist", "pd.read_csv.iterrows", "testing._metrics_from_csv._row_has_criterion"], "function", ["None"], ["", "def", "_metrics_from_csv", "(", "metrics_file", ",", "criterion", ")", ":", "\n", "    ", "def", "_row_has_criterion", "(", "row", ":", "pd", ".", "Series", ")", ":", "\n", "        ", "index", "=", "row", ".", "index", ".", "tolist", "(", ")", "\n", "return", "criterion", "in", "index", "and", "not", "pd", ".", "isna", "(", "row", "[", "criterion", "]", ")", "\n", "\n", "", "metrics", "=", "pd", ".", "read_csv", "(", "metrics_file", ")", "\n", "metrics", "=", "[", "m", "for", "_", ",", "m", "in", "metrics", ".", "iterrows", "(", ")", "if", "_row_has_criterion", "(", "m", ")", "]", "\n", "metrics", "=", "[", "(", "int", "(", "m", "[", "\"step\"", "]", ")", ",", "m", "[", "criterion", "]", ")", "for", "m", "in", "metrics", "]", "\n", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.get_iters_per_epoch_eval": [[304, 340], ["abs", "numpy.diff", "int", "ValueError", "open", "len", "ValueError", "ValueError", "int", "os.path.join", "json.loads", "len", "numpy.all", "line.strip", "f.readlines"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["", "def", "get_iters_per_epoch_eval", "(", "cfg", ")", "->", "int", ":", "\n", "    ", "\"\"\"Get number of iterations per epoch for evaluation purposes.\n\n    This function expects a metrics named ``{cfg.OUTPUT_DIR}/metrics.json``\n    that is written during training.\n\n    Args:\n        cfg: The config.\n\n    Return:\n        int: Number of iterations per epoch.\n    \"\"\"", "\n", "exp_path", "=", "cfg", ".", "OUTPUT_DIR", "\n", "\n", "eval_period", "=", "cfg", ".", "TEST", ".", "EVAL_PERIOD", "\n", "time_scale", "=", "cfg", ".", "TIME_SCALE", "\n", "assert", "time_scale", "in", "[", "\"epoch\"", ",", "\"iter\"", "]", "\n", "if", "(", "time_scale", "==", "\"epoch\"", "and", "eval_period", "<", "0", ")", "or", "(", "time_scale", "==", "\"iter\"", "and", "eval_period", ">", "0", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Evaluation period is not in # epochs\"", ")", "\n", "", "eval_period", "=", "abs", "(", "eval_period", ")", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "exp_path", ",", "\"metrics.json\"", ")", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "metrics", "=", "[", "json", ".", "loads", "(", "line", ".", "strip", "(", ")", ")", "for", "line", "in", "f", ".", "readlines", "(", ")", "]", "\n", "# Filter to only have evaluation metrics.", "\n", "", "metrics", "=", "[", "m", "for", "m", "in", "metrics", "if", "\"eval_time\"", "in", "m", "]", "\n", "# last eval could be at end of training which doesnt have same", "\n", "# spacing of iters_per_epoch - skip it", "\n", "iterations", "=", "np", ".", "diff", "(", "[", "m", "[", "\"iteration\"", "]", "for", "m", "in", "metrics", "]", "[", ":", "-", "1", "]", ")", "\n", "if", "len", "(", "iterations", ")", "==", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"Could not determine iters_per_epoch - too few evaluations\"", ")", "\n", "", "if", "len", "(", "iterations", ")", ">=", "2", "and", "not", "np", ".", "all", "(", "iterations", "[", ":", "-", "1", "]", "==", "iterations", "[", "0", "]", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Not all iteration spacings are equal - {iterations}\"", ")", "\n", "\n", "", "iters_per_epoch", "=", "iterations", "[", "0", "]", "/", "eval_period", "\n", "assert", "iters_per_epoch", "==", "int", "(", "iters_per_epoch", ")", "\n", "return", "int", "(", "iters_per_epoch", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluator.reset": [[26, 32], ["None"], "methods", ["None"], ["def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Preparation for a new round of evaluation.\n        Should be called before starting a round of evaluation.\n        \"\"\"", "\n", "pass", "# pragma: no cover", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluator.process": [[33, 42], ["None"], "methods", ["None"], ["", "def", "process", "(", "self", ",", "input", ",", "output", ")", ":", "\n", "        ", "\"\"\"\n        Process an input/output pair.\n\n        Args:\n            input: the input that's used to call the model.\n            output: the return value of `model(input)`\n        \"\"\"", "\n", "pass", "# pragma: no cover", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluator.evaluate": [[43, 58], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate/summarize the performance, after processing all input/output\n        pairs.\n\n        Returns:\n            dict:\n                A new evaluator class can return a dict of arbitrary format\n                as long as the user can process the results.\n                In our train_net.py, we expect the following format:\n\n                * key: the name of the task (e.g., bbox)\n                * value: a dict of {metric name: score}, e.g.: {\"AP50\": 80}\n        \"\"\"", "\n", "pass", "# pragma: no cover", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.__init__": [[61, 70], ["len", "super().__init__", "isinstance", "evaluators.items"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["    ", "def", "__init__", "(", "self", ",", "evaluators", ",", "as_list", "=", "False", ")", ":", "\n", "        ", "assert", "len", "(", "evaluators", ")", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "evaluators", ",", "Mapping", ")", ":", "\n", "            ", "evaluators", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "evaluators", ".", "items", "(", ")", "if", "v", "is", "not", "None", "}", "\n", "", "else", ":", "\n", "            ", "evaluators", "=", "[", "x", "for", "x", "in", "evaluators", "if", "x", "is", "not", "None", "]", "\n", "", "self", ".", "_evaluators", "=", "evaluators", "\n", "self", ".", "as_list", "=", "as_list", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items": [[71, 75], ["isinstance", "list", "evaluator.DatasetEvaluators._evaluators.items", "enumerate"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "items", "(", "self", ")", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "_evaluators", ",", "Mapping", ")", ":", "\n", "            ", "return", "self", ".", "_evaluators", ".", "items", "(", ")", "\n", "", "return", "list", "(", "enumerate", "(", "self", ".", "_evaluators", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values": [[76, 81], ["isinstance", "evaluator.DatasetEvaluators._evaluators.values"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "values", "(", "self", ")", "->", "Sequence", "[", "DatasetEvaluator", "]", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "_evaluators", ",", "Mapping", ")", ":", "\n", "            ", "return", "self", ".", "_evaluators", ".", "values", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_evaluators", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.reset": [[82, 85], ["evaluator.DatasetEvaluators.values", "evaluator.reset"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "values", "(", ")", ":", "\n", "            ", "evaluator", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.process": [[86, 89], ["evaluator.DatasetEvaluators.values", "evaluator.process"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process"], ["", "", "def", "process", "(", "self", ",", "input", ",", "output", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "values", "(", ")", ":", "\n", "            ", "evaluator", ".", "process", "(", "input", ",", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.evaluate": [[90, 106], ["evaluator.DatasetEvaluators.values", "collections.OrderedDict", "evaluator.evaluate", "evaluator.evaluate.items", "results.append"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "results", "=", "[", "]", "if", "self", ".", "as_list", "else", "OrderedDict", "(", ")", "\n", "for", "evaluator", "in", "self", ".", "values", "(", ")", ":", "\n", "            ", "result", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "if", "self", ".", "as_list", ":", "\n", "                ", "if", "result", "is", "not", "None", ":", "\n", "                    ", "results", ".", "append", "(", "result", ")", "\n", "", "continue", "\n", "\n", "", "if", "result", "is", "not", "None", ":", "\n", "                ", "for", "k", ",", "v", "in", "result", ".", "items", "(", ")", ":", "\n", "                    ", "assert", "(", "\n", "k", "not", "in", "results", "\n", ")", ",", "\"Different evaluators produce results \"", "\"with the same key {}\"", ".", "format", "(", "k", ")", "\n", "results", "[", "k", "]", "=", "v", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.__getitem__": [[107, 116], ["isinstance", "isinstance", "isinstance", "ValueError", "list", "evaluator.DatasetEvaluators.values"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "if", "isinstance", "(", "index", ",", "str", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "self", ".", "_evaluators", ",", "Mapping", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"Cannot index sequence of evaluators with string key.\"", ")", "\n", "", "return", "self", ".", "_evaluators", "[", "index", "]", "\n", "", "if", "isinstance", "(", "self", ".", "_evaluators", ",", "Mapping", ")", ":", "\n", "            ", "return", "list", "(", "self", ".", "values", "(", ")", ")", "[", "index", "]", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_evaluators", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.__len__": [[117, 119], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_evaluators", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.__contains__": [[120, 122], ["evaluator.DatasetEvaluators.values"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values"], ["", "def", "__contains__", "(", "self", ",", "obj", ")", ":", "\n", "        ", "return", "obj", "in", "self", ".", "values", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.inference_on_dataset": [[124, 214], ["logging.getLogger", "len", "logging.getLogger.info", "evaluator.reset", "min", "time.perf_counter", "str", "logging.getLogger.info", "str", "logging.getLogger.info", "time.perf_counter", "evaluator.evaluate", "logging.getLogger.info", "evaluator.inference_context", "torch.no_grad", "enumerate", "time.perf_counter", "datetime.timedelta", "datetime.timedelta", "time.perf_counter", "time.perf_counter", "model", "evaluator.process", "time.perf_counter", "time.perf_counter", "datetime.timedelta", "meddlr.utils.logger.log_every_n_seconds", "int", "int", "time.perf_counter", "int", "str"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.inference_context", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.log_every_n_seconds"], ["", "", "def", "inference_on_dataset", "(", "model", ",", "data_loader", ",", "evaluator", ")", ":", "\n", "    ", "\"\"\"\n    Run model on the data_loader and evaluate the metrics with evaluator.\n    The model will be used in eval mode.\n\n    Args:\n        model (nn.Module): a module which accepts an object from\n            `data_loader` and returns some outputs. It will be temporarily set\n            to `eval` mode.\n\n            If you wish to evaluate a model in `training` mode instead, you can\n            wrap the given model and override its behavior of `.eval()` and\n            `.train()`.\n        data_loader: an iterable object with a length.\n            The elements it generates will be the inputs to the model.\n        evaluator (DatasetEvaluator): the evaluator to run. Use\n            :class:`DatasetEvaluators([])` if you only want to benchmark, but\n            don't want to do any evaluation.\n\n    Returns:\n        The return value of `evaluator.evaluate()`\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "total", "=", "len", "(", "data_loader", ")", "# inference data loader must have a fixed length", "\n", "logger", ".", "info", "(", "f\"Start inference on {total} batches\"", ")", "\n", "evaluator", ".", "reset", "(", ")", "\n", "\n", "num_warmup", "=", "min", "(", "5", ",", "total", "-", "1", ")", "\n", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "with", "inference_context", "(", "model", ")", ",", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "idx", ",", "inputs", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "            ", "if", "idx", "==", "num_warmup", ":", "\n", "                ", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "\n", "", "start_compute_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "total_compute_time", "+=", "time", ".", "perf_counter", "(", ")", "-", "start_compute_time", "\n", "\n", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "iters_after_start", "=", "idx", "+", "1", "-", "num_warmup", "*", "int", "(", "idx", ">=", "num_warmup", ")", "\n", "seconds_per_img", "=", "total_compute_time", "/", "iters_after_start", "\n", "if", "idx", ">=", "num_warmup", "*", "2", "or", "seconds_per_img", ">", "5", ":", "\n", "                ", "total_seconds_per_img", "=", "(", "\n", "time", ".", "perf_counter", "(", ")", "-", "start_time", "\n", ")", "/", "iters_after_start", "# noqa", "\n", "eta", "=", "datetime", ".", "timedelta", "(", "\n", "seconds", "=", "int", "(", "total_seconds_per_img", "*", "(", "total", "-", "idx", "-", "1", ")", ")", "\n", ")", "# noqa", "\n", "log_every_n_seconds", "(", "\n", "logging", ".", "INFO", ",", "\n", "\"Inference done {}/{}. {:.4f} s / img. ETA={}\"", ".", "format", "(", "\n", "idx", "+", "1", ",", "total", ",", "seconds_per_img", ",", "str", "(", "eta", ")", "\n", ")", ",", "\n", "n", "=", "5", ",", "\n", ")", "\n", "\n", "# Measure the time only for this worker (before the synchronization barrier)", "\n", "", "", "", "total_time", "=", "time", ".", "perf_counter", "(", ")", "-", "start_time", "\n", "total_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "total_time", ")", ")", "\n", "# NOTE this format is parsed by grep", "\n", "logger", ".", "info", "(", "\n", "\"Total inference time: \"", "\n", "\"{} ({:.6f} s / batch)\"", ".", "format", "(", "\n", "total_time_str", ",", "\n", "total_time", "/", "(", "total", "-", "num_warmup", ")", ",", "\n", ")", "\n", ")", "\n", "total_compute_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_compute_time", ")", ")", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total inference pure compute time: \"", "\n", "\"{} ({:.6f} s / batch)\"", ".", "format", "(", "\n", "total_compute_time_str", ",", "\n", "total_compute_time", "/", "(", "total", "-", "num_warmup", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "eval_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "evaluation_time", "=", "time", ".", "perf_counter", "(", ")", "-", "eval_start_time", "\n", "logger", ".", "info", "(", "f\"Evaluation Time: {evaluation_time:.6f} s\"", ")", "\n", "# An evaluator may return None when not in main process.", "\n", "# Replace it by an empty dict instead to make it easier", "\n", "# for downstream code to handle", "\n", "if", "results", "is", "None", ":", "\n", "        ", "results", "=", "{", "}", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.inference_context": [[216, 229], ["model.eval", "model.train"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.train"], ["", "@", "contextmanager", "\n", "def", "inference_context", "(", "model", ")", ":", "\n", "    ", "\"\"\"\n    A context where the model is temporarily changed to eval mode,\n    and restored to previous mode afterwards.\n\n    Args:\n        model: a torch Module\n    \"\"\"", "\n", "training_mode", "=", "model", ".", "training", "\n", "model", ".", "eval", "(", ")", "\n", "yield", "\n", "model", ".", "train", "(", "training_mode", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_testing.test_flatten_results_dict": [[16, 24], ["meddlr.evaluation.testing.flatten_results_dict", "meddlr.evaluation.testing.flatten_results_dict.keys", "expected.keys"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.flatten_results_dict"], ["def", "test_flatten_results_dict", "(", ")", ":", "\n", "    ", "x", "=", "{", "\"a\"", ":", "1", ",", "\"b\"", ":", "{", "\"b1\"", ":", "5", ",", "\"b2\"", ":", "{", "\"b2-1\"", ":", "2", "}", "}", ",", "\"c\"", ":", "{", "\"c1\"", ":", "8", ",", "\"c2\"", ":", "10", "}", "}", "\n", "expected", "=", "{", "\"a\"", ":", "1", ",", "\"b/b1\"", ":", "5", ",", "\"b/b2/b2-1\"", ":", "2", ",", "\"c/c1\"", ":", "8", ",", "\"c/c2\"", ":", "10", "}", "\n", "out", "=", "flatten_results_dict", "(", "x", ")", "\n", "\n", "assert", "out", ".", "keys", "(", ")", "==", "expected", ".", "keys", "(", ")", "\n", "for", "k", "in", "expected", ":", "\n", "        ", "assert", "out", "[", "k", "]", "==", "expected", "[", "k", "]", ",", "f\"{k}: {out[k]} != {expected[k]}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_testing.test_check_consistency": [[26, 43], ["torch.nn.Sequential", "nn.Sequential.state_dict", "meddlr.evaluation.testing.check_consistency", "copy.deepcopy", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "pytest.raises", "meddlr.evaluation.testing.check_consistency"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.state_dict", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.check_consistency", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.check_consistency"], ["", "", "def", "test_check_consistency", "(", ")", ":", "\n", "    ", "model", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "10", ",", "10", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "10", ",", "10", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "10", ",", "10", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "\n", "state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "check_consistency", "(", "state_dict", ",", "model", ")", "\n", "\n", "state_dict", "=", "deepcopy", "(", "state_dict", ")", "\n", "state_dict", "[", "\"0.weight\"", "]", "+=", "1", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "check_consistency", "(", "state_dict", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_testing.test_find_weights_basic": [[45, 82], ["pytest.mark.parametrize", "meddlr.utils.env.get_path_manager", "env.get_path_manager.get_local_path", "pathlib.Path", "meddlr.config.get_cfg", "meddlr.config.get_cfg.merge_from_file", "str", "os.path.isdir", "meddlr.evaluation.testing.find_weights", "tarfile.open", "tfile.extractall", "pytest.raises", "meddlr.evaluation.testing.find_weights", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.find_weights", "home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.find_weights"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"func_kwargs,expected_file\"", ",", "\n", "[", "\n", "(", "{", "\"criterion\"", ":", "\"psnr_scan\"", "}", ",", "\"model_0001399.pth\"", ")", ",", "\n", "(", "{", "\"criterion\"", ":", "\"ssim (Wang)_scan\"", "}", ",", "\"model_0000799.pth\"", ")", ",", "\n", "(", "{", "\"criterion\"", ":", "\"psnr_scan\"", ",", "\"iter_limit\"", ":", "800", "}", ",", "\"model_0000399.pth\"", ")", ",", "\n", "(", "{", "\"criterion\"", ":", "\"ssim_psnr\"", "}", ",", "None", ")", ",", "\n", "(", "{", "\"criterion\"", ":", "\"foobar\"", "}", ",", "None", ")", ",", "\n", "(", "{", "\"criterion\"", ":", "\"foobar\"", ",", "\"operation\"", ":", "\"max\"", "}", ",", "None", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_find_weights_basic", "(", "func_kwargs", ",", "expected_file", ")", ":", "\n", "    ", "\"\"\"Test that we can find the best weights from a basic experiment.\"\"\"", "\n", "exp_name", "=", "\"basic-cpu\"", "\n", "cache_file", "=", "util", ".", "TEMP_CACHE_DIR", "/", "f\"{exp_name}.tar.gz\"", "\n", "exp_dir", "=", "util", ".", "TEMP_CACHE_DIR", "/", "exp_name", "\n", "\n", "pm", "=", "env", ".", "get_path_manager", "(", ")", "\n", "tar_path", "=", "pm", ".", "get_local_path", "(", "\n", "f\"https://huggingface.co/datasets/arjundd/meddlr-data/resolve/main/test-data/test-exps/{exp_name}.tar.gz\"", ",", "# noqa: E501", "\n", "cache", "=", "cache_file", ",", "\n", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "exp_dir", ")", ":", "\n", "        ", "with", "tarfile", ".", "open", "(", "tar_path", ",", "\"r:gz\"", ")", "as", "tfile", ":", "\n", "            ", "tfile", ".", "extractall", "(", "util", ".", "TEMP_CACHE_DIR", ")", "\n", "", "", "exp_dir", "=", "Path", "(", "exp_dir", ")", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "exp_dir", "/", "\"config.yaml\"", ")", "\n", "cfg", ".", "OUTPUT_DIR", "=", "str", "(", "exp_dir", ")", "\n", "\n", "if", "expected_file", "is", "None", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "find_weights", "(", "cfg", ",", "**", "func_kwargs", ")", "\n", "", "", "else", ":", "\n", "        ", "weights", ",", "_", ",", "_", "=", "find_weights", "(", "cfg", ",", "**", "func_kwargs", ")", "\n", "assert", "os", ".", "path", ".", "basename", "(", "weights", ")", "==", "expected_file", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_sem_seg_evaluation.TestSemSegEvaluator.setup": [[51, 54], ["pytest.fixture"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "(", "autouse", "=", "True", ")", "\n", "def", "setup", "(", "self", ",", "tmpdir", ")", ":", "\n", "        ", "self", ".", "tmpdir", "=", "tmpdir", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_sem_seg_evaluation.TestSemSegEvaluator.test_basic": [[55, 81], ["meddlr.config.get_cfg", "meddlr.config.get_cfg.defrost", "meddlr.evaluation.seg_evaluation.SemSegEvaluator", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.reset", "zip", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.evaluate", "len", "all", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.evaluate.keys", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.process", "len", "test_sem_seg_evaluation._simulate_data", "itertools.product"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_sem_seg_evaluation._simulate_data"], ["", "def", "test_basic", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "CLASSES", "=", "(", "\"class_1\"", ",", "\"class_2\"", ",", "\"class_3\"", ",", "\"class_4\"", ")", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "ACTIVATION", "=", "\"sigmoid\"", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "INCLUDE_BACKGROUND", "=", "False", "\n", "\n", "evaluator", "=", "SemSegEvaluator", "(", "\"test\"", ",", "cfg", ",", "distributed", "=", "False", ",", "aggregate_scans", "=", "True", ")", "\n", "evaluator", ".", "reset", "(", ")", "\n", "\n", "shape", "=", "(", "20", ",", "4", ",", "75", ",", "75", ")", "# N x # classes x Y x X", "\n", "\n", "for", "inputs", ",", "outputs", "in", "zip", "(", "*", "_simulate_data", "(", "shape", ",", "num_scans", "=", "10", ")", ")", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "", "metrics", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "# 7 metrics (DSC, VOE, CV, DSC_scan, VOE_scan, CV_scan, ASSD_scan) * 4 classes = 28", "\n", "assert", "len", "(", "metrics", ")", "==", "28", ",", "len", "(", "metrics", ")", "\n", "expected_metric_names", "=", "[", "\n", "\"/\"", ".", "join", "(", "x", ")", "\n", "for", "x", "in", "itertools", ".", "product", "(", "\n", "[", "\"DSC\"", ",", "\"VOE\"", ",", "\"CV\"", ",", "\"DSC_scan\"", ",", "\"VOE_scan\"", ",", "\"CV_scan\"", ",", "\"ASSD_scan\"", "]", ",", "\n", "[", "\"class_1\"", ",", "\"class_2\"", ",", "\"class_3\"", ",", "\"class_4\"", "]", ",", "\n", ")", "\n", "]", "\n", "assert", "all", "(", "x", "in", "metrics", "for", "x", "in", "expected_metric_names", ")", ",", "metrics", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_sem_seg_evaluation.TestSemSegEvaluator.test_flush": [[82, 116], ["meddlr.config.get_cfg", "meddlr.config.get_cfg.defrost", "meddlr.evaluation.seg_evaluation.SemSegEvaluator", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.reset", "test_sem_seg_evaluation._simulate_data", "range", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.flush", "all", "range", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.evaluate", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.process", "len", "len", "len", "len", "len", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.process", "len", "len", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.scan_metrics.ids", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.slice_metrics.ids", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.scan_metrics.ids", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.slice_metrics.ids"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_sem_seg_evaluation._simulate_data", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.ids", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.ids", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.ids", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.collection.MetricCollection.ids"], ["", "def", "test_flush", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "CLASSES", "=", "(", "\"class_1\"", ",", "\"class_2\"", ",", "\"class_3\"", ",", "\"class_4\"", ")", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "ACTIVATION", "=", "\"sigmoid\"", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "INCLUDE_BACKGROUND", "=", "False", "\n", "\n", "# Test manual flushing.", "\n", "evaluator", "=", "SemSegEvaluator", "(", "\n", "\"test\"", ",", "cfg", ",", "distributed", "=", "False", ",", "aggregate_scans", "=", "True", ",", "flush_period", "=", "None", "\n", ")", "\n", "evaluator", ".", "reset", "(", ")", "\n", "\n", "shape", "=", "(", "20", ",", "4", ",", "75", ",", "75", ")", "# N x # classes x Y x X", "\n", "Z", "=", "shape", "[", "0", "]", "\n", "batch_size", "=", "10", "\n", "assert", "shape", "[", "0", "]", "%", "batch_size", "==", "0", "\n", "inputs", ",", "outputs", "=", "_simulate_data", "(", "shape", ",", "num_scans", "=", "2", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "num_steps", "=", "shape", "[", "0", "]", "//", "batch_size", "+", "1", "\n", "for", "i", "in", "range", "(", "num_steps", ")", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", "[", "i", "]", ",", "outputs", "[", "i", "]", ")", "\n", "", "evaluator", ".", "flush", "(", "skip_last_scan", "=", "True", ")", "\n", "assert", "len", "(", "evaluator", ".", "_predictions", ")", "==", "batch_size", "\n", "assert", "len", "(", "{", "x", "[", "\"metadata\"", "]", "[", "\"scan_id\"", "]", "for", "x", "in", "evaluator", ".", "_predictions", "}", ")", "==", "1", "\n", "assert", "all", "(", "x", "[", "\"metadata\"", "]", "[", "\"scan_id\"", "]", "==", "\"scan_1\"", "for", "x", "in", "evaluator", ".", "_predictions", ")", "\n", "assert", "len", "(", "evaluator", ".", "scan_metrics", ".", "ids", "(", ")", ")", "==", "1", "\n", "assert", "len", "(", "evaluator", ".", "slice_metrics", ".", "ids", "(", ")", ")", "==", "Z", "\n", "\n", "for", "i", "in", "range", "(", "num_steps", ",", "len", "(", "inputs", ")", ")", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", "[", "i", "]", ",", "outputs", "[", "i", "]", ")", "\n", "", "evaluator", ".", "evaluate", "(", ")", "\n", "assert", "len", "(", "evaluator", ".", "scan_metrics", ".", "ids", "(", ")", ")", "==", "2", "\n", "assert", "len", "(", "evaluator", ".", "slice_metrics", ".", "ids", "(", ")", ")", "==", "2", "*", "Z", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_sem_seg_evaluation.TestSemSegEvaluator.test_output_dir": [[117, 139], ["meddlr.config.get_cfg", "meddlr.config.get_cfg.defrost", "meddlr.evaluation.seg_evaluation.SemSegEvaluator", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.reset", "zip", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.evaluate", "os.path.exists", "os.path.exists", "os.path.exists", "meddlr.evaluation.seg_evaluation.SemSegEvaluator.process", "test_sem_seg_evaluation._simulate_data"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_sem_seg_evaluation._simulate_data"], ["", "def", "test_output_dir", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "CLASSES", "=", "(", "\"class_1\"", ",", "\"class_2\"", ",", "\"class_3\"", ",", "\"class_4\"", ")", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "ACTIVATION", "=", "\"sigmoid\"", "\n", "cfg", ".", "MODEL", ".", "SEG", ".", "INCLUDE_BACKGROUND", "=", "False", "\n", "\n", "evaluator", "=", "SemSegEvaluator", "(", "\n", "\"test\"", ",", "cfg", ",", "distributed", "=", "False", ",", "aggregate_scans", "=", "True", ",", "output_dir", "=", "self", ".", "tmpdir", "\n", ")", "\n", "evaluator", ".", "reset", "(", ")", "\n", "\n", "shape", "=", "(", "20", ",", "4", ",", "75", ",", "75", ")", "# N x # classes x Y x X", "\n", "\n", "for", "inputs", ",", "outputs", "in", "zip", "(", "*", "_simulate_data", "(", "shape", ",", "num_scans", "=", "10", ")", ")", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "", "_", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "self", ".", "tmpdir", "/", "\"results.txt\"", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "self", ".", "tmpdir", "/", "\"slice_metrics.csv\"", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "self", ".", "tmpdir", "/", "\"scan_metrics.csv\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_sem_seg_evaluation._simulate_data": [[12, 48], ["range", "torch.rand", "inputs.append", "outputs.append", "len", "len", "torch.split", "all_inputs.extend", "len", "len", "torch.rand", "len", "len", "torch.split", "range", "range", "len", "len", "zip", "zip", "len"], "function", ["None"], ["def", "_simulate_data", "(", "shape", ",", "num_scans", "=", "10", ",", "batch_size", ":", "int", "=", "None", ")", ":", "\n", "    ", "inputs", "=", "[", "]", "\n", "outputs", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "num_scans", ")", ":", "\n", "        ", "probs", "=", "torch", ".", "rand", "(", "*", "shape", ")", "\n", "target", "=", "torch", ".", "rand", "(", "*", "shape", ")", ">=", "0.5", "\n", "metadata", "=", "[", "{", "\"scan_id\"", ":", "f\"scan_{idx}\"", ",", "\"slice_id\"", ":", "i", "}", "for", "i", "in", "range", "(", "probs", ".", "shape", "[", "0", "]", ")", "]", "\n", "inputs", ".", "append", "(", "{", "\"labels\"", ":", "target", ",", "\"metadata\"", ":", "metadata", "}", ")", "\n", "outputs", ".", "append", "(", "{", "\"probs\"", ":", "probs", "}", ")", "\n", "\n", "", "assert", "len", "(", "inputs", ")", "==", "len", "(", "outputs", ")", "\n", "if", "not", "batch_size", ":", "\n", "        ", "return", "inputs", ",", "outputs", "\n", "\n", "", "assert", "batch_size", ">", "0", "\n", "all_inputs", "=", "[", "]", "\n", "for", "input", "in", "inputs", ":", "\n", "        ", "labels", "=", "torch", ".", "split", "(", "input", "[", "\"labels\"", "]", ",", "batch_size", ",", "dim", "=", "0", ")", "\n", "metadata", "=", "input", "[", "\"metadata\"", "]", "\n", "metadata", "=", "[", "\n", "metadata", "[", "idx", "*", "batch_size", ":", "(", "idx", "+", "1", ")", "*", "batch_size", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "metadata", ")", "//", "batch_size", ")", "\n", "]", "\n", "assert", "len", "(", "labels", ")", "==", "len", "(", "metadata", ")", "\n", "assert", "(", "len", "(", "x_label", ")", "==", "len", "(", "x_metadata", ")", "for", "x_label", ",", "x_metadata", "in", "zip", "(", "labels", ",", "metadata", ")", ")", "\n", "all_inputs", ".", "extend", "(", "\n", "[", "\n", "{", "\"labels\"", ":", "x_label", ",", "\"metadata\"", ":", "x_metadata", "}", "\n", "for", "x_label", ",", "x_metadata", "in", "zip", "(", "labels", ",", "metadata", ")", "\n", "]", "\n", ")", "\n", "", "outputs", "=", "[", "\n", "{", "\"probs\"", ":", "x", "}", "for", "out", "in", "outputs", "for", "x", "in", "torch", ".", "split", "(", "out", "[", "\"probs\"", "]", ",", "batch_size", ",", "dim", "=", "0", ")", "\n", "]", "\n", "assert", "len", "(", "all_inputs", ")", "==", "len", "(", "outputs", ")", "\n", "return", "all_inputs", ",", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.__init__": [[11, 19], ["str", "torch.sum", "uuid.uuid4", "torch.abs"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["    ", "def", "__init__", "(", "self", ",", "name", "=", "None", ",", "func", "=", "None", ")", ":", "\n", "        ", "if", "func", "is", "None", ":", "\n", "            ", "func", "=", "lambda", "input", ",", "output", ":", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "input", "-", "output", ")", ")", "# noqa: E731", "\n", "", "if", "name", "is", "None", ":", "\n", "            ", "name", "=", "str", "(", "uuid", ".", "uuid4", "(", ")", ")", "\n", "", "self", ".", "name", "=", "name", "\n", "self", ".", "func", "=", "func", "\n", "self", ".", "values", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset": [[20, 23], ["super().reset"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "values", "=", "[", "]", "\n", "return", "super", "(", ")", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.process": [[24, 26], ["test_evaluator.MockEvaluator.values.append", "test_evaluator.MockEvaluator.func"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func"], ["", "def", "process", "(", "self", ",", "input", ",", "output", ")", ":", "\n", "        ", "self", ".", "values", ".", "append", "(", "self", ".", "func", "(", "input", ",", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate": [[27, 29], ["torch.mean", "torch.as_tensor"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "return", "{", "self", ".", "name", ":", "torch", ".", "mean", "(", "torch", ".", "as_tensor", "(", "self", ".", "values", ")", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MultiplyModule.__init__": [[32, 35], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "self", ",", "factor", "=", "2", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "factor", "=", "factor", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MultiplyModule.forward": [[36, 38], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "factor", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.test_dataset_evaluators": [[40, 65], ["pytest.mark.parametrize", "meddlr.evaluation.evaluator.DatasetEvaluators.process", "meddlr.evaluation.evaluator.DatasetEvaluators.evaluate", "meddlr.evaluation.evaluator.DatasetEvaluators.reset", "test_evaluator.MockEvaluator", "test_evaluator.MockEvaluator", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "meddlr.evaluation.evaluator.DatasetEvaluators", "meddlr.evaluation.evaluator.DatasetEvaluators", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"ltype\"", ",", "[", "list", ",", "dict", "]", ")", "\n", "def", "test_dataset_evaluators", "(", "ltype", ")", ":", "\n", "    ", "a", ",", "b", "=", "MockEvaluator", "(", "\"a\"", ")", ",", "MockEvaluator", "(", "\"b\"", ")", "\n", "inputs", "=", "[", "torch", ".", "rand", "(", "10", ",", "10", ")", ",", "torch", ".", "rand", "(", "10", ",", "10", ")", "]", "\n", "outputs", "=", "[", "torch", ".", "rand", "(", "10", ",", "10", ")", ",", "torch", ".", "rand", "(", "10", ",", "10", ")", "]", "\n", "\n", "if", "ltype", "is", "list", ":", "\n", "        ", "evaluator", "=", "DatasetEvaluators", "(", "[", "a", ",", "b", "]", ")", "\n", "", "else", ":", "\n", "        ", "evaluator", "=", "DatasetEvaluators", "(", "{", "\"a\"", ":", "a", ",", "\"b\"", ":", "b", "}", ")", "\n", "\n", "", "assert", "len", "(", "evaluator", ")", "==", "2", "\n", "assert", "a", "in", "evaluator", "\n", "assert", "b", "in", "evaluator", "\n", "\n", "evaluator", ".", "process", "(", "inputs", "[", "0", "]", ",", "outputs", "[", "0", "]", ")", "\n", "assert", "a", ".", "values", "\n", "assert", "b", ".", "values", "\n", "\n", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "assert", "\"a\"", "in", "results", "and", "\"b\"", "in", "results", "\n", "\n", "evaluator", ".", "reset", "(", ")", "\n", "assert", "not", "a", ".", "values", "\n", "assert", "not", "b", ".", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.test_inference_on_dataset": [[67, 74], ["torch.rand", "test_evaluator.MockEvaluator", "meddlr.evaluation.evaluator.inference_on_dataset", "test_evaluator.MultiplyModule"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.inference_on_dataset"], ["", "def", "test_inference_on_dataset", "(", ")", ":", "\n", "    ", "inputs", "=", "torch", ".", "rand", "(", "20", ",", "10", ",", "10", ")", "\n", "evaluator", "=", "MockEvaluator", "(", "\"a\"", ")", "\n", "results", "=", "inference_on_dataset", "(", "MultiplyModule", "(", ")", ",", "inputs", ",", "evaluator", ")", "\n", "\n", "assert", "evaluator", ".", "values", "\n", "assert", "\"a\"", "in", "results", "\n", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.MockReconEvaluator.__init__": [[14, 41], ["meddlr.config.config.get_cfg", "meddlr.evaluation.recon_evaluation.ReconEvaluator.__init__", "torch.device", "test_recon_evaluation.MockReconEvaluator.reset"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.reset"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "dataset_name", "=", "\"mock_dataset\"", ",", "\n", "group_by_scan", ":", "bool", "=", "False", ",", "\n", "metrics", "=", "None", ",", "\n", "flush_period", ":", "int", "=", "None", ",", "\n", "eval_in_process", ":", "bool", "=", "False", ",", "\n", "output_dir", ":", "str", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "metrics", "is", "None", ":", "\n", "            ", "metrics", "=", "[", "\"nrmse\"", ",", "\"psnr\"", ",", "\"ssim (Wang)\"", ",", "\"nrmse_scan\"", ",", "\"psnr_scan\"", "]", "\n", "", "cfg", "=", "get_cfg", "(", ")", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "dataset_name", ",", "\n", "cfg", ",", "\n", "output_dir", "=", "output_dir", ",", "\n", "group_by_scan", "=", "group_by_scan", ",", "\n", "metrics", "=", "metrics", ",", "\n", "flush_period", "=", "flush_period", ",", "\n", "skip_rescale", "=", "True", ",", "\n", "eval_in_process", "=", "eval_in_process", ",", "\n", ")", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_normalizer", "=", "None", "\n", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator._cmp_results": [[76, 85], ["a.keys", "a.keys", "b.keys", "cmp_func", "numpy.allclose", "numpy.all"], "methods", ["None"], ["    ", "def", "_cmp_results", "(", "self", ",", "a", ":", "Mapping", ",", "b", ":", "Mapping", ",", "cmp_func", "=", "\"eq\"", ")", ":", "\n", "        ", "if", "cmp_func", "==", "\"allclose\"", ":", "\n", "            ", "cmp_func", "=", "lambda", "x", ",", "y", ":", "np", ".", "allclose", "(", "x", ",", "y", ")", "# noqa: E731", "\n", "", "elif", "cmp_func", "in", "(", "\"equal\"", ",", "\"eq\"", ")", ":", "\n", "            ", "cmp_func", "=", "lambda", "x", ",", "y", ":", "np", ".", "all", "(", "x", "==", "y", ")", "# noqa: E731", "\n", "\n", "", "assert", "a", ".", "keys", "(", ")", "==", "b", ".", "keys", "(", ")", "\n", "for", "k", "in", "a", ".", "keys", "(", ")", ":", "\n", "            ", "assert", "cmp_func", "(", "a", "[", "k", "]", ",", "b", "[", "k", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator.setup": [[86, 89], ["pytest.fixture"], "methods", ["None"], ["", "", "@", "pytest", ".", "fixture", "(", "autouse", "=", "True", ")", "\n", "def", "setup", "(", "self", ",", "tmpdir", ")", ":", "\n", "        ", "self", ".", "tmpdir", "=", "tmpdir", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator.test_flush": [[90, 121], ["torch.rand", "torch.rand", "test_recon_evaluation._build_mock_data", "test_recon_evaluation.MockReconEvaluator", "MockReconEvaluator.evaluate", "test_recon_evaluation.MockReconEvaluator", "zip", "MockReconEvaluator.evaluate", "test_recon_evaluation.TestReconEvaluator._cmp_results", "test_recon_evaluation._build_mock_data", "test_recon_evaluation.MockReconEvaluator", "zip", "MockReconEvaluator.evaluate", "test_recon_evaluation.TestReconEvaluator._cmp_results", "sum", "sum", "MockReconEvaluator.process", "MockReconEvaluator.process", "MockReconEvaluator.flush", "MockReconEvaluator.process", "MockReconEvaluator.flush", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation._build_mock_data", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator._cmp_results", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation._build_mock_data", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator._cmp_results", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush"], ["", "def", "test_flush", "(", "self", ")", ":", "\n", "        ", "scan_slices", "=", "(", "2", ",", "2", ",", "2", ")", "\n", "pred", "=", "torch", ".", "rand", "(", "sum", "(", "scan_slices", ")", ",", "20", ",", "20", ",", "1", ",", "2", ")", "\n", "target", "=", "torch", ".", "rand", "(", "sum", "(", "scan_slices", ")", ",", "20", ",", "20", ",", "1", ",", "2", ")", "\n", "\n", "data", "=", "_build_mock_data", "(", "scan_slices", "=", "scan_slices", ",", "batch_size", "=", "3", ",", "pred", "=", "pred", ",", "target", "=", "target", ")", "\n", "\n", "# Expected results (no flushing).", "\n", "evaluator", "=", "MockReconEvaluator", "(", ")", "\n", "for", "inputs", ",", "outputs", "in", "data", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "", "expected_results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "\n", "# Results with flushing every 3 examples.", "\n", "evaluator", "=", "MockReconEvaluator", "(", ")", "\n", "for", "(", "inputs", ",", "outputs", ")", ",", "num_preds_remaining", "in", "zip", "(", "data", ",", "[", "1", ",", "2", "]", ")", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "evaluator", ".", "flush", "(", "skip_last_scan", "=", "True", ")", "\n", "assert", "len", "(", "evaluator", ".", "_predictions", ")", "==", "num_preds_remaining", "\n", "", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "self", ".", "_cmp_results", "(", "results", ",", "expected_results", ")", "\n", "\n", "# Results with flushing every 4 examples.", "\n", "data", "=", "_build_mock_data", "(", "scan_slices", "=", "scan_slices", ",", "batch_size", "=", "4", ",", "pred", "=", "pred", ",", "target", "=", "target", ")", "\n", "evaluator", "=", "MockReconEvaluator", "(", ")", "\n", "for", "(", "inputs", ",", "outputs", ")", ",", "num_preds_remaining", "in", "zip", "(", "data", ",", "[", "2", ",", "2", "]", ")", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "evaluator", ".", "flush", "(", "skip_last_scan", "=", "True", ")", "\n", "assert", "len", "(", "evaluator", ".", "_predictions", ")", "==", "num_preds_remaining", "\n", "", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "self", ".", "_cmp_results", "(", "results", ",", "expected_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator.test_process_flush": [[122, 141], ["test_recon_evaluation._build_mock_data", "test_recon_evaluation.MockReconEvaluator", "MockReconEvaluator.evaluate", "test_recon_evaluation.MockReconEvaluator", "MockReconEvaluator.evaluate", "test_recon_evaluation.TestReconEvaluator._cmp_results", "MockReconEvaluator.process", "MockReconEvaluator.process"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation._build_mock_data", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator._cmp_results", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process"], ["", "def", "test_process_flush", "(", "self", ")", ":", "\n", "        ", "scan_slices", "=", "(", "3", ",", "8", ",", "2", ",", "5", ",", "10", ",", "5", ",", "17", ",", "7", ")", "\n", "batch_size", "=", "6", "\n", "flush_period", "=", "20", "\n", "data", "=", "_build_mock_data", "(", "scan_slices", "=", "scan_slices", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "# Expected results (no flushing).", "\n", "evaluator", "=", "MockReconEvaluator", "(", ")", "\n", "for", "inputs", ",", "outputs", "in", "data", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "", "expected_results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "\n", "# Test setting flush period.", "\n", "evaluator", "=", "MockReconEvaluator", "(", "flush_period", "=", "flush_period", ")", "\n", "for", "inputs", ",", "outputs", "in", "data", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "\n", "self", ".", "_cmp_results", "(", "results", ",", "expected_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator.test_eval_in_process": [[142, 167], ["test_recon_evaluation._build_mock_data", "test_recon_evaluation.MockReconEvaluator", "MockReconEvaluator.evaluate", "test_recon_evaluation.MockReconEvaluator", "MockReconEvaluator.evaluate", "test_recon_evaluation.TestReconEvaluator._cmp_results", "test_recon_evaluation.MockReconEvaluator", "MockReconEvaluator.evaluate", "test_recon_evaluation.TestReconEvaluator._cmp_results", "MockReconEvaluator.process", "MockReconEvaluator.process", "MockReconEvaluator.process"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation._build_mock_data", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator._cmp_results", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator._cmp_results", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process"], ["", "def", "test_eval_in_process", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test if evaulating inside `process` works.\"\"\"", "\n", "scan_slices", "=", "(", "3", ",", "8", ",", "2", ",", "5", ",", "10", ",", "5", ",", "17", ",", "7", ")", "\n", "batch_size", "=", "6", "\n", "data", "=", "_build_mock_data", "(", "scan_slices", "=", "scan_slices", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "# Expected results (evaluate after process).", "\n", "evaluator", "=", "MockReconEvaluator", "(", ")", "\n", "for", "inputs", ",", "outputs", "in", "data", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "", "expected_results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "\n", "# Test evaluation while processing.", "\n", "evaluator", "=", "MockReconEvaluator", "(", "eval_in_process", "=", "True", ")", "\n", "for", "inputs", ",", "outputs", "in", "data", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "self", ".", "_cmp_results", "(", "results", ",", "expected_results", ")", "\n", "\n", "flush_period", "=", "20", "\n", "evaluator", "=", "MockReconEvaluator", "(", "flush_period", "=", "flush_period", ",", "eval_in_process", "=", "True", ")", "\n", "for", "inputs", ",", "outputs", "in", "data", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "self", ".", "_cmp_results", "(", "results", ",", "expected_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator.test_output_dir": [[168, 182], ["test_recon_evaluation._build_mock_data", "test_recon_evaluation.MockReconEvaluator", "MockReconEvaluator.evaluate", "os.path.exists", "os.path.exists", "os.path.exists", "MockReconEvaluator.process"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation._build_mock_data", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process"], ["", "def", "test_output_dir", "(", "self", ")", ":", "\n", "        ", "scan_slices", "=", "(", "3", ",", "8", ",", "2", ",", "5", ",", "10", ",", "5", ",", "17", ",", "7", ")", "\n", "batch_size", "=", "6", "\n", "data", "=", "_build_mock_data", "(", "scan_slices", "=", "scan_slices", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "# Expected results (evaluate after process).", "\n", "evaluator", "=", "MockReconEvaluator", "(", "output_dir", "=", "self", ".", "tmpdir", ")", "\n", "for", "inputs", ",", "outputs", "in", "data", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "", "_", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "self", ".", "tmpdir", "/", "\"results.txt\"", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "self", ".", "tmpdir", "/", "\"slice_metrics.csv\"", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "self", ".", "tmpdir", "/", "\"scan_metrics.csv\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation.TestReconEvaluator.test_group_results_by_scan": [[183, 198], ["test_recon_evaluation._build_mock_data", "test_recon_evaluation.MockReconEvaluator", "MockReconEvaluator.evaluate", "all", "MockReconEvaluator.evaluate.values", "MockReconEvaluator.process", "all", "chr", "range", "len", "ord"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation._build_mock_data", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_evaluator.MockEvaluator.evaluate", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.values", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process"], ["", "def", "test_group_results_by_scan", "(", "self", ")", ":", "\n", "        ", "scan_slices", "=", "(", "3", ",", "8", ",", "2", ",", "5", ",", "10", ",", "5", ",", "17", ",", "7", ")", "\n", "metrics", "=", "[", "\"nrmse\"", ",", "\"psnr\"", ",", "\"ssim (Wang)\"", ",", "\"nrmse_scan\"", ",", "\"psnr_scan\"", "]", "\n", "batch_size", "=", "6", "\n", "data", "=", "_build_mock_data", "(", "scan_slices", "=", "scan_slices", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "# Expected results (evaluate after process).", "\n", "evaluator", "=", "MockReconEvaluator", "(", "output_dir", "=", "self", ".", "tmpdir", ",", "metrics", "=", "metrics", ",", "group_by_scan", "=", "True", ")", "\n", "for", "inputs", ",", "outputs", "in", "data", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "\n", "assert", "all", "(", "chr", "(", "ord", "(", "\"A\"", ")", "+", "i", ")", "in", "results", "for", "i", "in", "range", "(", "len", "(", "scan_slices", ")", ")", ")", "\n", "for", "v", "in", "results", ".", "values", "(", ")", ":", "\n", "            ", "assert", "all", "(", "f\"val_{name}\"", "in", "v", "for", "name", "in", "metrics", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.test_recon_evaluation._build_mock_data": [[43, 73], ["isinstance", "range", "torch.rand", "torch.rand", "chr", "len", "data.append", "sum", "len", "sum", "sum", "len", "sum", "range", "enumerate", "range", "ord", "len"], "function", ["None"], ["", "", "def", "_build_mock_data", "(", "scan_slices", "=", "(", "2", ",", "2", ",", "2", ")", ",", "batch_size", ":", "int", "=", "2", ",", "pred", "=", "None", ",", "target", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "scan_slices", ",", "int", ")", ":", "\n", "        ", "scan_slices", "=", "(", "scan_slices", ",", ")", "\n", "\n", "", "if", "pred", "is", "None", ":", "\n", "        ", "pred", "=", "torch", ".", "rand", "(", "sum", "(", "scan_slices", ")", ",", "20", ",", "20", ",", "1", ",", "2", ")", "\n", "", "else", ":", "\n", "        ", "assert", "len", "(", "pred", ")", "==", "sum", "(", "scan_slices", ")", "\n", "\n", "", "if", "target", "is", "None", ":", "\n", "        ", "target", "=", "torch", ".", "rand", "(", "sum", "(", "scan_slices", ")", ",", "20", ",", "20", ",", "1", ",", "2", ")", "\n", "", "else", ":", "\n", "        ", "assert", "len", "(", "target", ")", "==", "sum", "(", "scan_slices", ")", "\n", "\n", "", "scan_ids", "=", "[", "chr", "(", "ord", "(", "\"A\"", ")", "+", "i", ")", "for", "i", "in", "range", "(", "len", "(", "scan_slices", ")", ")", "]", "\n", "metadata", "=", "[", "\n", "{", "\"scan_id\"", ":", "scan_id", ",", "\"slice_id\"", ":", "slice_id", "}", "\n", "for", "s_idx", ",", "scan_id", "in", "enumerate", "(", "scan_ids", ")", "\n", "for", "slice_id", "in", "range", "(", "scan_slices", "[", "s_idx", "]", ")", "\n", "]", "\n", "\n", "data", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "pred", ")", ",", "batch_size", ")", ":", "\n", "        ", "data", ".", "append", "(", "\n", "(", "\n", "{", "\"metadata\"", ":", "metadata", "[", "i", ":", "i", "+", "batch_size", "]", "}", ",", "\n", "{", "\"pred\"", ":", "pred", "[", "i", ":", "i", "+", "batch_size", "]", ",", "\"target\"", ":", "target", "[", "i", ":", "i", "+", "batch_size", "]", "}", ",", "\n", ")", "\n", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.build.build_optimizer": [[12, 31], ["model.named_parameters", "build._build_opt", "key.endswith", "key.endswith", "key.endswith"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.build._build_opt"], ["META_ARCH_REGISTRY", "=", "Registry", "(", "\"META_ARCH\"", ")", "# noqa F401 isort:skip", "\n", "META_ARCH_REGISTRY", ".", "__doc__", "=", "\"\"\"\nRegistry for meta-architectures, i.e. the whole model.\n\nThe registered object will be called with `obj(cfg)`\nand expected to return a `nn.Module` object.\n\"\"\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "\n", "def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "return", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.build._build_opt": [[33, 49], ["torch.optim.SGD", "ValueError", "torch.optim.Adam", "ValueError", "optimizer.GradAccumOptimizer"], "function", ["None"], ["    "]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.build.build_lr_scheduler": [[51, 101], ["isinstance", "hasattr", "lr_scheduler.NoOpLR", "lr_scheduler.WarmupMultiStepLR", "lr_scheduler.WarmupCosineLR", "lr_scheduler.WarmupMultiStepLR", "ValueError", "len", "ValueError", "range"], "function", ["None"], ["\n", "_kind_kwd", "=", "\"kind\"", "\n", "_pattern_kwd", "=", "\"patterns\"", "\n", "_init_kwd", "=", "\"initializers\"", "\n", "\n", "if", "isinstance", "(", "initializers", ",", "Dict", ")", ":", "\n", "        ", "initializers", "=", "[", "initializers", "]", "\n", "\n", "# Backwards compatibility with pattern-only initialization.", "\n", "", "if", "isinstance", "(", "initializers", ",", "Sequence", ")", "and", "not", "any", "(", "isinstance", "(", "x", ",", "Dict", ")", "for", "x", "in", "initializers", ")", ":", "\n", "        ", "assert", "len", "(", "initializers", ")", "%", "2", "==", "0", ",", "\"Sequence of regex_to_init must be even\"", "\n", "initializers", "=", "[", "\n", "{", "_pattern_kwd", ":", "k", ",", "_init_kwd", ":", "v", "}", "for", "k", ",", "v", "in", "zip", "(", "initializers", "[", ":", ":", "2", "]", ",", "initializers", "[", "1", ":", ":", "2", "]", ")", "\n", "]", "\n", "\n", "# Convert string values to python literals.", "\n", "", "initializers", "=", "_to_literal", "(", "initializers", ")", "\n", "\n", "if", "not", "all", "(", "\n", "isinstance", "(", "x", ",", "Dict", ")", "or", "(", "isinstance", "(", "x", ",", "Sequence", ")", "and", "len", "(", "x", ")", "==", "2", ")", "for", "x", "in", "initializers", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"All initializers must either be a dict or sequence of 2 elements \"", "\n", "\"(pattern, initializer). Got:\\n\\t{}\"", ".", "format", "(", "initializers", ")", "\n", ")", "\n", "\n", "", "initializers", ":", "List", "[", "Dict", "]", "=", "[", "\n", "{", "_pattern_kwd", ":", "x", "[", "0", "]", ",", "_init_kwd", ":", "x", "[", "1", "]", "}", "if", "isinstance", "(", "x", ",", "Sequence", ")", "else", "x", "\n", "for", "x", "in", "initializers", "\n", "]", "\n", "matched_patterns", "=", "{", "}", "\n", "for", "init_cfg", "in", "initializers", ":", "\n", "        ", "pattern", "=", "init_cfg", ".", "pop", "(", "_pattern_kwd", ",", "None", ")", "\n", "if", "pattern", "is", "None", ":", "\n", "            ", "pattern", "=", "(", "\".*\"", ",", ")", "\n", "", "elif", "not", "isinstance", "(", "pattern", ",", "Sequence", ")", "or", "isinstance", "(", "pattern", ",", "str", ")", ":", "\n", "            ", "pattern", "=", "(", "pattern", ",", ")", "\n", "\n", "", "init_method", "=", "init_cfg", ".", "pop", "(", "_init_kwd", ")", "\n", "if", "not", "isinstance", "(", "init_method", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "init_method", "=", "(", "init_method", ",", ")", "\n", "\n", "", "if", "len", "(", "pattern", ")", "!=", "len", "(", "init_method", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Got {} pattern(s) but {} initializer(s):\\n\\t\"", "\n", "\"Patterns: {}\\n\\tInitializers: {}\"", ".", "format", "(", "\n", "len", "(", "pattern", ")", ",", "len", "(", "init_method", ")", ",", "pattern", ",", "init_method", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.NoOpLR.__init__": [[14, 16], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "self", ",", "optimizer", ",", "last_epoch", "=", "-", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.NoOpLR.get_lr": [[17, 19], ["None"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "return", "self", ".", "base_lrs", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.NoOpLR._compute_values": [[20, 23], ["lr_scheduler.NoOpLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupCosineLR.get_lr"], ["", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupMultiStepLR.__init__": [[32, 52], ["super().__init__", "ValueError", "list", "sorted"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list"], ["def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "milestones", ":", "List", "[", "int", "]", ",", "\n", "gamma", ":", "float", "=", "0.1", ",", "\n", "warmup_factor", ":", "float", "=", "0.001", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "if", "not", "list", "(", "milestones", ")", "==", "sorted", "(", "milestones", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Milestones should be a list of\"", "\" increasing integers. Got {}\"", ",", "milestones", "\n", ")", "\n", "", "self", ".", "milestones", "=", "milestones", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupMultiStepLR.get_lr": [[53, 60], ["lr_scheduler._get_warmup_factor_at_iter", "bisect.bisect_right"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler._get_warmup_factor_at_iter"], ["", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "return", "[", "\n", "base_lr", "*", "warmup_factor", "*", "self", ".", "gamma", "**", "bisect_right", "(", "self", ".", "milestones", ",", "self", ".", "last_epoch", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupMultiStepLR._compute_values": [[62, 65], ["lr_scheduler.WarmupMultiStepLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupCosineLR.get_lr"], ["", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupCosineLR.__init__": [[68, 86], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "max_iters", ":", "int", ",", "\n", "warmup_factor", ":", "float", "=", "0.001", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Adapted from\n        https://github.com/facebookresearch/detectron2\n        \"\"\"", "\n", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupCosineLR.get_lr": [[87, 102], ["lr_scheduler._get_warmup_factor_at_iter", "math.cos"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler._get_warmup_factor_at_iter"], ["", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "# Different definitions of half-cosine with warmup are possible. For", "\n", "# simplicity we multiply the standard half-cosine schedule by the warmup", "\n", "# factor. An alternative is to start the period of the cosine at warmup", "\n", "# iters instead of at 0. In the case that warmup_iters << max_iters the", "\n", "# two are very close to each other.", "\n", "return", "[", "\n", "base_lr", "\n", "*", "warmup_factor", "\n", "*", "0.5", "\n", "*", "(", "1.0", "+", "math", ".", "cos", "(", "math", ".", "pi", "*", "self", ".", "last_epoch", "/", "self", ".", "max_iters", ")", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupCosineLR._compute_values": [[104, 107], ["lr_scheduler.WarmupCosineLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler.WarmupCosineLR.get_lr"], ["", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.lr_scheduler._get_warmup_factor_at_iter": [[109, 136], ["ValueError"], "function", ["None"], ["", "", "def", "_get_warmup_factor_at_iter", "(", "\n", "method", ":", "str", ",", "iter", ":", "int", ",", "warmup_iters", ":", "int", ",", "warmup_factor", ":", "float", "\n", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Return the learning rate warmup factor at a specific iteration.\n    See https://arxiv.org/abs/1706.02677 for more details.\n\n    Args:\n        method (str): warmup method; either \"constant\" or \"linear\".\n        iter (int): iteration at which to calculate the warmup factor.\n        warmup_iters (int): the number of warmup iterations.\n        warmup_factor (float): the base warmup factor (the meaning changes\n            according to the method used).\n\n    Returns:\n        float: the effective warmup factor at the given iteration.\n    \"\"\"", "\n", "if", "iter", ">=", "warmup_iters", ":", "\n", "        ", "return", "1.0", "\n", "\n", "", "if", "method", "==", "\"constant\"", ":", "\n", "        ", "return", "warmup_factor", "\n", "", "elif", "method", "==", "\"linear\"", ":", "\n", "        ", "alpha", "=", "iter", "/", "warmup_iters", "\n", "return", "warmup_factor", "*", "(", "1", "-", "alpha", ")", "+", "alpha", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown warmup method: {}\"", ".", "format", "(", "method", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.__init__": [[13, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "optimizer", ":", "Optimizer", ",", "accumulation_iters", ":", "int", ")", ":", "\n", "        ", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "accumulation_iters", "=", "accumulation_iters", "\n", "self", ".", "step_iters", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.state_dict": [[18, 27], ["optimizer.GradAccumOptimizer.optimizer.state_dict"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.state_dict"], ["", "def", "state_dict", "(", "self", ")", ":", "\n", "# `step_iters` is not saved because if step_iters > 0,", "\n", "# gradients were being accumulated. However when the state dict is saved,", "\n", "# there is no way of restoring these gradients.", "\n", "# So a `step_iters`>0 would falsely indicate we have some gradients", "\n", "# accumulated when we do not.", "\n", "        ", "return", "{", "\n", "\"optimizer\"", ":", "self", ".", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "\"accumulation_iters\"", ":", "self", ".", "accumulation_iters", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.load_state_dict": [[29, 39], ["isinstance", "optimizer.GradAccumOptimizer.optimizer.load_state_dict", "logger.warning"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.load_state_dict"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ")", ":", "\n", "        ", "if", "isinstance", "(", "state_dict", "[", "\"accumulation_iters\"", "]", ",", "int", ")", ":", "\n", "# Needed because of a bug in our saving the state dict", "\n", "            ", "self", ".", "accumulation_iters", "=", "state_dict", "[", "\"accumulation_iters\"", "]", "\n", "", "else", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "f\"`accumulation_iters` is of the wrong type due to saving issue. \"", "\n", "f\"Using initialized value of {self.accumulation_iters}.\"", "\n", ")", "\n", "", "return", "self", ".", "optimizer", ".", "load_state_dict", "(", "state_dict", "[", "\"optimizer\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad": [[40, 43], ["optimizer.GradAccumOptimizer.optimizer.zero_grad"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "step_iters", "%", "self", ".", "accumulation_iters", "==", "0", ":", "\n", "            ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step": [[44, 48], ["optimizer.GradAccumOptimizer._step"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer._step"], ["", "", "def", "step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "        ", "self", ".", "step_iters", "+=", "1", "\n", "if", "self", ".", "step_iters", "%", "self", ".", "accumulation_iters", "==", "0", ":", "\n", "            ", "self", ".", "_step", "(", "closure", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush": [[49, 53], ["optimizer.GradAccumOptimizer.optimizer.zero_grad", "optimizer.GradAccumOptimizer._step"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer._step"], ["", "", "def", "flush", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "step_iters", ">", "0", ":", "\n", "            ", "self", ".", "_step", "(", "closure", ")", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer._step": [[54, 58], ["optimizer.GradAccumOptimizer.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step"], ["", "def", "_step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "        ", "\"\"\"Internal step method. Resets `step_iters` attribute to 0.\"\"\"", "\n", "self", ".", "optimizer", ".", "step", "(", "closure", ")", "\n", "self", ".", "step_iters", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.__getattr__": [[59, 62], ["hasattr", "getattr"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "item", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ".", "optimizer", ",", "item", ")", ":", "\n", "            ", "return", "getattr", "(", "self", ".", "optimizer", ",", "item", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.TestGradAccumOptimizer.test_basic_loop": [[25, 61], ["test_optimizer.build_mock_model", "torch.optim.Adam", "torch.optim.Adam", "meddlr.solver.optimizer.GradAccumOptimizer", "range", "build_mock_model.parameters", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "build_mock_model.", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "torch.sum.backward", "torch.sum.backward", "meddlr.solver.optimizer.GradAccumOptimizer.step", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "test_optimizer._is_zero_grad"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.build_mock_model", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer._is_zero_grad"], ["    ", "def", "test_basic_loop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Pseudo-code:\n\n            ```python\n                for i in range(num_iterations):\n                    ...\n\n                    optimizer.zero_grad()\n                    loss.backward()\n                    optimizer.step()\n            ```\n\n        Expected:\n            i=0: [x] ZG, [-] S\n            i=1: [-] ZG, [x] S\n            i=2: [x] ZG, [-] S\n            i=3: [-] ZG, [x] S\n        \"\"\"", "\n", "num_accum", "=", "2", "\n", "model", "=", "build_mock_model", "(", ")", "\n", "optimizer", "=", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "1e-3", ")", "\n", "optimizer", "=", "GradAccumOptimizer", "(", "optimizer", ",", "num_accum", ")", "\n", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "input", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "16", ",", "16", ")", "\n", "output", "=", "model", "(", "input", ")", "\n", "loss", "=", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "output", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "if", "i", "%", "num_accum", "==", "0", ":", "\n", "                ", "_is_zero_grad", "(", "optimizer", ".", "optimizer", ")", "\n", "", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "(", "i", "+", "1", ")", "%", "num_accum", "==", "0", ":", "\n", "                ", "assert", "optimizer", ".", "step_iters", "==", "0", ",", "f\"Iteration i={i}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.TestGradAccumOptimizer.test_initial_zero_grad_outside_for_loop": [[62, 96], ["test_optimizer.build_mock_model", "torch.optim.Adam", "torch.optim.Adam", "meddlr.solver.optimizer.GradAccumOptimizer", "meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "range", "build_mock_model.parameters", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "build_mock_model.", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum.backward", "torch.sum.backward", "meddlr.solver.optimizer.GradAccumOptimizer.step", "meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "test_optimizer._is_zero_grad"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.build_mock_model", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer._is_zero_grad"], ["", "", "", "def", "test_initial_zero_grad_outside_for_loop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Pseudo-code:\n\n            ```python\n                optimizer.zero_grad()\n\n                for i in range(num_iterations):\n                    ...\n\n                    loss.backward()\n                    optimizer.step()\n                    optimizer.zero_grad()\n            ```\n        \"\"\"", "\n", "num_accum", "=", "2", "\n", "model", "=", "build_mock_model", "(", ")", "\n", "optimizer", "=", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "1e-3", ")", "\n", "optimizer", "=", "GradAccumOptimizer", "(", "optimizer", ",", "num_accum", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "input", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "16", ",", "16", ")", "\n", "output", "=", "model", "(", "input", ")", "\n", "loss", "=", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "output", ")", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "(", "i", "+", "1", ")", "%", "num_accum", "==", "0", ":", "\n", "                ", "assert", "optimizer", ".", "step_iters", "==", "0", ",", "f\"Iteration i={i}\"", "\n", "\n", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "if", "(", "i", "+", "1", ")", "%", "num_accum", "==", "0", ":", "\n", "                ", "_is_zero_grad", "(", "optimizer", ".", "optimizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.TestGradAccumOptimizer.test_flush": [[97, 119], ["test_optimizer.build_mock_model", "torch.optim.Adam", "torch.optim.Adam", "meddlr.solver.optimizer.GradAccumOptimizer", "meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "range", "meddlr.solver.optimizer.GradAccumOptimizer.flush", "test_optimizer._is_zero_grad", "build_mock_model.parameters", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "build_mock_model.", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum.backward", "torch.sum.backward", "meddlr.solver.optimizer.GradAccumOptimizer.step", "meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.build_mock_model", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush", "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer._is_zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "", "", "def", "test_flush", "(", "self", ")", ":", "\n", "        ", "num_accum", "=", "10", "\n", "model", "=", "build_mock_model", "(", ")", "\n", "optimizer", "=", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "1e-3", ")", "\n", "optimizer", "=", "GradAccumOptimizer", "(", "optimizer", ",", "num_accum", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "for", "_i", "in", "range", "(", "num_accum", "-", "1", ")", ":", "\n", "            ", "input", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "16", ",", "16", ")", "\n", "output", "=", "model", "(", "input", ")", "\n", "loss", "=", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "output", ")", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "", "assert", "optimizer", ".", "step_iters", "==", "num_accum", "-", "1", "\n", "\n", "optimizer", ".", "flush", "(", ")", "\n", "\n", "assert", "optimizer", ".", "step_iters", "==", "0", "\n", "_is_zero_grad", "(", "optimizer", ".", "optimizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.TestGradAccumOptimizer.test_flush_zero_steps": [[120, 143], ["test_optimizer.build_mock_model", "torch.optim.Adam", "torch.optim.Adam", "meddlr.solver.optimizer.GradAccumOptimizer", "meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "range", "meddlr.solver.optimizer.GradAccumOptimizer.flush", "test_optimizer._is_zero_grad", "build_mock_model.parameters", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "build_mock_model.", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum.backward", "torch.sum.backward", "meddlr.solver.optimizer.GradAccumOptimizer.step", "meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.build_mock_model", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.flush", "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer._is_zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.step", "home.repos.pwc.inspect_result.ad12_meddlr.solver.optimizer.GradAccumOptimizer.zero_grad", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.abs"], ["", "def", "test_flush_zero_steps", "(", "self", ")", ":", "\n", "        ", "\"\"\"Flushing when step_iters == 0 should only zero out the gradient.\"\"\"", "\n", "num_accum", "=", "10", "\n", "model", "=", "build_mock_model", "(", ")", "\n", "optimizer", "=", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "1e-3", ")", "\n", "optimizer", "=", "GradAccumOptimizer", "(", "optimizer", ",", "num_accum", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "for", "_i", "in", "range", "(", "num_accum", ")", ":", "\n", "            ", "input", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "16", ",", "16", ")", "\n", "output", "=", "model", "(", "input", ")", "\n", "loss", "=", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "output", ")", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "", "assert", "optimizer", ".", "step_iters", "==", "0", "\n", "\n", "optimizer", ".", "flush", "(", ")", "\n", "\n", "assert", "optimizer", ".", "step_iters", "==", "0", "\n", "_is_zero_grad", "(", "optimizer", ".", "optimizer", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer._is_zero_grad": [[10, 16], ["torch.allclose", "torch.allclose", "torch.zeros", "torch.zeros"], "function", ["None"], ["def", "_is_zero_grad", "(", "optimizer", ")", ":", "\n", "    ", "for", "group", "in", "optimizer", ".", "param_groups", ":", "\n", "        ", "for", "p", "in", "group", "[", "\"params\"", "]", ":", "\n", "            ", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                ", "a", "=", "p", ".", "grad", "\n", "assert", "torch", ".", "allclose", "(", "a", ",", "torch", ".", "zeros", "(", "a", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.build_mock_model": [[18, 21], ["torch.Sequential", "torch.Conv2d", "torch.Conv2d"], "function", ["None"], ["", "", "", "", "def", "build_mock_model", "(", ")", ":", "\n", "    ", "return", "nn", ".", "Sequential", "(", "\n", "*", "[", "nn", ".", "Conv2d", "(", "1", ",", "16", ",", "kernel_size", "=", "(", "3", ",", "3", ")", ")", ",", "nn", ".", "Conv2d", "(", "16", ",", "32", ",", "kernel_size", "=", "(", "3", ",", "3", ")", ")", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.solver.test_build.TestBuildOptimizer.test_build_grad_accumulation": [[13, 26], ["test_optimizer.build_mock_model", "meddlr.config.get_cfg", "meddlr.solver.build.build_optimizer", "isinstance", "meddlr.config.get_cfg", "meddlr.solver.build.build_optimizer", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.solver.test_optimizer.build_mock_model", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.solver.build.build_optimizer", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.solver.build.build_optimizer"], ["block_order", "=", "(", "\"conv\"", ",", "\"relu\"", ",", "\"conv\"", ",", "\"relu\"", ",", "\"batchnorm\"", ",", "\"dropout\"", ")", ",", "\n", ")", "\n", "initialize_model", "(", "\n", "model", ",", "initializers", "=", "{", "\"kind\"", ":", "\"conv\"", ",", "\"patterns\"", ":", "\".*bias\"", ",", "\"initializers\"", ":", "\"zeros_\"", "}", "\n", ")", "\n", "\n", "layers_by_kind", "=", "_get_model_layers", "(", "model", ",", "by_kind", "=", "True", ")", "\n", "for", "layer", "in", "layers_by_kind", "[", "\"conv\"", "]", ":", "\n", "        ", "assert", "torch", ".", "all", "(", "layer", ".", "bias", "==", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process": [[40, 47], ["meddlr.is_complex_as_real", "super().process", "torch.view_as_complex"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.is_complex_as_real", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.ZFReconEvaluator.process"], ["def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "zf_out", "=", "{", "k", ":", "outputs", "[", "k", "]", "for", "k", "in", "(", "\"target\"", ",", ")", "}", "\n", "zf_image", "=", "outputs", "[", "\"zf_image\"", "]", "\n", "if", "cplx", ".", "is_complex_as_real", "(", "zf_image", ")", ":", "\n", "            ", "zf_image", "=", "torch", ".", "view_as_complex", "(", "zf_image", ")", "\n", "", "zf_out", "[", "\"pred\"", "]", "=", "zf_image", "\n", "return", "super", "(", ")", ".", "process", "(", "inputs", ",", "zf_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.setup": [[49, 70], ["meddlr.config.get_cfg", "meddlr.config.get_cfg.merge_from_file", "meddlr.config.get_cfg.merge_from_list", "meddlr.config.get_cfg.freeze", "meddlr.engine.default_setup", "meddlr.utils.logger.setup_logger", "meddlr.utils.logger.setup_logger.info", "os.path.join"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_list", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.default_setup", "home.repos.pwc.inspect_result.ad12_meddlr.utils.logger.setup_logger"], ["", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    We do not save the config.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "opts", "=", "args", ".", "opts", "\n", "if", "opts", "and", "opts", "[", "0", "]", "==", "\"--\"", ":", "\n", "        ", "opts", "=", "opts", "[", "1", ":", "]", "\n", "", "cfg", ".", "merge_from_list", "(", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ",", "save_cfg", "=", "False", ")", "\n", "\n", "# Setup logger for test results", "\n", "global", "logger", "\n", "dirname", "=", "\"test_results\"", "\n", "logger", "=", "setup_logger", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "dirname", ")", ",", "name", "=", "_FILE_NAME", ")", "\n", "\n", "logger", ".", "info", "(", "f\"Command Line Args: {args}\"", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.add_default_params": [[72, 98], ["copy.deepcopy", "defaults_keys_map.items", "df.rename.rename", "df.rename.rename", "x.lower", "k.lower", "_DEFAULT_VALS.keys", "_DEFAULT_VALS.keys", "column_map.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "add_default_params", "(", "metrics", ":", "pd", ".", "DataFrame", ",", "ignore_case", "=", "True", ")", ":", "\n", "    ", "\"\"\"Adds default config parameters (if missing).\n\n    Args:\n        metrics (pd.DataFrame): Will be filtered based on column values.\n        ignore_case (bool, optional): If `True`, ignores the column casing.\n            Raises `ValueError` if two columns have the same lower case\n            form.\n    \"\"\"", "\n", "\n", "df", "=", "deepcopy", "(", "metrics", ")", "\n", "if", "ignore_case", ":", "\n", "        ", "column_map", "=", "{", "x", ":", "x", ".", "lower", "(", ")", "for", "x", "in", "df", ".", "columns", "}", "\n", "defaults_keys_map", "=", "{", "k", ".", "lower", "(", ")", ":", "k", "for", "k", "in", "_DEFAULT_VALS", ".", "keys", "(", ")", "}", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "column_map", ")", "\n", "", "else", ":", "\n", "        ", "defaults_keys_map", "=", "{", "k", ":", "k", "for", "k", "in", "_DEFAULT_VALS", ".", "keys", "(", ")", "}", "\n", "\n", "", "for", "fmt_key", ",", "real_key", "in", "defaults_keys_map", ".", "items", "(", ")", ":", "\n", "        ", "if", "fmt_key", "not", "in", "df", ".", "columns", ":", "\n", "            ", "df", "[", "real_key", "]", "=", "_DEFAULT_VALS", "[", "real_key", "]", "\n", "\n", "", "", "if", "ignore_case", ":", "\n", "        ", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "column_map", ".", "items", "(", ")", "}", ")", "\n", "\n", "", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.find_metrics": [[100, 150], ["copy.deepcopy", "params.items", "df.rename.rename", "x.lower", "df.rename.rename", "x.lower", "k.lower", "x.lower", "x.lower", "params.items", "_DEFAULT_VALS.keys", "KeyError", "column_map.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "def", "find_metrics", "(", "\n", "metrics", ":", "pd", ".", "DataFrame", ",", "params", ":", "Dict", "[", "str", ",", "Any", "]", ",", "ignore_missing", "=", "False", ",", "ignore_case", "=", "True", "\n", ")", ":", "\n", "    ", "\"\"\"Find subset of metrics dictionary that matches parameter configuration.\n\n    Note:\n        Values that are not available will be filled in by _DEFAULT_VALS.\n\n    Args:\n        metrics (pd.DataFrame): Will be filtered based on column values.\n        params (Dict[str, Any]): Parameter values to filter by.\n            Keys should correspond to column names in `metrics`.\n        ignore_missing (bool, optional): If `True`, ignores filtering by\n            columns that are missing.\n        ignore_case (bool, optional): If `True`, ignores the column casing.\n            Raises `ValueError` if two columns have the same lower case\n            form.\n\n    Returns:\n        df (pd.DataFrame): The remaining dataframe after filtering.\n    \"\"\"", "\n", "\n", "df", "=", "deepcopy", "(", "metrics", ")", "\n", "if", "ignore_case", ":", "\n", "        ", "column_map", "=", "{", "x", ":", "x", ".", "lower", "(", ")", "for", "x", "in", "df", ".", "columns", "}", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "column_map", ")", "\n", "params", "=", "{", "k", ".", "lower", "(", ")", ":", "v", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", "}", "\n", "\n", "# Fill in with default values if missing.", "\n", "# Note these will always be lower case, so we match based on case.", "\n", "# Fill in default values when the columns are not available.", "\n", "", "default_keys", "=", "{", "x", ".", "lower", "(", ")", "for", "x", "in", "params", "}", "&", "{", "x", ".", "lower", "(", ")", "for", "x", "in", "_DEFAULT_VALS", ".", "keys", "(", ")", "}", "\n", "lowercase_cols", "=", "[", "x", ".", "lower", "(", ")", "for", "x", "in", "df", ".", "columns", "]", "\n", "for", "k", "in", "default_keys", ":", "\n", "        ", "if", "k", "not", "in", "lowercase_cols", ":", "\n", "            ", "df", "[", "k", "]", "=", "_DEFAULT_VALS", "[", "k", "]", "\n", "\n", "", "", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", ":", "\n", "        ", "if", "k", "not", "in", "df", ".", "columns", ":", "\n", "            ", "if", "ignore_missing", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "raise", "KeyError", "(", "f\"No column {k} in `metrics`\"", ")", "\n", "", "", "df", "=", "df", "[", "df", "[", "k", "]", "==", "v", "]", "\n", "\n", "# Undo matching by lower case.", "\n", "", "if", "ignore_case", ":", "\n", "        ", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "column_map", ".", "items", "(", ")", "}", ")", "\n", "\n", "", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.update_metrics": [[152, 185], ["any", "any", "list", "list", "KeyError", "KeyError", "itertools.product", "itertools.product", "len", "pandas.concat", "pandas.concat", "pd.concat.append", "eval_net.find_metrics", "metrics_old[].unique().tolist", "metrics_new[].unique().tolist", "zip", "metrics_old[].unique", "metrics_new[].unique"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.find_metrics"], ["", "def", "update_metrics", "(", "metrics_new", ":", "pd", ".", "DataFrame", ",", "metrics_old", ":", "pd", ".", "DataFrame", ",", "on", ":", "Sequence", "[", "str", "]", ")", ":", "\n", "    ", "\"\"\"Update a previous metrics version with the new one.\n\n    Metrics that were previously computed, may not be recomputed.\n    To avoid overwriting them when writing to a csv, we want to\n    port over any old metrics that we did not recompute.\n    \"\"\"", "\n", "# We currently do not support missing columns.", "\n", "missing_cols", "=", "[", "k", "not", "in", "metrics_old", ".", "columns", "for", "k", "in", "on", "]", "\n", "if", "any", "(", "missing_cols", ")", ":", "\n", "        ", "raise", "KeyError", "(", "f\"Column(s) {missing_cols} not found in `metrics_old`\"", ")", "\n", "", "missing_cols", "=", "[", "k", "not", "in", "metrics_new", ".", "columns", "for", "k", "in", "on", "]", "\n", "if", "any", "(", "missing_cols", ")", ":", "\n", "        ", "raise", "KeyError", "(", "f\"Column(s) {missing_cols} not found in `metrics_new`\"", ")", "\n", "\n", "# Find combination of columns to select on that is not", "\n", "# available in the new metrics, but is available in the", "\n", "# old metrics.", "\n", "", "old_metrics_combos", "=", "list", "(", "itertools", ".", "product", "(", "*", "[", "metrics_old", "[", "k", "]", ".", "unique", "(", ")", ".", "tolist", "(", ")", "for", "k", "in", "on", "]", ")", ")", "\n", "new_metrics_combos", "=", "list", "(", "itertools", ".", "product", "(", "*", "[", "metrics_new", "[", "k", "]", ".", "unique", "(", ")", ".", "tolist", "(", ")", "for", "k", "in", "on", "]", ")", ")", "\n", "\n", "to_prepend", "=", "[", "]", "\n", "for", "combo", "in", "old_metrics_combos", ":", "\n", "        ", "if", "combo", "not", "in", "new_metrics_combos", ":", "\n", "            ", "combo_as_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "on", ",", "combo", ")", "}", "\n", "to_prepend", ".", "append", "(", "find_metrics", "(", "metrics_old", ",", "combo_as_dict", ")", ")", "\n", "\n", "", "", "if", "len", "(", "to_prepend", ")", ">", "0", ":", "\n", "        ", "to_prepend", "=", "pd", ".", "concat", "(", "to_prepend", ",", "ignore_index", "=", "True", ")", "\n", "metrics", "=", "pd", ".", "concat", "(", "[", "to_prepend", ",", "metrics_new", "]", ",", "ignore_index", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "metrics", "=", "metrics_new", "\n", "", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval": [[187, 403], ["torch.no_grad", "args.noise.lower", "args.motion.lower", "model.eval.to", "model.eval.eval", "os.path.join", "os.path.join", "itertools.product", "list", "meddlr.evaluation.ReconEvaluator.default_metrics", "enumerate", "os.path.isfile", "pandas.read_csv", "eval_net.add_default_params", "sorted", "sorted", "ReconEvaluator.default_metrics.extend", "logger.info", "logger.info", "logger.info", "logger.info", "params.update", "cfg.clone", "cfg.clone.defrost", "cfg.clone.freeze", "meddlr.data.build.build_recon_val_loader", "os.path.join", "meddlr.evaluation.DatasetEvaluators", "meddlr.evaluation.inference_on_dataset", "pandas.concat", "logger.info", "pd.concat.append", "len", "pandas.concat", "logger.info", "logger.info", "update_metrics.to_csv", "set", "set", "ValueError", "meddlr.evaluation.ReconEvaluator", "os.path.join", "meddlr.evaluation.DatasetEvaluators.append", "pandas.DataFrame().T.reset_index().rename", "find_metrics.merge", "scan_results.drop.drop", "params.items", "len", "eval_net.find_metrics", "list", "eval_net.ZFReconEvaluator", "len", "scan_results.drop.filter().columns.tolist", "tabulate.tabulate", "tabulate.tabulate", "eval_net.update_metrics", "len", "len", "logger.info", "pd.concat.append", "params.items", "pandas.DataFrame().T.reset_index", "logger.error", "logger.error", "params.items", "set", "set", "tabulate.tabulate", "scan_results.drop.filter", "pandas.DataFrame", "params.items"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.recon_evaluation.ReconEvaluator.default_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.add_default_params", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_recon_val_loader", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.inference_on_dataset", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.find_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.list", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.update_metrics", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "eval", "(", "cfg", ",", "args", ",", "model", ",", "weights_basename", ",", "criterion", ",", "best_value", ")", ":", "\n", "    ", "zero_filled", "=", "args", ".", "zero_filled", "\n", "noise_arg", "=", "args", ".", "noise", ".", "lower", "(", ")", "\n", "motion_arg", "=", "args", ".", "motion", ".", "lower", "(", ")", "\n", "include_noise", "=", "noise_arg", "!=", "\"false\"", "\n", "include_motion", "=", "motion_arg", "!=", "\"false\"", "\n", "noise_sweep_vals", "=", "args", ".", "sweep_vals", "\n", "motion_sweep_vals", "=", "args", ".", "sweep_vals_motion", "\n", "skip_rescale", "=", "args", ".", "skip_rescale", "\n", "overwrite", "=", "args", ".", "overwrite", "\n", "save_scans", "=", "args", ".", "save_scans", "or", "\"save_scans\"", "in", "args", ".", "ops", "\n", "compute_metrics", "=", "\"metrics\"", "in", "args", ".", "ops", "\n", "# TODO: Set up W&B configuration.", "\n", "# use_wandb = args.use_wandb", "\n", "# if use_wandb:", "\n", "#     run = init_wandb_run(cfg, resume=True, job_type=\"eval\", use_api=True)", "\n", "\n", "device", "=", "cfg", ".", "MODEL", ".", "DEVICE", "\n", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "model", "=", "model", ".", "eval", "(", ")", "\n", "\n", "# Get and load metrics file", "\n", "output_dir", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"test_results\"", ")", "\n", "metrics_file", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "args", ".", "metrics_file", ")", "\n", "if", "not", "overwrite", "and", "os", ".", "path", ".", "isfile", "(", "metrics_file", ")", ":", "\n", "        ", "metrics", "=", "pd", ".", "read_csv", "(", "metrics_file", ",", "index_col", "=", "0", ")", "\n", "# Add default parameters to metrics.", "\n", "metrics", "=", "add_default_params", "(", "metrics", ")", "\n", "", "else", ":", "\n", "        ", "metrics", "=", "None", "\n", "\n", "# Returns average or each scan", "\n", "", "group_by_scan", "=", "True", "\n", "\n", "# Find range of noise values to search", "\n", "if", "include_noise", ":", "\n", "        ", "noise_vals", "=", "noise_sweep_vals", "if", "noise_arg", "==", "\"sweep\"", "else", "[", "0", "]", "\n", "# noise_vals += list(cfg.MODEL.CONSISTENCY.AUG.NOISE.STD_DEV)", "\n", "noise_vals", "=", "sorted", "(", "set", "(", "noise_vals", ")", ")", "\n", "", "else", ":", "\n", "        ", "noise_vals", "=", "[", "0", "]", "\n", "\n", "", "if", "include_motion", ":", "\n", "        ", "motion_vals", "=", "[", "0", "]", "+", "motion_sweep_vals", "if", "motion_arg", "==", "\"sweep\"", "else", "[", "0", "]", "\n", "motion_vals", "=", "sorted", "(", "set", "(", "motion_vals", ")", ")", "\n", "", "else", ":", "\n", "        ", "motion_vals", "=", "[", "0", "]", "\n", "\n", "", "values", "=", "itertools", ".", "product", "(", "\n", "cfg", ".", "DATASETS", ".", "TEST", ",", "cfg", ".", "AUG_TEST", ".", "UNDERSAMPLE", ".", "ACCELERATIONS", ",", "noise_vals", ",", "motion_vals", "\n", ")", "\n", "values", "=", "list", "(", "values", ")", "\n", "all_results", "=", "[", "]", "\n", "\n", "default_metrics", "=", "ReconEvaluator", ".", "default_metrics", "(", ")", "\n", "if", "args", ".", "extra_metrics", ":", "\n", "        ", "if", "not", "compute_metrics", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Extra metrics were specified, but `--ops` did not \"", "\n", "\"indicate eval should perform metric computation\"", "\n", ")", "\n", "", "default_metrics", ".", "extend", "(", "args", ".", "extra_metrics", ")", "\n", "\n", "", "for", "exp_idx", ",", "(", "dataset_name", ",", "acc", ",", "noise_level", ",", "motion_level", ")", "in", "enumerate", "(", "values", ")", ":", "\n", "# Check if the current configuration already has metrics computed", "\n", "# If so, dont recompute", "\n", "        ", "params", "=", "{", "\n", "\"Acceleration\"", ":", "acc", ",", "\n", "\"dataset\"", ":", "dataset_name", ",", "\n", "\"Noise Level\"", ":", "noise_level", ",", "\n", "\"Motion Level\"", ":", "motion_level", ",", "\n", "\"weights\"", ":", "weights_basename", ",", "\n", "\"rescaled\"", ":", "not", "skip_rescale", ",", "\n", "}", "\n", "eval_metrics", "=", "default_metrics", "\n", "\n", "logger", ".", "info", "(", "\"==\"", "*", "30", ")", "\n", "logger", ".", "info", "(", "\"Experiment ({}/{})\"", ".", "format", "(", "exp_idx", "+", "1", ",", "len", "(", "values", ")", ")", ")", "\n", "logger", ".", "info", "(", "\", \"", ".", "join", "(", "[", "f\"{k}: {v}\"", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", "]", ")", ")", "\n", "logger", ".", "info", "(", "\"==\"", "*", "30", ")", "\n", "\n", "existing_metrics", "=", "None", "\n", "if", "metrics", "is", "not", "None", "and", "compute_metrics", ":", "\n", "            ", "try", ":", "\n", "                ", "existing_metrics", "=", "find_metrics", "(", "metrics", ",", "params", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "existing_metrics", "=", "None", "\n", "", "if", "existing_metrics", "is", "not", "None", "and", "len", "(", "existing_metrics", ")", ">", "0", ":", "\n", "                ", "eval_metrics", "=", "list", "(", "set", "(", "eval_metrics", ")", "-", "set", "(", "existing_metrics", ".", "columns", ")", ")", "\n", "if", "len", "(", "eval_metrics", ")", "==", "0", ":", "\n", "                    ", "logger", ".", "info", "(", "\n", "\"Metrics for ({}) exist:\\n{}\"", ".", "format", "(", "\n", "\", \"", ".", "join", "(", "[", "f\"{k}: {v}\"", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", "]", ")", ",", "\n", "tabulate", "(", "existing_metrics", ",", "headers", "=", "existing_metrics", ".", "columns", ")", ",", "\n", ")", "\n", ")", "\n", "all_results", ".", "append", "(", "existing_metrics", ")", "\n", "continue", "\n", "\n", "# Add criterion and value after to avoid searching by it.", "\n", "", "", "", "params", ".", "update", "(", "{", "\"Criterion Name\"", ":", "criterion", ",", "\"Criterion Val\"", ":", "best_value", "}", ")", "\n", "\n", "# Assign the current acceleration", "\n", "s_cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "s_cfg", ".", "defrost", "(", ")", "\n", "s_cfg", ".", "AUG_TRAIN", ".", "UNDERSAMPLE", ".", "ACCELERATIONS", "=", "(", "acc", ",", ")", "\n", "s_cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "MOTION", ".", "RANGE", "=", "motion_level", "\n", "s_cfg", ".", "MODEL", ".", "CONSISTENCY", ".", "AUG", ".", "NOISE", ".", "STD_DEV", "=", "(", "noise_level", ",", ")", "\n", "s_cfg", ".", "freeze", "(", ")", "\n", "\n", "# Build a recon val loader", "\n", "dataloader", "=", "build_recon_val_loader", "(", "\n", "s_cfg", ",", "\n", "dataset_name", ",", "\n", "as_test", "=", "True", ",", "\n", "add_noise", "=", "noise_level", ">", "0", ",", "\n", "add_motion", "=", "motion_level", ">", "0", ",", "\n", ")", "\n", "\n", "# Build evaluators. Only save reconstructions for last scan.", "\n", "params_str", "=", "\"-\"", ".", "join", "(", "f\"{k}={v}\"", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", "if", "k", "!=", "\"dataset\"", ")", "\n", "exp_output_dir", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "dataset_name", ",", "params_str", ")", "\n", "evaluators", "=", "[", "\n", "ReconEvaluator", "(", "\n", "dataset_name", ",", "\n", "s_cfg", ",", "\n", "group_by_scan", "=", "group_by_scan", ",", "\n", "skip_rescale", "=", "skip_rescale", ",", "\n", "save_scans", "=", "save_scans", ",", "\n", "output_dir", "=", "exp_output_dir", ",", "\n", "metrics", "=", "eval_metrics", "if", "compute_metrics", "else", "False", ",", "\n", "prefix", "=", "None", ",", "\n", ")", "\n", "]", "\n", "# TODO: add support for multiple evaluators.", "\n", "if", "zero_filled", ":", "\n", "            ", "zf_output_dir", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "dataset_name", ",", "\"ZeroFilled-\"", "+", "params_str", ")", "\n", "\n", "evaluators", ".", "append", "(", "\n", "ZFReconEvaluator", "(", "\n", "dataset_name", ",", "\n", "s_cfg", ",", "\n", "group_by_scan", "=", "group_by_scan", ",", "\n", "skip_rescale", "=", "skip_rescale", ",", "\n", "save_scans", "=", "save_scans", ",", "\n", "output_dir", "=", "zf_output_dir", ",", "\n", "metrics", "=", "eval_metrics", "if", "compute_metrics", "else", "False", ",", "\n", "prefix", "=", "None", ",", "\n", ")", "\n", ")", "\n", "", "evaluators", "=", "DatasetEvaluators", "(", "evaluators", ",", "as_list", "=", "True", ")", "\n", "\n", "results", "=", "inference_on_dataset", "(", "model", ",", "dataloader", ",", "evaluators", ")", "\n", "results", "=", "[", "\n", "pd", ".", "DataFrame", "(", "x", ")", ".", "T", ".", "reset_index", "(", ")", ".", "rename", "(", "columns", "=", "{", "\"index\"", ":", "\"scan_name\"", "}", ")", "for", "x", "in", "results", "\n", "]", "\n", "\n", "results", "[", "0", "]", "[", "\"Method\"", "]", "=", "s_cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "if", "zero_filled", ":", "\n", "            ", "results", "[", "1", "]", "[", "\"Method\"", "]", "=", "\"Zero-Filled\"", "\n", "", "scan_results", "=", "pd", ".", "concat", "(", "results", ",", "ignore_index", "=", "True", ")", "\n", "\n", "if", "existing_metrics", "is", "not", "None", "and", "len", "(", "existing_metrics", ")", ">", "0", ":", "\n", "            ", "scan_results", "=", "existing_metrics", ".", "merge", "(", "\n", "scan_results", ",", "on", "=", "[", "\"scan_name\"", ",", "\"Method\"", "]", ",", "suffixes", "=", "(", "\"\"", ",", "\"_y\"", ")", "\n", ")", "\n", "scan_results", "=", "scan_results", ".", "drop", "(", "\n", "scan_results", ".", "filter", "(", "regex", "=", "\"_y$\"", ")", ".", "columns", ".", "tolist", "(", ")", ",", "axis", "=", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", ":", "\n", "                ", "scan_results", "[", "k", "]", "=", "v", "\n", "", "", "logger", ".", "info", "(", "\"\\n\"", "+", "tabulate", "(", "scan_results", ",", "headers", "=", "scan_results", ".", "columns", ")", ")", "\n", "\n", "all_results", ".", "append", "(", "scan_results", ")", "\n", "del", "evaluators", "\n", "del", "dataloader", "\n", "# Currently don't support writing data because it takes too long", "\n", "# logger.info(\"Saving data...\")", "\n", "# file_path = os.path.join(output_dir, dataset_name, \"{}.h5\".format(scan_name))", "\n", "# os.makedirs(os.path.dirname(file_path), exist_ok=True)", "\n", "\n", "", "if", "len", "(", "all_results", ")", ">", "0", ":", "\n", "        ", "all_results", "=", "pd", ".", "concat", "(", "all_results", ",", "ignore_index", "=", "True", ")", "\n", "logger", ".", "info", "(", "\"Summary:\\n{}\"", ".", "format", "(", "tabulate", "(", "all_results", ",", "headers", "=", "all_results", ".", "columns", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\"No evaluation metrics were computed or available in this run\"", ")", "\n", "\n", "# Try to copy over old metrics information.", "\n", "# TODO: If fails, it automatically saves the old file in a versioned", "\n", "# form and prints logging message.", "\n", "", "if", "compute_metrics", ":", "\n", "        ", "if", "metrics", "is", "not", "None", ":", "\n", "            ", "try", ":", "\n", "                ", "running_results", "=", "update_metrics", "(", "\n", "all_results", ",", "\n", "metrics", ",", "\n", "on", "=", "[", "\n", "\"Acceleration\"", ",", "\n", "\"dataset\"", ",", "\n", "\"Noise Level\"", ",", "\n", "\"Motion Level\"", ",", "\n", "\"weights\"", ",", "\n", "\"Method\"", ",", "\n", "\"rescaled\"", ",", "\n", "]", ",", "\n", ")", "\n", "", "except", "KeyError", "as", "e", ":", "\n", "                ", "logger", ".", "error", "(", "e", ")", "\n", "logger", ".", "error", "(", "\"Failed to load old metrics information\"", ")", "\n", "# raise e", "\n", "running_results", "=", "all_results", "\n", "", "", "else", ":", "\n", "            ", "running_results", "=", "all_results", "\n", "", "running_results", ".", "to_csv", "(", "metrics_file", ",", "mode", "=", "\"w\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.main": [[405, 433], ["eval_net.setup", "meddlr.engine.DefaultTrainer.build_model", "isinstance", "setup.defrost", "setup.freeze", "eval_net.eval", "model.to.to", "meddlr.checkpoint.Checkpointer().resume_or_load", "logger.info", "meddlr.evaluation.testing.check_consistency", "logger.info", "logger.info", "meddlr.evaluation.testing.find_weights", "os.path.basename", "meddlr.checkpoint.Checkpointer", "torch.load"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tools.train_net.setup", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.defrost", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.tools.eval_net.eval", "home.repos.pwc.inspect_result.ad12_meddlr.builtin.mri.MRIReconAugmentor.to", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.check_consistency", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.find_weights"], ["", "", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "model", "=", "DefaultTrainer", ".", "build_model", "(", "cfg", ")", "\n", "if", "isinstance", "(", "model", ",", "CSModel", ")", ":", "\n", "        ", "weights", ",", "criterion", ",", "best_value", "=", "None", ",", "None", ",", "0", "\n", "", "else", ":", "\n", "        ", "metric", "=", "args", ".", "metric", "if", "args", ".", "metric", "else", "f\"val_{cfg.MODEL.RECON_LOSS.NAME}\"", "\n", "weights", ",", "criterion", ",", "best_value", "=", "(", "\n", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "None", ",", "None", ")", "\n", "if", "cfg", ".", "MODEL", ".", "WEIGHTS", "\n", "else", "find_weights", "(", "cfg", ",", "metric", ",", "iter_limit", "=", "args", ".", "iter_limit", ")", "\n", ")", "\n", "model", "=", "model", ".", "to", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", "\n", "Checkpointer", "(", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "weights", ",", "resume", "=", "args", ".", "resume", ")", "\n", "\n", "# See https://github.com/pytorch/pytorch/issues/42300", "\n", "logger", ".", "info", "(", "\"Checking weights were properly loaded...\"", ")", "\n", "check_consistency", "(", "torch", ".", "load", "(", "weights", ")", "[", "\"model\"", "]", ",", "model", ")", "\n", "\n", "logger", ".", "info", "(", "\"\\n\\n==============================\"", ")", "\n", "logger", ".", "info", "(", "\"Loading weights from {}\"", ".", "format", "(", "weights", ")", ")", "\n", "\n", "# Do not limit number of scans to evaluate during testing.", "\n", "", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "DATALOADER", ".", "SUBSAMPLE_TRAIN", ".", "NUM_VAL", "=", "-", "1", "\n", "cfg", ".", "freeze", "(", ")", "\n", "\n", "eval", "(", "cfg", ",", "args", ",", "model", ",", "os", ".", "path", ".", "basename", "(", "weights", ")", "if", "weights", "else", "None", ",", "criterion", ",", "best_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.clean_results.clean_results": [[31, 113], ["meddlr.utils.general.find_experiment_dirs", "isinstance", "isinstance", "os.path.abspath", "print", "meddlr.config.get_cfg", "meddlr.config.get_cfg.merge_from_file", "collections.defaultdict", "itertools.product", "pandas.DataFrame", "print", "print", "isinstance", "os.path.join", "meddlr.evaluation.testing.find_weights", "isinstance", "data[].extend", "data[].extend", "data[].extend", "data[].extend", "tabulate.tabulate", "set", "os.path.abspath", "str().lower", "str().lower", "data[].tolist", "os.path.join", "os.path.join", "os.listdir", "x.endswith", "len", "len", "input", "input", "os.remove", "len", "len", "sys.exit", "str", "str", "str", "len", "len"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.utils.general.find_experiment_dirs", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.testing.find_weights", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["def", "clean_results", "(", "\n", "dirpath", ":", "Union", "[", "str", ",", "Path", "]", ",", "\n", "top_k", ":", "int", ",", "\n", "metrics", ":", "Union", "[", "str", ",", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "iter_limit", ":", "Union", "[", "int", ",", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "interactive", ":", "bool", "=", "False", ",", "\n", "remove", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Remove all extra weight files that are no longer needed.\n\n    We do not remove the ``'model_final.pth'`` file as this is one way we\n    identify which runs are complete.\n\n    Args:\n        dirpath: Directory to recursively search.\n        top_k (int): The number of top weights to keep.\n        metrics: The metrics(s) to use for finding weights.\n        interactive (bool, optional): If `True`, this method will\n            wait for your input before deleting all weights.\n        remove (bool, optional): If ``True``, weight will be deleted. Otherwise,\n            the weights will just be printed out.\n    \"\"\"", "\n", "if", "isinstance", "(", "metrics", ",", "str", ")", "or", "not", "isinstance", "(", "metrics", ",", "Collection", ")", ":", "\n", "        ", "metrics", "=", "[", "metrics", "]", "\n", "", "if", "not", "isinstance", "(", "iter_limit", ",", "Collection", ")", ":", "\n", "        ", "iter_limit", "=", "[", "iter_limit", "]", "\n", "\n", "", "all_exp_paths", "=", "find_experiment_dirs", "(", "dirpath", ",", "completed", "=", "True", ")", "\n", "for", "exp_path", "in", "all_exp_paths", ":", "\n", "        ", "exp_path", "=", "os", ".", "path", ".", "abspath", "(", "exp_path", ")", "\n", "print", "(", "exp_path", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "os", ".", "path", ".", "join", "(", "exp_path", ",", "\"config.yaml\"", ")", ")", "\n", "\n", "data", "=", "defaultdict", "(", "list", ")", "\n", "for", "_metric", ",", "_iter_limit", "in", "itertools", ".", "product", "(", "metrics", ",", "iter_limit", ")", ":", "\n", "            ", "if", "str", "(", "_metric", ")", ".", "lower", "(", ")", "==", "\"none\"", ":", "\n", "                ", "_metric", "=", "None", "\n", "", "if", "str", "(", "_iter_limit", ")", ".", "lower", "(", ")", "==", "\"none\"", ":", "\n", "                ", "_iter_limit", "=", "None", "\n", "", "filepaths", ",", "criterion", ",", "best_vals", "=", "find_weights", "(", "\n", "cfg", ",", "criterion", "=", "_metric", ",", "iter_limit", "=", "_iter_limit", ",", "top_k", "=", "top_k", "\n", ")", "\n", "if", "isinstance", "(", "filepaths", ",", "(", "str", ",", "Path", ")", ")", ":", "\n", "                ", "filepaths", "=", "[", "filepaths", "]", "\n", "best_vals", "=", "[", "best_vals", "]", "\n", "", "data", "[", "\"criterion\"", "]", ".", "extend", "(", "[", "criterion", "]", "*", "len", "(", "filepaths", ")", ")", "\n", "data", "[", "\"iter_limit\"", "]", ".", "extend", "(", "[", "str", "(", "_iter_limit", ")", "]", "*", "len", "(", "filepaths", ")", ")", "\n", "data", "[", "\"filepath\"", "]", ".", "extend", "(", "filepaths", ")", "\n", "data", "[", "\"criterion_val\"", "]", ".", "extend", "(", "best_vals", ")", "\n", "\n", "", "data", "=", "pd", ".", "DataFrame", "(", "data", ")", "\n", "print", "(", "tabulate", "(", "data", ",", "headers", "=", "data", ".", "columns", ")", ")", "\n", "\n", "filepaths_to_keep", "=", "set", "(", "data", "[", "\"filepath\"", "]", ".", "tolist", "(", ")", ")", "|", "{", "\n", "os", ".", "path", ".", "join", "(", "exp_path", ",", "\"model_final.pth\"", ")", "\n", "}", "\n", "all_model_paths", "=", "{", "\n", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "exp_path", ",", "x", ")", ")", "\n", "for", "x", "in", "os", ".", "listdir", "(", "exp_path", ")", "\n", "if", "x", ".", "endswith", "(", "\".pth\"", ")", "\n", "}", "\n", "remove_files", "=", "all_model_paths", "-", "filepaths_to_keep", "\n", "\n", "print", "(", "\n", "\"Found {}/{} files to remove from {}:\\n\\t{}\"", ".", "format", "(", "\n", "len", "(", "remove_files", ")", ",", "len", "(", "all_model_paths", ")", ",", "exp_path", ",", "\"\\n\\t\"", ".", "join", "(", "remove_files", ")", "\n", ")", "\n", ")", "\n", "if", "interactive", ":", "\n", "            ", "if", "remove", ":", "\n", "                ", "key", "=", "input", "(", "\n", "\"Remove {}/{} files? (y|[n]) \"", ".", "format", "(", "len", "(", "remove_files", ")", ",", "len", "(", "all_model_paths", ")", ")", "\n", ")", "\n", "if", "key", "not", "in", "[", "\"y\"", "]", ":", "\n", "                    ", "sys", ".", "exit", "(", "0", ")", "\n", "", "", "else", ":", "\n", "                ", "key", "=", "input", "(", "\"Press any key to continue\"", ")", "\n", "\n", "", "", "if", "remove", ":", "\n", "            ", "for", "fp", "in", "remove_files", ":", "\n", "                ", "os", ".", "remove", "(", "fp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.clean_results.main": [[115, 135], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "clean_results.clean_results"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tools.clean_results.clean_results"], ["", "", "", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\"Clean out results folder\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--dir\"", ",", "help", "=", "\"Results directory to recursively search\"", ",", "required", "=", "True", ",", "type", "=", "str", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--top_k\"", ",", "help", "=", "\"Top k weights to store\"", ",", "required", "=", "True", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"--iter_limit\"", ",", "help", "=", "\"Iteration limits\"", ",", "default", "=", "None", ",", "nargs", "=", "\"*\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--metrics\"", ",", "help", "=", "\"Metrics to use\"", ",", "default", "=", "None", ",", "nargs", "=", "\"*\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--interactive\"", ",", "help", "=", "\"Run interactively\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--remove\"", ",", "help", "=", "\"Remove weights files\"", ",", "action", "=", "\"store_true\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "clean_results", "(", "\n", "args", ".", "dir", ",", "\n", "args", ".", "top_k", ",", "\n", "args", ".", "metrics", ",", "\n", "iter_limit", "=", "args", ".", "iter_limit", ",", "\n", "interactive", "=", "args", ".", "interactive", ",", "\n", "remove", "=", "args", ".", "remove", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.train_net.setup": [[24, 49], ["meddlr.config.get_cfg", "meddlr.config.get_cfg.merge_from_file", "meddlr.config.get_cfg.merge_from_list", "meddlr.config.get_cfg.freeze", "meddlr.engine.default_setup", "meddlr.utils.env.supports_wandb", "meddlr.utils.env.get_path_manager().get_local_path", "ValueError", "meddlr.engine.defaults.init_wandb_run", "meddlr.utils.env.get_path_manager"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.merge_from_list", "home.repos.pwc.inspect_result.ad12_meddlr.config.config.CfgNode.freeze", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.default_setup", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.supports_wandb", "home.repos.pwc.inspect_result.ad12_meddlr.engine.defaults.init_wandb_run", "home.repos.pwc.inspect_result.ad12_meddlr.utils.env.get_path_manager"], ["def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "env", ".", "get_path_manager", "(", ")", ".", "get_local_path", "(", "args", ".", "config_file", ")", ")", "\n", "opts", "=", "args", ".", "opts", "\n", "if", "opts", "and", "opts", "[", "0", "]", "==", "\"--\"", ":", "\n", "        ", "opts", "=", "opts", "[", "1", ":", "]", "\n", "", "cfg", ".", "merge_from_list", "(", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "\n", "if", "not", "cfg", ".", "OUTPUT_DIR", ":", "\n", "        ", "raise", "ValueError", "(", "\"OUTPUT_DIR not specified\"", ")", "\n", "\n", "", "default_setup", "(", "cfg", ",", "args", ")", "\n", "\n", "# TODO: Change resume=args.resume once functionality is specified.", "\n", "# Currently resuming with the same experiment id overwrites previous data.", "\n", "# So for now, even if you are resuming your experiment, it will be logged", "\n", "# as a separate run in W&B.", "\n", "if", "env", ".", "supports_wandb", "(", ")", ":", "\n", "        ", "init_wandb_run", "(", "cfg", ",", "resume", "=", "False", ",", "job_type", "=", "\"training\"", ",", "sync_tensorboard", "=", "True", ")", "\n", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tools.train_net.main": [[51, 60], ["train_net.setup", "meddlr.engine.DefaultTrainer", "meddlr.engine.DefaultTrainer.resume_or_load", "meddlr.engine.DefaultTrainer.train", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tools.train_net.setup", "home.repos.pwc.inspect_result.ad12_meddlr.engine.trainer.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.ad12_meddlr.engine.train_loop.TrainerBase.train"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Evaluation is not yet implemented\"", ")", "\n", "\n", "", "trainer", "=", "DefaultTrainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ",", "restart_iter", "=", "args", ".", "restart_iter", ")", "\n", "return", "trainer", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.source.conf.get_version": [[19, 27], ["os.path.join", "open().readlines", "[].strip().strip", "os.path.abspath", "os.path.dirname", "open", "l.strip", "[].strip", "l.startswith", "version_line.split"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.data.data_utils.HDF5Manager.open"], ["def", "get_version", "(", ")", ":", "\n", "    ", "init_py_path", "=", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ",", "\"../../meddlr\"", ",", "\"__init__.py\"", "\n", ")", "\n", "init_py", "=", "open", "(", "init_py_path", ",", "\"r\"", ")", ".", "readlines", "(", ")", "\n", "version_line", "=", "[", "l", ".", "strip", "(", ")", "for", "l", "in", "init_py", "if", "l", ".", "startswith", "(", "\"__version__\"", ")", "]", "[", "0", "]", "# noqa: E741", "\n", "version", "=", "version_line", ".", "split", "(", "\"=\"", ")", "[", "-", "1", "]", ".", "strip", "(", ")", ".", "strip", "(", "\"'\\\"\"", ")", "\n", "return", "version", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.test_reproducibility.test_eval_reproducibility": [[11, 52], ["unittest.skipIf", "meddlr.config.get_cfg", "meddlr.data.build.build_data_loaders_per_scan", "torch.cat", "meddlr.data.build.build_data_loaders_per_scan", "torch.cat", "torch.allclose", "loaders[].items", "loaders2[].items", "os.environ.get().lower", "enumerate", "enumerate", "kspace_data.append", "meddlr.ops.complex.get_mask", "kspace_data2.append", "os.environ.get"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.config.config.get_cfg", "home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_data_loaders_per_scan", "home.repos.pwc.inspect_result.ad12_meddlr.data.build.build_data_loaders_per_scan", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.ops.complex.get_mask", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get"], ["@", "unittest", ".", "skipIf", "(", "\n", "os", ".", "environ", ".", "get", "(", "\"MEDDLR_TEST_REPRO\"", ",", "\"\"", ")", ".", "lower", "(", ")", "!=", "\"true\"", ",", "\"Repro eval is time-consuming\"", "\n", ")", "\n", "def", "test_eval_reproducibility", "(", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "4", "\n", "cfg", ".", "SOLVER", ".", "TEST_BATCH_SIZE", "=", "16", "\n", "dataset_name", "=", "\"mridata_knee_2019_test\"", "\n", "loaders", "=", "build_data_loaders_per_scan", "(", "cfg", ",", "dataset_name", ",", "(", "6", ",", ")", ")", "\n", "kspace_data", "=", "[", "]", "\n", "mask", "=", "None", "\n", "for", "acc", "in", "loaders", ":", "\n", "        ", "for", "scan_name", ",", "loader", "in", "loaders", "[", "acc", "]", ".", "items", "(", ")", ":", "\n", "            ", "scan_name1", "=", "scan_name", "\n", "for", "idx", ",", "inputs", "in", "enumerate", "(", "loader", ")", ":", "# noqa", "\n", "                ", "kspace", "=", "inputs", "[", "\"kspace\"", "]", "\n", "kspace_data", ".", "append", "(", "kspace", ")", "\n", "c_mask", "=", "cplx", ".", "get_mask", "(", "kspace", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                    ", "pass", "\n", "# assert torch.all(mask == c_mask)", "\n", "", "else", ":", "\n", "                    ", "mask", "=", "c_mask", "\n", "", "", "break", "\n", "", "break", "\n", "", "kspace1", "=", "torch", ".", "cat", "(", "kspace_data", ",", "dim", "=", "0", ")", "\n", "\n", "loaders2", "=", "build_data_loaders_per_scan", "(", "cfg", ",", "dataset_name", ",", "(", "6", ",", ")", ")", "\n", "kspace_data2", "=", "[", "]", "\n", "for", "acc", "in", "loaders", ":", "\n", "        ", "for", "scan_name", ",", "loader", "in", "loaders2", "[", "acc", "]", ".", "items", "(", ")", ":", "\n", "            ", "scan_name2", "=", "scan_name", "\n", "for", "idx", ",", "inputs", "in", "enumerate", "(", "loader", ")", ":", "# noqa", "\n", "                ", "kspace", "=", "inputs", "[", "\"kspace\"", "]", "\n", "kspace_data2", ".", "append", "(", "kspace", ")", "\n", "", "break", "\n", "", "break", "\n", "", "kspace2", "=", "torch", ".", "cat", "(", "kspace_data2", ",", "dim", "=", "0", ")", "\n", "\n", "assert", "scan_name1", "==", "scan_name2", "\n", "assert", "torch", ".", "allclose", "(", "kspace1", ",", "kspace2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.test_experiments.TestMRIDataExperiments.test_subject_seeds": [[12, 67], ["print", "zip", "enumerate", "enumerate", "meddlr.data.build.get_recon_dataset_dicts", "zip", "set().issuperset", "len", "len", "scans.items", "set", "set", "scans.items", "len", "print", "set", "set", "sorted"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.build.get_recon_dataset_dicts", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.Metadata.set"], ["def", "test_subject_seeds", "(", "self", ")", ":", "\n", "        ", "\"\"\"Verify randomness of seeds for selecting subjects in mridata.org dataset.\n\n        Because the dataset is so small, it is possible that two different\n        random seeds can result in the same scans being selected.\n        \"\"\"", "\n", "dataset_sizes", "=", "[", "1", ",", "2", ",", "5", ",", "10", ",", "14", "]", "\n", "overlap_thresholds", "=", "[", "0", ",", "1", ",", "3", ",", "8", ",", "None", "]", "\n", "\n", "# Find 3 seeds that work relatively well", "\n", "# 1000 is fixed as it is used by most of our runs.", "\n", "scans", "=", "{", "}", "\n", "seeds", "=", "[", "1000", ",", "2000", ",", "3000", ",", "9860", ",", "9970", "]", "# last two seeds found by random search", "\n", "print", "(", "seeds", ")", "\n", "for", "num_total", "in", "dataset_sizes", ":", "\n", "            ", "for", "seed", "in", "seeds", ":", "\n", "                ", "dataset_dicts", "=", "get_recon_dataset_dicts", "(", "\n", "(", "self", ".", "TRAIN_DATASET", ",", ")", ",", "num_scans_total", "=", "num_total", ",", "seed", "=", "seed", "\n", ")", "\n", "assert", "len", "(", "dataset_dicts", ")", "==", "num_total", "\n", "selected_scans", "=", "[", "dd", "[", "\"file_name\"", "]", "for", "dd", "in", "dataset_dicts", "]", "\n", "assert", "len", "(", "set", "(", "selected_scans", ")", ")", "==", "num_total", "\n", "scans", "[", "(", "num_total", ",", "seed", ")", "]", "=", "selected_scans", "\n", "\n", "# For a fixed seed, set of scans must be supersets", "\n", "", "", "for", "seed", "in", "seeds", ":", "\n", "            ", "seed_scans", "=", "{", "\n", "num_total", ":", "_scans", "for", "(", "num_total", ",", "_seed", ")", ",", "_scans", "in", "scans", ".", "items", "(", ")", "if", "seed", "==", "_seed", "\n", "}", "\n", "ordered_scans", "=", "[", "seed_scans", "[", "x", "]", "for", "x", "in", "dataset_sizes", "]", "\n", "for", "idx", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "zip", "(", "ordered_scans", "[", ":", "-", "1", "]", ",", "ordered_scans", "[", "1", ":", "]", ")", ")", ":", "\n", "                ", "assert", "set", "(", "y", ")", ".", "issuperset", "(", "set", "(", "x", ")", ")", ",", "(", "\n", "f\"Case num_total={dataset_sizes[idx+1]} is not superset of \"", "\n", "f\"num_total={dataset_sizes[idx]} for seed {seed}\"", "\n", ")", "\n", "\n", "# All combinations for 1 & 2 subject cases must be different.", "\n", "", "", "for", "num_total", ",", "overlap_thresh", "in", "zip", "(", "dataset_sizes", ",", "overlap_thresholds", ")", ":", "\n", "            ", "if", "overlap_thresh", "is", "None", ":", "\n", "                ", "continue", "\n", "", "scan_names", "=", "[", "\n", "(", "_seed", ",", "set", "(", "_scans", ")", ")", "\n", "for", "(", "_num_total", ",", "_seed", ")", ",", "_scans", "in", "scans", ".", "items", "(", ")", "\n", "if", "_num_total", "==", "num_total", "\n", "]", "\n", "for", "idx", ",", "(", "seed1", ",", "scans1", ")", "in", "enumerate", "(", "scan_names", ")", ":", "\n", "                ", "for", "seed2", ",", "scans2", "in", "scan_names", "[", "idx", "+", "1", ":", "]", ":", "\n", "                    ", "overlap_scans", "=", "scans1", "&", "scans2", "\n", "num_same", "=", "len", "(", "overlap_scans", ")", "\n", "assert", "(", "\n", "num_same", "<=", "overlap_thresh", "\n", ")", ",", "\"Seeds {} and {} have the same \"", "\"{}/{} scan(s):\\n{}\"", ".", "format", "(", "\n", "seed1", ",", "seed2", ",", "num_same", ",", "num_total", ",", "\"\\n\"", ".", "join", "(", "sorted", "(", "overlap_scans", ")", ")", "\n", ")", "\n", "print", "(", "f\"{seed1} - {seed2}: {num_same}/{num_total}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.__init__": [[58, 64], ["None"], "methods", ["None"], [")", "->", "Union", "[", "bool", ",", "List", "[", "str", "]", "]", ":", "\n", "    "]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.add_children": [[65, 71], ["isinstance", "util.MarkdownNode.children.append"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.remove_children": [[72, 78], ["isinstance"], "methods", ["None"], ["\n", "keyword", "=", "\"# DEPENDENCY:\"", "\n", "\n", "if", "isinstance", "(", "cfg_file_or_lines", ",", "(", "str", ",", "os", ".", "PathLike", ",", "pathlib", ".", "Path", ")", ")", ":", "\n", "        ", "with", "open", "(", "cfg_file_or_lines", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "lines", "=", "f", ".", "readlines", "(", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict": [[79, 88], ["util.MarkdownNode._flattened_dict_repr", "c.to_dict"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode._flattened_dict_repr", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.to_dict"], ["", "", "else", ":", "\n", "        ", "lines", "=", "cfg_file_or_lines", "\n", "", "lines", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "lines", "if", "keyword", "in", "line", "]", "\n", "dependencies", "=", "[", "\n", "dep", ".", "strip", "(", ")", "for", "line", "in", "lines", "for", "dep", "in", "line", ".", "split", "(", "keyword", ")", "[", "-", "1", "]", ".", "strip", "(", ")", ".", "split", "(", "\";\"", ")", "\n", "]", "\n", "\n", "missing_deps", "=", "[", "]", "\n", "for", "dep", "in", "dependencies", ":", "\n", "        ", "if", "not", "env", ".", "is_package_installed", "(", "dep", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode._flattened_dict_repr": [[89, 99], ["out.update", "c._flattened_dict_repr().items", "c._flattened_dict_repr"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.evaluation.evaluator.DatasetEvaluators.items", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode._flattened_dict_repr"], ["            ", "missing_deps", ".", "append", "(", "dep", ")", "\n", "\n", "", "", "return", "missing_deps", "if", "return_failed_deps", "else", "len", "(", "missing_deps", ")", "==", "0", "\n", "\n", "\n", "", "def", "_stringify_value", "(", "value", ",", "depth", "=", "0", ")", "->", "str", ":", "\n", "    "]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__init__": [[129, 132], ["None"], "methods", ["None"], [")", "\n", "if", "isinstance", "(", "value", ",", "tuple", ")", ":", "\n", "            ", "value_str", "=", "f\"\\({value_str},\\)\"", "if", "len", "(", "value", ")", ">", "0", "else", "\"\\(\\)\"", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__enter__": [[133, 137], ["os.environ.get", "os.environ.update", "str"], "methods", ["home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.MetadataCatalog.get", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["            ", "value_str", "=", "f\"[{value_str}]\"", "\n", "\n", "", "", "return", "value_str", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.cplx_tensor_support.__exit__": [[138, 143], ["os.environ.pop"], "methods", ["None"], ["", "def", "_to_str", "(", "all_vals", ",", "value", ")", ":", "\n", "    ", "return", "[", "\n", "str", "(", "v", ")", "\n", "if", "not", "isinstance", "(", "v", ",", "str", ")", "or", "isinstance", "(", "ov", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", "\n", "else", "f\"'\\\"'\\\"'{v}'\\\"'\\\"'\"", "\n", "for", "v", ",", "ov", "in", "zip", "(", "all_vals", ",", "value", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.temp_env": [[18, 44], ["functools.wraps", "functools.wraps", "dict", "dict", "func", "os.environ.clear", "os.environ.update", "func", "os.environ.clear", "os.environ.update", "inspect.signature"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.test_metric.MockMetric.func", "home.repos.pwc.inspect_result.ad12_meddlr.data.catalog.DatasetCatalog.clear", "home.repos.pwc.inspect_result.ad12_meddlr.metrics.metric.Metric.update"], ["\n", "\n", "def", "_dict_to_list", "(", "d", ")", ":", "\n", "        ", "return", "[", "x", "for", "key_value", "in", "d", ".", "items", "(", ")", "for", "x", "in", "key_value", "]", "\n", "\n", "", "configs", "=", "itertools", ".", "product", "(", "*", "list", "(", "params", ".", "values", "(", ")", ")", ")", "\n", "configs", "=", "[", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "params", ".", "keys", "(", ")", ",", "cfg", ")", "}", "for", "cfg", "in", "configs", "]", "\n", "if", "fixed", "is", "not", "None", ":", "\n", "        ", "for", "c", "in", "configs", ":", "\n", "            ", "c", ".", "update", "(", "fixed", ")", "\n", "", "", "if", "base_cfg", ":", "\n", "        ", "configs", "=", "[", "\n", "base_cfg", ".", "clone", "(", ")", ".", "defrost", "(", ")", ".", "merge_from_list", "(", "_dict_to_list", "(", "c", ")", ")", ".", "freeze", "(", ")", "for", "c", "in", "configs", "\n", "]", "\n", "", "return", "configs", "\n", "\n", "\n", "", "def", "stringify", "(", "cfg", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.get_cfg_path": [[46, 53], ["os.path.join.split", "os.path.join", "os.path.dirname", "os.path.exists", "FileNotFoundError"], "function", ["None"], ["\n", "cfg", "=", "{", "k", ":", "f\"'{v}'\"", "if", "isinstance", "(", "v", ",", "str", ")", "else", "v", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", "}", "\n", "cfg", "=", "{", "k", ":", "_stringify_value", "(", "v", ")", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", "}", "\n", "return", "\" \"", ".", "join", "(", "f'{k} \"{v}\"'", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", ")", "\n"]], "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.parse_markdown": [[101, 126], ["util.MarkdownNode", "len", "lines[].strip", "[].strip", "len", "re.match", "MarkdownNode.content.append", "util.MarkdownNode", "util.parse_markdown", "util.MarkdownNode.add_children", "len", "[].strip", "lines[].strip.split", "lines[].strip.split"], "function", ["home.repos.pwc.inspect_result.ad12_meddlr.tests.util.parse_markdown", "home.repos.pwc.inspect_result.ad12_meddlr.tests.util.MarkdownNode.add_children"], ["\n", "if", "not", "isinstance", "(", "value", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", ":", "\n", "        ", "return", "value", "\n", "", "if", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "        ", "keys", "=", "list", "(", "value", ".", "keys", "(", ")", ")", "\n", "values", "=", "[", "value", "[", "k", "]", "for", "k", "in", "keys", "]", "\n", "keys_str", "=", "[", "_stringify_value", "(", "k", ",", "depth", "=", "depth", "+", "1", ")", "for", "k", "in", "keys", "]", "\n", "values_str", "=", "[", "_stringify_value", "(", "v", ",", "depth", "=", "depth", "+", "1", ")", "for", "v", "in", "values", "]", "\n", "keys_str", "=", "_to_str", "(", "keys_str", ",", "keys", ")", "\n", "values_str", "=", "_to_str", "(", "values_str", ",", "values", ")", "\n", "val_dict_str", "=", "{", "f\"{k}:{v}\"", "for", "k", ",", "v", "in", "zip", "(", "keys_str", ",", "values_str", ")", "}", "\n", "value_str", "=", "\"\\{\"", "\n", "value_str", "+=", "\",\"", ".", "join", "(", "val_dict_str", ")", "\n", "value_str", "+=", "\"\\}\"", "\n", "", "else", ":", "\n", "        ", "all_vals", "=", "[", "_stringify_value", "(", "v", ",", "depth", "=", "depth", "+", "1", ")", "for", "v", "in", "value", "]", "\n", "value_str", "=", "\",\"", ".", "join", "(", "\n", "str", "(", "v", ")", "\n", "if", "not", "isinstance", "(", "v", ",", "str", ")", "or", "isinstance", "(", "ov", ",", "(", "set", ",", "tuple", ",", "list", ",", "dict", ")", ")", "\n"]]}