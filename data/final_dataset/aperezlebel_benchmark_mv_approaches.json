{"home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whosmissing.missing_pt_imputation": [[19, 39], ["print", "df.reset_index.groupby", "df.groupby.agg", "df.reset_index.reset_index", "print", "df.reset_index.groupby", "list", "t_methods.sort", "print", "df[].isna"], "function", ["None"], ["def", "missing_pt_imputation", "(", "df", ")", ":", "\n", "    ", "idx", "=", "df", ".", "loc", "[", "df", "[", "'tuning_PT'", "]", ".", "isna", "(", ")", ",", "'tuning_PT'", "]", ".", "index", "\n", "\n", "df", "=", "df", ".", "loc", "[", "idx", "]", "\n", "\n", "print", "(", "df", ")", "\n", "\n", "dfgb", "=", "df", ".", "groupby", "(", "by", "=", "[", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "df", "=", "dfgb", ".", "agg", "(", "{", "'imputation_PT'", ":", "'first'", "}", ")", "\n", "df", "=", "df", ".", "reset_index", "(", ")", "\n", "\n", "print", "(", "df", ")", "\n", "\n", "for", "id", ",", "subdf", "in", "df", ".", "groupby", "(", "by", "=", "[", "'db'", ",", "'task'", "]", ")", ":", "\n", "        ", "methods", "=", "list", "(", "subdf", "[", "'method'", "]", ")", "\n", "t_methods", "=", "[", "translate_methods", "[", "m", "]", "for", "m", "in", "methods", "]", "\n", "t_methods", ".", "sort", "(", ")", "\n", "db", "=", "id", "[", "0", "]", "\n", "task", "=", "id", "[", "1", "]", "\n", "print", "(", "f'{db}/{task}: {methods}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whosmissing.missing_scores": [[41, 61], ["prediction.df_utils.aggregate", "prediction.df_utils.aggregate.groupby", "list", "print", "len", "print"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate"], ["", "", "def", "missing_scores", "(", "df", ",", "expected_methods", ")", ":", "\n", "    ", "df", "=", "aggregate", "(", "df", ",", "'tuning_PT'", ")", "\n", "\n", "for", "id", ",", "subdf", "in", "df", ".", "groupby", "(", "by", "=", "[", "'size'", ",", "'db'", ",", "'task'", "]", ")", ":", "\n", "        ", "methods", "=", "list", "(", "subdf", "[", "'method'", "]", ")", "\n", "size", "=", "id", "[", "0", "]", "\n", "db", "=", "id", "[", "1", "]", "\n", "task", "=", "id", "[", "2", "]", "\n", "\n", "for", "m", "in", "expected_methods", ":", "\n", "            ", "if", "m", "not", "in", "methods", ":", "\n", "                ", "print", "(", "f'{size}/{db}/{task}: {m} missing'", ")", "\n", "\n", "", "else", ":", "\n", "                ", "n_t", "=", "subdf", ".", "loc", "[", "subdf", "[", "'method'", "]", "==", "m", ",", "'n_trials'", "]", "\n", "assert", "len", "(", "n_t", ")", "==", "1", "\n", "n_t", "=", "n_t", ".", "iloc", "[", "0", "]", "\n", "\n", "if", "n_t", "!=", "5", ":", "\n", "                    ", "print", "(", "f'{size}/{db}/{task}: {m} missing trial: {n_t}/5'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whosmissing.run": [[63, 81], ["pandas.read_csv", "whosmissing.missing_scores"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whosmissing.missing_scores"], ["", "", "", "", "", "def", "run", "(", "args", ")", ":", "\n", "    ", "df", "=", "pd", ".", "read_csv", "(", "'scores/scores.csv'", ",", "index_col", "=", "0", ")", "\n", "\n", "methods", "=", "[", "\n", "'MIA'", ",", "\n", "'Mean'", ",", "\n", "'Mean+mask'", ",", "\n", "'Med'", ",", "\n", "'Med+mask'", ",", "\n", "'Iter'", ",", "\n", "'Iter+mask'", ",", "\n", "'KNN'", ",", "\n", "'KNN+mask'", ",", "\n", "'Linear+Iter'", ",", "\n", "'Linear+Iter+mask'", ",", "\n", "]", "\n", "\n", "missing_scores", "(", "df", ",", "expected_methods", "=", "methods", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode._df_type_handler": [[11, 42], ["len", "isinstance", "isinstance", "function", "isinstance", "function", "tuple", "df_seq[].keys", "encode._df_type_handler", "dict", "list", "list", "dict", "function", "range", "range", "enumerate", "df_encoded.values", "mv_encoded.values", "range", "[].copy", "range"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode._df_type_handler"], ["def", "_df_type_handler", "(", "function", ",", "df_seq", ",", "keys", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "keys", ",", "list", ")", ":", "\n", "        ", "keys", "=", "[", "keys", "]", "\n", "\n", "", "if", "not", "df_seq", ":", "# Empty df_seq", "\n", "        ", "return", "function", "(", "**", "kwargs", ")", "\n", "\n", "", "n_df", "=", "len", "(", "df_seq", ")", "\n", "if", "isinstance", "(", "df_seq", "[", "0", "]", ",", "dict", ")", ":", "\n", "        ", "res", "=", "tuple", "(", "[", "dict", "(", ")", "for", "k", "in", "range", "(", "n_df", ")", "]", ")", "\n", "\n", "for", "k", "in", "df_seq", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "            ", "if", "keys", "is", "None", "or", "(", "keys", "is", "not", "None", "and", "k", "in", "keys", ")", ":", "\n", "                ", "r", "=", "function", "(", "*", "(", "df_seq", "[", "i", "]", "[", "k", "]", "for", "i", "in", "range", "(", "n_df", ")", ")", ",", "**", "kwargs", ")", "\n", "for", "i", "in", "range", "(", "n_df", ")", ":", "\n", "                    ", "res", "[", "i", "]", "[", "k", "]", "=", "r", "[", "i", "]", "\n", "", "", "else", ":", "\n", "                ", "for", "i", "in", "range", "(", "n_df", ")", ":", "\n", "                    ", "res", "[", "i", "]", "[", "k", "]", "=", "df_seq", "[", "i", "]", "[", "k", "]", ".", "copy", "(", ")", "\n", "\n", "", "", "", "return", "res", "\n", "\n", "", "if", "isinstance", "(", "df_seq", "[", "0", "]", ",", "list", ")", ":", "\n", "        ", "new_df_seq", "=", "[", "dict", "(", "enumerate", "(", "df", ")", ")", "for", "df", "in", "df_seq", "]", "\n", "df_encoded", ",", "mv_encoded", "=", "_df_type_handler", "(", "function", ",", "\n", "new_df_seq", ",", "\n", "keys", "=", "keys", ",", "\n", "**", "kwargs", ")", "\n", "return", "list", "(", "df_encoded", ".", "values", "(", ")", ")", ",", "list", "(", "mv_encoded", ".", "values", "(", ")", ")", "\n", "\n", "", "return", "function", "(", "*", "df_seq", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode.ordinal_encode": [[44, 79], ["encode._df_type_handler", "sklearn.preprocessing.OrdinalEncoder", "df_utils.fill_df", "df_utils.fill_df.astype", "sklearn.preprocessing.OrdinalEncoder.fit_transform", "df_utils.fill_df", "pandas.DataFrame", "categories.append", "print", "list", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode._df_type_handler", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df"], ["", "def", "ordinal_encode", "(", "df", ",", "mv", ",", "keys", "=", "None", ",", "order", "=", "None", ")", ":", "\n", "\n", "    ", "def", "encode", "(", "df", ",", "mv", ",", "order", "=", "None", ")", ":", "\n", "        ", "categories", "=", "'auto'", "\n", "\n", "if", "order", "is", "not", "None", ":", "\n", "            ", "categories", "=", "[", "]", "\n", "for", "feature_name", "in", "df", ".", "columns", ":", "\n", "                ", "if", "feature_name", "in", "order", ":", "\n", "                    ", "feature_order", "=", "order", "[", "feature_name", "]", "\n", "", "else", ":", "\n", "                    ", "print", "(", "\n", "f'INFO: ordinal order for {feature_name} not found. '", "\n", "f'Derived from unique values found.'", ")", "\n", "feature_order", "=", "list", "(", "np", ".", "unique", "(", "df", "[", "feature_name", "]", ".", "values", ")", ")", "\n", "", "categories", ".", "append", "(", "feature_order", ")", "\n", "\n", "", "", "enc", "=", "OrdinalEncoder", "(", "categories", "=", "categories", ")", "\n", "\n", "df", "=", "fill_df", "(", "df", ",", "mv", "!=", "NOT_MISSING", ",", "MV_PLACEHOLDER", ")", "\n", "\n", "# Cast to str to prevent: \"Found unknown categories ...\" error", "\n", "# which occurs when float but order file is str", "\n", "df", "=", "df", ".", "astype", "(", "str", ")", "\n", "\n", "# Fit transform the encoder", "\n", "data_encoded", "=", "enc", ".", "fit_transform", "(", "df", ")", "\n", "df", "=", "fill_df", "(", "df", ",", "mv", "!=", "NOT_MISSING", ",", "np", ".", "nan", ")", "\n", "\n", "df_encoded", "=", "pd", ".", "DataFrame", "(", "data_encoded", ",", "\n", "index", "=", "df", ".", "index", ",", "columns", "=", "df", ".", "columns", ")", "\n", "\n", "return", "df_encoded", ",", "mv", "\n", "\n", "", "return", "_df_type_handler", "(", "encode", ",", "(", "df", ",", "mv", ")", ",", "keys", ",", "order", "=", "order", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode.one_hot_encode": [[81, 120], ["encode._df_type_handler", "sklearn.preprocessing.OneHotEncoder", "df_utils.fill_df.astype", "df_utils.fill_df", "sklearn.preprocessing.OneHotEncoder.fit_transform", "df_utils.fill_df", "list", "pandas.Series", "enumerate", "pandas.DataFrame", "pandas.DataFrame", "pandas.Series", "sklearn.preprocessing.OneHotEncoder.get_feature_names", "list", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode._df_type_handler", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df"], ["", "def", "one_hot_encode", "(", "df", ",", "mv", ",", "types", ",", "parent", ",", "keys", "=", "None", ")", ":", "\n", "\n", "    ", "def", "encode", "(", "df", ",", "mv", ",", "types", ",", "parent", ")", ":", "\n", "        ", "enc", "=", "OneHotEncoder", "(", "sparse", "=", "False", ")", "\n", "\n", "# Cast to str to prevent: \"argument must be a string or number\" error", "\n", "# which occurs when mixed types floats and str", "\n", "df", "=", "df", ".", "astype", "(", "str", ")", "\n", "\n", "# Fill missing values with a placeholder", "\n", "df", "=", "fill_df", "(", "df", ",", "mv", "!=", "NOT_MISSING", ",", "MV_PLACEHOLDER", ")", "\n", "\n", "# Fit transform the encoder", "\n", "data_encoded", "=", "enc", ".", "fit_transform", "(", "df", ")", "\n", "\n", "df", "=", "fill_df", "(", "df", ",", "mv", "!=", "NOT_MISSING", ",", "np", ".", "nan", ")", "\n", "\n", "feature_names", "=", "list", "(", "enc", ".", "get_feature_names", "(", "list", "(", "df", ".", "columns", ")", ")", ")", "\n", "\n", "parent", "=", "pd", ".", "Series", "(", ")", "\n", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "df", ".", "columns", ")", ":", "\n", "            ", "for", "suffix", "in", "enc", ".", "categories_", "[", "i", "]", ":", "\n", "                ", "parent", "[", "f'{c}_{suffix}'", "]", "=", "c", "\n", "\n", "", "", "df_encoded", "=", "pd", ".", "DataFrame", "(", "data_encoded", ",", "\n", "index", "=", "df", ".", "index", ",", "\n", "columns", "=", "feature_names", "\n", ")", "\n", "\n", "mv_encoded", "=", "pd", ".", "DataFrame", "(", "NOT_MISSING", "*", "np", ".", "ones", "(", "data_encoded", ".", "shape", ")", ",", "\n", "index", "=", "df", ".", "index", ",", "\n", "columns", "=", "feature_names", ")", "\n", "\n", "types_encoded", "=", "pd", ".", "Series", "(", "BINARY", ",", "index", "=", "feature_names", ")", "\n", "\n", "return", "df_encoded", ",", "mv_encoded", ",", "types_encoded", ",", "parent", "\n", "\n", "", "return", "_df_type_handler", "(", "encode", ",", "(", "df", ",", "mv", ",", "types", ",", "parent", ")", ",", "keys", "=", "keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode.date_encode": [[122, 168], ["encode._df_type_handler", "df_utils.fill_df", "dict", "pandas.DataFrame", "pandas.Series", "pandas.to_datetime", "numpy.datetime64", "numpy.timedelta64", "dict", "dict", "pandas.Series", "pandas.DataFrame", "pandas.DataFrame", "pandas.Series", "pd.to_datetime.min", "numpy.subtract", "pandas.to_datetime"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode._df_type_handler", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df"], ["", "def", "date_encode", "(", "df", ",", "mv", ",", "types", ",", "parent", ",", "keys", "=", "None", ",", "method", "=", "'timestamp'", ",", "dayfirst", "=", "False", ")", ":", "\n", "\n", "    ", "def", "encode", "(", "df", ",", "mv", ",", "types", ",", "parent", ",", "method", "=", "'timestamp'", ",", "dayfirst", "=", "False", ")", ":", "\n", "        ", "df", "=", "fill_df", "(", "df", ",", "mv", "!=", "NOT_MISSING", ",", "np", ".", "nan", ")", "\n", "\n", "if", "method", "==", "'timestamp'", ":", "\n", "            ", "data", "=", "dict", "(", ")", "\n", "\n", "for", "feature_name", "in", "df", ".", "columns", ":", "\n", "                ", "dt_series", "=", "pd", ".", "to_datetime", "(", "df", "[", "feature_name", "]", ",", "dayfirst", "=", "dayfirst", ")", "\n", "dt_min", "=", "np", ".", "datetime64", "(", "dt_series", ".", "min", "(", ")", ")", "\n", "tdt", "=", "np", ".", "timedelta64", "(", "1", ",", "'D'", ")", "\n", "data", "[", "feature_name", "]", "=", "np", ".", "subtract", "(", "dt_series", ".", "values", ",", "dt_min", ")", "/", "tdt", "\n", "\n", "", "df_encoded", "=", "pd", ".", "DataFrame", "(", "data", ",", "index", "=", "df", ".", "index", ")", "\n", "mv_encoded", "=", "mv", "\n", "types_encoded", "=", "pd", ".", "Series", "(", "CONTINUE_I", ",", "index", "=", "df_encoded", ".", "columns", ")", "\n", "\n", "", "elif", "method", "==", "'explode'", ":", "\n", "            ", "df_data", "=", "dict", "(", ")", "\n", "mv_data", "=", "dict", "(", ")", "\n", "parent", "=", "pd", ".", "Series", "(", ")", "\n", "\n", "for", "feature_name", "in", "df", ".", "columns", ":", "\n", "                ", "dt", "=", "pd", ".", "to_datetime", "(", "df", "[", "feature_name", "]", ",", "dayfirst", "=", "dayfirst", ")", ".", "dt", "\n", "\n", "df_data", "[", "f'{feature_name}_year'", "]", "=", "dt", ".", "year", "\n", "df_data", "[", "f'{feature_name}_month'", "]", "=", "dt", ".", "month", "\n", "df_data", "[", "f'{feature_name}_day'", "]", "=", "dt", ".", "day", "\n", "\n", "mv_data", "[", "f'{feature_name}_year'", "]", "=", "mv", "[", "feature_name", "]", "\n", "mv_data", "[", "f'{feature_name}_month'", "]", "=", "mv", "[", "feature_name", "]", "\n", "mv_data", "[", "f'{feature_name}_day'", "]", "=", "mv", "[", "feature_name", "]", "\n", "\n", "parent", "[", "f'{feature_name}_year'", "]", "=", "feature_name", "\n", "parent", "[", "f'{feature_name}_month'", "]", "=", "feature_name", "\n", "parent", "[", "f'{feature_name}_day'", "]", "=", "feature_name", "\n", "\n", "", "df_encoded", "=", "pd", ".", "DataFrame", "(", "df_data", ",", "index", "=", "df", ".", "index", ")", "\n", "mv_encoded", "=", "pd", ".", "DataFrame", "(", "mv_data", ",", "index", "=", "df", ".", "index", ")", "\n", "types_encoded", "=", "pd", ".", "Series", "(", "CONTINUE_I", ",", "index", "=", "df_encoded", ".", "columns", ")", "\n", "\n", "", "return", "df_encoded", ",", "mv_encoded", ",", "types_encoded", ",", "parent", "\n", "\n", "", "return", "_df_type_handler", "(", "encode", ",", "(", "df", ",", "mv", ",", "types", ",", "parent", ")", ",", "keys", "=", "keys", ",", "method", "=", "method", ",", "\n", "dayfirst", "=", "dayfirst", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.dump_ids.run": [[9, 46], ["argparse.Namespace", "prediction.run", "joblib.Parallel", "str", "joblib.delayed", "itertools.product", "range"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.__init__.run"], ["def", "run", "(", "args", ")", ":", "\n", "    ", "tasks", "=", "[", "\n", "'TB/death_pvals'", ",", "\n", "'TB/platelet_pvals'", ",", "\n", "'TB/hemo'", ",", "\n", "'TB/hemo_pvals'", ",", "\n", "'TB/acid'", ",", "\n", "'TB/septic_pvals'", ",", "\n", "'UKBB/breast_25'", ",", "\n", "'UKBB/breast_pvals'", ",", "\n", "'UKBB/skin_pvals'", ",", "\n", "'UKBB/parkinson_pvals'", ",", "\n", "'UKBB/fluid_pvals'", ",", "\n", "'MIMIC/septic_pvals'", ",", "\n", "'MIMIC/hemo_pvals'", ",", "\n", "'NHIS/income_pvals'", ",", "\n", "]", "\n", "\n", "def", "run_one", "(", "task", ",", "T", ")", ":", "\n", "        ", "argv", "=", "{", "\n", "'action'", ":", "'prediction'", ",", "\n", "'task_name'", ":", "task", ",", "\n", "'strategy_name'", ":", "'0'", ",", "\n", "'T'", ":", "str", "(", "T", ")", ",", "\n", "'RS'", ":", "'0'", ",", "\n", "'dump_idx_only'", ":", "True", ",", "\n", "'n_top_pvals'", ":", "100", ",", "\n", "}", "\n", "\n", "# Only one trial for task having features manually selected (not _pvals)", "\n", "if", "'_pvals'", "not", "in", "task", "and", "T", "!=", "0", ":", "\n", "            ", "return", "\n", "\n", "", "args", "=", "Namespace", "(", "**", "argv", ")", "\n", "prediction", ".", "run", "(", "args", ")", "\n", "\n", "", "Parallel", "(", "n_jobs", "=", "-", "1", ")", "(", "delayed", "(", "run_one", ")", "(", "task", ",", "T", ")", "for", "task", ",", "T", "in", "product", "(", "tasks", ",", "range", "(", "5", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whatsavailable.strategies_available": [[6, 11], ["print", "enumerate", "print", "prediction.strategies.strategies.keys", "print"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], ["def", "strategies_available", "(", ")", ":", "\n", "    ", "print", "(", "'\\nModels available:'", ")", "\n", "for", "i", ",", "name", "in", "enumerate", "(", "strategies", ".", "keys", "(", ")", ")", ":", "\n", "        ", "print", "(", "f'\\t{i}: '", "+", "name", ")", "\n", "", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whatsavailable.tasks_available": [[13, 18], ["print", "prediction.tasks.tasks.keys", "print", "print"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], ["", "def", "tasks_available", "(", ")", ":", "\n", "    ", "print", "(", "'\\nTasks available:'", ")", "\n", "for", "name", "in", "tasks", ".", "keys", "(", ")", ":", "\n", "        ", "print", "(", "'\\t'", "+", "name", ")", "\n", "", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whatsavailable.run": [[20, 28], ["whatsavailable.strategies_available", "whatsavailable.tasks_available", "whatsavailable.strategies_available", "whatsavailable.tasks_available"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whatsavailable.strategies_available", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whatsavailable.tasks_available", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whatsavailable.strategies_available", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.whatsavailable.tasks_available"], ["", "def", "run", "(", "args", ")", ":", "\n", "    ", "if", "args", ".", "method", ":", "\n", "        ", "strategies_available", "(", ")", "\n", "", "if", "args", ".", "task", ":", "\n", "        ", "tasks_available", "(", ")", "\n", "", "if", "not", "args", ".", "method", "and", "not", "args", ".", "task", ":", "\n", "        ", "strategies_available", "(", ")", "\n", "tasks_available", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._ask_feature_type_df": [[15, 91], ["pandas.Series", "print", "enumerate", "input", "print", "int", "isinstance"], "function", ["None"], ["def", "_ask_feature_type_df", "(", "df", ")", ":", "\n", "    ", "\"\"\"Ask to the user the types of the feature of the data frame.\n\n    Available types:\n        0 - Categorical\n        1 - Ordinal\n        2 - Continue \u2022 real\n        3 - Continue \u2022 integer\n        4 - Date timestamp\n        5 - Date exploded\n        6 - Binary\n        -1 - Not a feature\n\n    Parameters:\n    -----------\n    df : pandas.DataFrame\n        The data frame from which to determine the feature (=columns) types.\n\n    Returns:\n    --------\n    pandas.Series\n        Series with df.columns as index and integers as values.\n\n    \"\"\"", "\n", "types", "=", "pd", ".", "Series", "(", "0", ",", "index", "=", "df", ".", "columns", ")", "\n", "\n", "print", "(", "\n", "'\\n'", "\n", "' -------------------------------------------------------\\n'", "\n", "'|Set the type of features in the data frame.            |\\n'", "\n", "'|-------------------------------------------------------|\\n'", "\n", "'|Type an integer in [-1, 6] to set a category.          |\\n'", "\n", "'|Leave empty to select default choice [bracketed].      |\\n'", "\n", "'|Type \"end\" to exit and set all unaswered to default.   |\\n'", "\n", "'--------------------------------------------------------'", "\n", ")", "\n", "\n", "for", "i", ",", "feature", "in", "enumerate", "(", "df", ".", "columns", ")", ":", "\n", "# Ask the feature type to the user", "\n", "        ", "while", "True", ":", "\n", "            ", "t", "=", "input", "(", "\n", "f'\\n\\n'", "\n", "f'Feature (ID: {i}): {feature}\\n\\n'", "\n", "f'Type? [0 - Categorical]\\n'", "\n", "f'       1 - Ordinal\\n'", "\n", "f'       2 - Continue \u2022 real\\n'", "\n", "f'       3 - Continue \u2022 integer\\n'", "\n", "f'       4 - Date timestamp\\n'", "\n", "f'       5 - Date exploded\\n'", "\n", "f'       6 - Binary\\n'", "\n", "f'      -1 - Not a feature\\n'", "\n", ")", "\n", "\n", "# By typing 'end', the unanswered are set to default", "\n", "if", "t", "==", "'end'", ":", "\n", "                ", "return", "types", "\n", "\n", "# Convert empty (default) to 0 - Categorical", "\n", "", "if", "t", "==", "''", ":", "\n", "                ", "t", "=", "0", "\n", "\n", "# Try to convert user's input to integer", "\n", "", "try", ":", "\n", "                ", "t", "=", "int", "(", "t", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "pass", "\n", "\n", "# Check if the integer is in the good range", "\n", "", "if", "isinstance", "(", "t", ",", "int", ")", "and", "t", "<=", "6", "and", "t", ">=", "-", "1", ":", "\n", "                ", "break", "# t matchs all conditions, so break the loop", "\n", "\n", "", "print", "(", "'\\nError: enter an integer in [-1, 6] or type \"end\".'", ")", "\n", "\n", "", "types", "[", "feature", "]", "=", "t", "\n", "\n", "", "return", "types", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type.ask_feature_type_helper": [[93, 145], ["database.NHIS", "database.TB", "db.df_names", "input", "features_type._ask_feature_type_df", "features_type._dump_feature_types", "locals", "input", "print", "print"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.df_names", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._ask_feature_type_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._dump_feature_types"], ["", "def", "ask_feature_type_helper", "(", ")", ":", "\n", "    ", "\"\"\"Implement helper for asking feature type to the user.\"\"\"", "\n", "NHIS", ",", "TB", "=", "database", ".", "NHIS", "(", ")", ",", "database", ".", "TB", "(", ")", "\n", "available_db_names", "=", "[", "db", ".", "acronym", "for", "db", "in", "[", "NHIS", ",", "TB", "]", "]", "\n", "\n", "while", "True", ":", "\n", "# Prevent from asking again when user failed on second input", "\n", "        ", "if", "'db_name'", "not", "in", "locals", "(", ")", ":", "\n", "            ", "db_name", "=", "input", "(", "\n", "f'\\n'", "\n", "f'Which database do you want to set the features\\' types?\\n'", "\n", "f'Available choices: {available_db_names}\\n'", "\n", "f'Type \"exit\" to end.\\n'", "\n", ")", "\n", "\n", "# Load appropiate database", "\n", "", "if", "db_name", "==", "NHIS", ".", "acronym", ":", "\n", "            ", "db", "=", "NHIS", "\n", "", "elif", "db_name", "==", "TB", ".", "acronym", ":", "\n", "            ", "db", "=", "TB", "\n", "", "elif", "db_name", "==", "'exit'", ":", "\n", "            ", "return", "\n", "", "else", ":", "\n", "            ", "print", "(", "f'\\nAnswer must be in {available_db_names}'", ")", "\n", "del", "db_name", "\n", "continue", "\n", "\n", "", "available_df_names", "=", "db", ".", "df_names", "(", ")", "\n", "\n", "df_name", "=", "input", "(", "\n", "f'\\n'", "\n", "f'Which data frame of {db_name} do you want to set the '", "\n", "f'features\\' types?\\n'", "\n", "f'Available: {available_df_names}\\n'", "\n", "f'Type \"none\" to change database.\\n'", "\n", "f'Type \"exit\" to end.\\n'", "\n", ")", "\n", "\n", "if", "df_name", "==", "'none'", ":", "\n", "            ", "del", "db_name", "\n", "continue", "\n", "\n", "", "if", "df_name", "==", "'exit'", ":", "\n", "            ", "return", "\n", "\n", "", "if", "df_name", "not", "in", "available_df_names", ":", "\n", "            ", "print", "(", "f'\\nAnswer must be in {available_df_names}'", ")", "\n", "continue", "\n", "\n", "", "df", "=", "db", "[", "df_name", "]", "\n", "types", "=", "_ask_feature_type_df", "(", "df", ")", "\n", "_dump_feature_types", "(", "types", ",", "db", ",", "df_name", ",", "anonymize", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._dump_feature_types": [[147, 186], ["os.path.basename", "os.path.splitext", "os.makedirs", "pd.Series.to_csv", "pd.Series.to_csv", "pandas.Series", "filepath.replace", "time.time", "range", "len"], "function", ["None"], ["", "", "def", "_dump_feature_types", "(", "types", ",", "db", ",", "df_name", ",", "anonymize", "=", "True", ")", ":", "\n", "    ", "\"\"\"Dump the features' types anonymizing the features' names.\n\n    Parameters:\n    -----------\n    types: pandas.Series\n        Series with features' names as index and features' types as values.\n    db : Database object\n        Used to dump results in the right folder.\n    df_name : string\n        Name or path of the data frame from which has been computed the types.\n        Used to dump the results in the right folder.\n    anonymize : bool\n        Whether to anonymize feature names or not when dumping.\n        False: features' name is dumped. True: only id is dumped.\n\n    \"\"\"", "\n", "if", "df_name", "in", "db", ".", "frame_paths", ":", "\n", "        ", "path", "=", "db", ".", "frame_paths", "[", "df_name", "]", "\n", "", "else", ":", "\n", "        ", "path", "=", "df_name", "\n", "", "filename", "=", "os", ".", "path", ".", "basename", "(", "path", ")", "\n", "basename", ",", "_", "=", "os", ".", "path", ".", "splitext", "(", "filename", ")", "\n", "dir_path", "=", "f'{METADATA_PATH}features_types/{db.acronym}/'", "\n", "\n", "# Anonymize features' names", "\n", "if", "anonymize", ":", "\n", "        ", "types", "=", "pd", ".", "Series", "(", "types", ".", "values", ",", "index", "=", "range", "(", "len", "(", "types", ".", "index", ")", ")", ")", "\n", "\n", "# Creates directories if doesn't exist", "\n", "", "os", ".", "makedirs", "(", "dir_path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# Save to csv", "\n", "filepath", "=", "dir_path", "+", "basename", "\n", "types", ".", "to_csv", "(", "f'{filepath}.csv'", ",", "header", "=", "False", ")", "\n", "\n", "# Backup all dumps in the same folder", "\n", "backup_tag", "=", "f'{filepath.replace(\"/\", \"_\")}_{time():.1f}'", "\n", "types", ".", "to_csv", "(", "f'{backup_dir}{backup_tag}.csv'", ",", "header", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._load_feature_types": [[188, 220], ["os.path.basename", "os.path.splitext", "pandas.read_csv", "pandas.Series"], "function", ["None"], ["", "def", "_load_feature_types", "(", "db", ",", "df_name", ",", "anonymized", "=", "True", ")", ":", "\n", "    ", "\"\"\"Load the features' types deanonymizing the features' names.\n\n    Parameters:\n    -----------\n    db : Database class\n        The features' database.\n    df_name : string\n        Name of the features' data frame.\n    anonymized : bool\n        Whether the features have been anonymized before being dumped\n        (i.e no feature names but only their id).\n\n    Returns:\n    --------\n    pandas.Series\n        Series with features' names as index and features' types as values.\n\n    \"\"\"", "\n", "filename", "=", "os", ".", "path", ".", "basename", "(", "db", ".", "frame_paths", "[", "df_name", "]", ")", "\n", "basename", ",", "_", "=", "os", ".", "path", ".", "splitext", "(", "filename", ")", "\n", "filepath", "=", "f'{METADATA_PATH}features_types/{db.acronym}/{basename}.csv'", "\n", "\n", "# Load types series", "\n", "types", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ",", "\n", "header", "=", "None", ",", "squeeze", "=", "True", ")", "\n", "\n", "# Deanonymize features' names", "\n", "if", "anonymized", ":", "\n", "        ", "types", "=", "pd", ".", "Series", "(", "types", ".", "values", ",", "index", "=", "db", "[", "df_name", "]", ".", "columns", ")", "\n", "\n", "", "return", "types", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.selection.run": [[26, 205], ["logger.info", "int", "int", "int", "logger.info", "prediction.tasks.tasks.get", "logger.info", "logger.info", "logger.info", "tasks.get.is_classif", "sklearn.model_selection.ShuffleSplit.split", "range", "prediction.tasks.transform.Transform", "pandas.Series", "os.makedirs", "pd.Series.to_csv", "logger.info", "tasks.get._load_y", "logger.info", "logger.info", "logger.info", "os.makedirs", "X.transpose", "pd.read_csv.to_csv", "pandas.read_csv", "logger.info", "db._load_feature_types", "functools.reduce", "zip", "pandas.Series", "os.makedirs", "pd.Series.to_csv", "logger.info", "logger.info", "sklearn.model_selection.StratifiedShuffleSplit", "logger.info", "sklearn.model_selection.ShuffleSplit", "next", "df.astype.drop", "os.path.dirname", "pandas.Series", "np.squeeze.replace", "np.squeeze.astype", "set", "np.squeeze.drop", "y.drop", "np.squeeze.to_numpy().reshape", "y_dropped.to_numpy().reshape.to_numpy().reshape", "f_callable", "float", "numpy.squeeze", "logger.info", "logger.info", "joblib.Parallel", "os.path.dirname", "numpy.transpose", "pandas.DataFrame", "df.astype.astype", "df.astype.replace", "sklearn.preprocessing.OneHotEncoder", "df.astype.fillna", "sklearn.preprocessing.OneHotEncoder.fit_transform", "list", "pandas.DataFrame", "np.squeeze.to_numpy", "y_dropped.to_numpy().reshape.to_numpy", "row.to_numpy", "sklearn.preprocessing.OneHotEncoder.get_feature_names", "L.append", "joblib.delayed", "tqdm.tqdm", "np.squeeze.isna", "list", "selection.run.pval_one_feature"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_y", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_feature_types"], ["def", "run", "(", "args", ")", ":", "\n", "    ", "\"\"\"Run the feature selection using ANOVA on the chosen task.\"\"\"", "\n", "logger", ".", "info", "(", "'Retrieving task'", ")", "\n", "RS", "=", "int", "(", "args", ".", "RS", ")", "\n", "T", "=", "int", "(", "args", ".", "T", ")", "\n", "TMAX", "=", "int", "(", "args", ".", "TMAX", ")", "\n", "logger", ".", "info", "(", "f'RS {RS} T {T} TMAX {TMAX}'", ")", "\n", "task_name", "=", "args", ".", "task_name", "\n", "task", "=", "tasks", ".", "get", "(", "task_name", ",", "n_top_pvals", "=", "None", ")", "\n", "\n", "temp_dir", "=", "f'selected/{task.meta.tag}/temp/'", "\n", "\n", "logger", ".", "info", "(", "'Retreiving db'", ")", "\n", "db", "=", "dbs", "[", "task", ".", "meta", ".", "db", "]", "\n", "\n", "logger", ".", "info", "(", "'Retrieving y'", ")", "\n", "y", "=", "task", ".", "y", "\n", "logger", ".", "info", "(", "f'y loaded with shape {y.shape}'", ")", "\n", "\n", "if", "task", ".", "is_classif", "(", ")", ":", "\n", "        ", "logger", ".", "info", "(", "'Classification, using f_classif'", ")", "\n", "f_callable", "=", "f_classif", "\n", "ss", "=", "StratifiedShuffleSplit", "(", "n_splits", "=", "TMAX", ",", "\n", "test_size", "=", "2", "/", "3", ",", "\n", "random_state", "=", "RS", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "'Regression, using f_regression'", ")", "\n", "f_callable", "=", "f_regression", "\n", "ss", "=", "ShuffleSplit", "(", "n_splits", "=", "TMAX", ",", "test_size", "=", "2", "/", "3", ",", "\n", "random_state", "=", "RS", ")", "\n", "\n", "", "index", "=", "y", ".", "index", "\n", "\n", "assert", "T", ">=", "0", "\n", "\n", "# Alter the task to select only 1/3 for selection", "\n", "split_iter", "=", "ss", ".", "split", "(", "y", ",", "y", ")", "\n", "for", "_", "in", "range", "(", "T", "+", "1", ")", ":", "\n", "        ", "keep_idx", ",", "drop_idx", "=", "next", "(", "split_iter", ")", "\n", "\n", "# Convert to index", "\n", "", "keep_index", "=", "[", "index", "[", "i", "]", "for", "i", "in", "keep_idx", "]", "\n", "drop_index", "=", "[", "index", "[", "i", "]", "for", "i", "in", "drop_idx", "]", "\n", "\n", "def", "select_idx", "(", "df", ")", ":", "\n", "        ", "\"\"\"Define the idx to keep from the database.\"\"\"", "\n", "return", "df", ".", "drop", "(", "drop_index", ",", "axis", "=", "0", ")", "\n", "\n", "", "task", ".", "meta", ".", "idx_selection", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "select_idx", ",", "\n", ")", "\n", "\n", "series", "=", "pd", ".", "Series", "(", "keep_index", ")", "\n", "dump_path", "=", "f'pvals/{task.meta.tag}/RS{RS}-T{T}-used_idx.csv'", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "dump_path", ")", ",", "exist_ok", "=", "True", ")", "\n", "series", ".", "to_csv", "(", "dump_path", ",", "header", "=", "None", ",", "index", "=", "False", ")", "\n", "logger", ".", "info", "(", "f'Idx used of shape {series.size}'", ")", "\n", "\n", "# Ignore existing pvals selection", "\n", "task", ".", "meta", ".", "select", "=", "None", "\n", "task", ".", "meta", ".", "encode_select", "=", "'ordinal'", "\n", "\n", "# Force reload y to take into account previous change", "\n", "task", ".", "_load_y", "(", ")", "\n", "y", "=", "task", ".", "y", "\n", "logger", ".", "info", "(", "f'y reloaded with shape {y.shape}'", ")", "\n", "\n", "index", "=", "y", ".", "index", "\n", "\n", "temp_df_transposed_path", "=", "temp_dir", "+", "f'RS{RS}-T{T}-X_transposed.csv'", "\n", "\n", "logger", ".", "info", "(", "'Retrieving X'", ")", "\n", "X", "=", "task", ".", "X", "\n", "logger", ".", "info", "(", "f'X loaded with shape {X.shape}'", ")", "\n", "n_features", "=", "X", ".", "shape", "[", "1", "]", "\n", "\n", "os", ".", "makedirs", "(", "temp_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# Little trick here, to iterate efficiently over the features, data is", "\n", "# transposed so that features are now in the place of rows.", "\n", "# This is useful because it is less memory expensive to iterate over", "\n", "# rows than features (rows are loaded on the fly from the file).", "\n", "# Particularly usefull with big datasets that doesn't fit in memory.", "\n", "X_t", "=", "X", ".", "transpose", "(", ")", "\n", "X_t", ".", "to_csv", "(", "temp_df_transposed_path", ",", "quoting", "=", "csv", ".", "QUOTE_ALL", ")", "\n", "\n", "# Here we create an iterator over the rows (features, since its transposed)", "\n", "# Data is loaded row by row (since chunksize=1) when the iterator is called", "\n", "X_t", "=", "pd", ".", "read_csv", "(", "temp_df_transposed_path", ",", "iterator", "=", "True", ",", "chunksize", "=", "1", ",", "\n", "index_col", "=", "0", ")", "\n", "\n", "# Load types", "\n", "logger", ".", "info", "(", "'Loading types'", ")", "\n", "db", ".", "_load_feature_types", "(", "task", ".", "meta", ")", "\n", "types", "=", "db", ".", "feature_types", "[", "task", ".", "meta", ".", "tag", "]", "\n", "\n", "def", "pval_one_feature", "(", "x", ",", "y", ")", ":", "\n", "# Drop rows wih missing values both in f and y", "\n", "        ", "x", "=", "pd", ".", "Series", "(", "x", ",", "index", "=", "index", ")", "\n", "x", ".", "replace", "(", "to_replace", "=", "''", ",", "value", "=", "np", ".", "nan", ",", "inplace", "=", "True", ")", "\n", "x", "=", "x", ".", "astype", "(", "float", ")", "\n", "idx_to_drop", "=", "set", "(", "x", ".", "index", "[", "x", ".", "isna", "(", ")", "]", ")", "\n", "x", "=", "x", ".", "drop", "(", "idx_to_drop", ",", "axis", "=", "0", ")", "\n", "y_dropped", "=", "y", ".", "drop", "(", "idx_to_drop", ",", "axis", "=", "0", ")", "\n", "\n", "x", "=", "x", ".", "to_numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "y_dropped", "=", "y_dropped", ".", "to_numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "assert", "x", ".", "shape", "[", "0", "]", "==", "y_dropped", ".", "shape", "[", "0", "]", "\n", "\n", "if", "x", ".", "shape", "[", "0", "]", "<", "0.01", "*", "index", ".", "size", ":", "# Not enough sample, skipping", "\n", "            ", "return", "None", "\n", "\n", "", "_", ",", "pval", "=", "f_callable", "(", "x", ",", "y_dropped", ")", "\n", "\n", "# Keep only 6 significant digits (not the same as keeping 6 digits)", "\n", "# eg 1.23456789e-10 -> 1.234567e-10", "\n", "return", "float", "(", "f'{pval[0]:.6g}'", ")", "\n", "\n", "", "def", "handler", "(", "row", ",", "y", ")", ":", "\n", "        ", "name", "=", "row", ".", "index", "[", "0", "]", "\n", "x", "=", "np", ".", "squeeze", "(", "np", ".", "transpose", "(", "row", ".", "to_numpy", "(", ")", ")", ")", "\n", "logger", ".", "info", "(", "name", ")", "\n", "\n", "if", "name", "==", "''", ":", "\n", "            ", "return", "\n", "\n", "", "t", "=", "types", "[", "name", "]", "\n", "\n", "if", "t", "==", "CATEGORICAL", "or", "t", "==", "BINARY", ":", "\n", "# categorical encode", "\n", "            ", "df", "=", "pd", ".", "DataFrame", "(", "{", "name", ":", "x", "}", ")", "\n", "df", "=", "df", ".", "astype", "(", "str", ")", "\n", "df", ".", "replace", "(", "to_replace", "=", "''", ",", "value", "=", "np", ".", "nan", ",", "inplace", "=", "True", ")", "\n", "\n", "enc", "=", "OneHotEncoder", "(", "sparse", "=", "False", ")", "\n", "\n", "# Cast to str to prevent: \"argument must be a string or number\"", "\n", "# error which occurs when mixed types floats and str", "\n", "\n", "# Fill missing values with a placeholder", "\n", "df", ".", "fillna", "(", "'MISSING_VALUE'", ",", "inplace", "=", "True", ")", "\n", "\n", "# Fit transform the encoder", "\n", "data_encoded", "=", "enc", ".", "fit_transform", "(", "df", ")", "\n", "\n", "feature_names", "=", "list", "(", "enc", ".", "get_feature_names", "(", "list", "(", "df", ".", "columns", ")", ")", ")", "\n", "\n", "df_encoded", "=", "pd", ".", "DataFrame", "(", "data_encoded", ",", "\n", "index", "=", "df", ".", "index", ",", "\n", "columns", "=", "feature_names", "\n", ")", "\n", "L", "=", "[", "]", "\n", "for", "f", "in", "df_encoded", ":", "\n", "                ", "L", ".", "append", "(", "(", "f", ",", "pval_one_feature", "(", "df_encoded", "[", "f", "]", ",", "y", ")", ")", ")", "\n", "", "return", "L", "\n", "\n", "", "elif", "t", "==", "CONTINUE_R", "or", "t", "==", "CONTINUE_I", "or", "t", "==", "ORDINAL", ":", "\n", "            ", "return", "[", "(", "name", ",", "pval_one_feature", "(", "x", ",", "y", ")", ")", "]", "\n", "\n", "", "logger", ".", "info", "(", "f'\"{name}\" ignored '", ")", "\n", "\n", "", "res", "=", "Parallel", "(", "\n", "n_jobs", "=", "-", "1", ",", "\n", "require", "=", "'sharedmem'", "\n", ")", "(", "delayed", "(", "handler", ")", "(", "r", ",", "y", ")", "for", "r", "in", "tqdm", "(", "X_t", ",", "total", "=", "n_features", ")", ")", "\n", "\n", "res", "=", "[", "r", "for", "r", "in", "res", "if", "r", "is", "not", "None", "]", "\n", "\n", "res", "=", "functools", ".", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ",", "res", ")", "\n", "\n", "names", ",", "pvals", "=", "zip", "(", "*", "res", ")", "\n", "\n", "pvals", "=", "pd", ".", "Series", "(", "pvals", ",", "index", "=", "names", ")", "\n", "dump_path", "=", "f'pvals/{task.meta.tag}/RS{RS}-T{T}-pvals.csv'", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "dump_path", ")", ",", "exist_ok", "=", "True", ")", "\n", "pvals", ".", "to_csv", "(", "dump_path", ",", "header", "=", "False", ")", "\n", "logger", ".", "info", "(", "f'p-values of {task.meta.tag} dumped in {dump_path}'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.split_features": [[6, 35], ["dict", "groups.unique", "isinstance", "df.drop", "df.drop"], "function", ["None"], ["def", "split_features", "(", "df", ",", "groups", ")", ":", "\n", "    ", "\"\"\"Split the columns of a df according to their given group.\n\n    Parameters:\n    -----------\n    df : pandas.DataFrame\n        The data frame to be splitted.\n    groups : pandas.Series\n        Series with the features' names or indexs as index and the group as\n        values.\n\n    Returns:\n    --------\n    dict\n        Dictionnary with groups as keys and sub data frame as values.\n\n    \"\"\"", "\n", "sub_df", "=", "dict", "(", ")", "\n", "\n", "for", "group_id", "in", "groups", ".", "unique", "(", ")", ":", "\n", "# Get the names of the features to drop", "\n", "        ", "features_to_drop", "=", "groups", "[", "groups", "!=", "group_id", "]", ".", "index", "\n", "# Get the data frame without those features", "\n", "if", "isinstance", "(", "df", ",", "pd", ".", "Series", ")", ":", "\n", "            ", "sub_df", "[", "group_id", "]", "=", "df", ".", "drop", "(", "features_to_drop", ")", "\n", "", "else", ":", "\n", "            ", "sub_df", "[", "group_id", "]", "=", "df", ".", "drop", "(", "features_to_drop", ",", "1", ")", "\n", "\n", "", "", "return", "sub_df", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df": [[37, 60], ["isinstance", "isinstance", "df_utils.fill_df.fill"], "function", ["None"], ["", "def", "fill_df", "(", "df", ",", "b", ",", "value", ",", "keys", "=", "None", ")", ":", "\n", "\n", "    ", "def", "fill", "(", "df", ",", "b", ",", "value", ")", ":", "\n", "        ", "return", "df", ".", "mask", "(", "b", ",", "value", ")", "\n", "\n", "", "if", "isinstance", "(", "df", ",", "dict", ")", ":", "\n", "        ", "if", "keys", "is", "None", ":", "\n", "            ", "return", "{", "k", ":", "fill", "(", "df", "[", "k", "]", ",", "b", "[", "k", "]", ",", "value", ")", "for", "k", "in", "df", ".", "keys", "(", ")", "}", "\n", "\n", "", "df_filled", "=", "dict", "(", ")", "\n", "for", "k", "in", "keys", ":", "\n", "            ", "df_filled", "[", "k", "]", "=", "fill", "(", "df", "[", "k", "]", ",", "b", "[", "k", "]", ",", "value", ")", "\n", "\n", "", "for", "k", "in", "df", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "not", "in", "df_filled", ":", "\n", "                ", "df_filled", "[", "k", "]", "=", "df", "[", "k", "]", ".", "copy", "(", ")", "\n", "\n", "", "", "return", "df_filled", "\n", "\n", "", "if", "isinstance", "(", "df", ",", "list", ")", ":", "\n", "        ", "return", "[", "fill", "(", "v", ",", "b", "[", "k", "]", ",", "value", ")", "for", "k", ",", "v", "in", "enumerate", "(", "df", ")", "]", "\n", "\n", "", "return", "fill", "(", "df", ",", "b", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.rint_features": [[62, 87], ["df.copy", "numpy.rint"], "function", ["None"], ["", "def", "rint_features", "(", "df", ",", "features", ")", ":", "\n", "    ", "\"\"\"Inplace round elements of selected columns to nearest integer.\n\n    Parameters:\n    -----------\n    df : pandas.DataFrame\n        The data frame with columns to be rounded.\n    groups : pandas.Series\n        Series with the features' names as index and boolean values where True\n        encode the features to round.\n\n    Returns:\n    --------\n    pandas.DataFrame\n        Data frame with rounded columns.\n\n    \"\"\"", "\n", "features_to_round", "=", "features", "[", "features", "]", ".", "index", "\n", "\n", "df_rounded", "=", "df", ".", "copy", "(", ")", "\n", "\n", "for", "feature_name", "in", "features_to_round", ":", "\n", "        ", "df_rounded", "[", "feature_name", "]", "=", "np", ".", "rint", "(", "df", "[", "feature_name", "]", ")", "\n", "\n", "", "return", "df_rounded", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.set_dtypes_features": [[89, 120], ["dict", "dtypes.items", "df.astype"], "function", ["None"], ["", "def", "set_dtypes_features", "(", "df", ",", "groups", ",", "dtypes", ")", ":", "\n", "    ", "\"\"\"Split the columns of a df according to their given group.\n\n    Parameters:\n    -----------\n    df : pandas.DataFrame\n        The data frame to be splitted.\n    groups : pandas.Series\n        Series with the features' names or indexs as index and the group as\n        values.\n    group : scalar\n        Scalar to look for in the groups series. The dtype will be set on the\n        matched features.\n    dtypes: python type or np.dtype\n        Matched features will be set to this type\n\n    Returns:\n    --------\n    pandas.DataFrame\n        Data frame with casted dtypes.\n\n    \"\"\"", "\n", "_dtypes", "=", "dict", "(", ")", "\n", "\n", "for", "group", ",", "dtype", "in", "dtypes", ".", "items", "(", ")", ":", "\n", "# Get the names of the features to set the dtype", "\n", "        ", "features", "=", "groups", "[", "groups", "==", "group", "]", ".", "index", "\n", "for", "f", "in", "features", ":", "\n", "            ", "_dtypes", "[", "f", "]", "=", "dtype", "\n", "\n", "", "", "return", "df", ".", "astype", "(", "_dtypes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.dtype_from_types": [[122, 130], ["dict", "types.items"], "function", ["None"], ["", "def", "dtype_from_types", "(", "types", ",", "type_to_dtype", ")", ":", "\n", "    ", "dtype", "=", "dict", "(", ")", "\n", "\n", "for", "f", ",", "t", "in", "types", ".", "items", "(", ")", ":", "\n", "        ", "if", "t", "in", "type_to_dtype", ":", "\n", "            ", "dtype", "[", "f", "]", "=", "type_to_dtype", "[", "t", "]", "\n", "\n", "", "", "return", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_columns": [[132, 139], ["isinstance", "isinstance", "ValueError", "type"], "function", ["None"], ["", "def", "get_columns", "(", "df", ")", ":", "\n", "    ", "if", "isinstance", "(", "df", ",", "pd", ".", "DataFrame", ")", ":", "\n", "        ", "return", "df", ".", "columns", "\n", "", "elif", "isinstance", "(", "df", ",", "pd", ".", "Series", ")", ":", "\n", "        ", "return", "df", ".", "index", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'non supported type {type(df)}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values": [[141, 171], ["isinstance", "pandas.concat", "heuristic", "heuristic", "range"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS.heuristic", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS.heuristic"], ["", "", "def", "get_missing_values", "(", "df", ",", "heuristic", ")", ":", "\n", "    ", "\"\"\"Determine the type of missing value present in the given data frame.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        The data frame storing the input table from which to determine the type\n        of missing values.\n    heuristic : function with pandas.Series -> pandas.Series signature\n        The heuristic according to which are determined the type of missing\n        values. Given a column of df stored as a pandas.Series, the heuristic\n        returns a pandas.Series storing the type of missing values encountered.\n\n    Returns\n    -------\n    pandas.DataFrame\n        A data frame with same index and columns as the input one but storing\n        the type of missing values encountered (0: Not a missing value,\n        1: Not applicable, 2: Not available).\n\n    \"\"\"", "\n", "if", "isinstance", "(", "df", ",", "pd", ".", "Series", ")", ":", "\n", "        ", "return", "heuristic", "(", "df", ")", "\n", "\n", "# Compute the Series storing the types of missing values", "\n", "", "columns", "=", "[", "heuristic", "(", "df", ".", "iloc", "[", ":", ",", "index", "]", ")", "for", "index", "in", "range", "(", "df", ".", "shape", "[", "1", "]", ")", "]", "\n", "# Concat the Series into a data frame", "\n", "df_mv", "=", "pd", ".", "concat", "(", "columns", ",", "axis", "=", "1", ",", "sort", "=", "False", ")", "\n", "\n", "return", "df_mv", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.extraction.extract_UKBB.run_v2": [[11, 28], ["pandas.read_csv", "set", "pandas.read_csv", "set", "pandas.read_csv", "pd.read_csv.drop", "pd.read_csv.to_csv"], "function", ["None"], ["def", "run_v2", "(", "argv", "=", "None", ")", ":", "\n", "# Features to keep", "\n", "    ", "df2", "=", "pd", ".", "read_csv", "(", "'extracted/ukb40663_features_filtered.csv'", ")", "\n", "features_to_keep", "=", "set", "(", "df2", "[", "'feature_name'", "]", ")", "\n", "\n", "# All features", "\n", "df3", "=", "pd", ".", "read_csv", "(", "'UKBB/ukbb_tabular/csv/ukb40663.csv'", ",", "nrows", "=", "0", ")", "\n", "features", "=", "set", "(", "df3", ".", "columns", ")", "\n", "\n", "# Features to drop", "\n", "features_to_drop", "=", "features", "-", "features_to_keep", "\n", "\n", "df", "=", "pd", ".", "read_csv", "(", "'UKBB/ukbb_tabular/csv/ukb40663.csv'", ",", "index_col", "=", "'eid'", ",", "\n", "sep", "=", "sep", ",", "encoding", "=", "encoding", ")", "\n", "df", ".", "drop", "(", "features_to_drop", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "df", ".", "to_csv", "(", "f'ukb40663_filtered.csv'", ",", "quoting", "=", "csv", ".", "QUOTE_ALL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.extraction.extract_UKBB.run_v1": [[30, 43], ["pandas.read_csv", "set", "pandas.read_csv", "pd.read_csv.transpose", "df.transpose.to_csv", "pd.read_csv.to_csv"], "function", ["None"], ["", "def", "run_v1", "(", "argv", "=", "None", ")", ":", "\n", "# Features to keep", "\n", "    ", "df2", "=", "pd", ".", "read_csv", "(", "'extracted/ukb40663_features_filtered_v2.csv'", ")", "\n", "\n", "features", "=", "set", "(", "df2", "[", "'feature_name'", "]", ")", "\n", "\n", "df", "=", "pd", ".", "read_csv", "(", "'UKBB/ukbb_tabular/csv/ukb40663_filtered.csv'", ",", "usecols", "=", "features", ",", "\n", "index_col", "=", "'eid'", ",", "sep", "=", "sep", ",", "encoding", "=", "encoding", ")", "\n", "\n", "df_t", "=", "df", ".", "transpose", "(", ")", "\n", "df_t", ".", "to_csv", "(", "f'extracted/ukb40663_filtered_v2_transposed.csv'", ",", "quoting", "=", "csv", ".", "QUOTE_ALL", ")", "\n", "\n", "df", ".", "to_csv", "(", "f'extracted/ukb40663_filtered_v2.csv'", ",", "quoting", "=", "csv", ".", "QUOTE_ALL", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.extraction.extract.run": [[13, 39], ["pandas.read_csv", "database.base.Database.get_drop_and_keep_meta", "pandas.read_csv", "os.makedirs", "pd.read_csv.to_csv", "to_keep.add"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.get_drop_and_keep_meta"], ["def", "run", "(", "args", ")", ":", "\n", "    ", "task_name", "=", "args", ".", "task_name", "\n", "task", "=", "tasks", "[", "task_name", "]", "\n", "db", "=", "dbs", "[", "task", ".", "meta", ".", "db", "]", "\n", "df_name", "=", "task", ".", "meta", ".", "df_name", "\n", "path", "=", "db", ".", "frame_paths", "[", "df_name", "]", "\n", "\n", "features", "=", "pd", ".", "read_csv", "(", "path", ",", "sep", "=", "db", ".", "_sep", ",", "encoding", "=", "db", ".", "_encoding", ",", "\n", "nrows", "=", "0", ")", "\n", "\n", "to_keep", ",", "_", "=", "Database", ".", "get_drop_and_keep_meta", "(", "features", ",", "task", ".", "meta", ")", "\n", "\n", "if", "db", ".", "acronym", "==", "'UKBB'", ":", "\n", "        ", "index_col", "=", "'eid'", "\n", "to_keep", ".", "add", "(", "'eid'", ")", "\n", "quoting", "=", "csv", ".", "QUOTE_ALL", "\n", "", "else", ":", "\n", "        ", "index_col", "=", "None", "\n", "quoting", "=", "csv", ".", "QUOTE_MINIMAL", "\n", "\n", "", "df", "=", "pd", ".", "read_csv", "(", "path", ",", "sep", "=", "db", ".", "_sep", ",", "encoding", "=", "db", ".", "_encoding", ",", "\n", "usecols", "=", "to_keep", ",", "index_col", "=", "index_col", ")", "\n", "\n", "dump_path", "=", "dump_folder", "+", "db", ".", "acronym", "\n", "os", ".", "makedirs", "(", "dump_path", ",", "exist_ok", "=", "True", ")", "\n", "df", ".", "to_csv", "(", "f'{dump_folder}{task_name}_{df_name}.csv'", ",", "quoting", "=", "quoting", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.pvals.__init__.filter": [[6, 10], ["TB.filter.filter", "NHIS.filter.filter", "UKBB.filter.filter"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.TB.filter.filter", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.TB.filter.filter", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.TB.filter.filter"], []], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.NHIS.filter.filter": [[6, 40], ["next", "os.walk", "isinstance", "next", "pandas.read_csv", "os.path.splitext", "remove_features_id.to_csv", "os.walk", "open", "filter.filter.remove_features_id"], "function", ["None"], ["def", "filter", "(", ")", ":", "\n", "    ", "pvals_dirs", "=", "next", "(", "os", ".", "walk", "(", "'pvals/NHIS'", ")", ")", "[", "1", "]", "\n", "\n", "exclude_filename", "=", "'exclude.txt'", "\n", "\n", "def", "remove_features_id", "(", "pvals", ",", "features_ids", ")", ":", "\n", "        ", "\"\"\"Remove features from given pvals.\"\"\"", "\n", "if", "not", "isinstance", "(", "features_ids", ",", "list", ")", ":", "\n", "            ", "features_ids", "=", "[", "features_ids", "]", "\n", "\n", "", "for", "feature_id", "in", "features_ids", ":", "\n", "# Match exact feature or start with & followed by '_' (categorical)", "\n", "            ", "regex", "=", "f'(^{feature_id}$|^{feature_id}_)'", "\n", "pvals", "=", "pvals", "[", "~", "pvals", "[", "0", "]", ".", "str", ".", "match", "(", "regex", ")", "]", "\n", "\n", "", "return", "pvals", "\n", "\n", "", "for", "pvals_dir", "in", "pvals_dirs", ":", "\n", "        ", "for", "filename", "in", "next", "(", "os", ".", "walk", "(", "f'pvals/NHIS/{pvals_dir}'", ")", ")", "[", "2", "]", ":", "\n", "            ", "if", "'pvals.csv'", "not", "in", "filename", ":", "\n", "                ", "continue", "# not pvals, skipping", "\n", "\n", "", "pvals_path", "=", "f'pvals/NHIS/{pvals_dir}/{filename}'", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "pvals_path", ",", "header", "=", "None", ",", "dtype", "=", "str", ")", "\n", "\n", "# remove features", "\n", "exclude_path", "=", "f'pvals/NHIS/{pvals_dir}/{exclude_filename}'", "\n", "with", "open", "(", "exclude_path", ",", "'r'", ")", "as", "file", ":", "\n", "                ", "for", "line", "in", "file", ":", "\n", "                    ", "pvals", "=", "remove_features_id", "(", "pvals", ",", "line", ".", "strip", "(", ")", ")", "\n", "\n", "", "", "basepath", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "pvals_path", ")", "\n", "new_pvals_path", "=", "f'{basepath}_filtered{ext}'", "\n", "pvals", ".", "to_csv", "(", "new_pvals_path", ",", "index", "=", "None", ",", "header", "=", "None", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.UKBB.filter.filter": [[7, 44], ["dict", "tqdm.tqdm", "next", "os.walk", "open", "file.read().splitlines", "next", "pandas.read_csv", "dict.values", "os.path.splitext", "remove_features_id.to_csv", "os.walk", "filter.filter.remove_features_id"], "function", ["None"], ["    ", "pvals_dirs", "=", "next", "(", "os", ".", "walk", "(", "'pvals/NHIS'", ")", ")", "[", "1", "]", "\n", "\n", "exclude_filename", "=", "'exclude.txt'", "\n", "\n", "def", "remove_features_id", "(", "pvals", ",", "features_ids", ")", ":", "\n", "        ", "\"\"\"Remove features from given pvals.\"\"\"", "\n", "if", "not", "isinstance", "(", "features_ids", ",", "list", ")", ":", "\n", "            ", "features_ids", "=", "[", "features_ids", "]", "\n", "\n", "", "for", "feature_id", "in", "features_ids", ":", "\n", "# Match exact feature or start with & followed by '_' (categorical)", "\n", "            ", "regex", "=", "f'(^{feature_id}$|^{feature_id}_)'", "\n", "pvals", "=", "pvals", "[", "~", "pvals", "[", "0", "]", ".", "str", ".", "match", "(", "regex", ")", "]", "\n", "\n", "", "return", "pvals", "\n", "\n", "", "for", "pvals_dir", "in", "pvals_dirs", ":", "\n", "        ", "for", "filename", "in", "next", "(", "os", ".", "walk", "(", "f'pvals/NHIS/{pvals_dir}'", ")", ")", "[", "2", "]", ":", "\n", "            ", "if", "'pvals.csv'", "not", "in", "filename", ":", "\n", "                ", "continue", "# not pvals, skipping", "\n", "\n", "", "pvals_path", "=", "f'pvals/NHIS/{pvals_dir}/{filename}'", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "pvals_path", ",", "header", "=", "None", ",", "dtype", "=", "str", ")", "\n", "\n", "# remove features", "\n", "exclude_path", "=", "f'pvals/NHIS/{pvals_dir}/{exclude_filename}'", "\n", "with", "open", "(", "exclude_path", ",", "'r'", ")", "as", "file", ":", "\n", "                ", "for", "line", "in", "file", ":", "\n", "                    ", "pvals", "=", "remove_features_id", "(", "pvals", ",", "line", ".", "strip", "(", ")", ")", "\n", "\n", "", "", "basepath", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "pvals_path", ")", "\n", "new_pvals_path", "=", "f'{basepath}_filtered{ext}'", "\n", "pvals", ".", "to_csv", "(", "new_pvals_path", ",", "index", "=", "None", ",", "header", "=", "None", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.TB.filter.filter": [[7, 42], ["dict", "tqdm.tqdm", "next", "os.walk", "open", "file.read().splitlines", "next", "pandas.read_csv", "dict.values", "os.path.splitext", "remove_features_id.to_csv", "os.walk", "filter.filter.remove_features_id"], "function", ["None"], ["    ", "pvals_dirs", "=", "next", "(", "os", ".", "walk", "(", "'pvals/NHIS'", ")", ")", "[", "1", "]", "\n", "\n", "exclude_filename", "=", "'exclude.txt'", "\n", "\n", "def", "remove_features_id", "(", "pvals", ",", "features_ids", ")", ":", "\n", "        ", "\"\"\"Remove features from given pvals.\"\"\"", "\n", "if", "not", "isinstance", "(", "features_ids", ",", "list", ")", ":", "\n", "            ", "features_ids", "=", "[", "features_ids", "]", "\n", "\n", "", "for", "feature_id", "in", "features_ids", ":", "\n", "# Match exact feature or start with & followed by '_' (categorical)", "\n", "            ", "regex", "=", "f'(^{feature_id}$|^{feature_id}_)'", "\n", "pvals", "=", "pvals", "[", "~", "pvals", "[", "0", "]", ".", "str", ".", "match", "(", "regex", ")", "]", "\n", "\n", "", "return", "pvals", "\n", "\n", "", "for", "pvals_dir", "in", "pvals_dirs", ":", "\n", "        ", "for", "filename", "in", "next", "(", "os", ".", "walk", "(", "f'pvals/NHIS/{pvals_dir}'", ")", ")", "[", "2", "]", ":", "\n", "            ", "if", "'pvals.csv'", "not", "in", "filename", ":", "\n", "                ", "continue", "# not pvals, skipping", "\n", "\n", "", "pvals_path", "=", "f'pvals/NHIS/{pvals_dir}/{filename}'", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "pvals_path", ",", "header", "=", "None", ",", "dtype", "=", "str", ")", "\n", "\n", "# remove features", "\n", "exclude_path", "=", "f'pvals/NHIS/{pvals_dir}/{exclude_filename}'", "\n", "with", "open", "(", "exclude_path", ",", "'r'", ")", "as", "file", ":", "\n", "                ", "for", "line", "in", "file", ":", "\n", "                    ", "pvals", "=", "remove_features_id", "(", "pvals", ",", "line", ".", "strip", "(", ")", ")", "\n", "\n", "", "", "basepath", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "pvals_path", ")", "\n", "new_pvals_path", "=", "f'{basepath}_filtered{ext}'", "\n", "pvals", ".", "to_csv", "(", "new_pvals_path", ",", "index", "=", "None", ",", "header", "=", "None", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.__init__": [[7, 13], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "fit_timestamps", "=", "[", "]", "\n", "self", ".", "transform_timestamps", "=", "[", "]", "\n", "self", ".", "fit_pts", "=", "[", "]", "\n", "self", ".", "transform_pts", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.last_fit_timestamp": [[14, 18], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "last_fit_timestamp", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "fit_timestamps", ":", "\n", "            ", "return", "self", ".", "fit_timestamps", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.last_transform_timestamp": [[19, 23], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "last_transform_timestamp", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "transform_timestamps", ":", "\n", "            ", "return", "self", ".", "transform_timestamps", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.last_fit_pt": [[24, 28], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "last_fit_pt", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "fit_pts", ":", "\n", "            ", "return", "self", ".", "fit_pts", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.last_transform_pt": [[29, 33], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "last_transform_pt", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "transform_pts", ":", "\n", "            ", "return", "self", ".", "transform_pts", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.fit": [[34, 39], ["TimerStep.TimerStep.fit_timestamps.append", "TimerStep.TimerStep.fit_pts.append", "time.time", "time.process_time"], "methods", ["None"], ["", "", "def", "fit", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "self", ".", "fit_timestamps", ".", "append", "(", "time", ".", "time", "(", ")", ")", "\n", "self", ".", "fit_pts", ".", "append", "(", "time", ".", "process_time", "(", ")", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.transform": [[40, 45], ["TimerStep.TimerStep.transform_timestamps.append", "TimerStep.TimerStep.transform_pts.append", "time.time", "time.process_time"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "X", ")", ":", "\n", "        ", "self", ".", "transform_timestamps", ".", "append", "(", "time", ".", "time", "(", ")", ")", "\n", "self", ".", "transform_pts", ".", "append", "(", "time", ".", "process_time", "(", ")", ")", "\n", "\n", "return", "X", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.train.train": [[19, 225], ["logger.info", "logger.info", "logger.info", "DumpHelper.DumpHelper", "TimerStep.TimerStep", "TimerStep.TimerStep", "sklearn.pipeline.Pipeline", "logger.info", "ValueError", "logger.info", "strategy.reset_RS", "logger.info", "logger.info", "TimerStep.TimerStep", "Bagging", "sklearn.pipeline.Pipeline", "print", "print", "logger.info", "task.is_classif", "enumerate", "task.is_classif", "strategy.is_classification", "strategy.is_classification", "sklearn.model_selection.StratifiedShuffleSplit", "sklearn.model_selection.ShuffleSplit", "sklearn.model_selection.ShuffleSplit.split", "print", "logger.info", "sklearn.pipeline.Pipeline.fit", "logger.info", "DumpHelper.DumpHelper.dump_times", "logger.info", "DumpHelper.DumpHelper.dump_prediction", "print", "logger.info", "os.path.relpath", "os.makedirs", "task.meta.name.replace", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "pandas.Series().to_csv", "pandas.Series().to_csv", "pandas.Series().to_csv", "pandas.Series().to_csv", "time.time", "time.process_time", "train.train.compute_times"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.reset_RS", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.is_classification", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.is_classification", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.fit", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_times", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_prediction"], ["def", "train", "(", "task", ",", "strategy", ",", "RS", "=", "None", ",", "dump_idx_only", "=", "False", ",", "T", "=", "0", ",", "n_bagging", "=", "None", ",", "\n", "train_size", "=", "None", ",", "n_permutation", "=", "None", ",", "asked_fold", "=", "None", ",", "\n", "results_folder", "=", "None", ")", ":", "\n", "    ", "\"\"\"Train a model (strategy) on some data (task) and dump results.\n\n    Parameters\n    ----------\n    task : Task object\n        Define a prediction task. Used to retrieve the data of the wanted task.\n    strategy : Strategy object\n        Define the method (imputation + model) to use.\n    RS : int\n        Define a random state.\n    T : int\n        Trial number for the ANOVA selection step, from 1 to 5 if 5 trials for\n        the ANOVA selection.\n        Used only for names of folder when dumping results.\n    n_bagging : bool\n        Whether to use bagging.\n\n    \"\"\"", "\n", "if", "task", ".", "is_classif", "(", ")", "!=", "strategy", ".", "is_classification", "(", ")", "and", "not", "dump_idx_only", ":", "\n", "        ", "raise", "ValueError", "(", "'Task and strategy mix classif and regression.'", ")", "\n", "\n", "", "X", ",", "y", "=", "task", ".", "X", ",", "task", ".", "y", "# Expensive data retrieval is hidden here", "\n", "\n", "logger", ".", "info", "(", "f'Started task \"{task.meta.tag}\" '", "\n", "f'using \"{strategy.name}\" strategy on \"{task.meta.db}\".'", ")", "\n", "logger", ".", "info", "(", "f'X shape: {X.shape}'", ")", "\n", "logger", ".", "info", "(", "f'y shape: {y.shape}'", ")", "\n", "\n", "if", "RS", "is", "not", "None", ":", "\n", "        ", "logger", ".", "info", "(", "f'Resetting strategy RS to {RS}'", ")", "\n", "strategy", ".", "reset_RS", "(", "RS", ")", "# Must be done before init DumpHelper", "\n", "\n", "", "dh", "=", "DumpHelper", "(", "task", ",", "strategy", ",", "RS", "=", "RS", ",", "T", "=", "T", ",", "n_bagging", "=", "n_bagging", ",", "\n", "results_folder", "=", "results_folder", ")", "# Used to dump results", "\n", "\n", "# Create timer steps used in the pipeline to time training time", "\n", "timer_start", "=", "TimerStep", "(", "'start'", ")", "\n", "timer_mid", "=", "TimerStep", "(", "'mid'", ")", "\n", "\n", "# Create pipeline with imputation and hyper-parameters tuning", "\n", "if", "strategy", ".", "imputer", "is", "not", "None", ":", "# Has an imputation step", "\n", "        ", "logger", ".", "info", "(", "'Creating pipeline with imputer.'", ")", "\n", "steps", "=", "[", "\n", "(", "'timer_start'", ",", "timer_start", ")", ",", "\n", "(", "'imputer'", ",", "strategy", ".", "imputer", ")", ",", "# Imputation step", "\n", "(", "'timer_mid'", ",", "timer_mid", ")", ",", "\n", "(", "'searchCV_estimator'", ",", "strategy", ".", "search", ")", ",", "# HP tuning step", "\n", "]", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "'Creating pipeline without imputer.'", ")", "\n", "steps", "=", "[", "\n", "(", "'timer_mid'", ",", "timer_mid", ")", ",", "\n", "(", "'searchCV_estimator'", ",", "strategy", ".", "search", ")", ",", "# HP tuning step", "\n", "]", "\n", "\n", "", "estimator", "=", "Pipeline", "(", "steps", ")", "\n", "\n", "if", "n_bagging", "is", "not", "None", ":", "\n", "        ", "global_timer_start", "=", "TimerStep", "(", "'global_start'", ")", "\n", "Bagging", "=", "BaggingClassifier", "if", "strategy", ".", "is_classification", "(", ")", "else", "BaggingRegressor", "\n", "estimator", "=", "Bagging", "(", "estimator", ",", "n_estimators", "=", "n_bagging", ",", "random_state", "=", "RS", ")", "\n", "estimator", "=", "Pipeline", "(", "[", "\n", "(", "'global_timer_start'", ",", "global_timer_start", ")", ",", "\n", "(", "'bagged_estimator'", ",", "estimator", ")", ",", "\n", "]", ")", "\n", "print", "(", "f'Using {Bagging} with {n_bagging} estimators and RS={RS}.'", ")", "\n", "\n", "", "logger", ".", "info", "(", "'Before size loop'", ")", "\n", "# Size of the train set", "\n", "train_set_steps", "=", "strategy", ".", "train_set_steps", "if", "train_size", "is", "None", "else", "[", "train_size", "]", "\n", "for", "n", "in", "train_set_steps", ":", "\n", "        ", "print", "(", "f'SIZE {n}'", ")", "\n", "logger", ".", "info", "(", "f'Size {n}'", ")", "\n", "n_tot", "=", "X", ".", "shape", "[", "0", "]", "\n", "if", "n_tot", "-", "n", "<", "strategy", ".", "min_test_set", "*", "n_tot", ":", "\n", "# Size of the test set too small, skipping", "\n", "            ", "continue", "\n", "\n", "# Choose right splitter depending on classification or regression", "\n", "", "if", "task", ".", "is_classif", "(", ")", ":", "\n", "            ", "ss", "=", "StratifiedShuffleSplit", "(", "n_splits", "=", "strategy", ".", "n_splits", ",", "\n", "test_size", "=", "n_tot", "-", "n", ",", "\n", "random_state", "=", "RS", ")", "\n", "", "else", ":", "\n", "            ", "ss", "=", "ShuffleSplit", "(", "n_splits", "=", "strategy", ".", "n_splits", ",", "test_size", "=", "n_tot", "-", "n", ",", "\n", "random_state", "=", "RS", ")", "\n", "\n", "# Repetedly draw train and test sets", "\n", "", "for", "i", ",", "(", "train_idx", ",", "test_idx", ")", "in", "enumerate", "(", "ss", ".", "split", "(", "X", ",", "y", ")", ")", ":", "\n", "            ", "print", "(", "f'FOLD {i}'", ")", "\n", "if", "asked_fold", "is", "not", "None", "and", "i", "!=", "asked_fold", ":", "\n", "                ", "print", "(", "'skipped'", ")", "\n", "continue", "\n", "\n", "", "X_train", ",", "X_test", "=", "X", ".", "iloc", "[", "train_idx", "]", ",", "X", ".", "iloc", "[", "test_idx", "]", "\n", "y_train", ",", "y_test", "=", "y", ".", "iloc", "[", "train_idx", "]", ",", "y", ".", "iloc", "[", "test_idx", "]", "\n", "\n", "\n", "# Used to save the IDs of the sub-sampled dataset.", "\n", "if", "dump_idx_only", ":", "\n", "                ", "logger", ".", "info", "(", "f'Dumped IDs of {task.meta.tag}, size={n}, trial={T}, fold={i}'", ")", "\n", "folder", "=", "relpath", "(", "'ids/'", ")", "\n", "os", ".", "makedirs", "(", "folder", ",", "exist_ok", "=", "True", ")", "\n", "name", "=", "task", ".", "meta", ".", "name", ".", "replace", "(", "'pvals'", ",", "'screening'", ")", "\n", "trial", "=", "int", "(", "T", ")", "+", "1", "\n", "fold", "=", "i", "+", "1", "\n", "common", "=", "f'{task.meta.db}-{name}-size{n}-trial{trial}-fold{fold}'", "\n", "filepath_idx_train", "=", "join", "(", "folder", ",", "f'{common}-train-idx.csv'", ")", "\n", "filepath_idx_test", "=", "join", "(", "folder", ",", "f'{common}-test-idx.csv'", ")", "\n", "filepath_col_train", "=", "join", "(", "folder", ",", "f'{common}-train-col.csv'", ")", "\n", "filepath_col_test", "=", "join", "(", "folder", ",", "f'{common}-test-col.csv'", ")", "\n", "pd", ".", "Series", "(", "X_train", ".", "index", ")", ".", "to_csv", "(", "filepath_idx_train", ",", "index", "=", "False", ")", "\n", "pd", ".", "Series", "(", "X_test", ".", "index", ")", ".", "to_csv", "(", "filepath_idx_test", ",", "index", "=", "False", ")", "\n", "pd", ".", "Series", "(", "X_train", ".", "columns", ")", ".", "to_csv", "(", "filepath_col_train", ",", "index", "=", "False", ",", "header", "=", "False", ")", "\n", "pd", ".", "Series", "(", "X_test", ".", "columns", ")", ".", "to_csv", "(", "filepath_col_test", ",", "index", "=", "False", ",", "header", "=", "False", ")", "\n", "continue", "# when dumping IDs, we skip prediction", "\n", "\n", "", "logger", ".", "info", "(", "f'Fold {i}: Started fitting the estimator'", ")", "\n", "estimator", ".", "fit", "(", "X_train", ",", "y_train", ")", "\n", "logger", ".", "info", "(", "'Ended fitting the estimator'", ")", "\n", "\n", "def", "compute_times", "(", "start", ",", "mid", ",", "end", ")", ":", "\n", "                ", "return", "{", "\n", "'imputation'", ":", "round", "(", "mid", "-", "start", ",", "6", ")", "if", "start", "else", "None", ",", "\n", "'tuning'", ":", "round", "(", "end", "-", "mid", ",", "6", ")", ",", "\n", "}", "\n", "\n", "", "if", "n_bagging", "is", "None", ":", "\n", "# Retrieve fit times from timestamps", "\n", "                ", "end_ts", "=", "time", ".", "time", "(", ")", "# Wall-clock time", "\n", "start_ts", "=", "timer_start", ".", "last_fit_timestamp", "\n", "mid_ts", "=", "timer_mid", ".", "last_fit_timestamp", "\n", "\n", "end_pt", "=", "time", ".", "process_time", "(", ")", "# Process time (!= Wall-clock time)", "\n", "start_pt", "=", "timer_start", ".", "last_fit_pt", "\n", "mid_pt", "=", "timer_mid", ".", "last_fit_pt", "\n", "\n", "times", "=", "compute_times", "(", "start_ts", ",", "mid_ts", ",", "end_ts", ")", "\n", "pts", "=", "compute_times", "(", "start_pt", ",", "mid_pt", ",", "end_pt", ")", "\n", "imputation_time", "=", "times", "[", "'imputation'", "]", "\n", "tuning_time", "=", "times", "[", "'tuning'", "]", "\n", "imputation_pt", "=", "pts", "[", "'imputation'", "]", "\n", "tuning_pt", "=", "pts", "[", "'tuning'", "]", "\n", "\n", "", "else", ":", "\n", "                ", "end_ts", "=", "time", ".", "time", "(", ")", "# Wall-clock time", "\n", "start_ts", "=", "global_timer_start", ".", "last_fit_timestamp", "\n", "\n", "end_pt", "=", "time", ".", "process_time", "(", ")", "# Process time (!= Wall-clock time)", "\n", "start_pt", "=", "global_timer_start", ".", "last_fit_pt", "\n", "\n", "# No mid_timer for bagged estimator", "\n", "times", "=", "compute_times", "(", "start_ts", ",", "start_ts", ",", "end_ts", ")", "\n", "pts", "=", "compute_times", "(", "start_pt", ",", "start_pt", ",", "end_pt", ")", "\n", "imputation_time", "=", "times", "[", "'imputation'", "]", "\n", "tuning_time", "=", "times", "[", "'tuning'", "]", "\n", "imputation_pt", "=", "pts", "[", "'imputation'", "]", "\n", "tuning_pt", "=", "pts", "[", "'tuning'", "]", "\n", "\n", "# Dump fit times", "\n", "", "dh", ".", "dump_times", "(", "imputation_time", ",", "tuning_time", ",", "\n", "imputation_pt", ",", "tuning_pt", ",", "\n", "fold", "=", "i", ",", "tag", "=", "str", "(", "n", ")", ")", "\n", "\n", "# Predict", "\n", "if", "strategy", ".", "is_classification", "(", ")", "and", "strategy", ".", "roc", ":", "# ROC asked", "\n", "# Compute probas for retrieving ROC curve", "\n", "                ", "probas", "=", "estimator", ".", "predict_proba", "(", "X_test", ")", "\n", "logger", ".", "info", "(", "'Started predict_proba'", ")", "\n", "# y_pred = np.argmax(probas, axis=1)", "\n", "dh", ".", "dump_probas", "(", "y_test", ",", "probas", ",", "fold", "=", "i", ",", "tag", "=", "str", "(", "n", ")", ")", "\n", "y_pred", "=", "estimator", ".", "predict", "(", "X_test", ")", "\n", "", "else", ":", "\n", "# No need for probas, only predictions", "\n", "                ", "if", "not", "strategy", ".", "is_classification", "(", ")", ":", "\n", "                    ", "logger", ".", "info", "(", "'ROC: not a classification.'", ")", "\n", "", "elif", "not", "strategy", ".", "roc", ":", "\n", "                    ", "logger", ".", "info", "(", "'ROC: not wanted.'", ")", "\n", "\n", "", "logger", ".", "info", "(", "'Started predict'", ")", "\n", "y_pred", "=", "estimator", ".", "predict", "(", "X_test", ")", "\n", "\n", "# Dump results", "\n", "", "logger", ".", "info", "(", "f'Fold {i}: Ended predict.'", ")", "\n", "dh", ".", "dump_prediction", "(", "y_pred", ",", "y_test", ",", "fold", "=", "i", ",", "tag", "=", "str", "(", "n", ")", ")", "\n", "\n", "if", "n_permutation", "is", "not", "None", ":", "\n", "                ", "scoring", "=", "'roc_auc'", "if", "strategy", ".", "is_classification", "(", ")", "else", "'r2'", "\n", "r", "=", "permutation_importance", "(", "estimator", ",", "X_test", ",", "y_test", ",", "\n", "n_repeats", "=", "n_permutation", ",", "\n", "random_state", "=", "RS", ",", "scoring", "=", "scoring", ")", "\n", "\n", "importances", "=", "pd", ".", "DataFrame", "(", "r", ".", "importances", ".", "T", ",", "columns", "=", "X_train", ".", "columns", ")", "\n", "importances", ".", "index", ".", "rename", "(", "'repeat'", ",", "inplace", "=", "True", ")", "\n", "importances", "=", "importances", ".", "reindex", "(", "sorted", "(", "importances", ".", "columns", ")", ",", "axis", "=", "1", ")", "\n", "\n", "dh", ".", "dump_importances", "(", "importances", ",", "fold", "=", "i", ",", "tag", "=", "str", "(", "n", ")", ")", "\n", "\n", "mv_props", "=", "X_test", ".", "isna", "(", ")", ".", "sum", "(", "axis", "=", "0", ")", "/", "X_test", ".", "shape", "[", "0", "]", "\n", "mv_props", ".", "rename", "(", "i", ",", "inplace", "=", "True", ")", "\n", "mv_props", "=", "mv_props", ".", "to_frame", "(", ")", ".", "T", "\n", "mv_props", "=", "mv_props", ".", "reindex", "(", "sorted", "(", "mv_props", ".", "columns", ")", ",", "axis", "=", "1", ")", "\n", "dh", ".", "dump_mv_props", "(", "mv_props", ",", "fold", "=", "i", ",", "tag", "=", "str", "(", "n", ")", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.__init__": [[76, 103], ["os.path.join", "DumpHelper.get_tag", "os.path.join", "logger.info", "os.path.join", "DumpHelper.DumpHelper._dump_infos", "DumpHelper.DumpHelper._dump_features", "os.path.join", "logger.info"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.get_tag", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_infos", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump_features"], ["def", "__init__", "(", "self", ",", "task", ",", "strat", ",", "RS", "=", "None", ",", "T", "=", "None", ",", "n_bagging", "=", "None", ",", "results_folder", "=", "None", ")", ":", "\n", "        ", "self", ".", "task", "=", "task", "\n", "self", ".", "strat", "=", "strat", "\n", "self", ".", "RS", "=", "RS", "\n", "self", ".", "T", "=", "T", "\n", "self", ".", "n_bagging", "=", "n_bagging", "\n", "self", ".", "results_folder", "=", "results_folder", "if", "results_folder", "is", "not", "None", "else", "'results'", "\n", "\n", "# self.db_folder = f'{results_folder}{self.task.meta.db}/'", "\n", "self", ".", "db_folder", "=", "join", "(", "self", ".", "results_folder", ",", "self", ".", "task", ".", "meta", ".", "db", ")", "\n", "\n", "tag", "=", "get_tag", "(", "RS", ",", "T", ")", "\n", "\n", "# self.task_folder = f'{self.db_folder}{self.task.meta.name}/'", "\n", "self", ".", "task_folder", "=", "join", "(", "self", ".", "db_folder", ",", "self", ".", "task", ".", "meta", ".", "name", ")", "\n", "logger", ".", "info", "(", "f'Task folder: {self.task_folder}'", ")", "\n", "\n", "# self.backup_folder = f'{self.task_folder}backup/'", "\n", "self", ".", "backup_folder", "=", "join", "(", "self", ".", "task_folder", ",", "'backup'", ")", "\n", "\n", "if", "strat", "is", "not", "None", ":", "\n", "            ", "name", "=", "strat", ".", "name", "if", "n_bagging", "is", "None", "else", "f'{strat.name}_Bagged{self.n_bagging}'", "\n", "self", ".", "strat_folder", "=", "join", "(", "self", ".", "task_folder", ",", "f'{tag}{name}'", ")", "\n", "logger", ".", "info", "(", "f'Strat folder: {self.strat_folder}'", ")", "\n", "\n", "", "self", ".", "_dump_infos", "(", ")", "\n", "self", ".", "_dump_features", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump_infos": [[104, 135], ["os.path.isdir", "os.makedirs", "DumpHelper.DumpHelper.strat.get_infos", "DumpHelper._dump_yaml", "DumpHelper._dump_yaml", "os.makedirs", "DumpHelper._dump_yaml", "os.makedirs", "datetime.datetime.datetime.now().strftime", "os.path.join", "shutil.copytree", "shutil.rmtree", "DumpHelper.DumpHelper.task.get_infos", "os.path.join", "os.path.join", "DumpHelper.DumpHelper.task.get_infos", "os.path.join", "datetime.datetime.datetime.now"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_yaml", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_yaml", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_yaml", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos"], ["", "def", "_dump_infos", "(", "self", ")", ":", "\n", "        ", "\"\"\"Dump the infos of the task and strategy used.\"\"\"", "\n", "if", "self", ".", "strat", "is", "not", "None", ":", "\n", "# Check if task directory already exists", "\n", "            ", "if", "os", ".", "path", ".", "isdir", "(", "self", ".", "strat_folder", ")", ":", "\n", "# Move it in the backup folder", "\n", "                ", "os", ".", "makedirs", "(", "self", ".", "backup_folder", ",", "exist_ok", "=", "True", ")", "\n", "time_tag", "=", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%Y-%m-%d_%H:%M:%S.%f\"", ")", "\n", "dest", "=", "join", "(", "self", ".", "backup_folder", ",", "f'{self.strat.name}_{time_tag}'", ")", "\n", "\n", "# Move lead to error on next dumping so copy + delete", "\n", "shutil", ".", "copytree", "(", "self", ".", "strat_folder", ",", "dest", ")", "\n", "shutil", ".", "rmtree", "(", "self", ".", "strat_folder", ")", "\n", "\n", "# Create all necessary folders and ignore if already exist", "\n", "", "os", ".", "makedirs", "(", "self", ".", "strat_folder", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# Update infos of the task if using bagging", "\n", "strat_infos", "=", "self", ".", "strat", ".", "get_infos", "(", ")", "\n", "strat_infos", "[", "'n_bagging'", "]", "=", "self", ".", "n_bagging", "\n", "# if self.n_bagging is not None:", "\n", "#     strat_infos['name'] = f\"Bagged_{self.n_bagging}_{strat_infos['name']}\"", "\n", "\n", "_dump_yaml", "(", "self", ".", "task", ".", "get_infos", "(", ")", ",", "join", "(", "self", ".", "strat_folder", ",", "'task_infos.yml'", ")", ")", "\n", "_dump_yaml", "(", "strat_infos", ",", "join", "(", "self", ".", "strat_folder", ",", "'strat_infos.yml'", ")", ")", "\n", "\n", "", "else", ":", "\n", "# Create all necessary folders and ignore if already exist", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "task_folder", ",", "exist_ok", "=", "True", ")", "\n", "\n", "_dump_yaml", "(", "self", ".", "task", ".", "get_infos", "(", ")", ",", "join", "(", "self", ".", "task_folder", ",", "'task_infos.yml'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump_features": [[136, 139], ["os.path.join", "DumpHelper._dump_yaml", "list"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_yaml"], ["", "", "def", "_dump_features", "(", "self", ")", ":", "\n", "        ", "filepath", "=", "join", "(", "self", ".", "strat_folder", ",", "'features.yml'", ")", "\n", "_dump_yaml", "(", "list", "(", "self", ".", "task", ".", "X", ".", "columns", ")", ",", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._filepath": [[140, 142], ["os.path.join"], "methods", ["None"], ["", "def", "_filepath", "(", "self", ",", "filename", ")", ":", "\n", "        ", "return", "join", "(", "self", ".", "strat_folder", ",", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._load_content": [[143, 177], ["os.path.splitext", "os.path.exists", "dict", "open", "yaml.safe_load", "pandas.read_csv", "ValueError", "os.path.exists", "pandas.DataFrame"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_load_content", "(", "filepath", ")", ":", "\n", "        ", "\"\"\"Used to load a yaml or csv file as dict or df respectively.\n\n        Parameters\n        ----------\n        filepath : str\n            Path of the file to load\n\n        Returns\n        -------\n        dict or df\n            Depends on the extension present in the path:\n            If csv: returns df. If file doesn't exist, returns empty df.\n            If yml: returns dict. If file doesn't exist, returns empty dict.\n\n        \"\"\"", "\n", "_", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "filepath", ")", "\n", "\n", "if", "ext", "==", "'.yml'", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "filepath", ")", ":", "\n", "                ", "return", "dict", "(", ")", "\n", "# If exists", "\n", "", "with", "open", "(", "filepath", ",", "'r'", ")", "as", "file", ":", "\n", "                ", "return", "yaml", ".", "safe_load", "(", "file", ")", "\n", "\n", "", "", "elif", "ext", "==", "'.csv'", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "filepath", ")", ":", "\n", "                ", "return", "pd", ".", "DataFrame", "(", ")", "\n", "# If exists", "\n", "", "return", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ",", "dtype", "=", "str", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Extension {ext} not supported.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._append_fold": [[178, 220], ["DumpHelper._load_content", "isinstance", "DumpHelper._dump_yaml", "isinstance", "data.copy.copy.copy", "pandas.concat", "pandas.concat.to_csv", "isinstance", "ValueError"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._load_content", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_yaml"], ["", "", "@", "staticmethod", "\n", "def", "_append_fold", "(", "filepath", ",", "data", ",", "fold", "=", "None", ")", ":", "\n", "        ", "\"\"\"Dump data (df or dict) in a file while keeping track of the fold #.\n\n        Open or create a file and dump the data in it. If previous data has\n        been dumped for the same fold number, the newer one will replace it.\n        To keep track of the fold number, the data is stored in a dict with\n        fold number as key (if data is dict). If data is dataframe, an extra\n        fold columns is added and the dataframe is concatenated to the existing\n        after removing the existing data having the same fold number.\n\n        Parameters\n        ----------\n        filepath : str\n            Path of the file to dump the data in.\n        data : dict or pandas.DatFrame\n            The data to dump.\n        fold : int or None\n            The fold number of the data.\n\n        \"\"\"", "\n", "content", "=", "DumpHelper", ".", "_load_content", "(", "filepath", ")", "\n", "\n", "if", "isinstance", "(", "content", ",", "dict", ")", ":", "\n", "            ", "content", "[", "fold", "]", "=", "data", "\n", "_dump_yaml", "(", "content", ",", "filepath", ")", "\n", "\n", "", "elif", "isinstance", "(", "content", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "data", ",", "pd", ".", "DataFrame", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Dumping to csv require pandas df as data.'", ")", "\n", "\n", "# Remove previous results of same fold number", "\n", "", "if", "not", "content", ".", "empty", ":", "\n", "# Df is supposed to have fold column if not empty", "\n", "                ", "content", "=", "content", "[", "content", ".", "fold", "!=", "fold", "]", "\n", "\n", "# Add new results", "\n", "", "data", "=", "data", ".", "copy", "(", ")", "\n", "data", "[", "'fold'", "]", "=", "fold", "\n", "content", "=", "pd", ".", "concat", "(", "[", "content", ",", "data", "]", ")", "\n", "\n", "content", ".", "to_csv", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump": [[221, 225], ["DumpHelper.DumpHelper._filepath", "DumpHelper._append_fold"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._filepath", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._append_fold"], ["", "", "def", "_dump", "(", "self", ",", "data", ",", "filename", ",", "fold", "=", "None", ")", ":", "\n", "        ", "\"\"\"Wraper to dump data (dict or df) in a file.\"\"\"", "\n", "filepath", "=", "self", ".", "_filepath", "(", "filename", ")", "\n", "DumpHelper", ".", "_append_fold", "(", "filepath", ",", "data", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_prediction": [[226, 236], ["pandas.DataFrame", "DumpHelper.DumpHelper._dump"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_prediction", "(", "self", ",", "y_pred", ",", "y_true", ",", "fold", "=", "None", ",", "tag", "=", "None", ")", ":", "\n", "        ", "df", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'y_pred'", ":", "y_pred", ",", "\n", "'y_true'", ":", "y_true", ",", "\n", "}", ")", "\n", "\n", "if", "tag", "is", "None", ":", "\n", "            ", "tag", "=", "''", "\n", "\n", "", "self", ".", "_dump", "(", "df", ",", "f'{tag}_prediction.csv'", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_importances": [[237, 243], ["DumpHelper.DumpHelper._dump"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_importances", "(", "self", ",", "importances", ",", "fold", "=", "None", ",", "tag", "=", "None", ")", ":", "\n", "\n", "        ", "if", "tag", "is", "None", ":", "\n", "            ", "tag", "=", "''", "\n", "\n", "", "self", ".", "_dump", "(", "importances", ",", "f'{tag}_importances.csv'", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_mv_props": [[244, 250], ["DumpHelper.DumpHelper._dump"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_mv_props", "(", "self", ",", "mv_props", ",", "fold", "=", "None", ",", "tag", "=", "None", ")", ":", "\n", "\n", "        ", "if", "tag", "is", "None", ":", "\n", "            ", "tag", "=", "''", "\n", "\n", "", "self", ".", "_dump", "(", "mv_props", ",", "f'{tag}_mv_props.csv'", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_best_params": [[251, 253], ["DumpHelper.DumpHelper._dump"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_best_params", "(", "self", ",", "best_params", ",", "fold", "=", "None", ")", ":", "\n", "        ", "self", ".", "_dump", "(", "best_params", ",", "'best_params.yml'", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_cv_results": [[254, 256], ["DumpHelper.DumpHelper._dump"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_cv_results", "(", "self", ",", "cv_results", ",", "fold", "=", "None", ")", ":", "\n", "        ", "self", ".", "_dump", "(", "cv_results", ",", "'cv_results.yml'", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_roc": [[257, 264], ["pandas.DataFrame", "DumpHelper.DumpHelper._dump"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_roc", "(", "self", ",", "y_score", ",", "y_true", ",", "fold", "=", "None", ")", ":", "\n", "        ", "df", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'y_score'", ":", "y_score", ",", "\n", "'y_true'", ":", "y_true", "\n", "}", ")", "\n", "\n", "self", ".", "_dump", "(", "df", ",", "'roc.csv'", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_probas": [[265, 283], ["numpy.array", "numpy.array", "numpy.concatenate", "pandas.DataFrame", "DumpHelper.DumpHelper._dump", "range", "numpy.array.reshape"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_probas", "(", "self", ",", "y_true", ",", "probas", ",", "classes", "=", "None", ",", "fold", "=", "None", ",", "tag", "=", "None", ")", ":", "\n", "        ", "y_true", "=", "np", ".", "array", "(", "y_true", ")", "\n", "probas", "=", "np", ".", "array", "(", "probas", ")", "\n", "n_classes", "=", "probas", ".", "shape", "[", "1", "]", "\n", "\n", "if", "classes", "is", "None", ":", "\n", "            ", "classes", "=", "range", "(", "n_classes", ")", "\n", "\n", "", "cols", "=", "[", "'y_true'", "]", "+", "[", "f'proba_{c}'", "for", "c", "in", "classes", "]", "\n", "\n", "data", "=", "np", ".", "concatenate", "(", "[", "y_true", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "probas", "]", ",", "axis", "=", "1", ")", "\n", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "cols", ")", "\n", "\n", "if", "tag", "is", "None", ":", "\n", "            ", "tag", "=", "''", "\n", "\n", "", "self", ".", "_dump", "(", "df", ",", "f'{tag}_probas.csv'", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_learning_curve": [[292, 294], ["DumpHelper.DumpHelper._dump"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_learning_curve", "(", "self", ",", "learning_curve", ",", "fold", "=", "None", ")", ":", "\n", "        ", "self", ".", "_dump", "(", "learning_curve", ",", "'learning_curve.yml'", ",", "fold", "=", "fold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_pvals": [[295, 297], ["pvals.to_csv"], "methods", ["None"], ["", "def", "dump_pvals", "(", "self", ",", "pvals", ")", ":", "\n", "        ", "pvals", ".", "to_csv", "(", "self", ".", "task_folder", "+", "'pvals.csv'", ",", "header", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper.dump_times": [[298, 311], ["pandas.DataFrame", "DumpHelper.DumpHelper._dump"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.DumpHelper._dump"], ["", "def", "dump_times", "(", "self", ",", "imputation_time", ",", "tuning_time", ",", "imputation_pt", ",", "\n", "tuning_pt", ",", "fold", "=", "None", ",", "tag", "=", "None", ")", ":", "\n", "        ", "df", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'imputation_WCT'", ":", "[", "imputation_time", "]", ",", "\n", "'tuning_WCT'", ":", "[", "tuning_time", "]", ",", "\n", "'imputation_PT'", ":", "[", "imputation_pt", "]", ",", "\n", "'tuning_PT'", ":", "[", "tuning_pt", "]", ",", "\n", "}", ")", "\n", "\n", "if", "tag", "is", "None", ":", "\n", "            ", "tag", "=", "''", "\n", "\n", "", "self", ".", "_dump", "(", "df", ",", "f'{tag}_times.csv'", ",", "fold", "=", "fold", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_yaml": [[16, 20], ["DumpHelper.listify", "open", "file.write", "yaml.dump"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.listify", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.dump"], ["def", "_dump_yaml", "(", "data", ",", "filepath", ")", ":", "\n", "    ", "data", "=", "listify", "(", "data", ")", "\n", "with", "open", "(", "filepath", ",", "'w'", ")", "as", "file", ":", "\n", "        ", "file", ".", "write", "(", "yaml", ".", "dump", "(", "data", ",", "allow_unicode", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_infos": [[22, 34], ["item.get_infos", "DumpHelper._dump_yaml"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper._dump_yaml"], ["", "", "def", "_dump_infos", "(", "item", ",", "filepath", ")", ":", "\n", "    ", "\"\"\"Dump the infos at the given place.\n\n    Parameters\n    ----------\n    item : object\n        Object implementing  a get_infos method returning the infos to dump.\n    filepath : string\n        Path to the place to store the infos.\n    \"\"\"", "\n", "data", "=", "item", ".", "get_infos", "(", ")", "\n", "_dump_yaml", "(", "data", ",", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.listify": [[36, 65], ["isinstance", "isinstance", "DumpHelper.listify", "DumpHelper.listify", "isinstance", "d.tolist", "isinstance", "DumpHelper.listify", "isinstance", "d.items", "numpy.isscalar", "float", "callable"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.listify", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.listify", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.listify"], ["", "def", "listify", "(", "d", ")", ":", "\n", "    ", "\"\"\"Convert all numpy arrays contained in the dict to lists.\n\n    Parameters\n    ----------\n    d : dict\n\n    Returns\n    -------\n    dict\n        Same dict with numpy arrays converted to lists\n\n    \"\"\"", "\n", "if", "isinstance", "(", "d", ",", "list", ")", ":", "\n", "        ", "return", "[", "listify", "(", "v", ")", "for", "v", "in", "d", "]", "\n", "", "elif", "isinstance", "(", "d", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "listify", "(", "d", ".", "tolist", "(", ")", ")", "\n", "", "elif", "isinstance", "(", "d", ",", "dict", ")", ":", "\n", "        ", "return", "{", "k", ":", "listify", "(", "v", ")", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", "}", "\n", "", "elif", "isinstance", "(", "d", ",", "int", ")", ":", "\n", "        ", "return", "d", "\n", "", "elif", "isinstance", "(", "d", ",", "str", ")", ":", "\n", "        ", "return", "d", "\n", "", "elif", "np", ".", "isscalar", "(", "d", ")", ":", "\n", "        ", "return", "float", "(", "d", ")", "\n", "", "elif", "callable", "(", "d", ")", ":", "\n", "        ", "return", "d", ".", "__name__", "\n", "", "else", ":", "\n", "        ", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.DumpHelper.get_tag": [[67, 71], ["None"], "function", ["None"], ["", "", "def", "get_tag", "(", "RS", ",", "T", ")", ":", "\n", "    ", "RS_tag", "=", "''", "if", "RS", "is", "None", "else", "f'RS{RS}_'", "\n", "T_tag", "=", "''", "if", "T", "is", "None", "else", "f'T{T}_'", "\n", "return", "RS_tag", "+", "T_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.__init__.run": [[14, 44], ["isinstance", "tasks.tasks.get", "logger.info", "logger.info", "train.train", "int", "int", "list", "strategies.strategies.keys"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.train.train", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], []], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.__init__.aggregate_results": [[78, 81], ["PlotHelper.PlotHelper", "PlotHelper.PlotHelper.dump"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.dump"], []], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.__init__": [[22, 86], ["root_folder.rstrip.rstrip.rstrip", "os.walk", "os.path.isdir", "ValueError", "os.path.relpath", "os.path.relpath", "rel_dir_path.split", "rel_file_path.split", "dict", "PlotHelper.PlotHelper.existing_sizes", "d.setdefault.setdefault.setdefault", "d.setdefault.setdefault.setdefault", "PlotHelper.PlotHelper._reference_score.get", "PlotHelper.PlotHelper.databases", "abs_dirpaths.append", "abs_filepaths.append", "dict", "PlotHelper.PlotHelper.get", "PlotHelper.PlotHelper.tasks", "dict", "PlotHelper.PlotHelper.availale_methods_by_size", "PlotHelper.PlotHelper._is_reference_method", "PlotHelper.PlotHelper.score"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.existing_sizes", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.databases", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.tasks", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.availale_methods_by_size", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._is_reference_method", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.score"], ["def", "__init__", "(", "self", ",", "root_folder", ",", "rename", "=", "{", "}", ",", "reference_method", "=", "None", ")", ":", "\n", "        ", "\"\"\"Init.\"\"\"", "\n", "# Stepe 1: Check and register root_path", "\n", "root_folder", "=", "root_folder", ".", "rstrip", "(", "'/'", ")", "# Remove trailing '/'", "\n", "self", ".", "root_folder", "=", "root_folder", "\n", "self", ".", "_rename", "=", "rename", "\n", "self", ".", "_reference_method", "=", "reference_method", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "root_folder", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f'No dir at specified path: {self.root_folder}'", ")", "\n", "\n", "# Step 2: Get the relative path of all subdirs in the structure", "\n", "", "walk", "=", "os", ".", "walk", "(", "self", ".", "root_folder", ")", "\n", "\n", "abs_dirpaths", "=", "[", "]", "\n", "abs_filepaths", "=", "[", "]", "\n", "for", "root", ",", "dirnames", ",", "filenames", "in", "walk", ":", "\n", "            ", "if", "dirnames", ":", "\n", "                ", "for", "dirname", "in", "dirnames", ":", "\n", "                    ", "abs_dirpaths", ".", "append", "(", "f'{root}/{dirname}'", ")", "\n", "", "", "if", "filenames", ":", "\n", "                ", "for", "filename", "in", "filenames", ":", "\n", "                    ", "abs_filepaths", ".", "append", "(", "f'{root}/{filename}'", ")", "\n", "\n", "", "", "", "rel_dir_paths", "=", "[", "os", ".", "path", ".", "relpath", "(", "p", ",", "root_folder", ")", "for", "p", "in", "abs_dirpaths", "]", "\n", "rel_file_paths", "=", "[", "os", ".", "path", ".", "relpath", "(", "p", ",", "root_folder", ")", "for", "p", "in", "abs_filepaths", "]", "\n", "\n", "# Step 3.1: Convert relative paths to nested python dictionnary (dirs)", "\n", "nested_dir_dict", "=", "{", "}", "\n", "\n", "for", "rel_dir_path", "in", "rel_dir_paths", ":", "\n", "            ", "d", "=", "nested_dir_dict", "\n", "for", "x", "in", "rel_dir_path", ".", "split", "(", "'/'", ")", ":", "\n", "                ", "d", "=", "d", ".", "setdefault", "(", "x", ",", "{", "}", ")", "\n", "\n", "# Step 3.2: Convert relative paths to nested python dictionnary (files)", "\n", "", "", "nested_file_dict", "=", "{", "}", "\n", "\n", "for", "rel_file_path", "in", "rel_file_paths", ":", "\n", "            ", "d", "=", "nested_file_dict", "\n", "for", "x", "in", "rel_file_path", ".", "split", "(", "'/'", ")", ":", "\n", "                ", "d", "=", "d", ".", "setdefault", "(", "x", ",", "{", "}", ")", "\n", "\n", "# Step 4: Fill the class attributes with the nested dicts", "\n", "", "", "self", ".", "_nested_dir_dict", "=", "nested_dir_dict", "\n", "self", ".", "_nested_file_dict", "=", "nested_file_dict", "\n", "\n", "# Step 5: Compute scores for reference method", "\n", "if", "self", ".", "_reference_method", ":", "\n", "            ", "self", ".", "_reference_score", "=", "dict", "(", ")", "\n", "for", "size", "in", "self", ".", "existing_sizes", "(", ")", ":", "\n", "                ", "scores_size", "=", "self", ".", "_reference_score", ".", "get", "(", "size", ",", "dict", "(", ")", ")", "\n", "for", "db", "in", "self", ".", "databases", "(", ")", ":", "\n", "                    ", "scores", "=", "scores_size", ".", "get", "(", "db", ",", "dict", "(", ")", ")", "\n", "for", "t", "in", "self", ".", "tasks", "(", "db", ")", ":", "\n", "                        ", "score", "=", "None", "\n", "for", "m", "in", "self", ".", "availale_methods_by_size", "(", "db", ",", "t", ",", "size", ")", ":", "\n", "                            ", "if", "self", ".", "_is_reference_method", "(", "m", ")", ":", "\n", "                                ", "score", "=", "self", ".", "score", "(", "db", ",", "t", ",", "m", ",", "size", ",", "mean", "=", "True", ")", "\n", "break", "\n", "", "", "scores", "[", "t", "]", "=", "score", "\n", "", "scores_size", "[", "db", "]", "=", "scores", "\n", "\n", "", "self", ".", "_reference_score", "[", "size", "]", "=", "scores_size", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.databases": [[87, 91], ["ndd.keys", "PlotHelper.PlotHelper.tasks"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.tasks"], ["", "", "", "def", "databases", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the databases found in the root folder.\"\"\"", "\n", "ndd", "=", "self", ".", "_nested_dir_dict", "\n", "return", "[", "db", "for", "db", "in", "ndd", ".", "keys", "(", ")", "if", "self", ".", "tasks", "(", "db", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.tasks": [[92, 96], ["ndd[].keys", "PlotHelper.PlotHelper.methods"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.methods"], ["", "def", "tasks", "(", "self", ",", "db", ")", ":", "\n", "        ", "\"\"\"Return the tasks related to a given database.\"\"\"", "\n", "ndd", "=", "self", ".", "_nested_dir_dict", "\n", "return", "[", "t", "for", "t", "in", "ndd", "[", "db", "]", ".", "keys", "(", ")", "if", "self", ".", "methods", "(", "db", ",", "t", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.methods": [[97, 101], ["PlotHelper.PlotHelper._is_valid_method"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._is_valid_method"], ["", "def", "methods", "(", "self", ",", "db", ",", "t", ")", ":", "\n", "        ", "\"\"\"Return the methods used by a given task.\"\"\"", "\n", "ndd", "=", "self", ".", "_nested_dir_dict", "\n", "return", "[", "m", "for", "m", "in", "ndd", "[", "db", "]", "[", "t", "]", "if", "self", ".", "_is_valid_method", "(", "db", ",", "t", ",", "m", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._is_valid_method": [[102, 114], ["next", "os.path.exists", "os.walk", "len"], "methods", ["None"], ["", "def", "_is_valid_method", "(", "self", ",", "db", ",", "t", ",", "m", ")", ":", "\n", "# Must contain either Classification or Regression", "\n", "        ", "if", "'Regression'", "not", "in", "m", "and", "'Classification'", "not", "in", "m", ":", "\n", "            ", "return", "False", "\n", "\n", "", "path", "=", "f'{self.root_folder}/{db}/{t}/{m}/'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "_", ",", "_", ",", "filenames", "=", "next", "(", "os", ".", "walk", "(", "path", ")", ")", "\n", "\n", "return", "len", "(", "filenames", ")", ">", "1", "# always strat_infos.yml in m folder", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._is_reference_method": [[115, 121], ["PlotHelper.PlotHelper.short_method_name", "hasattr", "PlotHelper.PlotHelper.rename"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.short_method_name", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["", "def", "_is_reference_method", "(", "self", ",", "m", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "'_reference_method'", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "m", "=", "self", ".", "short_method_name", "(", "m", ")", "\n", "return", "self", ".", "rename", "(", "m", ")", "==", "self", ".", "_reference_method", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.short_method_name": [[122, 131], ["m.split", "len", "m.split", "len", "ValueError"], "methods", ["None"], ["", "def", "short_method_name", "(", "self", ",", "m", ")", ":", "\n", "        ", "\"\"\"Return the suffix from the method name.\"\"\"", "\n", "s", "=", "m", ".", "split", "(", "'Regression'", ")", "\n", "if", "len", "(", "s", ")", "==", "1", ":", "\n", "            ", "s", "=", "m", ".", "split", "(", "'Classification'", ")", "\n", "", "if", "len", "(", "s", ")", "==", "1", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unable to find short method name of {m}'", ")", "\n", "\n", "", "return", "s", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename_str": [[132, 135], ["rename_dict.get"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], ["", "@", "staticmethod", "\n", "def", "rename_str", "(", "rename_dict", ",", "s", ")", ":", "\n", "        ", "return", "rename_dict", ".", "get", "(", "s", ",", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename": [[136, 139], ["PlotHelper.PlotHelper.rename_str"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename_str"], ["", "def", "rename", "(", "self", ",", "s", ")", ":", "\n", "        ", "\"\"\"Rename a string.\"\"\"", "\n", "return", "self", ".", "rename_str", "(", "self", ".", "_rename", ",", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.existing_methods": [[140, 154], ["set", "PlotHelper.PlotHelper.databases", "PlotHelper.PlotHelper.tasks", "PlotHelper.PlotHelper.methods", "m.split", "set.add", "len", "m.split"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.databases", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.tasks", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.methods"], ["", "def", "existing_methods", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the existing methods used by the tasks in the root_folder.\"\"\"", "\n", "methods", "=", "set", "(", ")", "\n", "\n", "for", "db", "in", "self", ".", "databases", "(", ")", ":", "\n", "            ", "for", "t", "in", "self", ".", "tasks", "(", "db", ")", ":", "\n", "                ", "for", "m", "in", "self", ".", "methods", "(", "db", ",", "t", ")", ":", "\n", "                    ", "s", "=", "m", ".", "split", "(", "'Regression'", ")", "\n", "if", "len", "(", "s", ")", "==", "1", ":", "\n", "                        ", "s", "=", "m", ".", "split", "(", "'Classification'", ")", "\n", "", "suffix", "=", "s", "[", "1", "]", "\n", "methods", ".", "add", "(", "suffix", ")", "\n", "\n", "", "", "", "return", "methods", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.existing_sizes": [[155, 173], ["set", "PlotHelper.PlotHelper.databases", "list", "list.sort", "PlotHelper.PlotHelper.tasks", "PlotHelper.PlotHelper.methods", "[].keys", "filename.split", "len", "list.add"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.databases", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.tasks", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.methods", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], ["", "def", "existing_sizes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the existing training sizes found in the root_folder.\"\"\"", "\n", "sizes", "=", "set", "(", ")", "\n", "nfd", "=", "self", ".", "_nested_file_dict", "\n", "\n", "for", "db", "in", "self", ".", "databases", "(", ")", ":", "\n", "            ", "for", "t", "in", "self", ".", "tasks", "(", "db", ")", ":", "\n", "                ", "for", "m", "in", "self", ".", "methods", "(", "db", ",", "t", ")", ":", "\n", "                    ", "for", "filename", "in", "nfd", "[", "db", "]", "[", "t", "]", "[", "m", "]", ".", "keys", "(", ")", ":", "\n", "                        ", "s", "=", "filename", ".", "split", "(", "'_prediction.csv'", ")", "\n", "if", "len", "(", "s", ")", ">", "1", ":", "# Pattern found", "\n", "                            ", "size", "=", "s", "[", "0", "]", "# size is the first part", "\n", "sizes", ".", "add", "(", "size", ")", "\n", "\n", "", "", "", "", "", "sizes", "=", "list", "(", "sizes", ")", "\n", "sizes", ".", "sort", "(", "key", "=", "int", ")", "\n", "\n", "return", "sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.score": [[174, 248], ["print", "dict", "pandas.read_csv.groupby", "os.path.exists", "ValueError", "open", "yaml.safe_load", "pandas.read_csv", "scorer", "numpy.mean", "dict", "list", "dict", "numpy.mean.values"], "methods", ["None"], ["", "def", "score", "(", "self", ",", "db", ",", "t", ",", "m", ",", "size", ",", "true_class", "=", "'1'", ",", "mean", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute score of a given db, task, method, size.\n\n        Parameters\n        ----------\n        db : str\n            Name of db folder.\n        t : str\n            Name of task folder.\n        m : str\n            Name of method folder.\n        size : str\n            Size of the train set to load.\n        true_class : str\n            Name of the true class (if classification).\n        mean : bool\n            Whether to compute the mean of the score or return all scores.\n\n        Return\n        ------\n        scores : dict or float\n            If mean is False: return dict of scores of each fold.\n            Else, return a float, mean of scores on all folds.\n\n        \"\"\"", "\n", "print", "(", "f'Compute score of {db}/{t}/{m}/{size}'", ")", "\n", "method_path", "=", "f'{self.root_folder}/{db}/{t}/{m}/'", "\n", "strat_infos_path", "=", "method_path", "+", "'strat_infos.yml'", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "strat_infos_path", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f'Path {strat_infos_path} doesn\\'t exist.'", ")", "\n", "\n", "", "with", "open", "(", "strat_infos_path", ",", "'r'", ")", "as", "file", ":", "\n", "            ", "strat_infos", "=", "yaml", ".", "safe_load", "(", "file", ")", "\n", "\n", "", "is_classif", "=", "strat_infos", "[", "'classification'", "]", "\n", "\n", "if", "is_classif", ":", "\n", "            ", "scorer", "=", "roc_auc_score", "\n", "scorer_name", "=", "'roc_auc_score'", "\n", "df_path", "=", "f'{method_path}{size}_probas.csv'", "\n", "y_true_col", "=", "'y_true'", "\n", "y_col", "=", "f'proba_{true_class}'", "\n", "", "else", ":", "\n", "            ", "scorer", "=", "r2_score", "\n", "scorer_name", "=", "'r2_score'", "\n", "df_path", "=", "f'{method_path}{size}_prediction.csv'", "\n", "y_true_col", "=", "'y_true'", "\n", "y_col", "=", "'y_pred'", "\n", "\n", "", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "df_path", ")", "\n", "", "except", "pd", ".", "errors", ".", "EmptyDataError", ":", "\n", "            ", "if", "mean", ":", "\n", "                ", "return", "None", ",", "None", "\n", "", "return", "dict", "(", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "            ", "if", "mean", ":", "\n", "                ", "return", "None", ",", "None", "\n", "", "return", "dict", "(", ")", ",", "None", "\n", "\n", "", "scores", "=", "dict", "(", ")", "\n", "\n", "for", "fold", ",", "df_gb", "in", "df", ".", "groupby", "(", "'fold'", ")", ":", "\n", "            ", "y_true", "=", "df_gb", "[", "y_true_col", "]", "\n", "y", "=", "df_gb", "[", "y_col", "]", "\n", "\n", "score", "=", "scorer", "(", "y_true", ",", "y", ")", "\n", "scores", "[", "fold", "]", "=", "score", "\n", "\n", "", "if", "mean", ":", "\n", "            ", "scores", "=", "np", ".", "mean", "(", "list", "(", "scores", ".", "values", "(", ")", ")", ")", "\n", "\n", "", "return", "scores", ",", "scorer_name", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.times": [[249, 304], ["print", "dict", "dict", "dict", "dict", "pandas.read_csv.groupby", "pandas.read_csv", "float", "float", "float", "float", "float", "float", "len", "len"], "methods", ["None"], ["", "def", "times", "(", "self", ",", "db", ",", "t", ",", "m", ",", "size", ")", ":", "\n", "        ", "\"\"\"Compute time of a given db, task, method, size.\n\n        Parameters\n        ----------\n        db : str\n            Name of db folder.\n        t : str\n            Name of task folder.\n        m : str\n            Name of method folder.\n        size : str\n            Size of the train set to load.\n\n        Return\n        ------\n        imputation_times : dict\n            Dict of imputation time of each fold.\n        tuning_times : dict\n            Dict of tuning time of each fold.\n\n\n        \"\"\"", "\n", "print", "(", "f'Compute time of {db}/{t}/{m}/{size}'", ")", "\n", "df_path", "=", "f'{self.root_folder}/{db}/{t}/{m}/{size}_times.csv'", "\n", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "df_path", ")", "\n", "", "except", "pd", ".", "errors", ".", "EmptyDataError", ":", "\n", "            ", "return", "None", ",", "None", "\n", "\n", "", "cols", "=", "df", ".", "columns", "\n", "imputation_wct", "=", "dict", "(", ")", "\n", "tuning_wct", "=", "dict", "(", ")", "\n", "imputation_pt", "=", "dict", "(", ")", "\n", "tuning_pt", "=", "dict", "(", ")", "\n", "\n", "for", "fold", ",", "df_gb", "in", "df", ".", "groupby", "(", "'fold'", ")", ":", "\n", "\n", "            ", "if", "'imputation_PT'", "in", "cols", "and", "'imputation_WCT'", "in", "cols", ":", "\n", "                ", "imputation_wct", "[", "fold", "]", "=", "float", "(", "df_gb", "[", "'imputation_WCT'", "]", ")", "\n", "tuning_wct", "[", "fold", "]", "=", "float", "(", "df_gb", "[", "'tuning_WCT'", "]", ")", "\n", "imputation_pt", "[", "fold", "]", "=", "float", "(", "df_gb", "[", "'imputation_PT'", "]", ")", "\n", "tuning_pt", "[", "fold", "]", "=", "float", "(", "df_gb", "[", "'tuning_PT'", "]", ")", "\n", "\n", "", "else", ":", "\n", "                ", "assert", "len", "(", "df_gb", "[", "'imputation'", "]", ")", "==", "1", "\n", "assert", "len", "(", "df_gb", "[", "'tuning'", "]", ")", "==", "1", "\n", "imputation_wct", "[", "fold", "]", "=", "float", "(", "df_gb", "[", "'imputation'", "]", ")", "\n", "tuning_wct", "[", "fold", "]", "=", "float", "(", "df_gb", "[", "'tuning'", "]", ")", "\n", "\n", "", "", "return", "{", "\n", "'imputation_WCT'", ":", "imputation_wct", ",", "\n", "'tuning_WCT'", ":", "tuning_wct", ",", "\n", "'imputation_PT'", ":", "imputation_pt", ",", "\n", "'tuning_PT'", ":", "tuning_pt", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.absolute_scores": [[306, 312], ["PlotHelper.PlotHelper.score"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.score"], ["", "def", "absolute_scores", "(", "self", ",", "db", ",", "t", ",", "methods", ",", "size", ",", "mean", "=", "True", ")", ":", "\n", "        ", "\"\"\"Get absolute scores of given methods for (db, task, size).\n\n        Size and methods must exist (not check performed).\n        \"\"\"", "\n", "return", "{", "m", ":", "self", ".", "score", "(", "db", ",", "t", ",", "m", ",", "size", ",", "mean", "=", "mean", ")", "for", "m", "in", "methods", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.availale_methods_by_size": [[313, 325], ["PlotHelper.PlotHelper.methods", "set", "set.add"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.methods"], ["", "def", "availale_methods_by_size", "(", "self", ",", "db", ",", "t", ",", "size", ")", ":", "\n", "        ", "\"\"\"Get the methods available for a given size.\"\"\"", "\n", "methods", "=", "self", ".", "methods", "(", "db", ",", "t", ")", "\n", "nfd", "=", "self", ".", "_nested_file_dict", "\n", "available_methods", "=", "set", "(", ")", "\n", "\n", "for", "m", "in", "methods", ":", "\n", "            ", "for", "filename", "in", "nfd", "[", "db", "]", "[", "t", "]", "[", "m", "]", ":", "\n", "                ", "if", "f'{size}_'", "in", "filename", ":", "\n", "                    ", "available_methods", ".", "add", "(", "m", ")", "\n", "\n", "", "", "", "return", "available_methods", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._y": [[326, 332], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_y", "(", "m", ",", "db", ",", "n_m", ",", "n_db", ")", ":", "\n", "        ", "\"\"\"Get y-axis position given # db and # m and n_db and n_m.\"\"\"", "\n", "assert", "0", "<=", "m", "<", "n_m", "\n", "assert", "0", "<=", "db", "<", "n_db", "\n", "return", "n_m", "-", "m", "-", "(", "db", "+", "1", ")", "/", "(", "n_db", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._add_relative_value": [[333, 365], ["df.groupby", "df.groupby.apply", "df[].mean", "float", "df[].mean", "df[].std"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_add_relative_value", "(", "df", ",", "value", ",", "how", ",", "reference_method", "=", "None", ")", ":", "\n", "        ", "assert", "value", "in", "df", ".", "columns", "\n", "dfgb", "=", "df", ".", "groupby", "(", "[", "'size'", ",", "'db'", ",", "'task'", "]", ")", "\n", "\n", "def", "rel_value", "(", "df", ")", ":", "\n", "            ", "if", "reference_method", "is", "None", ":", "# use mean", "\n", "                ", "ref_value", "=", "df", "[", "value", "]", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                ", "methods", "=", "df", "[", "'method'", "]", "\n", "ref_value", "=", "float", "(", "df", ".", "loc", "[", "methods", "==", "reference_method", ",", "value", "]", ")", "\n", "df", "[", "'reference'", "]", "=", "reference_method", "\n", "df", "[", "f'referece_{value}'", "]", "=", "ref_value", "\n", "\n", "", "if", "how", "==", "'mean'", ":", "\n", "                ", "normalization", "=", "df", "[", "value", "]", ".", "mean", "(", ")", "\n", "", "elif", "how", "==", "'std'", ":", "\n", "                ", "normalization", "=", "df", "[", "value", "]", ".", "std", "(", ")", "\n", "", "elif", "how", "==", "'no-norm'", ":", "\n", "                ", "normalization", "=", "1", "\n", "", "elif", "how", "==", "'abs'", ":", "\n", "                ", "ref_value", "=", "0", "\n", "normalization", "=", "1", "\n", "", "elif", "how", "==", "'log'", ":", "\n", "                ", "normalization", "=", "ref_value", "\n", "ref_value", "=", "0", "\n", "\n", "", "df", "[", "f'relative_{value}'", "]", "=", "(", "df", "[", "value", "]", "-", "ref_value", ")", "/", "normalization", "\n", "\n", "return", "df", "\n", "\n", "", "return", "dfgb", ".", "apply", "(", "rel_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._export": [[366, 382], ["PlotHelper.PlotHelper.existing_sizes", "os.path.isdir", "os.makedirs", "PlotHelper.PlotHelper.tasks", "shutil.rmtree", "PlotHelper.PlotHelper.availale_methods_by_size", "print", "subpath.replace", "shutil.copyfile"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.existing_sizes", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.tasks", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.availale_methods_by_size"], ["", "def", "_export", "(", "self", ",", "db", ",", "id", ")", ":", "\n", "        ", "sizes", "=", "self", ".", "existing_sizes", "(", ")", "\n", "dump_dir", "=", "f'sandbox/compare_{id}/{db}/'", "\n", "if", "os", ".", "path", ".", "isdir", "(", "dump_dir", ")", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "dump_dir", ")", "\n", "", "os", ".", "makedirs", "(", "dump_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "for", "t", "in", "self", ".", "tasks", "(", "db", ")", ":", "\n", "            ", "for", "size", "in", "sizes", ":", "\n", "                ", "methods", "=", "self", ".", "availale_methods_by_size", "(", "db", ",", "t", ",", "size", ")", "\n", "for", "m", "in", "methods", ":", "\n", "                    ", "subpath", "=", "f'{db}/{t}/{m}/{size}_prediction.csv'", "\n", "df_path", "=", "f'{self.root_folder}/{subpath}'", "\n", "print", "(", "df_path", ")", "\n", "r_subpath", "=", "subpath", ".", "replace", "(", "'/'", ",", "'_'", ")", "\n", "shutil", ".", "copyfile", "(", "df_path", ",", "dump_dir", "+", "r_subpath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.dump": [[383, 464], ["PlotHelper.PlotHelper.existing_sizes", "enumerate", "pandas.DataFrame().astype", "pandas.DataFrame().astype.sort_values", "print", "pandas.DataFrame().astype.to_csv", "ValueError", "PlotHelper.PlotHelper.databases", "str", "PlotHelper.PlotHelper.tasks", "pandas.DataFrame", "str", "PlotHelper.PlotHelper.availale_methods_by_size", "PlotHelper.PlotHelper.absolute_scores", "PlotHelper.PlotHelper.items", "PlotHelper.PlotHelper.times", "X_shape.replace.replace.replace", "X_shape.replace.replace.replace", "X_shape.replace.replace.replace", "X_shape.replace.replace.split", "scores.items", "os.path.exists", "ValueError", "open", "yaml.safe_load", "os.path.exists", "ValueError", "open", "yaml.safe_load", "re.search", "re.search.group", "PlotHelper.PlotHelper.short_method_name", "PlotHelper.PlotHelper.rename", "times[].get", "times[].get", "rows.append", "print", "m.split", "print", "m.split"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.existing_sizes", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.databases", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.tasks", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.availale_methods_by_size", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.absolute_scores", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.times", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.short_method_name", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], ["", "", "", "", "def", "dump", "(", "self", ",", "filepath", ",", "n", "=", "None", ")", ":", "\n", "        ", "\"\"\"Scan results in result_folder and compute scores.\"\"\"", "\n", "existing_sizes", "=", "self", ".", "existing_sizes", "(", ")", "\n", "if", "n", "is", "not", "None", "and", "str", "(", "n", ")", "not", "in", "existing_sizes", ":", "\n", "            ", "raise", "ValueError", "(", "f'Asked n={n} not in existing sizes: {existing_sizes}'", ")", "\n", "", "elif", "n", "is", "not", "None", ":", "\n", "            ", "sizes", "=", "[", "str", "(", "n", ")", "]", "\n", "", "else", ":", "\n", "            ", "sizes", "=", "existing_sizes", "\n", "\n", "", "rows", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "sizes", ")", ":", "\n", "            ", "for", "db", "in", "self", ".", "databases", "(", ")", ":", "\n", "                ", "for", "t", "in", "self", ".", "tasks", "(", "db", ")", ":", "\n", "                    ", "methods", "=", "self", ".", "availale_methods_by_size", "(", "db", ",", "t", ",", "size", ")", "\n", "abs_scores", "=", "self", ".", "absolute_scores", "(", "db", ",", "t", ",", "methods", ",", "size", ",", "\n", "mean", "=", "False", ")", "\n", "for", "m", ",", "(", "scores", ",", "scorer", ")", "in", "abs_scores", ".", "items", "(", ")", ":", "\n", "                        ", "times", "=", "self", ".", "times", "(", "db", ",", "t", ",", "m", ",", "size", ")", "\n", "\n", "method_path", "=", "f'{self.root_folder}/{db}/{t}/{m}/'", "\n", "\n", "# Load strat info", "\n", "strat_infos_path", "=", "method_path", "+", "'strat_infos.yml'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "strat_infos_path", ")", ":", "\n", "                            ", "raise", "ValueError", "(", "f'Path {strat_infos_path} doesn\\'t exist.'", ")", "\n", "", "with", "open", "(", "strat_infos_path", ",", "'r'", ")", "as", "file", ":", "\n", "                            ", "strat_infos", "=", "yaml", ".", "safe_load", "(", "file", ")", "\n", "", "is_classif", "=", "strat_infos", "[", "'classification'", "]", "\n", "task_type", "=", "'Classification'", "if", "is_classif", "else", "'Regression'", "\n", "\n", "# Load task info", "\n", "task_infos_path", "=", "method_path", "+", "'task_infos.yml'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "task_infos_path", ")", ":", "\n", "                            ", "raise", "ValueError", "(", "f'Path {task_infos_path} doesn\\'t exist.'", ")", "\n", "", "with", "open", "(", "task_infos_path", ",", "'r'", ")", "as", "file", ":", "\n", "                            ", "task_infos", "=", "yaml", ".", "safe_load", "(", "file", ")", "\n", "", "X_shape", "=", "task_infos", "[", "'X.shape'", "]", "\n", "# Convert representation of tuple (str) to tuple", "\n", "X_shape", "=", "X_shape", ".", "replace", "(", "'('", ",", "''", ")", "\n", "X_shape", "=", "X_shape", ".", "replace", "(", "')'", ",", "''", ")", "\n", "X_shape", "=", "X_shape", ".", "replace", "(", "' '", ",", "''", ")", "\n", "n", ",", "p", "=", "X_shape", ".", "split", "(", "','", ")", "\n", "\n", "for", "fold", ",", "s", "in", "scores", ".", "items", "(", ")", ":", "\n", "                            ", "if", "s", "is", "None", ":", "\n", "                                ", "print", "(", "f'Skipping {db}/{t}/{m}'", ")", "\n", "continue", "\n", "", "if", "'Regression'", "in", "m", ":", "\n", "                                ", "tag", "=", "m", ".", "split", "(", "'Regression'", ")", "[", "0", "]", "\n", "", "elif", "'Classification'", "in", "m", ":", "\n", "                                ", "tag", "=", "m", ".", "split", "(", "'Classification'", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "                                ", "tag", "=", "'Error while retrieving tag'", "\n", "print", "(", "tag", ")", "\n", "", "params", "=", "re", ".", "search", "(", "'RS(.+?)_T(.+?)_'", ",", "tag", ")", "\n", "T", "=", "params", ".", "group", "(", "2", ")", "\n", "short_m", "=", "self", ".", "short_method_name", "(", "m", ")", "\n", "renamed_m", "=", "self", ".", "rename", "(", "short_m", ")", "\n", "selection", "=", "'ANOVA'", "if", "'_pvals'", "in", "t", "else", "'manual'", "\n", "imp_wct", "=", "times", "[", "'imputation_WCT'", "]", "[", "fold", "]", "\n", "tun_wct", "=", "times", "[", "'tuning_WCT'", "]", "[", "fold", "]", "\n", "imp_pt", "=", "times", "[", "'imputation_PT'", "]", ".", "get", "(", "fold", ",", "None", ")", "\n", "tun_pt", "=", "times", "[", "'tuning_PT'", "]", ".", "get", "(", "fold", ",", "None", ")", "\n", "\n", "rows", ".", "append", "(", "\n", "(", "size", ",", "db", ",", "t", ",", "renamed_m", ",", "T", ",", "fold", ",", "s", ",", "scorer", ",", "selection", ",", "n", ",", "p", ",", "task_type", ",", "imp_wct", ",", "tun_wct", ",", "imp_pt", ",", "tun_pt", ")", "\n", ")", "\n", "\n", "", "", "", "", "", "cols", "=", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'method'", ",", "'trial'", ",", "'fold'", ",", "'score'", ",", "'scorer'", ",", "'selection'", ",", "'n'", ",", "'p'", ",", "'type'", ",", "'imputation_WCT'", ",", "'tuning_WCT'", ",", "'imputation_PT'", ",", "'tuning_PT'", "]", "\n", "\n", "df", "=", "pd", ".", "DataFrame", "(", "rows", ",", "columns", "=", "cols", ")", ".", "astype", "(", "{", "\n", "'size'", ":", "int", ",", "\n", "'trial'", ":", "int", ",", "\n", "'fold'", ":", "int", ",", "\n", "}", ")", "\n", "df", ".", "sort_values", "(", "by", "=", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'method'", ",", "'trial'", ",", "'fold'", "]", ",", "\n", "inplace", "=", "True", ",", "ignore_index", "=", "True", ")", "\n", "print", "(", "df", ")", "\n", "\n", "df", ".", "to_csv", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.get_task_description": [[465, 557], ["prediction.df_utils.aggregate", "print", "pandas.concat.groupby", "pd.concat.groupby.agg", "pandas.concat.reset_index", "df[].astype", "df[].astype", "df[].astype", "df[].astype", "df[].round", "df[].astype", "df[].astype", "pandas.concat.drop", "df[].replace", "df[].replace", "df[].replace", "pandas.concat.rename", "pandas.concat.set_index", "os.path.exists", "isinstance", "pandas.read_csv", "df[].fillna", "df[].fillna", "pandas.read_csv", "pandas.concat", "pandas.DataFrame", "pandas.DataFrame.to_csv", "f.capitalize"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["", "@", "staticmethod", "\n", "def", "get_task_description", "(", "filepath", ")", ":", "\n", "        ", "\"\"\"Build and dump a csv that will explain each task once completed.\"\"\"", "\n", "if", "not", "isinstance", "(", "filepath", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "df", "=", "filepath", "\n", "\n", "", "df", "=", "aggregate", "(", "df", ",", "'score'", ")", "\n", "\n", "print", "(", "df", ")", "\n", "\n", "dfgb", "=", "df", ".", "groupby", "(", "[", "'db'", ",", "'task'", "]", ")", "\n", "df", "=", "dfgb", ".", "agg", "(", "{", "\n", "'score'", ":", "'mean'", ",", "\n", "# 'n_trials': 'sum',", "\n", "# 'n_folds': 'sum',", "\n", "'scorer'", ":", "assert_equal", ",", "# first and assert equal", "\n", "'selection'", ":", "assert_equal", ",", "\n", "'n'", ":", "assert_equal", ",", "\n", "'p'", ":", "assert_equal", ",", "\n", "'type'", ":", "assert_equal", ",", "\n", "'imputation_WCT'", ":", "'mean'", ",", "\n", "'tuning_WCT'", ":", "'mean'", ",", "\n", "'imputation_PT'", ":", "'mean'", ",", "\n", "'tuning_PT'", ":", "'mean'", ",", "\n", "}", ")", "\n", "\n", "df", "=", "df", ".", "reset_index", "(", ")", "\n", "\n", "# Sum times", "\n", "df", "[", "'total_PT'", "]", "=", "df", "[", "'imputation_PT'", "]", ".", "fillna", "(", "0", ")", "+", "df", "[", "'tuning_PT'", "]", "\n", "df", "[", "'total_WCT'", "]", "=", "df", "[", "'imputation_WCT'", "]", ".", "fillna", "(", "0", ")", "+", "df", "[", "'tuning_WCT'", "]", "\n", "\n", "# Round scores", "\n", "df", "[", "'imputation_PT'", "]", "=", "df", "[", "'imputation_PT'", "]", ".", "astype", "(", "int", ")", "\n", "df", "[", "'imputation_WCT'", "]", "=", "df", "[", "'imputation_WCT'", "]", ".", "astype", "(", "int", ")", "\n", "df", "[", "'tuning_PT'", "]", "=", "df", "[", "'tuning_PT'", "]", ".", "astype", "(", "int", ")", "\n", "df", "[", "'tuning_WCT'", "]", "=", "df", "[", "'tuning_WCT'", "]", ".", "astype", "(", "int", ")", "\n", "df", "[", "'score'", "]", "=", "df", "[", "'score'", "]", ".", "round", "(", "2", ")", "\n", "df", "[", "'total_PT'", "]", "=", "df", "[", "'total_PT'", "]", ".", "astype", "(", "int", ")", "\n", "df", "[", "'total_WCT'", "]", "=", "df", "[", "'total_WCT'", "]", ".", "astype", "(", "int", ")", "\n", "\n", "df", "=", "df", ".", "drop", "(", "[", "'imputation_WCT'", ",", "'tuning_WCT'", ",", "'total_WCT'", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Rename values in columns", "\n", "df", "[", "'selection'", "]", "=", "df", "[", "'selection'", "]", ".", "replace", "(", "{", "\n", "'ANOVA'", ":", "'A'", ",", "\n", "'manual'", ":", "'M'", ",", "\n", "}", ")", "\n", "df", "[", "'scorer'", "]", "=", "df", "[", "'scorer'", "]", ".", "replace", "(", "{", "\n", "'roc_auc_score'", ":", "'AUC'", ",", "\n", "'r2_score'", ":", "'R2'", ",", "\n", "}", ")", "\n", "df", "[", "'type'", "]", "=", "df", "[", "'type'", "]", ".", "replace", "(", "{", "\n", "'Classification'", ":", "'C'", ",", "\n", "'Regression'", ":", "'R'", ",", "\n", "}", ")", "\n", "\n", "# Rename columns", "\n", "rename_dict", "=", "{", "\n", "'db'", ":", "'Database'", ",", "\n", "'imputation_PT'", ":", "'Imputation time (s)'", ",", "\n", "'tuning_PT'", ":", "'Tuning time (s)'", ",", "\n", "'total_PT'", ":", "'Total time (s)'", ",", "\n", "'n'", ":", "'n'", ",", "\n", "'p'", ":", "'p'", ",", "\n", "}", "\n", "\n", "# Capitalize", "\n", "for", "f", "in", "df", ".", "columns", ":", "\n", "            ", "if", "f", "not", "in", "rename_dict", ":", "\n", "                ", "rename_dict", "[", "f", "]", "=", "f", ".", "capitalize", "(", ")", "\n", "\n", "", "", "df", "=", "df", ".", "rename", "(", "rename_dict", ",", "axis", "=", "1", ")", "\n", "\n", "# Create multi index", "\n", "df", "=", "df", ".", "set_index", "(", "[", "'Database'", ",", "'Task'", "]", ")", "\n", "\n", "# Read desciptions from file", "\n", "description_filepath", "=", "'scores/descriptions.csv'", "\n", "if", "os", ".", "path", ".", "exists", "(", "description_filepath", ")", ":", "\n", "            ", "desc", "=", "pd", ".", "read_csv", "(", "description_filepath", ",", "index_col", "=", "[", "0", ",", "1", "]", ")", "\n", "df", "=", "pd", ".", "concat", "(", "[", "df", ",", "desc", "]", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "desc", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'Target'", ":", "'Explain target here.'", ",", "'Description'", ":", "'Write task description here.'", "}", ",", "\n", "index", "=", "df", ".", "index", ",", "columns", "=", "[", "'Target'", ",", "'Description'", "]", "\n", ")", "\n", "desc", ".", "to_csv", "(", "description_filepath", ")", "\n", "\n", "", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._plot": [[558, 1061], ["dict", "list", "len", "list", "len", "list", "list", "len", "prediction.df_utils.aggregate", "PlotHelper._add_relative_value", "pandas.read_csv.apply", "pandas.read_csv.apply", "print", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots_adjust", "matplotlib.subplots_adjust", "enumerate", "isinstance", "pandas.read_csv", "df[].unique", "df[].unique", "df[].unique", "set().issubset", "df[].unique", "method_order.index", "db_order.index", "PlotHelper._y", "PlotHelper.rename_str", "min", "min.as_tuple", "len", "decimal.Decimal", "decimal.Decimal", "decimal.Decimal", "list", "len", "ax.twinx", "ax.twinx.set_ylim", "ax.twinx.yaxis.set_visible", "range", "ax.axvline", "seaborn.set_palette", "seaborn.boxplot", "seaborn.set_palette", "seaborn.scatterplot", "PlotHelper.PlotHelper._plot.xticks_params"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._add_relative_value", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._y", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename_str"], ["", "@", "staticmethod", "\n", "def", "_plot", "(", "filepath", ",", "value", ",", "how", ",", "xticks_dict", "=", "None", ",", "xlims", "=", "None", ",", "db_order", "=", "None", ",", "\n", "method_order", "=", "None", ",", "rename", "=", "dict", "(", ")", ",", "reference_method", "=", "None", ",", "\n", "figsize", "=", "None", ",", "legend_bbox", "=", "None", ",", "xlabel", "=", "None", ",", "symbols", "=", "None", ",", "comments", "=", "None", ",", "\n", "only_full_samples", "=", "True", ",", "y_labelsize", "=", "18", ",", "broken_axis", "=", "None", ",", "comments_align", "=", "None", ",", "\n", "comments_spacing", "=", "0.025", ",", "colors", "=", "None", ",", "ref_vline", "=", "None", ",", "non_ref_vline", "=", "False", ")", ":", "\n", "        ", "\"\"\"Plot the full available results.\"\"\"", "\n", "if", "not", "isinstance", "(", "filepath", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "df", "=", "filepath", "\n", "\n", "", "assert", "value", "in", "df", ".", "columns", "\n", "\n", "sizes", "=", "list", "(", "df", "[", "'size'", "]", ".", "unique", "(", ")", ")", "\n", "n_sizes", "=", "len", "(", "sizes", ")", "\n", "dbs", "=", "list", "(", "df", "[", "'db'", "]", ".", "unique", "(", ")", ")", "\n", "n_dbs", "=", "len", "(", "dbs", ")", "\n", "methods", "=", "list", "(", "df", "[", "'method'", "]", ".", "unique", "(", ")", ")", "\n", "\n", "# Check db_order", "\n", "if", "db_order", "is", "None", ":", "\n", "            ", "db_order", "=", "dbs", "\n", "", "elif", "set", "(", "dbs", ")", "!=", "set", "(", "db_order", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f'Db order missmatch existing ones {dbs}'", ")", "\n", "\n", "# Check method order", "\n", "", "if", "method_order", "is", "None", ":", "\n", "            ", "method_order", "=", "methods", "\n", "", "elif", "set", "(", "method_order", ")", ".", "issubset", "(", "set", "(", "methods", ")", ")", ":", "\n", "            ", "df", "=", "df", "[", "df", "[", "'method'", "]", ".", "isin", "(", "method_order", ")", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Method order missmatch existing ones {methods}'", ")", "\n", "\n", "", "methods", "=", "list", "(", "df", "[", "'method'", "]", ".", "unique", "(", ")", ")", "\n", "n_methods", "=", "len", "(", "methods", ")", "\n", "\n", "df", "=", "aggregate", "(", "df", ",", "value", ")", "\n", "\n", "# Compute and add relative value", "\n", "df", "=", "PlotHelper", ".", "_add_relative_value", "(", "df", ",", "value", ",", "how", ",", "\n", "reference_method", "=", "reference_method", ")", "\n", "\n", "# Add y position for plotting", "\n", "def", "_add_y", "(", "row", ")", ":", "\n", "            ", "method_idx", "=", "method_order", ".", "index", "(", "row", "[", "'method'", "]", ")", "\n", "db_idx", "=", "db_order", ".", "index", "(", "row", "[", "'db'", "]", ")", "\n", "return", "PlotHelper", ".", "_y", "(", "method_idx", ",", "db_idx", ",", "n_methods", ",", "n_dbs", ")", "\n", "\n", "", "df", "[", "'y'", "]", "=", "df", ".", "apply", "(", "_add_y", ",", "axis", "=", "1", ")", "\n", "\n", "# Add a renamed column for databases for plotting", "\n", "df", "[", "'Database'", "]", "=", "df", ".", "apply", "(", "lambda", "row", ":", "PlotHelper", ".", "rename_str", "(", "rename", ",", "row", "[", "'db'", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "# Print df with all its edits", "\n", "print", "(", "df", ")", "\n", "\n", "matplotlib", ".", "rcParams", ".", "update", "(", "{", "\n", "'font.size'", ":", "10", ",", "\n", "'legend.fontsize'", ":", "16", ",", "\n", "'legend.title_fontsize'", ":", "18", ",", "\n", "'axes.titlesize'", ":", "20", ",", "\n", "'axes.labelsize'", ":", "18", ",", "\n", "'xtick.labelsize'", ":", "16", ",", "\n", "'ytick.labelsize'", ":", "y_labelsize", ",", "\n", "# 'mathtext.fontset': 'stixsans',", "\n", "'font.family'", ":", "'STIXGeneral'", ",", "\n", "'text.usetex'", ":", "True", ",", "\n", "}", ")", "\n", "\n", "if", "figsize", "is", "None", ":", "\n", "            ", "figsize", "=", "(", "17", ",", "5.25", ")", "\n", "\n", "", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "1", ",", "ncols", "=", "n_sizes", ",", "figsize", "=", "figsize", ")", "\n", "plt", ".", "subplots_adjust", "(", "\n", "left", "=", "0.075", ",", "\n", "right", "=", "0.95", ",", "\n", "bottom", "=", "0.1", ",", "\n", "top", "=", "0.95", ",", "\n", "wspace", "=", "0.05", "\n", ")", "\n", "\n", "if", "n_sizes", "==", "1", ":", "\n", "            ", "axes", "=", "[", "axes", "]", "\n", "\n", "", "markers", "=", "[", "'o'", ",", "'^'", ",", "'v'", ",", "'s'", "]", "\n", "renamed_db_order", "=", "[", "PlotHelper", ".", "rename_str", "(", "rename", ",", "db", ")", "for", "db", "in", "db_order", "]", "\n", "db_markers", "=", "{", "db", ":", "markers", "[", "i", "]", "for", "i", ",", "db", "in", "enumerate", "(", "renamed_db_order", ")", "}", "\n", "\n", "def", "round_extrema", "(", "min_x", ",", "max_x", ")", ":", "\n", "            ", "if", "how", "==", "'log'", ":", "\n", "                ", "return", "min_x", ",", "max_x", "\n", "\n", "", "min_delta", "=", "min", "(", "abs", "(", "min_x", ")", ",", "abs", "(", "max_x", ")", ")", "\n", "min_delta_tuple", "=", "min_delta", ".", "as_tuple", "(", ")", "\n", "n_digits", "=", "len", "(", "min_delta_tuple", ".", "digits", ")", "\n", "e", "=", "min_delta_tuple", ".", "exponent", "\n", "\n", "e_unit", "=", "n_digits", "+", "e", "-", "1", "\n", "mult", "=", "Decimal", "(", "str", "(", "10", "**", "e_unit", ")", ")", "\n", "\n", "# Round to first significant digit", "\n", "min_x", "=", "mult", "*", "np", ".", "floor", "(", "min_x", "/", "mult", ")", "\n", "max_x", "=", "mult", "*", "np", ".", "ceil", "(", "max_x", "/", "mult", ")", "\n", "\n", "return", "min_x", ",", "max_x", "\n", "\n", "# Compute the xticks", "\n", "", "def", "xticks_params", "(", "values", ",", "xticks_dict", "=", "None", ")", ":", "\n", "            ", "true_min_x", "=", "Decimal", "(", "str", "(", "values", ".", "min", "(", ")", ")", ")", "\n", "true_max_x", "=", "Decimal", "(", "str", "(", "values", ".", "max", "(", ")", ")", ")", "\n", "\n", "if", "xlims", "is", "not", "None", ":", "\n", "                ", "true_min_x", ",", "true_max_x", "=", "xlims", "\n", "\n", "", "if", "xticks_dict", "is", "None", ":", "# Automatic xticks", "\n", "\n", "                ", "min_x", ",", "max_x", "=", "round_extrema", "(", "true_min_x", ",", "true_max_x", ")", "\n", "max_delta", "=", "float", "(", "max", "(", "abs", "(", "min_x", ")", ",", "abs", "(", "max_x", ")", ")", ")", "\n", "\n", "xticks", "=", "list", "(", "np", ".", "linspace", "(", "-", "max_delta", ",", "max_delta", ",", "5", ")", ")", "\n", "del", "xticks", "[", "0", "]", "\n", "del", "xticks", "[", "-", "1", "]", "\n", "xtick_labels", "=", "None", "\n", "\n", "", "else", ":", "# Manual xticks", "\n", "                ", "assert", "isinstance", "(", "xticks_dict", ",", "dict", ")", "\n", "xticks", "=", "list", "(", "xticks_dict", ".", "keys", "(", ")", ")", "\n", "xtick_labels", "=", "list", "(", "xticks_dict", ".", "values", "(", ")", ")", "\n", "\n", "# min_x = Decimal(min(xticks))", "\n", "# max_x = Decimal(max(xticks))", "\n", "\n", "min_x", "=", "true_min_x", "\n", "max_x", "=", "true_max_x", "\n", "\n", "max_delta", "=", "float", "(", "max", "(", "abs", "(", "min_x", ")", ",", "abs", "(", "max_x", ")", ")", ")", "\n", "\n", "# Set limits", "\n", "", "if", "how", "==", "'log'", ":", "\n", "                ", "xlim_min", "=", ".9", "*", "float", "(", "true_min_x", ")", "\n", "xlim_max", "=", "1.1", "*", "float", "(", "true_max_x", ")", "\n", "\n", "", "else", ":", "\n", "# Symetric constraint on xlims: use max absolute value", "\n", "# xlim_min = -max_delta", "\n", "# xlim_max = max_delta", "\n", "\n", "# Asymetric constraint: add margin to max and min", "\n", "                ", "margin", "=", "max_delta", "*", "0.05", "\n", "xlim_min", "=", "float", "(", "true_min_x", ")", "-", "margin", "\n", "xlim_max", "=", "float", "(", "true_max_x", ")", "+", "margin", "\n", "\n", "", "return", "xlim_min", ",", "xlim_max", ",", "xticks", ",", "xtick_labels", "\n", "\n", "# Uncomment this line to use same xlims constraint for all subplots", "\n", "# xlim_min, xlim_max, xticks, xtick_labels = xticks_params(df[f'relative_{value}'], xticks_dict=xticks_dict)", "\n", "\n", "", "if", "broken_axis", "is", "not", "None", ":", "\n", "            ", "axes_bg", ",", "axes_left", ",", "axes_right", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "", "for", "i", ",", "size", "in", "enumerate", "(", "sizes", ")", ":", "\n", "            ", "ax", "=", "axes", "[", "i", "]", "\n", "\n", "ax_bg", "=", "ax", "\n", "# ax_bg.axis('off')", "\n", "# break", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "divider", "=", "make_axes_locatable", "(", "ax", ")", "\n", "# ax_right = divider.new_horizontal(size=\"2000%\", pad=0.01)", "\n", "# ax = divider.new_horizontal(size=\"2000%\", pad=0.01, pack_start=True)", "\n", "# ax.axis('off')", "\n", "# ax_bg.axis('off')", "\n", "ax_bg", ".", "spines", "[", "'right'", "]", ".", "set_visible", "(", "False", ")", "\n", "ax_bg", ".", "spines", "[", "'bottom'", "]", ".", "set_visible", "(", "False", ")", "\n", "ax_bg", ".", "spines", "[", "'top'", "]", ".", "set_visible", "(", "False", ")", "\n", "ax_bg", ".", "spines", "[", "'left'", "]", ".", "set_visible", "(", "False", ")", "\n", "ax_bg", ".", "tick_params", "(", "bottom", "=", "False", ",", "left", "=", "False", ",", "labelleft", "=", "False", ")", "#, labelbottom=False)", "\n", "ax_bg", ".", "xaxis", ".", "set_ticks", "(", "[", "0", ",", "1", "]", ")", "\n", "ax_bg", ".", "xaxis", ".", "set_ticklabels", "(", "[", "' '", ",", "' '", "]", ")", "\n", "# ax_bg.set_xticks(xticks, minor=False)", "\n", "ax_bg", ".", "set_xticklabels", "(", "[", "' '", ",", "' '", "]", ",", "minor", "=", "False", ")", "\n", "ax_right", "=", "divider", ".", "append_axes", "(", "'right'", ",", "size", "=", "'2000%'", ",", "pad", "=", "0.0", ")", "\n", "ax_left", "=", "divider", ".", "append_axes", "(", "'left'", ",", "size", "=", "'2000%'", ",", "pad", "=", "0.0", ")", "\n", "fig", ".", "add_axes", "(", "ax_right", ")", "\n", "# fig.add_axes(ax)", "\n", "fig", ".", "add_axes", "(", "ax_left", ")", "\n", "ax", "=", "ax_left", "\n", "ax_left", ".", "spines", "[", "'right'", "]", ".", "set_visible", "(", "False", ")", "\n", "ax_right", ".", "spines", "[", "'left'", "]", ".", "set_visible", "(", "False", ")", "\n", "ax_right", ".", "tick_params", "(", "left", "=", "False", ",", "labelleft", "=", "False", ")", "\n", "\n", "axes_bg", ".", "append", "(", "ax_bg", ")", "\n", "axes_left", ".", "append", "(", "ax_left", ")", "\n", "axes_right", ".", "append", "(", "ax_right", ")", "\n", "\n", "d", "=", ".01", "# how big to make the diagonal lines in axes coordinates", "\n", "# arguments to pass to plot, just so we don't keep repeating them", "\n", "kwargs", "=", "dict", "(", "transform", "=", "ax_right", ".", "transAxes", ",", "color", "=", "'k'", ",", "clip_on", "=", "False", ")", "\n", "ax_right", ".", "plot", "(", "(", "-", "d", ",", "+", "d", ")", ",", "(", "-", "d", ",", "+", "d", ")", ",", "**", "kwargs", ")", "# top-left diagonal", "\n", "kwargs", "=", "dict", "(", "transform", "=", "ax_left", ".", "transAxes", ",", "color", "=", "'k'", ",", "clip_on", "=", "False", ")", "\n", "ax_left", ".", "plot", "(", "(", "1", "-", "d", ",", "1", "+", "d", ")", ",", "(", "-", "d", ",", "+", "d", ")", ",", "**", "kwargs", ")", "# top-right diagonal", "\n", "\n", "kwargs", ".", "update", "(", "transform", "=", "ax_right", ".", "transAxes", ")", "# switch to the bottom axes", "\n", "ax_right", ".", "plot", "(", "(", "-", "d", ",", "+", "d", ")", ",", "(", "1", "-", "d", ",", "1", "+", "d", ")", ",", "**", "kwargs", ")", "# bottom-left diagonal", "\n", "kwargs", ".", "update", "(", "transform", "=", "ax_left", ".", "transAxes", ")", "# switch to the bottom axes", "\n", "ax_left", ".", "plot", "(", "(", "1", "-", "d", ",", "1", "+", "d", ")", ",", "(", "1", "-", "d", ",", "1", "+", "d", ")", ",", "**", "kwargs", ")", "# bottom-right diagonal", "\n", "\n", "# ax_left.axis('off')", "\n", "# ax_right.axis('off')", "\n", "# ax_bg.axis('off')", "\n", "\n", "# ax_left.spines['right'].set_visible(False)", "\n", "# ax_left.spines['bottom'].set_visible(False)", "\n", "# ax_left.spines['top'].set_visible(False)", "\n", "# ax_left.spines['left'].set_visible(False)", "\n", "\n", "# ax_right.spines['right'].set_visible(False)", "\n", "# ax_right.spines['bottom'].set_visible(False)", "\n", "# ax_right.spines['top'].set_visible(False)", "\n", "# ax_right.spines['left'].set_visible(False)", "\n", "\n", "# locator = divider.new_locator(nx=0, ny=1)", "\n", "# ax.set_axes_locator(locator)", "\n", "\n", "# break", "\n", "\n", "# Select the rows of interest", "\n", "", "subdf", "=", "df", "[", "df", "[", "'size'", "]", "==", "size", "]", "\n", "\n", "# Split in valid and invalid data", "\n", "# idx_valid = subdf.index[(subdf['selection'] == 'manual') | (", "\n", "#     (subdf['selection'] != 'manual') & (subdf['n_trials'] == 5))]", "\n", "if", "only_full_samples", ":", "\n", "                ", "idx_valid", "=", "subdf", ".", "index", "[", "subdf", "[", "'n_folds'", "]", "==", "25", "]", "\n", "idx_invalid", "=", "subdf", ".", "index", ".", "difference", "(", "idx_valid", ")", "\n", "df_valid", "=", "subdf", ".", "loc", "[", "idx_valid", "]", "\n", "df_invalid", "=", "subdf", ".", "loc", "[", "idx_invalid", "]", "\n", "\n", "", "else", ":", "\n", "                ", "df_valid", "=", "subdf", "\n", "df_invalid", "=", "pd", ".", "DataFrame", "(", "columns", "=", "subdf", ".", "columns", ")", "\n", "\n", "# Update parameters for plotting invalids", "\n", "", "dbs_having_invalids", "=", "list", "(", "df_invalid", "[", "'Database'", "]", ".", "unique", "(", ")", ")", "\n", "n_dbs_invalid", "=", "len", "(", "dbs_having_invalids", ")", "\n", "db_invalid_markers", "=", "{", "db", ":", "m", "for", "db", ",", "m", "in", "db_markers", ".", "items", "(", ")", "if", "db", "in", "dbs_having_invalids", "}", "\n", "renamed_db_order_invalid", "=", "[", "x", "for", "x", "in", "renamed_db_order", "if", "x", "in", "dbs_having_invalids", "]", "\n", "\n", "twinx", "=", "ax", ".", "twinx", "(", ")", "\n", "twinx", ".", "set_ylim", "(", "0", ",", "n_methods", ")", "\n", "twinx", ".", "yaxis", ".", "set_visible", "(", "False", ")", "\n", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "twinx_right", "=", "ax_right", ".", "twinx", "(", ")", "\n", "twinx_right", ".", "set_ylim", "(", "0", ",", "n_methods", ")", "\n", "twinx_right", ".", "yaxis", ".", "set_visible", "(", "False", ")", "\n", "twinx_right", ".", "spines", "[", "'left'", "]", ".", "set_visible", "(", "False", ")", "\n", "twinx", ".", "spines", "[", "'right'", "]", ".", "set_visible", "(", "False", ")", "\n", "twinx_right", ".", "tick_params", "(", "left", "=", "False", ",", "labelleft", "=", "False", ")", "\n", "\n", "# Add gray layouts in the background every other rows", "\n", "", "for", "k", "in", "range", "(", "0", ",", "n_methods", ",", "2", ")", ":", "\n", "                ", "ax", ".", "axhspan", "(", "k", "-", "0.5", ",", "k", "+", "0.5", ",", "color", "=", "'.93'", ",", "zorder", "=", "0", ")", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                    ", "ax_right", ".", "axhspan", "(", "k", "-", "0.5", ",", "k", "+", "0.5", ",", "color", "=", "'.93'", ",", "zorder", "=", "0", ")", "\n", "ax_bg", ".", "axhspan", "(", "k", "-", "0.5", ",", "k", "+", "0.5", ",", "color", "=", "'.93'", ",", "zorder", "=", "0", ")", "\n", "ax_bg", ".", "set_ylim", "(", "-", "0.5", "-", "(", "(", "n_methods", "+", "1", ")", "%", "2", ")", ",", "n_methods", "-", "0.5", "-", "(", "(", "n_methods", "+", "1", ")", "%", "2", ")", ")", "\n", "\n", "", "", "mid", "=", "1", "if", "how", "==", "'log'", "else", "0", "\n", "ax", ".", "axvline", "(", "mid", ",", "ymin", "=", "0", ",", "ymax", "=", "n_methods", ",", "color", "=", "'gray'", ",", "zorder", "=", "0", ")", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "ax", ".", "axvline", "(", "mid", ",", "ymin", "=", "0", ",", "ymax", "=", "n_methods", ",", "color", "=", "'gray'", ",", "zorder", "=", "0", ")", "\n", "\n", "# Build the color palette for the boxplot", "\n", "", "if", "colors", "is", "None", ":", "\n", "                ", "paired_colors", "=", "sns", ".", "color_palette", "(", "'Paired'", ")", ".", "as_hex", "(", ")", "\n", "# del paired_colors[10]", "\n", "paired_colors", "[", "10", "]", "=", "sns", ".", "color_palette", "(", "\"Set2\"", ")", ".", "as_hex", "(", ")", "[", "5", "]", "\n", "boxplot_palette", "=", "sns", ".", "color_palette", "(", "[", "'#525252'", "]", "+", "paired_colors", ")", "\n", "\n", "", "else", ":", "\n", "                ", "boxplot_palette", "=", "sns", ".", "color_palette", "(", "colors", ")", "\n", "\n", "# Add axvline for reference method", "\n", "", "if", "ref_vline", "is", "not", "None", ":", "\n", "                ", "ref_med", "=", "df_valid", ".", "query", "(", "'method == @ref_vline'", ")", "[", "f'relative_{value}'", "]", ".", "median", "(", ")", "\n", "ax", ".", "axvline", "(", "ref_med", ",", "ymin", "=", "0", ",", "ymax", "=", "n_methods", ",", "color", "=", "'gray'", ",", "zorder", "=", "0", ",", "ls", "=", "'--'", ",", "lw", "=", "1", ")", "\n", "\n", "# Add mean of methods other than reference", "\n", "", "if", "non_ref_vline", ":", "\n", "                ", "non_ref_mean", "=", "df_valid", ".", "query", "(", "'method != @ref_vline and method != \"MI\" and method != \"MI+mask\" and method != \"MIA+mask\"'", ")", "[", "f'relative_{value}'", "]", ".", "median", "(", ")", "\n", "ax", ".", "axvline", "(", "non_ref_mean", ",", "ymin", "=", "0", ",", "ymax", "=", "n_methods", ",", "color", "=", "'gray'", ",", "zorder", "=", "0", ",", "ls", "=", "'--'", ",", "lw", "=", "1", ")", "\n", "\n", "# Boxplot", "\n", "", "sns", ".", "set_palette", "(", "boxplot_palette", ")", "\n", "sns", ".", "boxplot", "(", "x", "=", "f'relative_{value}'", ",", "y", "=", "'method'", ",", "data", "=", "df_valid", ",", "orient", "=", "'h'", ",", "\n", "ax", "=", "ax", ",", "order", "=", "method_order", ",", "showfliers", "=", "False", ")", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "sns", ".", "boxplot", "(", "x", "=", "f'relative_{value}'", ",", "y", "=", "'method'", ",", "data", "=", "df_valid", ",", "orient", "=", "'h'", ",", "\n", "ax", "=", "ax_right", ",", "order", "=", "method_order", ",", "showfliers", "=", "False", ")", "\n", "# sns.boxplot(x=f'relative_{value}', y='method', data=df_valid, orient='h',", "\n", "#             ax=ax_bg, order=method_order, showfliers=False)", "\n", "\n", "# Scatter plot for valid data points", "\n", "", "sns", ".", "set_palette", "(", "sns", ".", "color_palette", "(", "'colorblind'", ")", ")", "\n", "g2", "=", "sns", ".", "scatterplot", "(", "x", "=", "f'relative_{value}'", ",", "y", "=", "'y'", ",", "hue", "=", "'Database'", ",", "\n", "data", "=", "df_valid", ",", "ax", "=", "twinx", ",", "\n", "hue_order", "=", "renamed_db_order", ",", "\n", "style", "=", "'Database'", ",", "\n", "markers", "=", "db_markers", ",", "\n", "s", "=", "75", ",", "\n", ")", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "g2_2", "=", "sns", ".", "scatterplot", "(", "x", "=", "f'relative_{value}'", ",", "y", "=", "'y'", ",", "hue", "=", "'Database'", ",", "\n", "data", "=", "df_valid", ",", "ax", "=", "twinx_right", ",", "\n", "hue_order", "=", "renamed_db_order", ",", "\n", "style", "=", "'Database'", ",", "\n", "markers", "=", "db_markers", ",", "\n", "s", "=", "75", ",", "\n", ")", "\n", "\n", "", "if", "legend_bbox", ":", "\n", "# g2.legend(loc='upper left', bbox_to_anchor=legend_bbox, ncol=1, title='Database')", "\n", "                ", "handles", ",", "labels", "=", "g2", ".", "get_legend_handles_labels", "(", ")", "\n", "r", "=", "matplotlib", ".", "patches", ".", "Rectangle", "(", "(", "0", ",", "0", ")", ",", "1", ",", "1", ",", "fill", "=", "False", ",", "edgecolor", "=", "'none'", ",", "\n", "visible", "=", "False", ")", "\n", "handles", "=", "[", "r", "]", "+", "handles", "\n", "labels", "=", "[", "'\\\\textbf{{Database}}'", "]", "+", "labels", "\n", "# g2.legend(loc='lower center', bbox_to_anchor=legend_bbox, ncol=4, title='\\\\textbf{{Database}}')", "\n", "# g2.get_legend().get_title().set_position((-250, -20))", "\n", "g2", ".", "legend", "(", "loc", "=", "'lower center'", ",", "bbox_to_anchor", "=", "legend_bbox", ",", "ncol", "=", "5", ",", "handles", "=", "handles", ",", "labels", "=", "labels", ")", "\n", "# g2.legend(loc='lower center', bbox_to_anchor=legend_bbox, ncol=4, title='Database')", "\n", "\n", "# Scatter plot for invalid data points", "\n", "", "if", "n_dbs_invalid", ">", "0", ":", "\n", "                ", "sns", ".", "set_palette", "(", "sns", ".", "color_palette", "(", "n_dbs_invalid", "*", "[", "'lightgray'", "]", ")", ")", "\n", "g3", "=", "sns", ".", "scatterplot", "(", "x", "=", "f'relative_{value}'", ",", "y", "=", "'y'", ",", "hue", "=", "'Database'", ",", "\n", "data", "=", "df_invalid", ",", "ax", "=", "twinx", ",", "\n", "hue_order", "=", "renamed_db_order_invalid", ",", "\n", "style", "=", "'Database'", ",", "\n", "markers", "=", "db_invalid_markers", ",", "\n", "s", "=", "75", ",", "\n", "legend", "=", "False", ",", "\n", ")", "\n", "# g3.legend(title='title')", "\n", "\n", "", "if", "not", "legend_bbox", "and", "i", "<", "len", "(", "sizes", ")", "-", "1", ":", "\n", "                ", "twinx", ".", "get_legend", "(", ")", ".", "remove", "(", ")", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                    ", "twinx_right", ".", "get_legend", "(", ")", ".", "remove", "(", ")", "\n", "\n", "", "", "elif", "legend_bbox", "and", "i", ">", "0", ":", "\n", "                ", "twinx", ".", "get_legend", "(", ")", ".", "remove", "(", ")", "\n", "\n", "", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "twinx_right", ".", "get_legend", "(", ")", ".", "remove", "(", ")", "\n", "\n", "", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "ax_right", ".", "yaxis", ".", "set_visible", "(", "False", ")", "\n", "\n", "", "if", "i", ">", "0", ":", "# if not the first axis", "\n", "                ", "ax", ".", "yaxis", ".", "set_visible", "(", "False", ")", "\n", "# twinx.get_legend().remove()", "\n", "", "else", ":", "\n", "# Get yticks labels and rename them according to given dict", "\n", "                ", "labels", "=", "[", "item", ".", "get_text", "(", ")", "for", "item", "in", "ax", ".", "get_yticklabels", "(", ")", "]", "\n", "r_labels", "=", "[", "PlotHelper", ".", "rename_str", "(", "rename", ",", "l", ")", "for", "l", "in", "labels", "]", "\n", "ax", ".", "set_yticklabels", "(", "r_labels", ")", "\n", "# ax.text(1.1, 1.1, '\\\\textbf{{Database}}', fontsize='x-large', ha='left', va='center', transform=ax.transAxes, zorder=10)", "\n", "# if broken_axis is not None:", "\n", "#     ax_right.set_yticklabels(r_labels)", "\n", "\n", "", "if", "how", "==", "'log'", ":", "\n", "                ", "ax", ".", "set_xscale", "(", "'log'", ")", "\n", "twinx", ".", "set_xscale", "(", "'log'", ")", "\n", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                    ", "ax_right", ".", "set_xscale", "(", "'log'", ")", "\n", "twinx_right", ".", "set_xscale", "(", "'log'", ")", "\n", "\n", "# Comment this line to use same xlims constraint for all subplots", "\n", "", "", "xlim_min", ",", "xlim_max", ",", "xticks", ",", "xtick_labels", "=", "xticks_params", "(", "subdf", "[", "f'relative_{value}'", "]", ",", "xticks_dict", "=", "xticks_dict", ")", "\n", "\n", "if", "xtick_labels", "is", "not", "None", ":", "\n", "                ", "ax", ".", "set_xticks", "(", "xticks", ",", "minor", "=", "False", ")", "\n", "ax", ".", "set_xticklabels", "(", "xtick_labels", ",", "minor", "=", "False", ")", "\n", "ax", ".", "xaxis", ".", "set_minor_locator", "(", "matplotlib", ".", "ticker", ".", "NullLocator", "(", ")", ")", "\n", "\n", "twinx", ".", "set_xticks", "(", "xticks", ",", "minor", "=", "False", ")", "\n", "twinx", ".", "set_xticklabels", "(", "xtick_labels", ",", "minor", "=", "False", ")", "\n", "twinx", ".", "xaxis", ".", "set_minor_locator", "(", "matplotlib", ".", "ticker", ".", "NullLocator", "(", ")", ")", "\n", "\n", "", "else", ":", "\n", "                ", "ax", ".", "set_xticks", "(", "xticks", ")", "\n", "twinx", ".", "set_xticks", "(", "xticks", ")", "\n", "\n", "", "ax", ".", "set_xlim", "(", "left", "=", "xlim_min", ",", "right", "=", "xlim_max", ")", "\n", "# twinx.set_xlim(left=xlim_min, right=xlim_max)", "\n", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "if", "xtick_labels", "is", "not", "None", ":", "\n", "                    ", "xlim", "=", "ax_right", ".", "get_xlim", "(", ")", "\n", "ax_right", ".", "set_xticks", "(", "xticks", ",", "minor", "=", "False", ")", "\n", "ax_right", ".", "set_xticklabels", "(", "xtick_labels", ",", "minor", "=", "False", ")", "\n", "ax_right", ".", "xaxis", ".", "set_minor_locator", "(", "matplotlib", ".", "ticker", ".", "NullLocator", "(", ")", ")", "\n", "ax_right", ".", "set_xlim", "(", "xlim", ")", "\n", "\n", "xlim", "=", "twinx_right", ".", "get_xlim", "(", ")", "\n", "twinx_right", ".", "set_xticks", "(", "xticks", ",", "minor", "=", "False", ")", "\n", "twinx_right", ".", "set_xticklabels", "(", "xtick_labels", ",", "minor", "=", "False", ")", "\n", "twinx_right", ".", "xaxis", ".", "set_minor_locator", "(", "matplotlib", ".", "ticker", ".", "NullLocator", "(", ")", ")", "\n", "twinx_right", ".", "set_xlim", "(", "xlim", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "ax_right", ".", "set_xticks", "(", "xticks", ")", "\n", "twinx_right", ".", "set_xticks", "(", "xticks", ")", "\n", "\n", "", "ax", ".", "set_xlim", "(", "left", "=", "xlim_min", ",", "right", "=", "xlim_max", ")", "\n", "\n", "", "ax_bg", ".", "set_title", "(", "f'n={size:,d}'", ".", "replace", "(", "','", ",", "'\\\\,'", ")", ")", "\n", "if", "xlabel", "is", "None", ":", "\n", "                ", "xlabel", "=", "ax", ".", "get_xlabel", "(", ")", "\n", "", "ax_bg", ".", "set_xlabel", "(", "PlotHelper", ".", "rename_str", "(", "rename", ",", "xlabel", ")", ")", "\n", "ax", ".", "set_ylabel", "(", "None", ")", "\n", "ax", ".", "set_axisbelow", "(", "True", ")", "\n", "ax", ".", "grid", "(", "True", ",", "axis", "=", "'x'", ")", "\n", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "if", "xlabel", "is", "None", ":", "\n", "                    ", "xlabel", "=", "ax_right", ".", "get_xlabel", "(", ")", "\n", "# ax_right.set_xlabel(PlotHelper.rename_str(rename, xlabel))", "\n", "", "ax_right", ".", "set_xlabel", "(", "None", ")", "\n", "ax_left", ".", "set_xlabel", "(", "None", ")", "\n", "ax_right", ".", "set_ylabel", "(", "None", ")", "\n", "ax_right", ".", "set_axisbelow", "(", "True", ")", "\n", "ax_right", ".", "grid", "(", "True", ",", "axis", "=", "'x'", ")", "\n", "\n", "", "if", "broken_axis", "is", "not", "None", ":", "\n", "                ", "xlim", "=", "ax", ".", "get_xlim", "(", ")", "\n", "xlim2", "=", "ax_right", ".", "get_xlim", "(", ")", "\n", "if", "isinstance", "(", "broken_axis", ",", "list", ")", ":", "\n", "                    ", "ba_lims", "=", "broken_axis", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "ba_lims", "=", "broken_axis", "\n", "", "ax", ".", "set_xlim", "(", "(", "xlim", "[", "0", "]", ",", "ba_lims", "[", "0", "]", ")", ")", "\n", "ax_right", ".", "set_xlim", "(", "(", "ba_lims", "[", "1", "]", ",", "xlim2", "[", "1", "]", ")", ")", "\n", "\n", "ax_bg", ".", "set_ylim", "(", "ax", ".", "get_ylim", "(", ")", ")", "\n", "\n", "# break", "\n", "\n", "# Optionally adds symbols on each line (for significance)", "\n", "", "if", "symbols", "is", "not", "None", ":", "\n", "                ", "method_symbols", "=", "symbols", ".", "get", "(", "size", ",", "None", ")", "\n", "if", "method_symbols", "is", "None", ":", "\n", "                    ", "continue", "\n", "\n", "", "xmin", ",", "xmax", "=", "ax", ".", "get_xlim", "(", ")", "\n", "ax", ".", "set_xlim", "(", "(", "xmin", "-", "0.08", "*", "(", "xmax", "-", "xmin", ")", ",", "xmax", ")", ")", "\n", "\n", "for", "i", ",", "method", "in", "enumerate", "(", "method_order", ")", ":", "\n", "                    ", "symbol", "=", "method_symbols", ".", "get", "(", "method", ",", "None", ")", "\n", "\n", "if", "symbol", "is", "None", ":", "\n", "                        ", "continue", "\n", "\n", "", "ax", ".", "annotate", "(", "symbol", ",", "xy", "=", "(", "0.025", ",", "1", "-", "(", "i", "+", "0.5", ")", "/", "n_methods", ")", ",", "color", "=", "'black'", ",", "\n", "xycoords", "=", "'axes fraction'", ",", "fontsize", "=", "'x-large'", ",", "va", "=", "'center'", ")", "\n", "\n", "# Optionally adds comments on each line (for untractable)", "\n", "", "", "if", "comments", "is", "not", "None", ":", "\n", "                ", "method_comments", "=", "comments", ".", "get", "(", "size", ",", "None", ")", "\n", "if", "method_comments", "is", "None", ":", "\n", "                    ", "continue", "\n", "\n", "", "for", "m", ",", "method", "in", "enumerate", "(", "method_order", ")", ":", "\n", "                    ", "comment", "=", "method_comments", ".", "get", "(", "method", ",", "None", ")", "\n", "\n", "if", "comment", "is", "None", ":", "\n", "                        ", "continue", "\n", "\n", "", "x", "=", "comments_spacing", "\n", "ha", "=", "'left'", "\n", "ax_comment", "=", "ax_left", "if", "broken_axis", "is", "not", "None", "else", "ax_bg", "\n", "if", "comments_align", "is", "not", "None", ":", "\n", "                        ", "if", "isinstance", "(", "comments_align", ",", "dict", ")", ":", "\n", "                            ", "align", "=", "comments_align", "[", "i", "]", "[", "m", "]", "\n", "", "else", ":", "\n", "                            ", "align", "=", "comments_align", "[", "m", "]", "\n", "\n", "", "if", "align", "==", "'right'", ":", "\n", "                            ", "x", "=", "1", "-", "comments_spacing", "\n", "ha", "=", "'right'", "\n", "ax_comment", "=", "ax_right", "if", "broken_axis", "is", "not", "None", "else", "ax_bg", "\n", "\n", "", "", "ax_comment", ".", "text", "(", "x", ",", "1", "-", "(", "m", "+", "0.5", ")", "/", "n_methods", ",", "comment", ",", "\n", "color", "=", "'.4'", ",", "fontsize", "=", "'x-large'", ",", "ha", "=", "ha", ",", "\n", "va", "=", "'center'", ",", "transform", "=", "ax_comment", ".", "transAxes", ")", "\n", "\n", "", "", "", "if", "broken_axis", "is", "not", "None", ":", "\n", "            ", "return", "fig", ",", "axes_bg", ",", "axes_left", ",", "axes_right", "\n", "\n", "", "return", "fig", ",", "axes", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.mean_rank": [[1062, 1142], ["list", "pandas.read_csv.groupby", "dfgb[].rank", "print", "pandas.read_csv.groupby", "pd.read_csv.groupby.agg", "pandas.read_csv.reset_index", "pandas.read_csv.groupby", "pd.read_csv.groupby.agg", "pandas.read_csv.reset_index", "pandas.read_csv.groupby", "pd.read_csv.groupby.agg", "pandas.read_csv.reset_index", "pandas.read_csv.groupby", "pd.read_csv.groupby.agg", "pandas.pivot_table.reset_index", "pandas.pivot_table", "pandas.read_csv.groupby", "pd.read_csv.groupby.agg", "pandas.pivot_table", "df_pt.reindex.reindex.sort_values", "df[].unique", "df_pt.reindex.reindex.sort_values", "df.groupby.agg.rank().astype", "df_pt.reindex.reindex.round", "print", "isinstance", "pandas.read_csv", "df[].unique", "set().issubset", "df_pt.reindex.reindex.reindex", "set", "ValueError", "df.groupby.agg.rank", "len", "len", "set", "set", "set", "df[].isin", "df[].unique"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "mean_rank", "(", "filepath", ",", "method_order", "=", "None", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "filepath", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "df", "=", "filepath", "\n", "\n", "# Check method order", "\n", "", "methods", "=", "list", "(", "df", "[", "'method'", "]", ".", "unique", "(", ")", ")", "\n", "if", "method_order", "is", "None", ":", "\n", "            ", "method_order", "=", "methods", "\n", "", "elif", "set", "(", "method_order", ")", ".", "issubset", "(", "set", "(", "methods", ")", ")", ":", "\n", "# Keep only the rows having methods in method_order", "\n", "            ", "df", "=", "df", "[", "df", "[", "'method'", "]", ".", "isin", "(", "method_order", ")", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Method order missmatch existing ones {methods}'", ")", "\n", "\n", "", "dfgb", "=", "df", ".", "groupby", "(", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'trial'", ",", "'fold'", "]", ")", "\n", "df", "[", "'rank'", "]", "=", "dfgb", "[", "'score'", "]", ".", "rank", "(", "method", "=", "'dense'", ",", "ascending", "=", "False", ")", "\n", "print", "(", "df", ")", "\n", "\n", "# Agregate across foldss by averaging", "\n", "dfgb", "=", "df", ".", "groupby", "(", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'method'", ",", "'trial'", "]", ")", "\n", "df", "=", "dfgb", ".", "agg", "(", "{", "'rank'", ":", "'mean'", ",", "'selection'", ":", "'first'", "}", ")", "\n", "\n", "# Agregate across trials by averaging", "\n", "df", "=", "df", ".", "reset_index", "(", ")", "\n", "df", "[", "'n_trials'", "]", "=", "1", "# Add a count column to keep track of # of trials", "\n", "dfgb", "=", "df", ".", "groupby", "(", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "df", "=", "dfgb", ".", "agg", "(", "{", "'rank'", ":", "'mean'", ",", "'selection'", ":", "'first'", ",", "'n_trials'", ":", "'sum'", "}", ")", "\n", "\n", "# We only take into account full results (n_trials == 5)", "\n", "df", "=", "df", ".", "reset_index", "(", ")", "\n", "idx_valid", "=", "df", ".", "index", "[", "(", "df", "[", "'selection'", "]", "==", "'manual'", ")", "|", "(", "\n", "(", "df", "[", "'selection'", "]", "!=", "'manual'", ")", "&", "(", "df", "[", "'n_trials'", "]", "==", "5", ")", ")", "]", "\n", "df", "=", "df", ".", "loc", "[", "idx_valid", "]", "\n", "\n", "# Average across tasks", "\n", "dfgb", "=", "df", ".", "groupby", "(", "[", "'size'", ",", "'db'", ",", "'method'", "]", ")", "\n", "df", "=", "dfgb", ".", "agg", "(", "{", "'rank'", ":", "'mean'", "}", ")", "\n", "\n", "# Reset index to addlevel of the multi index to the columns of the df", "\n", "df", "=", "df", ".", "reset_index", "(", ")", "\n", "\n", "# Compute average by size", "\n", "dfgb", "=", "df", ".", "groupby", "(", "[", "'size'", ",", "'method'", "]", ")", "\n", "df_avg_by_size", "=", "dfgb", ".", "agg", "(", "{", "'rank'", ":", "'mean'", "}", ")", "\n", "df_avg_by_size", "=", "df_avg_by_size", ".", "reset_index", "(", ")", "\n", "df_avg_by_size", "=", "pd", ".", "pivot_table", "(", "df_avg_by_size", ",", "values", "=", "'rank'", ",", "index", "=", "[", "'method'", "]", ",", "columns", "=", "[", "'size'", "]", ")", "\n", "\n", "# Compute average on all data", "\n", "dfgb", "=", "df", ".", "groupby", "(", "[", "'method'", "]", ")", "\n", "df_avg", "=", "dfgb", ".", "agg", "(", "{", "'rank'", ":", "'mean'", "}", ")", "\n", "\n", "# Create a pivot table of the rank accross methods", "\n", "df_pt", "=", "pd", ".", "pivot_table", "(", "df", ",", "values", "=", "'rank'", ",", "index", "=", "[", "'method'", "]", ",", "columns", "=", "[", "'size'", ",", "'db'", "]", ")", "\n", "\n", "df_pt", ".", "sort_values", "(", "by", "=", "[", "'size'", ",", "'db'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "# Add average by size columns", "\n", "for", "size", "in", "df", "[", "'size'", "]", ".", "unique", "(", ")", ":", "\n", "            ", "df_pt", "[", "(", "size", ",", "'AVG'", ")", "]", "=", "df_avg_by_size", "[", "size", "]", "\n", "\n", "", "df_pt", ".", "sort_values", "(", "by", "=", "[", "'size'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "# Add global order column", "\n", "df_pt", "[", "(", "'Global'", ",", "'AVG'", ")", "]", "=", "df_avg", "\n", "df_pt", "[", "(", "'Global'", ",", "'Rank'", ")", "]", "=", "df_avg", ".", "rank", "(", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# Round mean ranks", "\n", "df_pt", "=", "df_pt", ".", "round", "(", "2", ")", "\n", "\n", "# Reorder the method index", "\n", "if", "method_order", ":", "\n", "            ", "assert", "len", "(", "set", "(", "method_order", ")", ")", "==", "len", "(", "set", "(", "df", "[", "'method'", "]", ".", "unique", "(", ")", ")", ")", "\n", "df_pt", "=", "df_pt", ".", "reindex", "(", "method_order", ")", "\n", "\n", "", "print", "(", "df_pt", ")", "\n", "\n", "return", "df_pt", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.ranks": [[1143, 1209], ["list", "filepath.copy.groupby", "dfgb[].rank", "prediction.df_utils.aggregate", "prediction.df_utils.aggregate", "mean_scores.reset_index.reset_index.groupby", "dfgb[].rank", "mean_scores.reset_index.reset_index.set_index", "mean_ranks.reset_index.reset_index.set_index", "rank_of_mean_scores.reset_index.reset_index.reset_index", "mean_scores.reset_index.reset_index.reset_index", "mean_ranks.reset_index.reset_index.reset_index", "mean_scores.reset_index.reset_index.groupby", "dfgb.agg.groupby.agg", "rank_of_mean_scores.reset_index.reset_index.groupby", "dfgb.agg.groupby.agg", "mean_ranks.reset_index.reset_index.groupby", "dfgb.agg.groupby.agg", "mean_scores_on_sizes.groupby.agg.groupby", "dfgb[].rank", "print", "print", "print", "print", "mean_scores_on_sizes.groupby.agg.copy().rename", "print", "isinstance", "pandas.read_csv", "filepath.copy", "df[].unique", "set().issubset", "set", "ValueError", "mean_scores_on_sizes.groupby.agg.copy", "set", "df[].isin"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["", "@", "staticmethod", "\n", "def", "ranks", "(", "filepath", ",", "method_order", "=", "None", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "filepath", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "df", "=", "filepath", ".", "copy", "(", ")", "\n", "\n", "# Check method order", "\n", "", "methods", "=", "list", "(", "df", "[", "'method'", "]", ".", "unique", "(", ")", ")", "\n", "if", "method_order", "is", "None", ":", "\n", "            ", "method_order", "=", "methods", "\n", "", "elif", "set", "(", "method_order", ")", ".", "issubset", "(", "set", "(", "methods", ")", ")", ":", "\n", "# Keep only the rows having methods in method_order", "\n", "            ", "df", "=", "df", "[", "df", "[", "'method'", "]", ".", "isin", "(", "method_order", ")", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Method order missmatch existing ones {methods}'", ")", "\n", "\n", "# Compute ranks on each fold, trial", "\n", "", "dfgb", "=", "df", ".", "groupby", "(", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'trial'", ",", "'fold'", "]", ")", "\n", "df", "[", "'rank'", "]", "=", "dfgb", "[", "'score'", "]", ".", "rank", "(", "method", "=", "'dense'", ",", "ascending", "=", "False", ")", "\n", "\n", "# Average accross folds and trials", "\n", "mean_scores", "=", "aggregate", "(", "df", ",", "'score'", ")", "\n", "mean_ranks", "=", "aggregate", "(", "df", ",", "'rank'", ")", "\n", "\n", "dfgb", "=", "mean_scores", ".", "groupby", "(", "[", "'size'", ",", "'db'", ",", "'task'", "]", ")", "\n", "mean_scores", "[", "'rank'", "]", "=", "dfgb", "[", "'score'", "]", ".", "rank", "(", "method", "=", "'dense'", ",", "ascending", "=", "False", ")", "\n", "\n", "mean_scores", "=", "mean_scores", ".", "set_index", "(", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "mean_ranks", "=", "mean_ranks", ".", "set_index", "(", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "\n", "rank_of_mean_scores", "=", "mean_scores", "[", "'rank'", "]", "\n", "mean_scores", "=", "mean_scores", "[", "'score'", "]", "\n", "mean_ranks", "=", "mean_ranks", "[", "'rank'", "]", "\n", "\n", "rank_of_mean_scores", "=", "rank_of_mean_scores", ".", "reset_index", "(", ")", "\n", "mean_scores", "=", "mean_scores", ".", "reset_index", "(", ")", "\n", "mean_ranks", "=", "mean_ranks", ".", "reset_index", "(", ")", "\n", "\n", "# print(mean_scores)", "\n", "# print(rank_of_mean_scores)", "\n", "# print(mean_ranks)", "\n", "\n", "# Average on dataset size", "\n", "dfgb", "=", "mean_scores", ".", "groupby", "(", "[", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "mean_scores_on_sizes", "=", "dfgb", ".", "agg", "(", "{", "'score'", ":", "'mean'", "}", ")", "\n", "\n", "dfgb", "=", "rank_of_mean_scores", ".", "groupby", "(", "[", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "mean_rank_of_mean_scores_on_sizes", "=", "dfgb", ".", "agg", "(", "{", "'rank'", ":", "'mean'", "}", ")", "\n", "\n", "dfgb", "=", "mean_ranks", ".", "groupby", "(", "[", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "mean_ranks_on_sizes", "=", "dfgb", ".", "agg", "(", "{", "'rank'", ":", "'mean'", "}", ")", "\n", "\n", "dfgb", "=", "mean_scores_on_sizes", ".", "groupby", "(", "[", "'db'", ",", "'task'", "]", ")", "\n", "rank_of_mean_scores_on_sizes", "=", "dfgb", "[", "'score'", "]", ".", "rank", "(", "method", "=", "'dense'", ",", "ascending", "=", "False", ")", "\n", "\n", "print", "(", "mean_scores_on_sizes", ")", "\n", "print", "(", "rank_of_mean_scores_on_sizes", ")", "\n", "print", "(", "mean_rank_of_mean_scores_on_sizes", ")", "\n", "print", "(", "mean_ranks_on_sizes", ")", "\n", "\n", "ranks_on_sizes", "=", "mean_ranks_on_sizes", ".", "copy", "(", ")", ".", "rename", "(", "{", "'rank'", ":", "'mean_ranks'", "}", ",", "axis", "=", "1", ")", "\n", "ranks_on_sizes", "[", "'rank_of_mean_scores'", "]", "=", "rank_of_mean_scores_on_sizes", "\n", "ranks_on_sizes", "[", "'mean_rank_of_mean_scores'", "]", "=", "mean_rank_of_mean_scores_on_sizes", "\n", "\n", "print", "(", "ranks_on_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_scores": [[1210, 1342], ["dict", "PlotHelper._plot", "prediction.df_utils.get_ranks_tab", "global_avg_ranks.argmin", "numpy.transpose", "list", "range", "axes[].table", "axes[].table.set_fontsize", "matplotlib.subplots_adjust", "matplotlib.subplots_adjust", "isinstance", "pandas.read_csv", "PlotHelper.rename_str", "len", "ax.annotate", "ax.annotate", "ax.annotate", "list", "global_avg_ranks.astype", "dict", "dict", "dict", "ax.axhline"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._plot", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_ranks_tab", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename_str"], ["", "@", "staticmethod", "\n", "def", "plot_scores", "(", "filepath", ",", "db_order", "=", "None", ",", "method_order", "=", "None", ",", "rename", "=", "dict", "(", ")", ",", "\n", "reference_method", "=", "None", ",", "symbols", "=", "None", ",", "comments", "=", "None", ",", "only_full_samples", "=", "True", ",", "\n", "legend_bbox", "=", "(", "4.22", ",", "1.075", ")", ",", "figsize", "=", "(", "18", ",", "5.25", ")", ",", "table_fontsize", "=", "13", ",", "\n", "y_labelsize", "=", "18", ",", "pos_arrow", "=", "None", ",", "w_bag", "=", "None", ",", "w_const", "=", "None", ",", "\n", "w_cond", "=", "None", ",", "colors", "=", "None", ",", "hline_pos", "=", "None", ",", "ref_vline", "=", "None", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "filepath", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "scores", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "scores", "=", "filepath", "\n", "\n", "", "fig", ",", "axes", ",", "_", ",", "_", "=", "PlotHelper", ".", "_plot", "(", "scores", ",", "'score'", ",", "how", "=", "'no-norm'", ",", "\n", "method_order", "=", "method_order", ",", "\n", "db_order", "=", "db_order", ",", "rename", "=", "rename", ",", "\n", "reference_method", "=", "reference_method", ",", "\n", "figsize", "=", "figsize", ",", "\n", "legend_bbox", "=", "legend_bbox", ",", "\n", "symbols", "=", "symbols", ",", "\n", "comments", "=", "comments", ",", "\n", "only_full_samples", "=", "only_full_samples", ",", "\n", "y_labelsize", "=", "y_labelsize", ",", "\n", "colors", "=", "colors", ",", "\n", "ref_vline", "=", "ref_vline", ",", "\n", ")", "\n", "\n", "df_ranks", "=", "get_ranks_tab", "(", "scores", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "average_sizes", "=", "True", ")", "\n", "\n", "global_avg_ranks", "=", "df_ranks", "[", "(", "'Average'", ",", "'All'", ")", "]", ".", "loc", "[", "'Average'", "]", "\n", "argmin", "=", "global_avg_ranks", ".", "argmin", "(", ")", "\n", "global_avg_ranks", ".", "iloc", "[", "argmin", "]", "=", "f\"\\\\textbf{{{global_avg_ranks.iloc[argmin]}}}\"", "\n", "cellText", "=", "np", ".", "transpose", "(", "[", "list", "(", "global_avg_ranks", ".", "astype", "(", "str", ")", ")", "]", ")", "\n", "rowLabels", "=", "list", "(", "global_avg_ranks", ".", "index", ")", "\n", "rowLabels", "=", "[", "PlotHelper", ".", "rename_str", "(", "rename", ",", "s", ")", "for", "s", "in", "rowLabels", "]", "\n", "n_methods", "=", "cellText", ".", "shape", "[", "0", "]", "\n", "cellColours", "=", "[", "[", "'white'", "]", "]", "*", "n_methods", "\n", "for", "i", "in", "range", "(", "0", ",", "n_methods", ",", "2", ")", ":", "\n", "            ", "cellColours", "[", "i", "]", "=", "[", "'.93'", "]", "\n", "\n", "", "table", "=", "axes", "[", "-", "1", "]", ".", "table", "(", "cellText", "=", "cellText", ",", "loc", "=", "'right'", ",", "\n", "rowLabels", "=", "None", ",", "\n", "colLabels", "=", "[", "'Mean\\nrank'", "]", ",", "\n", "#    bbox=[1.32, -0.11, .19, .87],", "\n", "bbox", "=", "[", "1.02", ",", "0", ",", ".14", ",", "(", "n_methods", "+", "1", ")", "/", "n_methods", "]", ",", "\n", "#    bbox=[1.3, 0, .2, .735],", "\n", "colWidths", "=", "[", "0.14", "]", ",", "\n", "cellColours", "=", "cellColours", ",", "\n", ")", "\n", "table", ".", "set_fontsize", "(", "table_fontsize", ")", "\n", "\n", "n_methods", "=", "9", "if", "method_order", "is", "None", "else", "len", "(", "method_order", ")", "\n", "\n", "# Add brackets", "\n", "ax", "=", "axes", "[", "0", "]", "\n", "\n", "w_bag", "=", "45", "if", "w_bag", "is", "None", "else", "w_bag", "\n", "n_bag", "=", "1.5", "\n", "bag_subsize", "=", "'small'", "\n", "\n", "l_tail", "=", "0.03", "\n", "dh", "=", "1.", "/", "n_methods", "\n", "lw", "=", "1.3", "\n", "fs", "=", "18", "\n", "\n", "if", "n_methods", "<=", "8", ":", "\n", "            ", "w_const", "=", "70", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "70", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "w_bag", "=", "110", "if", "w_bag", "is", "None", "else", "w_bag", "\n", "pos_arrow", "=", "-", "0.94", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "None", "\n", "n_const", "=", "None", "\n", "n_bag", "=", "1.5", "\n", "bag_subsize", "=", "'Large'", "\n", "", "if", "n_methods", "==", "9", ":", "\n", "            ", "w_const", "=", "70", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "70", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "pos_arrow", "=", "-", "0.3", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "2", "\n", "n_const", "=", "6", "\n", "", "elif", "n_methods", "==", "10", ":", "\n", "            ", "w_const", "=", "55", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "70", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "pos_arrow", "=", "-", "0.3", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "3", "\n", "n_const", "=", "7", "\n", "", "elif", "n_methods", "==", "11", ":", "\n", "            ", "w_const", "=", "55", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "86", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "pos_arrow", "=", "-", "0.3", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "3", "\n", "n_const", "=", "8", "\n", "", "elif", "n_methods", "==", "12", ":", "\n", "            ", "w_const", "=", "60", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "60", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "w_bag", "=", "45", "if", "w_bag", "is", "None", "else", "w_bag", "\n", "pos_arrow", "=", "-", "0.74", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "5", "\n", "n_const", "=", "9", "\n", "n_bag", "=", "1.5", "\n", "\n", "# Here is the label and arrow code of interest", "\n", "", "if", "n_const", "is", "not", "None", ":", "\n", "            ", "ax", ".", "annotate", "(", "'Constant\\nimputation\\n\\n'", ",", "xy", "=", "(", "pos_arrow", ",", "n_const", "*", "dh", ")", ",", "xytext", "=", "(", "pos_arrow", "-", "l_tail", ",", "n_const", "*", "dh", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "None", ",", "#dict(boxstyle='square', fc='white'),", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'-[, widthB={w_const/fs}, lengthB=0.5'", ",", "lw", "=", "lw", ")", ",", "\n", "rotation", "=", "90", ",", "\n", ")", "\n", "\n", "", "if", "n_cond", "is", "not", "None", ":", "\n", "            ", "ax", ".", "annotate", "(", "'Conditional\\nimputation\\n\\n'", ",", "xy", "=", "(", "pos_arrow", ",", "n_cond", "*", "dh", ")", ",", "xytext", "=", "(", "pos_arrow", "-", "l_tail", ",", "n_cond", "*", "dh", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "None", ",", "#dict(boxstyle='square', fc='white'),", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'-[, widthB={w_cond/fs}, lengthB=0.5'", ",", "lw", "=", "lw", ")", ",", "\n", "rotation", "=", "90", ",", "\n", ")", "\n", "\n", "", "if", "w_bag", "!=", "0", ":", "\n", "            ", "ax", ".", "annotate", "(", "f'Bagging\\n\\\\{bag_subsize}{{(multiple imputation)}}\\n\\n'", ",", "xy", "=", "(", "pos_arrow", ",", "n_bag", "*", "dh", ")", ",", "xytext", "=", "(", "pos_arrow", "-", "l_tail", ",", "n_bag", "*", "dh", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "None", ",", "#dict(boxstyle='square', fc='white'),", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'-[, widthB={w_bag/fs}, lengthB=0.5'", ",", "lw", "=", "lw", ")", ",", "\n", "rotation", "=", "90", ",", "\n", ")", "\n", "\n", "", "plt", ".", "subplots_adjust", "(", "right", "=", ".88", ")", "\n", "\n", "if", "hline_pos", "is", "not", "None", ":", "\n", "            ", "for", "ax", "in", "axes", ":", "\n", "                ", "for", "pos", "in", "hline_pos", ":", "\n", "                    ", "ax", ".", "axhline", "(", "pos", "-", "0.5", ",", "color", "=", "'black'", ",", "lw", "=", "1", ")", "\n", "\n", "", "", "", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_times": [[1343, 1521], ["dict", "PlotHelper._plot", "pandas.read_csv.groupby().aggregate", "numpy.transpose", "len", "range", "axes_table[].table", "axes_table[].table.set_fontsize", "ax.annotate", "isinstance", "pandas.read_csv", "PlotHelper.rename_str", "len", "ax.annotate", "ax.annotate", "ax.annotate", "scores[].fillna", "ValueError", "pandas.read_csv.groupby", "dict", "scores[].fillna", "dict", "dict", "dict", "ax.axhline", "int"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._plot", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename_str"], ["", "@", "staticmethod", "\n", "def", "plot_times", "(", "filepath", ",", "which", ",", "xticks_dict", "=", "None", ",", "xlims", "=", "None", ",", "db_order", "=", "None", ",", "\n", "method_order", "=", "None", ",", "rename", "=", "dict", "(", ")", ",", "reference_method", "=", "None", ",", "\n", "linear", "=", "False", ",", "only_full_samples", "=", "True", ",", "y_labelsize", "=", "18", ",", "comments", "=", "None", ",", "figsize", "=", "(", "18", ",", "5.25", ")", ",", "\n", "legend_bbox", "=", "(", "4.22", ",", "1.075", ")", ",", "broken_axis", "=", "None", ",", "comments_align", "=", "None", ",", "comments_spacing", "=", "0.025", ",", "\n", "table_fontsize", "=", "13", ",", "pos_arrow", "=", "None", ",", "w_bag", "=", "None", ",", "w_const", "=", "None", ",", "\n", "w_cond", "=", "None", ",", "colors", "=", "None", ",", "hline_pos", "=", "None", ",", "non_ref_vline", "=", "False", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "filepath", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "scores", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "scores", "=", "filepath", "\n", "\n", "", "if", "which", "==", "'PT'", ":", "\n", "            ", "scores", "[", "'total_PT'", "]", "=", "scores", "[", "'imputation_PT'", "]", ".", "fillna", "(", "0", ")", "+", "scores", "[", "'tuning_PT'", "]", "\n", "value", "=", "'total_PT'", "\n", "", "elif", "which", "==", "'WCT'", ":", "\n", "            ", "scores", "[", "'total_WCT'", "]", "=", "scores", "[", "'imputation_WCT'", "]", ".", "fillna", "(", "0", ")", "+", "scores", "[", "'tuning_WCT'", "]", "\n", "value", "=", "'total_WCT'", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unknown argument {which}'", ")", "\n", "", "fig", ",", "axes_bg", ",", "axes_left", ",", "axes_right", "=", "PlotHelper", ".", "_plot", "(", "scores", ",", "value", ",", "how", "=", "'log'", ",", "\n", "xticks_dict", "=", "xticks_dict", ",", "\n", "xlims", "=", "xlims", ",", "\n", "method_order", "=", "method_order", ",", "\n", "db_order", "=", "db_order", ",", "rename", "=", "rename", ",", "\n", "reference_method", "=", "reference_method", ",", "\n", "figsize", "=", "figsize", ",", "\n", "only_full_samples", "=", "only_full_samples", ",", "\n", "y_labelsize", "=", "y_labelsize", ",", "\n", "comments", "=", "comments", ",", "\n", "legend_bbox", "=", "legend_bbox", ",", "\n", "broken_axis", "=", "broken_axis", ",", "\n", "comments_align", "=", "comments_align", ",", "\n", "comments_spacing", "=", "comments_spacing", ",", "\n", "colors", "=", "colors", ",", "\n", "non_ref_vline", "=", "non_ref_vline", ",", "\n", ")", "\n", "\n", "# df_ranks = get_ranks_tab(scores, method_order=method_order, db_order=db_order, average_sizes=True)", "\n", "\n", "# global_avg_ranks = df_ranks[('Average', 'All')].loc['Average']", "\n", "# argmin = global_avg_ranks.argmin()", "\n", "# global_avg_ranks.iloc[argmin] = f\"\\\\textbf{{{global_avg_ranks.iloc[argmin]}}}\"", "\n", "\n", "times", "=", "scores", ".", "groupby", "(", "[", "'method'", "]", ")", ".", "aggregate", "(", "{", "'tuning_PT'", ":", "'sum'", "}", ")", "\n", "# print(times)", "\n", "cellText", "=", "[", "f'{int(times.loc[m]/3600/24):,d}'", ".", "replace", "(", "','", ",", "'\\,'", ")", "for", "m", "in", "method_order", "]", "\n", "# print(cellText)", "\n", "# exit()", "\n", "\n", "cellText", "=", "np", ".", "transpose", "(", "[", "cellText", "]", ")", "\n", "# cellText = np.transpose([list(global_avg_ranks.astype(str))])", "\n", "rowLabels", "=", "method_order", "\n", "rowLabels", "=", "[", "PlotHelper", ".", "rename_str", "(", "rename", ",", "s", ")", "for", "s", "in", "rowLabels", "]", "\n", "n_methods", "=", "len", "(", "cellText", ")", "\n", "cellColours", "=", "[", "[", "'white'", "]", "]", "*", "n_methods", "\n", "for", "i", "in", "range", "(", "0", ",", "n_methods", ",", "2", ")", ":", "\n", "            ", "cellColours", "[", "i", "]", "=", "[", "'.93'", "]", "\n", "\n", "", "axes_table", "=", "axes_bg", "if", "broken_axis", "is", "None", "else", "axes_right", "\n", "\n", "if", "broken_axis", ":", "\n", "            ", "bbox", "=", "[", "1.042", ",", "0", ",", ".28", ",", "(", "n_methods", "+", "1", ")", "/", "n_methods", "]", "\n", "colWidths", "=", "[", "0.28", "]", "\n", "\n", "", "else", ":", "\n", "            ", "bbox", "=", "[", "1.02", ",", "0", ",", ".14", ",", "(", "n_methods", "+", "1", ")", "/", "n_methods", "]", "\n", "colWidths", "=", "[", "0.14", "]", "\n", "\n", "", "table", "=", "axes_table", "[", "-", "1", "]", ".", "table", "(", "cellText", "=", "cellText", ",", "loc", "=", "'right'", ",", "\n", "rowLabels", "=", "None", ",", "\n", "colLabels", "=", "[", "'CPU\\ndays'", "]", ",", "\n", "bbox", "=", "bbox", ",", "\n", "colWidths", "=", "colWidths", ",", "\n", "cellColours", "=", "cellColours", ",", "\n", ")", "\n", "table", ".", "set_fontsize", "(", "table_fontsize", ")", "\n", "\n", "# Add brackets", "\n", "# fs = 18", "\n", "# lw = 1.3", "\n", "# dh = 1./9", "\n", "# l_tail = 0.03", "\n", "n_methods", "=", "9", "if", "method_order", "is", "None", "else", "len", "(", "method_order", ")", "\n", "\n", "w_bag", "=", "45", "if", "w_bag", "is", "None", "else", "w_bag", "\n", "n_bag", "=", "1.5", "\n", "bag_subsize", "=", "'small'", "\n", "\n", "l_tail", "=", "0.03", "\n", "dh", "=", "1.", "/", "n_methods", "\n", "lw", "=", "1.3", "\n", "fs", "=", "18", "\n", "\n", "if", "n_methods", "<=", "8", ":", "\n", "            ", "w_const", "=", "70", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "70", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "w_bag", "=", "110", "if", "w_bag", "is", "None", "else", "w_bag", "\n", "n_cond", "=", "2", "\n", "n_const", "=", "6", "\n", "pos_arrow", "=", "-", "1.84", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "None", "\n", "n_const", "=", "None", "\n", "n_bag", "=", "1.5", "\n", "bag_subsize", "=", "'Large'", "\n", "", "if", "n_methods", "==", "9", ":", "\n", "            ", "w_const", "=", "70", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "70", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "pos_arrow", "=", "-", "0.3", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "2", "\n", "n_const", "=", "6", "\n", "", "elif", "n_methods", "==", "10", ":", "\n", "            ", "w_const", "=", "55", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "70", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "pos_arrow", "=", "-", "0.3", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "3", "\n", "n_const", "=", "7", "\n", "", "elif", "n_methods", "==", "11", ":", "\n", "            ", "w_const", "=", "55", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "86", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "pos_arrow", "=", "-", "0.3", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "3", "\n", "n_const", "=", "8", "\n", "", "elif", "n_methods", "==", "12", ":", "\n", "            ", "w_const", "=", "60", "if", "w_const", "is", "None", "else", "w_const", "\n", "w_cond", "=", "60", "if", "w_cond", "is", "None", "else", "w_cond", "\n", "w_bag", "=", "45", "if", "w_bag", "is", "None", "else", "w_bag", "\n", "pos_arrow", "=", "-", "1.575", "if", "pos_arrow", "is", "None", "else", "pos_arrow", "\n", "n_cond", "=", "5", "\n", "n_const", "=", "9", "\n", "n_bag", "=", "1.5", "\n", "\n", "", "ax", "=", "axes_bg", "[", "0", "]", "if", "broken_axis", "is", "None", "else", "axes_left", "[", "0", "]", "\n", "\n", "# Here is the label and arrow code of interest", "\n", "if", "n_const", "is", "not", "None", ":", "\n", "            ", "ax", ".", "annotate", "(", "'Constant\\nimputation\\n\\n'", ",", "xy", "=", "(", "pos_arrow", ",", "n_const", "*", "dh", ")", ",", "xytext", "=", "(", "pos_arrow", "-", "l_tail", ",", "n_const", "*", "dh", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "None", ",", "#dict(boxstyle='square', fc='white'),", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'-[, widthB={w_const/fs}, lengthB=0.5'", ",", "lw", "=", "lw", ")", ",", "\n", "rotation", "=", "90", ",", "\n", ")", "\n", "\n", "", "if", "n_cond", "is", "not", "None", ":", "\n", "            ", "ax", ".", "annotate", "(", "'Conditional\\nimputation\\n\\n'", ",", "xy", "=", "(", "pos_arrow", ",", "n_cond", "*", "dh", ")", ",", "xytext", "=", "(", "pos_arrow", "-", "l_tail", ",", "n_cond", "*", "dh", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "None", ",", "#dict(boxstyle='square', fc='white'),", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'-[, widthB={w_cond/fs}, lengthB=0.5'", ",", "lw", "=", "lw", ")", ",", "\n", "rotation", "=", "90", ",", "\n", ")", "\n", "\n", "", "if", "w_bag", "!=", "0", ":", "\n", "            ", "ax", ".", "annotate", "(", "f'Bagging\\n\\\\{bag_subsize}{{(multiple imputation)}}\\n\\n'", ",", "xy", "=", "(", "pos_arrow", ",", "n_bag", "*", "dh", ")", ",", "xytext", "=", "(", "pos_arrow", "-", "l_tail", ",", "n_bag", "*", "dh", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "None", ",", "#dict(boxstyle='square', fc='white'),", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'-[, widthB={w_bag/fs}, lengthB=0.5'", ",", "lw", "=", "lw", ")", ",", "\n", "rotation", "=", "90", ",", "\n", ")", "\n", "\n", "# Add arrow on top right comment", "\n", "", "ax", "=", "axes_bg", "[", "-", "1", "]", "if", "broken_axis", "is", "None", "else", "axes_right", "[", "-", "1", "]", "\n", "xpos", "=", "0.7", "if", "broken_axis", "is", "not", "None", "else", "0.85", "\n", "ypos", "=", "0.94", "if", "n_methods", "<", "7", "else", "0.964", "\n", "ax", ".", "annotate", "(", "'Mean time\\nper task'", ",", "xy", "=", "(", "xpos", ",", "ypos", ")", ",", "xytext", "=", "(", "xpos", ",", "1.1", ")", ",", "\n", "xycoords", "=", "'axes fraction'", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "fontsize", "=", "fs", ",", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'->'", ",", "lw", "=", "1", ",", "color", "=", "'gray'", ")", ",", "\n", ")", "\n", "\n", "if", "hline_pos", "is", "not", "None", ":", "\n", "            ", "for", "axes", "in", "[", "axes_bg", ",", "axes_left", ",", "axes_right", "]", ":", "\n", "                ", "if", "axes", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "for", "ax", "in", "axes", ":", "\n", "                    ", "for", "pos", "in", "hline_pos", ":", "\n", "                        ", "ax", ".", "axhline", "(", "pos", "-", "0.5", ",", "color", "=", "'black'", ",", "lw", "=", "1", ")", "\n", "\n", "", "", "", "", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_MIA_linear": [[1522, 1598], ["dict", "PlotHelper._plot", "prediction.df_utils.get_ranks_tab", "global_avg_ranks.argmin", "numpy.transpose", "list", "axes[].table", "axes[].table.set_fontsize", "ax.annotate", "ax.annotate", "matplotlib.subplots_adjust", "matplotlib.subplots_adjust", "isinstance", "pandas.read_csv", "PlotHelper.rename_str", "scores[].isin", "list", "dict", "dict", "global_avg_ranks.astype"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper._plot", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_ranks_tab", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename_str"], ["", "@", "staticmethod", "\n", "def", "plot_MIA_linear", "(", "filepath", ",", "db_order", ",", "method_order", ",", "rename", "=", "dict", "(", ")", ",", "symbols", "=", "None", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "filepath", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "scores", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "scores", "=", "filepath", "\n", "# Select methods of interest", "\n", "", "scores", "=", "scores", ".", "loc", "[", "scores", "[", "'method'", "]", ".", "isin", "(", "method_order", ")", "]", "\n", "\n", "fig", ",", "axes", "=", "PlotHelper", ".", "_plot", "(", "scores", ",", "'score'", ",", "how", "=", "'no-norm'", ",", "\n", "rename", "=", "rename", ",", "\n", "db_order", "=", "db_order", ",", "\n", "method_order", "=", "method_order", ",", "\n", "\n", "#    xlabel='absolute_score',", "\n", "#    xticks_dict={", "\n", "#        0: '0',", "\n", "#        1: '1',", "\n", "#    },", "\n", "#    xlims=(0, 1.1)", "\n", "xticks_dict", "=", "{", "\n", "#    -0.05: '-0.05',", "\n", "0", ":", "'0'", ",", "\n", "0.05", ":", "'0.05'", ",", "\n", ".1", ":", "'0.1'", ",", "\n", "}", ",", "\n", "xlims", "=", "(", "-", "0.04", ",", "0.14", ")", ",", "\n", "#    figsize=(17, 3.25),", "\n", "figsize", "=", "(", "18", ",", "5.25", ")", ",", "\n", "legend_bbox", "=", "(", "4.30", ",", "1.075", ")", ",", "\n", "symbols", "=", "symbols", ",", "\n", ")", "\n", "\n", "df_ranks", "=", "get_ranks_tab", "(", "scores", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "average_sizes", "=", "True", ")", "\n", "\n", "global_avg_ranks", "=", "df_ranks", "[", "(", "'Average'", ",", "'All'", ")", "]", ".", "loc", "[", "'Average'", "]", "\n", "argmin", "=", "global_avg_ranks", ".", "argmin", "(", ")", "\n", "global_avg_ranks", ".", "iloc", "[", "argmin", "]", "=", "f\"\\\\textbf{{{global_avg_ranks.iloc[argmin]}}}\"", "\n", "cellText", "=", "np", ".", "transpose", "(", "[", "list", "(", "global_avg_ranks", ".", "astype", "(", "str", ")", ")", "]", ")", "\n", "rowLabels", "=", "list", "(", "global_avg_ranks", ".", "index", ")", "\n", "rowLabels", "=", "[", "PlotHelper", ".", "rename_str", "(", "rename", ",", "s", ")", "for", "s", "in", "rowLabels", "]", "\n", "\n", "table", "=", "axes", "[", "-", "1", "]", ".", "table", "(", "cellText", "=", "cellText", ",", "loc", "=", "'right'", ",", "\n", "rowLabels", "=", "rowLabels", ",", "\n", "colLabels", "=", "[", "'Mean\\nrank'", "]", ",", "\n", "#    bbox=[1.37, 0, .2, .735],", "\n", "bbox", "=", "[", "1.41", ",", "-", "0.11", ",", ".19", ",", ".87", "]", ",", "\n", "colWidths", "=", "[", "0.2", "]", ",", "\n", ")", "\n", "table", ".", "set_fontsize", "(", "13", ")", "\n", "\n", "# Add brackets", "\n", "ax", "=", "axes", "[", "0", "]", "\n", "fs", "=", "18", "\n", "lw", "=", "1.3", "\n", "dh", "=", "1.", "/", "9", "\n", "l_tail", "=", "0.03", "\n", "pos_arrow", "=", "-", "0.45", "\n", "# Here is the label and arrow code of interest", "\n", "ax", ".", "annotate", "(", "'Constant\\nimputation\\n\\n'", ",", "xy", "=", "(", "pos_arrow", ",", "6", "*", "dh", ")", ",", "xytext", "=", "(", "pos_arrow", "-", "l_tail", ",", "6", "*", "dh", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "None", ",", "#dict(boxstyle='square', fc='white'),", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'-[, widthB={70/fs}, lengthB=0.5'", ",", "lw", "=", "lw", ")", ",", "\n", "rotation", "=", "90", ",", "\n", ")", "\n", "\n", "ax", ".", "annotate", "(", "'Conditional\\nimputation\\n\\n'", ",", "xy", "=", "(", "pos_arrow", ",", "2", "*", "dh", ")", ",", "xytext", "=", "(", "pos_arrow", "-", "l_tail", ",", "2", "*", "dh", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "None", ",", "#dict(boxstyle='square', fc='white'),", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "f'-[, widthB={70/fs}, lengthB=0.5'", ",", "lw", "=", "lw", ")", ",", "\n", "rotation", "=", "90", ",", "\n", ")", "\n", "\n", "plt", ".", "subplots_adjust", "(", "right", "=", ".88", ",", "left", "=", ".09", ")", "\n", "\n", "return", "fig", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.assert_equal": [[6, 16], ["ValueError"], "function", ["None"], ["def", "split_features", "(", "df", ",", "groups", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate": [[18, 59], ["df.reset_index.groupby", "df.groupby.agg", "df.reset_index.reset_index", "df.reset_index.groupby", "df.groupby.agg", "df.reset_index.reset_index"], "function", ["None"], ["\n", "sub_df", "=", "dict", "(", ")", "\n", "\n", "for", "group_id", "in", "groups", ".", "unique", "(", ")", ":", "\n", "# Get the names of the features to drop", "\n", "        ", "features_to_drop", "=", "groups", "[", "groups", "!=", "group_id", "]", ".", "index", "\n", "# Get the data frame without those features", "\n", "if", "isinstance", "(", "df", ",", "pd", ".", "Series", ")", ":", "\n", "            ", "sub_df", "[", "group_id", "]", "=", "df", ".", "drop", "(", "features_to_drop", ")", "\n", "", "else", ":", "\n", "            ", "sub_df", "[", "group_id", "]", "=", "df", ".", "drop", "(", "features_to_drop", ",", "1", ")", "\n", "\n", "", "", "return", "sub_df", "\n", "\n", "\n", "", "def", "fill_df", "(", "df", ",", "b", ",", "value", ",", "keys", "=", "None", ")", ":", "\n", "\n", "    ", "def", "fill", "(", "df", ",", "b", ",", "value", ")", ":", "\n", "        ", "return", "df", ".", "mask", "(", "b", ",", "value", ")", "\n", "\n", "", "if", "isinstance", "(", "df", ",", "dict", ")", ":", "\n", "        ", "if", "keys", "is", "None", ":", "\n", "            ", "return", "{", "k", ":", "fill", "(", "df", "[", "k", "]", ",", "b", "[", "k", "]", ",", "value", ")", "for", "k", "in", "df", ".", "keys", "(", ")", "}", "\n", "\n", "", "df_filled", "=", "dict", "(", ")", "\n", "for", "k", "in", "keys", ":", "\n", "            ", "df_filled", "[", "k", "]", "=", "fill", "(", "df", "[", "k", "]", ",", "b", "[", "k", "]", ",", "value", ")", "\n", "\n", "", "for", "k", "in", "df", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "not", "in", "df_filled", ":", "\n", "                ", "df_filled", "[", "k", "]", "=", "df", "[", "k", "]", ".", "copy", "(", ")", "\n", "\n", "", "", "return", "df_filled", "\n", "\n", "", "if", "isinstance", "(", "df", ",", "list", ")", ":", "\n", "        ", "return", "[", "fill", "(", "v", ",", "b", "[", "k", "]", ",", "value", ")", "for", "k", ",", "v", "in", "enumerate", "(", "df", ")", "]", "\n", "\n", "", "return", "fill", "(", "df", ",", "b", ",", "value", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_scores_tab": [[61, 140], ["scores_raw.copy", "df_utils.aggregate", "df.applymap.set_index", "pandas.pivot_table", "df.applymap.mean", "avg_by_size.applymap.mean", "avg_by_size.applymap.set_index", "df.applymap.index.get_level_values().unique", "df.applymap.index.rename", "df.applymap.columns.rename", "df.applymap.groupby", "df.applymap.reindex", "df.applymap.reindex", "df.applymap.sub", "pandas.isnull", "df.applymap.applymap", "pandas.concat", "df.applymap.reindex", "df.applymap.index.get_level_values", "avg_by_size.applymap.droplevel", "df.applymap.applymap", "df.applymap.applymap", "avg_by_size.applymap.applymap", "avg_by_size.applymap.applymap", "df[].isin", "pandas.isnull", "list", "numpy.isclose().all", "float", "df_utils.get_scores_tab.space"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["\n", "", "def", "rint_features", "(", "df", ",", "features", ")", ":", "\n", "    ", "\"\"\"Inplace round elements of selected columns to nearest integer.\n\n    Parameters:\n    -----------\n    df : pandas.DataFrame\n        The data frame with columns to be rounded.\n    groups : pandas.Series\n        Series with the features' names as index and boolean values where True\n        encode the features to round.\n\n    Returns:\n    --------\n    pandas.DataFrame\n        Data frame with rounded columns.\n\n    \"\"\"", "\n", "features_to_round", "=", "features", "[", "features", "]", ".", "index", "\n", "\n", "df_rounded", "=", "df", ".", "copy", "(", ")", "\n", "\n", "for", "feature_name", "in", "features_to_round", ":", "\n", "        ", "df_rounded", "[", "feature_name", "]", "=", "np", ".", "rint", "(", "df", "[", "feature_name", "]", ")", "\n", "\n", "", "return", "df_rounded", "\n", "\n", "\n", "", "def", "set_dtypes_features", "(", "df", ",", "groups", ",", "dtypes", ")", ":", "\n", "    ", "\"\"\"Split the columns of a df according to their given group.\n\n    Parameters:\n    -----------\n    df : pandas.DataFrame\n        The data frame to be splitted.\n    groups : pandas.Series\n        Series with the features' names or indexs as index and the group as\n        values.\n    group : scalar\n        Scalar to look for in the groups series. The dtype will be set on the\n        matched features.\n    dtypes: python type or np.dtype\n        Matched features will be set to this type\n\n    Returns:\n    --------\n    pandas.DataFrame\n        Data frame with casted dtypes.\n\n    \"\"\"", "\n", "_dtypes", "=", "dict", "(", ")", "\n", "\n", "for", "group", ",", "dtype", "in", "dtypes", ".", "items", "(", ")", ":", "\n", "# Get the names of the features to set the dtype", "\n", "        ", "features", "=", "groups", "[", "groups", "==", "group", "]", ".", "index", "\n", "for", "f", "in", "features", ":", "\n", "            ", "_dtypes", "[", "f", "]", "=", "dtype", "\n", "\n", "", "", "return", "df", ".", "astype", "(", "_dtypes", ")", "\n", "\n", "\n", "", "def", "dtype_from_types", "(", "types", ",", "type_to_dtype", ")", ":", "\n", "    ", "dtype", "=", "dict", "(", ")", "\n", "\n", "for", "f", ",", "t", "in", "types", ".", "items", "(", ")", ":", "\n", "        ", "if", "t", "in", "type_to_dtype", ":", "\n", "            ", "dtype", "[", "f", "]", "=", "type_to_dtype", "[", "t", "]", "\n", "\n", "", "", "return", "dtype", "\n", "\n", "\n", "", "def", "get_columns", "(", "df", ")", ":", "\n", "    ", "if", "isinstance", "(", "df", ",", "pd", ".", "DataFrame", ")", ":", "\n", "        ", "return", "df", ".", "columns", "\n", "", "elif", "isinstance", "(", "df", ",", "pd", ".", "Series", ")", ":", "\n", "        ", "return", "df", ".", "index", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'non supported type {type(df)}'", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_ranks_tab": [[142, 211], ["scores_raw.copy", "df_utils.aggregate", "pd.concat.groupby", "dfgb[].rank", "pd.concat.set_index", "pandas.pivot_table", "pd.concat.applymap", "pd.concat.index.rename", "pd.concat.columns.rename", "df[].unique", "pd.concat.groupby", "pd.concat.reindex", "pd.concat.reindex", "pd.concat.mean", "avg_on_sizes.round.reset_index().set_index", "pandas.concat", "avg_on_sizes.round.round", "pandas.concat", "pd.concat.mean", "avg_on_dbs.round.mean", "pandas.MultiIndex.from_product", "avg_on_dbs.round.round", "pandas.concat", "str", "df[].isin", "avg_on_sizes.round.reset_index", "int"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["    ", "\"\"\"Determine the type of missing value present in the given data frame.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        The data frame storing the input table from which to determine the type\n        of missing values.\n    heuristic : function with pandas.Series -> pandas.Series signature\n        The heuristic according to which are determined the type of missing\n        values. Given a column of df stored as a pandas.Series, the heuristic\n        returns a pandas.Series storing the type of missing values encountered.\n\n    Returns\n    -------\n    pandas.DataFrame\n        A data frame with same index and columns as the input one but storing\n        the type of missing values encountered (0: Not a missing value,\n        1: Not applicable, 2: Not available).\n\n    \"\"\"", "\n", "if", "isinstance", "(", "df", ",", "pd", ".", "Series", ")", ":", "\n", "        ", "return", "heuristic", "(", "df", ")", "\n", "\n", "# Compute the Series storing the types of missing values", "\n", "", "columns", "=", "[", "heuristic", "(", "df", ".", "iloc", "[", ":", ",", "index", "]", ")", "for", "index", "in", "range", "(", "df", ".", "shape", "[", "1", "]", ")", "]", "\n", "# Concat the Series into a data frame", "\n", "df_mv", "=", "pd", ".", "concat", "(", "columns", ",", "axis", "=", "1", ",", "sort", "=", "False", ")", "\n", "\n", "return", "df_mv", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal": [[22, 27], ["None"], "function", ["None"], ["def", "ICD9_equal", "(", "df", ",", "value", ")", ":", "\n", "    ", "\"\"\"Define a helper for ICD9 diagnsoses.\"\"\"", "\n", "return", "(", "(", "df", "[", "ICD9", "]", "==", "value", ")", "\n", "|", "(", "df", "[", "ICD9_main", "]", "==", "value", ")", "\n", "|", "(", "df", "[", "ICD9_sec", "]", "==", "value", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal": [[29, 34], ["None"], "function", ["None"], ["", "def", "ICD10_equal", "(", "df", ",", "value", ")", ":", "\n", "    ", "\"\"\"Define a helper for ICD10 diagnsoses.\"\"\"", "\n", "return", "(", "(", "df", "[", "ICD10", "]", "==", "value", ")", "\n", "|", "(", "df", "[", "ICD10_main", "]", "==", "value", ")", "\n", "|", "(", "df", "[", "ICD10_sec", "]", "==", "value", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10": [[36, 39], ["None"], "function", ["None"], ["", "def", "cancer_ICD10", "(", "df", ",", "value", ")", ":", "\n", "    ", "\"\"\"Define a helper for ICD10 cancer diagnsoses.\"\"\"", "\n", "return", "df", "[", "ICD10_cancer", "]", "==", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9": [[41, 44], ["None"], "function", ["None"], ["", "def", "cancer_ICD9", "(", "df", ",", "value", ")", ":", "\n", "    ", "\"\"\"Define a helper for ICD9 cancer diagnsoses.\"\"\"", "\n", "return", "df", "[", "ICD9_cancer", "]", "==", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.select_idx_breast": [[51, 55], ["df.drop"], "function", ["None"], ["", "def", "select_idx_breast", "(", "df", ")", ":", "\n", "    ", "\"\"\"Define the idx to keep from the database.\"\"\"", "\n", "male_idx", "=", "df", ".", "index", "[", "df", "[", "'31-0.0'", "]", "==", "1", "]", "\n", "return", "df", ".", "drop", "(", "male_idx", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.define_predict_breast": [[58, 83], ["df[].astype", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.cancer_ICD10", "UKBB.ICD10_equal"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal"], ["", "def", "define_predict_breast", "(", "df", ")", ":", "\n", "    ", "\"\"\"Callable used to define the feature to predict.\"\"\"", "\n", "# Breast cancer", "\n", "df", "[", "'C50'", "]", "=", "(", "\n", "cancer_ICD10", "(", "df", ",", "'C500'", ")", "|", "ICD10_equal", "(", "df", ",", "'C500'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C501'", ")", "|", "ICD10_equal", "(", "df", ",", "'C501'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C502'", ")", "|", "ICD10_equal", "(", "df", ",", "'C502'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C503'", ")", "|", "ICD10_equal", "(", "df", ",", "'C503'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C504'", ")", "|", "ICD10_equal", "(", "df", ",", "'C504'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C505'", ")", "|", "ICD10_equal", "(", "df", ",", "'C505'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C506'", ")", "|", "ICD10_equal", "(", "df", ",", "'C506'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C508'", ")", "|", "ICD10_equal", "(", "df", ",", "'C508'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C509'", ")", "|", "ICD10_equal", "(", "df", ",", "'C509'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1740'", ")", "|", "ICD9_equal", "(", "df", ",", "'1740'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1743'", ")", "|", "ICD9_equal", "(", "df", ",", "'1743'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1744'", ")", "|", "ICD9_equal", "(", "df", ",", "'1744'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1745'", ")", "|", "ICD9_equal", "(", "df", ",", "'1745'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1748'", ")", "|", "ICD9_equal", "(", "df", ",", "'1748'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1749'", ")", "|", "ICD9_equal", "(", "df", ",", "'1749'", ")", "\n", ")", "\n", "\n", "# Convert bool to {0, 1}", "\n", "df", "[", "'C50'", "]", "=", "df", "[", "'C50'", "]", ".", "astype", "(", "int", ")", "\n", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.breast_task": [[93, 184], ["transform.Transform", "transform.Transform", "transform.Transform", "task.TaskMeta", "df[].astype", "df[].astype", "df[].astype", "df[].astype", "UKBB.ICD9_equal", "UKBB.ICD10_equal", "UKBB.ICD9_equal", "UKBB.ICD9_equal", "UKBB.ICD10_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "df[].isna", "df[].isna", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.ICD10_equal", "UKBB.ICD9_equal", "UKBB.ICD10_equal", "UKBB.ICD9_equal", "UKBB.ICD10_equal", "UKBB.ICD9_equal", "UKBB.ICD10_equal", "UKBB.ICD9_equal", "UKBB.ICD10_equal", "UKBB.ICD9_equal", "UKBB.ICD10_equal", "UKBB.ICD9_equal", "UKBB.ICD10_equal", "UKBB.ICD10_equal", "UKBB.ICD9_equal"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal"], ["def", "breast_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for breast cancer prediction.\"\"\"", "\n", "breast_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'31-0.0'", "]", ",", "\n", "transform", "=", "select_idx_breast", ",", "\n", ")", "\n", "\n", "def", "define_new_features_breast", "(", "df", ")", ":", "\n", "        ", "\"\"\"Callable used to define new features from a bunch of features.\"\"\"", "\n", "# People with endometriosis", "\n", "df", "[", "'N80'", "]", "=", "(", "\n", "ICD10_equal", "(", "df", ",", "'N800'", ")", "|", "ICD9_equal", "(", "df", ",", "'6170'", ")", "|", "\n", "ICD10_equal", "(", "df", ",", "'N801'", ")", "|", "ICD9_equal", "(", "df", ",", "'6171'", ")", "|", "\n", "ICD10_equal", "(", "df", ",", "'N802'", ")", "|", "ICD9_equal", "(", "df", ",", "'6172'", ")", "|", "\n", "ICD10_equal", "(", "df", ",", "'N803'", ")", "|", "ICD9_equal", "(", "df", ",", "'6173'", ")", "|", "\n", "ICD10_equal", "(", "df", ",", "'N804'", ")", "|", "ICD9_equal", "(", "df", ",", "'6174'", ")", "|", "\n", "ICD10_equal", "(", "df", ",", "'N805'", ")", "|", "ICD9_equal", "(", "df", ",", "'6175'", ")", "|", "\n", "ICD10_equal", "(", "df", ",", "'N806'", ")", "|", "ICD9_equal", "(", "df", ",", "'6176'", ")", "|", "\n", "ICD10_equal", "(", "df", ",", "'N808'", ")", "|", "ICD9_equal", "(", "df", ",", "'6178'", ")", "|", "\n", "ICD10_equal", "(", "df", ",", "'N809'", ")", "|", "ICD9_equal", "(", "df", ",", "'6179'", ")", "\n", ")", "\n", "\n", "# Polycystic ovarian syndrom", "\n", "df", "[", "'E28.2'", "]", "=", "ICD10_equal", "(", "df", ",", "'E282'", ")", "|", "ICD9_equal", "(", "df", ",", "'2564'", ")", "\n", "\n", "# Has cancer", "\n", "df", "[", "'Cancer != C50'", "]", "=", "(", "\n", "(", "~", "df", "[", "ICD10_cancer", "]", ".", "isna", "(", ")", "|", "~", "df", "[", "ICD9_cancer", "]", ".", "isna", "(", ")", ")", "&", "~", "df", "[", "'C50'", "]", "\n", ")", "\n", "\n", "# Ovarian cancer", "\n", "df", "[", "'C56'", "]", "=", "(", "\n", "cancer_ICD10", "(", "df", ",", "'C56'", ")", "|", "ICD10_equal", "(", "df", ",", "'C56'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1830'", ")", "|", "ICD9_equal", "(", "df", ",", "'1830'", ")", "\n", ")", "\n", "\n", "# Convert bool to {0, 1}", "\n", "df", "[", "'N80'", "]", "=", "df", "[", "'N80'", "]", ".", "astype", "(", "int", ")", "\n", "df", "[", "'E28.2'", "]", "=", "df", "[", "'E28.2'", "]", ".", "astype", "(", "int", ")", "\n", "df", "[", "'Cancer != C50'", "]", "=", "df", "[", "'Cancer != C50'", "]", ".", "astype", "(", "int", ")", "\n", "df", "[", "'C56'", "]", "=", "df", "[", "'C56'", "]", ".", "astype", "(", "int", ")", "\n", "\n", "return", "df", "\n", "\n", "", "breast_new_features_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "ICD9", ",", "ICD9_main", ",", "ICD9_sec", ",", "ICD9_cancer", ",", "ICD10", ",", "ICD10_main", ",", "\n", "ICD10_sec", ",", "ICD10_cancer", ",", "'C50'", "]", ",", "\n", "transform", "=", "define_new_features_breast", ",", "\n", "output_features", "=", "[", "'N80'", ",", "'E28.2'", ",", "'Cancer != C50'", ",", "'C56'", "]", ",", "\n", ")", "\n", "\n", "# Define the features to keep", "\n", "breast_keep_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "\n", "'48-0.0'", ",", "# Waist circumpherence", "\n", "'2714-0.0'", ",", "# Age of menarche", "\n", "'3581-0.0'", ",", "# Age of menopause", "\n", "'2724-0.0'", ",", "# Had menopause", "\n", "'21001-0.0'", ",", "# BMI", "\n", "'23104-0.0'", ",", "# BMI", "\n", "'20116-0.0'", ",", "# Smoking status", "\n", "'1239-0.0'", ",", "# Current tobacco smoking", "\n", "'1249-0.0'", ",", "# Past tobacco smoking", "\n", "'22506-0.0'", ",", "# Tobacco smoking", "\n", "'20160-0.0'", ",", "# Ever smoked", "\n", "'1259-0.0'", ",", "# Smoking/smokers in household", "\n", "'3436-0.0'", ",", "# Age started smoking in current smokers", "\n", "'2867-0.0'", ",", "# Age started smoking in former smokers", "\n", "'20161-0.0'", ",", "# Pack years adult smoking as proportion of life span...", "\n", "'20162-0.0'", ",", "# Pack years of smoking", "\n", "'22611-0.0'", ",", "# Workplace had a lot of cigarette smoke...", "\n", "'1787-0.0'", ",", "# Maternal smoking around birth", "\n", "'2794-0.0'", ",", "# Age started oral contraceptive pill", "\n", "'2804-0.0'", ",", "# Age when last used oral contraceptive pill", "\n", "'2784-0.0'", ",", "# Ever taken oral contraceptive pill", "\n", "]", "\n", ")", "\n", "\n", "return", "TaskMeta", "(", "\n", "name", "=", "'breast_25'", ",", "\n", "db", "=", "'UKBB'", ",", "\n", "df_name", "=", "'40663_filtered'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'eid'", ",", "\n", "idx_selection", "=", "breast_idx_transform", ",", "\n", "predict", "=", "breast_predict_transform", ",", "\n", "transform", "=", "breast_new_features_transform", ",", "\n", "select", "=", "breast_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", "encode_y", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.breast_pvals_task": [[189, 248], ["task.TaskMeta", "transform.Transform", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "select_idx_breast().drop", "UKBB.select_idx_breast"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.select_idx_breast"], ["", "def", "breast_pvals_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for breast cancer prediction.\"\"\"", "\n", "# Define which features to keep", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "breast_pvals_keep_transform", "=", "None", "\n", "breast_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'31-0.0'", "]", ",", "\n", "transform", "=", "select_idx_breast", ",", "\n", ")", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "breast_pvals_dir", "=", "'pvals/UKBB/breast_pvals/'", "\n", "breast_idx_path", "=", "f'{breast_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "breast_pvals_path", "=", "f'{breast_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "breast_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "breast_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "breast_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "breast_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "breast_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "breast_top_pvals", "\n", ")", "\n", "\n", "breast_drop_idx", "=", "pd", ".", "read_csv", "(", "breast_idx_path", ",", "index_col", "=", "0", ",", "\n", "squeeze", "=", "True", ")", "\n", "\n", "breast_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'31-0.0'", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "select_idx_breast", "(", "df", ")", ".", "drop", "(", "breast_drop_idx", ".", "index", ",", "\n", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'breast_pvals'", ",", "\n", "db", "=", "'UKBB'", ",", "\n", "df_name", "=", "'40663_filtered'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'eid'", ",", "\n", "idx_selection", "=", "breast_idx_transform", ",", "\n", "predict", "=", "breast_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "breast_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.skin_task": [[253, 359], ["transform.Transform", "task.TaskMeta", "df[].astype", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "UKBB.ICD9_equal", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "df.drop", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "UKBB.cancer_ICD9", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.cancer_ICD10", "UKBB.ICD10_equal"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal"], ["", "def", "skin_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for skin cancer prediction.\"\"\"", "\n", "# Define the callable used to create the feature to predict", "\n", "def", "define_predict_skin", "(", "df", ")", ":", "\n", "        ", "\"\"\"Callable used to define the feature to predict.\"\"\"", "\n", "# Melanoma and other malignant neoplasms of skin", "\n", "df", "[", "'C43-C44'", "]", "=", "(", "\n", "cancer_ICD10", "(", "df", ",", "'C430'", ")", "|", "ICD10_equal", "(", "df", ",", "'C430'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C431'", ")", "|", "ICD10_equal", "(", "df", ",", "'C431'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C432'", ")", "|", "ICD10_equal", "(", "df", ",", "'C432'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C433'", ")", "|", "ICD10_equal", "(", "df", ",", "'C433'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C434'", ")", "|", "ICD10_equal", "(", "df", ",", "'C434'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C435'", ")", "|", "ICD10_equal", "(", "df", ",", "'C435'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C436'", ")", "|", "ICD10_equal", "(", "df", ",", "'C436'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C437'", ")", "|", "ICD10_equal", "(", "df", ",", "'C437'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C438'", ")", "|", "ICD10_equal", "(", "df", ",", "'C438'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C439'", ")", "|", "ICD10_equal", "(", "df", ",", "'C439'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C440'", ")", "|", "ICD10_equal", "(", "df", ",", "'C440'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C441'", ")", "|", "ICD10_equal", "(", "df", ",", "'C441'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C442'", ")", "|", "ICD10_equal", "(", "df", ",", "'C442'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C443'", ")", "|", "ICD10_equal", "(", "df", ",", "'C443'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C444'", ")", "|", "ICD10_equal", "(", "df", ",", "'C444'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C445'", ")", "|", "ICD10_equal", "(", "df", ",", "'C445'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C446'", ")", "|", "ICD10_equal", "(", "df", ",", "'C446'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C447'", ")", "|", "ICD10_equal", "(", "df", ",", "'C447'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C448'", ")", "|", "ICD10_equal", "(", "df", ",", "'C448'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'C449'", ")", "|", "ICD10_equal", "(", "df", ",", "'C449'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1720'", ")", "|", "ICD9_equal", "(", "df", ",", "'1720'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1723'", ")", "|", "ICD9_equal", "(", "df", ",", "'1723'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1725'", ")", "|", "ICD9_equal", "(", "df", ",", "'1725'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1726'", ")", "|", "ICD9_equal", "(", "df", ",", "'1726'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1727'", ")", "|", "ICD9_equal", "(", "df", ",", "'1727'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1729'", ")", "|", "ICD9_equal", "(", "df", ",", "'1729'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1730'", ")", "|", "ICD9_equal", "(", "df", ",", "'1730'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1731'", ")", "|", "ICD9_equal", "(", "df", ",", "'1731'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1732'", ")", "|", "ICD9_equal", "(", "df", ",", "'1732'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1733'", ")", "|", "ICD9_equal", "(", "df", ",", "'1733'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1734'", ")", "|", "ICD9_equal", "(", "df", ",", "'1734'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1735'", ")", "|", "ICD9_equal", "(", "df", ",", "'1735'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1736'", ")", "|", "ICD9_equal", "(", "df", ",", "'1736'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1737'", ")", "|", "ICD9_equal", "(", "df", ",", "'1737'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'1739'", ")", "|", "ICD9_equal", "(", "df", ",", "'1739'", ")", "\n", ")", "\n", "\n", "# Convert bool to {0, 1}", "\n", "df", "[", "'C43-C44'", "]", "=", "df", "[", "'C43-C44'", "]", ".", "astype", "(", "int", ")", "\n", "\n", "return", "df", "\n", "\n", "", "skin_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "ICD9", ",", "ICD9_main", ",", "ICD9_sec", ",", "ICD9_cancer", ",", "ICD10", ",", "ICD10_main", ",", "\n", "ICD10_sec", ",", "ICD10_cancer", "]", ",", "\n", "transform", "=", "define_predict_skin", ",", "\n", "output_features", "=", "[", "'C43-C44'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "skin_pvals_keep_transform", "=", "None", "\n", "skin_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "skin_pvals_dir", "=", "'pvals/UKBB/skin_pvals/'", "\n", "skin_idx_path", "=", "f'{skin_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "skin_pvals_path", "=", "f'{skin_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "skin_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "skin_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "skin_pvals_path", ",", "header", "=", "None", ",", "index_col", "=", "0", ",", "\n", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "skin_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "skin_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "skin_top_pvals", "\n", ")", "\n", "\n", "skin_drop_idx", "=", "pd", ".", "read_csv", "(", "skin_idx_path", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "skin_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "skin_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'skin_pvals'", ",", "\n", "db", "=", "'UKBB'", ",", "\n", "df_name", "=", "'40663_filtered'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'eid'", ",", "\n", "idx_selection", "=", "skin_idx_transform", ",", "\n", "predict", "=", "skin_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "skin_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.parkinson_task": [[364, 448], ["transform.Transform", "task.TaskMeta", "df[].astype", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "UKBB.ICD9_equal", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "UKBB.cancer_ICD9", "UKBB.ICD9_equal", "df.drop", "UKBB.cancer_ICD9", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.ICD10_equal", "UKBB.cancer_ICD10", "UKBB.cancer_ICD10", "UKBB.ICD10_equal"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD9_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD9", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.cancer_ICD10", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.ICD10_equal"], ["", "def", "parkinson_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for parkinson prediction.\"\"\"", "\n", "# Define the callable used to create the feature to predict", "\n", "def", "define_predict_parkinson", "(", "df", ")", ":", "\n", "        ", "\"\"\"Callable used to define the feature to predict.\"\"\"", "\n", "# Parkinson's disease", "\n", "df", "[", "'Parkinson'", "]", "=", "(", "\n", "cancer_ICD10", "(", "df", ",", "'G20'", ")", "|", "ICD10_equal", "(", "df", ",", "'G20'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'G210'", ")", "|", "ICD10_equal", "(", "df", ",", "'G210'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'G211'", ")", "|", "ICD10_equal", "(", "df", ",", "'G211'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'G212'", ")", "|", "ICD10_equal", "(", "df", ",", "'G212'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'G213'", ")", "|", "ICD10_equal", "(", "df", ",", "'G213'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'G214'", ")", "|", "ICD10_equal", "(", "df", ",", "'G214'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'G218'", ")", "|", "ICD10_equal", "(", "df", ",", "'G218'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'G219'", ")", "|", "ICD10_equal", "(", "df", ",", "'G219'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'G22'", ")", "|", "ICD10_equal", "(", "df", ",", "'G22'", ")", "|", "\n", "cancer_ICD10", "(", "df", ",", "'F023'", ")", "|", "ICD10_equal", "(", "df", ",", "'F023'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'3320'", ")", "|", "ICD9_equal", "(", "df", ",", "'3320'", ")", "|", "\n", "cancer_ICD9", "(", "df", ",", "'3321'", ")", "|", "ICD9_equal", "(", "df", ",", "'3321'", ")", "\n", ")", "\n", "\n", "# Convert bool to {0, 1}", "\n", "df", "[", "'Parkinson'", "]", "=", "df", "[", "'Parkinson'", "]", ".", "astype", "(", "int", ")", "\n", "\n", "return", "df", "\n", "\n", "", "parkinson_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "ICD9", ",", "ICD9_main", ",", "ICD9_sec", ",", "ICD9_cancer", ",", "ICD10", ",", "ICD10_main", ",", "\n", "ICD10_sec", ",", "ICD10_cancer", "]", ",", "\n", "transform", "=", "define_predict_parkinson", ",", "\n", "output_features", "=", "[", "'Parkinson'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "parkinson_pvals_keep_transform", "=", "None", "\n", "parkinson_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "parkinson_pvals_dir", "=", "'pvals/UKBB/parkinson_pvals/'", "\n", "parkinson_idx_path", "=", "f'{parkinson_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "parkinson_pvals_path", "=", "f'{parkinson_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "parkinson_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "parkinson_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "parkinson_pvals_path", ",", "header", "=", "None", ",", "index_col", "=", "0", ",", "\n", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "parkinson_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "parkinson_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "parkinson_top_pvals", "\n", ")", "\n", "\n", "parkinson_drop_idx", "=", "pd", ".", "read_csv", "(", "parkinson_idx_path", ",", "index_col", "=", "0", ",", "\n", "squeeze", "=", "True", ")", "\n", "\n", "parkinson_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "parkinson_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'parkinson_pvals'", ",", "\n", "db", "=", "'UKBB'", ",", "\n", "df_name", "=", "'40663_filtered'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'eid'", ",", "\n", "idx_selection", "=", "parkinson_idx_transform", ",", "\n", "predict", "=", "parkinson_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "parkinson_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.UKBB.fluid_task": [[453, 510], ["transform.Transform", "task.TaskMeta", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "df.drop"], "function", ["None"], ["", "def", "fluid_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for fluid_intelligence prediction.\"\"\"", "\n", "fluid_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'20016-0.0'", "]", ",", "\n", "output_features", "=", "[", "'20016-0.0'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "fluid_pvals_keep_transform", "=", "None", "\n", "fluid_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "fluid_pvals_dir", "=", "'pvals/UKBB/fluid_pvals/'", "\n", "fluid_idx_path", "=", "f'{fluid_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "fluid_pvals_path", "=", "f'{fluid_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "fluid_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "fluid_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "fluid_pvals_path", ",", "\n", "header", "=", "None", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "fluid_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "fluid_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "fluid_top_pvals", "\n", ")", "\n", "\n", "fluid_drop_idx", "=", "pd", ".", "read_csv", "(", "fluid_idx_path", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "fluid_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "fluid_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'fluid_pvals'", ",", "\n", "db", "=", "'UKBB'", ",", "\n", "df_name", "=", "'40663_filtered'", ",", "\n", "classif", "=", "False", ",", "\n", "idx_column", "=", "'eid'", ",", "\n", "idx_selection", "=", "fluid_idx_transform", ",", "\n", "predict", "=", "fluid_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "fluid_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.MIMIC.septic_task": [[32, 112], ["transform.Transform", "task.TaskMeta", "patients_diagnosis.merge", "pd.DataFrame.compute", "idx.difference().intersection", "positives_idx.intersection.intersection", "pandas.DataFrame", "pandas.DataFrame", "pandas.concat().sort_index", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.DataFrame.drop_duplicates().set_index", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "idx.difference", "pandas.concat", "pd.DataFrame.drop_duplicates", "pd.concat().sort_index.drop"], "function", ["None"], ["", "def", "septic_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for septic shock prediction.\"\"\"", "\n", "# Define y", "\n", "def", "define_predict_septic", "(", "df", ")", ":", "\n", "        ", "\"\"\"Compute y from patients table.\"\"\"", "\n", "# Ignore given df", "\n", "positives", "=", "patients_diagnosis", ".", "merge", "(", "septic_shock", ",", "how", "=", "'inner'", ",", "on", "=", "'ICD9_CODE'", ")", "\n", "positives", "=", "positives", ".", "drop_duplicates", "(", "subset", "=", "[", "'SUBJECT_ID'", "]", ")", ".", "set_index", "(", "'SUBJECT_ID'", ")", ".", "index", "\n", "positives_idx", "=", "positives", ".", "compute", "(", ")", "\n", "\n", "# Get full idx from df and set the complementary to 0", "\n", "# idx = patients.set_index('SUBJECT_ID').index.compute()", "\n", "idx", "=", "df", ".", "index", "\n", "# need to intersect because one index of positives_idx is not in idx", "\n", "negatives_idx", "=", "idx", ".", "difference", "(", "positives_idx", ")", ".", "intersection", "(", "idx", ")", "\n", "positives_idx", "=", "positives_idx", ".", "intersection", "(", "idx", ")", "\n", "\n", "positives", "=", "pd", ".", "DataFrame", "(", "{", "'y'", ":", "1", "}", ",", "index", "=", "positives_idx", ")", "\n", "negatives", "=", "pd", ".", "DataFrame", "(", "{", "'y'", ":", "0", "}", ",", "index", "=", "negatives_idx", ")", "\n", "df", "=", "pd", ".", "concat", "(", "(", "positives", ",", "negatives", ")", ",", "axis", "=", "0", ")", ".", "sort_index", "(", ")", "\n", "\n", "return", "df", "\n", "\n", "", "septic_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "define_predict_septic", ",", "\n", "output_features", "=", "[", "'y'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "septic_pvals_keep_transform", "=", "None", "\n", "septic_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "septic_pvals_dir", "=", "'pvals/MIMIC/septic_pvals/'", "\n", "septic_idx_path", "=", "f'{septic_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "septic_pvals_path", "=", "f'{septic_pvals_dir}RS{RS}-T{T}-pvals.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "septic_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "septic_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "septic_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "septic_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "septic_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "septic_top_pvals", "\n", ")", "\n", "\n", "septic_drop_idx", "=", "pd", ".", "read_csv", "(", "septic_idx_path", ",", "index_col", "=", "0", ",", "\n", "squeeze", "=", "True", ")", "\n", "\n", "septic_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "septic_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'septic_pvals'", ",", "\n", "db", "=", "'MIMIC'", ",", "\n", "df_name", "=", "'X_labevents'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'subject_id'", ",", "\n", "idx_selection", "=", "septic_idx_transform", ",", "\n", "predict", "=", "septic_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "septic_pvals_keep_transform", ",", "\n", "encode_select", "=", "None", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.MIMIC.hemo_task": [[117, 196], ["transform.Transform", "task.TaskMeta", "patients_diagnosis.merge", "pd.DataFrame.compute", "idx.difference().intersection", "positives_idx.intersection.intersection", "pandas.DataFrame", "pandas.DataFrame", "pandas.concat().sort_index", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.DataFrame.drop_duplicates().set_index", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "idx.difference", "pandas.concat", "pd.DataFrame.drop_duplicates", "pd.concat().sort_index.drop"], "function", ["None"], ["", "def", "hemo_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for Hemorrhagic shock prediction.\"\"\"", "\n", "# Define y", "\n", "def", "define_predict_hemo", "(", "df", ")", ":", "\n", "        ", "\"\"\"Compute y from patients table.\"\"\"", "\n", "# Ignore given df", "\n", "positives", "=", "patients_diagnosis", ".", "merge", "(", "hemo_shock", ",", "how", "=", "'inner'", ",", "on", "=", "'ICD9_CODE'", ")", "\n", "positives", "=", "positives", ".", "drop_duplicates", "(", "subset", "=", "[", "'SUBJECT_ID'", "]", ")", ".", "set_index", "(", "'SUBJECT_ID'", ")", ".", "index", "\n", "positives_idx", "=", "positives", ".", "compute", "(", ")", "\n", "\n", "# Get full idx from df and set the complementary to 0", "\n", "# idx = patients.set_index('SUBJECT_ID').index.compute()", "\n", "idx", "=", "df", ".", "index", "\n", "# need to intersect because one index of positives_idx is not in idx", "\n", "negatives_idx", "=", "idx", ".", "difference", "(", "positives_idx", ")", ".", "intersection", "(", "idx", ")", "\n", "positives_idx", "=", "positives_idx", ".", "intersection", "(", "idx", ")", "\n", "\n", "positives", "=", "pd", ".", "DataFrame", "(", "{", "'y'", ":", "1", "}", ",", "index", "=", "positives_idx", ")", "\n", "negatives", "=", "pd", ".", "DataFrame", "(", "{", "'y'", ":", "0", "}", ",", "index", "=", "negatives_idx", ")", "\n", "df", "=", "pd", ".", "concat", "(", "(", "positives", ",", "negatives", ")", ",", "axis", "=", "0", ")", ".", "sort_index", "(", ")", "\n", "\n", "return", "df", "\n", "\n", "", "hemo_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "define_predict_hemo", ",", "\n", "output_features", "=", "[", "'y'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "hemo_pvals_keep_transform", "=", "None", "\n", "hemo_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "hemo_pvals_dir", "=", "'pvals/MIMIC/hemo_pvals/'", "\n", "hemo_idx_path", "=", "f'{hemo_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "hemo_pvals_path", "=", "f'{hemo_pvals_dir}RS{RS}-T{T}-pvals.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "hemo_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "hemo_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "hemo_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "hemo_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "hemo_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "hemo_top_pvals", "\n", ")", "\n", "\n", "hemo_drop_idx", "=", "pd", ".", "read_csv", "(", "hemo_idx_path", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "hemo_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "hemo_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'hemo_pvals'", ",", "\n", "db", "=", "'MIMIC'", ",", "\n", "df_name", "=", "'X_labevents'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'subject_id'", ",", "\n", "idx_selection", "=", "hemo_idx_transform", ",", "\n", "predict", "=", "hemo_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "hemo_pvals_keep_transform", ",", "\n", "encode_select", "=", "None", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.TB.death_task": [[12, 69], ["transform.Transform", "task.TaskMeta", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "df.drop"], "function", ["None"], ["def", "death_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for death prediction.\"\"\"", "\n", "death_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'D\u00e9c\u00e8s'", "]", ",", "\n", "output_features", "=", "[", "'D\u00e9c\u00e8s'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "death_pvals_keep_transform", "=", "None", "\n", "death_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "death_pvals_dir", "=", "'pvals/TB/death_pvals/'", "\n", "death_idx_path", "=", "f'{death_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "death_pvals_path", "=", "f'{death_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "death_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "death_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "death_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "death_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "death_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "death_top_pvals", "\n", ")", "\n", "\n", "death_drop_idx", "=", "pd", ".", "read_csv", "(", "death_idx_path", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "death_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "death_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'death_pvals'", ",", "\n", "db", "=", "'TB'", ",", "\n", "df_name", "=", "'20000'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'ID_PATIENT'", ",", "\n", "idx_selection", "=", "death_idx_transform", ",", "\n", "predict", "=", "death_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "death_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.TB.platelet_task": [[81, 163], ["transform.Transform", "task.TaskMeta", "df.astype.astype", "df[].divide", "df[].divide", "df.astype.replace"], "function", ["None"], ["def", "platelet_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for platelet prediction.\"\"\"", "\n", "def", "define_new_features_platelet", "(", "df", ")", ":", "\n", "        ", "\"\"\"Callable used to define new features from a bunch of features.\"\"\"", "\n", "# github.com/wjiang94/ABSLOPE/blob/master/ABSLOPE/OnlineSupp/OnlineSupp.pdf", "\n", "\n", "df", "=", "df", ".", "astype", "(", "float", ")", "\n", "\n", "df", "[", "'Age'", "]", "=", "df", "[", "'Age du patient (ans)'", "]", "\n", "df", "[", "'SI'", "]", "=", "df", "[", "'FC en phase hospitali\u00e8re'", "]", ".", "divide", "(", "df", "[", "'Pression Art\u00e9rielle Systolique - PAS'", "]", ")", "\n", "df", "[", "'MBP'", "]", "=", "(", "2", "*", "df", "[", "'Pression Art\u00e9rielle Diastolique - PAD'", "]", "+", "df", "[", "'Pression Art\u00e9rielle Systolique - PAS'", "]", ")", "/", "3", "\n", "df", "[", "'Delta.hemo'", "]", "=", "df", "[", "'Delta H\u00e9mocue'", "]", "\n", "df", "[", "'Time.amb'", "]", "=", "df", "[", "'D\u00e9lai \u00ab arriv\u00e9e sur les lieux - arriv\u00e9e h\u00f4pital \u00bb'", "]", "\n", "df", "[", "'Lactate'", "]", "=", "df", "[", "'Lactates'", "]", "\n", "df", "[", "'Temp'", "]", "=", "df", "[", "'Temp\u00e9rature'", "]", "\n", "df", "[", "'HR'", "]", "=", "df", "[", "'FC en phase hospitali\u00e8re'", "]", "\n", "df", "[", "'VE'", "]", "=", "df", "[", "'Cristallo\u00efdes'", "]", "+", "df", "[", "'Collo\u00efdes'", "]", "\n", "df", "[", "'RBC'", "]", "=", "df", "[", "'Choc h\u00e9morragique (? 4 CGR sur 6h)'", "]", "\n", "df", "[", "'SI.amb'", "]", "=", "df", "[", "'Fr\u00e9quence cardiaque (FC) \u00e0 l arriv\u00e9e du SMUR'", "]", ".", "divide", "(", "df", "[", "'Pression Art\u00e9rielle Systolique (PAS) \u00e0 l arriv\u00e9e du SMUR'", "]", ")", "\n", "df", "[", "'MAP.amb'", "]", "=", "(", "2", "*", "df", "[", "'Pression Art\u00e9rielle Diastolique (PAD) \u00e0 l arriv\u00e9e du SMUR'", "]", "+", "df", "[", "'Pression Art\u00e9rielle Systolique (PAS) \u00e0 l arriv\u00e9e du SMUR'", "]", ")", "/", "3", "\n", "df", "[", "'HR.max'", "]", "=", "df", "[", "'Fr\u00e9quence cardiaque (FC) maximum'", "]", "\n", "df", "[", "'SBP.min'", "]", "=", "df", "[", "'Pression Art\u00e9rielle Systolique (PAS) minimum'", "]", "\n", "df", "[", "'DBP.min'", "]", "=", "df", "[", "'Pression Art\u00e9rielle Diastolique (PAD) minimum'", "]", "\n", "\n", "# Replace potential infinite values by Nans (divide may have created infs)", "\n", "df", ".", "replace", "(", "[", "np", ".", "inf", ",", "-", "np", ".", "inf", "]", ",", "np", ".", "nan", ",", "inplace", "=", "True", ")", "\n", "\n", "return", "df", "\n", "\n", "", "platelet_new_features_tranform", "=", "Transform", "(", "\n", "input_features", "=", "[", "\n", "'Age du patient (ans)'", ",", "\n", "'FC en phase hospitali\u00e8re'", ",", "\n", "'Pression Art\u00e9rielle Systolique - PAS'", ",", "\n", "'Pression Art\u00e9rielle Diastolique - PAD'", ",", "\n", "'Delta H\u00e9mocue'", ",", "\n", "'D\u00e9lai \u00ab arriv\u00e9e sur les lieux - arriv\u00e9e h\u00f4pital \u00bb'", ",", "\n", "'Lactates'", ",", "\n", "'Temp\u00e9rature'", ",", "\n", "# 'FC en phase hospitali\u00e8re',", "\n", "'Cristallo\u00efdes'", ",", "\n", "'Collo\u00efdes'", ",", "\n", "'Choc h\u00e9morragique (? 4 CGR sur 6h)'", ",", "\n", "'Fr\u00e9quence cardiaque (FC) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'Pression Art\u00e9rielle Systolique (PAS) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'Pression Art\u00e9rielle Diastolique (PAD) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'Fr\u00e9quence cardiaque (FC) maximum'", ",", "\n", "'Pression Art\u00e9rielle Systolique (PAS) minimum'", ",", "\n", "'Pression Art\u00e9rielle Diastolique (PAD) minimum'", ",", "\n", "]", ",", "\n", "transform", "=", "define_new_features_platelet", ",", "\n", "output_features", "=", "[", "\n", "'Age'", ",", "\n", "'SI'", ",", "\n", "'MBP'", ",", "\n", "'Delta.hemo'", ",", "\n", "'Time.amb'", ",", "\n", "'Lactate'", ",", "\n", "'Temp'", ",", "\n", "'HR'", ",", "\n", "'VE'", ",", "\n", "'RBC'", ",", "\n", "'SI.amb'", ",", "\n", "'MAP.amb'", ",", "\n", "'HR.max'", ",", "\n", "'SBP.min'", ",", "\n", "'DBP.min'", ",", "\n", "]", ",", "\n", ")", "\n", "\n", "return", "TaskMeta", "(", "\n", "name", "=", "'platelet'", ",", "\n", "db", "=", "'TB'", ",", "\n", "df_name", "=", "'20000'", ",", "\n", "classif", "=", "False", ",", "\n", "idx_column", "=", "'ID_PATIENT'", ",", "\n", "idx_selection", "=", "None", ",", "\n", "predict", "=", "platelet_predict_transform", ",", "\n", "transform", "=", "platelet_new_features_tranform", ",", "\n", "select", "=", "None", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "'ordinal'", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.TB.platelet_pvals_task": [[168, 229], ["task.TaskMeta", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "df.drop", "pd.read_csv.index.str.match"], "function", ["None"], ["", "def", "platelet_pvals_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for platelet prediction.\"\"\"", "\n", "# Drop features linked to feature to predict", "\n", "platelet_drop_features", "=", "{", "\n", "'Plaquettes'", ",", "\n", "}", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "platelet_pvals_keep_transform", "=", "None", "\n", "platelet_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "platelet_pvals_dir", "=", "'pvals/TB/platelet_pvals/'", "\n", "platelet_idx_path", "=", "f'{platelet_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "platelet_pvals_path", "=", "f'{platelet_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "platelet_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "platelet_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "platelet_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "# Match exact feature or start with and followed by '_' (categorical)", "\n", "for", "f", "in", "platelet_drop_features", ":", "# Drop asked features from pvals", "\n", "            ", "regex", "=", "f'(^{f}$|^{f}_)'", "\n", "pvals", "=", "pvals", "[", "~", "pvals", ".", "index", ".", "str", ".", "match", "(", "regex", ")", "]", "\n", "", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "platelet_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "platelet_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "platelet_top_pvals", "\n", ")", "\n", "\n", "platelet_drop_idx", "=", "pd", ".", "read_csv", "(", "platelet_idx_path", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "platelet_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "platelet_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'platelet_pvals'", ",", "\n", "db", "=", "'TB'", ",", "\n", "df_name", "=", "'20000'", ",", "\n", "classif", "=", "False", ",", "\n", "idx_column", "=", "'ID_PATIENT'", ",", "\n", "idx_selection", "=", "platelet_idx_transform", ",", "\n", "predict", "=", "platelet_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "platelet_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.TB.hemo_task": [[241, 312], ["transform.Transform", "task.TaskMeta", "df.astype.astype", "df.astype.replace"], "function", ["None"], ["def", "hemo_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for hemo shock prediction.\"\"\"", "\n", "\n", "def", "define_new_features_hemo", "(", "df", ")", ":", "\n", "        ", "\"\"\"Callable used to define new features from a bunch of features.\"\"\"", "\n", "df", "=", "df", ".", "astype", "(", "float", ")", "\n", "\n", "df", "[", "'Age'", "]", "=", "df", "[", "'Age du patient (ans)'", "]", "\n", "df", "[", "'BMI'", "]", "=", "df", "[", "'BMI'", "]", "\n", "df", "[", "'FC.SMUR'", "]", "=", "df", "[", "'Fr\u00e9quence cardiaque (FC) \u00e0 l arriv\u00e9e du SMUR'", "]", "\n", "df", "[", "'SD.SMUR'", "]", "=", "df", "[", "'Pression Art\u00e9rielle Systolique (PAS) \u00e0 l arriv\u00e9e du SMUR'", "]", "-", "df", "[", "'Pression Art\u00e9rielle Diastolique (PAD) \u00e0 l arriv\u00e9e du SMUR'", "]", "\n", "df", "[", "'SD.min'", "]", "=", "df", "[", "'Pression Art\u00e9rielle Systolique (PAS) minimum'", "]", "-", "df", "[", "'Pression Art\u00e9rielle Diastolique (PAD) minimum'", "]", "\n", "df", "[", "'FC.max'", "]", "=", "df", "[", "'Fr\u00e9quence cardiaque (FC) maximum'", "]", "\n", "df", "[", "'Glasgow.moteur.init'", "]", "=", "df", "[", "'Glasgow moteur initial'", "]", "\n", "df", "[", "'Glasgow.init'", "]", "=", "df", "[", "'Glasgow initial'", "]", "\n", "df", "[", "'Hemocue.init'", "]", "=", "df", "[", "'H\u00e9mocue initial'", "]", "\n", "df", "[", "'SpO2.min'", "]", "=", "df", "[", "'SpO2 min'", "]", "\n", "df", "[", "'RT.colloides'", "]", "=", "df", "[", "'Collo\u00efdes'", "]", "\n", "df", "[", "'RT.cristalloides'", "]", "=", "df", "[", "'Cristallo\u00efdes'", "]", "\n", "\n", "# Replace potential infinite values by Nans (divide may have created infs)", "\n", "df", ".", "replace", "(", "[", "np", ".", "inf", ",", "-", "np", ".", "inf", "]", ",", "np", ".", "nan", ",", "inplace", "=", "True", ")", "\n", "\n", "return", "df", "\n", "\n", "", "hemo_new_features_tranform", "=", "Transform", "(", "\n", "input_features", "=", "[", "\n", "'Age du patient (ans)'", ",", "\n", "'BMI'", ",", "\n", "'Fr\u00e9quence cardiaque (FC) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'Pression Art\u00e9rielle Systolique (PAS) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'Pression Art\u00e9rielle Diastolique (PAD) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'Pression Art\u00e9rielle Systolique (PAS) minimum'", ",", "\n", "'Pression Art\u00e9rielle Diastolique (PAD) minimum'", ",", "\n", "'Fr\u00e9quence cardiaque (FC) maximum'", ",", "\n", "'Glasgow moteur initial'", ",", "\n", "'Glasgow initial'", ",", "\n", "'H\u00e9mocue initial'", ",", "\n", "'SpO2 min'", ",", "\n", "'Collo\u00efdes'", ",", "\n", "'Cristallo\u00efdes'", ",", "\n", "]", ",", "\n", "transform", "=", "define_new_features_hemo", ",", "\n", "output_features", "=", "[", "\n", "'Age'", ",", "\n", "'BMI'", ",", "\n", "'FC.SMUR'", ",", "\n", "'SD.SMUR'", ",", "\n", "'SD.min'", ",", "\n", "'FC.max'", ",", "\n", "'Glasgow.moteur.init'", ",", "\n", "'Glasgow.init'", ",", "\n", "'Hemocue.init'", ",", "\n", "'SpO2.min'", ",", "\n", "'RT.colloides'", ",", "\n", "'RT.cristalloides'", "\n", "]", ",", "\n", ")", "\n", "\n", "return", "TaskMeta", "(", "\n", "name", "=", "'hemo'", ",", "\n", "db", "=", "'TB'", ",", "\n", "df_name", "=", "'20000'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'ID_PATIENT'", ",", "\n", "idx_selection", "=", "None", ",", "\n", "predict", "=", "hemo_predict_transform", ",", "\n", "transform", "=", "hemo_new_features_tranform", ",", "\n", "select", "=", "None", ",", "\n", "encode_transform", "=", "None", ",", "\n", "encode_select", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.TB.hemo_pvals_task": [[317, 369], ["task.TaskMeta", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "df.drop"], "function", ["None"], ["", "def", "hemo_pvals_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for hemo shock prediction.\"\"\"", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "hemo_pvals_keep_transform", "=", "None", "\n", "hemo_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "hemo_pvals_dir", "=", "'pvals/TB/hemo_pvals/'", "\n", "hemo_idx_path", "=", "f'{hemo_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "hemo_pvals_path", "=", "f'{hemo_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "hemo_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "hemo_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "hemo_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "hemo_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "hemo_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "hemo_top_pvals", "\n", ")", "\n", "\n", "hemo_drop_idx", "=", "pd", ".", "read_csv", "(", "hemo_idx_path", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "hemo_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "hemo_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'hemo_pvals'", ",", "\n", "db", "=", "'TB'", ",", "\n", "df_name", "=", "'20000'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'ID_PATIENT'", ",", "\n", "idx_selection", "=", "hemo_idx_transform", ",", "\n", "predict", "=", "hemo_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "hemo_pvals_keep_transform", ",", "\n", "encode_transform", "=", "None", ",", "\n", "encode_select", "=", "'all'", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.TB.acid_task": [[374, 538], ["transform.Transform", "transform.Transform", "transform.Transform", "task.TaskMeta", "df.astype.astype", "df[].divide", "numpy.minimum", "numpy.minimum", "numpy.maximum", "df[].divide", "df.astype.replace"], "function", ["None"], ["", "def", "acid_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for acid prediction.\"\"\"", "\n", "acid_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'Acide tranexamique'", "]", ",", "\n", "output_features", "=", "[", "'Acide tranexamique'", "]", ",", "\n", ")", "\n", "\n", "def", "define_new_features_acid", "(", "df", ")", ":", "\n", "        ", "\"\"\"Callable used to define new features from a bunch of features.\"\"\"", "\n", "df", "=", "df", ".", "astype", "(", "float", ")", "\n", "\n", "# Temp features (will be dropped)", "\n", "df", "[", "'SBP.min'", "]", "=", "df", "[", "'Pression Art\u00e9rielle Systolique (PAS) minimum'", "]", "\n", "df", "[", "'SBP.MICU'", "]", "=", "df", "[", "'Pression Art\u00e9rielle Systolique (PAS) \u00e0 l arriv\u00e9e du SMUR'", "]", "\n", "df", "[", "'DBP.min'", "]", "=", "df", "[", "'Pression Art\u00e9rielle Diastolique (PAD) minimum'", "]", "\n", "df", "[", "'DBP.MICU'", "]", "=", "df", "[", "'Pression Art\u00e9rielle Diastolique (PAD) \u00e0 l arriv\u00e9e du SMUR'", "]", "\n", "df", "[", "'HR.max'", "]", "=", "df", "[", "'Fr\u00e9quence cardiaque (FC) maximum'", "]", "\n", "df", "[", "'HR.MICU'", "]", "=", "df", "[", "'Fr\u00e9quence cardiaque (FC) \u00e0 l arriv\u00e9e du SMUR'", "]", "\n", "df", "[", "'Shock.index.h'", "]", "=", "df", "[", "'FC en phase hospitali\u00e8re'", "]", ".", "divide", "(", "df", "[", "'Pression Art\u00e9rielle Systolique - PAS'", "]", ")", "\n", "\n", "# Persistent features", "\n", "df", "[", "'SBP.ph'", "]", "=", "np", ".", "minimum", "(", "df", "[", "'SBP.min'", "]", ",", "df", "[", "'SBP.MICU'", "]", ")", "\n", "df", "[", "'DBP.ph'", "]", "=", "np", ".", "minimum", "(", "df", "[", "'DBP.min'", "]", ",", "df", "[", "'DBP.MICU'", "]", ")", "\n", "df", "[", "'HR.ph'", "]", "=", "np", ".", "maximum", "(", "df", "[", "'HR.max'", "]", ",", "df", "[", "'HR.MICU'", "]", ")", "\n", "df", "[", "'Cardiac.arrest.ph'", "]", "=", "df", "[", "'Arr\u00eat cardio-respiratoire (massage)'", "]", "\n", "df", "[", "'HemoCue.init'", "]", "=", "df", "[", "'H\u00e9mocue initial'", "]", "\n", "df", "[", "'SpO2.min'", "]", "=", "df", "[", "'SpO2 min'", "]", "\n", "df", "[", "'Vasopressor.therapy'", "]", "=", "df", "[", "'Cat\u00e9cholamines max dans choc h\u00e9morragique'", "]", "\n", "df", "[", "'Cristalloid.volume'", "]", "=", "df", "[", "'Cristallo\u00efdes'", "]", "\n", "df", "[", "'Colloid.volume'", "]", "=", "df", "[", "'Collo\u00efdes'", "]", "\n", "df", "[", "'Shock.index.ph'", "]", "=", "df", "[", "'Fr\u00e9quence cardiaque (FC) \u00e0 l arriv\u00e9e du SMUR'", "]", ".", "divide", "(", "df", "[", "'Pression Art\u00e9rielle Systolique (PAS) \u00e0 l arriv\u00e9e du SMUR'", "]", ")", "\n", "df", "[", "'AIS.external'", "]", "=", "df", "[", "'ISS  / External'", "]", "\n", "df", "[", "'Delta.shock.index'", "]", "=", "df", "[", "'Shock.index.h'", "]", "-", "df", "[", "'Shock.index.ph'", "]", "\n", "df", "[", "'Delta.hemoCue'", "]", "=", "df", "[", "'Delta H\u00e9mocue'", "]", "\n", "\n", "df", "[", "'Anticoagulant.therapy'", "]", "=", "df", "[", "'Traitement anticoagulant'", "]", "\n", "df", "[", "'Antiplatelet.therapy'", "]", "=", "df", "[", "'Traitement antiagr\u00e9gants'", "]", "\n", "df", "[", "'GCS.init'", "]", "=", "df", "[", "'Glasgow initial'", "]", "\n", "df", "[", "'GCS'", "]", "=", "df", "[", "'Score de Glasgow en phase hospitali\u00e8re'", "]", "\n", "df", "[", "'GCS.motor.init'", "]", "=", "df", "[", "'Glasgow moteur initial'", "]", "\n", "df", "[", "'GCS.motor'", "]", "=", "df", "[", "'Glasgow moteur'", "]", "\n", "df", "[", "'Improv.anomaly.osmo'", "]", "=", "df", "[", "'R\u00e9gression mydriase sous osmoth\u00e9rapie'", "]", "\n", "df", "[", "'Medcare.time.ph'", "]", "=", "df", "[", "'D\u00e9lai \u00ab arriv\u00e9e sur les lieux - arriv\u00e9e h\u00f4pital \u00bb'", "]", "\n", "df", "[", "'FiO2'", "]", "=", "df", "[", "'FiO2'", "]", "\n", "df", "[", "'Temperature.min'", "]", "=", "df", "[", "'Temp\u00e9rature min'", "]", "\n", "df", "[", "'TCD.PI.max'", "]", "=", "df", "[", "'DTC IP max (sur les premi\u00e8res 24 heures d HTIC)'", "]", "\n", "df", "[", "'IICP'", "]", "=", "df", "[", "'HTIC (>25 PIC simple s\u00e9dation)'", "]", "\n", "df", "[", "'EVD'", "]", "=", "df", "[", "'D\u00e9rivation ventriculaire externe (DVE)'", "]", "\n", "df", "[", "'Decompressive.craniectomy'", "]", "=", "df", "[", "'Craniectomie d\u00e9-compressive'", "]", "\n", "df", "[", "'Neurosurgery.day0'", "]", "=", "df", "[", "'Bloc dans les premi\u00e8res 24h  / Neurochirurgie (ex. : Craniotomie ou DVE)'", "]", "\n", "df", "[", "'AIS.head'", "]", "=", "df", "[", "'ISS  / Head neck'", "]", "\n", "df", "[", "'AIS.face'", "]", "=", "df", "[", "'ISS  / Face'", "]", "\n", "df", "[", "'ISS'", "]", "=", "df", "[", "'Score ISS'", "]", "\n", "df", "[", "'ISS.II'", "]", "=", "df", "[", "'Total Score IGS'", "]", "\n", "\n", "# Replace potential infinite values by Nans (divide may have created infs)", "\n", "df", ".", "replace", "(", "[", "np", ".", "inf", ",", "-", "np", ".", "inf", "]", ",", "np", ".", "nan", ",", "inplace", "=", "True", ")", "\n", "\n", "return", "df", "\n", "\n", "", "acid_new_features_tranform", "=", "Transform", "(", "\n", "input_features", "=", "[", "\n", "'Pression Art\u00e9rielle Systolique (PAS) minimum'", ",", "\n", "'Pression Art\u00e9rielle Systolique (PAS) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'Pression Art\u00e9rielle Diastolique (PAD) minimum'", ",", "\n", "'Pression Art\u00e9rielle Diastolique (PAD) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'Fr\u00e9quence cardiaque (FC) maximum'", ",", "\n", "'Fr\u00e9quence cardiaque (FC) \u00e0 l arriv\u00e9e du SMUR'", ",", "\n", "'FC en phase hospitali\u00e8re'", ",", "\n", "'Pression Art\u00e9rielle Systolique - PAS'", ",", "\n", "# 'Num\u00e9ro de centre',", "\n", "'Arr\u00eat cardio-respiratoire (massage)'", ",", "\n", "'H\u00e9mocue initial'", ",", "\n", "'SpO2 min'", ",", "\n", "'Cat\u00e9cholamines max dans choc h\u00e9morragique'", ",", "\n", "'Cristallo\u00efdes'", ",", "\n", "'Collo\u00efdes'", ",", "\n", "'ISS  / External'", ",", "\n", "'Delta H\u00e9mocue'", ",", "\n", "'Traitement anticoagulant'", ",", "\n", "'Traitement antiagr\u00e9gants'", ",", "\n", "'Glasgow initial'", ",", "\n", "'Score de Glasgow en phase hospitali\u00e8re'", ",", "\n", "'Glasgow moteur initial'", ",", "\n", "'Glasgow moteur'", ",", "\n", "# 'Anomalie pupillaire (Pr\u00e9-hospitalier)',", "\n", "# 'Anomalie pupillaire (Phase hospitali\u00e8re)',", "\n", "# 'Osmoth\u00e9rapie',", "\n", "'R\u00e9gression mydriase sous osmoth\u00e9rapie'", ",", "\n", "'D\u00e9lai \u00ab arriv\u00e9e sur les lieux - arriv\u00e9e h\u00f4pital \u00bb'", ",", "\n", "'FiO2'", ",", "\n", "'Temp\u00e9rature min'", ",", "\n", "'DTC IP max (sur les premi\u00e8res 24 heures d HTIC)'", ",", "\n", "'HTIC (>25 PIC simple s\u00e9dation)'", ",", "\n", "'D\u00e9rivation ventriculaire externe (DVE)'", ",", "\n", "'Craniectomie d\u00e9-compressive'", ",", "\n", "'Bloc dans les premi\u00e8res 24h  / Neurochirurgie (ex. : Craniotomie ou DVE)'", ",", "\n", "'ISS  / Head neck'", ",", "\n", "'ISS  / Face'", ",", "\n", "'Score ISS'", ",", "\n", "'Total Score IGS'", ",", "\n", "]", ",", "\n", "transform", "=", "define_new_features_acid", ",", "\n", "output_features", "=", "[", "\n", "# 'Trauma.center',", "\n", "'SBP.ph'", ",", "\n", "'DBP.ph'", ",", "\n", "'HR.ph'", ",", "\n", "'Cardiac.arrest.ph'", ",", "\n", "'HemoCue.init'", ",", "\n", "'SpO2.min'", ",", "\n", "'Vasopressor.therapy'", ",", "\n", "'Cristalloid.volume'", ",", "\n", "'Colloid.volume'", ",", "\n", "'Shock.index.ph'", ",", "\n", "'AIS.external'", ",", "\n", "'Delta.shock.index'", ",", "\n", "'Delta.hemoCue'", ",", "\n", "'Anticoagulant.therapy'", ",", "\n", "'Antiplatelet.therapy'", ",", "\n", "'GCS.init'", ",", "\n", "'GCS'", ",", "\n", "'GCS.motor.init'", ",", "\n", "'GCS.motor'", ",", "\n", "# 'Pupil.anomaly.ph',", "\n", "# 'Pupil.anomaly.h',", "\n", "# 'Osmotherapy',", "\n", "'Improv.anomaly.osmo'", ",", "\n", "'Medcare.time.ph'", ",", "\n", "'FiO2'", ",", "\n", "'Temperature.min'", ",", "\n", "'TCD.PI.max'", ",", "\n", "'IICP'", ",", "\n", "'EVD'", ",", "\n", "'Decompressive.craniectomy'", ",", "\n", "'Neurosurgery.day0'", ",", "\n", "'AIS.head'", ",", "\n", "'AIS.face'", ",", "\n", "'ISS'", ",", "\n", "'ISS.II'", ",", "\n", "]", ",", "\n", ")", "\n", "\n", "acid_keep_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "\n", "'Num\u00e9ro de centre'", ",", "\n", "'Anomalie pupillaire (Pr\u00e9-hospitalier)'", ",", "\n", "'Anomalie pupillaire (Phase hospitali\u00e8re)'", ",", "\n", "'Osmoth\u00e9rapie'", ",", "\n", "]", ",", "\n", ")", "\n", "\n", "return", "TaskMeta", "(", "\n", "name", "=", "'acid'", ",", "\n", "db", "=", "'TB'", ",", "\n", "df_name", "=", "'20000'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'ID_PATIENT'", ",", "\n", "idx_selection", "=", "None", ",", "\n", "predict", "=", "acid_predict_transform", ",", "\n", "transform", "=", "acid_new_features_tranform", ",", "\n", "select", "=", "acid_keep_transform", ",", "\n", "encode_transform", "=", "'ordinal'", ",", "\n", "encode_select", "=", "'all'", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.TB.septic_task": [[543, 603], ["transform.Transform", "task.TaskMeta", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "df.drop"], "function", ["None"], ["", "def", "septic_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for septic prediction.\"\"\"", "\n", "septic_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'Choc septique'", "]", ",", "\n", "output_features", "=", "[", "'Choc septique'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "septic_pvals_keep_transform", "=", "None", "\n", "septic_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "septic_pvals_dir", "=", "'pvals/TB/septic_pvals/'", "\n", "septic_idx_path", "=", "f'{septic_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "septic_pvals_path", "=", "f'{septic_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "septic_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "septic_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "septic_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "septic_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "septic_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "septic_top_pvals", "\n", ")", "\n", "\n", "septic_drop_idx", "=", "pd", ".", "read_csv", "(", "septic_idx_path", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "septic_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "septic_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'septic_pvals'", ",", "\n", "db", "=", "'TB'", ",", "\n", "df_name", "=", "'20000'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'ID_PATIENT'", ",", "\n", "idx_selection", "=", "septic_idx_transform", ",", "\n", "predict", "=", "septic_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "septic_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.transform.Transform.get_infos": [[16, 21], ["None"], "methods", ["None"], ["def", "get_infos", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a dict containing infos on the object.\"\"\"", "\n", "return", "{", "\n", "'input_features'", ":", "self", ".", "input_features", ",", "\n", "'output_features'", ":", "self", ".", "output_features", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.transform.Transform.get_parent": [[23, 30], ["isinstance", "transform.Transform.get_parent.parent"], "methods", ["None"], ["", "def", "get_parent", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"From a set of features, derive the parent features.\"\"\"", "\n", "def", "parent", "(", "f", ")", ":", "\n", "            ", "if", "isinstance", "(", "f", ",", "str", ")", ":", "\n", "                ", "return", "f", ".", "split", "(", "self", ".", "child_sep", ")", "[", "0", "]", "\n", "", "return", "f", "\n", "", "return", "{", "parent", "(", "f", ")", "for", "f", "in", "features", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.__init__": [[13, 20], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get": [[22, 33], ["tag.split", "task.Task"], "methods", ["None"], []], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.__getitem__": [[34, 37], ["__init__._TaskAccessor.get"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], []], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys": [[38, 43], ["__init__._TaskAccessor.task_metas.items", "metas.keys"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], []], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.TaskMeta.__post_init__": [[33, 44], ["isinstance", "task.TaskMeta.drop.intersection", "set", "ValueError", "isinstance"], "methods", ["None"], ["def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "drop", ",", "list", ")", ":", "\n", "            ", "self", ".", "drop", "=", "set", "(", "self", ".", "drop", ")", "\n", "\n", "", "if", "self", ".", "idx_column", "is", "None", ":", "\n", "            ", "self", ".", "idx_column", "=", "[", "]", "\n", "", "elif", "not", "isinstance", "(", "self", ".", "idx_column", ",", "list", ")", ":", "\n", "            ", "self", ".", "idx_column", "=", "[", "self", ".", "idx_column", "]", "\n", "\n", "", "if", "self", ".", "drop", ".", "intersection", "(", "self", ".", "predict", ".", "output_features", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Some predict output features are in drop.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.TaskMeta.get_infos": [[45, 69], ["task.TaskMeta.idx_selection.get_infos", "task.TaskMeta.predict.get_infos", "task.TaskMeta.transform.get_infos", "task.TaskMeta.select.get_infos"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos"], ["", "", "def", "get_infos", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a dict containing infos on the object.\"\"\"", "\n", "data", "=", "{", "\n", "'name'", ":", "self", ".", "name", ",", "\n", "'db'", ":", "self", ".", "db", ",", "\n", "'df_name'", ":", "self", ".", "df_name", ",", "\n", "'classif'", ":", "self", ".", "classif", ",", "\n", "'encode_select'", ":", "self", ".", "encode_select", ",", "\n", "'encode_transform'", ":", "self", ".", "encode_transform", ",", "\n", "}", "\n", "\n", "if", "self", ".", "idx_selection", "is", "not", "None", ":", "\n", "            ", "data", "[", "'idx_selection'", "]", "=", "self", ".", "idx_selection", ".", "get_infos", "(", ")", "\n", "\n", "", "if", "self", ".", "predict", "is", "not", "None", ":", "\n", "            ", "data", "[", "'predict'", "]", ":", "self", ".", "predict", ".", "get_infos", "(", ")", "\n", "\n", "", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "data", "[", "'transform'", "]", ":", "self", ".", "transform", ".", "get_infos", "(", ")", "\n", "\n", "", "if", "self", ".", "select", "is", "not", "None", ":", "\n", "            ", "data", "[", "'select'", "]", ":", "self", ".", "select", ".", "get_infos", "(", ")", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.TaskMeta.tag": [[70, 74], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "tag", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return db_name/task_name.\"\"\"", "\n", "return", "f'{self.db}/{self.name}'", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.__init__": [[79, 100], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "meta", ")", ":", "\n", "        ", "\"\"\"Init.\"\"\"", "\n", "self", ".", "meta", "=", "meta", "\n", "\n", "# Store the features availables in each dataframe", "\n", "self", ".", "_f_init", "=", "None", "\n", "self", ".", "_f_y", "=", "None", "\n", "self", ".", "_f_transform", "=", "None", "\n", "\n", "# Store the dataframes", "\n", "self", ".", "_X_select_base", "=", "None", "\n", "self", ".", "_X_select_unenc", "=", "None", "\n", "self", ".", "_X_select", "=", "None", "\n", "self", ".", "_X_extra_base", "=", "None", "\n", "self", ".", "_X_extra_unenc", "=", "None", "\n", "self", ".", "_X_extra", "=", "None", "\n", "self", ".", "_y", "=", "None", "\n", "\n", "self", ".", "_file_index", "=", "None", "\n", "\n", "self", ".", "_rows_to_drop", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.X": [[101, 114], ["pandas.concat", "task.Task._load_X_y"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_X_y"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "\"\"\"Input dataset.\"\"\"", "\n", "if", "self", ".", "_X_select", "is", "None", "and", "self", ".", "_X_extra", "is", "None", ":", "\n", "            ", "self", ".", "_load_X_y", "(", ")", "\n", "\n", "", "if", "self", ".", "_X_select", "is", "None", ":", "\n", "            ", "return", "self", ".", "_X_extra", "\n", "\n", "", "if", "self", ".", "_X_extra", "is", "None", ":", "\n", "            ", "return", "self", ".", "_X_select", "\n", "\n", "", "return", "pd", ".", "concat", "(", "(", "self", ".", "_X_select", ",", "self", ".", "_X_extra", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.y": [[115, 122], ["task.Task._load_y"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_y"], ["", "@", "property", "\n", "def", "y", "(", "self", ")", ":", "\n", "        ", "\"\"\"Feature to predict.\"\"\"", "\n", "if", "self", ".", "_y", "is", "None", ":", "\n", "            ", "self", ".", "_load_y", "(", ")", "\n", "\n", "", "return", "self", ".", "_y", "[", "self", ".", "_f_y", "[", "0", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.mv": [[123, 128], ["df_utils.get_missing_values"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values"], ["", "@", "property", "\n", "def", "mv", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the missing values table.\"\"\"", "\n", "db", "=", "dbs", "[", "self", ".", "meta", ".", "db", "]", "\n", "return", "get_missing_values", "(", "self", ".", "X", ",", "db", ".", "heuristic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif": [[129, 132], ["None"], "methods", ["None"], ["", "def", "is_classif", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tell if the task is a classification or a regression.\"\"\"", "\n", "return", "self", ".", "meta", ".", "classif", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.get_infos": [[133, 141], ["task.Task.meta.get_infos", "repr", "repr", "repr", "repr", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos"], ["", "def", "get_infos", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get infos on the task.\"\"\"", "\n", "infos", "=", "self", ".", "meta", ".", "get_infos", "(", ")", "\n", "infos", "[", "'_X_select.shape'", "]", "=", "repr", "(", "getattr", "(", "self", ".", "_X_select", ",", "'shape'", ",", "None", ")", ")", "\n", "infos", "[", "'_X_extra.shape'", "]", "=", "repr", "(", "getattr", "(", "self", ".", "_X_extra", ",", "'shape'", ",", "None", ")", ")", "\n", "infos", "[", "'X.shape'", "]", "=", "repr", "(", "getattr", "(", "self", ".", "X", ",", "'shape'", ",", "None", ")", ")", "\n", "infos", "[", "'_y.shape'", "]", "=", "repr", "(", "getattr", "(", "self", ".", "_y", ",", "'shape'", ",", "None", ")", ")", "\n", "return", "infos", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._idx_to_rows": [[142, 155], ["task.Task._load_index", "rows.append", "index.get_loc"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_index"], ["", "def", "_idx_to_rows", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "meta", ".", "idx_column", "is", "None", ":", "\n", "            ", "return", "idx", "+", "1", "# Rows start to 1 wih header", "\n", "\n", "", "if", "self", ".", "_file_index", "is", "None", ":", "\n", "            ", "self", ".", "_load_index", "(", ")", "\n", "\n", "", "rows", "=", "[", "]", "\n", "index", "=", "self", ".", "_file_index", "\n", "for", "i", "in", "idx", ":", "\n", "            ", "rows", ".", "append", "(", "index", ".", "get_loc", "(", "i", ")", "+", "1", ")", "\n", "\n", "", "return", "rows", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._features_to_load": [[156, 175], ["set", "set", "set", "set().intersection", "set().intersection", "set().intersection", "set", "set().intersection.union().union", "ValueError", "set", "set", "set", "set().intersection.union"], "methods", ["None"], ["", "def", "_features_to_load", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"From a set of features to load, find where they are.\"\"\"", "\n", "f_init", ",", "f_y", ",", "f_transform", "=", "set", "(", ")", ",", "set", "(", ")", ",", "set", "(", ")", "\n", "\n", "if", "self", ".", "_f_init", ":", "\n", "            ", "f_init", "=", "set", "(", "self", ".", "_f_init", ")", ".", "intersection", "(", "features", ")", "\n", "\n", "", "if", "self", ".", "_f_y", ":", "\n", "            ", "f_y", "=", "set", "(", "self", ".", "_f_y", ")", ".", "intersection", "(", "features", ")", "\n", "\n", "", "if", "self", ".", "_f_transform", ":", "\n", "            ", "f_transform", "=", "set", "(", "self", ".", "_f_transform", ")", ".", "intersection", "(", "features", ")", "\n", "\n", "", "diff", "=", "set", "(", "features", ")", "-", "f_init", ".", "union", "(", "f_y", ")", ".", "union", "(", "f_transform", ")", "\n", "if", "diff", ":", "\n", "            ", "raise", "ValueError", "(", "f'Some asked features where not found in any df. '", "\n", "f'Diff: {diff}'", ")", "\n", "\n", "", "return", "f_init", ",", "f_y", ",", "f_transform", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_and_merge": [[176, 202], ["pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.concat", "set", "df_init.drop.drop.drop", "set", "ValueError", "ValueError"], "methods", ["None"], ["", "def", "_load_and_merge", "(", "self", ",", "f_init", ",", "f_y", ",", "f_transform", ")", ":", "\n", "        ", "\"\"\"Load asked features from each dataframe and merge them.\"\"\"", "\n", "df_init", "=", "pd", ".", "DataFrame", "(", ")", "\n", "df_y", "=", "pd", ".", "DataFrame", "(", ")", "\n", "df_transform", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "if", "f_init", ":", "\n", "            ", "df_init", "=", "self", ".", "_X_extra_base", "\n", "features", "=", "set", "(", "df_init", ".", "columns", ")", "\n", "features_to_drop", "=", "features", "-", "set", "(", "f_init", ")", "\n", "df_init", "=", "df_init", ".", "drop", "(", "features_to_drop", ",", "axis", "=", "1", ")", "\n", "\n", "", "if", "f_y", ":", "\n", "            ", "if", "self", ".", "_y", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "'Asked to load feature from y but y is None.'", ")", "\n", "\n", "", "df_y", "=", "self", ".", "_y", "[", "f_y", "]", "\n", "\n", "", "if", "f_transform", ":", "\n", "            ", "if", "self", ".", "_X_extra", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "'Asked to load feature from transformed df '", "\n", "'which id None.'", ")", "\n", "\n", "", "df_transform", "=", "self", ".", "_X_extra", "[", "f_transform", "]", "\n", "\n", "", "return", "pd", ".", "concat", "(", "(", "df_init", ",", "df_y", ",", "df_transform", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_index": [[203, 215], ["pandas.read_csv"], "methods", ["None"], ["", "def", "_load_index", "(", "self", ")", ":", "\n", "        ", "db", "=", "dbs", "[", "self", ".", "meta", ".", "db", "]", "\n", "df_name", "=", "self", ".", "meta", ".", "df_name", "\n", "df_path", "=", "db", ".", "frame_paths", "[", "df_name", "]", "\n", "sep", "=", "db", ".", "_sep", "\n", "encoding", "=", "db", ".", "_encoding", "\n", "index_col", "=", "self", ".", "meta", ".", "idx_column", "\n", "\n", "if", "index_col", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "df_path", ",", "sep", "=", "sep", ",", "encoding", "=", "encoding", ",", "\n", "usecols", "=", "index_col", ",", "index_col", "=", "index_col", ")", "\n", "self", ".", "_file_index", "=", "df", ".", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_y": [[216, 289], ["logging.debug", "pandas.read_csv", "task.Task._f_init.update", "task.Task._load_index", "pandas.Index", "logging.debug", "set", "features_to_load.intersection.intersection.intersection", "pandas.read_csv", "logging.debug", "task.Task.meta.predict.transform", "task.Task._f_init.discard", "df_utils.get_missing_values", "idx.difference.union", "task.Task._idx_to_rows", "task.Task._y.drop", "task.Task._y.sort_index", "logging.debug", "set", "features_to_load.intersection.intersection.intersection", "pandas.read_csv", "logging.debug", "idx_transformer.transform", "idx.difference", "task.Task._idx_to_rows", "len", "ValueError", "task.Task.is_classif", "df_utils.get_missing_values", "encode.ordinal_encode", "set", "task.Task._y.astype"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_index", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.transform", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._idx_to_rows", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.transform", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._idx_to_rows", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode.ordinal_encode"], ["", "", "def", "_load_y", "(", "self", ")", ":", "\n", "        ", "\"\"\"Load a dataframe from taskmeta (only y).\"\"\"", "\n", "# Step 0: get dataframe's path and load infos", "\n", "logging", ".", "debug", "(", "'Get df path and load infos'", ")", "\n", "db", "=", "dbs", "[", "self", ".", "meta", ".", "db", "]", "\n", "df_name", "=", "self", ".", "meta", ".", "df_name", "\n", "df_path", "=", "db", ".", "frame_paths", "[", "df_name", "]", "\n", "sep", "=", "db", ".", "_sep", "\n", "encoding", "=", "db", ".", "_encoding", "\n", "index_col", "=", "self", ".", "meta", ".", "idx_column", "\n", "\n", "# Step 1: Load available features from initial df", "\n", "df", "=", "pd", ".", "read_csv", "(", "df_path", ",", "sep", "=", "sep", ",", "encoding", "=", "encoding", ",", "nrows", "=", "0", ",", "\n", "index_col", "=", "index_col", ")", "\n", "self", ".", "_f_init", "=", "{", "s", "for", "s", "in", "set", "(", "df", ".", "columns", ")", "if", "s", "not", "in", "self", ".", "meta", ".", "drop", "}", "\n", "self", ".", "_f_init", ".", "update", "(", "index_col", ")", "\n", "\n", "# Step 1.2: load index", "\n", "self", ".", "_load_index", "(", ")", "\n", "\n", "# Step 2: Derive indexes to drop if any", "\n", "idx_transformer", "=", "self", ".", "meta", ".", "idx_selection", "\n", "idx_to_drop", "=", "pd", ".", "Index", "(", "[", "]", ")", "# At start, no indexes to drop", "\n", "if", "idx_transformer", ":", "\n", "            ", "logging", ".", "debug", "(", "'Derive indexes to drop.'", ")", "\n", "features_to_load", "=", "set", "(", "idx_transformer", ".", "input_features", "+", "index_col", ")", "\n", "features_to_load", "=", "features_to_load", ".", "intersection", "(", "self", ".", "_f_init", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "df_path", ",", "sep", "=", "sep", ",", "encoding", "=", "encoding", ",", "\n", "usecols", "=", "features_to_load", ",", "index_col", "=", "index_col", ")", "\n", "idx", "=", "df", ".", "index", "\n", "logging", ".", "debug", "(", "f'Loaded df of shape {df.shape}.'", ")", "\n", "df", "=", "idx_transformer", ".", "transform", "(", "df", ")", "\n", "idx_to_keep", "=", "df", ".", "index", "\n", "idx_to_drop", "=", "idx", ".", "difference", "(", "idx_to_keep", ")", "\n", "self", ".", "_rows_to_drop", "=", "self", ".", "_idx_to_rows", "(", "idx_to_drop", ")", "\n", "\n", "# Step 3: Derive the feature to predict y", "\n", "", "logging", ".", "debug", "(", "'Derive the feature to predict y.'", ")", "\n", "features_to_load", "=", "set", "(", "self", ".", "meta", ".", "predict", ".", "input_features", "+", "index_col", ")", "\n", "features_to_load", "=", "features_to_load", ".", "intersection", "(", "self", ".", "_f_init", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "df_path", ",", "sep", "=", "sep", ",", "encoding", "=", "encoding", ",", "\n", "usecols", "=", "features_to_load", ",", "skiprows", "=", "self", ".", "_rows_to_drop", ",", "\n", "index_col", "=", "index_col", ")", "\n", "logging", ".", "debug", "(", "f'Loaded df of shape {df.shape}.'", ")", "\n", "\n", "if", "len", "(", "self", ".", "meta", ".", "predict", ".", "output_features", ")", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected only one item in output features '", "\n", "'for deriving predict.'", ")", "\n", "\n", "", "df", "=", "self", ".", "meta", ".", "predict", ".", "transform", "(", "df", ")", "\n", "y_name", "=", "self", ".", "meta", ".", "predict", ".", "output_features", "[", "0", "]", "\n", "self", ".", "_y", "=", "df", "[", "[", "y_name", "]", "]", "\n", "self", ".", "_f_y", "=", "[", "y_name", "]", "# Store the name of the feature to predict", "\n", "\n", "# Drop the feature to predict from _f_init", "\n", "self", ".", "_f_init", ".", "discard", "(", "y_name", ")", "\n", "\n", "# Step 4: Add NAN values of y to index to drop and drop them from y", "\n", "y_mv", "=", "get_missing_values", "(", "self", ".", "_y", "[", "y_name", "]", ",", "db", ".", "heuristic", ")", "\n", "idx_to_drop_y", "=", "self", ".", "_y", "[", "y_name", "]", ".", "index", "[", "y_mv", "!=", "0", "]", "\n", "\n", "idx_to_drop", "=", "idx_to_drop", ".", "union", "(", "idx_to_drop_y", ")", "# merge the indexes", "\n", "self", ".", "_rows_to_drop", "=", "self", ".", "_idx_to_rows", "(", "idx_to_drop", ")", "\n", "self", ".", "_y", "=", "self", ".", "_y", ".", "drop", "(", "idx_to_drop_y", ",", "axis", "=", "0", ")", "\n", "\n", "# Step 5: Encode y if needed", "\n", "if", "self", ".", "is_classif", "(", ")", "and", "self", ".", "meta", ".", "encode_y", ":", "\n", "            ", "y_mv", "=", "get_missing_values", "(", "self", ".", "_y", ",", "db", ".", "heuristic", ")", "\n", "self", ".", "_y", ",", "_", "=", "ordinal_encode", "(", "self", ".", "_y", ",", "y_mv", ")", "\n", "", "elif", "self", ".", "meta", ".", "encode_y", ":", "# cast to float for regression", "\n", "            ", "self", ".", "_y", "=", "self", ".", "_y", ".", "astype", "(", "float", ")", "\n", "\n", "", "self", ".", "_y", ".", "sort_index", "(", "inplace", "=", "True", ")", "# to have consistent order with X", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_X_base": [[290, 377], ["logging.debug", "set", "pandas.read_csv", "df_utils.get_missing_values", "df_utils.fill_df", "df_utils.fill_df.sort_index", "task.Task.check_index_consistency", "task.Task._load_y", "set().intersection", "features_to_load.intersection.intersection.update", "features_to_load.intersection.intersection.intersection", "set().intersection", "features_to_load.intersection.intersection.update", "features_to_load.intersection.intersection.intersection", "df_utils.get_missing_values", "database._load_feature_types", "db._load_ordinal_orders", "db.ordinal_orders.get", "db._encode_df", "task.Task._X_extra_base.sort_index", "df_utils.get_missing_values", "database._load_feature_types", "db._load_ordinal_orders", "db.ordinal_orders.get", "db._encode_df", "task.Task._X_select_base.sort_index", "ValueError", "select.get_parent", "set", "set"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.check_index_consistency", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_y", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_feature_types", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_ordinal_orders", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._encode_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_feature_types", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_ordinal_orders", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._encode_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.transform.Transform.get_parent"], ["", "def", "_load_X_base", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_y", "is", "None", ":", "\n", "            ", "self", ".", "_load_y", "(", ")", "\n", "\n", "# Step 0: get dataframe's path and load infos", "\n", "", "logging", ".", "debug", "(", "'Get df path and load infos'", ")", "\n", "db", "=", "dbs", "[", "self", ".", "meta", ".", "db", "]", "\n", "df_name", "=", "self", ".", "meta", ".", "df_name", "\n", "df_path", "=", "db", ".", "frame_paths", "[", "df_name", "]", "\n", "sep", "=", "db", ".", "_sep", "\n", "encoding", "=", "db", ".", "_encoding", "\n", "index_col", "=", "self", ".", "meta", ".", "idx_column", "\n", "\n", "# Step 5.1: Load asked features", "\n", "features_to_load", "=", "set", "(", "index_col", ")", "\n", "select", "=", "self", ".", "meta", ".", "select", "\n", "if", "select", ":", "\n", "            ", "if", "select", ".", "output_features", "and", "select", ".", "input_features", ":", "\n", "                ", "raise", "ValueError", "(", "'Cannot specify both input and output '", "\n", "'features for select transform.'", ")", "\n", "\n", "", "if", "select", ".", "output_features", ":", "\n", "                ", "select_f", "=", "select", ".", "get_parent", "(", "select", ".", "output_features", ")", "\n", "", "else", ":", "\n", "                ", "select_f", "=", "select", ".", "input_features", "\n", "", "select_f", "=", "set", "(", "select_f", ")", ".", "intersection", "(", "self", ".", "_f_init", ")", "\n", "features_to_load", ".", "update", "(", "select_f", ")", "\n", "features_to_load", "=", "features_to_load", ".", "intersection", "(", "self", ".", "_f_init", ")", "\n", "\n", "", "transform", "=", "self", ".", "meta", ".", "transform", "\n", "if", "transform", ":", "\n", "            ", "transform_f", "=", "set", "(", "transform", ".", "input_features", ")", ".", "intersection", "(", "self", ".", "_f_init", ")", "\n", "features_to_load", ".", "update", "(", "transform_f", ")", "\n", "features_to_load", "=", "features_to_load", ".", "intersection", "(", "self", ".", "_f_init", ")", "\n", "\n", "# If nothing specified, we load everything", "\n", "", "if", "not", "select", "and", "not", "transform", ":", "\n", "            ", "features_to_load", "=", "None", "\n", "\n", "", "df", "=", "pd", ".", "read_csv", "(", "df_path", ",", "sep", "=", "sep", ",", "usecols", "=", "features_to_load", ",", "\n", "encoding", "=", "encoding", ",", "skiprows", "=", "self", ".", "_rows_to_drop", ",", "\n", "index_col", "=", "index_col", ",", "low_memory", "=", "False", ")", "\n", "# We add low_memory=False because if True, types are inferred by chunk", "\n", "# and some mixed types may happen (eg 1 and 1.0) which lead to an", "\n", "# error when ordinal encoding (2 categories instead of one).", "\n", "mv", "=", "get_missing_values", "(", "df", ",", "db", ".", "heuristic", ")", "\n", "df", "=", "fill_df", "(", "df", ",", "mv", "!=", "0", ",", "np", ".", "nan", ")", "\n", "\n", "df", ".", "sort_index", "(", "inplace", "=", "True", ")", "# to have consistent order with y", "\n", "\n", "# Step 5.2: save the results", "\n", "if", "select", ":", "\n", "            ", "self", ".", "_X_select_base", "=", "df", "[", "select_f", "]", "\n", "self", ".", "_X_select_unenc", "=", "df", "[", "select_f", "]", "\n", "\n", "", "if", "transform", ":", "\n", "            ", "self", ".", "_X_extra_base", "=", "df", "[", "transform_f", "]", "\n", "self", ".", "_X_extra_unenc", "=", "df", "[", "transform_f", "]", "\n", "\n", "", "if", "not", "select", "and", "not", "transform", ":", "\n", "            ", "self", ".", "_X_select_base", "=", "df", "\n", "self", ".", "_X_select_unenc", "=", "df", "\n", "\n", "# Step 5.3: Encode both dataframes", "\n", "", "if", "self", ".", "meta", ".", "encode_transform", "and", "self", ".", "_X_extra_base", "is", "not", "None", ":", "\n", "            ", "df", "=", "self", ".", "_X_extra_base", "\n", "mv", "=", "get_missing_values", "(", "df", ",", "db", ".", "heuristic", ")", "\n", "types", "=", "_load_feature_types", "(", "db", ",", "df_name", ",", "anonymized", "=", "False", ")", "\n", "db", ".", "_load_ordinal_orders", "(", "self", ".", "meta", ")", "\n", "order", "=", "db", ".", "ordinal_orders", ".", "get", "(", "self", ".", "meta", ".", "tag", ",", "None", ")", "\n", "df", ",", "_", ",", "_", ",", "_", "=", "db", ".", "_encode_df", "(", "df", ",", "mv", ",", "types", ",", "order", "=", "order", ",", "\n", "encode", "=", "self", ".", "meta", ".", "encode_transform", ")", "\n", "self", ".", "_X_extra_base", "=", "df", "\n", "self", ".", "_X_extra_base", ".", "sort_index", "(", "inplace", "=", "True", ")", "\n", "\n", "", "if", "self", ".", "meta", ".", "encode_select", "and", "self", ".", "_X_select_base", "is", "not", "None", ":", "\n", "            ", "df", "=", "self", ".", "_X_select_base", "\n", "mv", "=", "get_missing_values", "(", "df", ",", "db", ".", "heuristic", ")", "\n", "types", "=", "_load_feature_types", "(", "db", ",", "df_name", ",", "anonymized", "=", "False", ")", "\n", "db", ".", "_load_ordinal_orders", "(", "self", ".", "meta", ")", "\n", "order", "=", "db", ".", "ordinal_orders", ".", "get", "(", "self", ".", "meta", ".", "tag", ",", "None", ")", "\n", "df", ",", "_", ",", "_", ",", "_", "=", "db", ".", "_encode_df", "(", "df", ",", "mv", ",", "types", ",", "order", "=", "order", ",", "\n", "encode", "=", "self", ".", "meta", ".", "encode_select", ")", "\n", "self", ".", "_X_select_base", "=", "df", "\n", "self", ".", "_X_select_base", ".", "sort_index", "(", "inplace", "=", "True", ")", "\n", "\n", "", "self", ".", "check_index_consistency", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_X_y": [[378, 412], ["task.Task.check_index_consistency", "task.Task._load_X_base", "task.Task._features_to_load", "task.Task._load_and_merge", "logging.debug", "transform.transform", "set", "set", "df.drop.drop.drop", "df.drop.drop.sort_index", "set", "df.drop.drop.drop", "df.drop.drop.sort_index", "set"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.check_index_consistency", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_X_base", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._features_to_load", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task._load_and_merge", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.TimerStep.TimerStep.transform"], ["", "def", "_load_X_y", "(", "self", ")", ":", "\n", "        ", "\"\"\"Load a dataframe from taskmeta (X and y).\"\"\"", "\n", "if", "self", ".", "_X_extra_base", "is", "None", "and", "self", ".", "_X_select_base", "is", "None", ":", "\n", "            ", "self", ".", "_load_X_base", "(", ")", "\n", "\n", "# Step 6: Derive new set of features if any", "\n", "", "transform", "=", "self", ".", "meta", ".", "transform", "\n", "if", "transform", ":", "\n", "            ", "asked_features", "=", "transform", ".", "input_features", "\n", "f_init", ",", "f_y", ",", "f_transform", "=", "self", ".", "_features_to_load", "(", "asked_features", ")", "\n", "df", "=", "self", ".", "_load_and_merge", "(", "f_init", ",", "f_y", ",", "f_transform", ")", "\n", "logging", ".", "debug", "(", "f'Loaded df of shape {df.shape}.'", ")", "\n", "df", "=", "transform", ".", "transform", "(", "df", ")", "\n", "features", "=", "set", "(", "df", ".", "columns", ")", "\n", "features_to_keep", "=", "set", "(", "transform", ".", "output_features", ")", "\n", "features_to_drop", "=", "features", "-", "features_to_keep", "\n", "df", ".", "drop", "(", "features_to_drop", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "df", ".", "sort_index", "(", "inplace", "=", "True", ")", "\n", "self", ".", "_X_extra", "=", "df", "\n", "\n", "# Step 7: Drop unwanted features if output specified", "\n", "", "select", "=", "self", ".", "meta", ".", "select", "\n", "if", "select", "and", "select", ".", "output_features", ":", "\n", "            ", "df", "=", "self", ".", "_X_select_base", "\n", "features_to_keep", "=", "select", ".", "output_features", "\n", "features", "=", "set", "(", "df", ".", "columns", ")", "\n", "features_to_drop", "=", "features", "-", "set", "(", "features_to_keep", ")", "\n", "df", "=", "df", ".", "drop", "(", "features_to_drop", ",", "axis", "=", "1", ")", "\n", "df", ".", "sort_index", "(", "inplace", "=", "True", ")", "\n", "self", ".", "_X_select", "=", "df", "\n", "", "else", ":", "\n", "            ", "self", ".", "_X_select", "=", "self", ".", "_X_select_base", "\n", "\n", "", "self", ".", "check_index_consistency", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.check_index_consistency": [[413, 424], ["range", "idx1.equals", "len"], "methods", ["None"], ["", "def", "check_index_consistency", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check whether all indexes are equal.\"\"\"", "\n", "dfs", "=", "[", "self", ".", "_y", ",", "self", ".", "_X_extra", ",", "self", ".", "_X_extra_base", ",", "self", ".", "_X_extra_unenc", ",", "\n", "self", ".", "_X_select", ",", "self", ".", "_X_select_base", ",", "self", ".", "_X_select_unenc", "]", "\n", "\n", "indexes", "=", "[", "df", ".", "index", "for", "df", "in", "dfs", "if", "df", "is", "not", "None", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "indexes", ")", "-", "1", ")", ":", "\n", "            ", "idx1", "=", "indexes", "[", "i", "]", "\n", "idx2", "=", "indexes", "[", "i", "+", "1", "]", "\n", "assert", "idx1", ".", "equals", "(", "idx2", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.NHIS.income_task": [[11, 79], ["transform.Transform", "task.TaskMeta", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "df.drop", "pd.read_csv.index.str.match"], "function", ["None"], ["def", "income_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for income prediction.\"\"\"", "\n", "income_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'ERNYR-P'", "]", ",", "\n", "output_features", "=", "[", "'ERNYR-P'", "]", ",", "\n", ")", "\n", "\n", "# Drop features linked to feature to predict", "\n", "income_drop_features", "=", "{", "\n", "'INCGRP4'", ",", "\n", "'INCGRP5'", ",", "\n", "}", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "income_pvals_keep_transform", "=", "None", "\n", "income_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "income_pvals_dir", "=", "'pvals/NHIS/income_pvals/'", "\n", "income_idx_path", "=", "f'{income_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "income_pvals_path", "=", "f'{income_pvals_dir}RS{RS}-T{T}-pvals.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "income_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "income_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "income_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "# Match exact feature or start with and followed by '_' (categorical)", "\n", "for", "f", "in", "income_drop_features", ":", "# Drop asked features from pvals", "\n", "            ", "regex", "=", "f'(^{f}$|^{f}_)'", "\n", "pvals", "=", "pvals", "[", "~", "pvals", ".", "index", ".", "str", ".", "match", "(", "regex", ")", "]", "\n", "", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "income_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "income_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "income_top_pvals", "\n", ")", "\n", "\n", "income_drop_idx", "=", "pd", ".", "read_csv", "(", "income_idx_path", ",", "index_col", "=", "0", ",", "\n", "squeeze", "=", "True", ")", "\n", "\n", "income_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "income_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'income_pvals'", ",", "\n", "db", "=", "'NHIS'", ",", "\n", "df_name", "=", "'X_income'", ",", "\n", "classif", "=", "False", ",", "\n", "idx_column", "=", "'IDX'", ",", "\n", "idx_selection", "=", "income_idx_transform", ",", "\n", "predict", "=", "income_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "income_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.NHIS.bmi_task": [[84, 152], ["transform.Transform", "task.TaskMeta", "os.path.exists", "os.path.exists", "pandas.read_csv", "list", "transform.Transform", "pandas.read_csv", "transform.Transform", "pd.read_csv.sort_values", "pd.read_csv.index.astype", "df.drop", "pd.read_csv.index.str.match"], "function", ["None"], ["", "def", "bmi_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for bmi prediction.\"\"\"", "\n", "bmi_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'BMI'", "]", ",", "\n", "output_features", "=", "[", "'BMI'", "]", ",", "\n", ")", "\n", "\n", "# Drop features linked to feature to predict", "\n", "bmi_drop_features", "=", "{", "\n", "'BMI'", ",", "\n", "'AHEIGHT'", ",", "\n", "'AWEIGHTP'", ",", "\n", "}", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "bmi_pvals_keep_transform", "=", "None", "\n", "bmi_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n", "\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "bmi_pvals_dir", "=", "'pvals/NHIS/bmi_pvals/'", "\n", "bmi_idx_path", "=", "f'{bmi_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "bmi_pvals_path", "=", "f'{bmi_pvals_dir}RS{RS}-T{T}-pvals.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "bmi_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "bmi_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "bmi_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "# Match exact feature or start with and followed by '_' (categorical)", "\n", "for", "f", "in", "bmi_drop_features", ":", "# Drop asked features from pvals", "\n", "            ", "regex", "=", "f'(^{f}$|^{f}_)'", "\n", "pvals", "=", "pvals", "[", "~", "pvals", ".", "index", ".", "str", ".", "match", "(", "regex", ")", "]", "\n", "", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "bmi_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "bmi_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "bmi_top_pvals", "\n", ")", "\n", "\n", "bmi_drop_idx", "=", "pd", ".", "read_csv", "(", "bmi_idx_path", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "bmi_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "bmi_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'bmi_pvals'", ",", "\n", "db", "=", "'NHIS'", ",", "\n", "df_name", "=", "'X_income'", ",", "\n", "classif", "=", "False", ",", "\n", "idx_column", "=", "'IDX'", ",", "\n", "idx_selection", "=", "bmi_idx_transform", ",", "\n", "predict", "=", "bmi_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "bmi_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.__init__": [[14, 47], ["dict", "dict", "dict", "sklearn.pipeline.Pipeline", "search", "all", "dict", "strategy.Strategy.param_space.items", "sklearn.pipeline.Pipeline.get_params().keys", "strategy.Strategy.param_space.keys", "sklearn.pipeline.Pipeline.get_params"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], ["def", "__init__", "(", "self", ",", "estimator", ",", "inner_cv", ",", "outer_cv", ",", "param_space", ",", "search", ",", "\n", "imputer", "=", "None", ",", "search_params", "=", "dict", "(", ")", ",", "compute_importance", "=", "False", ",", "\n", "importance_params", "=", "dict", "(", ")", ",", "learning_curve", "=", "False", ",", "\n", "learning_curve_params", "=", "dict", "(", ")", ",", "roc", "=", "False", ",", "name", "=", "None", ",", "\n", "train_set_steps", "=", "None", ",", "min_test_set", "=", "None", ",", "n_splits", "=", "None", ")", ":", "\n", "        ", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "inner_cv", "=", "inner_cv", "\n", "self", ".", "outer_cv", "=", "outer_cv", "\n", "self", ".", "param_space", "=", "param_space", "\n", "self", ".", "_name", "=", "name", "\n", "self", ".", "imputer", "=", "imputer", "\n", "self", ".", "compute_importance", "=", "compute_importance", "\n", "self", ".", "importance_params", "=", "importance_params", "\n", "self", ".", "learning_curve", "=", "learning_curve", "\n", "self", ".", "learning_curve_params", "=", "learning_curve_params", "\n", "self", ".", "roc", "=", "roc", "\n", "self", ".", "train_set_steps", "=", "train_set_steps", "\n", "self", ".", "min_test_set", "=", "min_test_set", "\n", "self", ".", "n_splits", "=", "n_splits", "\n", "\n", "if", "search", "is", "None", ":", "\n", "            ", "self", ".", "search", "=", "self", ".", "estimator", "\n", "\n", "", "else", ":", "\n", "            ", "if", "not", "all", "(", "p", "in", "estimator", ".", "get_params", "(", ")", ".", "keys", "(", ")", "for", "p", "in", "self", ".", "param_space", ".", "keys", "(", ")", ")", ":", "\n", "                ", "self", ".", "param_space", "=", "dict", "(", ")", "\n", "\n", "", "search_params", "[", "'cv'", "]", "=", "self", ".", "inner_cv", "\n", "estimator", "=", "Pipeline", "(", "[", "\n", "(", "'model'", ",", "estimator", ")", "\n", "]", ")", "\n", "param_space", "=", "{", "f'model__{k}'", ":", "v", "for", "k", ",", "v", "in", "self", ".", "param_space", ".", "items", "(", ")", "}", "\n", "self", ".", "search", "=", "search", "(", "estimator", ",", "param_space", ",", "**", "search_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.name": [[54, 57], ["None"], "methods", ["None"], ["", "@", "name", ".", "setter", "\n", "def", "name", "(", "self", ",", "name", ")", ":", "\n", "        ", "self", ".", "_name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.is_regression": [[58, 61], ["isinstance"], "methods", ["None"], ["", "def", "is_regression", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return True if the estimator is a regressor.\"\"\"", "\n", "return", "isinstance", "(", "self", ".", "estimator", ",", "RegressorMixin", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.is_classification": [[62, 65], ["isinstance"], "methods", ["None"], ["", "def", "is_classification", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return True if the estimator is a regressor.\"\"\"", "\n", "return", "isinstance", "(", "self", ".", "estimator", ",", "ClassifierMixin", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.estimator_class": [[66, 68], ["None"], "methods", ["None"], ["", "def", "estimator_class", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "estimator", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.inner_cv_class": [[69, 71], ["None"], "methods", ["None"], ["", "def", "inner_cv_class", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "inner_cv", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.outer_cv_class": [[72, 74], ["None"], "methods", ["None"], ["", "def", "outer_cv_class", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "inner_cv", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.search_class": [[75, 77], ["None"], "methods", ["None"], ["", "def", "search_class", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "search", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.imputer_class": [[78, 80], ["None"], "methods", ["None"], ["", "def", "imputer_class", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "imputer", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.get_infos": [[81, 116], ["strategy.Strategy.estimator_class", "strategy.Strategy.inner_cv_class", "strategy.Strategy.outer_cv_class", "strategy.Strategy.search_class", "strategy.Strategy.is_classification", "strategy.Strategy.imputer_class", "strategy.Strategy.search.__dict__.items", "strategy.Strategy.estimator.__dict__.items"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.estimator_class", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.inner_cv_class", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.outer_cv_class", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.search_class", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.is_classification", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.imputer_class"], ["", "def", "get_infos", "(", "self", ")", ":", "\n", "# Remove redondant params in the dump", "\n", "        ", "if", "self", ".", "param_space", ":", "\n", "            ", "estimator_params", "=", "{", "\n", "k", ":", "v", "for", "k", ",", "v", "in", "self", ".", "estimator", ".", "__dict__", ".", "items", "(", ")", "if", "k", "not", "in", "self", ".", "param_space", "\n", "}", "\n", "", "else", ":", "\n", "            ", "estimator_params", "=", "None", "\n", "# Remove redondant params in the dump", "\n", "", "search_params", "=", "{", "\n", "k", ":", "v", "for", "k", ",", "v", "in", "self", ".", "search", ".", "__dict__", ".", "items", "(", ")", "if", "k", "not", "in", "[", "'estimator'", ",", "'cv'", "]", "\n", "}", "\n", "imputer_params", "=", "None", "if", "self", ".", "imputer", "is", "None", "else", "self", ".", "imputer", ".", "__dict__", "\n", "\n", "# Retrieving params", "\n", "inner_cv", "=", "None", "if", "self", ".", "inner_cv", "is", "None", "else", "self", ".", "inner_cv", ".", "__dict__", "\n", "\n", "return", "{", "\n", "'name'", ":", "self", ".", "name", ",", "\n", "'estimator'", ":", "self", ".", "estimator_class", "(", ")", ",", "\n", "'estimator_params'", ":", "estimator_params", ",", "\n", "'inner_cv'", ":", "self", ".", "inner_cv_class", "(", ")", ",", "\n", "'inner_cv_params'", ":", "inner_cv", ",", "\n", "'outer_cv'", ":", "self", ".", "outer_cv_class", "(", ")", ",", "\n", "'outer_cv_params'", ":", "self", ".", "outer_cv", ".", "__dict__", ",", "\n", "'search'", ":", "self", ".", "search_class", "(", ")", ",", "\n", "'search_params'", ":", "search_params", ",", "\n", "'classification'", ":", "self", ".", "is_classification", "(", ")", ",", "\n", "'param_space'", ":", "self", ".", "param_space", ",", "\n", "'imputer'", ":", "self", ".", "imputer_class", "(", ")", ",", "\n", "'imputer_params'", ":", "imputer_params", ",", "\n", "'compute_importance'", ":", "self", ".", "compute_importance", ",", "\n", "'importance_params'", ":", "self", ".", "importance_params", ",", "\n", "'learning_curve_params'", ":", "self", ".", "learning_curve_params", ",", "\n", "'sklearn_version'", ":", "sklearn", ".", "__version__", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.strategies.strategy.Strategy.reset_RS": [[118, 128], ["int", "hasattr", "logger.info"], "methods", ["None"], ["", "def", "reset_RS", "(", "self", ",", "RS", ")", ":", "\n", "        ", "if", "RS", "is", "None", ":", "\n", "            ", "return", "# Nothing to do", "\n", "\n", "", "RS", "=", "int", "(", "RS", ")", "\n", "\n", "for", "obj", "in", "[", "self", ".", "estimator", ",", "self", ".", "inner_cv", ",", "self", ".", "outer_cv", ",", "self", ".", "imputer", "]", ":", "\n", "            ", "if", "obj", "is", "not", "None", "and", "hasattr", "(", "obj", ",", "'random_state'", ")", ":", "\n", "                ", "logger", ".", "info", "(", "f'Reset RS for {obj.__class__.__name__} to {RS}.'", ")", "\n", "obj", ".", "random_state", "=", "RS", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tabs.run_scores": [[13, 167], ["pandas.concat", "tests.tasks_to_drop.items", "df[].str.replace", "prediction.df_utils.get_scores_tab", "prediction.df_utils.get_ranks_tab", "prediction.df_utils.get_scores_tab.rename", "prediction.df_utils.get_ranks_tab.rename", "prediction.df_utils.get_scores_tab.rename", "prediction.df_utils.get_ranks_tab.rename", "print", "print", "prediction.df_utils.get_ranks_tab.loc[].astype().idxmin", "ranks.loc[].astype().idxmin.iteritems", "ranks[].drop().astype().groupby().idxmin", "prediction.df_utils.get_scores_tab.columns.get_level_values", "prediction.df_utils.get_scores_tab.rename", "prediction.df_utils.get_ranks_tab.rename", "prediction.df_utils.get_ranks_tab.rename", "prediction.df_utils.get_scores_tab.rename", "prediction.df_utils.get_scores_tab.rename", "prediction.df_utils.get_ranks_tab.rename", "custom.const.get_tab_folder", "prediction.df_utils.get_scores_tab.to_latex", "prediction.df_utils.get_ranks_tab.to_latex", "pandas.read_csv", "pd.concat.drop", "best_ranks_by_size[].iteritems", "k.replace", "pandas.isnull", "prediction.df_utils.get_scores_tab.loc[].apply", "len", "os.path.join", "os.path.join", "prediction.df_utils.get_scores_tab.to_csv", "prediction.df_utils.get_ranks_tab.to_csv", "prediction.df_utils.get_ranks_tab.loc[].astype", "ranks[].drop().astype().groupby", "pandas.isnull", "rename.items", "os.path.join", "os.path.join", "ranks[].drop().astype", "ranks[].drop"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_scores_tab", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_ranks_tab", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["def", "run_scores", "(", "graphics_folder", ",", "linear", ",", "csv", "=", "False", ",", "relative", "=", "True", ")", ":", "\n", "# path = os.path.abspath('scores/scores.csv')", "\n", "# df = pd.read_csv(path, index_col=0)", "\n", "\n", "# filepaths = [", "\n", "#     'scores/scores.csv',", "\n", "#     'scores/scores_mi_2500.csv',", "\n", "#     'scores/scores_mia_2500.csv',", "\n", "#     'scores/scores_mi_10000.csv',", "\n", "#     'scores/scores_mia_10000.csv',", "\n", "#     'scores/scores_mia_25000.csv',", "\n", "#     'scores/scores_mi_25000.csv',", "\n", "#     'scores/scores_mia_100000.csv',", "\n", "#     'scores/scores_mi_100000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_2500.csv',", "\n", "#     'scores/scores_mean+mask+bagging_10000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_25000.csv',", "\n", "# ]", "\n", "    ", "dfs", "=", "[", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "for", "path", "in", "filepaths", "]", "\n", "df", "=", "pd", ".", "concat", "(", "dfs", ",", "axis", "=", "0", ")", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "df", ".", "drop", "(", "index", "=", "df", "[", "(", "df", "[", "'db'", "]", "==", "db", ")", "&", "(", "df", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "df", "[", "'task'", "]", "=", "df", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "if", "linear", ":", "\n", "        ", "method_order", "=", "[", "\n", "'MIA'", ",", "\n", "'Linear+Mean'", ",", "\n", "'Linear+Mean+mask'", ",", "\n", "'Linear+Med'", ",", "\n", "'Linear+Med+mask'", ",", "\n", "'Linear+Iter'", ",", "\n", "'Linear+Iter+mask'", ",", "\n", "'Linear+KNN'", ",", "\n", "'Linear+KNN+mask'", ",", "\n", "]", "\n", "\n", "", "else", ":", "\n", "        ", "method_order", "=", "[", "\n", "'MIA'", ",", "\n", "'Mean'", ",", "\n", "'Mean+mask'", ",", "\n", "'Med'", ",", "\n", "'Med+mask'", ",", "\n", "'Iter'", ",", "\n", "'Iter+mask'", ",", "\n", "'KNN'", ",", "\n", "'KNN+mask'", ",", "\n", "'MI'", ",", "\n", "'MI+mask'", ",", "\n", "'MIA+bagging'", ",", "\n", "]", "\n", "\n", "", "db_order", "=", "[", "\n", "'TB'", ",", "\n", "'UKBB'", ",", "\n", "'MIMIC'", ",", "\n", "'NHIS'", ",", "\n", "]", "\n", "\n", "scores", "=", "get_scores_tab", "(", "df", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "relative", "=", "relative", ")", "\n", "ranks", "=", "get_ranks_tab", "(", "df", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ")", "\n", "\n", "rename", "=", "{", "\n", "'Med'", ":", "'Median'", ",", "\n", "'Med+mask'", ":", "'Median+mask'", ",", "\n", "'Iter'", ":", "'Iterative'", ",", "\n", "'Iter+mask'", ":", "'Iterative+mask'", ",", "\n", "'MIA+bagging'", ":", "'MIA+Bagging'", ",", "\n", "'MI'", ":", "'Iterative+Bagging'", ",", "\n", "'MI+mask'", ":", "'Iterative+mask+Bagging'", ",", "\n", "}", "\n", "\n", "if", "linear", ":", "\n", "        ", "rename", "[", "'MIA'", "]", "=", "'Boosted trees+MIA'", "\n", "", "scores", ".", "rename", "(", "rename", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "ranks", ".", "rename", "(", "rename", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "# Rename DBs", "\n", "scores", ".", "rename", "(", "db_rename", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "ranks", ".", "rename", "(", "db_rename", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "print", "(", "scores", ")", "\n", "print", "(", "ranks", ")", "\n", "\n", "# Turn bold the best ranks", "\n", "best_ranks_by_task", "=", "ranks", ".", "loc", "[", "'Average'", "]", ".", "astype", "(", "float", ")", ".", "idxmin", "(", "axis", "=", "0", ",", "skipna", "=", "True", ")", "\n", "for", "(", "db", ",", "task", ")", ",", "best_method", "in", "best_ranks_by_task", ".", "iteritems", "(", ")", ":", "\n", "        ", "ranks", ".", "loc", "[", "(", "'Average'", ",", "best_method", ")", ",", "(", "db", ",", "task", ")", "]", "=", "f\"\\\\textbf{{{ranks.loc[('Average', best_method), (db, task)]}}}\"", "\n", "\n", "", "best_ranks_by_size", "=", "ranks", "[", "'Average'", "]", ".", "drop", "(", "'Average'", ",", "axis", "=", "0", ",", "level", "=", "0", ")", ".", "astype", "(", "float", ")", ".", "groupby", "(", "[", "'Size'", "]", ")", ".", "idxmin", "(", "axis", "=", "0", ",", "skipna", "=", "True", ")", "\n", "for", "db", "in", "best_ranks_by_size", ".", "columns", ":", "\n", "        ", "for", "size", ",", "value", "in", "best_ranks_by_size", "[", "db", "]", ".", "iteritems", "(", ")", ":", "\n", "            ", "if", "pd", ".", "isnull", "(", "value", ")", ":", "\n", "                ", "continue", "\n", "", "best_method", "=", "value", "[", "1", "]", "\n", "ranks", ".", "loc", "[", "(", "size", ",", "best_method", ")", ",", "(", "'Average'", ",", "db", ")", "]", "=", "f\"\\\\textbf{{{ranks.loc[(size, best_method), ('Average', db)]}}}\"", "\n", "\n", "# Preprocessing for latex dump", "\n", "", "", "tasks", "=", "scores", ".", "columns", ".", "get_level_values", "(", "1", ")", "\n", "rename", "=", "{", "k", ":", "k", ".", "replace", "(", "\"_\"", ",", "r\"\\_\"", ")", "for", "k", "in", "tasks", "}", "\n", "rename", "=", "{", "k", ":", "f'\\\\rot{{{v}}}'", "for", "k", ",", "v", "in", "rename", ".", "items", "(", ")", "}", "\n", "\n", "scores", ".", "rename", "(", "columns", "=", "rename", ",", "inplace", "=", "True", ")", "\n", "ranks", ".", "rename", "(", "columns", "=", "rename", ",", "inplace", "=", "True", ")", "\n", "\n", "# Rotate dbs on ranks", "\n", "ranks", ".", "rename", "(", "{", "v", ":", "f'\\\\rot{{{v}}}'", "for", "v", "in", "ranks", "[", "'Average'", "]", ".", "columns", "}", ",", "axis", "=", "1", ",", "level", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "# Turn bold the reference scores", "\n", "def", "boldify", "(", "x", ")", ":", "\n", "        ", "if", "pd", ".", "isnull", "(", "x", ")", ":", "\n", "            ", "return", "''", "\n", "", "else", ":", "\n", "            ", "return", "f'\\\\textbf{{{x}}}'", "\n", "\n", "", "", "smallskip", "=", "'0.15in'", "\n", "bigskip", "=", "'0.23in'", "\n", "medskip", "=", "'0.20in'", "\n", "# smallskip = '0.15in'", "\n", "# bigskip = '0.3in'", "\n", "# medskip = '0.23in'", "\n", "index_rename", "=", "{", "}", "\n", "\n", "for", "size", "in", "[", "2500", ",", "10000", ",", "25000", ",", "100000", ",", "'Average'", "]", ":", "\n", "        ", "scores", ".", "loc", "[", "(", "size", ",", "'Reference score'", ")", "]", "=", "scores", ".", "loc", "[", "(", "size", ",", "'Reference score'", ")", "]", ".", "apply", "(", "boldify", ")", "\n", "if", "size", "==", "2500", ":", "\n", "            ", "continue", "\n", "", "skip", "=", "bigskip", "if", "size", "==", "'Average'", "else", "medskip", "\n", "index_rename", "[", "size", "]", "=", "f'\\\\rule{{0pt}}{{{skip}}}{size}'", "\n", "\n", "", "scores", ".", "rename", "(", "index_rename", ",", "axis", "=", "0", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "scores", ".", "rename", "(", "{", "'Reference score'", ":", "f'\\\\rule{{0pt}}{{{smallskip}}}Reference score'", "}", ",", "axis", "=", "0", ",", "level", "=", "1", ",", "inplace", "=", "True", ")", "\n", "ranks", ".", "rename", "(", "index_rename", ",", "axis", "=", "0", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "n_latex_columns", "=", "len", "(", "ranks", ".", "columns", ")", "+", "2", "\n", "column_format", "=", "'l'", "*", "(", "n_latex_columns", "-", "5", ")", "+", "f'@{{\\\\hskip {smallskip}}}'", "+", "'l'", "*", "4", "+", "f'@{{\\\\hskip {medskip}}}'", "+", "'l'", "\n", "\n", "tab_folder", "=", "get_tab_folder", "(", "graphics_folder", ")", "\n", "abs", "=", "'_absolute'", "if", "not", "relative", "else", "''", "\n", "tab1_name", "=", "f'scores_linear{abs}'", "if", "linear", "else", "f'scores{abs}'", "\n", "tab2_name", "=", "f'ranks_linear{abs}'", "if", "linear", "else", "f'ranks{abs}'", "\n", "\n", "scores", ".", "to_latex", "(", "join", "(", "tab_folder", ",", "f'{tab1_name}.tex'", ")", ",", "na_rep", "=", "''", ",", "escape", "=", "False", ")", "#, table_env='tabularx') #, column_format='L'*scores.shape[1])", "\n", "ranks", ".", "to_latex", "(", "join", "(", "tab_folder", ",", "f'{tab2_name}.tex'", ")", ",", "na_rep", "=", "''", ",", "escape", "=", "False", ",", "\n", "#table_env='tabularx',", "\n", "column_format", "=", "column_format", ")", "\n", "\n", "if", "csv", ":", "\n", "        ", "scores", ".", "to_csv", "(", "join", "(", "tab_folder", ",", "f'{tab1_name}.csv'", ")", ")", "\n", "ranks", ".", "to_csv", "(", "join", "(", "tab_folder", ",", "f'{tab2_name}.csv'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tabs.run_desc": [[169, 247], ["os.path.abspath", "pandas.read_csv", "tests.tasks_to_drop.items", "prediction.PlotHelper.PlotHelper.get_task_description", "df.drop.drop", "tests.tasks_to_drop.items", "df.drop.reset_index", "df[].str.replace", "df.drop.set_index", "df.drop.reindex", "custom.const.get_tab_folder", "df.drop.rename", "df.drop.rename", "df.drop.rename", "df[].map", "df.drop.applymap", "df.drop.index.get_level_values", "df.drop.rename", "df.drop.rename", "enumerate", "df.drop.rename", "len", "df.drop.drop", "time_columns.keys", "df.drop.drop", "k.replace", "pandas.unique", "pandas.option_context", "df.drop.to_latex", "str().replace", "float", "str", "df.drop.index.get_level_values", "os.path.join", "int", "str"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.get_task_description", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], ["", "", "def", "run_desc", "(", "graphics_folder", ")", ":", "\n", "    ", "path", "=", "os", ".", "path", ".", "abspath", "(", "'scores/scores.csv'", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "df", ".", "drop", "(", "index", "=", "df", "[", "(", "df", "[", "'db'", "]", "==", "db", ")", "&", "(", "df", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "df", "=", "PlotHelper", ".", "get_task_description", "(", "df", ")", "\n", "\n", "time_columns", "=", "{", "\n", "'Imputation time (s)'", ":", "'Time - Imputation (s)'", ",", "\n", "'Tuning time (s)'", ":", "'Time - Tuning (s)'", ",", "\n", "'Total time (s)'", ":", "'Time - Total (s)'", ",", "\n", "}", "\n", "\n", "df", ".", "drop", "(", "time_columns", ".", "keys", "(", ")", ",", "inplace", "=", "True", ",", "axis", "=", "1", ")", "\n", "# df.rename(columns=time_columns, inplace=True)", "\n", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "df", "=", "df", ".", "drop", "(", "(", "db", ",", "task", ")", ",", "axis", "=", "0", ")", "\n", "\n", "", "df", "=", "df", ".", "reset_index", "(", ")", "\n", "df", "[", "'Task'", "]", "=", "df", "[", "'Task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "df", "=", "df", ".", "set_index", "(", "[", "'Database'", ",", "'Task'", "]", ")", "\n", "\n", "df", "=", "df", ".", "reindex", "(", "db_order", ",", "level", "=", "0", ",", "axis", "=", "0", ")", "\n", "\n", "tab_folder", "=", "get_tab_folder", "(", "graphics_folder", ")", "\n", "\n", "# Rename DBs", "\n", "df", ".", "rename", "(", "db_rename", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "# Rotate Traumabase", "\n", "df", ".", "rename", "(", "{", "'Traumabase'", ":", "'\\\\rotsmash{Traumabase}'", "}", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "df", ".", "rename", "(", "{", "'n'", ":", "'Number of samples'", ",", "'p'", ":", "'Number of features'", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "# Custom escape content of table", "\n", "df", "[", "'Target'", "]", "=", "df", "[", "'Target'", "]", ".", "map", "(", "lambda", "x", ":", "str", "(", "x", ")", ".", "replace", "(", "'_'", ",", "r'\\_'", ")", ")", "\n", "\n", "# Round floats to int", "\n", "def", "to_int", "(", "x", ")", ":", "# Convert to int and robust to NaN", "\n", "        ", "try", ":", "\n", "            ", "f", "=", "float", "(", "x", ")", "\n", "if", "f", "<", "1", ":", "\n", "                ", "return", "f'{f:.2f}'", "\n", "", "return", "str", "(", "int", "(", "x", ")", ")", "\n", "", "except", ":", "\n", "            ", "return", "x", "\n", "\n", "", "", "df", "=", "df", ".", "applymap", "(", "to_int", ")", "\n", "\n", "# Preprocessing for latex dump", "\n", "tasks", "=", "df", ".", "index", ".", "get_level_values", "(", "1", ")", "\n", "rename", "=", "{", "k", ":", "k", ".", "replace", "(", "\"_\"", ",", "r\"\\_\"", ")", "for", "k", "in", "tasks", "}", "\n", "df", ".", "rename", "(", "index", "=", "rename", ",", "inplace", "=", "True", ")", "\n", "\n", "rename", "=", "{", "v", ":", "f'\\\\rot{{{v}}}'", "for", "v", "in", "df", ".", "columns", "if", "v", "not", "in", "[", "'Target'", ",", "'Description'", "]", "}", "\n", "df", ".", "rename", "(", "columns", "=", "rename", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "skip", "=", "'0.3in'", "\n", "index_rename", "=", "{", "}", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "pd", ".", "unique", "(", "df", ".", "index", ".", "get_level_values", "(", "0", ")", ")", ")", ":", "\n", "        ", "if", "i", "==", "0", ":", "\n", "            ", "continue", "\n", "", "index_rename", "[", "v", "]", "=", "f'\\\\rule{{0pt}}{{{skip}}}{v}'", "\n", "\n", "", "df", ".", "rename", "(", "index_rename", ",", "axis", "=", "0", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "n", "=", "len", "(", "df", ".", "columns", ")", "\n", "column_format", "=", "'l'", "*", "df", ".", "index", ".", "nlevels", "+", "'l'", "*", "(", "n", "-", "2", ")", "+", "'X'", "*", "2", "\n", "\n", "with", "pd", ".", "option_context", "(", "\"max_colwidth\"", ",", "None", ")", ":", "\n", "        ", "df", ".", "to_latex", "(", "join", "(", "tab_folder", ",", "'task_description.tex'", ")", ",", "\n", "# table_env='tabularx',", "\n", "bold_rows", "=", "False", ",", "na_rep", "=", "None", ",", "escape", "=", "False", ",", "\n", "column_format", "=", "column_format", ",", "\n", "multirow", "=", "False", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.get_indicators_mv": [[67, 308], ["df_mv1.values.sum", "df_mv2.values.sum", "pandas.DataFrame", "df_mv1.any().rename", "df_mv2.any().rename", "pandas.concat", "pd.concat.sum", "pandas.DataFrame", "df_mv1.sum().to_frame", "df_mv2.sum().to_frame", "pandas.concat", "numpy.arange", "pd.concat.sort_values", "df_mv1.any().rename", "df_mv2.any().rename", "pandas.concat", "pd.concat.sum", "pandas.DataFrame", "pandas.Series", "df_mv_bool.drop", "df_mv_bool.drop", "df_mv_bool.drop", "df_mv_bool.drop", "df_mv_bool.drop", "df_mv_bool.drop", "pandas.DataFrame", "pandas.DataFrame", "df_mv1.any", "df_mv2.any", "df_mv1.sum", "df_mv2.sum", "df_mv1.any", "df_mv2.any"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["def", "get_indicators_mv", "(", "df_mv", ")", ":", "\n", "    ", "\"\"\"Compute indicators about missing values. Used for plotting figures.\"\"\"", "\n", "# 1: Statistics on the full database", "\n", "n_rows", ",", "n_cols", "=", "df_mv", ".", "shape", "\n", "n_values", "=", "n_rows", "*", "n_cols", "\n", "df_mv1", "=", "df_mv", "==", "1", "\n", "df_mv2", "=", "df_mv", "==", "2", "\n", "df_mv_bool", "=", "df_mv", "!=", "0", "\n", "\n", "# Number of missing values in the DB", "\n", "n_mv1", "=", "df_mv1", ".", "values", ".", "sum", "(", ")", "\n", "n_mv2", "=", "df_mv2", ".", "values", ".", "sum", "(", ")", "\n", "n_mv", "=", "n_mv1", "+", "n_mv2", "\n", "n_not_mv", "=", "n_values", "-", "n_mv", "\n", "\n", "# Frequencies of missing values in the DB", "\n", "f_mv1", "=", "100", "*", "n_mv1", "/", "n_values", "\n", "f_mv2", "=", "100", "*", "n_mv2", "/", "n_values", "\n", "f_mv", "=", "100", "*", "n_mv", "/", "n_values", "\n", "f_not_mv", "=", "100", "*", "n_not_mv", "/", "n_values", "\n", "\n", "# Store the indicators in a df", "\n", "df_1", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'n_rows'", ":", "[", "n_rows", "]", ",", "\n", "'n_cols'", ":", "[", "n_cols", "]", ",", "\n", "'n_values'", ":", "[", "n_values", "]", ",", "\n", "'n_mv'", ":", "[", "n_mv", "]", ",", "\n", "'n_mv1'", ":", "[", "n_mv1", "]", ",", "\n", "'n_mv2'", ":", "[", "n_mv2", "]", ",", "\n", "'n_not_mv'", ":", "[", "n_not_mv", "]", ",", "\n", "'f_mv'", ":", "[", "f_mv", "]", ",", "\n", "'f_mv1'", ":", "[", "f_mv1", "]", ",", "\n", "'f_mv2'", ":", "[", "f_mv2", "]", ",", "\n", "'f_not_mv'", ":", "[", "f_not_mv", "]", ",", "\n", "}", ")", "\n", "\n", "# 2: Number of features with missing values", "\n", "# For each feature, tells if it contains MV of type 1", "\n", "df_f_w_mv1", "=", "df_mv1", ".", "any", "(", ")", ".", "rename", "(", "'MV1'", ")", "\n", "# For each feature, tells if it contains MV of type 2", "\n", "df_f_w_mv2", "=", "df_mv2", ".", "any", "(", ")", ".", "rename", "(", "'MV2'", ")", "\n", "# Concat previous series", "\n", "df_f_w_mv", "=", "pd", ".", "concat", "(", "[", "df_f_w_mv1", ",", "df_f_w_mv2", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Add columns for logical combination of the two series", "\n", "df_f_w_mv", "[", "'MV'", "]", "=", "df_f_w_mv", "[", "'MV1'", "]", "|", "df_f_w_mv", "[", "'MV2'", "]", "# MV1 or MV2", "\n", "df_f_w_mv", "[", "'MV1a2'", "]", "=", "df_f_w_mv", "[", "'MV1'", "]", "&", "df_f_w_mv", "[", "'MV2'", "]", "# MV1 and MV2", "\n", "df_f_w_mv", "[", "'MV1o'", "]", "=", "df_f_w_mv", "[", "'MV1'", "]", "&", "~", "df_f_w_mv", "[", "'MV2'", "]", "# MV1 only", "\n", "df_f_w_mv", "[", "'MV2o'", "]", "=", "~", "df_f_w_mv", "[", "'MV1'", "]", "&", "df_f_w_mv", "[", "'MV2'", "]", "# MV2 only", "\n", "\n", "# By summing, derive the number of features with MV of a given type", "\n", "df_n_f_w_mv", "=", "df_f_w_mv", ".", "sum", "(", ")", "\n", "\n", "# Numbers of features with missing values", "\n", "n_f_w_mv", "=", "df_n_f_w_mv", "[", "'MV'", "]", "# MV1 or MV2", "\n", "n_f_w_mv1_o", "=", "df_n_f_w_mv", "[", "'MV1o'", "]", "# MV1 only", "\n", "n_f_w_mv2_o", "=", "df_n_f_w_mv", "[", "'MV2o'", "]", "# MV2 only", "\n", "n_f_w_mv_1a2", "=", "df_n_f_w_mv", "[", "'MV1a2'", "]", "# MV1 and MV2", "\n", "n_f_wo_mv", "=", "n_cols", "-", "df_n_f_w_mv", "[", "'MV'", "]", "# Without MV", "\n", "\n", "# Frequencies of features with missing values", "\n", "f_f_w_mv1_o", "=", "100", "*", "n_f_w_mv1_o", "/", "n_cols", "\n", "f_f_w_mv2_o", "=", "100", "*", "n_f_w_mv2_o", "/", "n_cols", "\n", "f_f_w_mv", "=", "100", "*", "n_f_w_mv", "/", "n_cols", "\n", "f_f_w_mv_1a2", "=", "100", "*", "n_f_w_mv_1a2", "/", "n_cols", "\n", "f_f_wo_mv", "=", "100", "*", "n_f_wo_mv", "/", "n_cols", "\n", "\n", "# Store the indicators in a df", "\n", "df_2", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'n_f_w_mv'", ":", "[", "n_f_w_mv", "]", ",", "\n", "'n_f_w_mv1_o'", ":", "[", "n_f_w_mv1_o", "]", ",", "\n", "'n_f_w_mv2_o'", ":", "[", "n_f_w_mv2_o", "]", ",", "\n", "'n_f_w_mv_1a2'", ":", "[", "n_f_w_mv_1a2", "]", ",", "\n", "'n_f_wo_mv'", ":", "[", "n_f_wo_mv", "]", ",", "\n", "'f_f_w_mv'", ":", "[", "f_f_w_mv", "]", ",", "\n", "'f_f_w_mv1_o'", ":", "[", "f_f_w_mv1_o", "]", ",", "\n", "'f_f_w_mv2_o'", ":", "[", "f_f_w_mv2_o", "]", ",", "\n", "'f_f_w_mv_1a2'", ":", "[", "f_f_w_mv_1a2", "]", ",", "\n", "'f_f_wo_mv'", ":", "[", "f_f_wo_mv", "]", ",", "\n", "}", ")", "\n", "\n", "# 3: Statistics feature-wise", "\n", "n_mv1_fw", "=", "df_mv1", ".", "sum", "(", ")", ".", "to_frame", "(", "'N MV1'", ")", "# Number of MV 1 by feature", "\n", "n_mv2_fw", "=", "df_mv2", ".", "sum", "(", ")", ".", "to_frame", "(", "'N MV2'", ")", "# Number of MV 2 by feature", "\n", "\n", "n_mv_fw", "=", "pd", ".", "concat", "(", "[", "n_mv1_fw", ",", "n_mv2_fw", "]", ",", "axis", "=", "1", ")", "\n", "n_mv_fw", "[", "'N MV'", "]", "=", "n_mv_fw", "[", "'N MV1'", "]", "+", "n_mv_fw", "[", "'N MV2'", "]", "\n", "n_mv_fw", "[", "'N V'", "]", "=", "n_rows", "\n", "n_mv_fw", "[", "'N NMV'", "]", "=", "n_mv_fw", "[", "'N V'", "]", "-", "n_mv_fw", "[", "'N MV'", "]", "\n", "n_mv_fw", "[", "'F MV1'", "]", "=", "100", "*", "n_mv_fw", "[", "'N MV1'", "]", "/", "n_rows", "\n", "n_mv_fw", "[", "'F MV2'", "]", "=", "100", "*", "n_mv_fw", "[", "'N MV2'", "]", "/", "n_rows", "\n", "n_mv_fw", "[", "'F MV'", "]", "=", "100", "*", "n_mv_fw", "[", "'N MV'", "]", "/", "n_rows", "\n", "n_mv_fw", "[", "'id'", "]", "=", "np", ".", "arange", "(", "0", ",", "n_mv_fw", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# Sort by number of missing values", "\n", "n_mv_fw", ".", "sort_values", "(", "'N MV'", ",", "ascending", "=", "False", ",", "inplace", "=", "True", ")", "\n", "\n", "# Store the indicators in a df", "\n", "df_3", "=", "n_mv_fw", "\n", "\n", "# 4: Rows without missing values", "\n", "# For each row, tells if it contains MV of type 1", "\n", "df_r_w_mv1", "=", "df_mv1", ".", "any", "(", "axis", "=", "1", ")", ".", "rename", "(", "'MV1'", ")", "\n", "# For each row, tells if it contains MV of type 2", "\n", "df_r_w_mv2", "=", "df_mv2", ".", "any", "(", "axis", "=", "1", ")", ".", "rename", "(", "'MV2'", ")", "\n", "# Concat previous series", "\n", "df_r_w_mv", "=", "pd", ".", "concat", "(", "[", "df_r_w_mv1", ",", "df_r_w_mv2", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Add columns for logical combination of the two series", "\n", "df_r_w_mv", "[", "'MV'", "]", "=", "df_r_w_mv", "[", "'MV1'", "]", "|", "df_r_w_mv", "[", "'MV2'", "]", "# MV1 or MV2", "\n", "df_r_w_mv", "[", "'MV1a2'", "]", "=", "df_r_w_mv", "[", "'MV1'", "]", "&", "df_r_w_mv", "[", "'MV2'", "]", "# MV1 and MV2", "\n", "df_r_w_mv", "[", "'MV1o'", "]", "=", "df_r_w_mv", "[", "'MV1'", "]", "&", "~", "df_r_w_mv", "[", "'MV2'", "]", "# MV1 only", "\n", "df_r_w_mv", "[", "'MV2o'", "]", "=", "~", "df_r_w_mv", "[", "'MV1'", "]", "&", "df_r_w_mv", "[", "'MV2'", "]", "# MV2 only", "\n", "\n", "# By summing, derive the number of rows with MV of a given type", "\n", "df_n_r_w_mv", "=", "df_r_w_mv", ".", "sum", "(", ")", "\n", "\n", "# Numbers of rows with missing values", "\n", "n_r_w_mv", "=", "df_n_r_w_mv", "[", "'MV'", "]", "# MV1 or MV2", "\n", "n_r_w_mv1_o", "=", "df_n_r_w_mv", "[", "'MV1o'", "]", "# MV1 only", "\n", "n_r_w_mv2_o", "=", "df_n_r_w_mv", "[", "'MV2o'", "]", "# MV2 only", "\n", "n_r_w_mv_1a2", "=", "df_n_r_w_mv", "[", "'MV1a2'", "]", "# MV1 and MV2", "\n", "n_r_wo_mv", "=", "n_rows", "-", "df_n_r_w_mv", "[", "'MV'", "]", "# Without MV", "\n", "\n", "# Frequencies of rows with missing values", "\n", "f_r_w_mv1_o", "=", "100", "*", "n_r_w_mv1_o", "/", "n_rows", "\n", "f_r_w_mv2_o", "=", "100", "*", "n_r_w_mv2_o", "/", "n_rows", "\n", "f_r_w_mv", "=", "100", "*", "n_r_w_mv", "/", "n_rows", "\n", "f_r_w_mv_1a2", "=", "100", "*", "n_r_w_mv_1a2", "/", "n_rows", "\n", "f_r_wo_mv", "=", "100", "*", "n_r_wo_mv", "/", "n_rows", "\n", "\n", "# Store the indicators in a df", "\n", "df_4", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'n_r_w_mv'", ":", "[", "n_r_w_mv", "]", ",", "\n", "'n_r_w_mv1_o'", ":", "[", "n_r_w_mv1_o", "]", ",", "\n", "'n_r_w_mv2_o'", ":", "[", "n_r_w_mv2_o", "]", ",", "\n", "'n_r_w_mv_1a2'", ":", "[", "n_r_w_mv_1a2", "]", ",", "\n", "'n_r_wo_mv'", ":", "[", "n_r_wo_mv", "]", ",", "\n", "'f_r_w_mv'", ":", "[", "f_r_w_mv", "]", ",", "\n", "'f_r_w_mv1_o'", ":", "[", "f_r_w_mv1_o", "]", ",", "\n", "'f_r_w_mv2_o'", ":", "[", "f_r_w_mv2_o", "]", ",", "\n", "'f_r_w_mv_1a2'", ":", "[", "f_r_w_mv_1a2", "]", ",", "\n", "'f_r_wo_mv'", ":", "[", "f_r_wo_mv", "]", ",", "\n", "}", ")", "\n", "\n", "# 5: Number of rows affected if we remove features with MV", "\n", "df_f_w_mv1", "=", "df_f_w_mv", "[", "'MV1'", "]", "# Series of features having MV1", "\n", "df_f_w_mv2", "=", "df_f_w_mv", "[", "'MV2'", "]", "# Series of features having MV2", "\n", "df_f_w_mv_1o2", "=", "df_f_w_mv", "[", "'MV'", "]", "# Series of features having MV1 or MV2", "\n", "df_f_w_mv1_o", "=", "df_f_w_mv", "[", "'MV1o'", "]", "# Series of features having MV1 only", "\n", "df_f_w_mv2_o", "=", "df_f_w_mv", "[", "'MV2o'", "]", "# Series of features having MV2 only", "\n", "df_f_w_mv_1a2", "=", "df_f_w_mv", "[", "'MV1a2'", "]", "# Series of features having MV1 and MV2", "\n", "\n", "df_features", "=", "pd", ".", "Series", "(", "True", ",", "index", "=", "df_f_w_mv", ".", "index", ")", "\n", "\n", "features_to_drop_mv1", "=", "df_features", ".", "loc", "[", "~", "df_f_w_mv1", "]", ".", "index", "\n", "features_to_drop_mv2", "=", "df_features", ".", "loc", "[", "~", "df_f_w_mv2", "]", ".", "index", "\n", "features_to_drop_mv_1o2", "=", "df_features", ".", "loc", "[", "~", "df_f_w_mv_1o2", "]", ".", "index", "\n", "features_to_drop_mv1_o", "=", "df_features", ".", "loc", "[", "~", "df_f_w_mv1_o", "]", ".", "index", "\n", "features_to_drop_mv2_o", "=", "df_features", ".", "loc", "[", "~", "df_f_w_mv2_o", "]", ".", "index", "\n", "features_to_drop_mv_1a2", "=", "df_features", ".", "loc", "[", "~", "df_f_w_mv_1a2", "]", ".", "index", "\n", "\n", "df_mv1_dropped", "=", "df_mv_bool", ".", "drop", "(", "features_to_drop_mv1", ",", "1", ")", "\n", "df_mv2_dropped", "=", "df_mv_bool", ".", "drop", "(", "features_to_drop_mv2", ",", "1", ")", "\n", "df_mv_1o2_dropped", "=", "df_mv_bool", ".", "drop", "(", "features_to_drop_mv_1o2", ",", "1", ")", "\n", "df_mv1_o_dropped", "=", "df_mv_bool", ".", "drop", "(", "features_to_drop_mv1_o", ",", "1", ")", "\n", "df_mv2_o_dropped", "=", "df_mv_bool", ".", "drop", "(", "features_to_drop_mv2_o", ",", "1", ")", "\n", "df_mv_1a2_dropped", "=", "df_mv_bool", ".", "drop", "(", "features_to_drop_mv_1a2", ",", "1", ")", "\n", "\n", "# Number of rows affected if we remove feature having MV of type:", "\n", "n_r_a_rm_mv1", "=", "(", "~", "df_mv1_dropped", ")", ".", "any", "(", "axis", "=", "1", ")", ".", "sum", "(", ")", "# MV1", "\n", "n_r_a_rm_mv2", "=", "(", "~", "df_mv2_dropped", ")", ".", "any", "(", "axis", "=", "1", ")", ".", "sum", "(", ")", "# MV2", "\n", "n_r_a_rm_mv_1o2", "=", "(", "~", "df_mv_1o2_dropped", ")", ".", "any", "(", "axis", "=", "1", ")", ".", "sum", "(", ")", "# MV1 or MV2", "\n", "n_r_a_rm_mv1_o", "=", "(", "~", "df_mv1_o_dropped", ")", ".", "any", "(", "axis", "=", "1", ")", ".", "sum", "(", ")", "# MV1 only", "\n", "n_r_a_rm_mv2_o", "=", "(", "~", "df_mv2_o_dropped", ")", ".", "any", "(", "axis", "=", "1", ")", ".", "sum", "(", ")", "# MV2 only", "\n", "n_r_a_rm_mv_1a2", "=", "(", "~", "df_mv_1a2_dropped", ")", ".", "any", "(", "axis", "=", "1", ")", ".", "sum", "(", ")", "# MV1 and MV2", "\n", "\n", "# Frequencies of rows affected if we remove feature having MV of type:", "\n", "f_r_a_rm_mv1", "=", "100", "*", "n_r_a_rm_mv1", "/", "n_rows", "# MV1", "\n", "f_r_a_rm_mv2", "=", "100", "*", "n_r_a_rm_mv2", "/", "n_rows", "# MV2", "\n", "f_r_a_rm_mv_1o2", "=", "100", "*", "n_r_a_rm_mv_1o2", "/", "n_rows", "# MV1 or MV2", "\n", "f_r_a_rm_mv1_o", "=", "100", "*", "n_r_a_rm_mv1_o", "/", "n_rows", "# MV1 only", "\n", "f_r_a_rm_mv2_o", "=", "100", "*", "n_r_a_rm_mv2_o", "/", "n_rows", "# MV2 only", "\n", "f_r_a_rm_mv_1a2", "=", "100", "*", "n_r_a_rm_mv_1a2", "/", "n_rows", "# MV1 and MV2", "\n", "\n", "# Store the indicators in a df", "\n", "df_5", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'n_r_a_rm_mv1'", ":", "[", "n_r_a_rm_mv1", "]", ",", "\n", "'n_r_a_rm_mv2'", ":", "[", "n_r_a_rm_mv2", "]", ",", "\n", "'n_r_a_rm_mv_1o2'", ":", "[", "n_r_a_rm_mv_1o2", "]", ",", "\n", "'n_r_a_rm_mv1_o'", ":", "[", "n_r_a_rm_mv1_o", "]", ",", "\n", "'n_r_a_rm_mv2_o'", ":", "[", "n_r_a_rm_mv2_o", "]", ",", "\n", "'n_r_a_rm_mv_1a2'", ":", "[", "n_r_a_rm_mv_1a2", "]", ",", "\n", "'f_r_a_rm_mv1'", ":", "[", "f_r_a_rm_mv1", "]", ",", "\n", "'f_r_a_rm_mv2'", ":", "[", "f_r_a_rm_mv2", "]", ",", "\n", "'f_r_a_rm_mv_1o2'", ":", "[", "f_r_a_rm_mv_1o2", "]", ",", "\n", "'f_r_a_rm_mv1_o'", ":", "[", "f_r_a_rm_mv1_o", "]", ",", "\n", "'f_r_a_rm_mv2_o'", ":", "[", "f_r_a_rm_mv2_o", "]", ",", "\n", "'f_r_a_rm_mv_1a2'", ":", "[", "f_r_a_rm_mv_1a2", "]", ",", "\n", "}", ")", "\n", "\n", "# 6: Proportion of information lost when removing features with MV", "\n", "# Number", "\n", "n_v_lost_mv1", "=", "(", "~", "df_mv1_dropped", ")", ".", "sum", "(", ")", ".", "sum", "(", ")", "\n", "n_v_lost_mv2", "=", "(", "~", "df_mv2_dropped", ")", ".", "sum", "(", ")", ".", "sum", "(", ")", "\n", "n_v_lost_mv_1o2", "=", "(", "~", "df_mv_1o2_dropped", ")", ".", "sum", "(", ")", ".", "sum", "(", ")", "\n", "n_v_lost_mv1_o", "=", "(", "~", "df_mv1_o_dropped", ")", ".", "sum", "(", ")", ".", "sum", "(", ")", "\n", "n_v_lost_mv2_o", "=", "(", "~", "df_mv2_o_dropped", ")", ".", "sum", "(", ")", ".", "sum", "(", ")", "\n", "n_v_lost_mv_1a2", "=", "(", "~", "df_mv_1a2_dropped", ")", ".", "sum", "(", ")", ".", "sum", "(", ")", "\n", "\n", "# Frequencies", "\n", "f_v_lost_mv1", "=", "100", "*", "n_v_lost_mv1", "/", "n_values", "\n", "f_v_lost_mv2", "=", "100", "*", "n_v_lost_mv2", "/", "n_values", "\n", "f_v_lost_mv_1o2", "=", "100", "*", "n_v_lost_mv_1o2", "/", "n_values", "\n", "f_v_lost_mv1_o", "=", "100", "*", "n_v_lost_mv1_o", "/", "n_values", "\n", "f_v_lost_mv2_o", "=", "100", "*", "n_v_lost_mv2_o", "/", "n_values", "\n", "f_v_lost_mv_1a2", "=", "100", "*", "n_v_lost_mv_1a2", "/", "n_values", "\n", "\n", "# Store the indicators in a df", "\n", "df_6", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'n_v_lost_mv1'", ":", "[", "n_v_lost_mv1", "]", ",", "\n", "'n_v_lost_mv2'", ":", "[", "n_v_lost_mv2", "]", ",", "\n", "'n_v_lost_mv_1o2'", ":", "[", "n_v_lost_mv_1o2", "]", ",", "\n", "'n_v_lost_mv1_o'", ":", "[", "n_v_lost_mv1_o", "]", ",", "\n", "'n_v_lost_mv2_o'", ":", "[", "n_v_lost_mv2_o", "]", ",", "\n", "'n_v_lost_mv_1a2'", ":", "[", "n_v_lost_mv_1a2", "]", ",", "\n", "'f_v_lost_mv1'", ":", "[", "f_v_lost_mv1", "]", ",", "\n", "'f_v_lost_mv2'", ":", "[", "f_v_lost_mv2", "]", ",", "\n", "'f_v_lost_mv_1o2'", ":", "[", "f_v_lost_mv_1o2", "]", ",", "\n", "'f_v_lost_mv1_o'", ":", "[", "f_v_lost_mv1_o", "]", ",", "\n", "'f_v_lost_mv2_o'", ":", "[", "f_v_lost_mv2_o", "]", ",", "\n", "'f_v_lost_mv_1a2'", ":", "[", "f_v_lost_mv_1a2", "]", ",", "\n", "}", ")", "\n", "\n", "return", "{", "\n", "'global'", ":", "df_1", ",", "\n", "'features'", ":", "df_2", ",", "\n", "'feature-wise'", ":", "df_3", ",", "\n", "'rows'", ":", "df_4", ",", "\n", "'rm_rows'", ":", "df_5", ",", "\n", "'rm_features'", ":", "df_6", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.every_mv_distribution": [[311, 430], ["matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.subplots", "enumerate", "fig.tight_layout", "db_titles2.items", "axes[].set_xlabel", "tqdm.tqdm", "enumerate", "axes[].annotate", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "fig.add_artist", "ax.set_ylabel", "tag.split", "statistics.cached_indicators", "plot_statistics.plot_feature_wise_v2", "db.replace.replace", "task.replace.replace", "task.replace.replace", "ax.set_title", "ax.axis", "dict"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.cached_indicators", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_feature_wise_v2"], ["", "def", "every_mv_distribution", "(", ")", ":", "\n", "    ", "matplotlib", ".", "rcParams", ".", "update", "(", "{", "\n", "'font.size'", ":", "14", ",", "\n", "'axes.titlesize'", ":", "10", ",", "\n", "'axes.labelsize'", ":", "8", ",", "\n", "# 'xtick.labelsize': 13,", "\n", "# 'ytick.labelsize': 13,", "\n", "}", ")", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "6", ",", "3", ",", "figsize", "=", "(", "6", ",", "9", ")", ")", "\n", "\n", "L1", "=", "[", "'TB/death_pvals'", ",", "'TB/hemo'", ",", "'TB/hemo_pvals'", "]", "\n", "L2", "=", "[", "'TB/platelet_pvals'", ",", "'TB/septic_pvals'", ",", "None", "]", "\n", "# L2 = [None, None, None]", "\n", "# L3 = [None, None, None]", "\n", "# L4 = [None, None, None]", "\n", "# L5 = [None, None, None]", "\n", "# L6 = [None, None, None]", "\n", "L3", "=", "[", "'UKBB/breast_25'", ",", "'UKBB/breast_pvals'", ",", "'UKBB/fluid_pvals'", "]", "\n", "L4", "=", "[", "'UKBB/parkinson_pvals'", ",", "'UKBB/skin_pvals'", ",", "None", "]", "\n", "L5", "=", "[", "'MIMIC/hemo_pvals'", ",", "'MIMIC/septic_pvals'", ",", "None", "]", "\n", "L6", "=", "[", "'NHIS/income_pvals'", ",", "None", ",", "None", "]", "\n", "\n", "L", "=", "[", "L1", ",", "L2", ",", "L3", ",", "L4", ",", "L5", ",", "L6", "]", "\n", "\n", "colors", "=", "{", "\n", "'TB'", ":", "'tab:blue'", ",", "\n", "'UKBB'", ":", "'tab:orange'", ",", "\n", "'MIMIC'", ":", "'tab:green'", ",", "\n", "'NHIS'", ":", "'tab:red'", ",", "\n", "# 'TB': 'blue',", "\n", "# 'UKBB': 'orange',", "\n", "# 'MIMIC': 'green',", "\n", "# 'NHIS': 'red',", "\n", "}", "\n", "\n", "handles_dict", "=", "{", "}", "\n", "\n", "for", "i", ",", "row", "in", "enumerate", "(", "tqdm", "(", "L", ")", ")", ":", "\n", "        ", "for", "j", ",", "tag", "in", "enumerate", "(", "row", ")", ":", "\n", "            ", "ax", "=", "axes", "[", "i", "]", "[", "j", "]", "\n", "\n", "if", "tag", "is", "None", ":", "\n", "                ", "ax", ".", "axis", "(", "'off'", ")", "\n", "continue", "\n", "\n", "", "db", ",", "task", "=", "tag", ".", "split", "(", "'/'", ")", "\n", "indicators", "=", "cached_indicators", "(", "tag", ",", "encode_features", "=", "False", ")", "\n", "_", ",", "_", ",", "handles", "=", "plot_feature_wise_v2", "(", "indicators", ",", "ax", "=", "ax", ",", "plot", "=", "True", ",", "color", "=", "colors", "[", "db", "]", ")", "\n", "\n", "db", "=", "db", ".", "replace", "(", "'TB'", ",", "'Traumabase'", ")", "\n", "handles_dict", "[", "db", "]", "=", "handles", "[", "1", "]", "\n", "\n", "task", "=", "task", ".", "replace", "(", "'_'", ",", "'\\\\_'", ")", "\n", "task", "=", "task", ".", "replace", "(", "'pvals'", ",", "'screening'", ")", "\n", "ax", ".", "set_title", "(", "task", ")", "\n", "\n", "# axes[-1, -1].legend(handles_dict.values(), handles_dict.keys(),", "\n", "#     fancybox=True, shadow=True, loc='center', title='Missing values')", "\n", "# p_dummy, = plt.plot([0], marker='None', linestyle='None', label='dummy-tophead')", "\n", "# handles_dict[''] = handles[0]", "\n", "# handles = [p_dummy]*5+list(handles_dict.values())", "\n", "# labels = ['Missing'] + ['']*3 + ['Not missing'] + list(handles_dict.keys())", "\n", "# axes[-1, -1].legend(handles, labels, ncol=2,", "\n", "# fancybox=True, shadow=True, loc='center',)", "\n", "\n", "", "", "fig", ".", "tight_layout", "(", ")", "\n", "\n", "db_titles", "=", "{", "\n", "0", ":", "'Traumabase'", ",", "\n", "2", ":", "'UKBB'", ",", "\n", "4", ":", "'MIMIC'", ",", "\n", "5", ":", "'NHIS'", ",", "\n", "}", "\n", "\n", "db_titles2", "=", "{", "\n", "1", ":", "'Traumabase'", ",", "\n", "3", ":", "'UKBB'", ",", "\n", "4", ":", "'MIMIC'", ",", "\n", "5", ":", "'NHIS'", ",", "\n", "}", "\n", "\n", "ax", "=", "axes", "[", "0", "]", "\n", "fs", "=", "14", "\n", "lw", "=", "1.3", "\n", "dh", "=", "1.", "/", "9", "\n", "l_tail", "=", "0.03", "\n", "pos_arrow", "=", "-", "0.45", "\n", "\n", "for", "i", ",", "db", "in", "db_titles2", ".", "items", "(", ")", ":", "\n", "# Here is the label and arrow code of interest", "\n", "# axes[i, 0].annotate(db, xy=(-0.4, 0.5), xycoords='axes fraction',", "\n", "#             fontsize=fs, ha='center', va='center',", "\n", "#             bbox=None,#dict(boxstyle='square', fc='white'),", "\n", "#             # arrowprops=dict(arrowstyle=f'-[, widthB={70/fs}, lengthB=0.5', lw=lw),", "\n", "#             rotation=90,", "\n", "#             )", "\n", "        ", "axes", "[", "i", ",", "-", "1", "]", ".", "annotate", "(", "db", ",", "xy", "=", "(", "0.5", ",", "0.5", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "dict", "(", "boxstyle", "=", "'square'", ",", "fc", "=", "'white'", ")", ",", "\n", "# arrowprops=dict(arrowstyle=f'-[, widthB={70/fs}, lengthB=0.5', lw=lw),", "\n", "rotation", "=", "0", ",", "\n", ")", "\n", "\n", "# x, y = np.array([[0, 1], ])", "\n", "", "dh", "=", "1.", "/", "6", "\n", "# for i in range(0,7):", "\n", "for", "i", "in", "[", "1.05", ",", "2.02", ",", "3.96", "]", ":", "\n", "        ", "y", "=", "i", "*", "dh", "\n", "line", "=", "matplotlib", ".", "lines", ".", "Line2D", "(", "[", "0", ",", "1", "]", ",", "[", "y", ",", "y", "]", ",", "lw", "=", "1", ",", "ls", "=", "'-'", ",", "color", "=", "'silver'", ",", "\n", "alpha", "=", "1", ",", "transform", "=", "fig", ".", "transFigure", ")", "\n", "# axes[1, 0].add_line(line)", "\n", "fig", ".", "add_artist", "(", "line", ")", "\n", "\n", "", "axes", "[", "-", "1", ",", "0", "]", ".", "set_xlabel", "(", "'Features'", ")", "\n", "for", "ax", "in", "axes", "[", ":", ",", "0", "]", ":", "\n", "        ", "ax", ".", "set_ylabel", "(", "'Proportion'", ")", "\n", "# axes[-1, 0].set_ylabel('Proportion')", "\n", "\n", "", "return", "fig", ",", "axes", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.cached_indicators": [[432, 444], ["statistics.get_indicators_mv"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.get_indicators_mv"], ["", "@", "memory", ".", "cache", "\n", "def", "cached_indicators", "(", "task_tag", ",", "encode_features", "=", "False", ")", ":", "\n", "    ", "task", "=", "tasks", "[", "task_tag", "]", "\n", "\n", "if", "not", "encode_features", "and", "'pvals'", "in", "task_tag", ":", "\n", "        ", "task", ".", "meta", ".", "encode_select", "=", "None", "\n", "task", ".", "meta", ".", "encode_transform", "=", "None", "\n", "\n", "", "mv", "=", "task", ".", "mv", "\n", "indicators", "=", "get_indicators_mv", "(", "mv", ")", "\n", "\n", "return", "indicators", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_mv": [[446, 488], ["statistics.cached_indicators", "custom.const.get_fig_folder", "os.makedirs", "matplotlib.savefig", "matplotlib.tight_layout", "matplotlib.show", "statistics.every_mv_distribution", "custom.const.get_fig_folder", "matplotlib.savefig", "matplotlib.tight_layout", "any", "plot_statistics.figure1", "plot_statistics.figure2", "plot_statistics.figure2bis", "plot_statistics.figure3", "os.path.join", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.cached_indicators", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.every_mv_distribution", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.figure1", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.figure2", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.figure2bis", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.figure3"], ["", "def", "run_mv", "(", "args", ",", "graphics_folder", ")", ":", "\n", "    ", "\"\"\"Show some statistics on the given df.\"\"\"", "\n", "if", "args", ".", "tag", "is", "None", ":", "\n", "        ", "every_mv_distribution", "(", ")", "\n", "\n", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "fig_name", "=", "'mv_distribution'", "\n", "\n", "plt", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "return", "\n", "\n", "", "task_tag", "=", "args", ".", "tag", "\n", "plot", "=", "not", "args", ".", "hide", "\n", "\n", "indicators", "=", "cached_indicators", "(", "task_tag", ")", "\n", "\n", "task", "=", "tasks", "[", "task_tag", "]", "\n", "db_name", "=", "task", ".", "meta", ".", "db", "\n", "df_name", "=", "task_tag", "\n", "fig1", ",", "fig2", ",", "fig2b", ",", "fig3", "=", "args", ".", "fig1", ",", "args", ".", "fig2", ",", "args", ".", "fig2b", ",", "args", ".", "fig3", "\n", "\n", "if", "not", "any", "(", "(", "fig1", ",", "fig2", ",", "fig2b", ",", "fig3", ")", ")", ":", "\n", "        ", "fig1", ",", "fig2", ",", "fig2b", ",", "fig3", "=", "True", ",", "True", ",", "True", ",", "True", "\n", "\n", "# Plot all the indicators", "\n", "", "if", "fig1", ":", "\n", "        ", "figure1", "(", "indicators", ",", "plot", "=", "plot", ",", "db_name", "=", "db_name", ",", "table", "=", "df_name", ")", "\n", "", "if", "fig2", ":", "\n", "        ", "figure2", "(", "indicators", ",", "plot", "=", "plot", ",", "db_name", "=", "db_name", ",", "table", "=", "df_name", ")", "\n", "", "if", "fig2b", ":", "\n", "        ", "figure2bis", "(", "indicators", ",", "plot", "=", "plot", ",", "db_name", "=", "db_name", ",", "table", "=", "df_name", ")", "\n", "", "if", "fig3", ":", "\n", "        ", "figure3", "(", "indicators", ",", "plot", "=", "plot", ",", "db_name", "=", "db_name", ",", "table", "=", "df_name", ")", "\n", "\n", "", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "\n", "os", ".", "makedirs", "(", "join", "(", "fig_folder", ",", "db_name", ")", ",", "exist_ok", "=", "True", ")", "\n", "plt", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{df_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.cached_types": [[490, 528], ["prediction.tasks.tasks.get", "database._load_feature_types", "list", "list.sort", "list", "database._load_feature_types.index.astype", "pd.Series.index.astype", "set", "set", "len", "pd.Series.update", "set", "pandas.Series", "print", "print", "f.split", "pandas.Series", "pandas.Series", "database.constants.is_categorical", "database.constants.is_ordinal", "database.constants.is_continuous", "database.constants.is_categorical", "database.constants.is_ordinal", "database.constants.is_continue"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_feature_types", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_categorical", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_ordinal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_continuous", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_categorical", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_ordinal", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_continue"], ["", "@", "memory", ".", "cache", "\n", "def", "cached_types", "(", "task_tag", ",", "encode_features", "=", "False", ",", "T", "=", "0", ")", ":", "\n", "    ", "task", "=", "tasks", ".", "get", "(", "task_tag", ",", "T", "=", "T", ")", "\n", "db_name", "=", "task", ".", "meta", ".", "db", "\n", "db", "=", "dbs", "[", "db_name", "]", "\n", "df_name", "=", "task", ".", "meta", ".", "df_name", "\n", "\n", "# Load types of all inital features of the database", "\n", "db_types", "=", "_load_feature_types", "(", "db", ",", "df_name", ",", "anonymized", "=", "False", ")", "\n", "\n", "L", "=", "list", "(", "task", ".", "X", ".", "columns", ")", "\n", "L", ".", "sort", "(", ")", "\n", "\n", "L", "=", "[", "f", ".", "split", "(", "'_'", ")", "[", "0", "]", "for", "f", "in", "L", "]", "\n", "L", "=", "list", "(", "set", "(", "L", ")", ")", "\n", "\n", "if", "db_name", "==", "'TB'", ":", "\n", "        ", "task_types", "=", "pd", ".", "Series", "(", "CONTINUE_R", ",", "index", "=", "L", ")", "\n", "", "elif", "db_name", "==", "'UKBB'", ":", "\n", "        ", "task_types", "=", "pd", ".", "Series", "(", "BINARY", ",", "index", "=", "L", ")", "\n", "", "else", ":", "\n", "        ", "task_types", "=", "pd", ".", "Series", "(", "CATEGORICAL", ",", "index", "=", "L", ")", "\n", "\n", "# Cast both index to str", "\n", "", "db_types", ".", "index", "=", "db_types", ".", "index", ".", "astype", "(", "str", ")", "\n", "task_types", ".", "index", "=", "task_types", ".", "index", ".", "astype", "(", "str", ")", "\n", "\n", "task_cols", "=", "set", "(", "task_types", ".", "index", ")", "\n", "db_cols", "=", "set", "(", "db_types", ".", "index", ")", "\n", "missing_cols", "=", "task_cols", "-", "db_cols", "\n", "m", "=", "len", "(", "missing_cols", ")", "\n", "if", "m", ">", "0", ":", "\n", "        ", "print", "(", "f'{m} features not found in DB features:\\n{missing_cols}'", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "'All features found in DB features'", ")", "\n", "", "task_types", ".", "update", "(", "db_types", ")", "\n", "\n", "return", "task_types", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.get_prop": [[530, 546], ["statistics.cached_types", "cached_types.map", "cached_types.map", "cached_types.map", "task_types.map.sum", "task_types.map.sum", "task_types.map.sum", "print", "len"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.cached_types"], ["", "def", "get_prop", "(", "task_tag", ",", "encode_features", "=", "False", ",", "T", "=", "0", ")", ":", "\n", "    ", "task_types", "=", "cached_types", "(", "task_tag", ",", "encode_features", ",", "T", "=", "T", ")", "\n", "\n", "f_categorical", "=", "task_types", ".", "map", "(", "is_categorical", ")", "\n", "f_ordinal", "=", "task_types", ".", "map", "(", "is_ordinal", ")", "\n", "f_continuous", "=", "task_types", ".", "map", "(", "is_continuous", ")", "\n", "\n", "n_categorical", "=", "f_categorical", ".", "sum", "(", ")", "\n", "n_ordinal", "=", "f_ordinal", ".", "sum", "(", ")", "\n", "n_continuous", "=", "f_continuous", ".", "sum", "(", ")", "\n", "\n", "print", "(", "n_categorical", ",", "n_ordinal", ",", "n_continuous", ")", "\n", "\n", "assert", "n_categorical", "+", "n_ordinal", "+", "n_continuous", "==", "len", "(", "task_types", ")", "\n", "\n", "return", "n_categorical", ",", "n_ordinal", ",", "n_continuous", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_prop": [[548, 581], ["pandas.DataFrame", "props[].str.cat", "props.drop.set_index", "tests.tasks_to_drop.items", "props.drop.reset_index", "props.drop.set_index", "print", "plot_statistics.plot_feature_types", "custom.const.get_fig_folder", "matplotlib.savefig", "matplotlib.tight_layout", "print", "task_tag.split", "props.drop.drop", "os.path.join", "list", "statistics.get_prop", "rows.append", "range", "db_rename.get"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_feature_types", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.get_prop", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], ["", "def", "run_prop", "(", "args", ",", "graphics_folder", ")", ":", "\n", "\n", "    ", "rows", "=", "[", "]", "\n", "for", "task_tag", "in", "task_tags", ":", "\n", "        ", "Ts", "=", "list", "(", "range", "(", "5", ")", ")", "if", "'pvals'", "in", "task_tag", "else", "[", "0", "]", "\n", "print", "(", "task_tag", ")", "\n", "\n", "db", ",", "task", "=", "task_tag", ".", "split", "(", "'/'", ")", "\n", "\n", "for", "T", "in", "Ts", ":", "\n", "            ", "n_categorical", ",", "n_ordinal", ",", "n_continuous", "=", "get_prop", "(", "task_tag", ",", "T", "=", "T", ")", "\n", "rows", ".", "append", "(", "[", "db_rename", ".", "get", "(", "db", ",", "db", ")", ",", "task", ",", "T", ",", "n_categorical", ",", "n_ordinal", ",", "n_continuous", "]", ")", "\n", "\n", "", "", "props", "=", "pd", ".", "DataFrame", "(", "rows", ",", "columns", "=", "[", "'db'", ",", "'task'", ",", "'T'", ",", "'categorical'", ",", "'ordinal'", ",", "'continuous'", "]", ")", "\n", "props", "[", "'tag'", "]", "=", "props", "[", "'db'", "]", ".", "str", ".", "cat", "(", "'/'", "+", "props", "[", "'task'", "]", ")", "\n", "props", "[", "'n'", "]", "=", "props", "[", "'categorical'", "]", "+", "props", "[", "'ordinal'", "]", "+", "props", "[", "'continuous'", "]", "\n", "\n", "# Drop tasks", "\n", "props", "=", "props", ".", "set_index", "(", "[", "'db'", ",", "'task'", "]", ")", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "props", "=", "props", ".", "drop", "(", "(", "db", ",", "task", ")", ",", "axis", "=", "0", ",", "errors", "=", "'ignore'", ")", "\n", "", "props", "=", "props", ".", "reset_index", "(", ")", "\n", "\n", "props", ".", "set_index", "(", "[", "'db'", ",", "'task'", ",", "'T'", "]", ",", "inplace", "=", "True", ")", "\n", "print", "(", "props", ")", "\n", "\n", "plot_feature_types", "(", "props", ")", "\n", "\n", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "fig_name", "=", "'proportion'", "\n", "\n", "plt", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "tight_layout", "(", "pad", "=", "0.3", ")", "\n", "# plt.show()", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.compute_correlation": [[584, 627], ["numpy.array", "numpy.zeros", "range", "isinstance", "numpy.ones", "range", "pandas.DataFrame", "numpy.sum", "print", "numpy.isnan", "numpy.isnan", "numpy.corrcoef"], "function", ["None"], ["", "def", "compute_correlation", "(", "_X", ")", ":", "\n", "    ", "\"\"\"Compute the pairwise correlation from observations of a feature vector.\n\n    Similar to numpy.corrcoef except that it ignores missing observations in X.\n\n    Parameters\n    ----------\n    X : np.array of shape (k, n)\n        Matrix containing the n observations of the k features\n\n    Returns\n    -------\n    R : np.array of shape (k, k)\n        Pairwise correlation coefficients\n    N : np.array of shape (k, k)\n        Number of values taken for correlation computation of pair of features\n        Number of values taken for correlation computation of pair of features\n\n    \"\"\"", "\n", "X", "=", "np", ".", "array", "(", "_X", ")", "\n", "k", ",", "n", "=", "X", ".", "shape", "\n", "R", "=", "np", ".", "nan", "*", "np", ".", "ones", "(", "(", "k", ",", "k", ")", ")", "\n", "N", "=", "np", ".", "zeros", "(", "(", "k", ",", "k", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "k", ")", ":", "\n", "            ", "x1", "=", "X", "[", "i", ",", ":", "]", "\n", "x2", "=", "X", "[", "j", ",", ":", "]", "\n", "\n", "# Select index for which no missing values are in x1 nor x2", "\n", "idx", "=", "~", "np", ".", "isnan", "(", "x1", ")", "&", "~", "np", ".", "isnan", "(", "x2", ")", "\n", "n_values", "=", "np", ".", "sum", "(", "idx", ")", "\n", "if", "n_values", "<", "100", ":", "\n", "                ", "print", "(", "f'Warning: only {n_values} values taken for correlation.'", ")", "\n", "\n", "", "R", "[", "i", ",", "j", "]", "=", "np", ".", "nan", "if", "n_values", "<", "3", "else", "np", ".", "corrcoef", "(", "[", "x1", "[", "idx", "]", ",", "x2", "[", "idx", "]", "]", ")", "[", "0", ",", "1", "]", "\n", "N", "[", "i", ",", "j", "]", "=", "n_values", "\n", "\n", "", "", "if", "isinstance", "(", "_X", ",", "pd", ".", "DataFrame", ")", ":", "\n", "        ", "features", "=", "_X", ".", "index", "\n", "R", "=", "pd", ".", "DataFrame", "(", "R", ",", "index", "=", "features", ",", "columns", "=", "features", ")", "\n", "\n", "", "return", "R", ",", "N", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.cached_task_correlation": [[629, 653], ["prediction.tasks.tasks.get", "statistics.cached_types", "cached_types.map", "cached_types.map", "cached_types.map", "statistics.compute_correlation"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.cached_types", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.compute_correlation"], ["", "@", "memory", ".", "cache", "\n", "def", "cached_task_correlation", "(", "task_tag", ",", "encode_features", "=", "False", ",", "T", "=", "0", ")", ":", "\n", "    ", "task", "=", "tasks", ".", "get", "(", "task_tag", ",", "T", "=", "T", ")", "\n", "db_name", "=", "task", ".", "meta", ".", "db", "\n", "db", "=", "dbs", "[", "db_name", "]", "\n", "df_name", "=", "task", ".", "meta", ".", "df_name", "\n", "\n", "task_types", "=", "cached_types", "(", "task_tag", ",", "encode_features", "=", "encode_features", ",", "T", "=", "T", ")", "\n", "\n", "\n", "f_categorical", "=", "task_types", ".", "map", "(", "is_categorical", ")", "\n", "f_ordinal", "=", "task_types", ".", "map", "(", "is_ordinal", ")", "\n", "f_continue", "=", "task_types", ".", "map", "(", "is_continue", ")", "\n", "\n", "\n", "f_selected", "=", "f_ordinal", "|", "f_continue", "\n", "f_selected", "=", "f_selected", "[", "f_selected", "]", "\n", "\n", "X_selected", "=", "task", ".", "X", "[", "f_selected", "[", "f_selected", "]", ".", "index", "]", "\n", "\n", "R", ",", "N", "=", "compute_correlation", "(", "X_selected", ".", "T", ")", "\n", "\n", "\n", "return", "R", ",", "N", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_cor": [[655, 744], ["pandas.DataFrame", "df_cor.reindex.groupby().agg", "df_cor.reindex.pivot", "df_cor.reindex.groupby", "df_cor.reindex.agg", "df_cor.reindex.mean", "pandas.MultiIndex.from_tuples", "pandas.concat", "float", "df_cor[].applymap", "df_cor[].applymap", "df_cor.groupby().agg.applymap", "df_cor.reindex.set_index", "df_cor.reindex.reindex", "df_cor.reindex.rename", "df_cor.reindex.index.rename", "df_cor.reindex.index.set_levels", "df_cor.reindex.index.set_levels", "enumerate", "df_cor.reindex.rename", "custom.const.get_tab_folder", "print", "df_cor.reindex.to_latex", "print", "task_tag.split", "pandas.DataFrame", "df_cor.groupby().agg.mean", "db_rename.get", "df_cor.reindex.index.levels[].str.replace", "df_cor.reindex.index.levels[].str.replace", "df_cor.reindex.drop", "df_cor.reindex.rename", "df_cor.reindex.columns.rename", "df_cor.reindex.columns.rename", "df_cor.reindex.rename", "pandas.unique", "os.path.join", "df_cor.reindex.to_csv", "list", "statistics.cached_task_correlation", "df_cor.reindex.groupby", "str", "df_cor.reindex.index.get_level_values", "os.path.join", "range", "N.mean", "rows.append", "int", "R.abs.abs", "int", "db_rename.get"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.cached_task_correlation", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], ["", "def", "run_cor", "(", "args", ",", "graphics_folder", ",", "absolute", "=", "False", ",", "csv", "=", "False", ",", "prop_only", "=", "True", ")", ":", "\n", "    ", "thresholds", "=", "[", "0.1", ",", "0.2", ",", "0.3", "]", "\n", "\n", "rows", "=", "[", "]", "\n", "for", "task_tag", "in", "task_tags", ":", "\n", "        ", "Ts", "=", "list", "(", "range", "(", "5", ")", ")", "if", "'pvals'", "in", "task_tag", "else", "[", "0", "]", "\n", "print", "(", "task_tag", ")", "\n", "\n", "db", ",", "task", "=", "task_tag", ".", "split", "(", "'/'", ")", "\n", "\n", "for", "T", "in", "Ts", ":", "\n", "            ", "R", ",", "_", "=", "cached_task_correlation", "(", "task_tag", ",", "T", "=", "T", ")", "\n", "for", "threshold", "in", "thresholds", ":", "\n", "                ", "if", "absolute", ":", "\n", "                    ", "R", "=", "R", ".", "abs", "(", ")", "\n", "", "N", "=", "(", "R", ">", "threshold", ")", ".", "sum", "(", "axis", "=", "1", ")", "\n", "N_mean", "=", "N", ".", "mean", "(", ")", "\n", "k", "=", "R", ".", "shape", "[", "0", "]", "\n", "rows", ".", "append", "(", "[", "db_rename", ".", "get", "(", "db", ",", "db", ")", ",", "task", ",", "T", ",", "threshold", ",", "k", ",", "N_mean", ",", "N_mean", "/", "k", "]", ")", "\n", "\n", "", "", "", "df_cor", "=", "pd", ".", "DataFrame", "(", "rows", ",", "columns", "=", "[", "'db'", ",", "'task'", ",", "'T'", ",", "'threshold'", ",", "'n_selected'", ",", "'N_mean'", ",", "'prop'", "]", ")", "\n", "df_n_selected", "=", "df_cor", ".", "groupby", "(", "[", "'db'", ",", "'task'", "]", ")", ".", "agg", "(", "{", "'n_selected'", ":", "'mean'", "}", ")", "\n", "df_cor", "=", "df_cor", ".", "pivot", "(", "index", "=", "[", "'db'", ",", "'task'", ",", "'T'", "]", ",", "columns", "=", "'threshold'", ",", "values", "=", "[", "'N_mean'", ",", "'prop'", "]", ")", "\n", "df_cor", "=", "df_cor", ".", "groupby", "(", "[", "'db'", ",", "'task'", "]", ")", "\n", "df_cor", "=", "df_cor", ".", "agg", "(", "'mean'", ")", "\n", "\n", "df_cor_mean", "=", "df_cor", ".", "mean", "(", ")", "\n", "df_cor_mean", "=", "pd", ".", "DataFrame", "(", "df_cor_mean", ")", ".", "T", "\n", "df_cor_mean", ".", "index", "=", "pd", ".", "MultiIndex", ".", "from_tuples", "(", "[", "(", "'Average'", ",", "''", ")", "]", ")", "\n", "df_cor", "=", "pd", ".", "concat", "(", "[", "df_cor", ",", "df_cor_mean", "]", ",", "axis", "=", "0", ")", "\n", "df_n_selected", ".", "loc", "[", "(", "'Average'", ",", "''", ")", ",", "'n_selected'", "]", "=", "float", "(", "df_n_selected", ".", "mean", "(", ")", ")", "\n", "\n", "def", "to_int", "(", "x", ")", ":", "# Convert to int and robust to NaN", "\n", "        ", "try", ":", "\n", "            ", "return", "str", "(", "int", "(", "x", ")", ")", "\n", "", "except", ":", "\n", "            ", "return", "x", "\n", "\n", "", "", "def", "to_percent", "(", "x", ")", ":", "# Convert to int and robust to NaN", "\n", "        ", "try", ":", "\n", "            ", "return", "f'{int(100*x)}\\\\%'", "\n", "", "except", ":", "\n", "            ", "return", "x", "\n", "\n", "", "", "df_cor", "[", "'N_mean'", "]", "=", "df_cor", "[", "'N_mean'", "]", ".", "applymap", "(", "to_int", ")", "\n", "df_cor", "[", "'prop'", "]", "=", "df_cor", "[", "'prop'", "]", ".", "applymap", "(", "to_percent", ")", "\n", "df_cor", "[", "'n_selected'", "]", "=", "df_n_selected", ".", "applymap", "(", "to_int", ")", "\n", "df_cor", ".", "set_index", "(", "'n_selected'", ",", "append", "=", "True", ",", "inplace", "=", "True", ")", "\n", "\n", "db_order_renamed", "=", "[", "db_rename", ".", "get", "(", "db", ",", "db", ")", "for", "db", "in", "db_order", "]", "\n", "df_cor", "=", "df_cor", ".", "reindex", "(", "db_order_renamed", "+", "[", "'Average'", "]", ",", "level", "=", "0", ",", "axis", "=", "0", ")", "\n", "\n", "# Rotate Traumabase", "\n", "df_cor", ".", "rename", "(", "{", "'Traumabase'", ":", "'\\\\rotsmash{Traumabase}'", "}", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "# Processing for dumping", "\n", "df_cor", ".", "index", ".", "rename", "(", "[", "'Database'", ",", "'Task'", ",", "'\\\\# features'", "]", ",", "inplace", "=", "True", ")", "\n", "df_cor", ".", "index", "=", "df_cor", ".", "index", ".", "set_levels", "(", "df_cor", ".", "index", ".", "levels", "[", "1", "]", ".", "str", ".", "replace", "(", "'pvals'", ",", "'screening'", ")", ",", "level", "=", "1", ")", "\n", "df_cor", ".", "index", "=", "df_cor", ".", "index", ".", "set_levels", "(", "df_cor", ".", "index", ".", "levels", "[", "1", "]", ".", "str", ".", "replace", "(", "'_'", ",", "r'\\_'", ")", ",", "level", "=", "1", ")", "\n", "\n", "if", "prop_only", ":", "\n", "        ", "df_cor", ".", "drop", "(", "[", "'N_mean'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "df_cor", ".", "rename", "(", "{", "'prop'", ":", "'Threshold'", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "df_cor", ".", "columns", ".", "rename", "(", "[", "''", ",", "''", "]", ",", "inplace", "=", "True", ")", "\n", "\n", "", "else", ":", "\n", "        ", "df_cor", ".", "columns", ".", "rename", "(", "[", "''", ",", "'Threshold'", "]", ",", "inplace", "=", "True", ")", "\n", "df_cor", ".", "rename", "(", "{", "'N_mean'", ":", "r'$\\bar{n}$'", ",", "'prop'", ":", "r'$\\bar{p}$'", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "", "smallskip", "=", "'0.15in'", "\n", "bigskip", "=", "'0.2in'", "\n", "index_rename", "=", "{", "}", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "pd", ".", "unique", "(", "df_cor", ".", "index", ".", "get_level_values", "(", "0", ")", ")", ")", ":", "\n", "        ", "if", "i", "==", "0", ":", "\n", "            ", "continue", "\n", "", "skip", "=", "bigskip", "if", "v", "==", "'Average'", "else", "smallskip", "\n", "index_rename", "[", "v", "]", "=", "f'\\\\rule{{0pt}}{{{skip}}}{v}'", "\n", "\n", "", "df_cor", ".", "rename", "(", "index_rename", ",", "axis", "=", "0", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "tab_folder", "=", "get_tab_folder", "(", "graphics_folder", ")", "\n", "tab_name", "=", "'correlation_abs'", "if", "absolute", "else", "'correlation'", "\n", "\n", "print", "(", "df_cor", ")", "\n", "\n", "df_cor", ".", "to_latex", "(", "join", "(", "tab_folder", ",", "f'{tab_name}.tex'", ")", ",", "na_rep", "=", "''", ",", "escape", "=", "False", ")", "\n", "\n", "if", "csv", ":", "\n", "        ", "df_cor", ".", "to_csv", "(", "join", "(", "tab_folder", ",", "f'{tab_name}.csv'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_time": [[746, 798], ["pandas.concat", "tests.tasks_to_drop.items", "df[].str.replace", "df[].sum", "df[].sum", "print", "df.query.query", "df[].sum", "df[].sum", "print", "pandas.read_csv", "df.query.drop", "df[].fillna", "df[].fillna", "df[].fillna", "df[].fillna", "int", "int", "int", "int"], "function", ["None"], ["", "", "def", "run_time", "(", ")", ":", "\n", "# path = os.path.abspath('scores/scores.csv')", "\n", "# df = pd.read_csv(path, index_col=0)", "\n", "# filepaths = [", "\n", "#     'scores/scores.csv',", "\n", "#     'scores/scores_mi_2500.csv',", "\n", "#     'scores/scores_mi_10000.csv',", "\n", "#     'scores/scores_mi_25000.csv',", "\n", "#     'scores/scores_mi_100000.csv',", "\n", "#     'scores/scores_mia_2500.csv',", "\n", "#     'scores/scores_mia_10000.csv',", "\n", "#     'scores/scores_mia_25000.csv',", "\n", "#     'scores/scores_mia_100000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_2500.csv',", "\n", "#     'scores/scores_mean+mask+bagging_10000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_25000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_100000.csv',", "\n", "# ]", "\n", "    ", "dfs", "=", "[", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "for", "path", "in", "filepaths", "]", "\n", "df", "=", "pd", ".", "concat", "(", "dfs", ",", "axis", "=", "0", ")", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "df", ".", "drop", "(", "index", "=", "df", "[", "(", "df", "[", "'db'", "]", "==", "db", ")", "&", "(", "df", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "df", "[", "'task'", "]", "=", "df", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "# Sum times", "\n", "df", "[", "'total_PT'", "]", "=", "df", "[", "'imputation_PT'", "]", ".", "fillna", "(", "0", ")", "+", "df", "[", "'tuning_PT'", "]", "\n", "df", "[", "'total_WCT'", "]", "=", "df", "[", "'imputation_WCT'", "]", ".", "fillna", "(", "0", ")", "+", "df", "[", "'tuning_WCT'", "]", "\n", "\n", "total_pt", "=", "df", "[", "'total_PT'", "]", ".", "sum", "(", ")", "\n", "total_wct", "=", "df", "[", "'total_WCT'", "]", ".", "sum", "(", ")", "\n", "\n", "print", "(", "\n", "f'Total training time:\\n'", "\n", "f'\\tCPU time: {int(total_pt/3600)} hours\\n'", "\n", "f'\\tWall-clock time: {int(total_wct/3600)} hours'", "\n", ")", "\n", "method", "=", "'MIA'", "\n", "\n", "df", "=", "df", ".", "query", "(", "'method == @method'", ")", "\n", "\n", "# Sum times", "\n", "df", "[", "'total_PT'", "]", "=", "df", "[", "'imputation_PT'", "]", ".", "fillna", "(", "0", ")", "+", "df", "[", "'tuning_PT'", "]", "\n", "df", "[", "'total_WCT'", "]", "=", "df", "[", "'imputation_WCT'", "]", ".", "fillna", "(", "0", ")", "+", "df", "[", "'tuning_WCT'", "]", "\n", "\n", "total_pt", "=", "df", "[", "'total_PT'", "]", ".", "sum", "(", ")", "\n", "total_wct", "=", "df", "[", "'total_WCT'", "]", ".", "sum", "(", ")", "\n", "\n", "print", "(", "\n", "f'{method} training time:\\n'", "\n", "f'\\tCPU time: {int(total_pt/3600)} hours\\n'", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_score_check": [[803, 812], ["pandas.read_csv", "pd.read_csv.groupby", "print", "len", "print"], "function", ["None"], ["", "def", "run_score_check", "(", ")", ":", "\n", "     ", "for", "path", "in", "filepaths", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "\n", "# print(df)", "\n", "\n", "dfgb", "=", "df", ".", "groupby", "(", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "print", "(", "f'\\n{path}'", ",", "len", "(", "dfgb", ")", ")", "\n", "for", "index", ",", "subdf", "in", "dfgb", ":", "\n", "            ", "print", "(", "index", ",", "subdf", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.difficulty.run_difficulty": [[19, 166], ["pandas.concat", "tasks_to_drop.items", "scores[].str.replace", "prediction.df_utils.aggregate.query", "prediction.df_utils.get_ranks_tab", "pandas.melt", "melted_ranks.astype.reset_index", "melted_ranks.astype.set_index", "prediction.df_utils.aggregate", "prediction.df_utils.aggregate.rename", "prediction.df_utils.aggregate.set_index", "melted_ranks.astype.astype", "melted_ranks.astype.dropna", "prediction.df_utils.aggregate.reset_index", "prediction.df_utils.aggregate.query", "prediction.df_utils.aggregate.query", "matplotlib.figure", "matplotlib.gca", "seaborn.color_palette().as_hex", "seaborn.color_palette", "seaborn.set_palette", "seaborn.scatterplot", "itertools.cycle", "scores.query.groupby", "plt.gca.legend", "plt.gca.set_xlabel", "plt.gca.invert_yaxis", "plt.gca.get_legend_handles_labels", "plt.gca.legend", "matplotlib.tight_layout", "matplotlib.figure", "matplotlib.gca", "seaborn.scatterplot", "itertools.cycle", "scores.query.groupby", "plt.gca.legend", "plt.gca.set_xlabel", "plt.gca.invert_yaxis", "plt.gca.get_legend_handles_labels", "plt.gca.legend", "matplotlib.tight_layout", "custom.const.get_fig_folder", "plt.figure.savefig", "plt.figure.savefig", "plt.figure.savefig", "plt.figure.savefig", "pandas.read_csv", "prediction.df_utils.aggregate.drop", "prediction.df_utils.aggregate.groupby", "seaborn.color_palette().as_hex", "seaborn.color_palette", "statsmodels.nonparametric.lowess", "plt.gca.plot", "rename.get", "seaborn.color_palette", "statsmodels.nonparametric.lowess", "plt.gca.plot", "rename.get", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "group[].mean", "prediction.df_utils.aggregate.update", "seaborn.color_palette", "seaborn.color_palette", "next", "next"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_ranks_tab", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], ["def", "run_difficulty", "(", "graphics_folder", ",", "averaged_scores", "=", "True", ")", ":", "\n", "# filepath = 'scores/scores.csv'", "\n", "# scores = pd.read_csv(filepath, index_col=0)", "\n", "    ", "filepaths", "=", "[", "\n", "'scores/scores.csv'", ",", "\n", "'scores/scores_mi_2500.csv'", ",", "\n", "'scores/scores_mia_2500.csv'", ",", "\n", "'scores/scores_mi_10000.csv'", ",", "\n", "'scores/scores_mia_10000.csv'", ",", "\n", "'scores/scores_mia_25000.csv'", ",", "\n", "'scores/scores_mi_25000.csv'", ",", "\n", "'scores/scores_mia_100000.csv'", ",", "\n", "]", "\n", "dfs", "=", "[", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "for", "path", "in", "filepaths", "]", "\n", "scores", "=", "pd", ".", "concat", "(", "dfs", ",", "axis", "=", "0", ")", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "scores", ".", "drop", "(", "index", "=", "scores", "[", "(", "scores", "[", "'db'", "]", "==", "db", ")", "&", "(", "scores", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "scores", "[", "'task'", "]", "=", "scores", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "method_order", "=", "[", "\n", "'MIA'", ",", "\n", "'Mean'", ",", "\n", "'Mean+mask'", ",", "\n", "'Med'", ",", "\n", "'Med+mask'", ",", "\n", "'Iter'", ",", "\n", "'Iter+mask'", ",", "\n", "'KNN'", ",", "\n", "'KNN+mask'", ",", "\n", "'MI'", ",", "\n", "'MI+mask'", ",", "\n", "'MIA+bagging'", ",", "\n", "]", "\n", "\n", "db_order", "=", "[", "\n", "'TB'", ",", "\n", "'UKBB'", ",", "\n", "'MIMIC'", ",", "\n", "'NHIS'", ",", "\n", "]", "\n", "\n", "rename", "=", "{", "\n", "'Med'", ":", "'Median'", ",", "\n", "'Med+mask'", ":", "'Median+mask'", ",", "\n", "'Iter'", ":", "'Iterative'", ",", "\n", "'Iter+mask'", ":", "'Iterative+mask'", ",", "\n", "}", "\n", "\n", "scores", "=", "scores", ".", "query", "(", "'method in @method_order'", ")", "\n", "ranks", "=", "get_ranks_tab", "(", "scores", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "\n", "average_sizes", "=", "False", ",", "average_on_dbs", "=", "False", ")", "\n", "\n", "melted_ranks", "=", "pd", ".", "melt", "(", "ranks", ",", "ignore_index", "=", "False", ",", "value_name", "=", "'Rank'", ")", "\n", "melted_ranks", ".", "reset_index", "(", "inplace", "=", "True", ")", "\n", "melted_ranks", ".", "set_index", "(", "[", "'Size'", ",", "'Database'", ",", "'Task'", ",", "'Method'", "]", ",", "inplace", "=", "True", ")", "\n", "\n", "scores", "=", "aggregate", "(", "scores", ",", "'score'", ")", "\n", "scores", ".", "rename", "(", "{", "\n", "'size'", ":", "'Size'", ",", "\n", "'db'", ":", "'Database'", ",", "\n", "'task'", ":", "'Task'", ",", "\n", "'method'", ":", "'Method'", ",", "\n", "}", ",", "inplace", "=", "True", ",", "axis", "=", "1", ")", "\n", "scores", ".", "set_index", "(", "[", "'Size'", ",", "'Database'", ",", "'Task'", ",", "'Method'", "]", ",", "inplace", "=", "True", ")", "\n", "\n", "scores", "=", "scores", "[", "[", "'score'", ",", "'scorer'", "]", "]", "\n", "melted_ranks", "=", "melted_ranks", ".", "astype", "(", "float", ")", "\n", "melted_ranks", "[", "'Score'", "]", "=", "scores", "[", "'score'", "]", "\n", "melted_ranks", "[", "'scorer'", "]", "=", "scores", "[", "'scorer'", "]", "\n", "melted_ranks", ".", "dropna", "(", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "scores", "=", "melted_ranks", "\n", "\n", "if", "averaged_scores", ":", "\n", "        ", "for", "_", ",", "group", "in", "scores", ".", "groupby", "(", "[", "'Size'", ",", "'Database'", ",", "'Task'", "]", ")", ":", "\n", "            ", "group", "[", "'Score'", "]", "=", "group", "[", "'Score'", "]", ".", "mean", "(", ")", "\n", "scores", ".", "update", "(", "group", "[", "'Score'", "]", ")", "\n", "\n", "", "", "scores", ".", "reset_index", "(", "inplace", "=", "True", ")", "\n", "\n", "scores_auc", "=", "scores", ".", "query", "(", "'scorer == \"roc_auc_score\"'", ")", "\n", "scores_r2", "=", "scores", ".", "query", "(", "'scorer == \"r2_score\"'", ")", "\n", "\n", "fig1", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "5", ",", "3.3", ")", ")", "\n", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "\n", "# Build the color palette", "\n", "paired_colors", "=", "sns", ".", "color_palette", "(", "'Paired'", ")", ".", "as_hex", "(", ")", "\n", "# del paired_colors[10]", "\n", "paired_colors", "[", "10", "]", "=", "sns", ".", "color_palette", "(", "\"Set2\"", ")", ".", "as_hex", "(", ")", "[", "5", "]", "\n", "boxplot_palette", "=", "sns", ".", "color_palette", "(", "[", "'#525252'", "]", "+", "paired_colors", ")", "\n", "sns", ".", "set_palette", "(", "boxplot_palette", ")", "\n", "\n", "# AUC figure", "\n", "sns", ".", "scatterplot", "(", "x", "=", "'Score'", ",", "y", "=", "'Rank'", ",", "hue", "=", "'Method'", ",", "data", "=", "scores_auc", ",", "\n", "ax", "=", "ax", ",", "hue_order", "=", "method_order", ",", "s", "=", "17", ")", "#, linewidth=0.2, edgecolor='black')", "\n", "palette", "=", "itertools", ".", "cycle", "(", "sns", ".", "color_palette", "(", ")", ")", "\n", "\n", "for", "_", ",", "group", "in", "scores_auc", ".", "groupby", "(", "'Method'", ",", "sort", "=", "False", ")", ":", "\n", "        ", "z", "=", "sm", ".", "nonparametric", ".", "lowess", "(", "group", "[", "'Rank'", "]", ",", "group", "[", "'Score'", "]", ",", "frac", "=", "1", ")", "\n", "ax", ".", "plot", "(", "z", "[", ":", ",", "0", "]", ",", "z", "[", ":", ",", "1", "]", ",", "color", "=", "next", "(", "palette", ")", ",", "lw", "=", "2", ")", "\n", "\n", "", "ax", ".", "legend", "(", "bbox_to_anchor", "=", "(", "1", ",", "1", ")", ")", "\n", "ax", ".", "set_xlabel", "(", "'AUC score'", ")", "\n", "ax", ".", "invert_yaxis", "(", ")", "\n", "\n", "# Rename methods in legend", "\n", "handles", ",", "labels", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "renamed_labels", "=", "[", "rename", ".", "get", "(", "label", ",", "label", ")", "for", "label", "in", "labels", "]", "\n", "ax", ".", "legend", "(", "title", "=", "'Method'", ",", "handles", "=", "handles", ",", "labels", "=", "renamed_labels", ",", "bbox_to_anchor", "=", "(", "1", ",", "1.12", ")", ")", "\n", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "# R2 figure", "\n", "fig2", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "5", ",", "3.3", ")", ")", "\n", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "\n", "sns", ".", "scatterplot", "(", "x", "=", "'Score'", ",", "y", "=", "'Rank'", ",", "hue", "=", "'Method'", ",", "data", "=", "scores_r2", ",", "\n", "ax", "=", "ax", ",", "hue_order", "=", "method_order", ",", "s", "=", "17", ")", "#, linewidth=0.2, edgecolor='black')", "\n", "palette", "=", "itertools", ".", "cycle", "(", "sns", ".", "color_palette", "(", ")", ")", "\n", "\n", "for", "_", ",", "group", "in", "scores_r2", ".", "groupby", "(", "'Method'", ",", "sort", "=", "False", ")", ":", "\n", "        ", "z", "=", "sm", ".", "nonparametric", ".", "lowess", "(", "group", "[", "'Rank'", "]", ",", "group", "[", "'Score'", "]", ",", "frac", "=", "1", ")", "\n", "ax", ".", "plot", "(", "z", "[", ":", ",", "0", "]", ",", "z", "[", ":", ",", "1", "]", ",", "color", "=", "next", "(", "palette", ")", ",", "lw", "=", "2", ")", "\n", "\n", "", "ax", ".", "legend", "(", "bbox_to_anchor", "=", "(", "1", ",", "1", ")", ")", "\n", "ax", ".", "set_xlabel", "(", "'$r^2$ score'", ")", "\n", "ax", ".", "invert_yaxis", "(", ")", "\n", "\n", "# Rename methods in legend", "\n", "handles", ",", "labels", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "renamed_labels", "=", "[", "rename", ".", "get", "(", "label", ",", "label", ")", "for", "label", "in", "labels", "]", "\n", "ax", ".", "legend", "(", "title", "=", "'Method'", ",", "handles", "=", "handles", ",", "labels", "=", "renamed_labels", ",", "bbox_to_anchor", "=", "(", "1", ",", "1.12", ")", ")", "\n", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "fig_name", "=", "'rank_vs_difficulty'", "\n", "\n", "fig1", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "fig_folder", ",", "f'{fig_name}_auc.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "fig1", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "fig_folder", ",", "f'{fig_name}_auc.jpg'", ")", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "\n", "fig2", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "fig_folder", ",", "f'{fig_name}_r2.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "fig2", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "fig_folder", ",", "f'{fig_name}_r2.jpg'", ")", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.boxplots.run_boxplot": [[93, 159], ["pandas.read_csv", "tasks_to_drop.items", "scores[].str.replace", "tests.run_wilcoxon", "custom.const.get_fig_folder", "PlotHelper.plot_scores.savefig", "PlotHelper.plot_times.savefig", "pd.read_csv.drop", "prediction.PlotHelper.PlotHelper.plot_MIA_linear", "prediction.PlotHelper.PlotHelper.plot_times", "prediction.PlotHelper.PlotHelper.plot_scores", "prediction.PlotHelper.PlotHelper.plot_times", "os.path.join", "os.path.join", "boxplots.run_boxplot.pvalue_to_symbol"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_MIA_linear", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_times", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_scores", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_times"], ["def", "run_boxplot", "(", "graphics_folder", ",", "linear", ")", ":", "\n", "    ", "filepath", "=", "'scores/scores.csv'", "\n", "scores", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "0", ")", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "scores", ".", "drop", "(", "index", "=", "scores", "[", "(", "scores", "[", "'db'", "]", "==", "db", ")", "&", "(", "scores", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "scores", "[", "'task'", "]", "=", "scores", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "# Get Wilcoxon table for symbol annotation", "\n", "W_test", "=", "run_wilcoxon", "(", "graphics_folder", "=", "None", ",", "spacing", "=", "False", ",", "no_rename", "=", "True", ")", "\n", "\n", "symbols", "=", "{", "}", "\n", "\n", "def", "pvalue_to_symbol", "(", "pvalue", ",", "alpha", ",", "n_bonferroni", ")", ":", "\n", "        ", "if", "pvalue", "<", "alpha", "/", "n_bonferroni", ":", "\n", "            ", "return", "'$\\\\star\\\\star$'", "\n", "", "if", "pvalue", "<", "alpha", ":", "\n", "            ", "return", "'$\\\\star$'", "\n", "", "return", "None", "\n", "\n", "", "alpha", "=", "0.05", "\n", "n_bonferroni", "=", "W_test", ".", "shape", "[", "0", "]", "\n", "\n", "for", "size", "in", "W_test", ":", "\n", "        ", "symbols", "[", "size", "]", "=", "{", "k", ":", "pvalue_to_symbol", "(", "v", ",", "alpha", ",", "n_bonferroni", ")", "for", "k", ",", "v", "in", "W_test", "[", "size", "]", ".", "iteritems", "(", ")", "}", "\n", "symbols", "[", "size", "]", "[", "'MIA'", "]", "=", "'$\\\\rightarrow$'", "\n", "\n", "", "if", "linear", ":", "\n", "        ", "fig", "=", "PlotHelper", ".", "plot_MIA_linear", "(", "\n", "scores", ",", "db_order", "=", "db_order", ",", "method_order", "=", "linear_method_order", ",", "\n", "rename", "=", "rename_on_plot", ",", "symbols", "=", "symbols", ")", "\n", "xticks", "=", "{", "\n", "1", "/", "50", ":", "'$\\\\frac{1}{50}\\\\times$'", ",", "\n", "1", "/", "10", ":", "'$\\\\frac{1}{10}\\\\times$'", ",", "\n", "1", "/", "3", ":", "'$\\\\frac{1}{3}\\\\times$'", ",", "\n", "1", ":", "'$1\\\\times$'", ",", "\n", "3", ":", "'$3\\\\times$'", ",", "\n", "10", ":", "'$10\\\\times$'", ",", "\n", "}", "\n", "fig_time", "=", "PlotHelper", ".", "plot_times", "(", "\n", "scores", ",", "'PT'", ",", "xticks_dict", "=", "xticks", ",", "xlims", "=", "(", "0.005", ",", "15", ")", ",", "\n", "method_order", "=", "linear_method_order", ",", "db_order", "=", "db_order", ",", "\n", "rename", "=", "rename_on_plot", ",", "linear", "=", "linear", ")", "\n", "\n", "", "else", ":", "\n", "        ", "fig", "=", "PlotHelper", ".", "plot_scores", "(", "\n", "scores", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "\n", "rename", "=", "rename_on_plot", ",", "reference_method", "=", "None", ",", "symbols", "=", "symbols", ")", "\n", "xticks", "=", "{", "\n", "2", "/", "3", ":", "'$\\\\frac{2}{3}\\\\times$'", ",", "\n", "1", ":", "'$1\\\\times$'", ",", "\n", "3", "/", "2", ":", "'$\\\\frac{3}{2}\\\\times$'", ",", "\n", "}", "\n", "fig_time", "=", "PlotHelper", ".", "plot_times", "(", "\n", "scores", ",", "'PT'", ",", "xticks_dict", "=", "xticks", ",", "method_order", "=", "method_order", ",", "\n", "db_order", "=", "db_order", ",", "rename", "=", "rename_on_plot", ",", "linear", "=", "linear", ")", "\n", "\n", "", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "\n", "fig_name", "=", "'boxplots_scores_linear'", "if", "linear", "else", "'boxplots_scores'", "\n", "fig_time_name", "=", "'boxplots_times_linear'", "if", "linear", "else", "'boxplots_times'", "\n", "\n", "fig", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "fig_time", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_time_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.mi.run_multiple_imputation": [[139, 351], ["pandas.concat", "tasks_to_drop.items", "scores.query.query", "scores[].str.replace", "tests.run_wilcoxon", "tests.run_wilcoxon", "prediction.PlotHelper.PlotHelper.plot_scores", "print", "scores.query.groupby", "print", "prediction.PlotHelper.PlotHelper.plot_times", "PlotHelper.plot_scores.subplots_adjust", "PlotHelper.plot_times.subplots_adjust", "custom.const.get_fig_folder", "PlotHelper.plot_scores.savefig", "PlotHelper.plot_times.savefig", "PlotHelper.plot_scores.savefig", "PlotHelper.plot_times.savefig", "ValueError", "pandas.read_csv", "scores.query.drop", "W_test_greater[].iteritems", "W_test_less[].iteritems", "scores.query.query", "len", "seaborn.color_palette().as_hex", "scores[].fillna", "len", "comments.get", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "mi.run_multiple_imputation.pvalue_to_symbol"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_scores", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.plot_times", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], ["def", "run_multiple_imputation", "(", "graphics_folder", ",", "n", "=", "None", ",", "bagging_only", "=", "False", ",", "linear", "=", "False", ")", ":", "\n", "    ", "if", "bagging_only", "and", "linear", ":", "\n", "        ", "raise", "ValueError", "(", "'No linear for bagging'", ")", "\n", "", "elif", "bagging_only", ":", "\n", "        ", "method_order", "=", "method_order_bagging", "\n", "", "elif", "linear", ":", "\n", "        ", "method_order", "=", "method_order_linear", "\n", "", "else", ":", "\n", "        ", "method_order", "=", "method_order_all", "\n", "\n", "", "reference_method", "=", "'MIA'", "\n", "\n", "dfs", "=", "[", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "for", "path", "in", "filepaths", "]", "\n", "scores", "=", "pd", ".", "concat", "(", "dfs", ",", "axis", "=", "0", ")", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "scores", ".", "drop", "(", "index", "=", "scores", "[", "(", "scores", "[", "'db'", "]", "==", "db", ")", "&", "(", "scores", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "scores", "=", "scores", ".", "query", "(", "'size != 100000 or (method not in [\"Linear+KNN\", \"Linear+KNN+mask\"])'", ")", "\n", "\n", "scores", "[", "'task'", "]", "=", "scores", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "# Get Wilcoxon table for symbol annotation", "\n", "W_test_greater", "=", "run_wilcoxon", "(", "graphics_folder", "=", "None", ",", "spacing", "=", "False", ",", "no_rename", "=", "True", ",", "greater", "=", "True", ")", "\n", "W_test_less", "=", "run_wilcoxon", "(", "graphics_folder", "=", "None", ",", "spacing", "=", "False", ",", "no_rename", "=", "True", ",", "greater", "=", "False", ")", "\n", "\n", "symbols", "=", "{", "}", "\n", "\n", "def", "pvalue_to_symbol", "(", "pvalue", ",", "alpha", ",", "n_bonferroni", ",", "greater", "=", "True", ")", ":", "\n", "        ", "c", "=", "''", "if", "greater", "else", "'(>)'", "\n", "if", "pvalue", "<", "alpha", "/", "n_bonferroni", ":", "\n", "            ", "return", "f'$\\\\star\\\\star{c}$'", "\n", "", "if", "pvalue", "<", "alpha", ":", "\n", "            ", "return", "f'$\\\\star{c}$'", "\n", "", "return", "None", "\n", "\n", "", "alpha", "=", "0.05", "\n", "n_bonferroni", "=", "W_test_greater", ".", "shape", "[", "0", "]", "\n", "\n", "for", "size", "in", "W_test_greater", ":", "\n", "        ", "symbols", "[", "size", "]", "=", "{", "}", "\n", "symbols", "[", "size", "]", "[", "'MIA'", "]", "=", "'$\\\\rightarrow$'", "\n", "for", "k", ",", "v", "in", "W_test_greater", "[", "size", "]", ".", "iteritems", "(", ")", ":", "\n", "            ", "symbols", "[", "size", "]", "[", "k", "]", "=", "pvalue_to_symbol", "(", "v", ",", "alpha", ",", "n_bonferroni", ",", "greater", "=", "True", ")", "\n", "", "for", "k", ",", "v", "in", "W_test_less", "[", "size", "]", ".", "iteritems", "(", ")", ":", "\n", "            ", "if", "symbols", "[", "size", "]", "[", "k", "]", "is", "None", ":", "\n", "                ", "symbols", "[", "size", "]", "[", "k", "]", "=", "pvalue_to_symbol", "(", "v", ",", "alpha", ",", "n_bonferroni", ",", "greater", "=", "False", ")", "\n", "\n", "", "", "", "comments", "=", "{", "}", "\n", "comments", "[", "100000", "]", "=", "{", "}", "\n", "comments", "[", "100000", "]", "[", "'KNN'", "]", "=", "'Intractable'", "\n", "comments", "[", "100000", "]", "[", "'KNN+mask'", "]", "=", "'Intractable'", "\n", "comments", "[", "100000", "]", "[", "'Linear+KNN'", "]", "=", "'Intractable'", "\n", "comments", "[", "100000", "]", "[", "'Linear+KNN+mask'", "]", "=", "'Intractable'", "\n", "\n", "if", "n", "is", "not", "None", ":", "\n", "        ", "scores", "=", "scores", ".", "query", "(", "f'size == {n}'", ")", "\n", "figsize", "=", "(", "4.5", ",", "5.25", ")", "\n", "legend_bbox", "=", "(", "1.055", ",", "1.075", ")", "\n", "\n", "", "else", ":", "\n", "        ", "figsize", "=", "(", "18", ",", "6", ")", "\n", "# legend_bbox = (4.415, 1.015)", "\n", "legend_bbox", "=", "(", "2.02", ",", "1.05", ")", "\n", "\n", "", "if", "len", "(", "method_order", ")", ">=", "12", ":", "\n", "        ", "y_labelsize", "=", "14", "\n", "", "else", ":", "\n", "        ", "y_labelsize", "=", "18", "\n", "\n", "", "pos_arrow", "=", "None", "\n", "w_bag", "=", "None", "\n", "w_const", "=", "None", "\n", "w_cond", "=", "None", "\n", "colors", "=", "None", "\n", "hline_pos", "=", "None", "\n", "\n", "if", "linear", ":", "\n", "        ", "pos_arrow", "=", "-", "0.58", "\n", "y_labelsize", "=", "15.5", "\n", "w_bag", "=", "0", "\n", "w_const", "=", "80", "\n", "w_cond", "=", "80", "\n", "\n", "", "if", "bagging_only", ":", "\n", "        ", "w_bag", "=", "0", "\n", "paired_colors", "=", "sns", ".", "color_palette", "(", "'Paired'", ")", ".", "as_hex", "(", ")", "\n", "paired_colors", "[", "10", "]", "=", "sns", ".", "color_palette", "(", "\"Set2\"", ")", ".", "as_hex", "(", ")", "[", "5", "]", "\n", "colors_all", "=", "[", "'#525252'", "]", "+", "paired_colors", "\n", "colors_dict", "=", "{", "m", ":", "c", "for", "m", ",", "c", "in", "zip", "(", "method_order_all", ",", "colors_all", ")", "}", "\n", "colors", "=", "[", "colors_dict", ".", "get", "(", "m", ",", "colors_all", "[", "-", "1", "]", ")", "for", "m", "in", "method_order_bagging", "]", "\n", "hline_pos", "=", "[", "2", ",", "4", "]", "\n", "\n", "", "ref_vline", "=", "'MIA'", "\n", "\n", "fig", "=", "PlotHelper", ".", "plot_scores", "(", "\n", "scores", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "\n", "rename", "=", "rename_on_plot", ",", "reference_method", "=", "None", ",", "symbols", "=", "symbols", ",", "\n", "only_full_samples", "=", "False", ",", "legend_bbox", "=", "legend_bbox", ",", "figsize", "=", "figsize", ",", "\n", "table_fontsize", "=", "13", ",", "y_labelsize", "=", "y_labelsize", ",", "comments", "=", "comments", ",", "\n", "pos_arrow", "=", "pos_arrow", ",", "w_bag", "=", "w_bag", ",", "w_const", "=", "w_const", ",", "w_cond", "=", "w_cond", ",", "\n", "colors", "=", "colors", ",", "hline_pos", "=", "hline_pos", ",", "ref_vline", "=", "ref_vline", ")", "\n", "\n", "scores", "[", "'total_PT'", "]", "=", "scores", "[", "'imputation_PT'", "]", ".", "fillna", "(", "0", ")", "+", "scores", "[", "'tuning_PT'", "]", "\n", "scores", "[", "'tag'", "]", "=", "scores", "[", "'db'", "]", "+", "'/'", "+", "scores", "[", "'task'", "]", "\n", "print", "(", "scores", ")", "\n", "for", "index", ",", "subdf", "in", "scores", ".", "groupby", "(", "[", "'size'", ",", "'method'", "]", ")", ":", "\n", "        ", "size", ",", "method", "=", "index", "\n", "n_tasks", "=", "len", "(", "subdf", "[", "'tag'", "]", ".", "unique", "(", ")", ")", "\n", "total_pt_time", "=", "subdf", "[", "'total_PT'", "]", ".", "sum", "(", ")", "/", "n_tasks", "\n", "\n", "comments_size", "=", "comments", ".", "get", "(", "size", ",", "{", "}", ")", "\n", "if", "comments_size", ".", "get", "(", "method", ",", "None", ")", "is", "None", ":", "\n", "            ", "time", "=", "total_pt_time", "/", "3600", "\n", "if", "time", "<", "10", ":", "\n", "                ", "time_str", "=", "f'{time:.2g} hours'", "\n", "", "elif", "time", "<", "100", ":", "\n", "                ", "time_str", "=", "f'{int(time):,d} hours'", "\n", "", "else", ":", "\n", "                ", "time_str", "=", "f'{int(time/24):,d} days'", "\n", "", "print", "(", "time", ",", "time_str", ")", "\n", "comments_size", "[", "method", "]", "=", "time_str", ".", "replace", "(", "','", ",", "'\\\\,'", ")", "\n", "", "comments", "[", "size", "]", "=", "comments_size", "\n", "", "print", "(", "comments", ")", "\n", "\n", "xticks", "=", "{", "\n", "# 1/10: '$\\\\frac{1}{10}\\\\times$',", "\n", "# 2/3: '$\\\\frac{2}{3}\\\\times$',", "\n", "1", ":", "'$1\\\\times$'", ",", "\n", "# 3/2: '$\\\\frac{3}{2}\\\\times$',", "\n", "2", ":", "'$2\\\\times$'", ",", "\n", "# 5: '$5\\\\times$',", "\n", "# 10: '$10\\\\times$',", "\n", "50", ":", "'$50\\\\times$'", ",", "\n", "100", ":", "'$100\\\\times$'", ",", "\n", "# 150: '$150\\\\times$',", "\n", "200", ":", "'$200\\\\times$'", ",", "\n", "500", ":", "'$500\\\\times$'", ",", "\n", "}", "\n", "legend_bbox", "=", "(", "4.16", ",", "1.05", ")", "\n", "broken_axis", "=", "[", "(", "2.3", ",", "55", ")", ",", "(", "2.3", ",", "55", ")", ",", "(", "2.5", ",", "25", ")", ",", "(", "3.5", ",", "25", ")", "]", "\n", "y_labelsize", "=", "15.5", "\n", "comments_spacing", "=", "0.11", "\n", "\n", "if", "bagging_only", ":", "\n", "        ", "comments_align", "=", "{", "\n", "0", ":", "[", "'right'", "]", "+", "[", "'left'", "]", "+", "[", "'right'", "]", "+", "[", "'left'", "]", "+", "[", "'right'", "]", "+", "[", "'left'", "]", ",", "\n", "1", ":", "[", "'right'", "]", "+", "[", "'left'", "]", "+", "[", "'right'", "]", "+", "[", "'left'", "]", "+", "[", "'right'", "]", "+", "[", "'left'", "]", ",", "\n", "2", ":", "[", "'right'", "]", "+", "[", "'left'", "]", "+", "[", "'right'", "]", "+", "[", "'left'", "]", "+", "[", "'right'", "]", "+", "[", "'left'", "]", ",", "\n", "3", ":", "[", "'right'", "]", "+", "[", "'left'", "]", "+", "[", "'right'", "]", "+", "[", "'left'", "]", "+", "[", "'right'", "]", "+", "[", "'left'", "]", ",", "\n", "}", "\n", "y_labelsize", "=", "20", "\n", "comments_spacing", "=", "0.13", "\n", "\n", "", "elif", "linear", ":", "\n", "        ", "comments_align", "=", "{", "\n", "0", ":", "[", "'right'", "]", "*", "5", "+", "[", "'left'", "]", "*", "2", "+", "[", "'right'", "]", "*", "2", ",", "\n", "1", ":", "[", "'right'", "]", "*", "5", "+", "[", "'left'", "]", "*", "4", ",", "\n", "2", ":", "[", "'right'", "]", "*", "5", "+", "[", "'left'", "]", "*", "4", ",", "\n", "3", ":", "[", "'right'", "]", "*", "5", "+", "[", "'left'", "]", "*", "4", ",", "\n", "}", "\n", "broken_axis", "=", "None", "\n", "legend_bbox", "=", "(", "2.02", ",", "1.05", ")", "\n", "pos_arrow", "=", "-", "0.53", "\n", "xticks", "=", "{", "\n", "1", ":", "'$1\\\\times$'", ",", "\n", "1", "/", "2", ":", "'$\\\\frac{1}{2}\\\\times$'", ",", "\n", "1", "/", "5", ":", "'$\\\\frac{1}{5}\\\\times$'", ",", "\n", "1", "/", "10", ":", "'$\\\\frac{1}{10}\\\\times$'", ",", "\n", "1", "/", "100", ":", "'$\\\\frac{1}{100}\\\\times$'", ",", "\n", "1", "/", "500", ":", "'$\\\\frac{1}{500}\\\\times$'", ",", "\n", "}", "\n", "comments_spacing", "=", "0.06", "\n", "\n", "", "else", ":", "\n", "        ", "comments_align", "=", "{", "\n", "0", ":", "[", "'right'", "]", "*", "9", "+", "[", "'left'", "]", "*", "3", ",", "\n", "1", ":", "[", "'right'", "]", "*", "9", "+", "[", "'left'", "]", "*", "3", ",", "\n", "2", ":", "[", "'right'", "]", "*", "9", "+", "[", "'left'", "]", "*", "3", ",", "\n", "3", ":", "[", "'right'", "]", "*", "7", "+", "[", "'left'", "]", "*", "5", ",", "\n", "}", "\n", "comments_spacing", "=", "0.13", "\n", "\n", "# figsize = (18, 6)", "\n", "\n", "", "fig_time", "=", "PlotHelper", ".", "plot_times", "(", "\n", "scores", ",", "'PT'", ",", "xticks_dict", "=", "xticks", ",", "method_order", "=", "method_order", ",", "\n", "db_order", "=", "db_order", ",", "rename", "=", "rename_on_plot", ",", "y_labelsize", "=", "y_labelsize", ",", "\n", "legend_bbox", "=", "legend_bbox", ",", "broken_axis", "=", "broken_axis", ",", "\n", "only_full_samples", "=", "False", ",", "reference_method", "=", "reference_method", ",", "figsize", "=", "figsize", ",", "comments", "=", "comments", ",", "\n", "comments_align", "=", "comments_align", ",", "comments_spacing", "=", "comments_spacing", ",", "\n", "pos_arrow", "=", "pos_arrow", ",", "w_bag", "=", "w_bag", ",", "w_const", "=", "w_const", ",", "w_cond", "=", "w_cond", ",", "\n", "colors", "=", "colors", ",", "hline_pos", "=", "hline_pos", ")", "\n", "\n", "fig", ".", "subplots_adjust", "(", "wspace", "=", "0.02", ")", "\n", "fig_time", ".", "subplots_adjust", "(", "wspace", "=", "0.02", ")", "\n", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "if", "bagging_only", ":", "\n", "        ", "name", "=", "'bagging'", "\n", "", "elif", "linear", ":", "\n", "        ", "name", "=", "'linear'", "\n", "", "else", ":", "\n", "        ", "name", "=", "'mi'", "\n", "\n", "", "fig_name", "=", "f'boxplots_{name}_scores_{n}'", "\n", "fig_time_name", "=", "f'boxplots_{name}_times_{n}'", "\n", "\n", "fig", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "fig_time", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_time_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "fig", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_name}.jpg'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "fig_time", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_time_name}.jpg'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.friedman_statistic": [[32, 71], ["numpy.squeeze", "numpy.isnan().any", "scipy.stats.chi2.sf", "scipy.stats.f.sf", "tests.critical_distance", "numpy.array", "ValueError", "numpy.isnan", "numpy.sum", "numpy.square"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.critical_distance"], ["def", "friedman_statistic", "(", "ranks", ",", "N", ")", ":", "\n", "    ", "\"\"\"Compute the Friedman statistic.\n\n    See (Demsar, 2006).\n\n    Parameters\n    ----------\n        ranks : np.array of shape (k,)\n            Mean ranks of the k algorithms averaged over N datasets\n        N : int\n            Number of datasets ranks were averaged on\n\n    Returns\n    -------\n        XF2 : float\n            Friedman statistic (chi 2 with k-1 degrees of freedom)\n        XF2_pval : flaot\n            p-value associated to XF2\n        FF : float\n            Corrected statistic by Iman and Davenport. F-distribution with\n            k-1 and (k-1)*(N-1) degrees of freedom\n        FF_pval : float\n            p-value associated to FF\n\n    \"\"\"", "\n", "ranks", "=", "np", ".", "squeeze", "(", "np", ".", "array", "(", "ranks", ")", ")", "\n", "if", "np", ".", "isnan", "(", "ranks", ")", ".", "any", "(", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'NaN found in given ranks: {ranks}'", ")", "\n", "", "k", "=", "ranks", ".", "shape", "[", "0", "]", "\n", "\n", "XF2", "=", "12", "*", "N", "/", "(", "k", "*", "(", "k", "+", "1", ")", ")", "*", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "ranks", ")", ")", "-", "1", "/", "4", "*", "k", "*", "(", "k", "+", "1", ")", "**", "2", ")", "\n", "FF", "=", "(", "N", "-", "1", ")", "*", "XF2", "/", "(", "N", "*", "(", "k", "-", "1", ")", "-", "XF2", ")", "\n", "\n", "XF2_pval", "=", "chi2", ".", "sf", "(", "XF2", ",", "k", ")", "\n", "FF_pval", "=", "f", ".", "sf", "(", "FF", ",", "k", "-", "1", ",", "(", "k", "-", "1", ")", "*", "(", "N", "-", "1", ")", ")", "\n", "\n", "CD", "=", "critical_distance", "(", "k", ",", "N", ")", "\n", "\n", "return", "XF2", ",", "XF2_pval", ",", "FF", ",", "FF_pval", ",", "CD", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.critical_distance": [[73, 113], ["numpy.sqrt", "len"], "function", ["None"], ["", "def", "critical_distance", "(", "k", ",", "N", ")", ":", "\n", "    ", "\"\"\"Compute the critical difference for the Nemenyi test.\n\n    Parameters\n    ----------\n        k : Number of algorithms to compare (2 <= k <= 10)\n        N : Number of datasets algorithms were tested on\n\n    Returns\n    -------\n        CD : float\n            Critical difference\n\n    \"\"\"", "\n", "# q_05 = [1.960, 2.343, 2.569, 2.728, 2.850, 2.949, 3.031, 3.102, 3.164]", "\n", "q_05", "=", "[", "\n", "1.959964233", ",", "\n", "2.343700476", ",", "\n", "2.569032073", ",", "\n", "2.727774717", ",", "\n", "2.849705382", ",", "\n", "2.948319908", ",", "\n", "3.030878867", ",", "\n", "3.10173026", ",", "\n", "3.16368342", ",", "\n", "3.218653901", ",", "\n", "3.268003591", ",", "\n", "3.312738701", ",", "\n", "3.353617959", ",", "\n", "3.391230382", ",", "\n", "3.426041249", ",", "\n", "3.458424619", ",", "\n", "3.488684546", ",", "\n", "3.517072762", ",", "\n", "3.543799277", ",", "\n", "]", "# Values taken on https://kourentzes.com/forecasting/2014/05/01/critical-values-for-the-nemenyi-test/", "\n", "assert", "2", "<=", "k", "<", "len", "(", "q_05", ")", "+", "2", "\n", "CD", "=", "q_05", "[", "k", "-", "2", "]", "*", "np", ".", "sqrt", "(", "k", "*", "(", "k", "+", "1", ")", "/", "(", "6", "*", "N", ")", ")", "\n", "\n", "return", "CD", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon_": [[115, 244], ["os.path.abspath", "pandas.read_csv", "prediction.PlotHelper.PlotHelper.aggregate", "df.set_index.reset_index", "df.set_index.set_index", "MIA.reset_index", "df.set_index.index.get_level_values().unique", "pandas.DataFrame().set_index", "W_test.reindex.reindex", "print", "pandas.MultiIndex.from_tuples", "print", "W_test.reindex.rename", "W_test.reindex.rename", "W_test.reindex.index.rename", "print", "W_test.reindex.drop", "W_test.reindex.columns.droplevel", "W_test.reindex.drop", "print", "W_test.reindex.to_csv", "W_test.reindex.to_latex", "m.reset_index", "scipy.stats.wilcoxon", "scipy.stats.wilcoxon", "rows.append", "df.set_index.index.get_level_values", "pandas.DataFrame", "s.split", "df.set_index.index.get_level_values", "df.set_index.index.get_level_values"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["", "def", "run_wilcoxon_", "(", ")", ":", "\n", "    ", "path", "=", "os", ".", "path", ".", "abspath", "(", "'scores/scores.csv'", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "\n", "\n", "# # Agregate accross trials by averaging", "\n", "# df = df.reset_index()", "\n", "# df['n_trials'] = 1  # Add a count column to keep track of # of trials", "\n", "# dfgb = df.groupby(['size', 'db', 'task', 'method', 'fold'])", "\n", "# df = dfgb.agg({", "\n", "#     'score': 'mean',", "\n", "#     'n_trials': 'sum',", "\n", "#     'scorer': PlotHelper.assert_equal,  # first and assert equal", "\n", "#     'selection': PlotHelper.assert_equal,", "\n", "#     'n': PlotHelper.assert_equal,", "\n", "#     'p': 'mean',  #PlotHelper.assert_equal,", "\n", "#     'type': PlotHelper.assert_equal,", "\n", "#     'imputation_WCT': 'mean',", "\n", "#     'tuning_WCT': 'mean',", "\n", "#     'imputation_PT': 'mean',", "\n", "#     'tuning_PT': 'mean',", "\n", "# })", "\n", "\n", "# Aggregate both trials and folds", "\n", "df", "=", "PlotHelper", ".", "aggregate", "(", "df", ",", "'score'", ")", "\n", "\n", "# Reset index to addlevel of the multi index to the columns of the df", "\n", "df", "=", "df", ".", "reset_index", "(", ")", "\n", "df", "=", "df", ".", "set_index", "(", "[", "'size'", ",", "'db'", ",", "'task'", ",", "'method'", "]", ")", "\n", "\n", "MIA", "=", "df", ".", "iloc", "[", "df", ".", "index", ".", "get_level_values", "(", "'method'", ")", "==", "'MIA'", "]", "\n", "MIA", ".", "reset_index", "(", "level", "=", "'method'", ",", "drop", "=", "True", ",", "inplace", "=", "True", ")", "\n", "MIA_scores", "=", "MIA", "[", "'score'", "]", "\n", "MIA_index", "=", "MIA", ".", "index", "\n", "\n", "methods", "=", "df", ".", "index", ".", "get_level_values", "(", "'method'", ")", ".", "unique", "(", ")", "\n", "methods", "=", "[", "m", "for", "m", "in", "methods", "if", "m", "!=", "'MIA'", "]", "\n", "\n", "rows", "=", "[", "]", "\n", "for", "method", "in", "methods", ":", "\n", "        ", "m", "=", "df", ".", "iloc", "[", "df", ".", "index", ".", "get_level_values", "(", "'method'", ")", "==", "method", "]", "\n", "m", ".", "reset_index", "(", "level", "=", "'method'", ",", "drop", "=", "True", ",", "inplace", "=", "True", ")", "\n", "m_scores", "=", "m", "[", "'score'", "]", "\n", "ref_scores", "=", "MIA_scores", ".", "loc", "[", "m_scores", ".", "index", "]", "\n", "w_double", "=", "wilcoxon", "(", "x", "=", "ref_scores", ",", "y", "=", "m_scores", ",", "alternative", "=", "'two-sided'", ")", "\n", "w_greater", "=", "wilcoxon", "(", "x", "=", "ref_scores", ",", "y", "=", "m_scores", ",", "alternative", "=", "'greater'", ")", "\n", "rows", ".", "append", "(", "(", "method", ",", "w_double", "[", "0", "]", ",", "w_double", "[", "1", "]", ",", "w_greater", "[", "0", "]", ",", "w_greater", "[", "1", "]", ")", ")", "\n", "\n", "", "W_test", "=", "pd", ".", "DataFrame", "(", "rows", ",", "columns", "=", "[", "\n", "'method'", ",", "\n", "'two-sided_stat'", ",", "\n", "'two-sided_pval'", ",", "\n", "'greater_stat'", ",", "\n", "'greater_pval'", ",", "\n", "]", ")", ".", "set_index", "(", "'method'", ")", "\n", "\n", "half1", "=", "[", "\n", "'Mean'", ",", "\n", "'Mean+mask'", ",", "\n", "'Med'", ",", "\n", "'Med+mask'", ",", "\n", "'Iter'", ",", "\n", "'Iter+mask'", ",", "\n", "'KNN'", ",", "\n", "'KNN+mask'", ",", "\n", "]", "\n", "\n", "half2", "=", "[", "\n", "'Linear+Mean'", ",", "\n", "'Linear+Mean+mask'", ",", "\n", "'Linear+Med'", ",", "\n", "'Linear+Med+mask'", ",", "\n", "'Linear+Iter'", ",", "\n", "'Linear+Iter+mask'", ",", "\n", "'Linear+KNN'", ",", "\n", "'Linear+KNN+mask'", ",", "\n", "]", "\n", "\n", "W_test", "=", "W_test", ".", "reindex", "(", "half1", "+", "half2", ")", "\n", "\n", "W_test", "[", "'two-sided_pval'", "]", "=", "[", "f'{w:.1g}'", "for", "w", "in", "W_test", "[", "'two-sided_pval'", "]", "]", "\n", "W_test", "[", "'greater_pval'", "]", "=", "[", "f'{w:.1g}'", "for", "w", "in", "W_test", "[", "'greater_pval'", "]", "]", "\n", "\n", "print", "(", "W_test", ")", "\n", "\n", "W_test", ".", "columns", "=", "pd", ".", "MultiIndex", ".", "from_tuples", "(", "[", "s", ".", "split", "(", "'_'", ")", "for", "s", "in", "W_test", ".", "columns", "]", ")", "\n", "\n", "print", "(", "W_test", ")", "\n", "\n", "W_test", ".", "rename", "(", "{", "\n", "'two-sided'", ":", "'Two-sided'", ",", "\n", "'greater'", ":", "'Greater'", ",", "\n", "'pval'", ":", "'p-value'", ",", "\n", "'stat'", ":", "'Statistic'", ",", "\n", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", ".", "rename", "(", "{", "\n", "# 'Mean': 'Mean',", "\n", "# 'Mean+mask': 'Mean+mask',", "\n", "'Med'", ":", "'Median'", ",", "\n", "'Med+mask'", ":", "'Median+mask'", ",", "\n", "'Iter'", ":", "'Iterative'", ",", "\n", "'Iter+mask'", ":", "'Iterative+mask'", ",", "\n", "# 'KNN': 'KNN',", "\n", "# 'KNN+mask': 'KNN+mask',", "\n", "# 'Linear+Mean': 'Linear+Mean',", "\n", "# 'Linear+Mean+mask': 'Linear+Mean+mask',", "\n", "# 'Linear+Med': 'Linear+Med',", "\n", "# 'Linear+Med+mask': 'Linear+Med+mask',", "\n", "# 'Linear+Iter': 'Linear+Iterative',", "\n", "# 'Linear+Iter+mask': 'Linear+Iterative+mask',", "\n", "# 'Linear+KNN': 'Linear+KNN',", "\n", "# 'Linear+KNN+mask': 'Linear+KNN+mask',", "\n", "# 'method': 'Method',", "\n", "}", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", ".", "index", ".", "rename", "(", "'Method'", ",", "inplace", "=", "True", ")", "\n", "\n", "print", "(", "W_test", ")", "\n", "\n", "# Delete two-sided", "\n", "W_test", ".", "drop", "(", "'Two-sided'", ",", "axis", "=", "1", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "W_test", ".", "columns", "=", "W_test", ".", "columns", ".", "droplevel", "(", "0", ")", "\n", "W_test", ".", "drop", "(", "'Statistic'", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "print", "(", "W_test", ")", "\n", "\n", "\n", "W_test", ".", "to_csv", "(", "'scores/wilcoxon.csv'", ")", "\n", "W_test", ".", "to_latex", "(", "'scores/wilcoxon.tex'", ",", "na_rep", "=", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon_mia": [[249, 447], ["pandas.concat", "tasks_to_drop.items", "df[].str.replace", "prediction.df_utils.get_scores_tab", "prediction.df_utils.get_scores_tab.index.get_level_values().unique", "pandas.DataFrame().set_index", "W_test.reindex.drop", "W_test.reindex.rename", "W_other.reindex.rename", "W_test.reindex.index.rename", "W_other.reindex.index.rename", "W_test.reindex.index.rename", "W_other.reindex.index.rename", "W_test.reindex.drop", "W_other.reindex.drop", "pandas.pivot_table", "pandas.pivot_table", "W_test.reindex.reindex", "W_other.reindex.reindex", "pandas.read_csv", "prediction.df_utils.get_scores_tab.drop", "scores.index.unique", "custom.const.get_tab_folder", "W_test.reindex.iterrows", "W_test.reindex.rename", "print", "W_test.reindex.to_latex", "os.path.abspath", "prediction.df_utils.get_scores_tab.index.get_level_values", "m_scores.notnull", "scipy.stats.wilcoxon", "scipy.stats.wilcoxon", "scipy.stats.wilcoxon", "rows.append", "pandas.DataFrame", "W_test.reindex.to_csv", "W_test[].iteritems", "W_other[].iteritems", "row.iteritems", "os.path.join", "x.isnull().any", "y.isnull().any", "os.path.join", "tests.run_wilcoxon_mia.pvalue_to_symbol"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_scores_tab", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["", "def", "run_wilcoxon_mia", "(", "graphics_folder", ",", "csv", "=", "False", ",", "greater", "=", "True", ",", "spacing", "=", "True", ",", "no_rename", "=", "False", ")", ":", "\n", "    ", "\"\"\"Wilcoxon test between MIA and every other methods (including linear).\"\"\"", "\n", "# path = os.path.abspath('scores/scores.csv')", "\n", "# df = pd.read_csv(path, index_col=0)", "\n", "\n", "# filepaths = [", "\n", "#     'scores/scores.csv',", "\n", "#     'scores/scores_mi_2500.csv',", "\n", "#     'scores/scores_mi_10000.csv',", "\n", "#     'scores/scores_mi_25000.csv',", "\n", "#     'scores/scores_mi_100000.csv',", "\n", "#     'scores/scores_mia_2500.csv',", "\n", "#     'scores/scores_mia_10000.csv',", "\n", "#     'scores/scores_mia_25000.csv',", "\n", "#     'scores/scores_mia_100000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_2500.csv',", "\n", "#     'scores/scores_mean+mask+bagging_10000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_25000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_100000.csv',", "\n", "# ]", "\n", "dfs", "=", "[", "pd", ".", "read_csv", "(", "os", ".", "path", ".", "abspath", "(", "path", ")", ",", "index_col", "=", "0", ")", "for", "path", "in", "filepaths", "]", "\n", "df", "=", "pd", ".", "concat", "(", "dfs", ",", "axis", "=", "0", ")", "\n", "\n", "which", "=", "'greater'", "if", "greater", "else", "'less'", "\n", "other", "=", "'less'", "if", "greater", "else", "'greater'", "\n", "\n", "# # Drop tasks", "\n", "# df = df.set_index(['db', 'task'])", "\n", "# for db, task in tasks_to_drop.items():", "\n", "#     df = df.drop((db, task), axis=0)", "\n", "# df = df.reset_index()", "\n", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "df", ".", "drop", "(", "index", "=", "df", "[", "(", "df", "[", "'db'", "]", "==", "db", ")", "&", "(", "df", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "\n", "", "df", "[", "'task'", "]", "=", "df", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "method_order1", "=", "[", "\n", "'Mean'", ",", "\n", "'Mean+mask'", ",", "\n", "'Med'", ",", "\n", "'Med+mask'", ",", "\n", "'Iter'", ",", "\n", "'Iter+mask'", ",", "\n", "'KNN'", ",", "\n", "'KNN+mask'", ",", "\n", "'MI'", ",", "\n", "'MI+mask'", ",", "\n", "'MIA+bagging'", ",", "\n", "]", "\n", "\n", "method_order2", "=", "[", "\n", "'Linear+Mean'", ",", "\n", "'Linear+Mean+mask'", ",", "\n", "'Linear+Med'", ",", "\n", "'Linear+Med+mask'", ",", "\n", "'Linear+Iter'", ",", "\n", "'Linear+Iter+mask'", ",", "\n", "'Linear+KNN'", ",", "\n", "'Linear+KNN+mask'", ",", "\n", "]", "\n", "\n", "method_order", "=", "[", "'MIA'", "]", "+", "method_order1", "+", "method_order2", "\n", "\n", "db_order", "=", "[", "\n", "'TB'", ",", "\n", "'UKBB'", ",", "\n", "'MIMIC'", ",", "\n", "'NHIS'", ",", "\n", "]", "\n", "\n", "df", "=", "get_scores_tab", "(", "df", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "\n", "average_sizes", "=", "False", ",", "formatting", "=", "False", ",", "add_empty_methods", "=", "False", ")", "\n", "sizes", "=", "df", ".", "index", ".", "get_level_values", "(", "0", ")", ".", "unique", "(", ")", "\n", "\n", "rows", "=", "[", "]", "\n", "for", "size", "in", "sizes", ":", "\n", "        ", "scores", "=", "df", ".", "loc", "[", "size", "]", "\n", "ref_scores", "=", "scores", ".", "loc", "[", "'MIA'", "]", "\n", "\n", "methods", "=", "scores", ".", "index", ".", "unique", "(", ")", "\n", "methods", "=", "[", "m", "for", "m", "in", "methods", "if", "m", "!=", "'MIA'", "]", "\n", "\n", "for", "method", "in", "methods", ":", "\n", "            ", "m_scores", "=", "scores", ".", "loc", "[", "method", "]", "\n", "idx", "=", "m_scores", ".", "notnull", "(", ")", "\n", "\n", "x", "=", "ref_scores", "[", "idx", "]", "\n", "y", "=", "m_scores", "[", "idx", "]", "\n", "\n", "assert", "not", "x", ".", "isnull", "(", ")", ".", "any", "(", ")", "\n", "assert", "not", "y", ".", "isnull", "(", ")", ".", "any", "(", ")", "\n", "\n", "w_double", "=", "wilcoxon", "(", "x", "=", "x", ",", "y", "=", "y", ",", "alternative", "=", "'two-sided'", ")", "\n", "w_greater", "=", "wilcoxon", "(", "x", "=", "x", ",", "y", "=", "y", ",", "alternative", "=", "'greater'", ")", "\n", "w_less", "=", "wilcoxon", "(", "x", "=", "x", ",", "y", "=", "y", ",", "alternative", "=", "'less'", ")", "\n", "\n", "rows", ".", "append", "(", "[", "size", ",", "method", ",", "w_double", "[", "0", "]", ",", "w_double", "[", "1", "]", ",", "w_greater", "[", "0", "]", ",", "w_greater", "[", "1", "]", ",", "w_less", "[", "0", "]", ",", "w_less", "[", "1", "]", "]", ")", "\n", "\n", "", "", "W_test", "=", "pd", ".", "DataFrame", "(", "rows", ",", "columns", "=", "[", "\n", "'size'", ",", "\n", "'method'", ",", "\n", "'two-sided_stat'", ",", "\n", "'two-sided_pval'", ",", "\n", "'greater_stat'", ",", "\n", "'greater_pval'", ",", "\n", "'less_stat'", ",", "\n", "'less_pval'", ",", "\n", "]", ")", ".", "set_index", "(", "[", "'size'", ",", "'method'", "]", ")", "\n", "\n", "W_other", "=", "W_test", "[", "[", "f'{other}_stat'", ",", "f'{other}_pval'", "]", "]", "\n", "\n", "W_test", ".", "drop", "(", "[", "'two-sided_pval'", ",", "'two-sided_stat'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", ".", "rename", "(", "{", "\n", "f'{which}_pval'", ":", "'p-value'", ",", "\n", "f'{which}_stat'", ":", "'Statistic'", ",", "\n", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "W_other", ".", "rename", "(", "{", "\n", "f'{other}_pval'", ":", "'p-value'", ",", "\n", "f'{other}_stat'", ":", "'Statistic'", ",", "\n", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", ".", "index", ".", "rename", "(", "'Size'", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "W_other", ".", "index", ".", "rename", "(", "'Size'", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "W_test", ".", "index", ".", "rename", "(", "'Method'", ",", "level", "=", "1", ",", "inplace", "=", "True", ")", "\n", "W_other", ".", "index", ".", "rename", "(", "'Method'", ",", "level", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", ".", "drop", "(", "[", "'Statistic'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "W_other", ".", "drop", "(", "[", "'Statistic'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", "=", "pd", ".", "pivot_table", "(", "W_test", ",", "values", "=", "'p-value'", ",", "index", "=", "'Method'", ",", "columns", "=", "'Size'", ")", "\n", "W_other", "=", "pd", ".", "pivot_table", "(", "W_other", ",", "values", "=", "'p-value'", ",", "index", "=", "'Method'", ",", "columns", "=", "'Size'", ")", "\n", "\n", "W_test", "=", "W_test", ".", "reindex", "(", "method_order1", "+", "method_order2", ")", "\n", "W_other", "=", "W_other", ".", "reindex", "(", "method_order1", "+", "method_order2", ")", "\n", "\n", "\n", "if", "graphics_folder", "is", "not", "None", ":", "\n", "        ", "tab_folder", "=", "get_tab_folder", "(", "graphics_folder", ")", "\n", "\n", "if", "csv", ":", "\n", "            ", "W_test", ".", "to_csv", "(", "join", "(", "tab_folder", ",", "f'wilcoxon_{which}.csv'", ")", ")", "\n", "\n", "", "symbols", "=", "{", "}", "\n", "\n", "def", "pvalue_to_symbol", "(", "pvalue", ",", "alpha", ",", "n_bonferroni", ",", "greater", "=", "True", ")", ":", "\n", "            ", "c", "=", "''", "if", "greater", "else", "'(>)'", "\n", "if", "pvalue", "<", "alpha", "/", "n_bonferroni", ":", "\n", "                ", "return", "f'\\\\star\\\\star{c}'", "\n", "", "if", "pvalue", "<", "alpha", ":", "\n", "                ", "return", "f'\\\\star{c}'", "\n", "", "return", "None", "\n", "\n", "", "alpha", "=", "0.05", "\n", "n_bonferroni", "=", "W_test", ".", "shape", "[", "0", "]", "\n", "\n", "for", "size", "in", "W_test", ":", "\n", "            ", "symbols", "[", "size", "]", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "W_test", "[", "size", "]", ".", "iteritems", "(", ")", ":", "\n", "                ", "symbols", "[", "size", "]", "[", "k", "]", "=", "pvalue_to_symbol", "(", "v", ",", "alpha", ",", "n_bonferroni", ",", "greater", "=", "greater", ")", "\n", "", "for", "k", ",", "v", "in", "W_other", "[", "size", "]", ".", "iteritems", "(", ")", ":", "\n", "                ", "if", "symbols", "[", "size", "]", "[", "k", "]", "is", "None", ":", "\n", "                    ", "symbols", "[", "size", "]", "[", "k", "]", "=", "pvalue_to_symbol", "(", "v", ",", "alpha", ",", "n_bonferroni", ",", "greater", "=", "not", "greater", ")", "\n", "\n", "", "", "", "for", "index", ",", "row", "in", "W_test", ".", "iterrows", "(", ")", ":", "\n", "            ", "for", "col", ",", "value", "in", "row", ".", "iteritems", "(", ")", ":", "\n", "                ", "print", "(", "index", ",", "col", ",", "value", ")", "\n", "symbol", "=", "symbols", "[", "col", "]", "[", "index", "]", "\n", "if", "symbol", "is", "not", "None", ":", "\n", "                    ", "W_test", ".", "loc", "[", "index", ",", "col", "]", "=", "f'$\\\\text{{{value:.1e}}}^{{{symbol}}}$'", "\n", "", "elif", "not", "pd", ".", "isna", "(", "value", ")", ":", "\n", "                    ", "W_test", ".", "loc", "[", "index", ",", "col", "]", "=", "f'{value:.1e}'", "\n", "\n", "", "", "", "skip", "=", "'0.15in'", "\n", "\n", "if", "no_rename", ":", "\n", "            ", "rename", "=", "{", "}", "\n", "", "else", ":", "\n", "            ", "rename", "=", "{", "\n", "'Med'", ":", "'Median'", ",", "\n", "'Med+mask'", ":", "'Median+mask'", ",", "\n", "'Iter'", ":", "'Iterative'", ",", "\n", "'Iter+mask'", ":", "'Iterative+mask'", ",", "\n", "}", "\n", "", "if", "spacing", ":", "\n", "            ", "rename", "[", "'Linear+Mean'", "]", "=", "f'\\\\midrule Linear+Mean'", "\n", "rename", "[", "'MI'", "]", "=", "f'\\\\midrule MI'", "\n", "", "W_test", ".", "rename", "(", "rename", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "print", "(", "W_test", ")", "\n", "\n", "W_test", ".", "to_latex", "(", "join", "(", "tab_folder", ",", "f'wilcoxon_{which}.tex'", ")", ",", "na_rep", "=", "''", ",", "escape", "=", "False", ")", "#, table_env='tabularx')", "\n", "\n", "", "return", "W_test", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon_linear": [[449, 590], ["os.path.abspath", "pandas.read_csv", "tasks_to_drop.items", "df[].str.replace", "prediction.df_utils.get_scores_tab", "prediction.df_utils.get_scores_tab.index.get_level_values().unique", "pandas.DataFrame().set_index", "W_test.applymap.drop", "W_test.applymap.rename", "W_test.applymap.index.rename", "W_test.applymap.index.rename", "W_test.applymap.drop", "pandas.pivot_table", "W_test.applymap.reindex", "W_test.applymap.rename", "print", "prediction.df_utils.get_scores_tab.drop", "zip", "numpy.isnan", "custom.const.get_tab_folder", "print", "W_test.applymap.applymap", "W_test.applymap.to_latex", "prediction.df_utils.get_scores_tab.index.get_level_values", "rows.append", "pandas.DataFrame", "W_test.applymap.to_csv", "os.path.join", "idx_na_x.union", "x.drop.drop", "y.drop.drop", "pandas.testing.assert_index_equal", "scipy.stats.wilcoxon", "scipy.stats.wilcoxon", "os.path.join", "tests.run_wilcoxon_linear.pvalue_formatter"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_scores_tab", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename"], ["", "def", "run_wilcoxon_linear", "(", "graphics_folder", ",", "csv", "=", "False", ",", "greater", "=", "True", ")", ":", "\n", "    ", "\"\"\"Wilcoxon test between trees and linear methods, pairwise.\"\"\"", "\n", "path", "=", "os", ".", "path", ".", "abspath", "(", "'scores/scores.csv'", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "\n", "\n", "which", "=", "'greater'", "if", "greater", "else", "'less'", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "df", ".", "drop", "(", "index", "=", "df", "[", "(", "df", "[", "'db'", "]", "==", "db", ")", "&", "(", "df", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "df", "[", "'task'", "]", "=", "df", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "method_order1", "=", "[", "\n", "'Mean'", ",", "\n", "'Mean+mask'", ",", "\n", "'Med'", ",", "\n", "'Med+mask'", ",", "\n", "'Iter'", ",", "\n", "'Iter+mask'", ",", "\n", "'KNN'", ",", "\n", "'KNN+mask'", ",", "\n", "]", "\n", "\n", "method_order2", "=", "[", "\n", "'Linear+Mean'", ",", "\n", "'Linear+Mean+mask'", ",", "\n", "'Linear+Med'", ",", "\n", "'Linear+Med+mask'", ",", "\n", "'Linear+Iter'", ",", "\n", "'Linear+Iter+mask'", ",", "\n", "'Linear+KNN'", ",", "\n", "'Linear+KNN+mask'", ",", "\n", "]", "\n", "\n", "method_order", "=", "method_order1", "+", "method_order2", "\n", "\n", "db_order", "=", "[", "\n", "'TB'", ",", "\n", "'UKBB'", ",", "\n", "'MIMIC'", ",", "\n", "'NHIS'", ",", "\n", "]", "\n", "\n", "df", "=", "get_scores_tab", "(", "df", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "\n", "average_sizes", "=", "False", ",", "formatting", "=", "False", ",", "add_empty_methods", "=", "False", ")", "\n", "sizes", "=", "df", ".", "index", ".", "get_level_values", "(", "0", ")", ".", "unique", "(", ")", "\n", "\n", "rows", "=", "[", "]", "\n", "for", "size", "in", "sizes", ":", "\n", "\n", "        ", "scores", "=", "df", ".", "loc", "[", "size", "]", "\n", "\n", "for", "method1", ",", "method2", "in", "zip", "(", "method_order1", ",", "method_order2", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "scores1", "=", "scores", ".", "loc", "[", "method1", "]", "\n", "scores2", "=", "scores", ".", "loc", "[", "method2", "]", "\n", "\n", "x", ",", "y", "=", "scores1", ",", "scores2", "\n", "\n", "# Drop nans, results are wrong otherwise", "\n", "idx_na_x", "=", "x", "[", "x", ".", "isna", "(", ")", "]", ".", "index", "\n", "idx_na_y", "=", "y", "[", "y", ".", "isna", "(", ")", "]", ".", "index", "\n", "idx_na", "=", "idx_na_x", ".", "union", "(", "idx_na_y", ")", "\n", "\n", "x", "=", "x", ".", "drop", "(", "index", "=", "idx_na", ")", "\n", "y", "=", "y", ".", "drop", "(", "index", "=", "idx_na", ")", "\n", "\n", "pd", ".", "testing", ".", "assert_index_equal", "(", "x", ".", "index", ",", "y", ".", "index", ")", "\n", "assert", "not", "x", ".", "isnull", "(", ")", ".", "any", "(", ")", "\n", "assert", "not", "y", ".", "isnull", "(", ")", ".", "any", "(", ")", "\n", "\n", "w_double", "=", "wilcoxon", "(", "x", "=", "x", ",", "y", "=", "y", ",", "alternative", "=", "'two-sided'", ")", "\n", "w_onesided", "=", "wilcoxon", "(", "x", "=", "x", ",", "y", "=", "y", ",", "alternative", "=", "which", ")", "\n", "\n", "", "except", "KeyError", ":", "\n", "                ", "w_double", "=", "(", "np", ".", "nan", ",", "np", ".", "nan", ")", "\n", "w_onesided", "=", "(", "np", ".", "nan", ",", "np", ".", "nan", ")", "\n", "\n", "", "rows", ".", "append", "(", "[", "size", ",", "method1", ",", "w_double", "[", "0", "]", ",", "w_double", "[", "1", "]", ",", "w_onesided", "[", "0", "]", ",", "w_onesided", "[", "1", "]", "]", ")", "\n", "\n", "", "", "W_test", "=", "pd", ".", "DataFrame", "(", "rows", ",", "columns", "=", "[", "\n", "'size'", ",", "\n", "'imputer'", ",", "\n", "'two-sided_stat'", ",", "\n", "'two-sided_pval'", ",", "\n", "f'{which}_stat'", ",", "\n", "f'{which}_pval'", ",", "\n", "]", ")", ".", "set_index", "(", "[", "'size'", ",", "'imputer'", "]", ")", "\n", "\n", "W_test", ".", "drop", "(", "[", "'two-sided_pval'", ",", "'two-sided_stat'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", ".", "rename", "(", "{", "\n", "f'{which}_pval'", ":", "'p-value'", ",", "\n", "f'{which}_stat'", ":", "'Statistic'", ",", "\n", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", ".", "index", ".", "rename", "(", "'Size'", ",", "level", "=", "0", ",", "inplace", "=", "True", ")", "\n", "W_test", ".", "index", ".", "rename", "(", "'Imputer'", ",", "level", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", ".", "drop", "(", "[", "'Statistic'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "W_test", "=", "pd", ".", "pivot_table", "(", "W_test", ",", "values", "=", "'p-value'", ",", "index", "=", "'Imputer'", ",", "columns", "=", "'Size'", ")", "\n", "\n", "W_test", "=", "W_test", ".", "reindex", "(", "method_order1", ")", "\n", "\n", "W_test", ".", "rename", "(", "{", "\n", "'Med'", ":", "'Median'", ",", "\n", "'Med+mask'", ":", "'Median+mask'", ",", "\n", "'Iter'", ":", "'Iterative'", ",", "\n", "'Iter+mask'", ":", "'Iterative+mask'", ",", "\n", "}", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "\n", "def", "pvalue_formatter", "(", "x", ",", "alpha", ",", "n_bonferroni", ",", "greater", "=", "True", ")", ":", "\n", "        ", "c", "=", "''", "if", "greater", "else", "'(>)'", "\n", "if", "np", ".", "isnan", "(", "x", ")", ":", "\n", "            ", "return", "x", "\n", "", "else", ":", "\n", "            ", "if", "x", "<", "alpha", "/", "n_bonferroni", ":", "# below bonferroni corrected alpha level", "\n", "                ", "return", "f'$\\\\text{{{x:.1e}}}^{{\\\\star\\\\star{c}}}$'", "\n", "\n", "", "if", "x", "<", "alpha", ":", "# below alpha level but above bonferroni", "\n", "                ", "return", "f'$\\\\text{{{x:.1e}}}^{{\\\\star{c}}}$'", "\n", "\n", "", "return", "f'{x:.1e}'", "\n", "\n", "", "", "print", "(", "W_test", ")", "\n", "\n", "if", "graphics_folder", "is", "not", "None", ":", "\n", "        ", "tab_folder", "=", "get_tab_folder", "(", "graphics_folder", ")", "\n", "\n", "if", "csv", ":", "\n", "            ", "W_test", ".", "to_csv", "(", "join", "(", "tab_folder", ",", "f'wilcoxon_linear_{which}.csv'", ")", ")", "\n", "\n", "", "print", "(", "f'Apply Bonferroni correction with {W_test.shape[0]} values.'", ")", "\n", "# print(W_test)", "\n", "# exit()", "\n", "W_test", "=", "W_test", ".", "applymap", "(", "lambda", "x", ":", "pvalue_formatter", "(", "x", ",", "alpha", "=", "0.05", ",", "n_bonferroni", "=", "W_test", ".", "shape", "[", "0", "]", ")", ")", "\n", "W_test", ".", "to_latex", "(", "join", "(", "tab_folder", ",", "f'wilcoxon_linear_{which}.tex'", ")", ",", "na_rep", "=", "''", ",", "escape", "=", "False", ")", "#, table_env='tabularx')", "\n", "\n", "", "return", "W_test", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon": [[592, 596], ["tests.run_wilcoxon_mia", "tests.run_wilcoxon_linear"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon_mia", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon_linear"], ["", "def", "run_wilcoxon", "(", "graphics_folder", ",", "linear", "=", "False", ",", "csv", "=", "False", ",", "greater", "=", "True", ",", "spacing", "=", "True", ",", "no_rename", "=", "False", ")", ":", "\n", "    ", "if", "linear", ":", "\n", "        ", "return", "run_wilcoxon_linear", "(", "graphics_folder", ",", "csv", "=", "csv", ",", "greater", "=", "greater", ")", "\n", "", "return", "run_wilcoxon_mia", "(", "graphics_folder", ",", "csv", "=", "csv", ",", "greater", "=", "greater", ",", "spacing", "=", "spacing", ",", "no_rename", "=", "no_rename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_friedman": [[598, 749], ["pandas.concat", "tasks_to_drop.items", "df[].str.replace", "prediction.df_utils.get_ranks_tab", "prediction.df_utils.get_ranks_tab.index.get_level_values().unique", "prediction.df_utils.get_ranks_tab.drop", "pandas.DataFrame", "df_statistic.applymap.applymap", "matplotlib.subplots", "enumerate", "custom.const.get_fig_folder", "custom.const.get_tab_folder", "matplotlib.savefig", "print", "df_statistic.applymap.rename", "df_statistic.applymap.applymap", "df_statistic.applymap.rename", "df_statistic.applymap.to_latex", "pandas.read_csv", "prediction.df_utils.get_ranks_tab.drop", "tests.friedman_statistic", "rows.append", "numpy.isnan", "prediction.df_utils.get_ranks_tab.rename", "fig.subplots_adjust", "prediction.df_utils.get_ranks_tab.rename", "axes.reshape", "df_statistic[].astype", "tests.plot_ranks", "ax.set_title", "os.path.join", "df_statistic.applymap.to_csv", "pandas.isnull", "os.path.join", "prediction.df_utils.get_ranks_tab.index.get_level_values", "os.path.join", "abs", "df.drop.loc[].isna().all", "float", "df.drop.loc[].isna"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.get_ranks_tab", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.friedman_statistic", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.plot_ranks"], ["", "def", "run_friedman", "(", "graphics_folder", ",", "linear", "=", "False", ",", "csv", "=", "False", ",", "ref", "=", "None", ")", ":", "\n", "    ", "fontsize_subtitle", "=", "13", "\n", "# path = os.path.abspath('scores/scores.csv')", "\n", "# df = pd.read_csv(path, index_col=0)", "\n", "\n", "# filepaths = [", "\n", "#     'scores/scores.csv',", "\n", "#     'scores/scores_mi_2500.csv',", "\n", "#     'scores/scores_mia_2500.csv',", "\n", "#     'scores/scores_mi_10000.csv',", "\n", "#     'scores/scores_mia_10000.csv',", "\n", "#     'scores/scores_mia_25000.csv',", "\n", "#     'scores/scores_mi_25000.csv',", "\n", "#     'scores/scores_mia_100000.csv',", "\n", "#     'scores/scores_mean+mask+bagging_2500.csv',", "\n", "# ]", "\n", "dfs", "=", "[", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "for", "path", "in", "filepaths", "]", "\n", "df", "=", "pd", ".", "concat", "(", "dfs", ",", "axis", "=", "0", ")", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "df", ".", "drop", "(", "index", "=", "df", "[", "(", "df", "[", "'db'", "]", "==", "db", ")", "&", "(", "df", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "df", "[", "'task'", "]", "=", "df", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "if", "linear", ":", "\n", "        ", "method_order", "=", "[", "\n", "'MIA'", ",", "\n", "'Linear+Mean'", ",", "\n", "'Linear+Mean+mask'", ",", "\n", "'Linear+Med'", ",", "\n", "'Linear+Med+mask'", ",", "\n", "'Linear+Iter'", ",", "\n", "'Linear+Iter+mask'", ",", "\n", "'Linear+KNN'", ",", "\n", "'Linear+KNN+mask'", ",", "\n", "]", "\n", "\n", "", "else", ":", "\n", "        ", "method_order", "=", "[", "\n", "'MIA'", ",", "\n", "'Mean'", ",", "\n", "'Mean+mask'", ",", "\n", "'Med'", ",", "\n", "'Med+mask'", ",", "\n", "'Iter'", ",", "\n", "'Iter+mask'", ",", "\n", "'KNN'", ",", "\n", "'KNN+mask'", ",", "\n", "'MI'", ",", "\n", "'MI+mask'", ",", "\n", "'MIA+bagging'", ",", "\n", "]", "\n", "\n", "", "db_order", "=", "[", "\n", "'TB'", ",", "\n", "'UKBB'", ",", "\n", "'MIMIC'", ",", "\n", "'NHIS'", ",", "\n", "]", "\n", "\n", "df", "=", "get_ranks_tab", "(", "df", ",", "method_order", "=", "method_order", ",", "db_order", "=", "db_order", ",", "\n", "average_sizes", "=", "False", ",", "add_empty_methods", "=", "False", ")", "\n", "sizes", "=", "df", ".", "index", ".", "get_level_values", "(", "0", ")", ".", "unique", "(", ")", "\n", "\n", "ranks_by_db", "=", "df", ".", "drop", "(", "'Average'", ",", "level", "=", "0", ",", "axis", "=", "1", ")", "\n", "\n", "rows", "=", "[", "]", "\n", "for", "size", "in", "sizes", ":", "\n", "        ", "ranks", "=", "df", ".", "loc", "[", "size", ",", "(", "'Average'", ",", "'All'", ")", "]", "\n", "N", "=", "(", "~", "ranks_by_db", ".", "loc", "[", "size", "]", ".", "isna", "(", ")", ".", "all", "(", "axis", "=", "0", ")", ")", ".", "sum", "(", ")", "\n", "\n", "XF2", ",", "XF2_pval", ",", "FF", ",", "FF_pval", ",", "CD", "=", "friedman_statistic", "(", "ranks", ",", "N", ")", "\n", "rows", ".", "append", "(", "[", "XF2", ",", "XF2_pval", ",", "FF", ",", "FF_pval", ",", "CD", ",", "N", "]", ")", "\n", "\n", "", "df_statistic", "=", "pd", ".", "DataFrame", "(", "rows", ",", "columns", "=", "[", "'XF2'", ",", "'XF2_pval'", ",", "'FF'", ",", "'FF_pval'", ",", "'CD'", ",", "'N'", "]", ",", "index", "=", "sizes", ")", "\n", "\n", "def", "myround", "(", "x", ")", ":", "\n", "        ", "if", "np", ".", "isnan", "(", "x", ")", ":", "\n", "            ", "return", "x", "\n", "", "else", ":", "\n", "            ", "if", "abs", "(", "x", ")", "<", "0.1", ":", "\n", "                ", "return", "f'{x:.1e}'", "\n", "", "else", ":", "\n", "                ", "return", "f'{x:.2g}'", "\n", "\n", "", "", "", "df_statistic", "=", "df_statistic", ".", "applymap", "(", "myround", ")", "\n", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "2", ",", "2", ",", "figsize", "=", "(", "7", ",", "8", ")", ")", "\n", "\n", "if", "linear", ":", "\n", "        ", "df", ".", "rename", "(", "{", "'MIA'", ":", "'Boosted trees+MIA'", "}", ",", "axis", "=", "0", ",", "inplace", "=", "True", ")", "\n", "fig", ".", "subplots_adjust", "(", "wspace", "=", "0.37", ")", "\n", "\n", "", "else", ":", "\n", "        ", "rename", "=", "{", "\n", "'Med'", ":", "'Median'", ",", "\n", "'Med+mask'", ":", "'Median+mask'", ",", "\n", "'Iter'", ":", "'Iterative'", ",", "\n", "'Iter+mask'", ":", "'Iterative+mask'", ",", "\n", "'MIA+bagging'", ":", "'MIA+Bagging'", ",", "\n", "'MI'", ":", "'Iterative+Bagging'", ",", "\n", "'MI+mask'", ":", "'Iterative+mask+Bagging'", ",", "\n", "}", "\n", "df", ".", "rename", "(", "rename", ",", "axis", "=", "0", ",", "level", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "", "for", "i", ",", "ax", "in", "enumerate", "(", "axes", ".", "reshape", "(", "-", "1", ")", ")", ":", "\n", "        ", "size", "=", "sizes", "[", "i", "]", "\n", "ranks", "=", "df", ".", "loc", "[", "size", ",", "(", "'Average'", ",", "'All'", ")", "]", "\n", "critical_distances", "=", "df_statistic", "[", "'CD'", "]", ".", "astype", "(", "float", ")", "\n", "\n", "plot_ranks", "(", "ranks", ",", "critical_distances", "[", "size", "]", ",", "ax", ",", "ref", "=", "ref", ")", "\n", "N", "=", "df_statistic", ".", "loc", "[", "size", ",", "'N'", "]", "\n", "ax", ".", "set_title", "(", "f'Size={size}, N={N}'", ",", "{", "'fontsize'", ":", "fontsize_subtitle", "}", ")", "\n", "\n", "", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "tab_folder", "=", "get_tab_folder", "(", "graphics_folder", ")", "\n", "\n", "tab_name", "=", "'friedman_linear'", "if", "linear", "else", "'friedman'", "\n", "fig_name", "=", "'critical_distance_linear'", "if", "linear", "else", "'critical_distance'", "\n", "\n", "plt", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "\n", "print", "(", "df_statistic", ")", "\n", "\n", "if", "csv", ":", "\n", "        ", "df_statistic", ".", "to_csv", "(", "join", "(", "tab_folder", ",", "f'{tab_name}.csv'", ")", ")", "\n", "\n", "# Preprocessing for latex dump", "\n", "", "df_statistic", ".", "rename", "(", "{", "\n", "'XF2'", ":", "r'$\\chi^2_F$'", ",", "\n", "'XF2_pval'", ":", "r'$\\chi^2_F$ p-value'", ",", "\n", "'FF'", ":", "r'$F_F$'", ",", "\n", "'FF_pval'", ":", "r'$F_F$ p-value'", ",", "\n", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "def", "space", "(", "x", ")", ":", "\n", "        ", "if", "pd", ".", "isnull", "(", "x", ")", ":", "\n", "            ", "return", "x", "\n", "", "else", ":", "\n", "            ", "space", "=", "''", "if", "float", "(", "x", ")", "<", "0", "else", "r'\\hphantom{-}'", "\n", "return", "f'{space}{x}'", "\n", "\n", "", "", "df_statistic", "=", "df_statistic", ".", "applymap", "(", "space", ")", "\n", "df_statistic", ".", "rename", "(", "\n", "{", "v", ":", "f'\\hphantom{{-}}{v}'", "for", "v", "in", "df_statistic", ".", "columns", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "df_statistic", ".", "to_latex", "(", "join", "(", "\n", "tab_folder", ",", "f'{tab_name}.tex'", ")", ",", "na_rep", "=", "''", ",", "escape", "=", "False", ")", "#, table_env='tabularx')", "\n", "\n", "return", "df_statistic", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.plot_ranks": [[751, 796], ["average_ranks.sort_values.sort_values", "numpy.min", "ax.spines[].set_position", "ax.spines[].set_color", "ax.spines[].set_color", "ax.spines[].set_color", "ax.xaxis.set_visible", "ax.yaxis.set_ticks_position", "ax.set_ylim", "ax.set_xlim", "ax.invert_yaxis", "ax.scatter", "ax.plot", "ax.text", "numpy.linspace", "enumerate", "numpy.min", "len", "numpy.zeros_like", "len", "average_ranks.sort_values.iteritems", "ax.text", "texts.append", "ax.plot", "numpy.ones", "len", "abs", "abs"], "function", ["None"], ["", "def", "plot_ranks", "(", "average_ranks", ",", "critical_distance", ",", "ax", ",", "ref", "=", "None", ")", ":", "\n", "    ", "fontsize_method", "=", "13", "\n", "\n", "average_ranks", "=", "average_ranks", ".", "sort_values", "(", ")", "\n", "\n", "if", "ref", "is", "None", ":", "\n", "        ", "ref_rank", "=", "np", ".", "min", "(", "average_ranks", ")", "\n", "", "else", ":", "\n", "        ", "ref_rank", "=", "average_ranks", "[", "ref", "]", "\n", "\n", "", "ref_rank_colors", "=", "ref_rank", "\n", "ref_rank_difference", "=", "np", ".", "min", "(", "average_ranks", ")", "\n", "\n", "# Move left y-axis and bottim x-axis to centre, passing through (0,0)", "\n", "xmin", "=", "-", ".11", "\n", "xmax", "=", ".5", "\n", "ax", ".", "spines", "[", "'left'", "]", ".", "set_position", "(", "(", "'axes'", ",", "abs", "(", "xmin", ")", "/", "(", "xmax", "-", "xmin", ")", ")", ")", "\n", "ax", ".", "spines", "[", "'bottom'", "]", ".", "set_color", "(", "'none'", ")", "\n", "\n", "# Eliminate upper and right axes", "\n", "ax", ".", "spines", "[", "'right'", "]", ".", "set_color", "(", "'none'", ")", "\n", "ax", ".", "spines", "[", "'top'", "]", ".", "set_color", "(", "'none'", ")", "\n", "\n", "# Show ticks in the left and lower axes only", "\n", "ax", ".", "xaxis", ".", "set_visible", "(", "False", ")", "#.set_ticks_position('none')", "\n", "ax", ".", "yaxis", ".", "set_ticks_position", "(", "'left'", ")", "\n", "ax", ".", "set_ylim", "(", "1", ",", "len", "(", "average_ranks", ")", ")", "\n", "ax", ".", "set_xlim", "(", "xmin", ",", "xmax", ")", "\n", "ax", ".", "invert_yaxis", "(", ")", "\n", "\n", "colors", "=", "[", "'red'", "if", "abs", "(", "r", "-", "ref_rank_colors", ")", "<", "critical_distance", "else", "'black'", "for", "r", "in", "average_ranks", "]", "\n", "ax", ".", "scatter", "(", "np", ".", "zeros_like", "(", "average_ranks", ")", ",", "average_ranks", ",", "\n", "color", "=", "colors", ",", "marker", "=", "'.'", ",", "clip_on", "=", "False", ",", "zorder", "=", "10", ")", "\n", "ax", ".", "plot", "(", "-", ".06", "*", "np", ".", "ones", "(", "2", ")", ",", "[", "ref_rank_difference", ",", "ref_rank_difference", "+", "critical_distance", "]", ",", "color", "=", "'red'", ",", "\n", "marker", "=", "'_'", ",", "markeredgewidth", "=", "1.5", ")", "\n", "ax", ".", "text", "(", "-", ".08", ",", "ref_rank_difference", "+", "critical_distance", "/", "2", ",", "'critical difference'", ",", "rotation", "=", "90", ",", "\n", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "color", "=", "'red'", ",", "fontsize", "=", "12", ")", "\n", "\n", "texts", "=", "[", "]", "\n", "y_pos", "=", "np", ".", "linspace", "(", "1.5", ",", "len", "(", "average_ranks", ")", "-", ".5", ",", "len", "(", "average_ranks", ")", ")", "\n", "for", "i", ",", "(", "method", ",", "rank", ")", "in", "enumerate", "(", "average_ranks", ".", "iteritems", "(", ")", ")", ":", "\n", "        ", "t", "=", "ax", ".", "text", "(", ".12", ",", "y_pos", "[", "i", "]", ",", "method", ",", "va", "=", "'center'", ",", "\n", "fontsize", "=", "fontsize_method", ")", "\n", "texts", ".", "append", "(", "t", ")", "\n", "ax", ".", "plot", "(", "[", "0", ",", ".12", "]", ",", "[", "rank", ",", "y_pos", "[", "i", "]", "]", ",", "color", "=", "'black'", ",", "ls", "=", "':'", ",", "lw", "=", "0.25", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_global": [[12, 80], ["print", "pandas.DataFrame", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "ax.get_position", "ax.set_position", "ax.legend", "ax.set", "ax.set_title", "seaborn.despine", "ax.tick_params", "matplotlib.subplots"], "function", ["None"], ["def", "plot_global", "(", "indicators", ",", "plot", "=", "False", ",", "show", "=", "True", ",", "ax", "=", "None", ")", ":", "\n", "    ", "\"\"\"Plot statistics on the full database.\"\"\"", "\n", "# Get required indicators", "\n", "df", "=", "indicators", "[", "'global'", "]", "\n", "\n", "n_rows", "=", "df", ".", "at", "[", "0", ",", "'n_rows'", "]", "\n", "n_cols", "=", "df", ".", "at", "[", "0", ",", "'n_cols'", "]", "\n", "n_values", "=", "df", ".", "at", "[", "0", ",", "'n_values'", "]", "\n", "n_mv", "=", "df", ".", "at", "[", "0", ",", "'n_mv'", "]", "\n", "n_mv1", "=", "df", ".", "at", "[", "0", ",", "'n_mv1'", "]", "\n", "n_mv2", "=", "df", ".", "at", "[", "0", ",", "'n_mv2'", "]", "\n", "n_not_mv", "=", "df", ".", "at", "[", "0", ",", "'n_not_mv'", "]", "\n", "f_mv", "=", "df", ".", "at", "[", "0", ",", "'f_mv'", "]", "\n", "f_mv1", "=", "df", ".", "at", "[", "0", ",", "'f_mv1'", "]", "\n", "f_mv2", "=", "df", ".", "at", "[", "0", ",", "'f_mv2'", "]", "\n", "f_not_mv", "=", "df", ".", "at", "[", "0", ",", "'f_not_mv'", "]", "\n", "\n", "# Print these statistics", "\n", "if", "show", ":", "\n", "        ", "print", "(", "\n", "f'\\n'", "\n", "f'Statistics on the full data frame:\\n'", "\n", "f'---------------------------------\\n'", "\n", "f'[{n_rows} rows x {n_cols} columns]\\n'", "\n", "f'{n_values} values\\n'", "\n", "f'N NMV:    {f_not_mv:.1f}% or {n_not_mv}\\n'", "\n", "f'N MV:     {f_mv:.1f}% or {n_mv}\\n'", "\n", "f'    N MV 1:   {f_mv1:.1f}% or {n_mv1}\\n'", "\n", "f'    N MV 2:   {f_mv2:.1f}% or {n_mv2}\\n'", "\n", ")", "\n", "\n", "# If asked, plot these statistics", "\n", "", "if", "plot", ":", "\n", "        ", "if", "ax", "is", "None", ":", "\n", "            ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "10", ",", "4", ")", ")", "\n", "\n", "", "df_show", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'MV1'", ":", "[", "n_mv1", "]", ",", "\n", "'MV2'", ":", "[", "n_mv2", "]", ",", "\n", "'MV'", ":", "[", "n_mv", "]", ",", "\n", "'V'", ":", "[", "n_values", "]", ",", "\n", "'type'", ":", "[", "'Full data frame'", "]", "\n", "}", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'pastel'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'V'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'lightgray'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Not missing ({f_not_mv:.1f}%)'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'muted'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'MV'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'b'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Missing - Not applicable ({f_mv1:.1f}%)'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'dark'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'MV2'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'b'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Missing - Not available ({f_mv2:.1f}%)'", ")", "\n", "\n", "box", "=", "ax", ".", "get_position", "(", ")", "\n", "ax", ".", "set_position", "(", "[", "box", ".", "x0", ",", "box", ".", "y0", ",", "box", ".", "width", "*", "0.5", ",", "box", ".", "height", "*", "0.5", "]", ")", "\n", "\n", "ax", ".", "legend", "(", "ncol", "=", "1", ",", "loc", "=", "'center left'", ",", "frameon", "=", "True", ",", "\n", "title", "=", "'Type of values'", ",", "\n", "bbox_to_anchor", "=", "(", "1.05", ",", "0.5", ")", ")", "\n", "ax", ".", "set", "(", "ylabel", "=", "''", ",", "xlabel", "=", "f'Number of values (Total {n_values})'", ")", "\n", "ax", ".", "set_title", "(", "'Proportion of missing values'", ")", "\n", "sns", ".", "despine", "(", "left", "=", "True", ",", "bottom", "=", "True", ",", "ax", "=", "ax", ")", "\n", "\n", "# Remove y labels", "\n", "ax", ".", "tick_params", "(", "axis", "=", "'y'", ",", "which", "=", "'both'", ",", "left", "=", "False", ",", "labelleft", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_features": [[82, 154], ["pandas.concat", "print", "pandas.DataFrame", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "ax.get_position", "ax.set_position", "ax.legend", "ax.set", "ax.set_title", "seaborn.despine", "ax.tick_params", "matplotlib.subplots"], "function", ["None"], ["", "", "def", "plot_features", "(", "indicators", ",", "plot", "=", "False", ",", "show", "=", "True", ",", "ax", "=", "None", ")", ":", "\n", "    ", "\"\"\"Plot the number of features with missing values.\"\"\"", "\n", "# Get required indicators", "\n", "df", "=", "pd", ".", "concat", "(", "[", "indicators", "[", "'features'", "]", ",", "indicators", "[", "'global'", "]", "]", ",", "axis", "=", "1", ")", "\n", "\n", "n_f_w_mv", "=", "df", ".", "at", "[", "0", ",", "'n_f_w_mv'", "]", "\n", "n_f_w_mv1_o", "=", "df", ".", "at", "[", "0", ",", "'n_f_w_mv1_o'", "]", "\n", "n_f_w_mv2_o", "=", "df", ".", "at", "[", "0", ",", "'n_f_w_mv2_o'", "]", "\n", "n_f_w_mv_1a2", "=", "df", ".", "at", "[", "0", ",", "'n_f_w_mv_1a2'", "]", "\n", "n_f_wo_mv", "=", "df", ".", "at", "[", "0", ",", "'n_f_wo_mv'", "]", "\n", "f_f_w_mv", "=", "df", ".", "at", "[", "0", ",", "'f_f_w_mv'", "]", "\n", "f_f_w_mv1_o", "=", "df", ".", "at", "[", "0", ",", "'f_f_w_mv1_o'", "]", "\n", "f_f_w_mv2_o", "=", "df", ".", "at", "[", "0", ",", "'f_f_w_mv2_o'", "]", "\n", "f_f_w_mv_1a2", "=", "df", ".", "at", "[", "0", ",", "'f_f_w_mv_1a2'", "]", "\n", "f_f_wo_mv", "=", "df", ".", "at", "[", "0", ",", "'f_f_wo_mv'", "]", "\n", "\n", "n_cols", "=", "df", ".", "at", "[", "0", ",", "'n_cols'", "]", "\n", "\n", "if", "show", ":", "\n", "        ", "print", "(", "\n", "f'\\n'", "\n", "f'Statistics on features:\\n'", "\n", "f'-----------------------\\n'", "\n", "f'N features: {n_cols}\\n'", "\n", "f'N features with MV:              {n_f_w_mv} ({f_f_w_mv:.1f}%)\\n'", "\n", "f'    N features with MV1 only:    {n_f_w_mv1_o} ({f_f_w_mv1_o:.1f}%)\\n'", "\n", "f'    N features with MV2 only:    {n_f_w_mv2_o} ({f_f_w_mv2_o:.1f}%)\\n'", "\n", "f'    N features with MV1 and MV2: {n_f_w_mv_1a2} ({f_f_w_mv_1a2:.1f}%)\\n'", "\n", ")", "\n", "\n", "", "if", "plot", ":", "\n", "# Plot proportion of features with missing values", "\n", "        ", "df_show", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'N MV'", ":", "[", "n_f_w_mv", "]", ",", "\n", "'N MV1 only'", ":", "[", "n_f_w_mv1_o", "]", ",", "\n", "'N MV2 only'", ":", "[", "n_f_w_mv2_o", "]", ",", "\n", "'N MV 1 xor 2'", ":", "[", "n_f_w_mv1_o", "+", "n_f_w_mv2_o", "]", ",", "\n", "'N F'", ":", "[", "n_cols", "]", ",", "\n", "'type'", ":", "[", "'Full data frame'", "]", "\n", "}", ")", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "10", ",", "4", ")", ")", "\n", "\n", "", "sns", ".", "set_color_codes", "(", "'pastel'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N F'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'lightgray'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'No missing values ({n_f_wo_mv} \u2022 {f_f_wo_mv:.1f}%)'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'pastel'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N MV'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'g'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Not applicable and not available ({n_f_w_mv_1a2} \u2022 {f_f_w_mv_1a2:.1f}%)'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'muted'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N MV 1 xor 2'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'g'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Not applicable only ({n_f_w_mv1_o} \u2022 {f_f_w_mv1_o:.1f}%)'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'dark'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N MV2 only'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'g'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Not available only ({n_f_w_mv2_o} \u2022 {f_f_w_mv2_o:.1f}%)'", ")", "\n", "\n", "box", "=", "ax", ".", "get_position", "(", ")", "\n", "ax", ".", "set_position", "(", "[", "box", ".", "x0", ",", "box", ".", "y0", ",", "box", ".", "width", "*", "0.5", ",", "box", ".", "height", "*", "0.5", "]", ")", "\n", "\n", "ax", ".", "legend", "(", "ncol", "=", "1", ",", "loc", "=", "'center left'", ",", "frameon", "=", "True", ",", "\n", "title", "=", "'Type of missing values contained in the feature'", ",", "\n", "bbox_to_anchor", "=", "(", "1.05", ",", "0.5", ")", ")", "\n", "ax", ".", "set", "(", "ylabel", "=", "''", ",", "xlabel", "=", "f'Number of features (Total {n_cols})'", ")", "\n", "ax", ".", "set_title", "(", "'Proportion of features having missing values'", ")", "\n", "sns", ".", "despine", "(", "left", "=", "True", ",", "bottom", "=", "True", ",", "ax", "=", "ax", ")", "\n", "\n", "# Remove y labels", "\n", "ax", ".", "tick_params", "(", "axis", "=", "'y'", ",", "which", "=", "'both'", ",", "left", "=", "False", ",", "labelleft", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_feature_wise": [[156, 230], ["n_mv_fw_l.head.head", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "ax.legend", "ax.set", "ax.tick_params", "seaborn.despine", "pandas.option_context", "print", "n_mv_fw[].apply", "matplotlib.subplots", "matplotlib.gcf", "ax.tick_params", "plt.gcf.tight_layout", "plt.gcf.tight_layout", "n_mv_fw[].astype", "len"], "function", ["None"], ["", "", "def", "plot_feature_wise", "(", "indicators", ",", "plot", "=", "False", ",", "show", "=", "True", ",", "ax", "=", "None", ",", "nf_max", "=", "40", ")", ":", "\n", "    ", "\"\"\"Plot the statistics feature-wise.\"\"\"", "\n", "n_mv_fw", "=", "indicators", "[", "'feature-wise'", "]", "\n", "\n", "n_rows", "=", "indicators", "[", "'global'", "]", ".", "at", "[", "0", ",", "'n_rows'", "]", "\n", "\n", "if", "show", ":", "\n", "        ", "with", "pd", ".", "option_context", "(", "'display.max_rows'", ",", "None", ")", ":", "\n", "            ", "print", "(", "\n", "f'\\n'", "\n", "f'Statistics feature-wise:\\n'", "\n", "f'------------------------\\n'", "\n", "f'\\n'", "\n", "f'{n_mv_fw}'", "\n", ")", "\n", "\n", "", "", "if", "plot", ":", "\n", "# Plot proportion of missing values in each feature", "\n", "# Copy index in a column for the barplot method", "\n", "        ", "n_mv_fw", "[", "'feature'", "]", "=", "n_mv_fw", ".", "index", "\n", "n_mv_fw", "[", "'feature_shortened'", "]", "=", "n_mv_fw", "[", "'id'", "]", ".", "astype", "(", "str", ")", "+", "': '", "+", "n_mv_fw", ".", "index", "\n", "\n", "# Truncate", "\n", "if", "n_mv_fw", ".", "shape", "[", "0", "]", "<=", "nf_max", ":", "\n", "            ", "def", "truncate", "(", "string", ")", ":", "\n", "                ", "if", "len", "(", "string", ")", "<=", "20", ":", "\n", "                    ", "return", "string", "\n", "", "return", "string", "[", ":", "27", "]", "+", "'...'", "\n", "\n", "", "n_mv_fw", "[", "'feature_shortened'", "]", "=", "n_mv_fw", "[", "'feature_shortened'", "]", ".", "apply", "(", "truncate", ")", "\n", "\n", "# Add the total number of values for each feature", "\n", "", "n_mv_fw", "[", "'N V'", "]", "=", "n_rows", "\n", "\n", "# Get rid of the features with no missing values", "\n", "n_mv_fw_l", "=", "n_mv_fw", "[", "(", "n_mv_fw", "[", "'N MV1'", "]", "!=", "0", ")", "|", "(", "n_mv_fw", "[", "'N MV2'", "]", "!=", "0", ")", "]", "\n", "\n", "n_mv_fw_l", "=", "n_mv_fw_l", ".", "head", "(", "20", ")", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "10", ",", "8", ")", ")", "\n", "", "else", ":", "\n", "            ", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "\n", "", "if", "n_mv_fw_l", ".", "empty", ":", "\n", "            ", "return", "fig", ",", "ax", "\n", "\n", "", "sns", ".", "set_color_codes", "(", "'pastel'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N V'", ",", "y", "=", "'feature_shortened'", ",", "data", "=", "n_mv_fw_l", ",", "ax", "=", "ax", ",", "\n", "color", "=", "'lightgray'", ",", "label", "=", "f'Not missing'", ",", "dodge", "=", "False", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'muted'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N MV'", ",", "y", "=", "'feature_shortened'", ",", "data", "=", "n_mv_fw_l", ",", "ax", "=", "ax", ",", "\n", "color", "=", "'b'", ",", "label", "=", "f'Missing - Not applicable'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "\"dark\"", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N MV2'", ",", "y", "=", "'feature_shortened'", ",", "data", "=", "n_mv_fw_l", ",", "ax", "=", "ax", ",", "\n", "color", "=", "\"b\"", ",", "label", "=", "f'Missing - Not available'", ")", "\n", "\n", "ax", ".", "legend", "(", "ncol", "=", "1", ",", "loc", "=", "'lower right'", ",", "frameon", "=", "True", ",", "\n", "title", "=", "'Type of values'", ")", "\n", "ax", ".", "set", "(", "ylabel", "=", "'Features'", ",", "xlabel", "=", "'Number of values'", ")", "\n", "ax", ".", "tick_params", "(", "labelsize", "=", "7", ")", "\n", "sns", ".", "despine", "(", "left", "=", "True", ",", "bottom", "=", "True", ",", "ax", "=", "ax", ")", "\n", "\n", "# Remove y labels if more than 40", "\n", "if", "n_mv_fw_l", ".", "shape", "[", "0", "]", ">", "nf_max", ":", "\n", "            ", "ax", ".", "tick_params", "(", "axis", "=", "'y'", ",", "which", "=", "'both'", ",", "left", "=", "False", ",", "labelleft", "=", "False", ")", "\n", "fig", ".", "tight_layout", "(", "rect", "=", "(", "0", ",", "0", ",", "1", ",", ".92", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "fig", ".", "tight_layout", "(", "rect", "=", "(", "0.", ",", "0", ",", "1", ",", ".92", ")", ")", "\n", "\n", "", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_feature_wise_v2": [[232, 281], ["numpy.arange", "seaborn.set_color_codes", "ax.stackplot", "ax.stackplot", "ax.tick_params", "seaborn.despine", "pandas.option_context", "print", "matplotlib.subplots", "matplotlib.gcf", "plt.gcf.tight_layout", "plt.gcf.tight_layout"], "function", ["None"], ["", "", "def", "plot_feature_wise_v2", "(", "indicators", ",", "plot", "=", "False", ",", "show", "=", "True", ",", "ax", "=", "None", ",", "nf_max", "=", "40", ",", "color", "=", "'b'", ")", ":", "\n", "    ", "\"\"\"Plot the statistics feature-wise.\"\"\"", "\n", "n_mv_fw", "=", "indicators", "[", "'feature-wise'", "]", "\n", "\n", "if", "show", ":", "\n", "        ", "with", "pd", ".", "option_context", "(", "'display.max_rows'", ",", "None", ")", ":", "\n", "            ", "print", "(", "\n", "f'\\n'", "\n", "f'Statistics feature-wise:\\n'", "\n", "f'------------------------\\n'", "\n", "f'\\n'", "\n", "f'{n_mv_fw}'", "\n", ")", "\n", "\n", "", "", "if", "plot", ":", "\n", "# Plot proportion of missing values in each feature", "\n", "# Copy index in a column for the barplot method", "\n", "        ", "n_mv_fw", "[", "'feature'", "]", "=", "n_mv_fw", ".", "index", "\n", "\n", "n_mv_fw", "[", "'id'", "]", "=", "np", ".", "arange", "(", "n_mv_fw", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# Get rid of the features with no missing values", "\n", "n_mv_fw_l", "=", "n_mv_fw", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "10", ",", "8", ")", ")", "\n", "", "else", ":", "\n", "            ", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "\n", "", "sns", ".", "set_color_codes", "(", "'pastel'", ")", "\n", "handle_nm", ",", "=", "ax", ".", "stackplot", "(", "n_mv_fw_l", "[", "'id'", "]", ".", "values", ",", "100", ",", "color", "=", "'lightgray'", ",", "labels", "=", "[", "'Not missing'", "]", ")", "\n", "handle_m", ",", "=", "ax", ".", "stackplot", "(", "n_mv_fw_l", "[", "'id'", "]", ".", "values", ",", "n_mv_fw_l", "[", "'F MV'", "]", ".", "values", ",", "color", "=", "color", ",", "labels", "=", "[", "'Missing'", "]", ")", "\n", "# ax.stackplot(n_mv_fw_l['id'].values, n_mv_fw_l['N V'].values, color='lightgray', labels=['Not missing'])", "\n", "# ax.stackplot(n_mv_fw_l['id'].values, n_mv_fw_l['N MV'].values, color='b', labels=['Missing'])", "\n", "\n", "# ax.legend(ncol=1, loc='upper right', frameon=True,", "\n", "#           title='Type of values')", "\n", "# ax.set(xlabel='Features', ylabel='Proportion')", "\n", "# ax.set(xlabel='Features', ylabel='Number of values')", "\n", "ax", ".", "tick_params", "(", "labelsize", "=", "7", ")", "\n", "sns", ".", "despine", "(", "left", "=", "True", ",", "bottom", "=", "True", ",", "ax", "=", "ax", ")", "\n", "\n", "# Remove y labels if more than 40", "\n", "if", "n_mv_fw", ".", "shape", "[", "0", "]", ">", "nf_max", ":", "\n", "            ", "fig", ".", "tight_layout", "(", "rect", "=", "(", "0", ",", "0", ",", "1", ",", ".92", ")", ")", "\n", "", "else", ":", "\n", "            ", "fig", ".", "tight_layout", "(", "rect", "=", "(", "0.", ",", "0", ",", "1", ",", ".92", ")", ")", "\n", "\n", "", "return", "fig", ",", "ax", ",", "(", "handle_nm", ",", "handle_m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_rows": [[283, 356], ["pandas.concat", "print", "pandas.DataFrame", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "seaborn.set_color_codes", "seaborn.barplot", "ax.get_position", "ax.set_position", "ax.legend", "ax.set", "ax.set_title", "seaborn.despine", "ax.tick_params", "matplotlib.subplots"], "function", ["None"], ["", "", "def", "plot_rows", "(", "indicators", ",", "plot", "=", "False", ",", "show", "=", "True", ",", "ax", "=", "None", ")", ":", "\n", "    ", "\"\"\"Plot stats on rows without missing values.\"\"\"", "\n", "# Get required indicators", "\n", "df", "=", "pd", ".", "concat", "(", "[", "indicators", "[", "'rows'", "]", ",", "indicators", "[", "'global'", "]", "]", ",", "axis", "=", "1", ")", "\n", "\n", "n_r_wo_mv", "=", "df", ".", "at", "[", "0", ",", "'n_r_wo_mv'", "]", "\n", "n_r_w_mv", "=", "df", ".", "at", "[", "0", ",", "'n_r_w_mv'", "]", "\n", "n_r_w_mv1_o", "=", "df", ".", "at", "[", "0", ",", "'n_r_w_mv1_o'", "]", "\n", "n_r_w_mv2_o", "=", "df", ".", "at", "[", "0", ",", "'n_r_w_mv2_o'", "]", "\n", "n_r_w_mv_1a2", "=", "df", ".", "at", "[", "0", ",", "'n_r_w_mv_1a2'", "]", "\n", "f_r_wo_mv", "=", "df", ".", "at", "[", "0", ",", "'f_r_wo_mv'", "]", "\n", "f_r_w_mv", "=", "df", ".", "at", "[", "0", ",", "'f_r_w_mv'", "]", "\n", "f_r_w_mv1_o", "=", "df", ".", "at", "[", "0", ",", "'f_r_w_mv1_o'", "]", "\n", "f_r_w_mv2_o", "=", "df", ".", "at", "[", "0", ",", "'f_r_w_mv2_o'", "]", "\n", "f_r_w_mv_1a2", "=", "df", ".", "at", "[", "0", ",", "'f_r_w_mv_1a2'", "]", "\n", "\n", "n_rows", "=", "df", ".", "at", "[", "0", ",", "'n_rows'", "]", "\n", "\n", "if", "show", ":", "\n", "        ", "print", "(", "\n", "f'\\n'", "\n", "f'Statistics on rows:\\n'", "\n", "f'-------------------\\n'", "\n", "f'N rows: {n_rows}\\n'", "\n", "f'N rows without MV:         {n_r_wo_mv} ({f_r_wo_mv:.2f}%)\\n'", "\n", "f'N rows with MV:            {n_r_w_mv} ({f_r_w_mv:.2f}%)\\n'", "\n", "f'  N rows with MV1 only:    {n_r_w_mv1_o} ({f_r_w_mv1_o:.2f}%)\\n'", "\n", "f'  N rows with MV2 only:    {n_r_w_mv2_o} ({f_r_w_mv2_o:.2f}%)\\n'", "\n", "f'  N rows with MV1 and MV2: {n_r_w_mv_1a2} ({f_r_w_mv_1a2:.2f}%)\\n'", "\n", ")", "\n", "\n", "", "if", "plot", ":", "\n", "# Plot proportion of features with missing values", "\n", "        ", "df_show", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'N MV'", ":", "[", "n_r_w_mv", "]", ",", "\n", "'N MV1 only'", ":", "[", "n_r_w_mv1_o", "]", ",", "\n", "'N MV2 only'", ":", "[", "n_r_w_mv2_o", "]", ",", "\n", "'N MV 1 xor 2'", ":", "[", "n_r_w_mv1_o", "+", "n_r_w_mv2_o", "]", ",", "\n", "'N R'", ":", "[", "n_rows", "]", ",", "\n", "'type'", ":", "[", "'Full data frame'", "]", "\n", "}", ")", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "10", ",", "4", ")", ")", "\n", "\n", "", "sns", ".", "set_color_codes", "(", "'pastel'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N R'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'lightgray'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'No missing values ({n_r_wo_mv} \u2022 {f_r_wo_mv:.2f}%)'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'pastel'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N MV'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'r'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Not applicable and not available ({n_r_w_mv_1a2} \u2022 {f_r_w_mv_1a2:.2f}%)'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'muted'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N MV 1 xor 2'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'r'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Not applicable only ({n_r_w_mv1_o} \u2022 {f_r_w_mv1_o:.2f}%)'", ")", "\n", "\n", "sns", ".", "set_color_codes", "(", "'dark'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N MV2 only'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'r'", ",", "ax", "=", "ax", ",", "\n", "label", "=", "f'Not available only ({n_r_w_mv2_o} \u2022 {f_r_w_mv2_o:.2f}%)'", ")", "\n", "\n", "box", "=", "ax", ".", "get_position", "(", ")", "\n", "ax", ".", "set_position", "(", "[", "box", ".", "x0", ",", "box", ".", "y0", ",", "box", ".", "width", "*", "0.5", ",", "box", ".", "height", "*", "0.5", "]", ")", "\n", "\n", "ax", ".", "legend", "(", "ncol", "=", "1", ",", "loc", "=", "'center left'", ",", "frameon", "=", "True", ",", "\n", "title", "=", "'Type of missing values contained in the row'", ",", "\n", "bbox_to_anchor", "=", "(", "1.05", ",", "0.5", ")", ")", "\n", "ax", ".", "set", "(", "ylabel", "=", "''", ",", "xlabel", "=", "f'Number of rows (Total {n_rows})'", ")", "\n", "ax", ".", "set_title", "(", "'Proportion of rows having missing values'", ")", "\n", "sns", ".", "despine", "(", "left", "=", "True", ",", "bottom", "=", "True", ",", "ax", "=", "ax", ")", "\n", "\n", "# Remove y labels", "\n", "ax", ".", "tick_params", "(", "axis", "=", "'y'", ",", "which", "=", "'both'", ",", "left", "=", "False", ",", "labelleft", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_rm_rows": [[358, 428], ["pandas.concat", "print", "pandas.DataFrame", "pd.DataFrame.sort_values", "seaborn.set_color_codes", "seaborn.barplot", "ax.get_position", "ax.set_position", "ax.set_title", "ax.set", "ax.set_xlim", "seaborn.despine", "matplotlib.subplots", "range"], "function", ["None"], ["", "", "def", "plot_rm_rows", "(", "indicators", ",", "plot", "=", "False", ",", "show", "=", "True", ",", "ax", "=", "None", ")", ":", "\n", "    ", "\"\"\"Plot number of rows affected if we remove features with MV.\"\"\"", "\n", "# Get required indicators", "\n", "df", "=", "pd", ".", "concat", "(", "[", "indicators", "[", "'rm_rows'", "]", ",", "indicators", "[", "'global'", "]", "]", ",", "axis", "=", "1", ")", "\n", "\n", "n_r_a_rm_mv1", "=", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv1'", "]", "\n", "n_r_a_rm_mv2", "=", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv2'", "]", "\n", "n_r_a_rm_mv_1o2", "=", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv_1o2'", "]", "\n", "n_r_a_rm_mv1_o", "=", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv1_o'", "]", "\n", "n_r_a_rm_mv2_o", "=", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv2_o'", "]", "\n", "n_r_a_rm_mv_1a2", "=", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv_1a2'", "]", "\n", "f_r_a_rm_mv1", "=", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv1'", "]", "\n", "f_r_a_rm_mv2", "=", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv2'", "]", "\n", "f_r_a_rm_mv_1o2", "=", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv_1o2'", "]", "\n", "f_r_a_rm_mv1_o", "=", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv1_o'", "]", "\n", "f_r_a_rm_mv2_o", "=", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv2_o'", "]", "\n", "f_r_a_rm_mv_1a2", "=", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv_1a2'", "]", "\n", "\n", "n_rows", "=", "df", ".", "at", "[", "0", ",", "'n_rows'", "]", "\n", "\n", "if", "show", ":", "\n", "        ", "print", "(", "\n", "f'N rows losing information if we remove features with :\\n'", "\n", "f'    MV1:          {n_r_a_rm_mv1} ({f_r_a_rm_mv1:.2f}%)\\n'", "\n", "f'    MV2:          {n_r_a_rm_mv2} ({f_r_a_rm_mv2:.2f}%)\\n'", "\n", "f'    MV:           {n_r_a_rm_mv_1o2} ({f_r_a_rm_mv_1o2:.2f}%)\\n'", "\n", "f'    MV1 only:     {n_r_a_rm_mv1_o} ({f_r_a_rm_mv1_o:.2f}%)\\n'", "\n", "f'    MV2 only:     {n_r_a_rm_mv2_o} ({f_r_a_rm_mv2_o:.2f}%)\\n'", "\n", "f'    MV1 and MV2:  {n_r_a_rm_mv_1a2} ({f_r_a_rm_mv_1a2:.2f}%)\\n'", "\n", ")", "\n", "\n", "", "if", "plot", ":", "\n", "# Plot number of rows losing information when removing features with MV", "\n", "        ", "df_show", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'N rows affected'", ":", "[", "\n", "n_r_a_rm_mv1", ",", "\n", "n_r_a_rm_mv2", ",", "\n", "n_r_a_rm_mv_1o2", ",", "\n", "# n_r_a_rm_mv1_o,", "\n", "# n_r_a_rm_mv2_o,", "\n", "# n_r_a_rm_mv_1a2,", "\n", "]", ",", "\n", "'N R'", ":", "[", "n_rows", "for", "_", "in", "range", "(", "3", ")", "]", ",", "\n", "# 'N R': [n_rows for _ in range(6)],", "\n", "'type'", ":", "[", "\n", "f'Not applicable\\n{f_r_a_rm_mv1:.2f}%'", ",", "\n", "f'Not available\\n{f_r_a_rm_mv2:.2f}%'", ",", "\n", "f'Not applicable or\\nnot available\\n{f_r_a_rm_mv_1o2:.2f}%'", ",", "\n", "# f'MV1 only\\n{f_r_a_rm_mv1_o:.2f}%',", "\n", "# f'MV2 only\\n{f_r_a_rm_mv2_o:.2f}%',", "\n", "# f'MV1 and MV2\\n{f_r_a_rm_mv_1a2:.2f}%'", "\n", "]", ",", "\n", "}", ")", "\n", "\n", "df_show", ".", "sort_values", "(", "'N rows affected'", ",", "ascending", "=", "False", ",", "inplace", "=", "True", ")", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "10", ",", "4", ")", ")", "\n", "\n", "", "sns", ".", "set_color_codes", "(", "'muted'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N rows affected'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'r'", ",", "ax", "=", "ax", ")", "\n", "\n", "box", "=", "ax", ".", "get_position", "(", ")", "\n", "ax", ".", "set_position", "(", "[", "1.1", "*", "box", ".", "x0", ",", "box", ".", "y0", ",", "box", ".", "width", ",", "box", ".", "height", "]", ")", "\n", "\n", "ax", ".", "set_title", "(", "'Number of rows losing information (non-missing values)\\n'", "\n", "'when removing features containing missing values of type:'", ")", "\n", "ax", ".", "set", "(", "ylabel", "=", "''", ",", "xlabel", "=", "f'Number of rows (Total {n_rows})'", ")", "\n", "ax", ".", "set_xlim", "(", "right", "=", "n_rows", ")", "\n", "sns", ".", "despine", "(", "left", "=", "True", ",", "bottom", "=", "True", ",", "ax", "=", "ax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_rm_features": [[430, 501], ["pandas.concat", "print", "pandas.DataFrame", "pd.DataFrame.sort_values", "seaborn.set_color_codes", "seaborn.barplot", "ax.get_position", "ax.set_position", "ax.set_title", "ax.set", "ax.set_xlim", "seaborn.despine", "matplotlib.subplots", "range"], "function", ["None"], ["", "", "def", "plot_rm_features", "(", "indicators", ",", "plot", "=", "False", ",", "show", "=", "True", ",", "ax", "=", "None", ")", ":", "\n", "    ", "\"\"\"Plot the part of information lost when removing features with MV.\"\"\"", "\n", "# Get required indicators", "\n", "df", "=", "pd", ".", "concat", "(", "[", "indicators", "[", "'rm_features'", "]", ",", "indicators", "[", "'global'", "]", "]", ",", "axis", "=", "1", ")", "\n", "\n", "n_v_lost_mv1", "=", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv1'", "]", "\n", "n_v_lost_mv2", "=", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv2'", "]", "\n", "n_v_lost_mv_1o2", "=", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv_1o2'", "]", "\n", "n_v_lost_mv1_o", "=", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv1_o'", "]", "\n", "n_v_lost_mv2_o", "=", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv2_o'", "]", "\n", "n_v_lost_mv_1a2", "=", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv_1a2'", "]", "\n", "f_v_lost_mv1", "=", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv1'", "]", "\n", "f_v_lost_mv2", "=", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv2'", "]", "\n", "f_v_lost_mv_1o2", "=", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv_1o2'", "]", "\n", "f_v_lost_mv1_o", "=", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv1_o'", "]", "\n", "f_v_lost_mv2_o", "=", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv2_o'", "]", "\n", "f_v_lost_mv_1a2", "=", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv_1a2'", "]", "\n", "\n", "n_rows", "=", "df", ".", "at", "[", "0", ",", "'n_rows'", "]", "\n", "n_values", "=", "df", ".", "at", "[", "0", ",", "'n_values'", "]", "\n", "\n", "if", "show", ":", "\n", "        ", "print", "(", "\n", "f'N values lost if we remove features with :\\n'", "\n", "f'    MV1:          {n_v_lost_mv1} ({f_v_lost_mv1:.2f}%)\\n'", "\n", "f'    MV2:          {n_v_lost_mv2} ({f_v_lost_mv2:.2f}%)\\n'", "\n", "f'    MV:           {n_v_lost_mv_1o2} ({f_v_lost_mv_1o2:.2f}%)\\n'", "\n", "f'    MV1 only:     {n_v_lost_mv1_o} ({f_v_lost_mv1_o:.2f}%)\\n'", "\n", "f'    MV2 only:     {n_v_lost_mv2_o} ({f_v_lost_mv2_o:.2f}%)\\n'", "\n", "f'    MV1 and MV2:  {n_v_lost_mv_1a2} ({f_v_lost_mv_1a2:.2f}%)\\n'", "\n", ")", "\n", "\n", "", "if", "plot", ":", "\n", "# Plot number of values lost when removing features with MV", "\n", "        ", "df_show", "=", "pd", ".", "DataFrame", "(", "{", "\n", "'N values lost'", ":", "[", "\n", "n_v_lost_mv1", ",", "\n", "n_v_lost_mv2", ",", "\n", "n_v_lost_mv_1o2", ",", "\n", "# n_v_lost_mv1_o,", "\n", "# n_v_lost_mv2_o,", "\n", "# n_v_lost_mv_1a2,", "\n", "]", ",", "\n", "'N R'", ":", "[", "n_rows", "for", "_", "in", "range", "(", "3", ")", "]", ",", "\n", "# 'N R': [n_rows for _ in range(6)],", "\n", "'type'", ":", "[", "\n", "f'Not applicable\\n{f_v_lost_mv1:.2f}%'", ",", "\n", "f'Not available\\n{f_v_lost_mv2:.2f}%'", ",", "\n", "f'Not applicable or\\nnot available\\n{f_v_lost_mv_1o2:.2f}%'", ",", "\n", "# f'MV1 only\\n{f_v_lost_mv1_o:.2f}%',", "\n", "# f'MV2 only\\n{f_v_lost_mv2_o:.2f}%',", "\n", "# f'MV1 and MV2\\n{f_v_lost_mv_1a2:.2f}%'", "\n", "]", ",", "\n", "}", ")", "\n", "\n", "df_show", ".", "sort_values", "(", "'N values lost'", ",", "ascending", "=", "False", ",", "inplace", "=", "True", ")", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "10", ",", "4", ")", ")", "\n", "\n", "", "sns", ".", "set_color_codes", "(", "'muted'", ")", "\n", "sns", ".", "barplot", "(", "x", "=", "'N values lost'", ",", "y", "=", "'type'", ",", "data", "=", "df_show", ",", "color", "=", "'b'", ",", "ax", "=", "ax", ")", "\n", "\n", "box", "=", "ax", ".", "get_position", "(", ")", "\n", "ax", ".", "set_position", "(", "[", "1.1", "*", "box", ".", "x0", ",", "box", ".", "y0", ",", "box", ".", "width", ",", "box", ".", "height", "]", ")", "\n", "\n", "ax", ".", "set_title", "(", "'Number of non-missing values lost'", "\n", "'\\nwhen removing features containing missing values of type:'", ")", "\n", "ax", ".", "set", "(", "ylabel", "=", "''", ",", "xlabel", "=", "f'Number of values (Total {n_values})'", ")", "\n", "ax", ".", "set_xlim", "(", "right", "=", "n_values", ")", "\n", "sns", ".", "despine", "(", "left", "=", "True", ",", "bottom", "=", "True", ",", "ax", "=", "ax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.figure1": [[503, 516], ["matplotlib.subplots", "fig1.tight_layout", "all", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "plot_statistics.plot_global", "plot_statistics.plot_features", "plot_statistics.plot_rows", "fig1.suptitle"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_global", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_features", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_rows"], ["", "", "def", "figure1", "(", "indicators", ",", "plot", "=", "True", ",", "db_name", "=", "None", ",", "table", "=", "None", ")", ":", "\n", "    ", "\"\"\"Print a global overview of missing values\"\"\"", "\n", "fig1", ",", "axes1", "=", "plt", ".", "subplots", "(", "3", ",", "1", ",", "figsize", "=", "(", "12", ",", "6", ")", ")", "\n", "fig1", ".", "tight_layout", "(", "pad", "=", "2", ")", "\n", "if", "all", "(", "(", "db_name", ",", "table", ")", ")", ":", "\n", "        ", "fig1", ".", "suptitle", "(", "f'Overview of missing values in {db_name} (table \"$\\\\verb|{table}|$\")'", ",", "\n", "fontsize", "=", "'xx-large'", ")", "\n", "\n", "", "matplotlib", ".", "rcParams", ".", "update", "(", "{", "'font.size'", ":", "13", "}", ")", "\n", "\n", "plot_global", "(", "indicators", ",", "plot", "=", "plot", ",", "ax", "=", "axes1", "[", "0", "]", ")", "\n", "plot_features", "(", "indicators", ",", "plot", "=", "plot", ",", "ax", "=", "axes1", "[", "1", "]", ")", "\n", "plot_rows", "(", "indicators", ",", "plot", "=", "plot", ",", "ax", "=", "axes1", "[", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.figure2": [[518, 531], ["matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "plot_statistics.plot_feature_wise", "all", "fig2.suptitle"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_feature_wise"], ["", "def", "figure2", "(", "indicators", ",", "plot", "=", "True", ",", "db_name", "=", "None", ",", "table", "=", "None", ")", ":", "\n", "    ", "matplotlib", ".", "rcParams", ".", "update", "(", "{", "\n", "'font.size'", ":", "14", ",", "\n", "'axes.titlesize'", ":", "14", ",", "\n", "'axes.labelsize'", ":", "13", ",", "\n", "'xtick.labelsize'", ":", "13", ",", "\n", "'ytick.labelsize'", ":", "13", ",", "\n", "}", ")", "\n", "fig2", ",", "_", "=", "plot_feature_wise", "(", "indicators", ",", "plot", "=", "plot", ")", "\n", "if", "all", "(", "(", "db_name", ",", "table", ")", ")", ":", "\n", "        ", "fig2", ".", "suptitle", "(", "f'Proportion of missing values in each feature'", "\n", "f'\\nof {db_name} (table \"$\\\\verb|{table}|$\")'", ",", "\n", "fontsize", "=", "'x-large'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.figure2bis": [[533, 546], ["matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "plot_statistics.plot_feature_wise_v2", "all", "fig2.suptitle"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_feature_wise_v2"], ["", "", "def", "figure2bis", "(", "indicators", ",", "plot", "=", "True", ",", "db_name", "=", "None", ",", "table", "=", "None", ")", ":", "\n", "    ", "matplotlib", ".", "rcParams", ".", "update", "(", "{", "\n", "'font.size'", ":", "14", ",", "\n", "'axes.titlesize'", ":", "14", ",", "\n", "'axes.labelsize'", ":", "13", ",", "\n", "'xtick.labelsize'", ":", "13", ",", "\n", "'ytick.labelsize'", ":", "13", ",", "\n", "}", ")", "\n", "fig2", ",", "*", "_", "=", "plot_feature_wise_v2", "(", "indicators", ",", "plot", "=", "plot", ")", "\n", "if", "all", "(", "(", "db_name", ",", "table", ")", ")", ":", "\n", "        ", "fig2", ".", "suptitle", "(", "f'Proportion of missing values in each feature'", "\n", "f'\\nof {db_name} (table \"$\\\\verb|{table}|$\")'", ",", "\n", "fontsize", "=", "'x-large'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.figure3": [[548, 566], ["matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.subplots", "fig3.tight_layout", "all", "plot_statistics.plot_rm_rows", "plot_statistics.plot_rm_features", "fig3.suptitle"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_rm_rows", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_rm_features"], ["", "", "def", "figure3", "(", "indicators", ",", "plot", "=", "True", ",", "db_name", "=", "None", ",", "table", "=", "None", ")", ":", "\n", "    ", "matplotlib", ".", "rcParams", ".", "update", "(", "{", "\n", "# 'font.size': 14,", "\n", "'axes.titlesize'", ":", "14", ",", "\n", "'axes.labelsize'", ":", "13", ",", "\n", "'xtick.labelsize'", ":", "13", ",", "\n", "'ytick.labelsize'", ":", "13", ",", "\n", "}", ")", "\n", "\n", "fig3", ",", "axes3", "=", "plt", ".", "subplots", "(", "2", ",", "1", ",", "figsize", "=", "(", "10", ",", "8", ")", ")", "\n", "fig3", ".", "tight_layout", "(", "pad", "=", "5", ",", "h_pad", "=", "7", ",", "rect", "=", "(", "0.05", ",", "0", ",", "1", ",", ".92", ")", ")", "\n", "if", "all", "(", "(", "db_name", ",", "table", ")", ")", ":", "\n", "        ", "fig3", ".", "suptitle", "(", "f'Effect of removing features containing missing values'", "\n", "f'\\non {db_name} (table \"$\\\\verb|{table}|$\")'", ",", "\n", "fontsize", "=", "'x-large'", ")", "\n", "\n", "", "plot_rm_rows", "(", "indicators", ",", "plot", "=", "plot", ",", "ax", "=", "axes3", "[", "0", "]", ")", "\n", "plot_rm_features", "(", "indicators", ",", "plot", "=", "plot", ",", "ax", "=", "axes3", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.plot_statistics.plot_feature_types": [[568, 616], ["matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "props.reset_index", "props[].str.replace", "props[].str.replace", "props[].str.replace", "seaborn.color_palette", "seaborn.barplot", "seaborn.barplot", "seaborn.barplot", "ax.get_legend_handles_labels", "ax.legend", "ax.set_xlabel", "ax.set_ylabel", "props.set_index", "ax.get_yaxis().get_majorticklocs", "[].first", "ax.set_yticklabels", "ax.get_xlim", "enumerate", "ax.set_xlim", "matplotlib.subplots", "subprops.index.get_level_values", "[].first.items", "ax.text", "ax.get_yaxis", "props.index.get_level_values", "subprops.groupby"], "function", ["None"], ["", "def", "plot_feature_types", "(", "props", ",", "ax", "=", "None", ")", ":", "\n", "    ", "matplotlib", ".", "rcParams", ".", "update", "(", "{", "\n", "'font.size'", ":", "12", ",", "\n", "# 'axes.titlesize': 10,", "\n", "'axes.labelsize'", ":", "11", ",", "\n", "'xtick.labelsize'", ":", "8", ",", "\n", "'ytick.labelsize'", ":", "11", ",", "\n", "'legend.fontsize'", ":", "11", ",", "\n", "'legend.title_fontsize'", ":", "12", ",", "\n", "}", ")", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "4.5", ",", "6.5", ")", ")", "\n", "\n", "", "props", ".", "reset_index", "(", "inplace", "=", "True", ")", "\n", "props", "[", "'tag'", "]", "=", "props", "[", "'tag'", "]", ".", "str", ".", "replace", "(", "'_'", ",", "'-'", ")", "\n", "props", "[", "'task'", "]", "=", "props", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_'", ",", "r'\\_'", ")", "\n", "props", "[", "'task'", "]", "=", "props", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'pvals'", ",", "r'screening'", ")", "\n", "\n", "# Compute cumsums for plotting", "\n", "props", "[", "'categorical+ordinal'", "]", "=", "props", "[", "'categorical'", "]", "+", "props", "[", "'ordinal'", "]", "\n", "props", "[", "'continuous+ordinal'", "]", "=", "props", "[", "'continuous'", "]", "+", "props", "[", "'ordinal'", "]", "\n", "\n", "c1", ",", "c2", ",", "c3", "=", "sns", ".", "color_palette", "(", "[", "'tab:grey'", ",", "'tab:olive'", ",", "'tab:cyan'", "]", ")", "\n", "g1", "=", "sns", ".", "barplot", "(", "y", "=", "'tag'", ",", "x", "=", "'n'", ",", "data", "=", "props", ",", "orient", "=", "'h'", ",", "hue", "=", "'T'", ",", "color", "=", "c1", ",", "palette", "=", "[", "c1", "]", ",", "ax", "=", "ax", ")", "\n", "g2", "=", "sns", ".", "barplot", "(", "y", "=", "'tag'", ",", "x", "=", "'categorical+ordinal'", ",", "data", "=", "props", ",", "orient", "=", "'h'", ",", "hue", "=", "'T'", ",", "color", "=", "c3", ",", "palette", "=", "[", "c3", "]", ",", "ax", "=", "ax", ")", "\n", "g3", "=", "sns", ".", "barplot", "(", "y", "=", "'tag'", ",", "x", "=", "'categorical'", ",", "data", "=", "props", ",", "orient", "=", "'h'", ",", "hue", "=", "'T'", ",", "color", "=", "c2", ",", "palette", "=", "[", "c2", "]", ",", "ax", "=", "ax", ")", "\n", "handles", ",", "labels", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "ax", ".", "legend", "(", "handles", "=", "[", "handles", "[", "10", "]", ",", "handles", "[", "5", "]", ",", "handles", "[", "0", "]", "]", ",", "\n", "labels", "=", "[", "'Categorical'", ",", "'Ordinal'", ",", "'Numerical'", "]", ",", "\n", "title", "=", "'Feature type'", ",", "fancybox", "=", "True", ",", "shadow", "=", "False", ",", "\n", "loc", "=", "'upper center'", ",", "bbox_to_anchor", "=", "(", "0.215", ",", "1.17", ")", ",", "ncol", "=", "3", ")", "\n", "ax", ".", "set_xlabel", "(", "'Number of features'", ")", "\n", "ax", ".", "set_ylabel", "(", "''", ")", "\n", "\n", "props", ".", "set_index", "(", "[", "'db'", ",", "'task'", ",", "'T'", "]", ",", "inplace", "=", "True", ")", "\n", "subprops", "=", "props", ".", "iloc", "[", "props", ".", "index", ".", "get_level_values", "(", "'T'", ")", "==", "0", "]", "\n", "minor_YT", "=", "ax", ".", "get_yaxis", "(", ")", ".", "get_majorticklocs", "(", ")", "\n", "subprops", "[", "'YT_V'", "]", "=", "minor_YT", "\n", "major", "=", "subprops", ".", "groupby", "(", "level", "=", "[", "0", "]", ")", "[", "'YT_V'", "]", ".", "first", "(", ")", "\n", "ax", ".", "set_yticklabels", "(", "subprops", ".", "index", ".", "get_level_values", "(", "1", ")", ")", "\n", "\n", "xlim", "=", "ax", ".", "get_xlim", "(", ")", "\n", "\n", "for", "i", ",", "(", "idx", ",", "value", ")", "in", "enumerate", "(", "major", ".", "items", "(", ")", ")", ":", "\n", "        ", "ax", ".", "text", "(", "-", "40", ",", "major", ".", "iloc", "[", "i", "]", ",", "idx", ",", "va", "=", "'center'", ",", "ha", "=", "'right'", ")", "\n", "\n", "", "ax", ".", "set_xlim", "(", "xlim", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.breakout.run_breakout": [[19, 260], ["pandas.concat", "tasks_to_drop.items", "scores[].str.replace", "scores.reindex.query", "prediction.df_utils.aggregate", "scores.reindex.rename", "scores.reindex.set_index", "scores.reindex.reindex", "scores.reindex.reset_index", "seaborn.color_palette().as_hex", "seaborn.color_palette", "seaborn.set_palette", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.subplots", "range", "scores.reindex.groupby", "db_titles2.items", "matplotlib.subplots_adjust", "custom.const.get_fig_folder", "matplotlib.savefig", "matplotlib.savefig", "matplotlib.tight_layout", "pandas.read_csv", "scores.reindex.drop", "seaborn.color_palette().as_hex", "range", "positions.get", "ax.axis", "group.astype.astype", "numpy.random.seed", "seaborn.stripplot", "ax.set_ylabel", "ax.set_title", "ax.annotate", "ax.get_xticklabels", "enumerate", "ax.set_xticklabels", "axes[].annotate", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "fig.add_artist", "os.path.join", "os.path.join", "seaborn.color_palette", "axes[].axis", "group[].iloc[].replace", "ax.get_legend_handles_labels", "ax.legend", "ax.get_legend().remove", "ax.set_ylabel", "ax.set_xlabel", "xticklabel.get_text", "seaborn.color_palette", "rename.get", "dict", "dict", "ax.get_legend", "int", "str"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.df_utils.aggregate", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], ["def", "run_breakout", "(", "graphics_folder", ",", "linear", ")", ":", "\n", "# filepath = 'scores/scores.csv'", "\n", "# scores = pd.read_csv(filepath, index_col=0)", "\n", "# filepaths = [", "\n", "#     'scores/scores.csv',", "\n", "#     'scores/scores_mi_2500.csv',", "\n", "#     'scores/scores_mia_2500.csv',", "\n", "#     'scores/scores_mi_10000.csv',", "\n", "#     'scores/scores_mia_10000.csv',", "\n", "#     'scores/scores_mia_25000.csv',", "\n", "#     'scores/scores_mi_25000.csv',", "\n", "#     'scores/scores_mia_100000.csv',", "\n", "# ]", "\n", "    ", "dfs", "=", "[", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "for", "path", "in", "filepaths", "]", "\n", "scores", "=", "pd", ".", "concat", "(", "dfs", ",", "axis", "=", "0", ")", "\n", "\n", "# Drop tasks", "\n", "for", "db", ",", "task", "in", "tasks_to_drop", ".", "items", "(", ")", ":", "\n", "        ", "scores", ".", "drop", "(", "index", "=", "scores", "[", "(", "scores", "[", "'db'", "]", "==", "db", ")", "&", "(", "scores", "[", "'task'", "]", "==", "task", ")", "]", ".", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "", "scores", "[", "'task'", "]", "=", "scores", "[", "'task'", "]", ".", "str", ".", "replace", "(", "'_pvals'", ",", "'_screening'", ")", "\n", "\n", "method_order", "=", "[", "\n", "'MIA'", ",", "\n", "'Mean'", ",", "\n", "'Mean+mask'", ",", "\n", "'Med'", ",", "\n", "'Med+mask'", ",", "\n", "'Iter'", ",", "\n", "'Iter+mask'", ",", "\n", "'KNN'", ",", "\n", "'KNN+mask'", ",", "\n", "'MI'", ",", "\n", "'MI+mask'", ",", "\n", "'MIA+bagging'", ",", "\n", "]", "\n", "\n", "db_order", "=", "[", "\n", "'TB'", ",", "\n", "'UKBB'", ",", "\n", "'MIMIC'", ",", "\n", "'NHIS'", ",", "\n", "]", "\n", "\n", "rename", "=", "{", "\n", "'Med'", ":", "'Median'", ",", "\n", "'Med+mask'", ":", "'Median+mask'", ",", "\n", "'Iter'", ":", "'Iterative'", ",", "\n", "'Iter+mask'", ":", "'Iterative+mask'", ",", "\n", "}", "\n", "\n", "scores", "=", "scores", ".", "query", "(", "'method in @method_order'", ")", "\n", "scores", "=", "aggregate", "(", "scores", ",", "'score'", ")", "\n", "scores", ".", "rename", "(", "{", "\n", "'size'", ":", "'Size'", ",", "\n", "'db'", ":", "'Database'", ",", "\n", "'task'", ":", "'Task'", ",", "\n", "'method'", ":", "'Method'", ",", "\n", "}", ",", "inplace", "=", "True", ",", "axis", "=", "1", ")", "\n", "scores", ".", "set_index", "(", "[", "'Size'", ",", "'Database'", ",", "'Task'", ",", "'Method'", "]", ",", "inplace", "=", "True", ")", "\n", "scores", "=", "scores", ".", "reindex", "(", "method_order", ",", "level", "=", "3", ")", "\n", "scores", ".", "reset_index", "(", "inplace", "=", "True", ")", "\n", "# scores.set_index(['Database', 'Task'], inplace=True)", "\n", "\n", "# print(scores)", "\n", "\n", "# Build the color palette", "\n", "paired_colors", "=", "sns", ".", "color_palette", "(", "'Paired'", ")", ".", "as_hex", "(", ")", "\n", "# del paired_colors[10]", "\n", "paired_colors", "[", "10", "]", "=", "sns", ".", "color_palette", "(", "\"Set2\"", ")", ".", "as_hex", "(", ")", "[", "5", "]", "\n", "boxplot_palette", "=", "sns", ".", "color_palette", "(", "[", "'#525252'", "]", "+", "paired_colors", ")", "\n", "sns", ".", "set_palette", "(", "boxplot_palette", ")", "\n", "\n", "L1", "=", "[", "'TB/death_pvals'", ",", "'TB/hemo'", ",", "'TB/hemo_pvals'", "]", "\n", "L2", "=", "[", "'TB/platelet_pvals'", ",", "'TB/septic_pvals'", ",", "None", "]", "\n", "# L2 = [None, None, None]", "\n", "# L3 = [None, None, None]", "\n", "# L4 = [None, None, None]", "\n", "# L5 = [None, None, None]", "\n", "# L6 = [None, None, None]", "\n", "L3", "=", "[", "'UKBB/breast_25'", ",", "'UKBB/breast_pvals'", ",", "'UKBB/fluid_pvals'", "]", "\n", "L4", "=", "[", "'UKBB/parkinson_pvals'", ",", "'UKBB/skin_pvals'", ",", "None", "]", "\n", "L5", "=", "[", "'MIMIC/hemo_pvals'", ",", "'MIMIC/septic_pvals'", ",", "None", "]", "\n", "L6", "=", "[", "'NHIS/income_pvals'", ",", "None", ",", "None", "]", "\n", "\n", "L", "=", "[", "L1", ",", "L2", ",", "L3", ",", "L4", ",", "L5", ",", "L6", "]", "\n", "\n", "plt", ".", "rcParams", ".", "update", "(", "{", "\n", "'font.size'", ":", "10", ",", "\n", "'axes.titlesize'", ":", "10", ",", "\n", "'axes.labelsize'", ":", "8", ",", "\n", "'xtick.labelsize'", ":", "8", ",", "\n", "'ytick.labelsize'", ":", "8", ",", "\n", "}", ")", "\n", "plt", ".", "rcParams", ".", "update", "(", "{", "\n", "'text.usetex'", ":", "True", ",", "\n", "'mathtext.fontset'", ":", "'stix'", ",", "\n", "'font.family'", ":", "'STIXGeneral'", ",", "\n", "# 'axes.labelsize': 15,", "\n", "'legend.fontsize'", ":", "9", ",", "#10,", "\n", "# 'figure.figsize': (8, 4.8),", "\n", "# 'figure.dpi': 600,", "\n", "}", ")", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "6", ",", "3", ",", "figsize", "=", "(", "8", ",", "13", ")", ")", "\n", "\n", "# plt.figure()", "\n", "# ax = plt.gca()", "\n", "\n", "positions", "=", "{", "\n", "'TB/death_screening'", ":", "(", "0", ",", "0", ")", ",", "\n", "'TB/hemo'", ":", "(", "0", ",", "1", ")", ",", "\n", "'TB/hemo_screening'", ":", "(", "0", ",", "2", ")", ",", "\n", "'TB/platelet_screening'", ":", "(", "1", ",", "0", ")", ",", "\n", "'TB/septic_screening'", ":", "(", "1", ",", "1", ")", ",", "\n", "'UKBB/breast_25'", ":", "(", "2", ",", "0", ")", ",", "\n", "'UKBB/breast_screening'", ":", "(", "2", ",", "1", ")", ",", "\n", "'UKBB/fluid_screening'", ":", "(", "2", ",", "2", ")", ",", "\n", "'UKBB/parkinson_screening'", ":", "(", "3", ",", "0", ")", ",", "\n", "'UKBB/skin_screening'", ":", "(", "3", ",", "1", ")", ",", "\n", "'MIMIC/hemo_screening'", ":", "(", "4", ",", "0", ")", ",", "\n", "'MIMIC/septic_screening'", ":", "(", "4", ",", "1", ")", ",", "\n", "'NHIS/income_screening'", ":", "(", "5", ",", "0", ")", ",", "\n", "}", "\n", "\n", "for", "i", "in", "range", "(", "6", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "            ", "axes", "[", "i", ",", "j", "]", ".", "axis", "(", "'off'", ")", "\n", "\n", "", "", "for", "name", ",", "group", "in", "scores", ".", "groupby", "(", "[", "'Database'", ",", "'Task'", "]", ")", ":", "\n", "# print(group)", "\n", "        ", "db", "=", "group", "[", "'Database'", "]", ".", "iloc", "[", "0", "]", "\n", "task", "=", "group", "[", "'Task'", "]", ".", "iloc", "[", "0", "]", "\n", "i", ",", "j", "=", "positions", ".", "get", "(", "f'{db}/{task}'", ",", "None", ")", "\n", "ax", "=", "axes", "[", "i", ",", "j", "]", "\n", "ax", ".", "axis", "(", "'on'", ")", "\n", "# print(group)", "\n", "# print(group)", "\n", "# group['score'] = pd.to_numeric(group['score'])", "\n", "# group = group.astype({'score': float})#, 'Size': str})", "\n", "group", "=", "group", ".", "astype", "(", "{", "'Size'", ":", "str", "}", ")", "\n", "# group['const'] = '0'", "\n", "# sns.stripplot(x='score', hue='Method', data=group)", "\n", "# sns.swarmplot(x='score', hue='Method', data=group)", "\n", "# sns.scatterplot(x='score', y=1, hue='Method', data=group)", "\n", "# sns.swarmplot(x='score', y='Size', hue='Method', data=group)", "\n", "# sns.stripplot(x='score', y='const', hue='Method', data=group)", "\n", "\n", "# Seed for jitter", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "# sns.stripplot(x='score', y='Size', hue='Method', data=group, ax=ax,", "\n", "sns", ".", "stripplot", "(", "x", "=", "'Size'", ",", "y", "=", "'score'", ",", "hue", "=", "'Method'", ",", "data", "=", "group", ",", "ax", "=", "ax", ",", "\n", "#   order=['100000', '25000', '10000', '2500'], s=4, jitter=1)#0.3)", "\n", "order", "=", "[", "'2500'", ",", "'10000'", ",", "'25000'", ",", "'100000'", "]", ",", "s", "=", "4", ",", "jitter", "=", "1", ")", "#, linewidth=0.2, edgecolor='black')#0.3)", "\n", "xlabels", "=", "{", "\n", "'roc_auc_score'", ":", "'AUC'", ",", "\n", "'r2_score'", ":", "'$r^2$'", ",", "\n", "}", "\n", "# ax.set_xlabel()", "\n", "ax", ".", "set_ylabel", "(", "'Score'", ")", "\n", "# ax.set_title(f\"\\\\verb|{group['Task'].iloc[0]}|\")", "\n", "ax", ".", "set_title", "(", "group", "[", "'Task'", "]", ".", "iloc", "[", "0", "]", ".", "replace", "(", "'_'", ",", "'\\\\_'", ")", ")", "\n", "# sns.swarmplot(x='score', y='Size', hue='Method', data=group)", "\n", "if", "(", "i", ",", "j", ")", "==", "(", "5", ",", "0", ")", ":", "\n", "# Rename methods in legend", "\n", "            ", "handles", ",", "labels", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "renamed_labels", "=", "[", "rename", ".", "get", "(", "label", ",", "label", ")", "for", "label", "in", "labels", "]", "\n", "ax", ".", "legend", "(", "title", "=", "'Method'", ",", "ncol", "=", "2", ",", "bbox_to_anchor", "=", "(", "1.12", ",", "1.06", ")", ",", "\n", "handles", "=", "handles", ",", "labels", "=", "renamed_labels", ",", "loc", "=", "'upper left'", ")", "\n", "", "else", ":", "\n", "            ", "ax", ".", "get_legend", "(", ")", ".", "remove", "(", ")", "\n", "", "if", "j", ">=", "1", ":", "\n", "# ax.get_yaxis().set_visible(False)", "\n", "            ", "ax", ".", "set_ylabel", "(", "None", ")", "\n", "", "if", "i", "<", "5", ":", "\n", "            ", "ax", ".", "set_xlabel", "(", "None", ")", "\n", "\n", "", "scorer", "=", "xlabels", "[", "group", "[", "'scorer'", "]", ".", "iloc", "[", "0", "]", "]", "\n", "# ax.annotate(scorer, xy=(0.018, 0.028), xycoords='axes fraction',", "\n", "#             bbox=dict(boxstyle='square', ec='black', fc='white', alpha=1, linewidth=0.7),", "\n", "#             ha='left', va='bottom', fontsize=8)", "\n", "\n", "ax", ".", "annotate", "(", "scorer", ",", "xy", "=", "(", "0.019", ",", "0.972", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "bbox", "=", "dict", "(", "boxstyle", "=", "'square'", ",", "ec", "=", "'black'", ",", "fc", "=", "'white'", ",", "alpha", "=", "1", ",", "linewidth", "=", "0.7", ")", ",", "\n", "ha", "=", "'left'", ",", "va", "=", "'top'", ",", "fontsize", "=", "8", ")", "\n", "\n", "# ax.annotate(scorer, xy=(0.981, 0.028), xycoords='axes fraction',", "\n", "#             bbox=dict(boxstyle='square', ec='black', fc='white', alpha=1, linewidth=0.7),", "\n", "#             ha='right', va='bottom', fontsize=8)", "\n", "\n", "\n", "# ax.tick_params(axis=\"x\",direction=\"in\", pad=-15)", "\n", "# break", "\n", "\n", "# Add thousand separator for sizes", "\n", "xticklabels", "=", "ax", ".", "get_xticklabels", "(", ")", "\n", "for", "i", ",", "xticklabel", "in", "enumerate", "(", "xticklabels", ")", ":", "\n", "            ", "s", "=", "xticklabel", ".", "get_text", "(", ")", "\n", "s", "=", "f'{int(str(s)):,}'", ".", "replace", "(", "','", ",", "'\\\\,'", ")", "\n", "xticklabels", "[", "i", "]", "=", "s", "\n", "", "ax", ".", "set_xticklabels", "(", "xticklabels", ")", "\n", "\n", "", "db_titles2", "=", "{", "\n", "1", ":", "'Traumabase'", ",", "\n", "3", ":", "'UKBB'", ",", "\n", "4", ":", "'MIMIC'", ",", "\n", "5", ":", "'NHIS'", ",", "\n", "}", "\n", "\n", "fs", "=", "14", "\n", "\n", "for", "i", ",", "db", "in", "db_titles2", ".", "items", "(", ")", ":", "\n", "# Here is the label and arrow code of interest", "\n", "# axes[i, 0].annotate(db, xy=(-0.4, 0.5), xycoords='axes fraction',", "\n", "#             fontsize=fs, ha='center', va='center',", "\n", "#             bbox=None,#dict(boxstyle='square', fc='white'),", "\n", "#             # arrowprops=dict(arrowstyle=f'-[, widthB={70/fs}, lengthB=0.5', lw=lw),", "\n", "#             rotation=90,", "\n", "#             )", "\n", "        ", "axes", "[", "i", ",", "-", "1", "]", ".", "annotate", "(", "db", ",", "xy", "=", "(", "0.5", ",", "0.5", ")", ",", "xycoords", "=", "'axes fraction'", ",", "\n", "fontsize", "=", "fs", ",", "ha", "=", "'center'", ",", "va", "=", "'center'", ",", "\n", "bbox", "=", "dict", "(", "boxstyle", "=", "'square'", ",", "fc", "=", "'white'", ")", ",", "\n", "# arrowprops=dict(arrowstyle=f'-[, widthB={70/fs}, lengthB=0.5', lw=lw),", "\n", "rotation", "=", "0", ",", "\n", ")", "\n", "", "dh", "=", "1.", "/", "6", "\n", "# for i in range(0,7):", "\n", "for", "i", "in", "[", "1.35", ",", "2.15", ",", "3.77", "]", ":", "\n", "        ", "y", "=", "i", "*", "dh", "\n", "line", "=", "matplotlib", ".", "lines", ".", "Line2D", "(", "[", "0.05", ",", "0.9", "]", ",", "[", "y", ",", "y", "]", ",", "lw", "=", "0.5", ",", "ls", "=", "'-'", ",", "color", "=", "'gray'", ",", "\n", "alpha", "=", "1", ",", "transform", "=", "fig", ".", "transFigure", ")", "\n", "# axes[1, 0].add_line(line)", "\n", "fig", ".", "add_artist", "(", "line", ")", "\n", "\n", "", "plt", ".", "subplots_adjust", "(", "hspace", "=", "0.4", ",", "wspace", "=", "0.25", ")", "\n", "\n", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "fig_name", "=", "'breakout'", "\n", "\n", "plt", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "fig_folder", ",", "f'{fig_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "fig_folder", ",", "f'{fig_name}.jpg'", ")", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "400", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "# plt.show()", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.importance.run_feature_importance": [[52, 310], ["matplotlib.rcParams.update", "functools.reduce", "enumerate", "custom.const.get_fig_folder", "plt.figure.savefig", "plt.figure.savefig", "os.walk", "pandas.concat", "pd.concat.reset_index", "pd.concat.set_index", "pd.concat.groupby().agg", "matplotlib.subplots", "matplotlib.figure", "matplotlib.gca", "seaborn.color_palette().as_hex", "seaborn.color_palette().as_hex", "zip", "importance.run_feature_importance.retrive_importance"], "function", ["None"], ["def", "run_feature_importance", "(", "graphics_folder", ",", "results_folder", ",", "n", ",", "average_folds", ",", "\n", "mode", ",", "hue_by_task", ")", ":", "\n", "\n", "    ", "def", "retrive_importance", "(", "n", ")", ":", "\n", "\n", "        ", "filenames", "=", "[", "\n", "f'{n}_importances.csv'", ",", "\n", "f'{n}_mv_props.csv'", ",", "\n", "]", "\n", "\n", "dfs", "=", "[", "]", "\n", "\n", "# Aggregate feature importances of all tasks", "\n", "for", "root", ",", "subdirs", ",", "files", "in", "os", ".", "walk", "(", "results_folder", ")", ":", "\n", "            ", "print", "(", "root", ")", "\n", "\n", "res", "=", "re", ".", "search", "(", "join", "(", "results_folder", ",", "'/(.*)/RS'", ")", ",", "root", ")", "\n", "\n", "if", "res", "is", "None", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "not", "all", "(", "[", "f", "in", "files", "for", "f", "in", "filenames", "]", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "task", "=", "res", ".", "group", "(", "1", ")", "\n", "db", "=", "task", ".", "split", "(", "'/'", ")", "[", "0", "]", "\n", "res", "=", "re", ".", "search", "(", "'RS0_T(.)_'", ",", "root", ")", "\n", "trial", "=", "res", ".", "group", "(", "1", ")", "\n", "task", "=", "task", ".", "replace", "(", "'_'", ",", "'\\\\_'", ")", ".", "replace", "(", "'pvals'", ",", "'screening'", ")", "\n", "\n", "importance", "=", "pd", ".", "read_csv", "(", "join", "(", "root", ",", "f'{n}_importances.csv'", ")", ",", "index_col", "=", "0", ")", "\n", "mv_props", "=", "pd", ".", "read_csv", "(", "join", "(", "root", ",", "f'{n}_mv_props.csv'", ")", ",", "index_col", "=", "0", ")", "\n", "mv_props", ".", "set_index", "(", "'fold'", ",", "inplace", "=", "True", ")", "\n", "\n", "importance", ".", "reset_index", "(", "inplace", "=", "True", ")", "\n", "importance", ".", "set_index", "(", "[", "'fold'", ",", "'repeat'", "]", ",", "inplace", "=", "True", ")", "\n", "importance_avg", "=", "importance", ".", "groupby", "(", "level", "=", "'fold'", ")", ".", "mean", "(", ")", "\n", "\n", "if", "average_folds", ":", "\n", "                ", "importance_avg", "=", "importance_avg", ".", "mean", "(", ")", "\n", "importance_avg", "=", "importance_avg", ".", "to_frame", "(", ")", ".", "T", "\n", "mv_props", "=", "mv_props", ".", "mean", "(", ")", "\n", "mv_props", "=", "mv_props", ".", "to_frame", "(", ")", ".", "T", "\n", "id_vars", "=", "None", "\n", "index", "=", "[", "'feature'", "]", "\n", "\n", "", "else", ":", "\n", "                ", "importance_avg", ".", "reset_index", "(", "inplace", "=", "True", ")", "\n", "mv_props", ".", "reset_index", "(", "inplace", "=", "True", ")", "\n", "id_vars", "=", "[", "'fold'", "]", "\n", "index", "=", "[", "'fold'", ",", "'feature'", "]", "\n", "\n", "", "importance_avg", "=", "pd", ".", "melt", "(", "importance_avg", ",", "id_vars", "=", "id_vars", ",", "\n", "var_name", "=", "'feature'", ",", "value_name", "=", "'importance_abs'", ")", "\n", "importance_avg", ".", "set_index", "(", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "mv_props", "=", "pd", ".", "melt", "(", "mv_props", ",", "id_vars", "=", "id_vars", ",", "var_name", "=", "'feature'", ",", "value_name", "=", "'mv_prop'", ")", "\n", "mv_props", ".", "set_index", "(", "index", ",", "inplace", "=", "True", ")", "\n", "\n", "df", "=", "pd", ".", "concat", "(", "[", "importance_avg", ",", "mv_props", "]", ",", "axis", "=", "1", ")", "\n", "assert", "not", "pd", ".", "isna", "(", "df", ")", ".", "any", "(", ")", ".", "any", "(", ")", "\n", "\n", "df", "[", "'db'", "]", "=", "rename_db", ".", "get", "(", "db", ",", "db", ")", "\n", "df", "[", "'trial'", "]", "=", "trial", "\n", "df", "=", "pd", ".", "concat", "(", "{", "task", ":", "df", "}", ",", "names", "=", "[", "'task'", "]", ")", "\n", "\n", "dfs", ".", "append", "(", "df", ")", "\n", "\n", "", "df", "=", "pd", ".", "concat", "(", "dfs", ",", "axis", "=", "0", ")", "\n", "\n", "df", ".", "reset_index", "(", "inplace", "=", "True", ")", "\n", "df", ".", "set_index", "(", "[", "'task'", ",", "'trial'", "]", ",", "inplace", "=", "True", ")", "\n", "df_agg", "=", "df", ".", "groupby", "(", "[", "'task'", ",", "'trial'", "]", ")", ".", "agg", "(", "{", "'importance_abs'", ":", "'mean'", "}", ")", "\n", "\n", "df", "[", "'importance_ref'", "]", "=", "df_agg", "\n", "df", "[", "'importance_rel'", "]", "=", "df", "[", "'importance_abs'", "]", "-", "df", "[", "'importance_ref'", "]", "\n", "df", "[", "'importance_rel_%'", "]", "=", "(", "df", "[", "'importance_abs'", "]", "-", "df", "[", "'importance_ref'", "]", ")", "/", "df", "[", "'importance_ref'", "]", "\n", "df", "[", "'importance_ratio'", "]", "=", "df", "[", "'importance_abs'", "]", "/", "df", "[", "'importance_ref'", "]", "\n", "\n", "return", "df", "\n", "\n", "", "plt", ".", "rcParams", ".", "update", "(", "{", "\n", "'font.size'", ":", "10", ",", "\n", "'legend.fontsize'", ":", "12", ",", "\n", "'legend.title_fontsize'", ":", "16", ",", "\n", "'axes.titlesize'", ":", "18", ",", "\n", "'axes.labelsize'", ":", "18", ",", "\n", "'xtick.labelsize'", ":", "12", ",", "\n", "'ytick.labelsize'", ":", "12", ",", "\n", "'font.family'", ":", "'STIXGeneral'", ",", "\n", "'text.usetex'", ":", "True", ",", "\n", "}", ")", "\n", "\n", "if", "n", "is", "None", ":", "\n", "        ", "sizes", "=", "[", "2500", ",", "10000", ",", "25000", ",", "100000", "]", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "4", ",", "ncols", "=", "1", ",", "figsize", "=", "(", "13", ",", "18", ")", ")", "#(6.25, 18))", "\n", "legend_bbox", "=", "(", "0.4", ",", "1.32", ")", "\n", "\n", "", "else", ":", "\n", "        ", "sizes", "=", "[", "n", "]", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "axes", "=", "[", "ax", "]", "\n", "legend_bbox", "=", "(", "0.5", ",", "1.28", ")", "\n", "\n", "", "if", "mode", "==", "'abs'", ":", "\n", "        ", "y", "=", "'importance_abs'", "\n", "yscale", "=", "'symlog'", "\n", "linthresh", "=", "0.001", "\n", "ylabel", "=", "'Feature importance (score drop)'", "\n", "", "elif", "mode", "==", "'rel'", ":", "\n", "        ", "y", "=", "'importance_rel'", "\n", "yscale", "=", "'symlog'", "\n", "linthresh", "=", "0.001", "\n", "ylabel", "=", "'Relative score drop'", "\n", "", "elif", "mode", "==", "'percent'", ":", "\n", "        ", "y", "=", "'importance_rel_%'", "\n", "yscale", "=", "'symlog'", "\n", "linthresh", "=", "1", "\n", "ylabel", "=", "'Relative score drop normalized'", "\n", "", "elif", "mode", "==", "'ratio'", ":", "\n", "        ", "y", "=", "'importance_ratio'", "\n", "yscale", "=", "'symlog'", "\n", "linthresh", "=", "1", "\n", "ylabel", "=", "'Score drop normalized'", "\n", "\n", "", "colors", "=", "[", "\n", "sns", ".", "color_palette", "(", "'Set2'", ",", "n_colors", "=", "8", ")", ".", "as_hex", "(", ")", ",", "\n", "sns", ".", "color_palette", "(", "'husl'", ",", "n_colors", "=", "5", ")", ".", "as_hex", "(", ")", ",", "\n", "]", "\n", "colors", "=", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ",", "colors", ")", "\n", "\n", "for", "i", ",", "(", "size", ",", "ax", ")", "in", "enumerate", "(", "zip", "(", "sizes", ",", "axes", ")", ")", ":", "\n", "        ", "df", "=", "retrive_importance", "(", "size", ")", "\n", "print", "(", "df", ")", "\n", "\n", "if", "hue_by_task", ":", "\n", "            ", "sns", ".", "set_palette", "(", "sns", ".", "color_palette", "(", "colors", ")", ")", "\n", "sns", ".", "scatterplot", "(", "x", "=", "'mv_prop'", ",", "y", "=", "y", ",", "hue", "=", "'task'", ",", "style", "=", "'db'", ",", "\n", "markers", "=", "markers_db", ",", "data", "=", "df", ",", "ax", "=", "ax", ",", "s", "=", "50", ",", "\n", "hue_order", "=", "task_order_renamed", ",", "style_order", "=", "db_order", ",", "\n", "linewidth", "=", "0.1", ")", "# , legend=False)", "\n", "\n", "ncol", "=", "3", "\n", "legend_bbox", "=", "(", "0.5", ",", "1.7", ")", "\n", "# legend_bbox = (0.4, 1.7)", "\n", "title", "=", "'\\\\textbf{{Task}}'", "\n", "", "else", ":", "\n", "            ", "sns", ".", "set_palette", "(", "sns", ".", "color_palette", "(", "'colorblind'", ")", ")", "\n", "sns", ".", "scatterplot", "(", "x", "=", "'mv_prop'", ",", "y", "=", "y", ",", "hue", "=", "'db'", ",", "data", "=", "df", ",", "ax", "=", "ax", ",", "\n", "s", "=", "15", ",", "hue_order", "=", "db_order", ",", "linewidth", "=", "0.3", ")", "\n", "ncol", "=", "4", "\n", "title", "=", "'Database'", "\n", "\n", "", "ax", ".", "set_ylabel", "(", "ylabel", ")", "\n", "if", "i", "==", "len", "(", "sizes", ")", "-", "1", ":", "\n", "            ", "ax", ".", "set_xlabel", "(", "'Proportion of missing values in features'", ")", "\n", "", "else", ":", "\n", "            ", "ax", ".", "set_xlabel", "(", "None", ")", "\n", "\n", "", "ax", ".", "set_yscale", "(", "yscale", ",", "linthresh", "=", "linthresh", ")", "\n", "if", "yscale", "!=", "'log'", ":", "\n", "            ", "ax", ".", "axhline", "(", "0", ",", "xmin", "=", "0", ",", "xmax", "=", "1", ",", "color", "=", "'grey'", ",", "zorder", "=", "-", "10", ")", "#, lw=1)", "\n", "\n", "", "ax", ".", "set_title", "(", "f'n={size}'", ")", "\n", "\n", "# Update legend", "\n", "if", "i", "==", "0", ":", "\n", "            ", "handles", ",", "labels", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "\n", "if", "hue_by_task", ":", "\n", "                ", "task_handles", "=", "handles", "[", "1", ":", "14", "]", "\n", "db_markers", "=", "ax", ".", "collections", "[", "-", "4", ":", "]", "\n", "\n", "# Update markers shapes in the legend (all had same shape)", "\n", "for", "i", "in", "range", "(", "13", ")", ":", "\n", "                    ", "if", "i", "<", "5", ":", "\n", "                        ", "id_marker", "=", "0", "\n", "", "elif", "i", "<", "10", ":", "\n", "                        ", "id_marker", "=", "1", "\n", "", "elif", "i", "<", "12", ":", "\n", "                        ", "id_marker", "=", "2", "\n", "", "else", ":", "\n", "                        ", "id_marker", "=", "3", "\n", "", "h", "=", "task_handles", "[", "i", "]", "\n", "fc", "=", "h", ".", "get_fc", "(", ")", "\n", "ec", "=", "h", ".", "get_ec", "(", ")", "\n", "task_handles", "[", "i", "]", "=", "copy", ".", "copy", "(", "db_markers", "[", "id_marker", "]", ")", "\n", "task_handles", "[", "i", "]", ".", "set_fc", "(", "fc", ")", "\n", "task_handles", "[", "i", "]", ".", "set_ec", "(", "ec", ")", "\n", "\n", "", "task_labels", "=", "labels", "[", "1", ":", "14", "]", "\n", "task_labels", "=", "[", "t", ".", "split", "(", "'/'", ")", "[", "1", "]", "for", "t", "in", "task_labels", "]", "\n", "blank_handle", "=", "[", "handles", "[", "0", "]", "]", "\n", "blank_label", "=", "[", "''", "]", "\n", "# 3 columns legend", "\n", "handles", "=", "(", "\n", "blank_handle", "\n", "+", "task_handles", "[", ":", "5", "]", "\n", "+", "blank_handle", "\n", "+", "task_handles", "[", "5", ":", "10", "]", "\n", "+", "blank_handle", "\n", "+", "task_handles", "[", "10", ":", "12", "]", "\n", "+", "2", "*", "blank_handle", "\n", "+", "task_handles", "[", "12", ":", "13", "]", ")", "\n", "labels", "=", "(", "\n", "[", "'\\\\textbf{{Traumabase}}'", "]", "\n", "+", "task_labels", "[", ":", "5", "]", "\n", "+", "[", "'\\\\textbf{{UKBB}}'", "]", "\n", "+", "task_labels", "[", "5", ":", "10", "]", "\n", "+", "[", "'\\\\textbf{{MIMIC}}'", "]", "\n", "+", "task_labels", "[", "10", ":", "12", "]", "\n", "+", "blank_label", "\n", "+", "[", "'\\\\textbf{{NHIS}}'", "]", "\n", "+", "task_labels", "[", "12", ":", "13", "]", ")", "\n", "# 4 columns legend", "\n", "# handles = (blank_handle", "\n", "# + task_handles[:5]", "\n", "# + blank_handle", "\n", "# + task_handles[5:10]", "\n", "# + blank_handle", "\n", "# + task_handles[10:12]", "\n", "# + 4*blank_handle", "\n", "# + task_handles[12:13]", "\n", "# + 4*blank_handle)", "\n", "# labels = (['Traumabase']", "\n", "# + task_labels[:5]", "\n", "# + ['UKBB']", "\n", "# + task_labels[5:10]", "\n", "# + ['MIMIC']", "\n", "# + task_labels[10:12]", "\n", "# + 3*blank_label", "\n", "# + ['NHIS']", "\n", "# + task_labels[12:13]", "\n", "# + 4*blank_label)", "\n", "\n", "", "ax", ".", "legend", "(", "title", "=", "title", ",", "ncol", "=", "ncol", ",", "loc", "=", "'upper center'", ",", "\n", "bbox_to_anchor", "=", "legend_bbox", ",", "\n", "handles", "=", "handles", ",", "labels", "=", "labels", ",", "\n", ")", "\n", "\n", "", "else", ":", "\n", "            ", "ax", ".", "get_legend", "(", ")", ".", "remove", "(", ")", "\n", "\n", "# Add lowess", "\n", "", "if", "hue_by_task", ":", "\n", "            ", "colors_index", "=", "{", "task", ":", "i", "for", "i", ",", "task", "in", "enumerate", "(", "task_order_renamed", ")", "}", "\n", "for", "i", ",", "(", "index", ",", "group", ")", "in", "enumerate", "(", "df", ".", "groupby", "(", "'task'", ",", "sort", "=", "False", ")", ")", ":", "\n", "                ", "print", "(", "index", ")", "\n", "z", "=", "sm", ".", "nonparametric", ".", "lowess", "(", "group", "[", "y", "]", ",", "group", "[", "'mv_prop'", "]", ",", "frac", "=", "1", ")", "\n", "ax", ".", "plot", "(", "z", "[", ":", ",", "0", "]", ",", "z", "[", ":", ",", "1", "]", ",", "color", "=", "colors", "[", "colors_index", "[", "index", "]", "]", ",", "lw", "=", "1.5", ")", "#lw=0.8)", "\n", "\n", "# exit()", "\n", "\n", "", "", "", "fig_name", "=", "f'importance_{n}_avg_{mode}_hue{hue_by_task}'", "if", "average_folds", "else", "f'importance_{n}_{mode}'", "\n", "fig_folder", "=", "get_fig_folder", "(", "graphics_folder", ")", "\n", "fig", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_name}.pdf'", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "fig", ".", "savefig", "(", "join", "(", "fig_folder", ",", "f'{fig_name}.jpg'", ")", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "300", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.__init__.run": [[26, 79], ["os.makedirs", "print", "hasattr", "tests.run_wilcoxon", "tests.run_friedman", "tabs.run_scores", "statistics.run_mv", "statistics.run_prop", "statistics.run_cor", "mi.run_multiple_imputation", "tabs.run_desc", "statistics.run_time", "statistics.run_score_check", "difficulty.run_difficulty", "breakout.run_breakout", "mi.run_multiple_imputation", "importance.run_feature_importance", "ValueError"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_wilcoxon", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tests.run_friedman", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tabs.run_scores", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_mv", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_prop", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_cor", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.mi.run_multiple_imputation", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.tabs.run_desc", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_time", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.run_score_check", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.difficulty.run_difficulty", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.breakout.run_breakout", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.mi.run_multiple_imputation", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.importance.run_feature_importance"], []], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_tasks_TB.test_TB.test_hemo": [[10, 31], ["task.is_classif", "list", "test_tasks_TB.test_TB.assertCountEqual", "y.isna().any", "y.isna"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif"], ["def", "test_hemo", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test shock hemo task.\"\"\"", "\n", "task", "=", "tasks", "[", "'TB/hemo'", "]", "\n", "meta", "=", "task", ".", "meta", "\n", "\n", "assert", "task", ".", "is_classif", "(", ")", "\n", "\n", "X", "=", "task", ".", "X", "\n", "y", "=", "task", ".", "y", "\n", "\n", "n_rows", "=", "19569", "\n", "n_features", "=", "12", "\n", "\n", "assert", "X", ".", "shape", "==", "(", "n_rows", ",", "n_features", ")", "\n", "assert", "y", ".", "shape", "==", "(", "n_rows", ",", ")", "\n", "assert", "not", "y", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "\n", "assert", "task", ".", "_f_y", "==", "meta", ".", "predict", ".", "output_features", "\n", "L1", "=", "list", "(", "X", ".", "columns", ")", "\n", "L2", "=", "meta", ".", "transform", ".", "output_features", "\n", "self", ".", "assertCountEqual", "(", "L1", ",", "L2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_tasks_TB.test_TB.test_acid": [[32, 50], ["task.is_classif", "y.isna().any", "y.isna"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif"], ["", "def", "test_acid", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test acid tranexamic task.\"\"\"", "\n", "task", "=", "tasks", "[", "'TB/acid'", "]", "\n", "meta", "=", "task", ".", "meta", "\n", "\n", "assert", "task", ".", "is_classif", "(", ")", "\n", "\n", "X", "=", "task", ".", "X", "\n", "y", "=", "task", ".", "y", "\n", "\n", "n_rows", "=", "1770", "\n", "n_features", "=", "62", "\n", "\n", "assert", "X", ".", "shape", "==", "(", "n_rows", ",", "n_features", ")", "\n", "assert", "y", ".", "shape", "==", "(", "n_rows", ",", ")", "\n", "assert", "not", "y", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "\n", "assert", "task", ".", "_f_y", "==", "meta", ".", "predict", ".", "output_features", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_tasks_TB.test_TB.test_platelet": [[51, 69], ["task.is_classif", "y.isna().any", "y.isna"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif"], ["", "def", "test_platelet", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test platelet task.\"\"\"", "\n", "task", "=", "tasks", "[", "'TB/platelet'", "]", "\n", "meta", "=", "task", ".", "meta", "\n", "\n", "assert", "not", "task", ".", "is_classif", "(", ")", "\n", "\n", "X", "=", "task", ".", "X", "\n", "y", "=", "task", ".", "y", "\n", "\n", "n_rows", "=", "19042", "\n", "n_features", "=", "15", "\n", "\n", "assert", "X", ".", "shape", "==", "(", "n_rows", ",", "n_features", ")", "\n", "assert", "y", ".", "shape", "==", "(", "n_rows", ",", ")", "\n", "assert", "not", "y", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "\n", "assert", "task", ".", "_f_y", "==", "meta", ".", "predict", ".", "output_features", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_tasks_TB.test_TB.test_death": [[70, 87], ["task.is_classif", "y.isna().any", "y.isna"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif"], ["", "def", "test_death", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test death task.\"\"\"", "\n", "task", "=", "tasks", "[", "'TB/death_pvals'", "]", "\n", "meta", "=", "task", ".", "meta", "\n", "\n", "assert", "task", ".", "is_classif", "(", ")", "\n", "\n", "X", "=", "task", ".", "X", "\n", "y", "=", "task", ".", "y", "\n", "\n", "n_rows", "=", "12341", "\n", "\n", "assert", "X", ".", "shape", "==", "(", "n_rows", ",", "99", ")", "\n", "assert", "y", ".", "shape", "==", "(", "n_rows", ",", ")", "\n", "assert", "not", "y", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "\n", "assert", "task", ".", "_f_y", "==", "meta", ".", "predict", ".", "output_features", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_stats.test_indicators": [[17, 133], ["statistics.statistics.get_indicators_mv", "pandas.concat"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.get_indicators_mv"], ["def", "test_indicators", "(", ")", ":", "\n", "    ", "\"\"\"Test all the indicators on a hand-crafted missing values df.\"\"\"", "\n", "indicators", "=", "get_indicators_mv", "(", "mv", ")", "\n", "\n", "# Merge all the indicators except feature-wise which has a different", "\n", "# way to store the information", "\n", "df", "=", "pd", ".", "concat", "(", "[", "\n", "indicators", "[", "'global'", "]", ",", "\n", "indicators", "[", "'features'", "]", ",", "\n", "indicators", "[", "'rows'", "]", ",", "\n", "indicators", "[", "'rm_rows'", "]", ",", "\n", "indicators", "[", "'rm_features'", "]", ",", "\n", "]", ",", "axis", "=", "1", ")", "\n", "\n", "df3", "=", "indicators", "[", "'feature-wise'", "]", "\n", "\n", "# 1st indicator", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_rows'", "]", "==", "4", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_cols'", "]", "==", "5", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_values'", "]", "==", "20", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_mv'", "]", "==", "6", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_mv1'", "]", "==", "2", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_mv2'", "]", "==", "4", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_not_mv'", "]", "==", "14", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_mv'", "]", "==", "30", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_mv1'", "]", "==", "10", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_mv2'", "]", "==", "20", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_not_mv'", "]", "==", "70", "\n", "\n", "# 2nd indicator", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_f_w_mv'", "]", "==", "4", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_f_w_mv1_o'", "]", "==", "1", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_f_w_mv2_o'", "]", "==", "2", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_f_w_mv_1a2'", "]", "==", "1", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_f_wo_mv'", "]", "==", "1", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_f_w_mv'", "]", "==", "80", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_f_w_mv1_o'", "]", "==", "20", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_f_w_mv2_o'", "]", "==", "40", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_f_w_mv_1a2'", "]", "==", "20", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_f_wo_mv'", "]", "==", "20", "\n", "\n", "# 3rd indicator", "\n", "assert", "df3", ".", "at", "[", "'F1'", ",", "'N MV'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F1'", ",", "'N MV1'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F1'", ",", "'N MV2'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F1'", ",", "'F MV'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F1'", ",", "'F MV1'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F1'", ",", "'F MV2'", "]", "==", "0", "\n", "\n", "assert", "df3", ".", "at", "[", "'F2'", ",", "'N MV'", "]", "==", "1", "\n", "assert", "df3", ".", "at", "[", "'F2'", ",", "'N MV1'", "]", "==", "1", "\n", "assert", "df3", ".", "at", "[", "'F2'", ",", "'N MV2'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F2'", ",", "'F MV'", "]", "==", "25", "\n", "assert", "df3", ".", "at", "[", "'F2'", ",", "'F MV1'", "]", "==", "25", "\n", "assert", "df3", ".", "at", "[", "'F2'", ",", "'F MV2'", "]", "==", "0", "\n", "\n", "assert", "df3", ".", "at", "[", "'F3'", ",", "'N MV'", "]", "==", "1", "\n", "assert", "df3", ".", "at", "[", "'F3'", ",", "'N MV1'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F3'", ",", "'N MV2'", "]", "==", "1", "\n", "assert", "df3", ".", "at", "[", "'F3'", ",", "'F MV'", "]", "==", "25", "\n", "assert", "df3", ".", "at", "[", "'F3'", ",", "'F MV1'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F3'", ",", "'F MV2'", "]", "==", "25", "\n", "\n", "assert", "df3", ".", "at", "[", "'F4'", ",", "'N MV'", "]", "==", "2", "\n", "assert", "df3", ".", "at", "[", "'F4'", ",", "'N MV1'", "]", "==", "1", "\n", "assert", "df3", ".", "at", "[", "'F4'", ",", "'N MV2'", "]", "==", "1", "\n", "assert", "df3", ".", "at", "[", "'F4'", ",", "'F MV'", "]", "==", "50", "\n", "assert", "df3", ".", "at", "[", "'F4'", ",", "'F MV1'", "]", "==", "25", "\n", "assert", "df3", ".", "at", "[", "'F4'", ",", "'F MV2'", "]", "==", "25", "\n", "\n", "assert", "df3", ".", "at", "[", "'F5'", ",", "'N MV'", "]", "==", "2", "\n", "assert", "df3", ".", "at", "[", "'F5'", ",", "'N MV1'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F5'", ",", "'N MV2'", "]", "==", "2", "\n", "assert", "df3", ".", "at", "[", "'F5'", ",", "'F MV'", "]", "==", "50", "\n", "assert", "df3", ".", "at", "[", "'F5'", ",", "'F MV1'", "]", "==", "0", "\n", "assert", "df3", ".", "at", "[", "'F5'", ",", "'F MV2'", "]", "==", "50", "\n", "\n", "# 4th indicator", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_w_mv'", "]", "==", "3", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_w_mv1_o'", "]", "==", "0", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_w_mv2_o'", "]", "==", "2", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_w_mv_1a2'", "]", "==", "1", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_wo_mv'", "]", "==", "1", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_w_mv'", "]", "==", "75", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_w_mv1_o'", "]", "==", "0", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_w_mv2_o'", "]", "==", "50", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_w_mv_1a2'", "]", "==", "25", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_wo_mv'", "]", "==", "25", "\n", "\n", "# 5th indicator", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv1'", "]", "==", "3", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv2'", "]", "==", "4", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv_1o2'", "]", "==", "4", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv1_o'", "]", "==", "3", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv2_o'", "]", "==", "4", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_r_a_rm_mv_1a2'", "]", "==", "2", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv1'", "]", "==", "75", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv2'", "]", "==", "100", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv_1o2'", "]", "==", "100", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv1_o'", "]", "==", "75", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv2_o'", "]", "==", "100", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_r_a_rm_mv_1a2'", "]", "==", "50", "\n", "\n", "# 6th indicator", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv1'", "]", "==", "5", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv2'", "]", "==", "7", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv_1o2'", "]", "==", "10", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv1_o'", "]", "==", "3", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv2_o'", "]", "==", "5", "\n", "assert", "df", ".", "at", "[", "0", ",", "'n_v_lost_mv_1a2'", "]", "==", "2", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv1'", "]", "==", "25", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv2'", "]", "==", "35", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv_1o2'", "]", "==", "50", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv1_o'", "]", "==", "15", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv2_o'", "]", "==", "25", "\n", "assert", "df", ".", "at", "[", "0", ",", "'f_v_lost_mv_1a2'", "]", "==", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_stats.test_correlation": [[135, 142], ["numpy.random.seed", "numpy.random.uniform", "statistics.statistics.compute_correlation", "numpy.corrcoef", "numpy.isclose().all", "numpy.isclose"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.statistics.statistics.compute_correlation"], ["", "def", "test_correlation", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "X", "=", "np", ".", "random", ".", "uniform", "(", "-", "100", ",", "100", ",", "size", "=", "(", "10000", ",", "100", ")", ")", "\n", "R1", "=", "compute_correlation", "(", "X", ".", "T", ")", "\n", "R2", "=", "np", ".", "corrcoef", "(", "X", ".", "T", ")", "\n", "\n", "assert", "np", ".", "isclose", "(", "R1", ",", "R2", ")", ".", "all", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_tasks_UKBB.test_UKBB.test_breast": [[23, 44], ["task.is_classif", "list", "test_tasks_UKBB.test_UKBB.assertCountEqual", "y.isna().any", "y.isna"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif"], ["def", "test_breast", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test breast cancer task.\"\"\"", "\n", "task", "=", "tasks", "[", "'UKBB/breast_pvals'", "]", "\n", "meta", "=", "task", ".", "meta", "\n", "\n", "assert", "task", ".", "is_classif", "(", ")", "\n", "\n", "X", "=", "task", ".", "X", "\n", "y", "=", "task", ".", "y", "\n", "\n", "n_rows", "=", "273384", "\n", "n_features", "=", "n_top_pvals", "\n", "\n", "assert", "X", ".", "shape", "==", "(", "n_rows", ",", "n_features", ")", "\n", "assert", "y", ".", "shape", "==", "(", "n_rows", ",", ")", "\n", "assert", "not", "y", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "\n", "assert", "task", ".", "_f_y", "==", "meta", ".", "predict", ".", "output_features", "\n", "L1", "=", "list", "(", "X", ".", "columns", ")", "\n", "L2", "=", "meta", ".", "select", ".", "output_features", "\n", "self", ".", "assertCountEqual", "(", "L1", ",", "L2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_tasks_NHIS.test_NHIS.test_income": [[23, 40], ["task.is_classif", "y.isna().any", "y.isna"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif"], ["def", "test_income", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test income cancer task.\"\"\"", "\n", "task", "=", "tasks", "[", "'NHIS/income_pvals'", "]", "\n", "meta", "=", "task", ".", "meta", "\n", "\n", "assert", "not", "task", ".", "is_classif", "(", ")", "\n", "\n", "X", "=", "task", ".", "X", "\n", "y", "=", "task", ".", "y", "\n", "\n", "n_rows", "=", "20987", "\n", "\n", "assert", "X", ".", "shape", "[", "0", "]", "==", "n_rows", "\n", "assert", "y", ".", "shape", "==", "(", "n_rows", ",", ")", "\n", "assert", "not", "y", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "\n", "assert", "task", ".", "_f_y", "==", "meta", ".", "predict", ".", "output_features", "\n", "# L1 = list(X.columns)", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tests.test_tasks_NHIS.test_NHIS.test_bmi": [[44, 61], ["task.is_classif", "y.isna().any", "y.isna"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.task.Task.is_classif"], ["", "def", "test_bmi", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test bmi cancer task.\"\"\"", "\n", "task", "=", "tasks", "[", "'NHIS/bmi_pvals'", "]", "\n", "meta", "=", "task", ".", "meta", "\n", "\n", "assert", "not", "task", ".", "is_classif", "(", ")", "\n", "\n", "X", "=", "task", ".", "X", "\n", "y", "=", "task", ".", "y", "\n", "\n", "n_rows", "=", "11247", "\n", "\n", "assert", "X", ".", "shape", "[", "0", "]", "==", "n_rows", "\n", "assert", "y", ".", "shape", "==", "(", "n_rows", ",", ")", "\n", "assert", "not", "y", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "\n", "assert", "task", ".", "_f_y", "==", "meta", ".", "predict", ".", "output_features", "\n", "# L1 = list(X.columns)", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.UKBB.UKBB.__init__": [[13, 39], ["base.Database.__init__"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS.__init__"], ["ICD9_cancer", "=", "'40013-0.0'", "\n", "\n", "ICD10", "=", "'41270-0.0'", "\n", "ICD10_main", "=", "'41202-0.0'", "\n", "ICD10_sec", "=", "'41204-0.0'", "\n", "ICD10_cancer", "=", "'40006-0.0'", "\n", "\n", "\n", "# Define some helpers", "\n", "def", "ICD9_equal", "(", "df", ",", "value", ")", ":", "\n", "    ", "\"\"\"Define a helper for ICD9 diagnsoses.\"\"\"", "\n", "return", "(", "(", "df", "[", "ICD9", "]", "==", "value", ")", "\n", "|", "(", "df", "[", "ICD9_main", "]", "==", "value", ")", "\n", "|", "(", "df", "[", "ICD9_sec", "]", "==", "value", ")", ")", "\n", "\n", "\n", "", "def", "ICD10_equal", "(", "df", ",", "value", ")", ":", "\n", "    ", "\"\"\"Define a helper for ICD10 diagnsoses.\"\"\"", "\n", "return", "(", "(", "df", "[", "ICD10", "]", "==", "value", ")", "\n", "|", "(", "df", "[", "ICD10_main", "]", "==", "value", ")", "\n", "|", "(", "df", "[", "ICD10_sec", "]", "==", "value", ")", ")", "\n", "\n", "\n", "", "def", "cancer_ICD10", "(", "df", ",", "value", ")", ":", "\n", "    ", "\"\"\"Define a helper for ICD10 cancer diagnsoses.\"\"\"", "\n", "return", "df", "[", "ICD10_cancer", "]", "==", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.UKBB.UKBB.heuristic": [[40, 51], ["pandas.Series", "series.isna"], "methods", ["None"], ["\n", "", "def", "cancer_ICD9", "(", "df", ",", "value", ")", ":", "\n", "    ", "\"\"\"Define a helper for ICD9 cancer diagnsoses.\"\"\"", "\n", "return", "df", "[", "ICD9_cancer", "]", "==", "value", "\n", "\n", "\n", "# Task 1.1: Breast cancer prediction followng paper", "\n", "# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6558751/", "\n", "# -----------------------------------------------------", "\n", "# The following is outside the task function because used by 2 tasks", "\n", "# Define the callable used to select the indexes to keep in the df", "\n", "", "def", "select_idx_breast", "(", "df", ")", ":", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.MIMIC.MIMIC.__init__": [[13, 56], ["base.Database.__init__"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS.__init__"], ["try", ":", "\n", "    ", "patients", "=", "dd", ".", "read_csv", "(", "MIMIC", ".", "frame_paths", "[", "'patients'", "]", ")", ".", "set_index", "(", "'ROW_ID'", ")", "\n", "diagnoses_icd", "=", "dd", ".", "read_csv", "(", "MIMIC", ".", "frame_paths", "[", "'diagnoses_icd'", "]", ",", "assume_missing", "=", "True", ")", ".", "set_index", "(", "'ROW_ID'", ")", "\n", "patients_diagnosis", "=", "patients", ".", "merge", "(", "diagnoses_icd", ".", "drop", "(", "[", "'SEQ_NUM'", "]", ",", "axis", "=", "1", ")", ",", "how", "=", "'left'", ",", "on", "=", "'SUBJECT_ID'", ")", "\n", "\n", "# Tasks specific tables", "\n", "septic_shock", "=", "dd", ".", "from_pandas", "(", "pd", ".", "DataFrame", "(", "{", "'ICD9_CODE'", ":", "[", "'78552'", "]", "}", ")", ",", "npartitions", "=", "1", ")", "\n", "hemo_shock", "=", "dd", ".", "from_pandas", "(", "pd", ".", "DataFrame", "(", "{", "'ICD9_CODE'", ":", "[", "'78559'", ",", "'99809'", ",", "'9584'", "]", "}", ")", ",", "npartitions", "=", "1", ")", "\n", "\n", "", "except", "FileNotFoundError", ":", "\n", "    ", "patients", "=", "None", "\n", "diagnoses_icd", "=", "None", "\n", "patients_diagnosis", "=", "None", "\n", "septic_shock", "=", "None", "\n", "hemo_shock", "=", "None", "\n", "\n", "\n", "# Task 1: Septic shock prediciton", "\n", "# -------------------------------", "\n", "", "def", "septic_task", "(", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return TaskMeta for septic shock prediction.\"\"\"", "\n", "# Define y", "\n", "def", "define_predict_septic", "(", "df", ")", ":", "\n", "        ", "\"\"\"Compute y from patients table.\"\"\"", "\n", "# Ignore given df", "\n", "positives", "=", "patients_diagnosis", ".", "merge", "(", "septic_shock", ",", "how", "=", "'inner'", ",", "on", "=", "'ICD9_CODE'", ")", "\n", "positives", "=", "positives", ".", "drop_duplicates", "(", "subset", "=", "[", "'SUBJECT_ID'", "]", ")", ".", "set_index", "(", "'SUBJECT_ID'", ")", ".", "index", "\n", "positives_idx", "=", "positives", ".", "compute", "(", ")", "\n", "\n", "# Get full idx from df and set the complementary to 0", "\n", "# idx = patients.set_index('SUBJECT_ID').index.compute()", "\n", "idx", "=", "df", ".", "index", "\n", "# need to intersect because one index of positives_idx is not in idx", "\n", "negatives_idx", "=", "idx", ".", "difference", "(", "positives_idx", ")", ".", "intersection", "(", "idx", ")", "\n", "positives_idx", "=", "positives_idx", ".", "intersection", "(", "idx", ")", "\n", "\n", "positives", "=", "pd", ".", "DataFrame", "(", "{", "'y'", ":", "1", "}", ",", "index", "=", "positives_idx", ")", "\n", "negatives", "=", "pd", ".", "DataFrame", "(", "{", "'y'", ":", "0", "}", ",", "index", "=", "negatives_idx", ")", "\n", "df", "=", "pd", ".", "concat", "(", "(", "positives", ",", "negatives", ")", ",", "axis", "=", "0", ")", ".", "sort_index", "(", ")", "\n", "\n", "return", "df", "\n", "\n", "", "septic_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.MIMIC.MIMIC.heuristic": [[57, 68], ["pandas.Series", "series.isna"], "methods", ["None"], ["transform", "=", "define_predict_septic", ",", "\n", "output_features", "=", "[", "'y'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "septic_pvals_keep_transform", "=", "None", "\n", "septic_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.__init__": [[34, 58], ["dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "base.Database.load"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.load"], ["    ", "@", "abstractmethod", "\n", "def", "__init__", "(", "self", ",", "name", "=", "''", ",", "acronym", "=", "''", ",", "paths", "=", "dict", "(", ")", ",", "sep", "=", "','", ",", "load", "=", "None", ",", "\n", "encoding", "=", "'utf-8'", ",", "encode", "=", "None", ",", "data_folder", "=", "None", ")", ":", "\n", "        ", "self", ".", "dataframes", "=", "dict", "(", ")", "\n", "self", ".", "missing_values", "=", "dict", "(", ")", "\n", "self", ".", "feature_types", "=", "dict", "(", ")", "\n", "self", ".", "ordinal_orders", "=", "dict", "(", ")", "\n", "\n", "self", ".", "encoded_dataframes", "=", "dict", "(", ")", "\n", "self", ".", "encoded_missing_values", "=", "dict", "(", ")", "\n", "self", ".", "encoded_feature_types", "=", "dict", "(", ")", "\n", "self", ".", "encoded_parent", "=", "dict", "(", ")", "\n", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "acronym", "=", "acronym", "\n", "self", ".", "frame_paths", "=", "paths", "\n", "self", ".", "_sep", "=", "sep", "\n", "self", ".", "_encoding", "=", "encoding", "\n", "self", ".", "encode", "=", "encode", "\n", "self", ".", "_dtype", "=", "None", "\n", "self", ".", "data_folder", "=", "data_folder", "\n", "\n", "if", "load", "is", "not", "None", ":", "\n", "            ", "self", ".", "load", "(", "load", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.available_paths": [[59, 62], ["base.Database.frame_paths.items", "os.path.exists"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "available_paths", "(", "self", ")", ":", "\n", "        ", "return", "{", "n", ":", "p", "for", "n", ",", "p", "in", "self", ".", "frame_paths", ".", "items", "(", ")", "if", "os", ".", "path", ".", "exists", "(", "p", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.is_loaded": [[63, 65], ["None"], "methods", ["None"], ["", "def", "is_loaded", "(", "self", ",", "df_name", ")", ":", "\n", "        ", "return", "df_name", "in", "self", ".", "dataframes", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.load": [[66, 72], ["base.Database._load_feature_types", "base.Database._load_db", "base.Database._load_ordinal_orders", "base.Database._find_missing_values", "base.Database._encode"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_feature_types", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_db", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_ordinal_orders", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._find_missing_values", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS._encode"], ["", "def", "load", "(", "self", ",", "meta", ")", ":", "\n", "        ", "self", ".", "_load_feature_types", "(", "meta", ")", "\n", "self", ".", "_load_db", "(", "meta", ")", "\n", "self", ".", "_load_ordinal_orders", "(", "meta", ")", "\n", "self", ".", "_find_missing_values", "(", "meta", ")", "\n", "self", ".", "_encode", "(", "meta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.get_drop_and_keep_meta": [[73, 99], ["Database.get_drop_and_keep"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.get_drop_and_keep"], ["", "@", "staticmethod", "\n", "def", "get_drop_and_keep_meta", "(", "features", ",", "meta", ")", ":", "\n", "        ", "\"\"\"Give which feature to keep and which to drop from a TaskMeta.\n\n        Prameters\n        ---------\n        features : list or pd.Series or pd.DataFrame\n            Gives the universal set of features, i.e the features to consider.\n        meta : TaskMeta object\n            Object having keep, drop, keep_contains, drop_contains parameters.\n\n        Returns\n        -------\n        to_keep : set\n            Set containing the features to keep\n        to_drop : set\n            Set containing the feature to drop\n\n        \"\"\"", "\n", "return", "Database", ".", "get_drop_and_keep", "(", "\n", "features", "=", "features", ",", "\n", "keep", "=", "meta", ".", "keep", ",", "\n", "keep_contains", "=", "meta", ".", "keep_contains", ",", "\n", "drop", "=", "meta", ".", "drop", ",", "\n", "drop_contains", "=", "meta", ".", "drop_contains", ",", "\n", "predict", "=", "meta", ".", "predict", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.get_drop_and_keep": [[101, 186], ["isinstance", "any", "numpy.logical_or.reduce", "pandas.Series", "list", "set", "select.intersection.intersection.intersection", "isinstance", "any", "any", "ValueError", "any", "any", "numpy.array", "set", "set", "isinstance", "set", "set", "ValueError", "pandas.Index", "ValueError", "pandas.Index.str.contains"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_drop_and_keep", "(", "features", ",", "keep", "=", "None", ",", "keep_contains", "=", "None", ",", "drop", "=", "None", ",", "\n", "drop_contains", "=", "None", ",", "predict", "=", "None", ")", ":", "\n", "        ", "\"\"\"Give which feature to keep and which to drop from a TaskMeta.\n\n        Prameters\n        ---------\n        features : list or pd.Series or pd.DataFrame\n            Gives the universal set of features, i.e the features to consider.\n        keep : list of str\n            List of features to keep.\n        keep_contains : list of str\n            List of patterns of features to keep.\n        drop : list of str\n            List of features to drop.\n        drop_contains : list of str\n            List of patterns of features to drop.\n\n        Returns\n        -------\n        to_keep : set\n            Set containing the features to keep\n        to_drop : set\n            Set containing the feature to drop\n\n        \"\"\"", "\n", "# Check features", "\n", "if", "isinstance", "(", "features", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "features", "=", "features", ".", "columns", "\n", "\n", "", "elif", "isinstance", "(", "features", ",", "pd", ".", "Series", ")", ":", "\n", "            ", "features", "=", "features", ".", "index", "\n", "\n", "", "elif", "isinstance", "(", "features", ",", "list", ")", ":", "\n", "            ", "features", "=", "pd", ".", "Index", "(", "features", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'features must be df, series or list.'", ")", "\n", "\n", "# Check keep and drop", "\n", "", "if", "any", "(", "(", "keep", ",", "keep_contains", ")", ")", "and", "any", "(", "(", "drop", ",", "drop_contains", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot use keep and drop at the same time.'", ")", "\n", "\n", "# Case where neither keep nor drop is given", "\n", "", "if", "not", "any", "(", "(", "keep", ",", "keep_contains", ",", "drop", ",", "drop_contains", ")", ")", ":", "\n", "            ", "return", "set", "(", "features", ")", ",", "set", "(", ")", "\n", "\n", "", "if", "any", "(", "(", "keep", ",", "keep_contains", ")", ")", ":", "\n", "            ", "method", "=", "'keep'", "\n", "select", "=", "[", "]", "if", "keep", "is", "None", "else", "keep", "\n", "if", "predict", "is", "not", "None", ":", "\n", "                ", "select", "+=", "[", "predict", "]", "\n", "", "select_contains", "=", "[", "]", "if", "keep_contains", "is", "None", "else", "keep_contains", "\n", "\n", "", "elif", "any", "(", "(", "drop", ",", "drop_contains", ")", ")", ":", "\n", "            ", "method", "=", "'drop'", "\n", "select", "=", "[", "]", "if", "drop", "is", "None", "else", "drop", "\n", "select_contains", "=", "[", "]", "if", "drop_contains", "is", "None", "else", "drop_contains", "\n", "\n", "# Convert select_contains based on patterns to explicit selection", "\n", "", "select_array", "=", "np", ".", "logical_or", ".", "reduce", "(", "\n", "np", ".", "array", "(", "[", "features", ".", "str", ".", "contains", "(", "p", ")", "for", "p", "in", "select_contains", "]", ")", "\n", ")", "\n", "select_series", "=", "pd", ".", "Series", "(", "select_array", ",", "index", "=", "features", ")", "\n", "select_extra", "=", "list", "(", "select_series", "[", "select_series", "]", ".", "index", ")", "\n", "\n", "# Merge select and select_extra", "\n", "select", "=", "set", "(", "select", "+", "select_extra", ")", "\n", "\n", "# Keep only the features present in features (non existing features", "\n", "# may have been given in keep/drop...)", "\n", "select", "=", "select", ".", "intersection", "(", "set", "(", "features", ")", ")", "\n", "\n", "# Transform drop selection into keep selection", "\n", "select_complement", "=", "set", "(", "features", ")", "-", "select", "\n", "# select_complement = Database.get_complement(select, list(features))", "\n", "\n", "if", "method", "==", "'drop'", ":", "\n", "            ", "if", "predict", "is", "not", "None", "and", "predict", "in", "select", ":", "\n", "                ", "raise", "ValueError", "(", "'Feature to predict is in features to drop.'", ")", "\n", "\n", "", "return", "select_complement", ",", "select", "\n", "\n", "", "assert", "method", "==", "'keep'", "\n", "return", "select", ",", "select_complement", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.__getitem__": [[187, 190], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"Get data frame giving its name.\"\"\"", "\n", "return", "self", ".", "dataframes", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.df_names": [[191, 194], ["list", "base.Database.dataframes.keys"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], ["", "def", "df_names", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get data frames' names.\"\"\"", "\n", "return", "list", "(", "self", ".", "dataframes", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_db": [[195, 253], ["isinstance", "logger.info", "pandas.read_csv", "logger.info", "ValueError", "isinstance", "pandas.read_csv", "base.Database.get_drop_and_keep_meta", "logger.info", "pandas.read_csv", "logger.info", "df_utils.get_missing_values", "logger.info", "len", "len"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.get_drop_and_keep_meta", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values"], ["", "def", "_load_db", "(", "self", ",", "meta", ")", ":", "\n", "        ", "if", "isinstance", "(", "meta", ",", "str", ")", ":", "\n", "            ", "df_name", ",", "tag", "=", "meta", ",", "meta", "\n", "", "else", ":", "\n", "            ", "df_name", ",", "tag", "=", "meta", ".", "df_name", ",", "meta", ".", "tag", "\n", "\n", "", "logger", ".", "info", "(", "f'Loading {df_name} data frame.'", ")", "\n", "available_paths", "=", "self", ".", "available_paths", "\n", "\n", "if", "df_name", "not", "in", "available_paths", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f'{df_name} not an available name.\\n'", "\n", "f'Available name and paths are {available_paths}.'", "\n", ")", "\n", "", "p", "=", "self", ".", "frame_paths", "[", "df_name", "]", "\n", "\n", "# dtype = None", "\n", "# if self._dtype is not None:", "\n", "#     dtype = self._dtype.get(df_name, None)", "\n", "\n", "if", "not", "isinstance", "(", "meta", ",", "str", ")", ":", "\n", "# Load only the features of the database (avoid load time)", "\n", "            ", "features", "=", "pd", ".", "read_csv", "(", "p", ",", "sep", "=", "self", ".", "_sep", ",", "encoding", "=", "self", ".", "_encoding", ",", "\n", "nrows", "=", "0", ")", "\n", "\n", "# Compute index where feature to predict is Nan", "\n", "if", "meta", ".", "predict", "is", "not", "None", "and", "meta", ".", "predict", "in", "features", ":", "\n", "                ", "df_predict", "=", "pd", ".", "read_csv", "(", "p", ",", "sep", "=", "self", ".", "_sep", ",", "encoding", "=", "self", ".", "_encoding", ",", "\n", "usecols", "=", "[", "meta", ".", "predict", "]", ",", "squeeze", "=", "True", ")", "\n", "logger", ".", "info", "(", "\n", "f'Raw DB of shape [{df_predict.size} x {features.shape[1]}]'", ")", "\n", "df_predict_mv", "=", "get_missing_values", "(", "df_predict", ",", "self", ".", "heuristic", ")", "\n", "index_to_drop", "=", "df_predict", ".", "index", "[", "df_predict_mv", "!=", "0", "]", "+", "1", "\n", "logger", ".", "info", "(", "\n", "f'Rows to drop because NA in predict {len(index_to_drop)}'", ")", "\n", "", "else", ":", "\n", "                ", "index_to_drop", "=", "None", "\n", "\n", "# Compute the features to keep", "\n", "", "to_keep", ",", "to_drop", "=", "self", ".", "get_drop_and_keep_meta", "(", "features", ",", "meta", ")", "\n", "logger", ".", "info", "(", "\n", "f'Features to drop as specified in meta {len(to_drop)}'", ")", "\n", "\n", "", "else", ":", "\n", "            ", "to_keep", "=", "None", "\n", "index_to_drop", "=", "None", "\n", "\n", "# Load only the features needed: save a lot of time and space", "\n", "", "df", "=", "pd", ".", "read_csv", "(", "p", ",", "sep", "=", "self", ".", "_sep", ",", "encoding", "=", "self", ".", "_encoding", ",", "\n", "usecols", "=", "to_keep", ",", "skiprows", "=", "index_to_drop", ")", "\n", "\n", "logger", ".", "info", "(", "f'df {tag} loaded with shape {df.shape}'", ")", "\n", "# dtype=dtype)", "\n", "\n", "# Replace potential infinite values by Nans", "\n", "# df.replace([np.inf, -np.inf], np.nan, inplace=True)", "\n", "\n", "self", ".", "dataframes", "[", "tag", "]", "=", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.heuristic": [[254, 272], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "heuristic", "(", "self", ",", "series", ")", ":", "\n", "        ", "\"\"\"Implement the heuristic for detecting missing values.\n\n        Parameters\n        ----------\n        series : pandas.Series\n            One column of the NHIS dataframe, stored as a pandas.Series object.\n\n        Returns\n        -------\n        pandas.Series\n            A series with same name and index as input series but having values\n            in [0, 1, 2] encoding respectively: Not a missing value,\n            Not applicable, Not available.\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_feature_types": [[273, 291], ["logger.info", "isinstance", "features_type._load_feature_types", "print"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_feature_types"], ["", "def", "_load_feature_types", "(", "self", ",", "meta", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f'Loading feature types for {self.acronym}.'", ")", "\n", "\n", "if", "isinstance", "(", "meta", ",", "str", ")", ":", "\n", "            ", "df_name", ",", "tag", "=", "meta", ",", "meta", "\n", "", "else", ":", "\n", "            ", "df_name", ",", "tag", "=", "meta", ".", "df_name", ",", "meta", ".", "tag", "\n", "\n", "", "try", ":", "\n", "            ", "types", "=", "_load_feature_types", "(", "self", ",", "df_name", ",", "anonymized", "=", "False", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "print", "(", "\n", "f'{df_name}: error while loading feature type. '", "\n", "f'Check if lengths match. Ignored.'", "\n", ")", "\n", "return", "\n", "\n", "", "self", ".", "feature_types", "[", "tag", "]", "=", "types", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._set_dtypes": [[292, 300], ["logger.info", "logger.info", "df_utils.dtype_from_types", "dict"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.dtype_from_types"], ["", "def", "_set_dtypes", "(", "self", ",", "meta", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f'Setting dtypes for {self.acronym}.'", ")", "\n", "if", "self", ".", "_dtype", "is", "None", ":", "\n", "            ", "self", ".", "_dtype", "=", "dict", "(", ")", "\n", "\n", "", "logger", ".", "info", "(", "f'Setting dtypes of {meta.tag}.'", ")", "\n", "types", "=", "self", ".", "feature_types", "[", "meta", ".", "tag", "]", "\n", "self", ".", "_dtype", "[", "meta", ".", "tag", "]", "=", "dtype_from_types", "(", "types", ",", "type_to_dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._load_ordinal_orders": [[301, 324], ["logger.info", "isinstance", "logger.info", "os.path.exists", "print", "open", "yaml.safe_load", "print"], "methods", ["None"], ["", "def", "_load_ordinal_orders", "(", "self", ",", "meta", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f'Loading ordinal orders for {self.acronym}.'", ")", "\n", "\n", "if", "isinstance", "(", "meta", ",", "str", ")", ":", "\n", "            ", "df_name", ",", "tag", "=", "meta", ",", "meta", "\n", "", "else", ":", "\n", "            ", "df_name", ",", "tag", "=", "meta", ".", "df_name", ",", "meta", ".", "tag", "\n", "\n", "", "logger", ".", "info", "(", "f'Loading ordinal orders of {df_name}.'", ")", "\n", "filepath", "=", "f'{METADATA_PATH}/ordinal_orders/{self.acronym}/{df_name}.yml'", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "filepath", ")", ":", "\n", "            ", "print", "(", "f'Order file not found. No order loaded for {df_name}.'", ")", "\n", "return", "\n", "\n", "", "with", "open", "(", "filepath", ",", "'r'", ")", "as", "file", ":", "\n", "            ", "try", ":", "\n", "                ", "order", "=", "yaml", ".", "safe_load", "(", "file", ")", "\n", "", "except", "yaml", ".", "YAMLError", "as", "exc", ":", "\n", "                ", "print", "(", "f'{exc}. No order loaded for {df_name}.'", ")", "\n", "return", "\n", "\n", "", "", "self", ".", "ordinal_orders", "[", "tag", "]", "=", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._find_missing_values": [[325, 330], ["logger.info", "df_utils.get_missing_values", "isinstance"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.get_missing_values"], ["", "def", "_find_missing_values", "(", "self", ",", "meta", ")", ":", "\n", "        ", "tag", "=", "meta", "if", "isinstance", "(", "meta", ",", "str", ")", "else", "meta", ".", "tag", "\n", "logger", ".", "info", "(", "f'Finding missing values of {tag}.'", ")", "\n", "df", "=", "self", ".", "dataframes", "[", "tag", "]", "\n", "self", ".", "missing_values", "[", "tag", "]", "=", "get_missing_values", "(", "df", ",", "self", ".", "heuristic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._encode_df": [[331, 427], ["logger.info", "pandas.Series", "pandas.concat", "pandas.Series", "df_utils.split_features", "df_utils.split_features", "df_utils.split_features", "df_utils.split_features", "logger.info", "logger.info", "logger.info", "logger.info", "logger.info", "logger.info", "df_utils.fill_df", "logger.info", "encode.ordinal_encode", "logger.info", "encode.one_hot_encode", "logger.info", "encode.date_encode", "encode.date_encode", "logger.info", "df_utils.fill_df", "logger.info", "pandas.concat", "pandas.concat", "pandas.concat", "pandas.concat", "df_utils.set_dtypes_features", "isinstance", "df_utils.fill_df.pop", "df_utils.split_features.pop", "df_utils.fill_df.values", "df_utils.split_features.values", "df_utils.split_features.values", "df_utils.split_features.values", "df_utils.split_features.items", "df_utils.split_features.items"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.split_features", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.split_features", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.split_features", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.split_features", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode.ordinal_encode", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode.one_hot_encode", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode.date_encode", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.encode.date_encode", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.fill_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.df_utils.set_dtypes_features"], ["", "@", "staticmethod", "\n", "def", "_encode_df", "(", "df", ",", "mv", ",", "types", ",", "order", "=", "None", ",", "encode", "=", "None", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f'Encode mode: {encode}'", ")", "\n", "\n", "common_features", "=", "[", "f", "for", "f", "in", "df", ".", "columns", "if", "f", "in", "types", ".", "index", "]", "\n", "types", "=", "types", "[", "common_features", "]", "\n", "\n", "# Assign a defaut type for extra features in type", "\n", "extra_features", "=", "[", "f", "for", "f", "in", "df", ".", "columns", "if", "f", "not", "in", "types", ".", "index", "]", "\n", "extra_types", "=", "pd", ".", "Series", "(", "CONTINUE_R", ",", "index", "=", "extra_features", ")", "\n", "\n", "types", "=", "pd", ".", "concat", "(", "[", "types", ",", "extra_types", "]", ")", "\n", "parent", "=", "pd", ".", "Series", "(", "df", ".", "columns", ",", "index", "=", "df", ".", "columns", ")", "\n", "\n", "# Split the data frame according to the types of the features", "\n", "splitted_df", "=", "split_features", "(", "df", ",", "types", ")", "\n", "\n", "# Split the missing values in the same way", "\n", "splitted_mv", "=", "split_features", "(", "mv", ",", "types", ")", "\n", "\n", "# Split the feature types in the same way", "\n", "splitted_types", "=", "split_features", "(", "types", ",", "types", ")", "\n", "\n", "# Split the parent features", "\n", "splitted_parent", "=", "split_features", "(", "parent", ",", "types", ")", "\n", "\n", "# Choose which tables go in which pipeline", "\n", "to_ordinal_encode_ids", "=", "[", "]", "\n", "to_one_hot_encode_ids", "=", "[", "]", "\n", "to_delete_ids", "=", "[", "NOT_A_FEATURE", "]", "\n", "to_date_encode_exp", "=", "[", "]", "\n", "to_date_encode_tim", "=", "[", "]", "\n", "\n", "if", "not", "isinstance", "(", "encode", ",", "list", ")", ":", "\n", "            ", "encode", "=", "[", "encode", "]", "\n", "\n", "", "if", "encode", "is", "not", "None", "and", "(", "'ordinal'", "in", "encode", "or", "'all'", "in", "encode", ")", ":", "\n", "            ", "to_ordinal_encode_ids", "=", "[", "ORDINAL", ",", "BINARY", "]", "\n", "\n", "", "if", "encode", "is", "not", "None", "and", "(", "'one_hot'", "in", "encode", "or", "'all'", "in", "encode", ")", ":", "\n", "            ", "to_one_hot_encode_ids", "=", "[", "CATEGORICAL", "]", "\n", "\n", "", "if", "encode", "is", "not", "None", "and", "(", "'date'", "in", "encode", "or", "'all'", "in", "encode", ")", ":", "\n", "            ", "to_date_encode_exp", "=", "[", "DATE_EXPLODED", "]", "\n", "to_date_encode_tim", "=", "[", "DATE_TIMESTAMP", "]", "\n", "\n", "", "logger", ".", "info", "(", "f'Keys, ordinal encode: {to_ordinal_encode_ids}'", ")", "\n", "logger", ".", "info", "(", "f'Keys, one hot encode: {to_one_hot_encode_ids}'", ")", "\n", "logger", ".", "info", "(", "f'Keys, date encode exp: {to_date_encode_exp}'", ")", "\n", "logger", ".", "info", "(", "f'Keys, date encode tim: {to_date_encode_tim}'", ")", "\n", "logger", ".", "info", "(", "f'Keys, to delete: {to_delete_ids}'", ")", "\n", "\n", "# Delete unwanted tables", "\n", "for", "k", "in", "to_delete_ids", ":", "\n", "            ", "splitted_df", ".", "pop", "(", "k", ",", "None", ")", "\n", "splitted_mv", ".", "pop", "(", "k", ",", "None", ")", "\n", "\n", "# Fill missing values otherwise the fit raises an error cause of Nans", "\n", "# splitted_mv_bool = {k: mv != NOT_MISSING for k, mv in splitted_mv.items()}", "\n", "# splitted_df = fill_df(splitted_df, splitted_mv_bool, 'z MISSING_VALUE')", "\n", "# Set missing values to blank", "\n", "", "logger", ".", "info", "(", "'Encoding: Fill missing values.'", ")", "\n", "splitted_mv_bool", "=", "{", "k", ":", "mv", "!=", "NOT_MISSING", "for", "k", ",", "mv", "in", "splitted_mv", ".", "items", "(", ")", "}", "\n", "splitted_df", "=", "fill_df", "(", "splitted_df", ",", "splitted_mv_bool", ",", "np", ".", "nan", ")", "\n", "\n", "# Ordinal encode", "\n", "logger", ".", "info", "(", "'Encoding: Ordinal encode.'", ")", "\n", "splitted_df", ",", "splitted_mv", "=", "ordinal_encode", "(", "splitted_df", ",", "splitted_mv", ",", "keys", "=", "to_ordinal_encode_ids", ",", "order", "=", "order", ")", "\n", "\n", "# One hot encode", "\n", "logger", ".", "info", "(", "'Encoding: One hot encode.'", ")", "\n", "splitted_df", ",", "splitted_mv", ",", "splitted_types", ",", "splitted_parent", "=", "one_hot_encode", "(", "splitted_df", ",", "splitted_mv", ",", "splitted_types", ",", "splitted_parent", ",", "keys", "=", "to_one_hot_encode_ids", ")", "\n", "\n", "# Date encode", "\n", "logger", ".", "info", "(", "'Encoding: Date encode.'", ")", "\n", "splitted_df", ",", "splitted_mv", ",", "splitted_types", ",", "splitted_parent", "=", "date_encode", "(", "splitted_df", ",", "splitted_mv", ",", "splitted_types", ",", "splitted_parent", ",", "keys", "=", "to_date_encode_exp", ",", "method", "=", "'explode'", ",", "dayfirst", "=", "True", ")", "\n", "splitted_df", ",", "splitted_mv", ",", "splitted_types", ",", "splitted_parent", "=", "date_encode", "(", "splitted_df", ",", "splitted_mv", ",", "splitted_types", ",", "splitted_parent", ",", "keys", "=", "to_date_encode_tim", ",", "method", "=", "'timestamp'", ",", "dayfirst", "=", "True", ")", "\n", "\n", "logger", ".", "info", "(", "'Encoding: Fill missing values.'", ")", "\n", "splitted_mv_bool", "=", "{", "k", ":", "mv", "!=", "NOT_MISSING", "for", "k", ",", "mv", "in", "splitted_mv", ".", "items", "(", ")", "}", "\n", "splitted_df", "=", "fill_df", "(", "splitted_df", ",", "splitted_mv_bool", ",", "np", ".", "nan", ")", "\n", "\n", "# Merge encoded df", "\n", "logger", ".", "info", "(", "'Encoding: Merge df.'", ")", "\n", "encoded_df", "=", "pd", ".", "concat", "(", "splitted_df", ".", "values", "(", ")", ",", "axis", "=", "1", ")", "\n", "encoded_mv", "=", "pd", ".", "concat", "(", "splitted_mv", ".", "values", "(", ")", ",", "axis", "=", "1", ")", "\n", "encoded_types", "=", "pd", ".", "concat", "(", "splitted_types", ".", "values", "(", ")", ")", "\n", "encoded_parent", "=", "pd", ".", "concat", "(", "splitted_parent", ".", "values", "(", ")", ")", "\n", "\n", "# Set types on encoded df", "\n", "encoded_df", "=", "set_dtypes_features", "(", "encoded_df", ",", "encoded_types", ",", "{", "\n", "CONTINUE_R", ":", "float", ",", "\n", "CONTINUE_I", ":", "float", ",", "\n", "}", ")", "\n", "\n", "return", "encoded_df", ",", "encoded_mv", ",", "encoded_types", ",", "encoded_parent", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._encode": [[428, 452], ["logger.info", "isinstance", "print", "print", "base.Database.ordinal_orders.get", "base.Database._encode_df", "logger.info"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._encode_df"], ["", "def", "_encode", "(", "self", ",", "meta", ")", ":", "\n", "        ", "tag", "=", "meta", "if", "isinstance", "(", "meta", ",", "str", ")", "else", "meta", ".", "tag", "\n", "df", "=", "self", ".", "dataframes", "[", "tag", "]", "\n", "logger", ".", "info", "(", "f'Encoding {tag}.'", ")", "\n", "\n", "if", "tag", "not", "in", "self", ".", "feature_types", ":", "\n", "            ", "print", "(", "f'{tag}: feature types missing. Encoding ignored.'", ")", "\n", "\n", "", "elif", "tag", "not", "in", "self", ".", "missing_values", ":", "\n", "            ", "print", "(", "f'{tag}: missing values df missing. Encoding ignored.'", ")", "\n", "\n", "", "else", ":", "\n", "            ", "types", "=", "self", ".", "feature_types", "[", "tag", "]", "\n", "mv", "=", "self", ".", "missing_values", "[", "tag", "]", "\n", "order", "=", "self", ".", "ordinal_orders", ".", "get", "(", "tag", ",", "None", ")", "\n", "\n", "encoded", "=", "self", ".", "_encode_df", "(", "df", ",", "mv", ",", "types", ",", "order", "=", "order", ",", "encode", "=", "self", ".", "encode", ")", "\n", "\n", "self", ".", "encoded_dataframes", "[", "tag", "]", "=", "encoded", "[", "0", "]", "\n", "self", ".", "encoded_missing_values", "[", "tag", "]", "=", "encoded", "[", "1", "]", "\n", "self", ".", "encoded_feature_types", "[", "tag", "]", "=", "encoded", "[", "2", "]", "\n", "self", ".", "encoded_parent", "[", "tag", "]", "=", "encoded", "[", "3", "]", "\n", "\n", "logger", ".", "info", "(", "f'df {tag} encoded with shape {encoded[0].shape}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._rename": [[453, 487], ["rename.keys", "isinstance", "isinstance", "isinstance", "obj.copy", "obj.copy.drop", "obj.copy", "obj.copy.drop", "obj.copy", "obj.copy.pop", "obj.keys", "set", "set", "set"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.keys"], ["", "", "def", "_rename", "(", "self", ",", "obj", ",", "rename", ")", ":", "\n", "        ", "rename_from", "=", "rename", ".", "keys", "(", ")", "\n", "\n", "if", "isinstance", "(", "obj", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "df", "=", "obj", ".", "copy", "(", ")", "\n", "cols_to_rename", "=", "[", "c", "for", "c", "in", "df", ".", "columns", "if", "c", "in", "set", "(", "rename_from", ")", "]", "\n", "\n", "for", "c", "in", "cols_to_rename", ":", "\n", "                ", "df", "[", "rename", "[", "c", "]", "]", "=", "df", "[", "c", "]", "\n", "\n", "", "df", ".", "drop", "(", "cols_to_rename", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "return", "df", "\n", "\n", "", "if", "isinstance", "(", "obj", ",", "pd", ".", "Series", ")", ":", "\n", "            ", "series", "=", "obj", ".", "copy", "(", ")", "\n", "cols_to_rename", "=", "[", "c", "for", "c", "in", "series", ".", "index", "if", "c", "in", "set", "(", "rename_from", ")", "]", "\n", "\n", "for", "c", "in", "cols_to_rename", ":", "\n", "                ", "series", "[", "rename", "[", "c", "]", "]", "=", "series", "[", "c", "]", "\n", "\n", "", "series", ".", "drop", "(", "cols_to_rename", ",", "inplace", "=", "True", ")", "\n", "\n", "return", "series", "\n", "\n", "", "if", "isinstance", "(", "obj", ",", "dict", ")", ":", "\n", "            ", "d", "=", "obj", ".", "copy", "(", ")", "\n", "\n", "cols_to_rename", "=", "[", "c", "for", "c", "in", "obj", ".", "keys", "(", ")", "if", "c", "in", "set", "(", "rename_from", ")", "]", "\n", "\n", "for", "c", "in", "cols_to_rename", ":", "\n", "                ", "d", "[", "rename", "[", "c", "]", "]", "=", "obj", "[", "c", "]", "\n", "d", ".", "pop", "(", "c", ")", "\n", "\n", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database.rename_encode": [[488, 506], ["base.Database._rename", "base.Database._rename", "base.Database._rename", "base.Database._encode_df", "base.Database._rename"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._encode_df", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.base.Database._rename"], ["", "", "def", "rename_encode", "(", "self", ",", "tag", ",", "rename", ",", "encode", "=", "'all'", ")", ":", "\n", "        ", "df", "=", "self", ".", "dataframes", "[", "tag", "]", "\n", "\n", "mv", "=", "self", ".", "missing_values", "[", "tag", "]", "\n", "types", "=", "self", ".", "feature_types", "[", "tag", "]", "\n", "order", "=", "None", "\n", "if", "tag", "in", "self", ".", "ordinal_orders", ":", "\n", "            ", "order", "=", "self", ".", "ordinal_orders", "[", "tag", "]", "\n", "\n", "", "df", "=", "self", ".", "_rename", "(", "df", ",", "rename", ")", "\n", "mv", "=", "self", ".", "_rename", "(", "mv", ",", "rename", ")", "\n", "types", "=", "self", ".", "_rename", "(", "types", ",", "rename", ")", "\n", "if", "order", "is", "not", "None", ":", "\n", "            ", "order", "=", "self", ".", "_rename", "(", "order", ",", "rename", ")", "\n", "\n", "", "df", ",", "_", ",", "_", ",", "parent", "=", "self", ".", "_encode_df", "(", "df", ",", "mv", ",", "types", ",", "order", "=", "order", ",", "encode", "=", "encode", ")", "\n", "\n", "return", "df", ",", "parent", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_categorical": [[24, 26], ["None"], "function", ["None"], ["def", "is_categorical", "(", "x", ")", ":", "\n", "    ", "return", "x", "in", "[", "CATEGORICAL", ",", "BINARY", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_ordinal": [[27, 29], ["None"], "function", ["None"], ["", "def", "is_ordinal", "(", "x", ")", ":", "\n", "    ", "return", "x", "in", "[", "ORDINAL", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_continue": [[30, 32], ["None"], "function", ["None"], ["", "def", "is_continue", "(", "x", ")", ":", "\n", "    ", "return", "x", "in", "[", "CONTINUE_I", ",", "CONTINUE_R", ",", "DATE_TIMESTAMP", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_continuous": [[33, 35], ["constants.is_continue"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.constants.is_continue"], ["", "def", "is_continuous", "(", "x", ")", ":", "\n", "    ", "return", "is_continue", "(", "x", ")", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS_utils.to_sql": [[20, 31], ["sqlalchemy.create_engine", "NHIS.frame_paths.items", "print", "pandas.read_csv", "print", "print", "pd.read_csv.to_sql", "c.lower"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS_utils.to_sql"], ["def", "to_sql", "(", ")", ":", "\n", "    ", "\"\"\"Import csv files to posgresql database.\"\"\"", "\n", "engine", "=", "create_engine", "(", "'postgresql://alexandreperez@localhost:5432/nhis'", ")", "\n", "\n", "for", "name", ",", "path", "in", "NHIS", ".", "frame_paths", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "f'\\n{name}\\n\\tReading csv'", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "path", ")", "\n", "print", "(", "f'\\tLowering columns'", ")", "\n", "df", ".", "columns", "=", "[", "c", ".", "lower", "(", ")", "for", "c", "in", "df", ".", "columns", "]", "\n", "print", "(", "f'\\tConverting to sql'", ")", "\n", "df", ".", "to_sql", "(", "name", ",", "engine", ",", "if_exists", "=", "'replace'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS_utils.create_X_income": [[33, 71], ["print", "print", "household.merge().merge().merge().dropna().compute", "print", "print", "household.merge().merge().merge().dropna().compute.rename", "print", "household.merge().merge().merge().dropna().compute.to_csv", "NHIS_utils._dump_types_X_income_v2", "f.replace", "household.merge().merge().merge().dropna", "household.merge().merge().merge", "household.merge().merge().merge().dropna().compute.columns.str.endswith", "household.merge().merge", "household.merge"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.prediction.PlotHelper.PlotHelper.rename", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS_utils._dump_types_X_income_v2"], ["", "", "def", "create_X_income", "(", "tables", ")", ":", "\n", "    ", "\"\"\"Create the X_income table.\"\"\"", "\n", "print", "(", "'\\nX_income'", ")", "\n", "household", "=", "tables", "[", "'household'", "]", "\n", "adult", "=", "tables", "[", "'adult'", "]", "\n", "family", "=", "tables", "[", "'family'", "]", "\n", "person", "=", "tables", "[", "'person'", "]", "\n", "\n", "print", "(", "'\\tMerging...'", ")", "\n", "df", "=", "household", ".", "merge", "(", "\n", "family", ",", "how", "=", "'inner'", ",", "on", "=", "[", "'SRVY_YR'", ",", "'HHX'", "]", ",", "\n", "suffixes", "=", "(", "''", ",", "'%to_drop'", ")", "\n", ")", ".", "merge", "(", "\n", "person", ",", "how", "=", "'inner'", ",", "on", "=", "[", "'SRVY_YR'", ",", "'HHX'", ",", "'FMX'", "]", ",", "\n", "suffixes", "=", "(", "''", ",", "'%to_drop'", ")", "\n", ")", ".", "merge", "(", "\n", "adult", ",", "how", "=", "'left'", ",", "on", "=", "[", "'SRVY_YR'", ",", "'HHX'", ",", "'FMX'", ",", "'FPX'", "]", ",", "\n", "suffixes", "=", "(", "''", ",", "'%to_drop'", ")", "\n", ")", ".", "dropna", "(", "subset", "=", "[", "'ERNYR_P'", "]", ")", ".", "compute", "(", ")", "\n", "\n", "# Remove duplicate columns of the merges", "\n", "print", "(", "'\\tRemoving duplicates...'", ")", "\n", "df", "=", "df", ".", "loc", "[", ":", ",", "~", "df", ".", "columns", ".", "str", ".", "endswith", "(", "'%to_drop'", ")", "]", "\n", "\n", "# Rename columns having forbidden character _ (reserved for OH encoding)", "\n", "rename", "=", "{", "f", ":", "f", ".", "replace", "(", "'_'", ",", "'-'", ")", "for", "f", "in", "df", ".", "columns", "}", "\n", "print", "(", "rename", ")", "\n", "df", ".", "rename", "(", "rename", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "\n", "# Save index in columns", "\n", "df", "[", "'IDX'", "]", "=", "df", ".", "index", "\n", "\n", "# Save new dataframe", "\n", "print", "(", "'\\tSaving...'", ")", "\n", "df", ".", "to_csv", "(", "f'{NHIS.data_folder}custom/X_income.csv'", ",", "index", "=", "None", ")", "\n", "\n", "# Compute the feature types and dump them", "\n", "_dump_types_X_income_v2", "(", "df", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS_utils._dump_types_X_income_v1": [[73, 79], ["print", "pandas.Series", "features_type._dump_feature_types", "df.dtypes.items", "str"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._dump_feature_types"], ["", "def", "_dump_types_X_income_v1", "(", "df", ")", ":", "\n", "    ", "\"\"\"Create types using translation dict and dtypes.\"\"\"", "\n", "print", "(", "'\\tDumping feature types...'", ")", "\n", "types", "=", "{", "n", ":", "translation", "[", "str", "(", "t", ")", "]", "for", "n", ",", "t", "in", "df", ".", "dtypes", ".", "items", "(", ")", "}", "\n", "types", "=", "pd", ".", "Series", "(", "types", ",", "index", "=", "df", ".", "columns", ")", "\n", "_dump_feature_types", "(", "types", ",", "NHIS", ",", "'X_income'", ",", "anonymize", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS_utils._dump_types_X_income_v2": [[81, 99], ["print", "pandas.Series", "features_type._dump_feature_types", "print", "open", "line.rstrip.rstrip", "line.rstrip.replace"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._dump_feature_types"], ["", "def", "_dump_types_X_income_v2", "(", "df", ")", ":", "\n", "    ", "\"\"\"Create types using files.\"\"\"", "\n", "print", "(", "'\\tDumping feature types...'", ")", "\n", "types", "=", "pd", ".", "Series", "(", "CATEGORICAL", ",", "index", "=", "df", ".", "columns", ")", "\n", "\n", "data_folder", "=", "NHIS", ".", "data_folder", "\n", "tables", "=", "[", "'household'", ",", "'family'", ",", "'person'", ",", "'adult'", "]", "\n", "for", "table", "in", "tables", ":", "\n", "        ", "print", "(", "f'\\t\\t{table}'", ")", "\n", "path", "=", "f'{data_folder}{table}/continue_i.txt'", "\n", "with", "open", "(", "path", ",", "'r'", ")", "as", "file", ":", "\n", "            ", "for", "line", "in", "file", ":", "\n", "                ", "line", "=", "line", ".", "rstrip", "(", ")", "\n", "if", "line", "==", "''", ":", "\n", "                    ", "continue", "\n", "", "types", "[", "line", ".", "replace", "(", "'_'", ",", "'-'", ")", "]", "=", "CONTINUE_I", "\n", "\n", "", "", "", "_dump_feature_types", "(", "types", ",", "NHIS", ",", "'X_income'", ",", "anonymize", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS_utils.create_table": [[101, 107], ["dask.dataframe.read_csv", "NHIS_utils.create_X_income", "NHIS.available_paths.items"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS_utils.create_X_income"], ["", "def", "create_table", "(", "table_name", ")", ":", "\n", "    ", "\"\"\"Create the asked table.\"\"\"", "\n", "tables", "=", "{", "name", ":", "dd", ".", "read_csv", "(", "p", ")", "for", "name", ",", "p", "in", "NHIS", ".", "available_paths", ".", "items", "(", ")", "}", "\n", "\n", "if", "table_name", "==", "'X_income'", ":", "\n", "        ", "create_X_income", "(", "tables", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.TB.TB.__init__": [[13, 29], ["base.Database.__init__"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS.__init__"], ["    ", "\"\"\"Return TaskMeta for death prediction.\"\"\"", "\n", "death_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'D\u00e9c\u00e8s'", "]", ",", "\n", "output_features", "=", "[", "'D\u00e9c\u00e8s'", "]", ",", "\n", ")", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "death_pvals_keep_transform", "=", "None", "\n", "death_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n", "assert", "'T'", "in", "kwargs", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.TB.TB.heuristic": [[31, 81], ["pandas.Series", "series.isna"], "methods", ["None"], ["RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "death_pvals_dir", "=", "'pvals/TB/death_pvals/'", "\n", "death_idx_path", "=", "f'{death_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "death_pvals_path", "=", "f'{death_pvals_dir}RS{RS}-T{T}-pvals_filtered.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "death_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "death_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "death_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "death_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "death_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "death_top_pvals", "\n", ")", "\n", "\n", "death_drop_idx", "=", "pd", ".", "read_csv", "(", "death_idx_path", ",", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "death_idx_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "death_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n", "\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'death_pvals'", ",", "\n", "db", "=", "'TB'", ",", "\n", "df_name", "=", "'20000'", ",", "\n", "classif", "=", "True", ",", "\n", "idx_column", "=", "'ID_PATIENT'", ",", "\n", "idx_selection", "=", "death_idx_transform", ",", "\n", "predict", "=", "death_predict_transform", ",", "\n", "transform", "=", "None", ",", "\n", "select", "=", "death_pvals_keep_transform", ",", "\n", "encode_select", "=", "'all'", ",", "\n", "encode_transform", "=", "None", ",", "\n", ")", "\n", "\n", "\n", "# Task 2: platelet prediction (https://arxiv.org/abs/1909.06631)", "\n", "# --------------------------------------------------------------", "\n", "# This is outside the callable because used in the pvals version of the task", "\n", "", "platelet_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'Plaquettes'", "]", ",", "\n", "output_features", "=", "[", "'Plaquettes'", "]", ",", "\n", ")", "\n", "\n", "\n", "def", "platelet_task", "(", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.MIMIC_utils.check_data_types": [[20, 39], ["pandas.read_csv", "dict", "pd.read_csv.iterrows", "dict.get", "print"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.tasks.__init__._TaskAccessor.get"], ["def", "check_data_types", "(", "filepath", ")", ":", "\n", "    ", "\"\"\"Check data types.\"\"\"", "\n", "df", "=", "pd", ".", "read_csv", "(", "filepath", ")", "\n", "\n", "data_types", "=", "dict", "(", ")", "\n", "\n", "for", "_", ",", "row", "in", "df", ".", "iterrows", "(", ")", ":", "\n", "        ", "table_name", ",", "column_name", ",", "data_type", "=", "row", "\n", "\n", "existing_data_type", "=", "data_types", ".", "get", "(", "column_name", ",", "None", ")", "\n", "if", "existing_data_type", "is", "None", ":", "\n", "            ", "data_types", "[", "column_name", "]", "=", "data_type", "\n", "continue", "\n", "\n", "", "elif", "existing_data_type", "==", "data_type", ":", "\n", "            ", "continue", "\n", "\n", "", "print", "(", "\n", "f'\\nFound different data types for same column name.\\n'", "\n", "f'Column: {column_name}\\n'", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.MIMIC_utils.MIMIC_feature_types": [[46, 59], ["pandas.read_csv", "dict", "pd.read_csv.iterrows", "pandas.Series", "features_type._dump_feature_types", "print"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._dump_feature_types"], ["", "", "def", "MIMIC_feature_types", "(", "filepath", ")", ":", "\n", "    ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ")", "\n", "\n", "types", "=", "dict", "(", ")", "\n", "\n", "for", "_", ",", "row", "in", "df", ".", "iterrows", "(", ")", ":", "\n", "        ", "table_name", ",", "column_name", ",", "data_type", "=", "row", "\n", "\n", "types", "[", "f'{table_name}/{column_name}'", "]", "=", "translation", "[", "data_type", "]", "\n", "\n", "", "types", "=", "pd", ".", "Series", "(", "types", ")", "\n", "_dump_feature_types", "(", "types", ",", "dbs", "[", "'MIMIC'", "]", ",", "'mimiciii'", ",", "anonymize", "=", "False", ")", "\n", "print", "(", "types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.MIMIC_utils.set_custom_types": [[61, 69], ["pandas.read_csv", "pandas.Series", "features_type._dump_feature_types", "print"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._dump_feature_types"], ["", "def", "set_custom_types", "(", ")", ":", "\n", "    ", "custom_dir", "=", "'/Users/alexandreperez/OneDrive/Documents/Stage/MILA/Task3_NHIS/NHIS_analyse/MIMICIII/physionet.org/files/mimiciii/1.4/custom/'", "\n", "\n", "df", "=", "pd", ".", "read_csv", "(", "custom_dir", "+", "'X_labevents.csv'", ",", "index_col", "=", "'subject_id'", ")", "\n", "\n", "types", "=", "pd", ".", "Series", "(", "CONTINUE_R", ",", "index", "=", "df", ".", "columns", ")", "\n", "_dump_feature_types", "(", "types", ",", "dbs", "[", "'MIMIC'", "]", ",", "'X_labevents'", ",", "anonymize", "=", "False", ")", "\n", "print", "(", "types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.UKBB_utils.UKBB_feature_types_converter": [[12, 27], ["next", "os.path.exists", "ValueError", "os.walk", "os.path.splitext", "os.path.join", "UKBB_utils._html_to_types", "features_type._dump_feature_types", "print", "UKBB.UKBB"], "function", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.UKBB_utils._html_to_types", "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.None.features_type._dump_feature_types"], ["def", "UKBB_feature_types_converter", "(", "html_folder", ")", ":", "\n", "# Get all files from the html folder", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "html_folder", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'Folder not found. {html_folder}'", ")", "\n", "", "(", "_", ",", "_", ",", "filenames", ")", "=", "next", "(", "os", ".", "walk", "(", "html_folder", ")", ")", "\n", "\n", "for", "filename", "in", "filenames", ":", "\n", "        ", "basename", ",", "extension", "=", "os", ".", "path", ".", "splitext", "(", "filename", ")", "\n", "\n", "if", "extension", "==", "'.html'", ":", "\n", "            ", "html_file", "=", "os", ".", "path", ".", "join", "(", "html_folder", ",", "filename", ")", "\n", "\n", "types", "=", "_html_to_types", "(", "html_file", ")", "\n", "_dump_feature_types", "(", "types", ",", "UKBB", "(", ")", ",", "basename", ",", "anonymize", "=", "False", ")", "\n", "print", "(", "types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.UKBB_utils._html_to_types": [[29, 46], ["table[].ffill", "table.set_index", "pandas.read_html"], "function", ["None"], ["", "", "", "def", "_html_to_types", "(", "html_file", ")", ":", "\n", "    ", "table", "=", "pd", ".", "read_html", "(", "html_file", ",", "match", "=", "'UDI'", ",", "header", "=", "0", ")", "[", "0", "]", "\n", "table", "[", "'Type'", "]", "=", "table", "[", "'Type'", "]", ".", "ffill", "(", ")", "\n", "\n", "table", ".", "set_index", "(", "'UDI'", ",", "inplace", "=", "True", ",", "verify_integrity", "=", "True", ")", "\n", "types", "=", "table", "[", "'Type'", "]", "\n", "types", "[", "types", "==", "'Categorical (multiple)'", "]", "=", "CATEGORICAL", "\n", "types", "[", "types", "==", "'Categorical (single)'", "]", "=", "CATEGORICAL", "\n", "types", "[", "types", "==", "'Integer'", "]", "=", "CONTINUE_I", "\n", "types", "[", "types", "==", "'Continuous'", "]", "=", "CONTINUE_R", "\n", "types", "[", "types", "==", "'Time'", "]", "=", "DATE_EXPLODED", "\n", "types", "[", "types", "==", "'Date'", "]", "=", "DATE_EXPLODED", "\n", "types", "[", "types", "==", "'Sequence'", "]", "=", "NOT_A_FEATURE", "\n", "types", "[", "types", "==", "'Curve'", "]", "=", "NOT_A_FEATURE", "\n", "types", "[", "types", "==", "'Text'", "]", "=", "NOT_A_FEATURE", "\n", "\n", "return", "types", "\n", "", ""]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS.__init__": [[12, 33], ["base.Database.__init__"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS.__init__"], ["    ", "\"\"\"Return TaskMeta for income prediction.\"\"\"", "\n", "income_predict_transform", "=", "Transform", "(", "\n", "input_features", "=", "[", "'ERNYR-P'", "]", ",", "\n", "output_features", "=", "[", "'ERNYR-P'", "]", ",", "\n", ")", "\n", "\n", "# Drop features linked to feature to predict", "\n", "income_drop_features", "=", "{", "\n", "'INCGRP4'", ",", "\n", "'INCGRP5'", ",", "\n", "}", "\n", "\n", "assert", "'n_top_pvals'", "in", "kwargs", "\n", "n_top_pvals", "=", "kwargs", "[", "'n_top_pvals'", "]", "\n", "\n", "if", "n_top_pvals", "is", "None", ":", "\n", "        ", "income_pvals_keep_transform", "=", "None", "\n", "income_idx_transform", "=", "None", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "assert", "'RS'", "in", "kwargs", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS.heuristic": [[35, 62], ["pandas.Series", "series.max", "series.isna"], "methods", ["None"], ["\n", "RS", "=", "kwargs", "[", "'RS'", "]", "\n", "T", "=", "kwargs", "[", "'T'", "]", "\n", "income_pvals_dir", "=", "'pvals/NHIS/income_pvals/'", "\n", "income_idx_path", "=", "f'{income_pvals_dir}RS{RS}-T{T}-used_idx.csv'", "\n", "income_pvals_path", "=", "f'{income_pvals_dir}RS{RS}-T{T}-pvals.csv'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "income_idx_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "income_pvals_path", ")", "\n", "\n", "pvals", "=", "pd", ".", "read_csv", "(", "income_pvals_path", ",", "header", "=", "None", ",", "\n", "index_col", "=", "0", ",", "squeeze", "=", "True", ")", "\n", "\n", "# Match exact feature or start with and followed by '_' (categorical)", "\n", "for", "f", "in", "income_drop_features", ":", "# Drop asked features from pvals", "\n", "            ", "regex", "=", "f'(^{f}$|^{f}_)'", "\n", "pvals", "=", "pvals", "[", "~", "pvals", ".", "index", ".", "str", ".", "match", "(", "regex", ")", "]", "\n", "", "pvals", "=", "pvals", ".", "sort_values", "(", ")", "[", ":", "n_top_pvals", "]", "\n", "income_top_pvals", "=", "list", "(", "pvals", ".", "index", ".", "astype", "(", "str", ")", ")", "\n", "\n", "income_pvals_keep_transform", "=", "Transform", "(", "\n", "output_features", "=", "income_top_pvals", "\n", ")", "\n", "\n", "income_drop_idx", "=", "pd", ".", "read_csv", "(", "income_idx_path", ",", "index_col", "=", "0", ",", "\n", "squeeze", "=", "True", ")", "\n", "\n", "income_idx_transform", "=", "Transform", "(", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS._encode": [[63, 65], ["super()._encode"], "methods", ["home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS._encode"], ["input_features", "=", "[", "]", ",", "\n", "transform", "=", "lambda", "df", ":", "df", ".", "drop", "(", "income_drop_idx", ".", "index", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.database.NHIS.NHIS._to_drop": [[66, 68], ["None"], "methods", ["None"], ["\n", "", "return", "TaskMeta", "(", "\n", "name", "=", "'income_pvals'", ",", "\n"]], "home.repos.pwc.inspect_result.aperezlebel_benchmark_mv_approaches.custom.const._subfolder": [[10, 14], ["os.path.join", "os.makedirs"], "function", ["None"], ["def", "_subfolder", "(", "graphics_folder", ",", "name", ")", ":", "\n", "    ", "subfolder", "=", "os", ".", "path", ".", "join", "(", "graphics_folder", ",", "name", ")", "\n", "os", ".", "makedirs", "(", "subfolder", ",", "exist_ok", "=", "True", ")", "\n", "return", "subfolder", "\n", "\n"]]}