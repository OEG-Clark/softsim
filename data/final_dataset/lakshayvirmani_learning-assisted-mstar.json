{"home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mstar_maps_unseen_same_type.NumpyEncoder.default": [[16, 39], ["isinstance", "json.JSONEncoder.default", "int", "isinstance", "float", "isinstance", "isinstance", "obj.tolist", "isinstance", "bool", "isinstance"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_solver.NumpyEncoder.default"], ["def", "default", "(", "self", ",", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "(", "np", ".", "int_", ",", "np", ".", "intc", ",", "np", ".", "intp", ",", "np", ".", "int8", ",", "\n", "np", ".", "int16", ",", "np", ".", "int32", ",", "np", ".", "int64", ",", "np", ".", "uint8", ",", "\n", "np", ".", "uint16", ",", "np", ".", "uint32", ",", "np", ".", "uint64", ")", ")", ":", "\n", "\n", "            ", "return", "int", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "float_", ",", "np", ".", "float16", ",", "np", ".", "float32", ",", "np", ".", "float64", ")", ")", ":", "\n", "            ", "return", "float", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "complex_", ",", "np", ".", "complex64", ",", "np", ".", "complex128", ")", ")", ":", "\n", "            ", "return", "{", "'real'", ":", "obj", ".", "real", ",", "'imag'", ":", "obj", ".", "imag", "}", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "ndarray", ",", ")", ")", ":", "\n", "            ", "return", "obj", ".", "tolist", "(", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "bool_", ")", ")", ":", "\n", "            ", "return", "bool", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "void", ")", ")", ":", "\n", "            ", "return", "None", "\n", "\n", "", "return", "json", ".", "JSONEncoder", ".", "default", "(", "self", ",", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mstar_maps_unseen_same_type.generate_mapf_instances": [[40, 94], ["sys.path.append", "range", "print", "numpy.random.uniform", "print", "available.copy", "dict", "numpy.array", "zip", "zip", "len", "random.shuffle", "init_pos.append", "goals.append", "all_costs_to_go.append", "open", "json.dump", "str", "numpy.where", "numpy.where", "numpy.array", "cpp_mstar.find_all_costs_to_go", "str"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy"], ["", "", "def", "generate_mapf_instances", "(", "output_dir", ",", "od_mstar3_dir", ")", ":", "\n", "  ", "sys", ".", "path", ".", "append", "(", "od_mstar3_dir", ")", "\n", "import", "cpp_mstar", "\n", "\n", "for", "world_num", "in", "range", "(", "NUM_WORLDS", ")", ":", "\n", "    ", "print", "(", "'Working on World: '", ",", "world_num", ")", "\n", "world", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "(", "OUT_DIM", ",", "OUT_DIM", ")", ")", "\n", "world", "[", "world", "<=", "OBS_DEN", "]", "=", "-", "1", "\n", "world", "[", "world", ">", "OBS_DEN", "]", "=", "0", "\n", "world", "[", "world", "==", "-", "1", "]", "=", "1", "\n", "obs", "=", "[", "(", "x", ",", "y", ")", "for", "x", ",", "y", "in", "zip", "(", "*", "np", ".", "where", "(", "world", "==", "1", ")", ")", "]", "\n", "available", "=", "[", "(", "x", ",", "y", ")", "for", "x", ",", "y", "in", "zip", "(", "*", "np", ".", "where", "(", "world", "==", "0", ")", ")", "]", "\n", "\n", "num_agents", "=", "2", "\n", "while", "num_agents", "<=", "MAX_AGENTS", ":", "\n", "      ", "print", "(", "'Working on no. agents: '", ",", "num_agents", ")", "\n", "free", "=", "available", ".", "copy", "(", ")", "\n", "\n", "init_pos", "=", "[", "]", "\n", "goals", "=", "[", "]", "\n", "all_costs_to_go", "=", "[", "]", "\n", "\n", "while", "len", "(", "init_pos", ")", "<", "num_agents", ":", "\n", "        ", "random", ".", "shuffle", "(", "free", ")", "\n", "start", "=", "free", "[", "0", "]", "\n", "goal", "=", "free", "[", "1", "]", "\n", "\n", "try", ":", "\n", "          ", "cost_to_go", "=", "np", ".", "array", "(", "cpp_mstar", ".", "find_all_costs_to_go", "(", "world", ",", "[", "goal", "]", ")", ")", "[", "0", "]", "\n", "if", "cost_to_go", "[", "start", "]", ">", "MAX_COST_POSSIBLE", ":", "\n", "            ", "raise", "Exception", "\n", "", "", "except", ":", "\n", "          ", "continue", "\n", "\n", "", "init_pos", ".", "append", "(", "start", ")", "\n", "goals", ".", "append", "(", "goal", ")", "\n", "all_costs_to_go", ".", "append", "(", "cost_to_go", ")", "\n", "\n", "free", "=", "free", "[", "2", ":", "]", "\n", "\n", "", "output", "=", "dict", "(", ")", "\n", "output", "[", "'world'", "]", "=", "world", "\n", "output", "[", "'obs'", "]", "=", "obs", "\n", "output", "[", "'init_pos'", "]", "=", "init_pos", "\n", "output", "[", "'goals'", "]", "=", "goals", "\n", "output", "[", "'map_dim'", "]", "=", "(", "OUT_DIM", ",", "OUT_DIM", ")", "\n", "output", "[", "'num_agents'", "]", "=", "num_agents", "\n", "output", "[", "'all_costs_to_go'", "]", "=", "np", ".", "array", "(", "all_costs_to_go", ")", "\n", "\n", "out_file", "=", "output_dir", "+", "str", "(", "world_num", ")", "+", "'_'", "+", "str", "(", "num_agents", ")", "+", "'.json'", "\n", "with", "open", "(", "out_file", ",", "'w'", ")", "as", "fout", ":", "\n", "          ", "json", ".", "dump", "(", "output", ",", "fout", ",", "cls", "=", "NumpyEncoder", ")", "\n", "\n", "", "num_agents", "+=", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mapf_benchmark_room_maze.NumpyEncoder.default": [[90, 94], ["isinstance", "json.JSONEncoder.default", "obj.tolist"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_solver.NumpyEncoder.default"], ["  ", "def", "default", "(", "self", ",", "obj", ")", ":", "\n", "    ", "if", "isinstance", "(", "obj", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "return", "obj", ".", "tolist", "(", ")", "\n", "", "return", "json", ".", "JSONEncoder", ".", "default", "(", "self", ",", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mapf_benchmark_room_maze.create_map_to_scenario_dict": [[9, 22], ["os.listdir", "[].split", "os.listdir", "os.listdir", "input_map.split"], "function", ["None"], ["def", "create_map_to_scenario_dict", "(", ")", ":", "\n", "  ", "input_maps", "=", "[", "INPUT_MAPS_DIR", "+", "x", "for", "x", "in", "os", ".", "listdir", "(", "INPUT_MAPS_DIR", ")", "if", "'.map'", "in", "x", "]", "\n", "map_to_scen", "=", "{", "}", "\n", "for", "input_map", "in", "input_maps", ":", "\n", "    ", "map_name", "=", "input_map", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "even_dir", "=", "INPUT_MAPS_DIR", "+", "map_name", "+", "'-scen-even/'", "\n", "even_scen", "=", "[", "even_dir", "+", "x", "for", "x", "in", "os", ".", "listdir", "(", "even_dir", ")", "]", "\n", "rand_dir", "=", "INPUT_MAPS_DIR", "+", "map_name", "+", "'-scen-random/'", "\n", "rand_scen", "=", "[", "rand_dir", "+", "x", "for", "x", "in", "os", ".", "listdir", "(", "rand_dir", ")", "]", "\n", "map_to_scen", "[", "input_map", "]", "=", "{", "}", "\n", "map_to_scen", "[", "input_map", "]", "[", "'even'", "]", "=", "even_scen", "\n", "map_to_scen", "[", "input_map", "]", "[", "'random'", "]", "=", "rand_scen", "\n", "", "return", "map_to_scen", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mapf_benchmark_room_maze.load_map": [[23, 54], ["numpy.zeros", "open", "f.readlines", "line.split", "int", "line.split", "int", "numpy.zeros", "line.split", "str"], "function", ["None"], ["", "def", "load_map", "(", "map_file", ")", ":", "\n", "  ", "\"\"\"\n  load map from given file\n  \"\"\"", "\n", "grids", "=", "np", ".", "zeros", "(", "(", "2", ",", "2", ")", ")", "\n", "with", "open", "(", "map_file", ",", "'r'", ")", "as", "f", ":", "\n", "    ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "lidx", "=", "0", "\n", "nx", "=", "0", "\n", "ny", "=", "0", "\n", "for", "line", "in", "lines", ":", "\n", "      ", "if", "lidx", "==", "1", ":", "\n", "        ", "a", "=", "line", ".", "split", "(", "\" \"", ")", "\n", "nx", "=", "int", "(", "a", "[", "1", "]", ")", "\n", "", "if", "lidx", "==", "2", ":", "\n", "        ", "a", "=", "line", ".", "split", "(", "\" \"", ")", "\n", "ny", "=", "int", "(", "a", "[", "1", "]", ")", "\n", "", "if", "lidx", "==", "4", ":", "\n", "        ", "grids", "=", "np", ".", "zeros", "(", "(", "nx", ",", "ny", ")", ")", "\n", "", "if", "lidx", ">=", "4", ":", "# map data begin", "\n", "        ", "x", "=", "lidx", "-", "4", "\n", "y", "=", "0", "\n", "a", "=", "line", ".", "split", "(", "\"\\n\"", ")", "\n", "for", "ia", "in", "str", "(", "a", "[", "0", "]", ")", ":", "\n", "          ", "if", "ia", "==", "\".\"", "or", "ia", "==", "\"G\"", ":", "\n", "            ", "grids", "[", "x", ",", "y", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "grids", "[", "x", ",", "y", "]", "=", "1", "\n", "", "y", "=", "y", "+", "1", "\n", "", "", "lidx", "=", "lidx", "+", "1", "\n", "", "", "return", "grids", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mapf_benchmark_room_maze.load_scenario": [[55, 88], ["mapf_benchmark_room_maze.load_map", "dict", "open", "f.readlines", "dict", "list", "list", "list", "list", "list", "line.split", "len", "list.append", "list.append", "list.append", "list.append", "list.append", "int", "int", "int", "int"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mapf_benchmark_room_maze.load_map"], ["", "def", "load_scenario", "(", "map_file", ",", "scen_file", ",", "cvecs", "=", "[", "]", ",", "cgrids", "=", "[", "]", ")", ":", "\n", "  ", "\"\"\"\n  load map and scen from given files and return a test_case dict.\n  \"\"\"", "\n", "grids", "=", "load_map", "(", "map_file", ")", "\n", "with", "open", "(", "scen_file", ",", "'r'", ")", "as", "f", ":", "\n", "    ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "test_case_dict", "=", "dict", "(", ")", "\n", "sx", "=", "list", "(", ")", "\n", "sy", "=", "list", "(", ")", "\n", "gx", "=", "list", "(", ")", "\n", "gy", "=", "list", "(", ")", "\n", "d_list", "=", "list", "(", ")", "\n", "for", "line", "in", "lines", ":", "\n", "      ", "a", "=", "line", ".", "split", "(", "\"\\t\"", ")", "\n", "if", "len", "(", "a", ")", "!=", "9", ":", "# an invalid line, skip it", "\n", "        ", "continue", "\n", "", "else", ":", "# same as last case", "\n", "        ", "sx", ".", "append", "(", "int", "(", "a", "[", "4", "]", ")", ")", "\n", "sy", ".", "append", "(", "int", "(", "a", "[", "5", "]", ")", ")", "\n", "gx", ".", "append", "(", "int", "(", "a", "[", "6", "]", ")", ")", "\n", "gy", ".", "append", "(", "int", "(", "a", "[", "7", "]", ")", ")", "\n", "d_list", ".", "append", "(", "1", ")", "# assume homo case", "\n", "", "", "", "test_case_dict", "=", "dict", "(", ")", "\n", "test_case_dict", "[", "\"sx\"", "]", "=", "sx", "\n", "test_case_dict", "[", "\"sy\"", "]", "=", "sy", "\n", "test_case_dict", "[", "\"gx\"", "]", "=", "gx", "\n", "test_case_dict", "[", "\"gy\"", "]", "=", "gy", "\n", "test_case_dict", "[", "\"d_list\"", "]", "=", "d_list", "\n", "test_case_dict", "[", "\"grids\"", "]", "=", "grids", "\n", "test_case_dict", "[", "\"cost_grids\"", "]", "=", "cgrids", "\n", "test_case_dict", "[", "\"cost_vecs\"", "]", "=", "cvecs", "\n", "return", "test_case_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mapf_benchmark_room_maze.generate_mapf_instances": [[95, 139], ["sys.path.append", "enumerate", "mapf_benchmark_room_maze.load_scenario", "range", "range", "numpy.array", "range", "[].split", "range", "len", "init_pos.append", "goals.append", "cpp_mstar.find_all_costs_to_go", "len", "open", "json.dump", "obs.append", "str", "map.split", "str"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.mapf_benchmark_room_maze.load_scenario"], ["", "", "def", "generate_mapf_instances", "(", "map_to_scen", ",", "output_dir", ",", "od_mstar3_dir", ")", ":", "\n", "  ", "sys", ".", "path", ".", "append", "(", "od_mstar3_dir", ")", "\n", "import", "cpp_mstar", "\n", "\n", "for", "map", "in", "map_to_scen", ":", "\n", "    ", "scens", "=", "map_to_scen", "[", "map", "]", "\n", "for", "scen_type", "in", "scens", ":", "\n", "      ", "for", "scen_idx", ",", "scen", "in", "enumerate", "(", "scens", "[", "scen_type", "]", ")", ":", "\n", "        ", "test_case", "=", "load_scenario", "(", "map", ",", "scen", ")", "\n", "map_name", "=", "map", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "world", "=", "test_case", "[", "'grids'", "]", "\n", "\n", "obs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "32", ")", ":", "\n", "          ", "for", "j", "in", "range", "(", "32", ")", ":", "\n", "            ", "if", "world", "[", "i", "]", "[", "j", "]", "==", "1", ":", "\n", "              ", "obs", ".", "append", "(", "(", "i", ",", "j", ")", ")", "\n", "\n", "", "", "", "init_pos", "=", "[", "]", "\n", "goals", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "test_case", "[", "'sx'", "]", ")", ")", ":", "\n", "          ", "start", "=", "(", "test_case", "[", "'sx'", "]", "[", "i", "]", ",", "test_case", "[", "'sy'", "]", "[", "i", "]", ")", "\n", "goal", "=", "(", "test_case", "[", "'gx'", "]", "[", "i", "]", ",", "test_case", "[", "'gy'", "]", "[", "i", "]", ")", "\n", "if", "start", "in", "obs", "or", "goal", "in", "obs", ":", "\n", "            ", "continue", "\n", "", "init_pos", ".", "append", "(", "start", ")", "\n", "goals", ".", "append", "(", "goal", ")", "\n", "\n", "", "all_costs_to_go", "=", "np", ".", "array", "(", "cpp_mstar", ".", "find_all_costs_to_go", "(", "world", ",", "goals", ")", ")", "\n", "\n", "out", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "5", ",", "len", "(", "init_pos", ")", ",", "5", ")", ":", "\n", "          ", "out", "[", "'map_dim'", "]", "=", "(", "32", ",", "32", ")", "\n", "out", "[", "'world'", "]", "=", "world", "\n", "out", "[", "'init_pos'", "]", "=", "init_pos", "[", ":", "i", "]", "\n", "out", "[", "'goals'", "]", "=", "goals", "[", ":", "i", "]", "\n", "out", "[", "'obs'", "]", "=", "obs", "\n", "out", "[", "'map_name'", "]", "=", "map_name", "\n", "out", "[", "'scen'", "]", "=", "scen_type", "\n", "out", "[", "'all_costs_to_go'", "]", "=", "all_costs_to_go", "[", ":", "i", "]", "\n", "\n", "out_name", "=", "map_name", "+", "'_'", "+", "scen_type", "+", "'_'", "+", "str", "(", "scen_idx", ")", "+", "'_'", "+", "str", "(", "i", ")", "+", "'.json'", "\n", "with", "open", "(", "output_dir", "+", "out_name", ",", "'w'", ")", "as", "fout", ":", "\n", "            ", "json", ".", "dump", "(", "out", ",", "fout", ",", "cls", "=", "NumpyEncoder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.seen_maps.NumpyEncoder.default": [[17, 40], ["isinstance", "json.JSONEncoder.default", "int", "isinstance", "float", "isinstance", "isinstance", "obj.tolist", "isinstance", "bool", "isinstance"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_solver.NumpyEncoder.default"], ["def", "default", "(", "self", ",", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "(", "np", ".", "int_", ",", "np", ".", "intc", ",", "np", ".", "intp", ",", "np", ".", "int8", ",", "\n", "np", ".", "int16", ",", "np", ".", "int32", ",", "np", ".", "int64", ",", "np", ".", "uint8", ",", "\n", "np", ".", "uint16", ",", "np", ".", "uint32", ",", "np", ".", "uint64", ")", ")", ":", "\n", "\n", "            ", "return", "int", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "float_", ",", "np", ".", "float16", ",", "np", ".", "float32", ",", "np", ".", "float64", ")", ")", ":", "\n", "            ", "return", "float", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "complex_", ",", "np", ".", "complex64", ",", "np", ".", "complex128", ")", ")", ":", "\n", "            ", "return", "{", "'real'", ":", "obj", ".", "real", ",", "'imag'", ":", "obj", ".", "imag", "}", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "ndarray", ",", ")", ")", ":", "\n", "            ", "return", "obj", ".", "tolist", "(", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "bool_", ")", ")", ":", "\n", "            ", "return", "bool", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "void", ")", ")", ":", "\n", "            ", "return", "None", "\n", "\n", "", "return", "json", ".", "JSONEncoder", ".", "default", "(", "self", ",", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.test.seen_maps.generate_mapf_instances": [[41, 99], ["sys.path.append", "print", "int", "json.load", "numpy.array", "gzip.open", "available.copy", "dict", "numpy.array", "[].split", "zip", "zip", "random.shuffle", "init_pos.append", "goals.append", "all_costs_to_go.append", "print", "open", "json.dump", "len", "str", "numpy.where", "numpy.where", "numpy.array", "input_map.split", "cpp_mstar.find_all_costs_to_go", "str"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy"], ["", "", "def", "generate_mapf_instances", "(", "input_maps", ",", "output_dir", ",", "od_mstar3_dir", ")", ":", "\n", "  ", "sys", ".", "path", ".", "append", "(", "od_mstar3_dir", ")", "\n", "import", "cpp_mstar", "\n", "\n", "for", "input_map", "in", "input_maps", ":", "\n", "    ", "print", "(", "'Working on World: '", ",", "input_map", ")", "\n", "world_num", "=", "int", "(", "input_map", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", ")", "\n", "map_data", "=", "json", ".", "load", "(", "gzip", ".", "open", "(", "input_map", ",", "'rt'", ",", "encoding", "=", "'ascii'", ")", ")", "\n", "world", "=", "np", ".", "array", "(", "map_data", "[", "'world'", "]", ")", "\n", "obs", "=", "[", "(", "x", ",", "y", ")", "for", "x", ",", "y", "in", "zip", "(", "*", "np", ".", "where", "(", "world", "==", "1", ")", ")", "]", "\n", "available", "=", "[", "(", "x", ",", "y", ")", "for", "x", ",", "y", "in", "zip", "(", "*", "np", ".", "where", "(", "world", "==", "0", ")", ")", "]", "\n", "\n", "num_agents", "=", "5", "\n", "while", "num_agents", "<=", "MAX_AGENTS", ":", "\n", "      ", "free", "=", "available", ".", "copy", "(", ")", "\n", "\n", "init_pos", "=", "[", "]", "\n", "goals", "=", "[", "]", "\n", "all_costs_to_go", "=", "[", "]", "\n", "\n", "trials", "=", "0", "\n", "while", "len", "(", "init_pos", ")", "<", "num_agents", "and", "trials", "<", "MAX_TRIALS", ":", "\n", "        ", "random", ".", "shuffle", "(", "free", ")", "\n", "start", "=", "free", "[", "0", "]", "\n", "goal", "=", "free", "[", "1", "]", "\n", "\n", "try", ":", "\n", "          ", "cost_to_go", "=", "np", ".", "array", "(", "cpp_mstar", ".", "find_all_costs_to_go", "(", "world", ",", "[", "goal", "]", ")", ")", "[", "0", "]", "\n", "if", "cost_to_go", "[", "start", "]", ">", "MAX_COST_POSSIBLE", ":", "\n", "            ", "raise", "Exception", "\n", "", "", "except", ":", "\n", "          ", "continue", "\n", "\n", "", "init_pos", ".", "append", "(", "start", ")", "\n", "goals", ".", "append", "(", "goal", ")", "\n", "all_costs_to_go", ".", "append", "(", "cost_to_go", ")", "\n", "\n", "free", "=", "free", "[", "2", ":", "]", "\n", "trials", "+=", "1", "\n", "\n", "", "if", "trials", ">=", "MAX_TRIALS", ":", "\n", "        ", "print", "(", "'Cannot add {} agents.'", ".", "format", "(", "num_agents", ")", ")", "\n", "break", "\n", "\n", "", "output", "=", "dict", "(", ")", "\n", "output", "[", "'world'", "]", "=", "world", "\n", "output", "[", "'obs'", "]", "=", "obs", "\n", "output", "[", "'init_pos'", "]", "=", "init_pos", "\n", "output", "[", "'goals'", "]", "=", "goals", "\n", "output", "[", "'map_dim'", "]", "=", "(", "OUT_DIM", ",", "OUT_DIM", ")", "\n", "output", "[", "'num_agents'", "]", "=", "num_agents", "\n", "output", "[", "'all_costs_to_go'", "]", "=", "np", ".", "array", "(", "all_costs_to_go", ")", "\n", "\n", "out_file", "=", "output_dir", "+", "str", "(", "world_num", ")", "+", "'_'", "+", "str", "(", "num_agents", ")", "+", "'.json'", "\n", "with", "open", "(", "out_file", ",", "'w'", ")", "as", "fout", ":", "\n", "          ", "json", ".", "dump", "(", "output", ",", "fout", ",", "cls", "=", "NumpyEncoder", ")", "\n", "\n", "", "num_agents", "+=", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_batch.get_normalised_ctg": [[14, 24], ["numpy.max", "numpy.min", "len"], "function", ["None"], ["def", "get_normalised_ctg", "(", "cost_to_go", ",", "max_cost_possible", ")", ":", "\n", "  ", "max_current", "=", "np", ".", "max", "(", "cost_to_go", "[", "cost_to_go", "<=", "max_cost_possible", "]", ")", "\n", "min_current", "=", "np", ".", "min", "(", "cost_to_go", ")", "\n", "if", "len", "(", "cost_to_go", "[", "cost_to_go", ">=", "max_cost_possible", "]", ")", "!=", "0", ":", "\n", "    ", "new_max", "=", "max_current", "+", "(", "max_current", "-", "min_current", ")", "\n", "", "else", ":", "\n", "    ", "new_max", "=", "max_current", "\n", "", "cost_to_go", "[", "cost_to_go", ">=", "max_cost_possible", "]", "=", "new_max", "\n", "cost_to_go", "=", "(", "cost_to_go", "-", "min_current", ")", "/", "(", "new_max", "-", "min_current", ")", "\n", "return", "cost_to_go", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_batch.generate_batches": [[25, 192], ["numpy.array", "numpy.zeros", "random.shuffle", "random.shuffle", "gzip.open", "json.load", "print", "print", "range", "int", "numpy.copy", "random_32_50oa_batch.get_normalised_ctg", "numpy.zeros", "range", "random_32_50oa_batch.get_normalised_ctg", "out_X.append", "out_y.append", "len", "numpy.random.permutation", "range", "int", "numpy.array", "random_32_50oa_batch.get_normalised_ctg", "print", "len", "len", "numpy.random.permutation", "len", "len", "numpy.array", "len", "len", "len", "open", "numpy.savez_compressed", "print", "numpy.array", "numpy.array", "Exception", "str", "str"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_batch.get_normalised_ctg", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_batch.get_normalised_ctg", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_batch.get_normalised_ctg"], ["", "def", "generate_batches", "(", "files", ",", "idx", ",", "output_dir", ")", ":", "\n", "  ", "output_file_num", "=", "0", "\n", "out_X", "=", "[", "]", "\n", "out_y", "=", "[", "]", "\n", "for", "file", "in", "files", ":", "\n", "    ", "try", ":", "\n", "      ", "with", "gzip", ".", "open", "(", "file", ",", "'rt'", ",", "encoding", "=", "'ascii'", ")", "as", "fin", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "fin", ")", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "      ", "print", "(", "file", ")", "\n", "print", "(", "e", ")", "\n", "continue", "\n", "\n", "", "map_dim", "=", "data", "[", "'map_dim'", "]", "\n", "num_agents", "=", "data", "[", "'num_agents'", "]", "\n", "\n", "world", "=", "np", ".", "array", "(", "data", "[", "'world'", "]", ")", "\n", "goals", "=", "data", "[", "'goals'", "]", "\n", "all_costs_to_go", "=", "data", "[", "'all_costs_to_go'", "]", "\n", "path", "=", "data", "[", "'path'", "]", "\n", "\n", "'''\n    1. Obstacle Map - Obstacles marked as 1\n    2. Agent Start Map - Initial Position marked as 1\n    3. Agent Goal Map - Goal position marked as 1\n    4. Cost-to-Map - Smallest value => 0 for goal, rest scaled between 0 and 1\n    5. Other Agent Start Map - Initial Positions marked as 1\n    6. Other Agent Goal Map - Other goal position marked as 1\n    7. Sum of Cost to Map - Other Agents\n    8. Future 1 of Other Agents\n    9. Future 2 of Other Agents\n    10. Future 3 of Other Agents\n    '''", "\n", "X_base", "=", "np", ".", "zeros", "(", "(", "10", ",", "OUT_DIM", ",", "OUT_DIM", ")", ")", "\n", "\n", "X_base", "[", "0", "]", "=", "world", "\n", "\n", "path_idxs", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", "]", "\n", "random", ".", "shuffle", "(", "path_idxs", ")", "\n", "path_idxs", "=", "path_idxs", "[", ":", "int", "(", "len", "(", "path", ")", "*", "PATH_PERC", ")", "]", "\n", "\n", "for", "path_idx", "in", "path_idxs", ":", "\n", "      ", "init_pos", "=", "path", "[", "path_idx", "]", "\n", "next_pos", "=", "path", "[", "path_idx", "+", "1", "]", "\n", "\n", "agent_idxs", "=", "[", "i", "for", "i", "in", "range", "(", "num_agents", ")", "]", "\n", "random", ".", "shuffle", "(", "agent_idxs", ")", "\n", "agent_idxs", "=", "agent_idxs", "[", ":", "int", "(", "num_agents", "*", "AGENT_PERC", ")", "]", "\n", "\n", "for", "i", "in", "agent_idxs", ":", "\n", "        ", "X", "=", "np", ".", "copy", "(", "X_base", ")", "\n", "start", "=", "init_pos", "[", "i", "]", "\n", "end", "=", "goals", "[", "i", "]", "\n", "\n", "X", "[", "1", "]", "[", "start", "[", "0", "]", "]", "[", "start", "[", "1", "]", "]", "=", "1", "\n", "X", "[", "2", "]", "[", "end", "[", "0", "]", "]", "[", "end", "[", "1", "]", "]", "=", "1", "\n", "\n", "X", "[", "3", "]", "=", "get_normalised_ctg", "(", "np", ".", "array", "(", "all_costs_to_go", "[", "i", "]", ")", ",", "map_dim", "[", "0", "]", "*", "map_dim", "[", "1", "]", ")", "\n", "\n", "rows", "=", "map_dim", "[", "0", "]", "\n", "cols", "=", "map_dim", "[", "1", "]", "\n", "\n", "sum_of_costs_to_go", "=", "np", ".", "zeros", "(", "(", "OUT_DIM", ",", "OUT_DIM", ")", ")", "\n", "\n", "for", "j", "in", "range", "(", "num_agents", ")", ":", "\n", "          ", "if", "i", "==", "j", ":", "\n", "            ", "continue", "\n", "\n", "", "other_start", "=", "init_pos", "[", "j", "]", "\n", "other_goal", "=", "goals", "[", "j", "]", "\n", "other_cost_to_go", "=", "get_normalised_ctg", "(", "np", ".", "array", "(", "all_costs_to_go", "[", "j", "]", ")", ",", "map_dim", "[", "0", "]", "*", "map_dim", "[", "1", "]", ")", "\n", "\n", "X", "[", "4", "]", "[", "other_start", "[", "0", "]", "]", "[", "other_start", "[", "1", "]", "]", "=", "1", "\n", "X", "[", "5", "]", "[", "other_goal", "[", "0", "]", "]", "[", "other_goal", "[", "1", "]", "]", "=", "1", "\n", "\n", "sum_of_costs_to_go", "+=", "other_cost_to_go", "\n", "\n", "pos_x", "=", "other_start", "[", "0", "]", "\n", "pos_y", "=", "other_start", "[", "1", "]", "\n", "\n", "moves", "=", "3", "\n", "array_idx", "=", "7", "\n", "while", "moves", ">", "0", ":", "\n", "            ", "min_x", "=", "pos_x", "\n", "min_y", "=", "pos_y", "\n", "min_cost", "=", "map_dim", "[", "0", "]", "*", "map_dim", "[", "1", "]", "\n", "\n", "if", "pos_x", ">", "0", "and", "other_cost_to_go", "[", "pos_x", "-", "1", "]", "[", "pos_y", "]", "<", "min_cost", ":", "\n", "              ", "min_cost", "=", "other_cost_to_go", "[", "pos_x", "-", "1", "]", "[", "pos_y", "]", "\n", "min_x", "=", "pos_x", "-", "1", "\n", "min_y", "=", "pos_y", "\n", "", "if", "pos_x", "<", "rows", "-", "1", "and", "other_cost_to_go", "[", "pos_x", "+", "1", "]", "[", "pos_y", "]", "<", "min_cost", ":", "\n", "              ", "min_cost", "=", "other_cost_to_go", "[", "pos_x", "+", "1", "]", "[", "pos_y", "]", "\n", "min_x", "=", "pos_x", "+", "1", "\n", "min_y", "=", "pos_y", "\n", "", "if", "pos_y", ">", "0", "and", "other_cost_to_go", "[", "pos_x", "]", "[", "pos_y", "-", "1", "]", "<", "min_cost", ":", "\n", "              ", "min_cost", "=", "other_cost_to_go", "[", "pos_x", "]", "[", "pos_y", "-", "1", "]", "\n", "min_x", "=", "pos_x", "\n", "min_y", "=", "pos_y", "-", "1", "\n", "", "if", "pos_y", "<", "cols", "-", "1", "and", "other_cost_to_go", "[", "pos_x", "]", "[", "pos_y", "+", "1", "]", "<", "min_cost", ":", "\n", "              ", "min_cost", "=", "other_cost_to_go", "[", "pos_x", "]", "[", "pos_y", "+", "1", "]", "\n", "min_x", "=", "pos_x", "\n", "min_y", "=", "pos_y", "+", "1", "\n", "\n", "", "X", "[", "array_idx", "]", "[", "min_x", "]", "[", "min_y", "]", "=", "1", "\n", "\n", "pos_x", "=", "min_x", "\n", "pos_y", "=", "min_y", "\n", "\n", "moves", "-=", "1", "\n", "array_idx", "+=", "1", "\n", "\n", "", "", "X", "[", "6", "]", "=", "get_normalised_ctg", "(", "sum_of_costs_to_go", ",", "map_dim", "[", "0", "]", "*", "map_dim", "[", "1", "]", ")", "\n", "\n", "start_x", "=", "start", "[", "0", "]", "\n", "start_y", "=", "start", "[", "1", "]", "\n", "next_pos_x", "=", "next_pos", "[", "i", "]", "[", "0", "]", "\n", "next_pos_y", "=", "next_pos", "[", "i", "]", "[", "1", "]", "\n", "\n", "if", "start_x", "==", "next_pos_x", "and", "start_y", "==", "next_pos_y", ":", "\n", "          ", "y", "=", "0", "#no move", "\n", "", "elif", "start_x", "-", "1", "==", "next_pos_x", "and", "start_y", "==", "next_pos_y", ":", "\n", "          ", "y", "=", "1", "#move up", "\n", "", "elif", "start_x", "+", "1", "==", "next_pos_x", "and", "start_y", "==", "next_pos_y", ":", "\n", "          ", "y", "=", "2", "#move down", "\n", "", "elif", "start_x", "==", "next_pos_x", "and", "start_y", "-", "1", "==", "next_pos_y", ":", "\n", "          ", "y", "=", "3", "#move left", "\n", "", "elif", "start_x", "==", "next_pos_x", "and", "start_y", "+", "1", "==", "next_pos_y", ":", "\n", "          ", "y", "=", "4", "#move right", "\n", "", "else", ":", "\n", "          ", "raise", "Exception", "(", "'Illegal move'", ")", "\n", "\n", "", "if", "len", "(", "out_X", ")", "%", "1000", "==", "0", ":", "\n", "          ", "print", "(", "len", "(", "out_X", ")", ")", "\n", "\n", "", "out_X", ".", "append", "(", "X", ")", "\n", "out_y", ".", "append", "(", "y", ")", "\n", "\n", "", "if", "len", "(", "out_X", ")", ">=", "8192", ":", "\n", "        ", "rand", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "out_X", ")", ")", "\n", "out_X_randomized", "=", "[", "out_X", "[", "i", "]", "for", "i", "in", "rand", "]", "\n", "out_y_randomized", "=", "[", "out_y", "[", "i", "]", "for", "i", "in", "rand", "]", "\n", "\n", "batch_size", "=", "16", "\n", "while", "len", "(", "out_X_randomized", ")", ">=", "batch_size", ":", "\n", "          ", "X_batch", "=", "out_X_randomized", "[", ":", "batch_size", "]", "\n", "y_batch", "=", "out_y_randomized", "[", ":", "batch_size", "]", "\n", "\n", "rand", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "X_batch", ")", ")", "\n", "X_batch_randomized", "=", "[", "X_batch", "[", "i", "]", "for", "i", "in", "rand", "]", "\n", "y_batch_randomized", "=", "[", "y_batch", "[", "i", "]", "for", "i", "in", "rand", "]", "\n", "\n", "with", "open", "(", "output_dir", "+", "str", "(", "idx", ")", "+", "'_'", "+", "str", "(", "output_file_num", ")", "+", "'.npz'", ",", "'wb'", ")", "as", "fout", ":", "\n", "            ", "np", ".", "savez_compressed", "(", "fout", ",", "X", "=", "np", ".", "array", "(", "X_batch_randomized", ")", ",", "y", "=", "np", ".", "array", "(", "y_batch_randomized", ")", ")", "\n", "\n", "", "output_file_num", "+=", "1", "\n", "\n", "if", "output_file_num", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "'Working on idx:'", ",", "idx", ",", "'Output file num:'", ",", "output_file_num", ")", "\n", "\n", "", "out_X_randomized", "=", "out_X_randomized", "[", "batch_size", ":", "]", "\n", "out_y_randomized", "=", "out_y_randomized", "[", "batch_size", ":", "]", "\n", "\n", "", "out_X", "=", "out_X_randomized", "\n", "out_y", "=", "out_y_randomized", "\n", "\n", "", "", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_batch.log_result": [[193, 195], ["print"], "function", ["None"], ["", "def", "log_result", "(", "idx", ")", ":", "\n", "    ", "print", "(", "'Completed:'", ",", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_maps.NumpyEncoder.default": [[20, 43], ["isinstance", "json.JSONEncoder.default", "int", "isinstance", "float", "isinstance", "isinstance", "obj.tolist", "isinstance", "bool", "isinstance"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_solver.NumpyEncoder.default"], ["def", "default", "(", "self", ",", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "(", "np", ".", "int_", ",", "np", ".", "intc", ",", "np", ".", "intp", ",", "np", ".", "int8", ",", "\n", "np", ".", "int16", ",", "np", ".", "int32", ",", "np", ".", "int64", ",", "np", ".", "uint8", ",", "\n", "np", ".", "uint16", ",", "np", ".", "uint32", ",", "np", ".", "uint64", ")", ")", ":", "\n", "\n", "            ", "return", "int", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "float_", ",", "np", ".", "float16", ",", "np", ".", "float32", ",", "np", ".", "float64", ")", ")", ":", "\n", "            ", "return", "float", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "complex_", ",", "np", ".", "complex64", ",", "np", ".", "complex128", ")", ")", ":", "\n", "            ", "return", "{", "'real'", ":", "obj", ".", "real", ",", "'imag'", ":", "obj", ".", "imag", "}", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "ndarray", ",", ")", ")", ":", "\n", "            ", "return", "obj", ".", "tolist", "(", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "bool_", ")", ")", ":", "\n", "            ", "return", "bool", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "void", ")", ")", ":", "\n", "            ", "return", "None", "\n", "\n", "", "return", "json", ".", "JSONEncoder", ".", "default", "(", "self", ",", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_maps.generate_mapf_instances": [[44, 120], ["sys.path.append", "sys.path.append", "print", "str", "numpy.random.uniform", "random.uniform", "print", "available.copy", "dict", "numpy.array", "pathlib.Path", "zip", "zip", "len", "random.shuffle", "init_pos.append", "goals.append", "all_costs_to_go.append", "gzip.open", "json.dump", "str", "numpy.where", "numpy.where", "numpy.array", "cpp_mstar.find_all_costs_to_go", "str", "int", "str"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy"], ["", "", "def", "generate_mapf_instances", "(", "worlds", ",", "idx", ",", "output_dir", ",", "od_mstar3_dir", ")", ":", "\n", "  ", "sys", ".", "path", ".", "append", "(", "od_mstar3_dir", ")", "\n", "sys", ".", "path", ".", "append", "(", "str", "(", "Path", "(", "od_mstar3_dir", ")", ".", "parent", ")", ")", "\n", "import", "cpp_mstar", "\n", "\n", "print", "(", "'Thread {} started.'", ".", "format", "(", "idx", ")", ")", "\n", "for", "world_num", "in", "worlds", ":", "\n", "    ", "world", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "(", "OUT_DIM", ",", "OUT_DIM", ")", ")", "\n", "\n", "obs_den_random", "=", "random", ".", "uniform", "(", "0", ",", "1", ")", "\n", "if", "obs_den_random", "<=", "0.166", ":", "\n", "      ", "obs_den", "=", "0.0", "\n", "", "elif", "obs_den_random", "<=", "0.166", "*", "2", ":", "\n", "      ", "obs_den", "=", "0.1", "\n", "", "elif", "obs_den_random", "<=", "0.166", "*", "3", ":", "\n", "      ", "obs_den", "=", "0.2", "\n", "", "elif", "obs_den_random", "<=", "0.166", "*", "4", ":", "\n", "      ", "obs_den", "=", "0.3", "\n", "", "elif", "obs_den_random", "<=", "0.166", "*", "5", ":", "\n", "      ", "obs_den", "=", "0.4", "\n", "", "else", ":", "\n", "      ", "obs_den", "=", "0.5", "\n", "\n", "", "if", "world_num", "%", "10", "==", "0", ":", "\n", "      ", "print", "(", "'Working on World: {} Obstacle Density: {}'", ".", "format", "(", "world_num", ",", "obs_den", ")", ")", "\n", "\n", "", "world", "[", "world", "<=", "obs_den", "]", "=", "-", "1", "\n", "world", "[", "world", ">", "obs_den", "]", "=", "0", "\n", "world", "[", "world", "==", "-", "1", "]", "=", "1", "\n", "obs", "=", "[", "(", "x", ",", "y", ")", "for", "x", ",", "y", "in", "zip", "(", "*", "np", ".", "where", "(", "world", "==", "1", ")", ")", "]", "\n", "available", "=", "[", "(", "x", ",", "y", ")", "for", "x", ",", "y", "in", "zip", "(", "*", "np", ".", "where", "(", "world", "==", "0", ")", ")", "]", "\n", "\n", "num_agents", "=", "2", "\n", "while", "num_agents", "<=", "MAX_AGENTS", ":", "\n", "#print('Working on no. agents: ', num_agents)", "\n", "      ", "free", "=", "available", ".", "copy", "(", ")", "\n", "\n", "init_pos", "=", "[", "]", "\n", "goals", "=", "[", "]", "\n", "all_costs_to_go", "=", "[", "]", "\n", "\n", "while", "len", "(", "init_pos", ")", "<", "num_agents", ":", "\n", "        ", "random", ".", "shuffle", "(", "free", ")", "\n", "start", "=", "free", "[", "0", "]", "\n", "goal", "=", "free", "[", "1", "]", "\n", "\n", "try", ":", "\n", "          ", "cost_to_go", "=", "np", ".", "array", "(", "cpp_mstar", ".", "find_all_costs_to_go", "(", "world", ",", "[", "goal", "]", ")", ")", "[", "0", "]", "\n", "if", "cost_to_go", "[", "start", "]", ">", "MAX_COST_POSSIBLE", ":", "\n", "            ", "raise", "Exception", "\n", "", "", "except", ":", "\n", "          ", "continue", "\n", "\n", "", "init_pos", ".", "append", "(", "start", ")", "\n", "goals", ".", "append", "(", "goal", ")", "\n", "all_costs_to_go", ".", "append", "(", "cost_to_go", ")", "\n", "\n", "free", "=", "free", "[", "2", ":", "]", "\n", "\n", "", "output", "=", "dict", "(", ")", "\n", "output", "[", "'world'", "]", "=", "world", "\n", "output", "[", "'obs_den'", "]", "=", "obs_den", "\n", "output", "[", "'obs'", "]", "=", "obs", "\n", "output", "[", "'init_pos'", "]", "=", "init_pos", "\n", "output", "[", "'goals'", "]", "=", "goals", "\n", "output", "[", "'map_dim'", "]", "=", "(", "OUT_DIM", ",", "OUT_DIM", ")", "\n", "output", "[", "'num_agents'", "]", "=", "num_agents", "\n", "output", "[", "'all_costs_to_go'", "]", "=", "np", ".", "array", "(", "all_costs_to_go", ")", "\n", "\n", "out_file", "=", "output_dir", "+", "str", "(", "world_num", ")", "+", "'_'", "+", "str", "(", "int", "(", "obs_den", "*", "10", ")", ")", "+", "'_'", "+", "str", "(", "num_agents", ")", "+", "'.json.gz'", "\n", "with", "gzip", ".", "open", "(", "out_file", ",", "'wt'", ",", "encoding", "=", "'ascii'", ")", "as", "fout", ":", "\n", "          ", "json", ".", "dump", "(", "output", ",", "fout", ",", "cls", "=", "NumpyEncoder", ")", "\n", "\n", "", "num_agents", "+=", "1", "\n", "\n", "", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_maps.log_result": [[121, 123], ["print"], "function", ["None"], ["", "def", "log_result", "(", "idx", ")", ":", "\n", "    ", "print", "(", "'Completed:'", ",", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_solver.NumpyEncoder.default": [[16, 39], ["isinstance", "json.JSONEncoder.default", "int", "isinstance", "float", "isinstance", "isinstance", "obj.tolist", "isinstance", "bool", "isinstance"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_solver.NumpyEncoder.default"], ["def", "default", "(", "self", ",", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "(", "np", ".", "int_", ",", "np", ".", "intc", ",", "np", ".", "intp", ",", "np", ".", "int8", ",", "\n", "np", ".", "int16", ",", "np", ".", "int32", ",", "np", ".", "int64", ",", "np", ".", "uint8", ",", "\n", "np", ".", "uint16", ",", "np", ".", "uint32", ",", "np", ".", "uint64", ")", ")", ":", "\n", "\n", "            ", "return", "int", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "float_", ",", "np", ".", "float16", ",", "np", ".", "float32", ",", "np", ".", "float64", ")", ")", ":", "\n", "            ", "return", "float", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "complex_", ",", "np", ".", "complex64", ",", "np", ".", "complex128", ")", ")", ":", "\n", "            ", "return", "{", "'real'", ":", "obj", ".", "real", ",", "'imag'", ":", "obj", ".", "imag", "}", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "ndarray", ",", ")", ")", ":", "\n", "            ", "return", "obj", ".", "tolist", "(", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "bool_", ")", ")", ":", "\n", "            ", "return", "bool", "(", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "(", "np", ".", "void", ")", ")", ":", "\n", "            ", "return", "None", "\n", "\n", "", "return", "json", ".", "JSONEncoder", ".", "default", "(", "self", ",", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_solver.solve_mapf_instances": [[40, 81], ["sys.path.append", "sys.path.append", "dict", "enumerate", "str", "numpy.array", "print", "[].split", "cpp_mstar.find_path", "gzip.open", "json.dump", "pathlib.Path", "gzip.open", "json.load", "print", "print", "print", "traceback.print_exc", "min", "file.split", "dict.get", "file.split"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path"], ["", "", "def", "solve_mapf_instances", "(", "files", ",", "idx", ",", "output_dir", ",", "od_mstar3_dir", ")", ":", "\n", "  ", "sys", ".", "path", ".", "append", "(", "od_mstar3_dir", ")", "\n", "sys", ".", "path", ".", "append", "(", "str", "(", "Path", "(", "od_mstar3_dir", ")", ".", "parent", ")", ")", "\n", "import", "cpp_mstar", "\n", "\n", "track_failed", "=", "dict", "(", ")", "\n", "for", "file_idx", ",", "file", "in", "enumerate", "(", "files", ")", ":", "\n", "    ", "if", "file_idx", "%", "10", "==", "0", ":", "\n", "      ", "print", "(", "'Working on file: {}, for thread: {}'", ".", "format", "(", "file_idx", ",", "idx", ")", ")", "\n", "\n", "", "try", ":", "\n", "      ", "with", "gzip", ".", "open", "(", "file", ",", "'rt'", ",", "encoding", "=", "'ascii'", ")", "as", "fin", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "fin", ")", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "      ", "print", "(", "file", ")", "\n", "print", "(", "e", ")", "\n", "continue", "\n", "\n", "", "world", "=", "np", ".", "array", "(", "data", "[", "'world'", "]", ")", "\n", "num_agents", "=", "data", "[", "'num_agents'", "]", "\n", "init_pos", "=", "data", "[", "'init_pos'", "]", "\n", "goals", "=", "data", "[", "'goals'", "]", "\n", "world_num", "=", "file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "\n", "if", "world_num", "in", "track_failed", ":", "\n", "      ", "if", "num_agents", ">", "track_failed", "[", "world_num", "]", ":", "\n", "        ", "print", "(", "'Skipping.'", ")", "\n", "continue", "\n", "\n", "", "", "try", ":", "\n", "      ", "path", "=", "cpp_mstar", ".", "find_path", "(", "world", ",", "init_pos", ",", "goals", ",", "inflation", "=", "1.1", ",", "time_limit", "=", "300", ")", "\n", "", "except", "Exception", ":", "\n", "      ", "traceback", ".", "print_exc", "(", ")", "\n", "track_failed", "[", "world_num", "]", "=", "min", "(", "num_agents", ",", "track_failed", ".", "get", "(", "world_num", ",", "100", ")", ")", "\n", "continue", "\n", "\n", "", "data", "[", "'path'", "]", "=", "path", "\n", "\n", "out_file", "=", "output_dir", "+", "file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "with", "gzip", ".", "open", "(", "out_file", ",", "'wt'", ",", "encoding", "=", "'ascii'", ")", "as", "fout", ":", "\n", "        ", "json", ".", "dump", "(", "data", ",", "fout", ",", "cls", "=", "NumpyEncoder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.train.random_32_50oa_solver.log_result": [[82, 84], ["print"], "function", ["None"], ["", "", "", "def", "log_result", "(", "idx", ")", ":", "\n", "    ", "print", "(", "'Completed:'", ",", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Graph_Interface.get_edge_cost": [[43, 46], ["None"], "methods", ["None"], ["def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Returns edge_cost of going from coord1 to coord2.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Graph_Interface.get_neighbors": [[47, 53], ["None"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the collision free neighbors of the specified coord.\n\n        Return value is a list of tuples each of which are a coordinate\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Policy_Interface.get_cost": [[74, 77], ["None"], "methods", ["None"], ["def", "get_cost", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"Returns the cost of moving from given position to goal\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Policy_Interface.get_edge_cost": [[78, 83], ["None"], "methods", ["None"], ["", "def", "get_edge_cost", "(", "self", ",", "config1", ",", "config2", ")", ":", "\n", "        ", "\"\"\"Returns the cost of traversing an edge in the underlying\n        graph\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Policy_Interface.get_step": [[84, 87], ["None"], "methods", ["None"], ["", "def", "get_step", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"Returns the configurations of the optimal neighbor of config\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Policy_Interface.get_neighbors": [[88, 97], ["None"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"Returns neighboring configurations of config\n\n        This function returns the configurations which are next to\n        config\n\n        Return list of tuples, each of which is a coordinate\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Policy_Interface.get_graph_size": [[98, 101], ["None"], "methods", ["None"], ["", "def", "get_graph_size", "(", "self", ",", "correct_for_size", "=", "True", ")", ":", "\n", "        ", "\"\"\"Returns number of nodes in graph\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Policy_Interface.get_limited_offset_neighbors": [[102, 105], ["None"], "methods", ["None"], ["", "def", "get_limited_offset_neighbors", "(", "self", ",", "config", ",", "max_offset", ",", "min_offset", "=", "0", ")", ":", "\n", "        ", "\"\"\"Returns set of neighbors between the offset arguments\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Policy_Interface.get_offset_neighbors": [[106, 109], ["None"], "methods", ["None"], ["", "def", "get_offset_neighbors", "(", "self", ",", "config", ",", "offset", ")", ":", "\n", "        ", "\"\"\"Returns neighbors of coord with offset specified by argument\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Policy_Interface.get_offsets": [[110, 113], ["None"], "methods", ["None"], ["", "def", "get_offsets", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"Return the offsets of the neighbors\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Config_Edge_Checker.col_check": [[118, 129], ["None"], "methods", ["None"], ["def", "col_check", "(", "self", ",", "state", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single state\n\n        state     - list of coordinates of robots\n        recursive - generate collisions sets for rM*\n\n        Returns:\n        M* collision set in type set if recursive false\n        rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.pass_through": [[138, 149], ["None"], "methods", ["None"], ["def", "pass_through", "(", "self", ",", "state1", ",", "state2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects pass through collisions\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state,\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.col_check": [[150, 161], ["None"], "methods", ["None"], ["", "def", "col_check", "(", "self", ",", "state", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single state\n\n        state     - list of coordinates of robots\n        recursive - generate collisions sets for rM*\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.cross_over": [[162, 174], ["None"], "methods", ["None"], ["", "def", "cross_over", "(", "self", ",", "state1", ",", "state2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over and pass through collisions\n\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.simple_pass_through": [[175, 186], ["None"], "methods", ["None"], ["", "def", "simple_pass_through", "(", "self", ",", "state1", ",", "state2", ")", ":", "\n", "        ", "\"\"\"Check for pass through collisions\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state\n\n        Returns:\n        True if pass through collision\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.simple_col_check": [[187, 197], ["None"], "methods", ["None"], ["", "def", "simple_col_check", "(", "self", ",", "state", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions at state,\n\n        state - list of robot coordinates\n\n        returns:\n        True if collision\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.simple_cross_over": [[198, 209], ["None"], "methods", ["None"], ["", "def", "simple_cross_over", "(", "self", ",", "state1", ",", "state2", ")", ":", "\n", "        ", "\"\"\"Check for cross over collisions in 8-connected worlds\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state\n\n        returns:\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.simple_incremental_cross_over": [[210, 225], ["None"], "methods", ["None"], ["", "def", "simple_incremental_cross_over", "(", "self", ",", "state1", ",", "state2", ")", ":", "\n", "        ", "\"\"\"Check for cross over collisions in 8-connected worlds.\n\n        Assumes that collision checking has been performed for everything\n        but the last robot in the coordinates.  To be used to save a bit\n        of time for partial expansion approaches\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state\n\n        returns:\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.simple_incremental_col_check": [[226, 240], ["None"], "methods", ["None"], ["", "def", "simple_incremental_col_check", "(", "self", ",", "state1", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions at c1,\n\n        Assumes that collision checking has been performed for everything\n        but the last robot in the coordinates.  To be used to save a bit\n        of time for partial expansion approaches\n\n        state1 - list of robot coordinates\n\n        returns:\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.single_bot_outpath_check": [[241, 256], ["None"], "methods", ["None"], ["", "def", "single_bot_outpath_check", "(", "self", ",", "cur_coord", ",", "prev_coord", ",", "cur_t", ",", "paths", ")", ":", "\n", "        ", "\"\"\"Tests for collisions from prev_coord to cur_coord\n\n        Checks for cross over collisions and collisions at the same\n        location when moving from cur_coord to prev_coord while robots\n        are moving in paths\n\n        cur_coord - position of a single robot\n\n        Returns:\n\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.simple_prio_col_check": [[257, 273], ["None"], "methods", ["None"], ["", "def", "simple_prio_col_check", "(", "self", ",", "coord", ",", "t", ",", "paths", ",", "pcoord", "=", "None", ",", "\n", "conn_8", "=", "False", ")", ":", "\n", "        ", "\"\"\"Returns true, if collision is detected, false otherwise\n        at the moment only used to check the obstacle collisions, but\n        didn't want to reject the other code already\n\n        coord - coord of potential new neighbor\n        t - current time step\n        paths - previously found paths\n        pcoord - previous coordinate of the path\n\n        Returns:\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.incremental_col_check": [[274, 288], ["None"], "methods", ["None"], ["", "def", "incremental_col_check", "(", "self", ",", "state", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions in state\n\n        state     - list of coordinates of robots\n        recursive - generate collisions sets for rM*\n\n        Only checks whether the last robot is\n        involved in a collision, for use with incremental methods\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.incremental_cross_over": [[289, 304], ["None"], "methods", ["None"], ["", "def", "incremental_cross_over", "(", "self", ",", "state1", ",", "state2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions.\n\n        Only checks if the last robot is involved in a collision, for use\n        with partial expansion approaches.\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state,\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.single_bot_cross_over": [[305, 320], ["None"], "methods", ["None"], ["", "def", "single_bot_cross_over", "(", "self", ",", "coord1", ",", "pcoord1", ",", "coord2", ",", "pcoord2", ")", ":", "\n", "        ", "\"\"\"Checks for cross-over and collisions between robots 1 and 2\n\n        Robots are moving from pcoord to coord\n\n        pcoord1 - first position of first robot\n        coord1  - second position of first robot\n        pcoord2 - first position of second robot\n        coord2  - second position of second robot\n\n        Returns:\n        True if collision\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.interface.Planner_Edge_Checker.prio_col_check": [[321, 336], ["None"], "methods", ["None"], ["", "def", "prio_col_check", "(", "self", ",", "coord", ",", "pcoord", ",", "t", ",", "paths", "=", "None", ",", "conn_8", "=", "False", ",", "\n", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Collision checking with paths passed as constraints\n\n        coord  - current node\n        pcoord - previous node\n        t      - timestep\n        paths  - paths that need to be avoided\n\n        Returns: (collision sets are of type set)\n            M* collision set if collision exists and recursive is false\n            rM* collision set if collision exists and recursive is true\n            None if no collision exists\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.prune_graph.to_networkx_graph": [[6, 24], ["od_mstar3.workspace_graph.Astar_Graph", "networkx.DiGraph", "range", "nx.DiGraph.nodes", "len", "range", "workspace_graph.Astar_Graph.get_neighbors", "len", "nx.DiGraph.add_edge", "nx.DiGraph.add_node"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Graph", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors"], ["def", "to_networkx_graph", "(", "obs_map", ")", ":", "\n", "    ", "'''Reads in a standard obs_map list and converts it to a networkx\n    digraph\n    obs_map - list of lists, 0 for empty cell, 1 for obstacle'''", "\n", "#Create a workspace_graph object to generate neighbors", "\n", "g", "=", "workspace_graph", ".", "Astar_Graph", "(", "obs_map", ",", "[", "0", ",", "0", "]", ")", "\n", "G", "=", "nx", ".", "DiGraph", "(", ")", "#Creates the graph object", "\n", "#Populate graph with nodes", "\n", "for", "x", "in", "range", "(", "len", "(", "obs_map", ")", ")", ":", "\n", "        ", "for", "y", "in", "range", "(", "len", "(", "obs_map", "[", "x", "]", ")", ")", ":", "\n", "            ", "if", "obs_map", "[", "x", "]", "[", "y", "]", "==", "0", ":", "\n", "                ", "G", ".", "add_node", "(", "(", "x", ",", "y", ")", ")", "\n", "#Add edges", "\n", "", "", "", "for", "i", "in", "G", ".", "nodes", "(", ")", ":", "\n", "#Stored nodes by their coordinates in G", "\n", "        ", "for", "j", "in", "g", ".", "get_neighbors", "(", "i", ")", ":", "\n", "            ", "G", ".", "add_edge", "(", "i", ",", "j", ")", "\n", "", "", "return", "G", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.prune_graph.prune_opposing_edge": [[25, 68], ["networkx.number_strongly_connected_components", "networkx.edge_betweenness_centrality", "max", "G.copy", "G.copy.remove_edge", "nx.edge_betweenness_centrality.values", "nx.edge_betweenness_centrality.keys", "networkx.number_strongly_connected_components", "nx.edge_betweenness_centrality.pop", "G.neighbors", "nx.edge_betweenness_centrality.values().index", "G.edges", "nx.edge_betweenness_centrality.values"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.index"], ["", "def", "prune_opposing_edge", "(", "G", ",", "num_edges", "=", "1", ")", ":", "\n", "    ", "'''Reads in a networkx digraph and prunes the edge opposing the most\n    between (i.e. edge on the most shortest path connections).  If this edge\n    doesn't have an opposing edge, or if the removal of said edge would\n    reduce the connectivity of the space, the next most between edge is pruned\n    instead.  Since computing completeness can be expensive, allows multiple\n    edges to be pruned before computing the impact of said prunning on\n    completeness is computed'''", "\n", "#Get the current number of strongly connected components, can't decrease", "\n", "#without preventing some paths from being found", "\n", "num_components", "=", "nx", ".", "number_strongly_connected_components", "(", "G", ")", "\n", "pruned", "=", "0", "\n", "# print 'computing betweeness'", "\n", "betweenness", "=", "nx", ".", "edge_betweenness_centrality", "(", "G", ")", "\n", "# print 'betweenness computed'", "\n", "while", "pruned", "<", "num_edges", ":", "\n", "        ", "max_bet", "=", "max", "(", "betweenness", ".", "values", "(", ")", ")", "\n", "if", "max_bet", "<=", "0", ":", "\n", "#Set betweeness to -1 if can't prune, set to 0 not between", "\n", "            ", "return", "G", "\n", "", "edge", "=", "betweenness", ".", "keys", "(", ")", "[", "betweenness", ".", "values", "(", ")", ".", "index", "(", "max_bet", ")", "]", "\n", "if", "not", "(", "edge", "[", "1", "]", ",", "edge", "[", "0", "]", ")", "in", "G", ".", "edges", "(", ")", ":", "\n", "#Already been pruned", "\n", "            ", "betweenness", "[", "edge", "]", "=", "-", "1", "\n", "# print 'no edge'", "\n", "continue", "\n", "#Test if pruning the edge will break connectivity", "\n", "", "temp_graph", "=", "G", ".", "copy", "(", ")", "\n", "temp_graph", ".", "remove_edge", "(", "edge", "[", "1", "]", ",", "edge", "[", "0", "]", ")", "\n", "if", "num_components", "==", "nx", ".", "number_strongly_connected_components", "(", "temp_graph", ")", ":", "\n", "#Can safely prune this edge", "\n", "            ", "G", "=", "temp_graph", "\n", "pruned", "+=", "1", "\n", "betweenness", "[", "edge", "]", "=", "-", "1", "\n", "betweenness", ".", "pop", "(", "(", "edge", "[", "1", "]", ",", "edge", "[", "0", "]", ")", ")", "\n", "# print 'pruned'", "\n", "#Need to prevent further edges from being pruned from this vertex", "\n", "for", "neighbor", "in", "G", ".", "neighbors", "(", "edge", "[", "1", "]", ")", ":", "\n", "                ", "betweenness", "[", "(", "edge", "[", "1", "]", ",", "neighbor", ")", "]", "=", "-", "1", "\n", "", "", "else", ":", "\n", "            ", "betweenness", "[", "edge", "]", "=", "-", "1", "\n", "# print 'breaks con %s' %(str(edge))", "\n", "", "", "return", "G", "\n", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.__init__": [[78, 85], ["sorted", "key"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "iterable", "=", "(", ")", ",", "key", "=", "None", ")", ":", "\n", "        ", "self", ".", "_given_key", "=", "key", "\n", "key", "=", "(", "lambda", "x", ":", "x", ")", "if", "key", "is", "None", "else", "key", "\n", "decorated", "=", "sorted", "(", "(", "key", "(", "item", ")", ",", "item", ")", "for", "item", "in", "iterable", ")", "\n", "self", ".", "_keys", "=", "[", "k", "for", "k", ",", "item", "in", "decorated", "]", "\n", "self", ".", "_items", "=", "[", "item", "for", "k", ",", "item", "in", "decorated", "]", "\n", "self", ".", "_key", "=", "key", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection._getkey": [[86, 88], ["None"], "methods", ["None"], ["", "def", "_getkey", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_key", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection._setkey": [[89, 92], ["SortedCollection.SortedCollection.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["", "def", "_setkey", "(", "self", ",", "key", ")", ":", "\n", "        ", "if", "key", "is", "not", "self", ".", "_key", ":", "\n", "            ", "self", ".", "__init__", "(", "self", ".", "_items", ",", "key", "=", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection._delkey": [[93, 95], ["SortedCollection.SortedCollection._setkey"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection._setkey"], ["", "", "def", "_delkey", "(", "self", ")", ":", "\n", "        ", "self", ".", "_setkey", "(", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.clear": [[98, 100], ["SortedCollection.SortedCollection.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "clear", "(", "self", ")", ":", "\n", "        ", "self", ".", "__init__", "(", "[", "]", ",", "self", ".", "_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.copy": [[101, 103], ["SortedCollection.SortedCollection.__class__"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", "(", "self", ",", "self", ".", "_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.__len__": [[104, 106], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_items", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.__getitem__": [[107, 109], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "self", ".", "_items", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.__iter__": [[110, 112], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "_items", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.__reversed__": [[113, 115], ["reversed"], "methods", ["None"], ["", "def", "__reversed__", "(", "self", ")", ":", "\n", "        ", "return", "reversed", "(", "self", ".", "_items", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.__repr__": [[116, 121], ["getattr", "repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'%s(%r, key=%s)'", "%", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "\n", "self", ".", "_items", ",", "\n", "getattr", "(", "self", ".", "_given_key", ",", "'__name__'", ",", "repr", "(", "self", ".", "_given_key", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.__reduce__": [[123, 125], ["None"], "methods", ["None"], ["", "def", "__reduce__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ",", "(", "self", ".", "_items", ",", "self", ".", "_given_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.__contains__": [[126, 134], ["SortedCollection.SortedCollection._key", "bisect.bisect_left", "bisect.bisect_right"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"So if an item has its key value changed, you are not going to\n        be able to recover its value\n        \"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "j", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "return", "item", "in", "self", ".", "_items", "[", "i", ":", "j", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.resort": [[135, 147], ["sorted", "SortedCollection.SortedCollection.key"], "methods", ["None"], ["", "def", "resort", "(", "self", ")", ":", "\n", "        ", "\"\"\"If all the key values are expected to have changed\n        dramatically, resort the items list, and regenerate the internal\n        representation\n\n        Note that this operation is not guaranteed to be stable, as it\n        depends on the ordering of a key, item pair, and the ordering of\n        the items is effectively arbitrary\n        \"\"\"", "\n", "decorated", "=", "sorted", "(", "(", "self", ".", "key", "(", "item", ")", ",", "item", ")", "for", "item", "in", "self", ".", "_items", ")", "\n", "self", ".", "_keys", "=", "[", "k", "for", "k", ",", "item", "in", "decorated", "]", "\n", "self", ".", "_items", "=", "[", "item", "for", "k", ",", "item", "in", "decorated", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.index": [[148, 154], ["SortedCollection.SortedCollection._key", "bisect.bisect_left", "bisect.bisect_right", "SortedCollection.SortedCollection._items[].index"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.index"], ["", "def", "index", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Find the position of an item.  Raise ValueError if not found.\"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "j", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "return", "self", ".", "_items", "[", "i", ":", "j", "]", ".", "index", "(", "item", ")", "+", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.count": [[155, 161], ["SortedCollection.SortedCollection._key", "bisect.bisect_left", "bisect.bisect_right", "SortedCollection.SortedCollection._items[].count"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.count"], ["", "def", "count", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Return number of occurrences of item\"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "j", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "return", "self", ".", "_items", "[", "i", ":", "j", "]", ".", "count", "(", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.insert": [[162, 168], ["SortedCollection.SortedCollection._key", "bisect.bisect_left", "SortedCollection.SortedCollection._keys.insert", "SortedCollection.SortedCollection._items.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], ["", "def", "insert", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Insert a new item.  If equal keys are found, add to the left\"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "self", ".", "_keys", ".", "insert", "(", "i", ",", "k", ")", "\n", "self", ".", "_items", ".", "insert", "(", "i", ",", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.insert_right": [[169, 175], ["SortedCollection.SortedCollection._key", "bisect.bisect_right", "SortedCollection.SortedCollection._keys.insert", "SortedCollection.SortedCollection._items.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], ["", "def", "insert_right", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Insert a new item.  If equal keys are found, add to the right\"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "self", ".", "_keys", ".", "insert", "(", "i", ",", "k", ")", "\n", "self", ".", "_items", ".", "insert", "(", "i", ",", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.remove": [[176, 184], ["SortedCollection.SortedCollection.index"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.index"], ["", "def", "remove", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Remove first occurence of item.\n\n        Raise ValueError if not found\n        \"\"\"", "\n", "i", "=", "self", ".", "index", "(", "item", ")", "\n", "del", "self", ".", "_keys", "[", "i", "]", "\n", "del", "self", ".", "_items", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.pop": [[185, 189], ["SortedCollection.SortedCollection._items.pop"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop"], ["", "def", "pop", "(", "self", ")", ":", "\n", "        ", "\"\"\"returns the rightmost value (greatest key value)\"\"\"", "\n", "del", "self", ".", "_keys", "[", "-", "1", "]", "\n", "return", "self", ".", "_items", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.consistent_pop": [[190, 202], ["SortedCollection.SortedCollection._keys.pop", "SortedCollection.SortedCollection._items.pop", "SortedCollection.SortedCollection._key"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop"], ["", "def", "consistent_pop", "(", "self", ")", ":", "\n", "        ", "\"\"\"returns the rightmost value (greatest key value) and checks\n        whether its cached key value is consistent with its current\n        cost.\n\n        returns:\n          value with greatest cached key\n          boolean: True if cached key is same as current key\n        \"\"\"", "\n", "cached_key", "=", "self", ".", "_keys", ".", "pop", "(", ")", "\n", "val", "=", "self", ".", "_items", ".", "pop", "(", ")", "\n", "return", "val", ",", "self", ".", "_key", "(", "val", ")", "==", "cached_key", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.find": [[203, 214], ["bisect.bisect_left", "ValueError", "len"], "methods", ["None"], ["", "def", "find", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return first item with a key == k.\n        Will fail if the key value of k was changed since it was\n        inserted\n\n        Raise ValueError if not found.\n        \"\"\"", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", "!=", "len", "(", "self", ")", "and", "self", ".", "_keys", "[", "i", "]", "==", "k", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key equal to: %r'", "%", "(", "k", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.find_le": [[215, 224], ["bisect.bisect_right", "ValueError"], "methods", ["None"], ["", "def", "find_le", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return last item with a key <= k.\n\n        Raise ValueError if not found.\n        \"\"\"", "\n", "i", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "-", "1", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key at or below: %r'", "%", "(", "k", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.find_lt": [[225, 234], ["bisect.bisect_left", "ValueError"], "methods", ["None"], ["", "def", "find_lt", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return last item with a key < k.\n\n        Raise ValueError if not found.\n        \"\"\"", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "-", "1", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key below: %r'", "%", "(", "k", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.find_ge": [[235, 244], ["bisect.bisect_left", "ValueError", "len"], "methods", ["None"], ["", "def", "find_ge", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return first item with a key >= equal to k.\n\n        Raise ValueError if not found\n        \"\"\"", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", "!=", "len", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key at or above: %r'", "%", "(", "k", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.SortedCollection.SortedCollection.find_gt": [[245, 254], ["bisect.bisect_right", "ValueError", "len"], "methods", ["None"], ["", "def", "find_gt", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return first item with a key > k.\n\n        Raise ValueError if not found\n        \"\"\"", "\n", "i", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", "!=", "len", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key above: %r'", "%", "(", "k", ",", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.OutOfTimeError.__init__": [[163, 165], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "value", "=", "None", ")", ":", "\n", "        ", "self", ".", "value", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.OutOfTimeError.__str__": [[166, 168], ["repr"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.NoSolutionError.__init__": [[171, 173], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "value", "=", "None", ")", ":", "\n", "        ", "self", ".", "value", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.NoSolutionError.__str__": [[174, 176], ["repr"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.OutOfScopeError.__init__": [[179, 182], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "value", "=", "None", ",", "col_set", "=", "(", ")", ")", ":", "\n", "        ", "self", ".", "value", "=", "value", "\n", "self", ".", "col_set", "=", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.OutOfScopeError.__str__": [[183, 185], ["repr"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "value", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.add_col_set_recursive": [[8, 53], ["list", "list", "tuple", "len", "len", "list.append", "c2[].isdisjoint", "c2[].issuperset", "list.pop", "list.append", "list.pop", "list.pop", "c2.pop.union", "list.pop"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop"], ["def", "add_col_set_recursive", "(", "c1", ",", "c2", ")", ":", "\n", "    ", "\"\"\"Returns a new collision set resulting from adding c1 to c2.  No\n    side effecting\n\n    collision set is done for the recursive case, where\n    ({1, 2}, ) + ({3, 4}, ) = ({1, 2}, {3, 4})\n\n    c1, c2 - tuples of (immutable) sets\n\n    returns:\n    recursive collision set containing c1 and c2\n\n    \"\"\"", "\n", "# Make shallow copies", "\n", "c1", "=", "list", "(", "c1", ")", "\n", "c2", "=", "list", "(", "c2", ")", "\n", "while", "len", "(", "c1", ")", ">", "0", ":", "\n", "        ", "i", "=", "0", "\n", "# Whether c1[-1] overlaps with any element of c2", "\n", "found_overlap", "=", "False", "\n", "while", "i", "<", "len", "(", "c2", ")", ":", "\n", "            ", "if", "not", "c2", "[", "i", "]", ".", "isdisjoint", "(", "c1", "[", "-", "1", "]", ")", ":", "\n", "# Found overlap", "\n", "                ", "if", "c2", "[", "i", "]", ".", "issuperset", "(", "c1", "[", "-", "1", "]", ")", ":", "\n", "# No change in c2", "\n", "                    ", "c1", ".", "pop", "(", ")", "\n", "found_overlap", "=", "True", "\n", "break", "\n", "# Have found a non-trivial overlap.  Need to add the", "\n", "# union to  c1 so that we can check if the union has any", "\n", "# further overlap with elements of c2", "\n", "", "temp", "=", "c2", ".", "pop", "(", "i", ")", "\n", "# replace c2[i] with the union of c2[i] and c1[-1]", "\n", "c1", ".", "append", "(", "temp", ".", "union", "(", "c1", ".", "pop", "(", ")", ")", ")", "\n", "found_overlap", "=", "True", "\n", "break", "\n", "", "else", ":", "\n", "# No overlap between c1[-1] and c2[i], so check next", "\n", "# element of c2", "\n", "                ", "i", "+=", "1", "\n", "", "", "if", "not", "found_overlap", ":", "\n", "# c1[-1] has no overlap with any element of c2, so it can be", "\n", "# added as is to c2", "\n", "            ", "c2", ".", "append", "(", "c1", ".", "pop", "(", ")", ")", "\n", "", "", "return", "tuple", "(", "c2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.add_col_set": [[55, 75], ["frozenset", "len", "temp.union.union", "len", "len"], "function", ["None"], ["", "def", "add_col_set", "(", "c1", ",", "c2", ")", ":", "\n", "    ", "\"\"\"Adds the collision sets c1 to c2.  c2 is assumed to contain a\n    single,\n    possibly empty, set\n\n    c1, c2 - input collision sets\n\n    returns:\n    combined collision set containing c1 and c2\n\n    \"\"\"", "\n", "temp", "=", "frozenset", "(", "[", "]", ")", "\n", "if", "len", "(", "c2", ")", ">=", "1", ":", "\n", "        ", "temp", "=", "c2", "[", "0", "]", "\n", "assert", "len", "(", "c2", ")", "==", "1", "\n", "", "for", "i", "in", "c1", ":", "\n", "        ", "temp", "=", "temp", ".", "union", "(", "i", ")", "\n", "", "if", "len", "(", "temp", ")", "==", "0", ":", "\n", "        ", "return", "(", ")", "\n", "", "return", "(", "temp", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.col_set_add": [[77, 91], ["col_set_addition.add_col_set_recursive", "col_set_addition.add_col_set"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.add_col_set_recursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set"], ["", "def", "col_set_add", "(", "c1", ",", "c2", ",", "recursive", ")", ":", "\n", "    ", "\"\"\"Adds two collision sets\n\n    c1, c2     - input collision sets\n    recursive - boolean, whether to perform recursive M* style addition\n\n    returns:\n    collision set containing c1 and c2\n\n    \"\"\"", "\n", "if", "recursive", ":", "\n", "        ", "return", "add_col_set_recursive", "(", "c1", ",", "c2", ")", "\n", "", "else", ":", "\n", "        ", "return", "add_col_set", "(", "c1", ",", "c2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.col_set_addition.effective_col_set": [[93, 160], ["list", "list", "effective_set.extend", "tuple", "len", "len", "col_set[].issubset", "effective_set.append", "col_set_to_remove.append", "list.pop", "list.pop", "col_set[].isdisjoint", "list.pop", "list.extend"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop"], ["", "", "def", "effective_col_set", "(", "col_set", ",", "prev_col_set", ")", ":", "\n", "    ", "\"\"\"Computes the effective collision set to use given the current\n    collision set and the collision set used to get to the current node\n\n    Only makes sense when used with recursive M*\n\n    The purpose of this code is that in recursive M*, you invoke a\n    subplanner to figure out how to get to the goal, which caches the\n    entire path to the goal .  The next step, you have an empty\n    collision set, so you don't query the subplanner with the cached\n    path, and have to find a bunch of collisions before using the cached\n    solution.  This is intended for use with a memory of what the\n    collision set was when you reached a given node.\n\n    Computes the \"effecitve collision set\".  Elements of the memorized\n    collision set are used if they have no non-empty intersections with\n    elements of the current collision set that are not subsets of the\n    memorized component.\n\n    elements of col_set are NOT used if they are contained within some\n    element of prev_col_set that is used.  Elements of prev_col_set are\n    used if they completely contain all elements of col_set with which\n    they intersect\n\n    col_set      - current collision set\n    prev_col_set - \"memorized\" collision set, i.e. the collision set of\n                   the optimal predecessor at the time the path from the\n                   optimal predecessor was first found\n\n    returns:\n    effective collision set.  Consists of the elements of the previous\n    collision set, which should index subplanners which have cached\n    paths available, and elements of the current collision set which\n    are not contained within prev_col_set\n    \"\"\"", "\n", "effective_set", "=", "[", "]", "\n", "prev_col_set", "=", "list", "(", "prev_col_set", ")", "\n", "col_set", "=", "list", "(", "col_set", ")", "\n", "while", "(", "len", "(", "prev_col_set", ")", ">", "0", ")", ":", "\n", "# Need to keep around the elements of col_set that won't be", "\n", "# used, because the containing element of prev_col_set may be", "\n", "# invalidated by a later element of col_set", "\n", "        ", "col_set_to_remove", "=", "[", "]", "\n", "j", "=", "0", "\n", "while", "(", "j", "<", "len", "(", "col_set", ")", ")", ":", "\n", "            ", "if", "col_set", "[", "j", "]", ".", "issubset", "(", "prev_col_set", "[", "-", "1", "]", ")", ":", "\n", "# this element is contained in prev_col_set, so can be", "\n", "# skipped unless prev_col_set-1] is invalidated by some", "\n", "# later element of col_set", "\n", "                ", "col_set_to_remove", ".", "append", "(", "col_set", ".", "pop", "(", "j", ")", ")", "\n", "", "elif", "not", "col_set", "[", "j", "]", ".", "isdisjoint", "(", "prev_col_set", "[", "-", "1", "]", ")", ":", "\n", "# this element partially overlaps prev_col_set,", "\n", "# invalidating it, so cannot use this element of", "\n", "# prev_col_set", "\n", "                ", "prev_col_set", ".", "pop", "(", ")", "\n", "# return the elements of col_set we were going to remove", "\n", "col_set", ".", "extend", "(", "col_set_to_remove", ")", "\n", "break", "\n", "", "else", ":", "\n", "                ", "j", "+=", "1", "\n", "", "", "else", ":", "\n", "# Never broke, so prev_col_set can be used as part of the", "\n", "# effective collision set", "\n", "            ", "effective_set", ".", "append", "(", "prev_col_set", ".", "pop", "(", ")", ")", "\n", "# Just copy over any elements of col_set that survived", "\n", "", "", "effective_set", ".", "extend", "(", "col_set", ")", "\n", "return", "tuple", "(", "effective_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.__init__": [[109, 188], ["float", "len", "od_mstar.Od_Mstar.gen_policy_planners", "tuple", "od_mstar3.workspace_graph.Edge_Checker", "range", "len"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_policy_planners"], ["def", "__init__", "(", "self", ",", "obs_map", ",", "goals", ",", "recursive", ",", "sub_search", "=", "None", ",", "\n", "col_checker", "=", "None", ",", "rob_id", "=", "None", ",", "inflation", "=", "1.0", ",", "\n", "end_time", "=", "10", "**", "15", ",", "connect_8", "=", "False", ",", "astar", "=", "False", ",", "\n", "full_space", "=", "False", ",", "flood_fill_policy", "=", "False", ",", "epeastar", "=", "False", ",", "\n", "offset_increment", "=", "1", ",", "makespan", "=", "False", ",", "col_set_memory", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        obs_map           - obstacle map,  matrix with 0 for free,  1\n                            for obstacle\n        goals             - ((x1, y1), (x2, y2), ...) coordinates of the\n                            goal, should be tuples\n        recursive         - True for rM*, false for basic M*\n        sub_search        - Sub planners, should be None for the full\n                            configuration space\n        col_checker       - object to handle robot-robot collision\n                            checking.  Should implement the same\n                            interface as workspace_graph.Edge_Checker\n        rob_id            - maps local robot identity to full\n                            configuration space identity,  should be\n                            None for the full configuration space\n                            instance\n        inflation         - how much the metric should be inflated by\n        end_time          - when the search should be terminated\n        connect_8         - True for 8 connected graph,  False for 4\n                            connected graph\n        astar             - use basic A* instead of operator\n                            decomposition\n        full_space        - whether to perform a full configuration\n                            space search\n        flood_fill_policy - compute policy with flood fill instead of\n                            resumable A*\n        epeastar          - Uses EPEA* instead of OD or A* for graph\n                            search\n        offset_increment  - how much to increase the EPEA* offset after\n                            every expansion\n        makespan          - minimize makespan (time to solution),\n                            instead of minimizing time robots spend away\n                            from their robots\n        col_set_memory    - remember previous step collision set,\n                            intended to provide more efficient cached\n                            path utillization.  False by default\n        \"\"\"", "\n", "# visualize - turn on visualization code - DISABLED", "\n", "self", ".", "obs_map", "=", "obs_map", "\n", "self", ".", "recursive", "=", "recursive", "\n", "self", ".", "sub_search", "=", "sub_search", "\n", "# Stores the global ids of the robots in order of their position", "\n", "# in coord", "\n", "self", ".", "rob_id", "=", "rob_id", "\n", "self", ".", "goals", "=", "goals", "\n", "# Graph that holds the graph representing the joint configuration space", "\n", "self", ".", "graph", "=", "{", "}", "\n", "self", ".", "end_time", "=", "end_time", "\n", "self", ".", "inflation", "=", "float", "(", "inflation", ")", "\n", "self", ".", "connect_8", "=", "connect_8", "\n", "self", ".", "astar", "=", "astar", "\n", "self", ".", "epeastar", "=", "epeastar", "\n", "self", ".", "offset_increment", "=", "offset_increment", "\n", "self", ".", "_makespan", "=", "makespan", "\n", "\n", "# Store some useful values", "\n", "self", ".", "updated", "=", "0", "\n", "self", ".", "num_bots", "=", "len", "(", "goals", ")", "\n", "# self.visualize = visualize", "\n", "self", ".", "full_space", "=", "full_space", "\n", "# Need a different key incorporating the offset for EPEM*", "\n", "if", "self", ".", "epeastar", ":", "\n", "            ", "self", ".", "open_list_key", "=", "lambda", "x", ":", "(", "-", "x", ".", "cost", "-", "x", ".", "h", "*", "self", ".", "inflation", "-", "\n", "x", ".", "offset", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "open_list_key", "=", "lambda", "x", ":", "-", "x", ".", "cost", "-", "x", ".", "h", "*", "self", ".", "inflation", "\n", "", "if", "self", ".", "rob_id", "is", "None", ":", "\n", "            ", "self", ".", "rob_id", "=", "tuple", "(", "range", "(", "len", "(", "goals", ")", ")", ")", "\n", "", "self", ".", "col_checker", "=", "col_checker", "\n", "if", "self", ".", "col_checker", "is", "None", ":", "\n", "            ", "self", ".", "col_checker", "=", "workspace_graph", ".", "Edge_Checker", "(", ")", "\n", "", "self", ".", "flood_fill_policy", "=", "flood_fill_policy", "\n", "# Making everything that can be immutable,  immutable", "\n", "self", ".", "_col_set_memory", "=", "col_set_memory", "\n", "self", ".", "gen_policy_planners", "(", "sub_search", ",", "self", ".", "obs_map", ",", "self", ".", "goals", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.gen_policy_planners": [[189, 212], ["tuple", "enumerate", "enumerate", "od_mstar3.workspace_graph.Workspace_Graph", "od_mstar3.workspace_graph.Astar_Graph"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Workspace_Graph", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Graph"], ["", "def", "gen_policy_planners", "(", "self", ",", "sub_search", ",", "obs_map", ",", "goals", ")", ":", "\n", "        ", "\"\"\"Creates the sub-planners and necessary policy keys.  This is\n        because pretty much every sub-planner I've made requires\n        adjusting the graph used to create the policies and passing\n        around dummy sub_searches\n\n        side effects to generate self.sub_search and self.policy_keys\n        \"\"\"", "\n", "self", ".", "policy_keys", "=", "tuple", "(", "[", "(", "i", ",", ")", "for", "i", "in", "self", ".", "rob_id", "]", ")", "\n", "self", ".", "sub_search", "=", "sub_search", "\n", "if", "self", ".", "sub_search", "is", "None", ":", "\n", "            ", "self", ".", "sub_search", "=", "{", "}", "\n", "# Wrapping the robot number in a tuple so we can use the same", "\n", "# structure for planners for compound robots", "\n", "if", "self", ".", "flood_fill_policy", ":", "\n", "                ", "for", "dex", ",", "key", "in", "enumerate", "(", "self", ".", "policy_keys", ")", ":", "\n", "                    ", "self", ".", "sub_search", "[", "key", "]", "=", "workspace_graph", ".", "Workspace_Graph", "(", "\n", "obs_map", ",", "goals", "[", "dex", "]", ",", "connect_8", "=", "self", ".", "connect_8", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "dex", ",", "key", "in", "enumerate", "(", "self", ".", "policy_keys", ")", ":", "\n", "                    ", "self", ".", "sub_search", "[", "key", "]", "=", "workspace_graph", ".", "Astar_Graph", "(", "\n", "obs_map", ",", "goals", "[", "dex", "]", ",", "connect_8", "=", "self", ".", "connect_8", ",", "\n", "makespan", "=", "self", ".", "_makespan", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_graph_size": [[213, 218], ["len", "len", "len"], "methods", ["None"], ["", "", "", "", "def", "get_graph_size", "(", "self", ",", "correct_for_size", "=", "True", ")", ":", "\n", "        ", "\"\"\"Returns the number of nodes in the current graph\"\"\"", "\n", "if", "correct_for_size", ":", "\n", "            ", "return", "len", "(", "self", ".", "graph", ")", "*", "len", "(", "self", ".", "rob_id", ")", "\n", "", "return", "len", "(", "self", ".", "graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_memory_useage": [[219, 227], ["od_mstar.Od_Mstar.get_graph_size", "od_mstar.Od_Mstar.sub_search[].get_graph_size"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_graph_size", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_graph_size"], ["", "def", "get_memory_useage", "(", "self", ",", "correct_for_size", "=", "True", ")", ":", "\n", "        ", "\"\"\"Returns the total number of nodes allocated in this planner\n        and any subplanners.\n        \"\"\"", "\n", "temp_sum", "=", "self", ".", "get_graph_size", "(", "correct_for_size", ")", "\n", "for", "i", "in", "self", ".", "sub_search", ":", "\n", "            ", "temp_sum", "+=", "self", ".", "sub_search", "[", "i", "]", ".", "get_graph_size", "(", ")", "\n", "", "return", "temp_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.reset": [[228, 233], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"resets the map for later searches,  does not remove\n        forwards_pointer\n        \"\"\"", "\n", "self", ".", "updated", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.heuristic": [[234, 260], ["sum", "sum", "sum", "od_mstar.Od_Mstar.sub_search[].get_cost", "od_mstar.Od_Mstar.sub_search[].get_cost", "od_mstar.Od_Mstar.sub_search[].get_cost", "enumerate", "enumerate", "enumerate", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["", "def", "heuristic", "(", "self", ",", "coord", ",", "standard_node", ")", ":", "\n", "        ", "\"\"\"Returns the heuristic value of the specified coordinate.\n\n        Does not handle inflation naturally so we can update the\n        heuristic properly\n\n        coord         - coordinate of the node at which to compute the\n                        heuristic\n        standard_node - whether this is a standard node\n        \"\"\"", "\n", "if", "standard_node", ":", "\n", "            ", "cost", "=", "sum", "(", "self", ".", "sub_search", "[", "key", "]", ".", "get_cost", "(", "coord", "[", "dex", "]", ")", "\n", "for", "dex", ",", "key", "in", "enumerate", "(", "self", ".", "policy_keys", ")", ")", "\n", "# return self.inflation * cost", "\n", "return", "cost", "\n", "", "else", ":", "\n", "# Compute heuristic for robots which have moved", "\n", "            ", "cost", "=", "sum", "(", "self", ".", "sub_search", "[", "key", "]", ".", "get_cost", "(", "coord", "[", "MOVE_TUPLE", "]", "[", "dex", "]", ")", "\n", "for", "dex", ",", "key", "in", "enumerate", "(", "\n", "self", ".", "policy_keys", "[", ":", "len", "(", "coord", "[", "MOVE_TUPLE", "]", ")", "]", ")", ")", "\n", "# compute heuristic for robots which have not moved", "\n", "cost", "+=", "sum", "(", "self", ".", "sub_search", "[", "key", "]", ".", "get_cost", "(", "\n", "coord", "[", "POSITION", "]", "[", "dex", "+", "len", "(", "coord", "[", "MOVE_TUPLE", "]", ")", "]", ")", "\n", "for", "dex", ",", "key", "in", "enumerate", "(", "self", ".", "policy_keys", "[", "len", "(", "coord", "[", "\n", "MOVE_TUPLE", "]", ")", ":", "]", ")", ")", "\n", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.pass_through": [[261, 274], ["od_mstar.Od_Mstar.col_checker.cross_over"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.cross_over"], ["", "", "def", "pass_through", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Tests for a collision during transition from coord 1 to coord\n        2.\n\n        coord1, coord2 - joint coordinates of multirobot system\n\n        returns:\n\n        collision set for the edge,  empty list if there are no\n        collisions\n        \"\"\"", "\n", "# return self.col_checker.pass_through(coord1, coord2, self.recursive)", "\n", "return", "self", ".", "col_checker", ".", "cross_over", "(", "coord1", ",", "coord2", ",", "self", ".", "recursive", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.incremental_col_check": [[275, 298], ["od_mstar.Od_Mstar.col_checker.incremental_cross_over", "od_mstar.Od_Mstar.col_checker.incremental_col_check"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.incremental_cross_over", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.incremental_col_check"], ["", "def", "incremental_col_check", "(", "self", ",", "start_coord", ",", "new_coord", ")", ":", "\n", "        ", "\"\"\"Performs an incremental collision check for new coord.\n\n        Assumes that the position of a single new robot has been added to\n        a list of coordinates of robots.  Checks whether adding this new\n        robot will lead to a collision.  Start coord is the joint state\n        before the action being built in new_coord,  and may contain more\n        robots than new_coord. counts on the implementation of the\n        incremental collision checks to be intelligent to avoid issues\n\n        start_coord - coordinate at which the system starts\n        new_coord   - coordinate to which the system moves\n\n        returns:\n\n        collision_set formed form the colliding robots during the move\n        \"\"\"", "\n", "col_set", "=", "self", ".", "col_checker", ".", "incremental_cross_over", "(", "\n", "start_coord", ",", "new_coord", ",", "self", ".", "recursive", ")", "\n", "if", "col_set", ":", "\n", "            ", "return", "col_set", "\n", "", "return", "self", ".", "col_checker", ".", "incremental_col_check", "(", "\n", "new_coord", ",", "self", ".", "recursive", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_node": [[299, 331], ["od_mstar.mstar_node", "od_mstar.Od_Mstar.heuristic", "od_mstar.mstar_node.reset", "od_mstar.Od_Mstar.col_checker.col_check", "od_mstar.Od_Mstar.col_checker.col_check", "len"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.heuristic", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.reset", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.col_check", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.col_check"], ["", "def", "get_node", "(", "self", ",", "coord", ",", "standard_node", ")", ":", "\n", "        ", "\"\"\"Returns the node at the specified coordinates.\n\n        Remember intermediate nodes are of the form\n        (base_coord, move_tuple)\n\n        coord         - coordinates of the node,  potentially an\n                        intermediate node\n        standard_node - whether this is a standard node or an\n                        intermediate node\n        \"\"\"", "\n", "if", "coord", "in", "self", ".", "graph", ":", "\n", "# Node already exists.  reset if necessary", "\n", "            ", "t_node", "=", "self", ".", "graph", "[", "coord", "]", "\n", "t_node", ".", "reset", "(", "self", ".", "updated", ")", "\n", "return", "t_node", "\n", "# Need to instantiate the node", "\n", "", "if", "standard_node", ":", "\n", "            ", "col", "=", "self", ".", "col_checker", ".", "col_check", "(", "coord", ",", "self", ".", "recursive", ")", "\n", "", "else", ":", "\n", "# Only check for collisions between robots whose move has", "\n", "# been determined", "\n", "            ", "col", "=", "self", ".", "col_checker", ".", "col_check", "(", "coord", "[", "MOVE_TUPLE", "]", ",", "self", ".", "recursive", ")", "\n", "", "free", "=", "(", "len", "(", "col", ")", "==", "0", ")", "\n", "t_node", "=", "mstar_node", "(", "coord", ",", "free", ",", "self", ".", "recursive", ",", "standard_node", ")", "\n", "# Cache the resultant col_set", "\n", "t_node", ".", "col_set", "=", "col", "\n", "t_node", ".", "updated", "=", "self", ".", "updated", "\n", "t_node", ".", "h", "=", "self", ".", "heuristic", "(", "coord", ",", "standard_node", ")", "\n", "# Add the node to the graph", "\n", "self", ".", "graph", "[", "coord", "]", "=", "t_node", "\n", "return", "t_node", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_step": [[332, 353], ["od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.get_step", "od_mstar.Od_Mstar.find_path", "od_mstar.Od_Mstar.get_step"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["", "def", "get_step", "(", "self", ",", "init_pos", ",", "standard_node", "=", "True", ")", ":", "\n", "        ", "\"\"\"Get the optimal step from init_pos.\n\n        Computes the entire optimal path if necessary, but preferentially\n        relying on the cached paths stored in mstar_node.forwards_ptr.\n\n        init_pos      - coordinate of the node to compute the step from\n        standard_node - standard_node whether init_pos represents a\n                        standard node\n\n        returns:\n\n        coordinate of the optimal step towards the goal\n        \"\"\"", "\n", "cur_node", "=", "self", ".", "get_node", "(", "init_pos", ",", "standard_node", ")", "\n", "temp", "=", "cur_node", ".", "get_step", "(", ")", "\n", "if", "temp", "is", "not", "None", ":", "\n", "            ", "return", "temp", "\n", "# Use a zero time limit,  so the end time will not be modified", "\n", "", "path", "=", "self", ".", "find_path", "(", "init_pos", ",", "time_limit", "=", "-", "1", ")", "\n", "return", "cur_node", ".", "get_step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.gen_init_nodes": [[354, 371], ["od_mstar.Od_Mstar.get_node"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node"], ["", "def", "gen_init_nodes", "(", "self", ",", "init_pos", ")", ":", "\n", "        ", "\"\"\"Generate the initial search nodes.\n\n        Potentially more than one node is generated, but in practice\n        will usually just one will be generated\n\n        init_pos - initial position\n\n        returns:\n\n        list of initial nodes\n        \"\"\"", "\n", "first", "=", "self", ".", "get_node", "(", "init_pos", ",", "True", ")", "\n", "first", ".", "open", "=", "True", "\n", "first", ".", "cost", "=", "0", "\n", "first", ".", "back_ptr", "=", "first", "\n", "return", "[", "first", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.find_path": [[372, 416], ["od_mstar.Od_Mstar.reset", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.gen_init_nodes", "od_mstar3.SortedCollection.SortedCollection", "od_mstar3.col_set_addition.NoSolutionError", "od_mstar.Od_Mstar.sub_search.values", "len", "od_mstar3.SortedCollection.SortedCollection.consistent_pop", "od_mstar.Od_Mstar.solution_condition", "od_mstar.Od_Mstar.expand", "time.time", "hasattr", "time.time", "od_mstar3.col_set_addition.OutOfTimeError", "node.get_path", "tuple", "time.time"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.reset", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_init_nodes", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.consistent_pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.solution_condition", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.expand", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.get_path"], ["", "def", "find_path", "(", "self", ",", "init_pos", ",", "time_limit", "=", "5", "*", "60", ")", ":", "\n", "        ", "\"\"\"Finds a path from init_pos to the goal specified when self\n        was instantiated.\n\n        init_pos   - ((x1, y1), (x2, y2), ...) coordinates of initial\n                     position\n        time_limit - time allocated to find a solution.  Will raise an\n                     exception if a path cannot be found within this time\n                     period\n        \"\"\"", "\n", "self", ".", "reset", "(", ")", "\n", "if", "time_limit", ">", "0", ":", "\n", "            ", "self", ".", "end_time", "=", "timer", ".", "time", "(", ")", "+", "time_limit", "\n", "# For replanning to work correctly, need to update the end", "\n", "# time for all subplanners.  Otherwise, the end time of the", "\n", "# subplanners will never be updated, so if you make a query", "\n", "# more than the original time_limit seconds after the first", "\n", "# query to this object, you will always get a timeout,", "\n", "# regardless of the time limit used on the second query", "\n", "for", "planner", "in", "self", ".", "sub_search", ".", "values", "(", ")", ":", "\n", "                ", "if", "hasattr", "(", "planner", ",", "'end_time'", ")", ":", "\n", "                    ", "planner", ".", "end_time", "=", "self", ".", "end_time", "\n", "\n", "# Configure the goal node", "\n", "", "", "", "goal_node", "=", "self", ".", "get_node", "(", "self", ".", "goals", ",", "True", ")", "\n", "goal_node", ".", "forwards_ptr", "=", "goal_node", "\n", "# Use the negation of the cost,  so SortedCollection will put the", "\n", "# lowest value item at the right of its internal list", "\n", "init_nodes", "=", "self", ".", "gen_init_nodes", "(", "init_pos", ")", "\n", "open_list", "=", "SortedCollection", ".", "SortedCollection", "(", "init_nodes", ",", "\n", "key", "=", "self", ".", "open_list_key", ")", "\n", "\n", "while", "len", "(", "open_list", ")", ">", "0", ":", "\n", "            ", "if", "timer", ".", "time", "(", ")", ">", "self", ".", "end_time", ":", "\n", "                ", "raise", "OutOfTimeError", "(", "timer", ".", "time", "(", ")", ")", "\n", "", "node", ",", "consistent", "=", "open_list", ".", "consistent_pop", "(", ")", "\n", "if", "not", "consistent", ":", "\n", "                ", "continue", "\n", "", "node", ".", "open", "=", "False", "\n", "if", "self", ".", "solution_condition", "(", "node", ")", ":", "\n", "                ", "path", "=", "node", ".", "get_path", "(", ")", "\n", "return", "tuple", "(", "path", ")", "\n", "", "self", ".", "expand", "(", "node", ",", "open_list", ")", "\n", "", "raise", "NoSolutionError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.solution_condition": [[417, 435], ["None"], "methods", ["None"], ["", "def", "solution_condition", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Checks whether we have finished finding a path when node has\n        been reached\n\n        Checks whether node.forwards_ptr indicates that a path to the\n        goal has been found\n\n        node - node to check for indicating a path to the goal\n\n        returns:\n\n        True if goal has been reached or a cached path to the goal has\n        been reached, else False\n        \"\"\"", "\n", "if", "node", ".", "forwards_ptr", "is", "not", "None", ":", "\n", "            ", "return", "True", "\n", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.expand": [[436, 474], ["od_mstar.Od_Mstar.get_neighbors_recursive", "od_mstar.Od_Mstar.get_neighbors_nonrecursive", "node.back_prop_col_set", "open_list.insert_right", "open_list.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_neighbors_recursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_neighbors_nonrecursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.back_prop_col_set", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert_right", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], ["", "def", "expand", "(", "self", ",", "node", ",", "open_list", ")", ":", "\n", "        ", "\"\"\"Handles the expansion of the given node and the addition of\n        its neighbors to the open list\n\n        node      - node to expand\n        open_list - open list used during the search\n        \"\"\"", "\n", "node", ".", "closed", "=", "True", "\n", "# ASSUMES THAT get_neighbors HANDLES UPDATING NEIGHBOR COST,", "\n", "# AND DOES NOT RETURN NEIGHBORS FOR WHICH THERE IS ALREADY A", "\n", "# PATH AT LEAST AS GOOD", "\n", "if", "self", ".", "recursive", ":", "\n", "            ", "neighbors", ",", "col_set", "=", "self", ".", "get_neighbors_recursive", "(", "node", ")", "\n", "", "else", ":", "\n", "            ", "neighbors", ",", "col_set", "=", "self", ".", "get_neighbors_nonrecursive", "(", "node", ")", "\n", "\n", "# node is the only element in the backpropagation sets of", "\n", "# neighbors that has changed,  so we can backpropagate from here", "\n", "", "old_col_set", "=", "node", ".", "col_set", "\n", "if", "not", "self", ".", "full_space", ":", "\n", "            ", "node", ".", "back_prop_col_set", "(", "col_set", ",", "open_list", ",", "epeastar", "=", "self", ".", "epeastar", ")", "\n", "", "for", "i", "in", "neighbors", ":", "\n", "            ", "i", ".", "back_ptr", "=", "node", "\n", "# Even if the node is already in the open list,  removing if", "\n", "# from its old position (given by the old cost value) is too", "\n", "# expensive, requiring an O(N) operation to delete.  Simply", "\n", "# add the new value and reject the old copy (which will be", "\n", "# marked as closed),  when you come to it", "\n", "i", ".", "open", "=", "True", "\n", "open_list", ".", "insert_right", "(", "i", ")", "\n", "", "if", "self", ".", "epeastar", ":", "\n", "# if running epeastar", "\n", "            ", "if", "old_col_set", "==", "node", ".", "col_set", ":", "\n", "# If the collision set changed,  then adding the node", "\n", "# back to the open list with properly updated collision", "\n", "# set has been handled by the backprop function", "\n", "                ", "node", ".", "offset", "+=", "self", ".", "offset_increment", "\n", "open_list", ".", "insert", "(", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.od_mstar_neighbors": [[475, 570], ["len", "od_mstar.Od_Mstar.sub_search[].get_neighbors", "list", "tuple.append", "tuple", "od_mstar.Od_Mstar.pass_through", "od_mstar3.col_set_addition.col_set_add", "od_mstar.Od_Mstar.od_mstar_transition_cost", "new_neighbors.append", "od_mstar.Od_Mstar.sub_search[].get_step", "len", "od_mstar3.col_set_addition.col_set_add", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.back_prop_set.append", "od_mstar.Od_Mstar.add_col_set", "len"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_mstar_transition_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set"], ["", "", "", "def", "od_mstar_neighbors", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Generates the free neighbors of the given node for the\n        non-recursive case, using operator decomposition\n\n        Also returns the associated collision set due to neighbors\n        which are non-free due to robot-robot collisions.  Only returns\n        nodes which can be most cheaply reached through node\n\n        node - node to determine neighbors\n\n        returns:\n\n        (neighbors, col_set)\n        neighbors - collision free neighbors which can most efficiently\n                    be reached from node\n        col_set   - collision set for neighbors which are not collision\n                    free\n        \"\"\"", "\n", "col_set", "=", "(", ")", "\n", "if", "not", "node", ".", "free", ":", "\n", "# Can't have an out neighbor for a node in collision", "\n", "            ", "return", "col_set", ",", "node", ".", "col_set", "\n", "", "rob_dex", "=", "0", "# Keeps track of the robot to move in this step", "\n", "\n", "# split the coordinates into the start coordinate and the move", "\n", "# list if the node is standard,  doing this so variables are", "\n", "# initialized in  the preferred namespace,  which is probably not", "\n", "# necessary", "\n", "move_list", "=", "(", ")", "\n", "start_coord", "=", "node", ".", "coord", "\n", "if", "not", "node", ".", "standard_node", ":", "\n", "            ", "start_coord", "=", "node", ".", "coord", "[", "POSITION", "]", "\n", "move_list", "=", "node", ".", "coord", "[", "MOVE_TUPLE", "]", "\n", "rob_dex", "=", "len", "(", "node", ".", "coord", "[", "MOVE_TUPLE", "]", ")", "\n", "", "if", "(", "(", "len", "(", "node", ".", "col_set", ")", ">", "0", "and", "rob_dex", "in", "node", ".", "col_set", "[", "0", "]", ")", "or", "\n", "self", ".", "full_space", ")", ":", "\n", "# This robot is in the collision set,  so consider all", "\n", "# possible neighbors", "\n", "            ", "neighbors", "=", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "rob_dex", "]", "]", ".", "get_neighbors", "(", "start_coord", "[", "rob_dex", "]", ")", "\n", "", "else", ":", "\n", "            ", "neighbors", "=", "[", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "rob_dex", "]", "]", ".", "get_step", "(", "\n", "start_coord", "[", "rob_dex", "]", ")", "]", "\n", "# check if this is the last robot to be moved", "\n", "", "filled", "=", "(", "rob_dex", "==", "(", "self", ".", "num_bots", "-", "1", ")", ")", "\n", "\n", "new_neighbors", "=", "[", "]", "\n", "# visualize_holder = []", "\n", "for", "i", "in", "neighbors", ":", "\n", "# Generate the move list with the new robot position", "\n", "            ", "new_moves", "=", "list", "(", "move_list", ")", "\n", "new_moves", ".", "append", "(", "i", ")", "\n", "new_moves", "=", "tuple", "(", "new_moves", ")", "\n", "# Check for collisions in the transition to the new", "\n", "# position, only need to consider the robots in the move list", "\n", "# pass through", "\n", "pass_col", "=", "self", ".", "pass_through", "(", "start_coord", "[", ":", "rob_dex", "+", "1", "]", ",", "new_moves", ")", "\n", "if", "len", "(", "pass_col", ")", ">", "0", ":", "\n", "# Have robot-robot collisions", "\n", "                ", "col_set", "=", "col_set_add", "(", "pass_col", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "continue", "\n", "# Need to branch on whether we have filled the move list", "\n", "", "if", "filled", ":", "\n", "# Generate a standard node.  Static collisions are found", "\n", "# in self.get_node()", "\n", "                ", "new_node", "=", "self", ".", "get_node", "(", "new_moves", ",", "True", ")", "\n", "", "else", ":", "\n", "# Generate an intermediate node", "\n", "                ", "new_node", "=", "self", ".", "get_node", "(", "(", "start_coord", ",", "new_moves", ")", ",", "False", ")", "\n", "", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "                ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "# Always need to add the col_set of any vertex that we can", "\n", "# actually reach,  as otherwise,  we would need to wait for", "\n", "# another robot to collide downstream of the reached vertex", "\n", "# before that vertex would back propagate its col_set", "\n", "", "col_set", "=", "col_set_add", "(", "new_node", ".", "col_set", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "if", "not", "new_node", ".", "free", ":", "\n", "                ", "continue", "\n", "# Skip if closed", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "                ", "continue", "\n", "# Handle costs, which depends soely on the move list,", "\n", "# function to allow for alternate cost functions", "\n", "", "temp_cost", "=", "self", ".", "od_mstar_transition_cost", "(", "start_coord", ",", "node", ".", "cost", ",", "\n", "i", ",", "rob_dex", ")", "\n", "if", "temp_cost", ">=", "new_node", ".", "cost", ":", "\n", "                ", "continue", "\n", "", "new_node", ".", "cost", "=", "temp_cost", "\n", "new_neighbors", ".", "append", "(", "new_node", ")", "\n", "# Set the intermediate nod's col_set equal to its parent,", "\n", "# so later elements will actually be explored.  Not", "\n", "# technically required but will cut back on thrashing", "\n", "if", "not", "new_node", ".", "standard_node", ":", "\n", "                ", "new_node", ".", "add_col_set", "(", "node", ".", "col_set", ")", "\n", "", "", "return", "new_neighbors", ",", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.od_mstar_transition_cost": [[571, 588], ["od_mstar.Od_Mstar.sub_search[].get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "od_mstar_transition_cost", "(", "self", ",", "start_coord", ",", "prev_cost", ",", "neighbor", ",", "\n", "rob_dex", ")", ":", "\n", "        ", "\"\"\"Computes the transition cost for a single robot in od_mstar\n        neighbor generation\n\n        start_coord - base position of robots (prior to move assignment)\n        prev_cost   - cost of base node\n        neighbor    - proposed move assignmetn\n        rob_dex     - robot move is assigned to\n\n        returns:\n\n        cost of a single robot transitioning state\n        \"\"\"", "\n", "prev_cost", "+=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "rob_dex", "]", "]", ".", "get_edge_cost", "(", "\n", "start_coord", "[", "rob_dex", "]", ",", "neighbor", ")", "\n", "return", "prev_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.gen_epeastar_coords": [[589, 663], ["range", "len", "tuple", "od_mstar.Od_Mstar.pass_through", "od_mstar.Od_Mstar.col_checker.col_check", "len", "enumerate", "neighbors.extend", "od_mstar.Od_Mstar.sub_search[].get_offsets", "od_mstar.Od_Mstar.sub_search[].get_step", "od_mstar.Od_Mstar.sub_search[].get_offset_neighbors", "range", "od_mstar.Od_Mstar.incremental_col_check", "new_list.append", "new_list.append", "new_list.append", "od_mstar.Od_Mstar.sub_search[].get_step", "adder"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.col_check", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_offsets", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_offset_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.incremental_col_check", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["", "def", "gen_epeastar_coords", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Helper function for generating neighbors of a node using EPEA*\n\n        Uses a two step process. First the incremental costs are\n        computed, then the neighbors fitting those incremental costs.\n        More directly matches what was done in the EPEA* paper.  Performs\n        incremental collision checking during the generation of\n        neighbors,  to prune out as many invalid nodes as early as\n        possible\n\n        node - node for which to generate neighbors\n        \"\"\"", "\n", "adder", "=", "add_col_set", "\n", "if", "self", ".", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "offset", "=", "node", ".", "offset", "\n", "coord", "=", "node", ".", "coord", "\n", "if", "len", "(", "node", ".", "col_set", ")", "==", "0", ":", "\n", "# have empty collision set", "\n", "            ", "new_coord", "=", "tuple", "(", "\n", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_step", "(", "\n", "coord", "[", "dex", "]", ")", "for", "dex", "in", "range", "(", "self", ".", "num_bots", ")", ")", "\n", "pass_col", "=", "self", ".", "pass_through", "(", "coord", ",", "new_coord", ")", "\n", "if", "pass_col", ":", "\n", "                ", "return", "[", "]", ",", "pass_col", "\n", "", "col", "=", "self", ".", "col_checker", ".", "col_check", "(", "new_coord", ",", "self", ".", "recursive", ")", "\n", "if", "col", ":", "\n", "                ", "return", "[", "]", ",", "col", "\n", "", "return", "[", "new_coord", "]", ",", "[", "]", "\n", "", "search_list", "=", "[", "(", "0", ",", "(", ")", ")", "]", "\n", "assert", "len", "(", "node", ".", "col_set", ")", "==", "1", "\n", "node_col", "=", "node", ".", "col_set", "[", "0", "]", "\n", "for", "rob_dex", "in", "range", "(", "self", ".", "num_bots", ")", ":", "\n", "            ", "if", "rob_dex", "in", "node_col", ":", "\n", "                ", "offsets", "=", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "rob_dex", "]", "]", ".", "get_offsets", "(", "coord", "[", "rob_dex", "]", ")", "\n", "", "else", ":", "\n", "                ", "offsets", "=", "(", "0", ",", ")", "\n", "", "new_list", "=", "[", "]", "\n", "for", "cost", ",", "pos", "in", "search_list", ":", "\n", "                ", "for", "off", "in", "offsets", ":", "\n", "                    ", "if", "rob_dex", "<", "self", ".", "num_bots", "-", "1", ":", "\n", "                        ", "if", "off", "+", "cost", "<=", "offset", ":", "\n", "                            ", "new_list", ".", "append", "(", "(", "off", "+", "cost", ",", "pos", "+", "(", "off", ",", ")", ")", ")", "\n", "", "", "elif", "off", "+", "cost", "==", "offset", ":", "\n", "# For the last robot,  only want to keep costs which", "\n", "# match perfectly", "\n", "                        ", "new_list", ".", "append", "(", "(", "off", "+", "cost", ",", "pos", "+", "(", "off", ",", ")", ")", ")", "\n", "", "", "search_list", "=", "new_list", "\n", "", "", "neighbors", "=", "[", "]", "\n", "col_set", "=", "[", "]", "\n", "for", "offset", ",", "costs", "in", "search_list", ":", "\n", "            ", "gen_list", "=", "[", "(", ")", "]", "\n", "for", "dex", ",", "c", "in", "enumerate", "(", "costs", ")", ":", "\n", "                ", "if", "dex", "in", "node_col", ":", "\n", "                    ", "neib", "=", "(", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_offset_neighbors", "(", "\n", "coord", "[", "dex", "]", ",", "c", ")", ")", "\n", "", "else", ":", "\n", "                    ", "neib", "=", "(", "(", "0", ",", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_step", "(", "coord", "[", "dex", "]", ")", ")", ",", ")", "\n", "", "new_list", "=", "[", "]", "\n", "for", "_", ",", "n", "in", "neib", ":", "\n", "                    ", "for", "old", "in", "gen_list", ":", "\n", "                        ", "new_coord", "=", "old", "+", "(", "n", ",", ")", "\n", "# Perform collision checking", "\n", "tcol", "=", "self", ".", "incremental_col_check", "(", "coord", ",", "new_coord", ")", "\n", "if", "tcol", ":", "\n", "                            ", "col_set", "=", "adder", "(", "col_set", ",", "tcol", ")", "\n", "continue", "\n", "", "new_list", ".", "append", "(", "new_coord", ")", "\n", "", "", "gen_list", "=", "new_list", "\n", "", "neighbors", ".", "extend", "(", "gen_list", ")", "\n", "", "return", "neighbors", ",", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_epeastar_neighbors": [[664, 702], ["od_mstar.Od_Mstar.gen_epeastar_coords", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.epeastar_transition_cost", "od_mstar.Od_Mstar.back_prop_set.append", "neighbors.append"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_epeastar_coords", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.epeastar_transition_cost"], ["", "def", "get_epeastar_neighbors", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Generates the free neighbors of the given node for the\n        non-recursive case.\n\n        Also returns the associated collision set due to neighbors\n        which are non-free due to robot-robot collisions.  Only returns\n        nodes which can be most cheaply reached through node\n\n        node - node to be expanded\n\n        returns:\n        (neighbors, col_set)\n        neighbors - neighbors that can most be efficiently reached from\n                    node, that are collision free\n        col_set   - collisions incurred when trying to reach\n                    non-collision free nodes\n        \"\"\"", "\n", "if", "not", "node", ".", "free", ":", "\n", "# Can't have an out neighbor for a node in collision", "\n", "            ", "return", "[", "]", ",", "node", ".", "col_set", "\n", "", "start_coord", "=", "node", ".", "coord", "\n", "neighbor_coords", ",", "col_set", "=", "self", ".", "gen_epeastar_coords", "(", "node", ")", "\n", "neighbors", "=", "[", "]", "\n", "for", "i", "in", "neighbor_coords", ":", "\n", "            ", "new_node", "=", "self", ".", "get_node", "(", "i", ",", "True", ")", "\n", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "                ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "", "if", "not", "new_node", ".", "free", ":", "\n", "                ", "continue", "\n", "# update costs", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "t_cost", "=", "self", ".", "epeastar_transition_cost", "(", "start_coord", ",", "node", ".", "cost", ",", "i", ")", "\n", "if", "t_cost", "<", "new_node", ".", "cost", ":", "\n", "                ", "new_node", ".", "cost", "=", "t_cost", "\n", "new_node", ".", "back_ptr", "=", "node", "\n", "neighbors", ".", "append", "(", "new_node", ")", "\n", "", "", "return", "neighbors", ",", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.epeastar_transition_cost": [[703, 715], ["enumerate", "zip", "od_mstar.Od_Mstar.sub_search[].get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "epeastar_transition_cost", "(", "self", ",", "start_coord", ",", "prev_cost", ",", "new_coord", ")", ":", "\n", "        ", "\"\"\"Computes the cost of a new node at the specified coordinates,\n        starting from the given position and cost\n\n        start_coord - node at which the system starts\n        prev_cost   - cost of the node at start_coord\n        new_coord   - destination node\n        \"\"\"", "\n", "for", "dex", ",", "(", "source", ",", "target", ")", "in", "enumerate", "(", "zip", "(", "start_coord", ",", "new_coord", ")", ")", ":", "\n", "            ", "prev_cost", "+=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_edge_cost", "(", "\n", "source", ",", "target", ")", "\n", "", "return", "prev_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_neighbors_nonrecursive": [[716, 728], ["od_mstar.Od_Mstar.od_mstar_neighbors", "od_mstar.Od_Mstar.get_astar_neighbors", "od_mstar.Od_Mstar.get_epeastar_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_mstar_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_astar_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_epeastar_neighbors"], ["", "def", "get_neighbors_nonrecursive", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Generates neighbors using a non-recursive method.  Note that\n        collision sets will still be generated in the style specified by\n        self.recursive\n\n        node - node for which to generate neighbors\n        \"\"\"", "\n", "if", "self", ".", "astar", ":", "\n", "            ", "return", "self", ".", "get_astar_neighbors", "(", "node", ")", "\n", "", "elif", "self", ".", "epeastar", ":", "\n", "            ", "return", "self", ".", "get_epeastar_neighbors", "(", "node", ")", "\n", "", "return", "self", ".", "od_mstar_neighbors", "(", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.create_sub_search": [[729, 747], ["od_mstar.Od_Mstar"], "methods", ["None"], ["", "def", "create_sub_search", "(", "self", ",", "new_goals", ",", "rob_id", ")", ":", "\n", "        ", "\"\"\"Creates a new instance of a subsearch for recursive search\n\n        new_goals - goals for the subset of the robots\n        rob_ids   - ids of the robots involved in the subsearch\n\n        returns:\n\n        new OD_Mstar instance to perform search for the specified subset\n        of robots\"\"\"", "\n", "return", "Od_Mstar", "(", "self", ".", "obs_map", ",", "new_goals", ",", "self", ".", "recursive", ",", "\n", "sub_search", "=", "self", ".", "sub_search", ",", "\n", "col_checker", "=", "self", ".", "col_checker", ",", "rob_id", "=", "rob_id", ",", "\n", "inflation", "=", "self", ".", "inflation", ",", "\n", "end_time", "=", "self", ".", "end_time", ",", "connect_8", "=", "self", ".", "connect_8", ",", "\n", "astar", "=", "self", ".", "astar", ",", "full_space", "=", "self", ".", "full_space", ",", "\n", "epeastar", "=", "self", ".", "epeastar", ",", "makespan", "=", "self", ".", "_makespan", ",", "\n", "col_set_memory", "=", "self", ".", "_col_set_memory", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_subplanner_keys": [[748, 768], ["list", "enumerate", "map", "tuple", "od_mstar.Od_Mstar.create_sub_search", "tuple", "map"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.create_sub_search"], ["", "def", "get_subplanner_keys", "(", "self", ",", "col_set", ")", ":", "\n", "        ", "\"\"\"Returns keys to subplanners required for planning for some\n        subset of robots.\n\n        col_set - collision set to be solved\n\n        returns:\n\n        keys for the necessary subplanners in self.sub_search\n        \"\"\"", "\n", "# Convert the collision sets into the global indicies,  and", "\n", "# convert to tuples.  Assumes self.rob_id is sorted", "\n", "global_col", "=", "list", "(", "map", "(", "lambda", "y", ":", "tuple", "(", "map", "(", "lambda", "x", ":", "self", ".", "rob_id", "[", "x", "]", ",", "y", ")", ")", ",", "\n", "col_set", ")", ")", "\n", "# generate the sub planners,  if necessary", "\n", "for", "dex", ",", "gc", "in", "enumerate", "(", "global_col", ")", ":", "\n", "            ", "if", "gc", "not", "in", "self", ".", "sub_search", ":", "\n", "                ", "t_goals", "=", "tuple", "(", "[", "self", ".", "goals", "[", "k", "]", "for", "k", "in", "col_set", "[", "dex", "]", "]", ")", "\n", "self", ".", "sub_search", "[", "gc", "]", "=", "self", ".", "create_sub_search", "(", "t_goals", ",", "gc", ")", "\n", "", "", "return", "global_col", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_neighbors_recursive": [[769, 855], ["od_mstar.Od_Mstar.get_subplanner_keys", "range", "tuple", "od_mstar.Od_Mstar.pass_through", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.od_rmstar_transition_cost", "od_mstar3.col_set_addition.effective_col_set", "list", "list", "od_mstar.Od_Mstar.get_neighbors_nonrecursive", "od_mstar.Od_Mstar.sub_search[].get_step", "len", "range", "len", "od_mstar.Od_Mstar.back_prop_set.append", "od_mstar.Od_Mstar.get_node", "map", "map", "len", "len", "range", "od_mstar.Od_Mstar.sub_search[].get_step", "len", "tuple"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_subplanner_keys", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_rmstar_transition_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.effective_col_set", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_neighbors_nonrecursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["", "def", "get_neighbors_recursive", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Get the neighbors of node for recursive M*.\n\n        Uses operator decomposition style expansion when necessary,  may\n        fail when called on an intermediate node\n\n        node - node for which to generate neighbors\n\n\n        returns:\n        (neighbors, col_set)\n        neighbors - list of coordinates for neighboring, reachable\n                    nodes\n        col_set   - collisions generated by trying to transition to\n                    non-reachable neighbors\n        \"\"\"", "\n", "# Handle collision set memory if necessary", "\n", "# use_memory = False", "\n", "if", "self", ".", "_col_set_memory", ":", "\n", "            ", "col_set", "=", "effective_col_set", "(", "node", ".", "col_set", ",", "node", ".", "prev_col_set", ")", "\n", "effective_set", "=", "col_set", "\n", "# if set(col_set) != set(node.col_set):", "\n", "#     # using memory", "\n", "#     use_memory = True", "\n", "# Sort the collision set,  which also converts them into", "\n", "# lists", "\n", "col_set", "=", "list", "(", "map", "(", "sorted", ",", "col_set", ")", ")", "\n", "", "else", ":", "\n", "# Sort the collision set,  which also converts them into lists", "\n", "            ", "col_set", "=", "list", "(", "map", "(", "sorted", ",", "node", ".", "col_set", ")", ")", "\n", "# Use standard operator decomposition,  if appropriate", "\n", "", "if", "len", "(", "col_set", ")", "==", "1", "and", "len", "(", "col_set", "[", "0", "]", ")", "==", "self", ".", "num_bots", ":", "\n", "# At base of recursion case", "\n", "            ", "return", "self", ".", "get_neighbors_nonrecursive", "(", "node", ")", "\n", "", "start_coord", "=", "node", ".", "coord", "\n", "if", "not", "node", ".", "standard_node", ":", "\n", "            ", "assert", "False", "\n", "# Generate subplanners for new coupled groups of robots and get", "\n", "# their sub_search keys", "\n", "", "coupled_keys", "=", "self", ".", "get_subplanner_keys", "(", "col_set", ")", "\n", "# Generate the individually optimal step", "\n", "new_coord", "=", "[", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "i", "]", "]", ".", "get_step", "(", "\n", "start_coord", "[", "i", "]", ")", "for", "i", "in", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "# Iterate over the colliding sets of robots,  and integrate the", "\n", "# results of the sup planning for each set", "\n", "for", "i", "in", "range", "(", "len", "(", "col_set", ")", ")", ":", "\n", "# if use_memory and frozenset(col_set[i]) in node.prev_col_set:", "\n", "# assert self.sub_search[", "\n", "#     coupled_keys[i]].graph[", "\n", "#         tuple([start_coord[j]", "\n", "#                for j in col_set[i]])].forwards_ptr != None", "\n", "            ", "try", ":", "\n", "                ", "new_step", "=", "self", ".", "sub_search", "[", "coupled_keys", "[", "i", "]", "]", ".", "get_step", "(", "\n", "tuple", "(", "[", "start_coord", "[", "j", "]", "for", "j", "in", "col_set", "[", "i", "]", "]", ")", ")", "\n", "", "except", "NoSolutionError", ":", "\n", "# Can't get to the goal from here", "\n", "                ", "return", "[", "]", ",", "[", "]", "\n", "# Copy the step into position", "\n", "", "for", "j", "in", "range", "(", "len", "(", "col_set", "[", "i", "]", ")", ")", ":", "\n", "                ", "new_coord", "[", "col_set", "[", "i", "]", "[", "j", "]", "]", "=", "new_step", "[", "j", "]", "\n", "\n", "", "", "new_coord", "=", "tuple", "(", "new_coord", ")", "\n", "# process the neighbor", "\n", "pass_col", "=", "self", ".", "pass_through", "(", "start_coord", ",", "new_coord", ")", "\n", "if", "len", "(", "pass_col", ")", ">", "0", ":", "\n", "# Have collisions before reaching node", "\n", "            ", "return", "[", "]", ",", "pass_col", "\n", "", "new_node", "=", "self", ".", "get_node", "(", "new_coord", ",", "True", ")", "\n", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "            ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "", "if", "not", "new_node", ".", "free", ":", "\n", "            ", "return", "[", "]", ",", "new_node", ".", "col_set", "\n", "# Skip if closed", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "            ", "return", "[", "]", ",", "new_node", ".", "col_set", "\n", "# Compute the costs. THIS MAY NOT WORK IF node IS AN INTERMEDIATE", "\n", "# NODE", "\n", "", "t_cost", "=", "self", ".", "get_node", "(", "start_coord", ",", "True", ")", ".", "cost", "\n", "t_cost", "=", "self", ".", "od_rmstar_transition_cost", "(", "start_coord", ",", "t_cost", ",", "\n", "new_node", ".", "coord", ")", "\n", "if", "t_cost", "<", "new_node", ".", "cost", ":", "\n", "            ", "new_node", ".", "cost", "=", "t_cost", "\n", "if", "self", ".", "_col_set_memory", ":", "\n", "                ", "new_node", ".", "prev_col_set", "=", "effective_set", "\n", "", "return", "[", "new_node", "]", ",", "new_node", ".", "col_set", "\n", "", "return", "[", "]", ",", "new_node", ".", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.od_rmstar_transition_cost": [[856, 872], ["enumerate", "zip", "od_mstar.Od_Mstar.sub_search[].get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "od_rmstar_transition_cost", "(", "self", ",", "start_coord", ",", "prev_cost", ",", "new_coord", ")", ":", "\n", "        ", "\"\"\"Computes the transition cost for a single robot in od_rmstar\n        neighbor generation\n\n        start_coord - base position of robots (prior to move assignment)\n        prev_cost   - cost of base node\n        new_coord    - proposed move assignmetn\n\n        returns:\n\n        total cost of reaching new_coord via start_coord\n        \"\"\"", "\n", "for", "dex", ",", "(", "source", ",", "target", ")", "in", "enumerate", "(", "zip", "(", "start_coord", ",", "new_coord", ")", ")", ":", "\n", "            ", "prev_cost", "+=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_edge_cost", "(", "\n", "source", ",", "target", ")", "\n", "", "return", "prev_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.alt_get_astar_neighbors": [[873, 935], ["list", "od_mstar.Od_Mstar.sub_search[].get_step", "len", "map", "od_mstar.Od_Mstar.pass_through", "od_mstar.Od_Mstar.get_node", "od_mstar3.col_set_addition.col_set_add", "range", "range", "range", "od_mstar.Od_Mstar.sub_search[].get_neighbors", "len", "od_mstar3.col_set_addition.col_set_add", "od_mstar.Od_Mstar.back_prop_set.append", "len", "od_mstar.Od_Mstar.sub_search[].get_edge_cost", "od_mstar.Od_Mstar.append", "new_coords.append"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "alt_get_astar_neighbors", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Gets neighbors of a specified node using the standard A*\n        approach.\n\n\n        assumes working with standard nodes\n\n        node - node for which to generate neighbors\n\n        returns:\n        (neighbors, col_set)\n        neighbors - coordinates of collision free neighboring nodes\n        col_set   - collisions resulting from trying to reach\n                    non-collision free neighbors\n        \"\"\"", "\n", "start_coord", "=", "node", ".", "coord", "\n", "# Generate the individually optimal setp", "\n", "base_coord", "=", "[", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "i", "]", "]", ".", "get_step", "(", "\n", "start_coord", "[", "i", "]", ")", "for", "i", "in", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "old_coords", "=", "[", "base_coord", "]", "\n", "assert", "len", "(", "node", ".", "col_set", ")", "<=", "1", "\n", "to_explore", "=", "node", ".", "col_set", "\n", "if", "self", ".", "full_space", ":", "\n", "            ", "to_explore", "=", "[", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "", "for", "i", "in", "to_explore", ":", "\n", "            ", "for", "bot", "in", "i", ":", "\n", "                ", "new_coords", "=", "[", "]", "\n", "neighbors", "=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "bot", "]", "]", ".", "get_neighbors", "(", "start_coord", "[", "bot", "]", ")", "\n", "for", "neigh", "in", "neighbors", ":", "\n", "                    ", "for", "k", "in", "old_coords", ":", "\n", "                        ", "temp", "=", "k", "[", ":", "]", "\n", "temp", "[", "bot", "]", "=", "neigh", "\n", "new_coords", ".", "append", "(", "temp", ")", "\n", "", "", "old_coords", "=", "new_coords", "\n", "", "", "col_set", "=", "[", "]", "\n", "neighbors", "=", "[", "]", "\n", "old_coords", "=", "list", "(", "map", "(", "tuple", ",", "old_coords", ")", ")", "\n", "for", "i", "in", "old_coords", ":", "\n", "# Check if we can get there", "\n", "            ", "pass_col", "=", "self", ".", "pass_through", "(", "start_coord", ",", "i", ")", "\n", "if", "len", "(", "pass_col", ")", ">", "0", ":", "\n", "                ", "col_set", "=", "col_set_add", "(", "pass_col", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "continue", "\n", "", "new_node", "=", "self", ".", "get_node", "(", "i", ",", "True", ")", "\n", "col_set", "=", "col_set_add", "(", "new_node", ".", "col_set", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "                ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "", "if", "not", "new_node", ".", "free", ":", "\n", "                ", "continue", "\n", "# update costs", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "t_cost", "=", "node", ".", "cost", "\n", "for", "j", "in", "range", "(", "len", "(", "start_coord", ")", ")", ":", "\n", "                ", "t_cost", "+=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "j", "]", "]", ".", "get_edge_cost", "(", "\n", "start_coord", "[", "i", "]", ",", "new_node", ".", "coord", "[", "j", "]", ")", "\n", "", "if", "t_cost", "<", "new_node", ".", "cost", ":", "\n", "                ", "new_node", ".", "cost", "=", "t_cost", "\n", "new_node", ".", "back_ptr", "=", "node", "\n", "neighbors", ".", "append", "(", "new_node", ")", "\n", "", "", "return", "neighbors", ",", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.Od_Mstar.get_astar_neighbors": [[936, 1005], ["list", "od_mstar.Od_Mstar.sub_search[].get_step", "len", "map", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.pass_through", "od_mstar.Od_Mstar.get_node", "od_mstar3.col_set_addition.col_set_add", "range", "range", "od_mstar.Od_Mstar.sub_search[].get_neighbors", "range", "len", "od_mstar3.col_set_addition.col_set_add", "od_mstar.Od_Mstar.back_prop_set.append", "od_mstar.Od_Mstar.append", "len", "od_mstar.Od_Mstar.sub_search[].get_edge_cost", "new_coords.append"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "get_astar_neighbors", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Gets neighbors of a specified node using the standard A*\n        approach,\n\n        assumes working with standard nodes\n\n        node - node for which to generate neighbors\n\n        returns:\n        (neighbors, col_set)\n        neighbors - coordinates of collision free neighboring nodes\n        col_set   - collisions resulting from trying to reach\n                    non-collision free neighbors\n        \"\"\"", "\n", "start_coord", "=", "node", ".", "coord", "\n", "# Generate the individually optimal setp", "\n", "base_coord", "=", "[", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "i", "]", "]", ".", "get_step", "(", "\n", "start_coord", "[", "i", "]", ")", "for", "i", "in", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "old_coords", "=", "[", "base_coord", "]", "\n", "assert", "len", "(", "node", ".", "col_set", ")", "<=", "1", "\n", "to_explore", "=", "node", ".", "col_set", "\n", "if", "self", ".", "full_space", ":", "\n", "            ", "to_explore", "=", "[", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "", "for", "i", "in", "to_explore", ":", "\n", "            ", "for", "bot", "in", "i", ":", "\n", "                ", "new_coords", "=", "[", "]", "\n", "neighbors", "=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "bot", "]", "]", ".", "get_neighbors", "(", "start_coord", "[", "bot", "]", ")", "\n", "for", "neigh", "in", "neighbors", ":", "\n", "                    ", "for", "k", "in", "old_coords", ":", "\n", "                        ", "temp", "=", "k", "[", ":", "]", "\n", "temp", "[", "bot", "]", "=", "neigh", "\n", "new_coords", ".", "append", "(", "temp", ")", "\n", "", "", "old_coords", "=", "new_coords", "\n", "", "", "col_set", "=", "[", "]", "\n", "neighbors", "=", "[", "]", "\n", "old_coords", "=", "list", "(", "map", "(", "tuple", ",", "old_coords", ")", ")", "\n", "for", "i", "in", "old_coords", ":", "\n", "# First check if this path is relevant.  I.e. if there is already a", "\n", "# better path to the node,  then the search will never try to use", "\n", "# that route,  so we don't need to consider collisions", "\n", "            ", "new_node", "=", "self", ".", "get_node", "(", "i", ",", "True", ")", "\n", "if", "node", ".", "free", ":", "\n", "                ", "t_cost", "=", "node", ".", "cost", "\n", "for", "j", "in", "range", "(", "len", "(", "start_coord", ")", ")", ":", "\n", "                    ", "t_cost", "+=", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "j", "]", "]", ".", "get_edge_cost", "(", "start_coord", "[", "j", "]", ",", "\n", "i", "[", "j", "]", ")", "\n", "", "if", "t_cost", ">=", "new_node", ".", "cost", ":", "\n", "                    ", "continue", "\n", "# Check if we can get there", "\n", "", "", "pass_col", "=", "self", ".", "pass_through", "(", "start_coord", ",", "i", ")", "\n", "if", "len", "(", "pass_col", ")", ">", "0", ":", "\n", "                ", "col_set", "=", "col_set_add", "(", "pass_col", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "continue", "\n", "", "new_node", "=", "self", ".", "get_node", "(", "i", ",", "True", ")", "\n", "col_set", "=", "col_set_add", "(", "new_node", ".", "col_set", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "                ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "", "if", "not", "new_node", ".", "free", ":", "\n", "                ", "continue", "\n", "# update costs", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "if", "t_cost", "<", "new_node", ".", "cost", ":", "\n", "                ", "new_node", ".", "cost", "=", "t_cost", "\n", "new_node", ".", "back_ptr", "=", "node", "\n", "neighbors", ".", "append", "(", "new_node", ")", "\n", "", "", "return", "neighbors", ",", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.mstar_node.__init__": [[1020, 1075], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "coord", ",", "free", ",", "recursive", ",", "standard_node", ",", "back_ptr", "=", "None", ",", "\n", "forwards_ptr", "=", "None", ")", ":", "\n", "        ", "\"\"\"Constructor for mstar_node\n\n        Assumes the col_set is empty by default\n\n        coord         - tuple giving coordinates,  may store partial\n                        moves if not standard node\n        free          - part of the free configuration space\n        standard_node - represents a standard node,  and not a partial\n                        move\n        back_ptr      - pointer to best node to get to self\n        forwards_ptr  - pointer along the best path to the goal\n        \"\"\"", "\n", "self", ".", "free", "=", "free", "\n", "self", ".", "coord", "=", "coord", "\n", "self", ".", "updated", "=", "-", "1", "\n", "# Whether already in the open list", "\n", "self", ".", "open", "=", "False", "\n", "\n", "# Whether this has been expanded.  Note that a node can be added", "\n", "# back to the open list after it has been expanded,  but will", "\n", "# still be marked as closed.  It cannot have its cost changed,", "\n", "# but it can add neighbors, but not be added as a neighbor", "\n", "self", ".", "closed", "=", "False", "\n", "self", ".", "standard_node", "=", "standard_node", "\n", "# Heuristic cost to go,  None to ensure it will be properly", "\n", "# calculated", "\n", "self", ".", "h", "=", "None", "\n", "# Cost to reach", "\n", "self", ".", "cost", "=", "MAX_COST", "\n", "\n", "# Optimal way to reach this node.  Point to self to indicate the", "\n", "# initial position", "\n", "self", ".", "back_ptr", "=", "back_ptr", "\n", "self", ".", "back_prop_set", "=", "[", "]", "# Ways found to reach this node", "\n", "self", ".", "col_set", "=", "(", ")", "\n", "# store the collision set of back_ptr when the path from", "\n", "# back_ptr to self was first found.  Used for hopefully more", "\n", "# efficient cached path access", "\n", "self", ".", "prev_col_set", "=", "(", ")", "\n", "self", ".", "recursive", "=", "recursive", "\n", "\n", "# Keeps track of solutions that have already been found,", "\n", "# replace forwards_tree.  Denote the goal node by pointing", "\n", "# forwards_ptr", "\n", "# to itself", "\n", "self", ".", "forwards_ptr", "=", "forwards_ptr", "\n", "self", ".", "assignment", "=", "None", "# Used for multiassignment mstar", "\n", "\n", "# Used to track whether new assignments need to be generated for", "\n", "# MURTY  mstar", "\n", "self", ".", "colset_changed", "=", "False", "\n", "# Tracks current offset for multiple re-expansion a la EPEA*", "\n", "self", ".", "offset", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.mstar_node.reset": [[1076, 1086], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ",", "t", ")", ":", "\n", "        ", "\"\"\"Resets if t > last update time\"\"\"", "\n", "if", "t", ">", "self", ".", "updated", ":", "\n", "            ", "self", ".", "updated", "=", "t", "\n", "self", ".", "open", "=", "False", "\n", "self", ".", "closed", "=", "False", "\n", "self", ".", "cost", "=", "MAX_COST", "\n", "self", ".", "back_ptr", "=", "None", "\n", "self", ".", "back_prop_set", "=", "[", "]", "\n", "self", ".", "offset", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.mstar_node.get_path": [[1087, 1094], ["od_mstar.mstar_node.backtrack_path", "od_mstar.mstar_node.forwards_extend_path"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.backtrack_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.forwards_extend_path"], ["", "", "def", "get_path", "(", "self", ")", ":", "\n", "        ", "\"\"\"Gets the path passing through path to the goal,  assumes that\n        self is either the goal node,  or a node connected to the goal\n        node through forwards_pointers\n        \"\"\"", "\n", "path", "=", "self", ".", "backtrack_path", "(", ")", "\n", "return", "self", ".", "forwards_extend_path", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.mstar_node.backtrack_path": [[1095, 1124], ["od_mstar.mstar_node.back_ptr.backtrack_path", "isinstance", "path.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.backtrack_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], ["", "def", "backtrack_path", "(", "self", ",", "path", "=", "None", ",", "prev", "=", "None", ")", ":", "\n", "        ", "\"\"\"Finds the path that leads up to this node,  updating\n        forwards_ptr so that we can recover this path quickly,  only\n        returns standard nodes\n\n        path - current reconstructed path for use in recusion, must\n               start as None\n        prev - pointer to the last node visited by backtrack_path, used\n               to update forwards_ptr to record the best paths to the\n               goal\n        \"\"\"", "\n", "if", "path", "is", "None", ":", "\n", "            ", "path", "=", "[", "]", "\n", "", "if", "prev", "is", "not", "None", ":", "\n", "            ", "self", ".", "forwards_ptr", "=", "prev", "\n", "if", "isinstance", "(", "self", ".", "h", ",", "tuple", ")", ":", "\n", "# Needed for constrained od_mstar,  and don't feel like", "\n", "# coming up with a better solution for now", "\n", "                ", "self", ".", "h", "=", "(", "prev", ".", "h", "[", "0", "]", "+", "prev", ".", "cost", "[", "0", "]", "-", "self", ".", "cost", "[", "0", "]", ",", "self", ".", "h", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "h", "=", "prev", ".", "h", "+", "(", "prev", ".", "cost", "-", "self", ".", "cost", ")", "\n", "", "", "if", "self", ".", "standard_node", ":", "\n", "            ", "assert", "self", ".", "coord", "not", "in", "path", "\n", "path", ".", "insert", "(", "0", ",", "self", ".", "coord", ")", "\n", "", "if", "self", ".", "back_ptr", "==", "self", ":", "\n", "# Done so that it cannot terminate on a node that wasn't", "\n", "# properly initialized", "\n", "            ", "return", "path", "\n", "", "return", "self", ".", "back_ptr", ".", "backtrack_path", "(", "path", ",", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.mstar_node.forwards_extend_path": [[1125, 1137], ["od_mstar.mstar_node.forwards_ptr.forwards_extend_path", "path.append"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.forwards_extend_path"], ["", "def", "forwards_extend_path", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"Extends the path from self to the goal node,  following\n        forwards pointers,  only includes standard nodes\n\n        path - current path to extend towards the goal, as list of joint\n               configuration space coordinates\n        \"\"\"", "\n", "if", "self", ".", "forwards_ptr", "==", "self", ":", "\n", "            ", "return", "path", "\n", "", "if", "self", ".", "forwards_ptr", ".", "standard_node", ":", "\n", "            ", "path", ".", "append", "(", "self", ".", "forwards_ptr", ".", "coord", ")", "\n", "", "return", "self", ".", "forwards_ptr", ".", "forwards_extend_path", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.mstar_node.add_col_set": [[1138, 1158], ["len", "od_mstar3.col_set_addition.add_col_set_recursive", "od_mstar3.col_set_addition.add_col_set"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.add_col_set_recursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set"], ["", "def", "add_col_set", "(", "self", ",", "c", ")", ":", "\n", "        ", "\"\"\"Adds the contents of c to self.col_set.\n\n        c - collision set to add to the current node's collision set\n\n        returns:\n\n        True if modifications were made, else False\n        \"\"\"", "\n", "if", "len", "(", "c", ")", "==", "0", ":", "\n", "            ", "return", "False", "\n", "", "if", "self", ".", "recursive", ":", "\n", "            ", "temp", "=", "add_col_set_recursive", "(", "c", ",", "self", ".", "col_set", ")", "\n", "", "else", ":", "\n", "            ", "temp", "=", "add_col_set", "(", "c", ",", "self", ".", "col_set", ")", "\n", "", "modified", "=", "(", "temp", "!=", "self", ".", "col_set", ")", "\n", "if", "modified", ":", "\n", "            ", "self", ".", "col_set", "=", "temp", "\n", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.mstar_node.back_prop_col_set": [[1159, 1189], ["od_mstar.mstar_node.add_col_set", "open_list.insert", "j.back_prop_col_set", "open_list.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.back_prop_col_set", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], ["", "def", "back_prop_col_set", "(", "self", ",", "new_col", ",", "open_list", ",", "epeastar", "=", "False", ")", ":", "\n", "        ", "\"\"\"Propagates the collision dependencies found by its children\n        to the parent,  which adds any new dependencies to this col_set\n\n        new_col   - the new collision set to add\n        open_list - the open list to which nodes with changed collisoin\n                    sets are added,  assumed to be a SortedCollection\n        \"\"\"", "\n", "further", "=", "self", ".", "add_col_set", "(", "new_col", ")", "\n", "if", "further", ":", "\n", "            ", "self", ".", "colset_changed", "=", "True", "\n", "if", "not", "self", ".", "open", ":", "\n", "# assert self.closed", "\n", "                ", "self", ".", "open", "=", "True", "\n", "# self.closed = False", "\n", "self", ".", "offset", "=", "0", "\n", "\n", "# Inserting to the left of any node with the same key", "\n", "# value,  to encourage exploring closer to the collison", "\n", "open_list", ".", "insert", "(", "self", ")", "\n", "", "elif", "epeastar", "and", "self", ".", "offset", "!=", "0", ":", "\n", "# Need to reset the offset and reinsert to allow a path", "\n", "# to be found even if the node is already in the open", "\n", "# list", "\n", "                ", "self", ".", "offset", "=", "0", "\n", "# Inserting to the left of any node with the same key", "\n", "# value, to encourage exploring closer to the collison", "\n", "open_list", ".", "insert", "(", "self", ")", "\n", "", "for", "j", "in", "self", ".", "back_prop_set", ":", "\n", "                ", "j", ".", "back_prop_col_set", "(", "self", ".", "col_set", ",", "open_list", ",", "epeastar", "=", "epeastar", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.mstar_node.get_step": [[1190, 1203], ["od_mstar.mstar_node.forwards_ptr.get_step"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["", "", "", "def", "get_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns the coordinate of the next standard node in the path,\n\n        returns:\n\n        None if no such thing\n        \"\"\"", "\n", "if", "self", ".", "forwards_ptr", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "if", "self", ".", "forwards_ptr", ".", "standard_node", ":", "\n", "            ", "return", "self", ".", "forwards_ptr", ".", "coord", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "forwards_ptr", ".", "get_step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.find_path": [[32, 102], ["od_mstar.Od_Mstar", "max", "sys.setrecursionlimit", "od_mstar.Od_Mstar.find_path", "od_mstar.Od_Mstar.get_memory_useage", "od_mstar.Od_Mstar.get_memory_useage", "isinstance", "tuple", "tuple", "max", "map", "map", "Od_Mstar.sub_search[].get_cost", "sys.getrecursionlimit", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["def", "find_path", "(", "obs_map", ",", "init_pos", ",", "goals", ",", "recursive", "=", "True", ",", "inflation", "=", "1.0", ",", "\n", "time_limit", "=", "5", "*", "60.0", ",", "astar", "=", "False", ",", "get_obj", "=", "False", ",", "connect_8", "=", "False", ",", "\n", "full_space", "=", "False", ",", "return_memory", "=", "False", ",", "flood_fill_policy", "=", "False", ",", "\n", "col_checker", "=", "None", ",", "epemstar", "=", "False", ",", "makespan", "=", "False", ",", "\n", "col_set_memory", "=", "True", ")", ":", "\n", "    ", "\"\"\"Finds a path in the specified obstacle environment from the\n    initial position to the goal.\n\n    obs_map           - obstacle map,  matrix with 0 for free,  1 for\n                        obstacle\n    init_pos          - ((x1, y1), (x2, y2), ...) coordinates of the\n                        initial state, should be tuples\n    goals             - ((x1, y1), (x2, y2), ...) coordinates of the goal\n                        should be tuples\n    recursive         - True for rM*,  false for basic M*\n    inflation         - factor by which the metric will be inflated\n    time_limit        - how long to run before raising an error\n                        (declaring timeout)\n    astar             - use basic A* instead of operator decomposition to\n                        search the graph produced by M* (i.e. run M* not\n                        ODM*)\n    get_obj           - Return the Od_Mstar instance used in path\n                        planning, default False\n    connect_8         - True (default) for 8 connected graph,  False for\n                        4 connected graph\n    full_space        - If True,  run pure A* or OD (depending on the\n                        astar flag) instead of subdimensional expansion.\n                        Default False\n    return_memory     - Returns information on memory useage.\n                        Default False\n    flood_fill_policy - compute policy with flood fill instead of\n                        resumable A*\n    col_checker       - Optional custom collision checker object,  used\n                        for searching non-grid graphs.  Default None\n    epemstar          - Use EPEA* to search the graph rather than A* or\n                        OD\n    makespan          - minimize makespan (time to solution),\n                        instead of minimizing time robots spend away\n                        from their robots\n    col_set_memory    - remember previous step collision set, intended\n                        to provide more efficient cached path\n                        utillization.  True by default\n    \"\"\"", "\n", "global", "global_move_list", "\n", "if", "(", "col_checker", "is", "None", "or", "isinstance", "(", "col_checker", ",", "\n", "workspace_graph", ".", "Edge_Checker", ")", ")", ":", "\n", "        ", "goals", "=", "tuple", "(", "map", "(", "tuple", ",", "goals", ")", ")", "\n", "init_pos", "=", "tuple", "(", "map", "(", "tuple", ",", "init_pos", ")", ")", "\n", "", "global_move_list", "=", "[", "]", "\n", "o", "=", "Od_Mstar", "(", "obs_map", ",", "goals", ",", "recursive", "=", "recursive", ",", "inflation", "=", "inflation", ",", "\n", "astar", "=", "astar", ",", "connect_8", "=", "connect_8", ",", "full_space", "=", "full_space", ",", "\n", "flood_fill_policy", "=", "flood_fill_policy", ",", "col_checker", "=", "col_checker", ",", "\n", "epeastar", "=", "epemstar", ",", "makespan", "=", "makespan", ",", "\n", "col_set_memory", "=", "col_set_memory", ")", "\n", "# Need to make sure that the recursion limit is great enough to", "\n", "# actually construct the path", "\n", "longest", "=", "max", "(", "[", "o", ".", "sub_search", "[", "(", "i", ",", ")", "]", ".", "get_cost", "(", "init_pos", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "init_pos", ")", ")", "]", ")", "\n", "# Guess that the longest path will not be any longer than 5 times the", "\n", "# longest individual robot path", "\n", "sys", ".", "setrecursionlimit", "(", "max", "(", "sys", ".", "getrecursionlimit", "(", ")", ",", "longest", "*", "5", "*", "\n", "len", "(", "init_pos", ")", ")", ")", "\n", "path", "=", "o", ".", "find_path", "(", "init_pos", ",", "time_limit", "=", "time_limit", ")", "\n", "num_nodes", "=", "o", ".", "get_memory_useage", "(", "False", ")", "\n", "corrected_mem", "=", "o", ".", "get_memory_useage", "(", "True", ")", "\n", "if", "get_obj", ":", "\n", "        ", "return", "path", ",", "o", "\n", "", "if", "return_memory", ":", "\n", "        ", "return", "path", ",", "num_nodes", ",", "corrected_mem", "\n", "", "return", "path", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.individually_optimal_paths": [[1205, 1223], ["range", "max", "range", "len", "path.append", "list", "jpath.append", "od_mstar.find_path", "map", "len", "i.append", "temp.append"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path"], ["", "", "", "def", "individually_optimal_paths", "(", "obs_map", ",", "init_pos", ",", "goals", ")", ":", "\n", "    ", "\"\"\"Returns the individually optimal paths for a system\"\"\"", "\n", "\n", "path", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "init_pos", ")", ")", ":", "\n", "        ", "path", ".", "append", "(", "find_path", "(", "obs_map", ",", "[", "init_pos", "[", "i", "]", "]", ",", "[", "goals", "[", "i", "]", "]", ")", ")", "\n", "# Need to convert to full space", "\n", "", "max_length", "=", "max", "(", "list", "(", "map", "(", "len", ",", "path", ")", ")", ")", "\n", "for", "i", "in", "path", ":", "\n", "        ", "while", "len", "(", "i", ")", "<", "max_length", ":", "\n", "            ", "i", ".", "append", "(", "i", "[", "-", "1", "]", ")", "\n", "", "", "jpath", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "max_length", ")", ":", "\n", "        ", "temp", "=", "[", "]", "\n", "for", "j", "in", "path", ":", "\n", "            ", "temp", ".", "append", "(", "j", "[", "i", "]", "[", "0", "]", ")", "\n", "", "jpath", ".", "append", "(", "temp", ")", "\n", "", "return", "jpath", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.od_mstar.find_path_limited_graph": [[1225, 1261], ["od_mstar.Od_Mstar", "prune_graph.to_networkx_graph", "range", "range", "max", "sys.setrecursionlimit", "od_mstar.Od_Mstar.find_path", "od_mstar.Od_Mstar.get_memory_useage", "od_mstar.Od_Mstar.get_memory_useage", "prune_graph.prune_opposing_edge", "len", "od_mstar3.workspace_graph.Networkx_Graph", "max", "Od_Mstar.sub_search[].get_cost", "sys.getrecursionlimit", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.prune_graph.to_networkx_graph", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.prune_graph.prune_opposing_edge", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["", "def", "find_path_limited_graph", "(", "obs_map", ",", "init_pos", ",", "goals", ",", "recursive", "=", "True", ",", "\n", "inflation", "=", "1.0", ",", "time_limit", "=", "5", "*", "60.0", ",", "astar", "=", "False", ",", "\n", "get_obj", "=", "False", ",", "connect_8", "=", "False", ",", "full_space", "=", "False", ",", "\n", "return_memory", "=", "False", ",", "flood_fill_policy", "=", "False", ",", "\n", "pruning_passes", "=", "5", ")", ":", "\n", "    ", "global", "global_move_list", "\n", "global_move_list", "=", "[", "]", "\n", "o", "=", "Od_Mstar", "(", "obs_map", ",", "goals", ",", "recursive", "=", "recursive", ",", "inflation", "=", "inflation", ",", "\n", "astar", "=", "astar", ",", "connect_8", "=", "connect_8", ",", "full_space", "=", "full_space", ",", "\n", "flood_fill_policy", "=", "flood_fill_policy", ")", "\n", "import", "prune_graph", "\n", "G", "=", "prune_graph", ".", "to_networkx_graph", "(", "obs_map", ")", "\n", "for", "i", "in", "range", "(", "pruning_passes", ")", ":", "\n", "        ", "G", "=", "prune_graph", ".", "prune_opposing_edge", "(", "G", ",", "num_edges", "=", "5", ")", "\n", "# Replace the individual policies with limited graphs", "\n", "", "for", "i", "in", "range", "(", "len", "(", "o", ".", "goals", ")", ")", ":", "\n", "        ", "o", ".", "sub_search", "[", "(", "i", ",", ")", "]", "=", "workspace_graph", ".", "Networkx_Graph", "(", "\n", "obs_map", ",", "goals", "[", "i", "]", ",", "graph", "=", "G", ",", "connect_8", "=", "connect_8", ")", "\n", "# Need to make sure that the recursion limit is great enough to", "\n", "# actually construct the path", "\n", "", "longest", "=", "max", "(", "[", "o", ".", "sub_search", "[", "(", "i", ",", ")", "]", ".", "get_cost", "(", "init_pos", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "init_pos", ")", ")", "]", ")", "\n", "# Guess that the longest path will not be any longer than 5 times the", "\n", "# longest individual robot path", "\n", "sys", ".", "setrecursionlimit", "(", "max", "(", "sys", ".", "getrecursionlimit", "(", ")", ",", "longest", "*", "5", "*", "\n", "len", "(", "init_pos", ")", ")", ")", "\n", "path", "=", "o", ".", "find_path", "(", "init_pos", ",", "time_limit", "=", "time_limit", ")", "\n", "num_nodes", "=", "o", ".", "get_memory_useage", "(", "False", ")", "\n", "corrected_mem", "=", "o", ".", "get_memory_useage", "(", "True", ")", "\n", "if", "get_obj", ":", "\n", "        ", "return", "path", ",", "o", "\n", "# if visualize:", "\n", "#     return path,  global_move_list", "\n", "", "if", "return_memory", ":", "\n", "        ", "return", "path", ",", "num_nodes", ",", "corrected_mem", "\n", "", "return", "path", "\n", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.wrk_node.__init__": [[140, 159], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Initialization function for nodes of astar policy graph.\n\n        coord - coordinate of configuration which wrk_node represents\n                in astar_policy graph\n        \"\"\"", "\n", "self", ".", "coord", "=", "coord", "# Want to store as tuples", "\n", "self", ".", "policy", "=", "None", "# Holds coordinate of next neighbor to visit", "\n", "# Holds all optimal neighbors, intended to make replanning the", "\n", "# policy to find an optimal, collision avoiding path easier", "\n", "self", ".", "opt_neighbors", "=", "[", "]", "# currently only generated by _road_rules,", "\n", "# also used to store neighbor offsets for EPEA*", "\n", "self", ".", "cost", "=", "MAX_COST", "# Cost to goal", "\n", "# Used for extension easier to running resumable A* search", "\n", "self", ".", "h", "=", "0", "\n", "# Used to determine when a policy is finalized", "\n", "self", ".", "closed", "=", "False", "\n", "self", ".", "iteration", "=", "-", "1", "\n", "self", ".", "open", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Networkx_DiGraph.__init__": [[198, 203], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "graph", ")", ":", "\n", "        ", "\"\"\"graph - networkx.DiGraph specifying the configuration space.\n                   assumes, cost is stored in the cost parameter\n        \"\"\"", "\n", "self", ".", "graph", "=", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Networkx_DiGraph.get_edge_cost": [[204, 213], ["None"], "methods", ["None"], ["", "def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Returns edge_cost of going from coord1 to coord2\n\n        coord1, coord2 - node identification\n\n        returns:\n        edge cost\n        \"\"\"", "\n", "return", "self", ".", "graph", "[", "coord1", "]", "[", "coord2", "]", "[", "'cost'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Networkx_DiGraph.get_neighbors": [[214, 223], ["workspace_graph.Networkx_DiGraph.graph.neighbors"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the out-neighbors of the specified node\n\n        coord - identifier of the node to query\n\n        returns:\n        list of node identifiers of neighboring nodes\n        \"\"\"", "\n", "return", "self", ".", "graph", ".", "neighbors", "(", "coord", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Networkx_DiGraph.get_in_neighbors": [[224, 233], ["workspace_graph.Networkx_DiGraph.graph.in_edges"], "methods", ["None"], ["", "def", "get_in_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the in-neighbors of the specified node\n\n        coord - identifier of the node to query\n\n        returns:\n        list of node identifiers of in-neighbors\n        \"\"\"", "\n", "return", "[", "c", "[", "0", "]", "for", "c", "in", "self", ".", "graph", ".", "in_edges", "(", "coord", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Grid_Graph.__init__": [[245, 259], ["len", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "world_descriptor", ",", "diagonal_cost", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization for grid graph\n\n        world_descriptor - Rectangular matrix, 0 for free cell, 1 for obstacle\n        diagonal_cost    - Boolean, apply 2**.5 for diagonal cost\n        \"\"\"", "\n", "self", ".", "world_descriptor", "=", "world_descriptor", "\n", "self", ".", "width", "=", "len", "(", "world_descriptor", ")", "\n", "self", ".", "height", "=", "len", "(", "world_descriptor", "[", "0", "]", ")", "\n", "self", ".", "actions", "=", "CONNECTED_4", "\n", "if", "diagonal_cost", ":", "\n", "            ", "self", ".", "_diagonal_cost", "=", "DIAGONAL_COST", "\n", "", "else", ":", "\n", "            ", "self", ".", "_diagonal_cost", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Grid_Graph.get_edge_cost": [[260, 275], ["None"], "methods", ["None"], ["", "", "def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Retrieves config edge cost between two configurations\n\n        Grid_Graph has a fixed edge cost of one, effectively optimizing\n        make-span\n\n        coord1 - coordinate of source vertex\n        coord2 - coordinate of target vertex\n\n        Returns edge_cost of going from coord1 to coord2.\n        \"\"\"", "\n", "if", "(", "self", ".", "_diagonal_cost", "and", "coord1", "[", "0", "]", "!=", "coord2", "[", "0", "]", "and", "\n", "coord1", "[", "1", "]", "!=", "coord2", "[", "1", "]", ")", ":", "\n", "            ", "return", "self", ".", "_diagonal_cost", "\n", "", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Grid_Graph.get_neighbors": [[276, 300], ["neighbors.append"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns collision free neighbors of the specified coordinate.\n\n        coord - (x, y) coordinate of the node for which neighbors are\n                being generated\n\n        Return value in form of list of (x, y) tuples giving coordinates\n        of neighbors, including self\n        \"\"\"", "\n", "neighbors", "=", "[", "]", "\n", "min_cost", "=", "MAX_COST", "\n", "for", "i", "in", "self", ".", "actions", ":", "\n", "            ", "new_coord", "=", "(", "i", "[", "0", "]", "+", "coord", "[", "0", "]", ",", "i", "[", "1", "]", "+", "coord", "[", "1", "]", ")", "\n", "# check if points to a coordinate in the graph", "\n", "if", "(", "new_coord", "[", "0", "]", "<", "0", "or", "new_coord", "[", "0", "]", ">=", "self", ".", "width", "or", "\n", "new_coord", "[", "1", "]", "<", "0", "or", "new_coord", "[", "1", "]", ">=", "self", ".", "height", ")", ":", "\n", "                ", "continue", "\n", "", "if", "self", ".", "world_descriptor", "[", "new_coord", "[", "0", "]", "]", "[", "new_coord", "[", "1", "]", "]", "==", "OBS", ":", "\n", "# Points to obstacle", "\n", "                ", "continue", "\n", "# Valid single robot action", "\n", "", "neighbors", ".", "append", "(", "new_coord", ")", "\n", "\n", "", "return", "neighbors", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Grid_Graph.get_in_neighbors": [[301, 314], ["workspace_graph.Grid_Graph.get_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors"], ["", "def", "get_in_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the collision free in-neighbors of the specified\n        coordinate.\n\n        Equivalent to get_neighbors, because the graph is undirected\n\n        coord - (x, y) coordinate of vertex for which to return the\n                in-neighbors\n\n        Returns:\n        List of coordinates of in-neighbors\n        \"\"\"", "\n", "return", "self", ".", "get_neighbors", "(", "coord", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Grid_Graph_Conn_8.__init__": [[323, 332], ["workspace_graph.Grid_Graph.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "__init__", "(", "self", ",", "world_descriptor", ",", "diagonal_cost", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization for grid graph with 8 connectivity\n\n        world_descriptor    - Rectangular matrix, 0 for free cell, 1 for\n                              obstacle\n        \"\"\"", "\n", "super", "(", "Grid_Graph_Conn_8", ",", "self", ")", ".", "__init__", "(", "world_descriptor", ",", "\n", "diagonal_cost", "=", "diagonal_cost", ")", "\n", "self", ".", "actions", "=", "CONNECTED_8", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.GridGraphConn4WaitAtGoal.__init__": [[342, 358], ["workspace_graph.Grid_Graph.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "__init__", "(", "self", ",", "world_descriptor", ",", "goal", ",", "wait_cost", "=", ".0", ",", "\n", "diagonal_cost", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization for grid graph\n\n        world_descriptor - Rectangular matrix, 0 for free cell, 1 for\n                           obstacle\n        goal             - goal of the robot\n        wait_cost        - cost to incur for waiting at the goal\n                           configuration\n        diagonal_cost    - incur DIAGONAL_COST for moving diagonally,\n                           1 otherwise. included to support subclasses\n        \"\"\"", "\n", "super", "(", "GridGraphConn4WaitAtGoal", ",", "self", ")", ".", "__init__", "(", "\n", "world_descriptor", ",", "diagonal_cost", "=", "diagonal_cost", ")", "\n", "self", ".", "_goal", "=", "goal", "\n", "self", ".", "_wait_cost", "=", "wait_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.GridGraphConn4WaitAtGoal.get_edge_cost": [[359, 374], ["workspace_graph.Grid_Graph.get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Retrieves edge cost between two configurations\n\n        Waiting at the goal incurs cost wait_cost, while any other\n        action incurs cost self._wait_cost\n\n        coord1 - coordinate of source vertex\n        coord2 - coordinate of target vertex\n\n        Returns edge_cost of going from coord1 to coord2.\n        \"\"\"", "\n", "if", "coord1", "==", "self", ".", "_goal", "and", "coord2", "==", "self", ".", "_goal", ":", "\n", "            ", "return", "self", ".", "_wait_cost", "\n", "", "return", "super", "(", "GridGraphConn4WaitAtGoal", ",", "self", ")", ".", "get_edge_cost", "(", "coord1", ",", "\n", "coord2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.GridGraphConn8WaitAtGoal.__init__": [[384, 400], ["workspace_graph.GridGraphConn4WaitAtGoal.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "__init__", "(", "self", ",", "world_descriptor", ",", "goal", ",", "wait_cost", "=", ".0", ",", "\n", "diagonal_cost", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization for grid graph\n\n        world_descriptor - Rectangular matrix, 0 for free cell, 1 for\n                           obstacle\n        goal             - goal of the robot\n        wait_cost        - cost to incur for waiting at the goal\n                           configuration\n        diagonal_cost    - incur DIAGONAL_COST for moving diagonally if True,\n                           incur 1 if False\n        \"\"\"", "\n", "super", "(", "GridGraphConn8WaitAtGoal", ",", "self", ")", ".", "__init__", "(", "\n", "world_descriptor", ",", "goal", ",", "wait_cost", "=", "wait_cost", ",", "\n", "diagonal_cost", "=", "diagonal_cost", ")", "\n", "self", ".", "actions", "=", "CONNECTED_8", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.__init__": [[534, 567], ["config_graph", "workspace_graph.Astar_Policy._get_node", "od_mstar3.SortedCollection.SortedCollection"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node"], ["def", "__init__", "(", "self", ",", "world_descriptor", ",", "config_graph", ",", "goal", "=", "None", ",", "\n", "compute_heuristic", "=", "compute_heuristic_conn_4", ")", ":", "\n", "        ", "\"\"\"Initialization function for Astar_Policy\n\n        world_descriptor  - two-dimensional matrix which describes the\n                            gridworld with obstacles. Each point in the\n                            matrix is either a zero (no obstacle) or a\n                            one (obstacle)\n        config_graph      - a callable that takes a single argument, the\n                            world descriptor, and returns an object that\n                            represents the configuration graph, which\n                            implements the methods defined by\n                            Graph_Interface\n        goal              - (x, y)  target, optional, if not supplied,\n                            will not generate policy\n        compute_heuristic - helper function used to calculate the\n                            heuristic distance to the goal. Passed in\n                            because it interacts with the workspace\n        \"\"\"", "\n", "self", ".", "cspace", "=", "config_graph", "(", "world_descriptor", ")", "\n", "self", ".", "graph", "=", "{", "}", "\n", "self", ".", "iteration", "=", "0", "\n", "self", ".", "goal", "=", "goal", "\n", "self", ".", "init_pos", "=", "self", ".", "goal", "\n", "self", ".", "compute_heuristic", "=", "compute_heuristic", "\n", "self", ".", "goal_node", "=", "self", ".", "_get_node", "(", "self", ".", "goal", ")", "\n", "# We implicitly assume a self loop by setting the goal node's", "\n", "# policy to be its own coordin", "\n", "self", ".", "goal_node", ".", "policy", "=", "self", ".", "goal_node", ".", "coord", "\n", "self", ".", "goal_node", ".", "cost", "=", "0", "\n", "self", ".", "goal_node", ".", "open", "=", "True", "\n", "self", ".", "open_list", "=", "SortedCollection", ".", "SortedCollection", "(", "\n", "[", "self", ".", "goal_node", "]", ",", "key", "=", "lambda", "x", ":", "-", "x", ".", "cost", "-", "x", ".", "h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy._get_node": [[568, 585], ["workspace_graph.Astar_Policy.compute_heuristic", "workspace_graph.wrk_node"], "methods", ["None"], ["", "def", "_get_node", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns node specified by coord\n\n        In addition, updates its heursitic and iteration values.  If no\n        such node exists, it is created.\n\n        coord - coordinate of node to return\n        \"\"\"", "\n", "try", ":", "\n", "            ", "node", "=", "self", ".", "graph", "[", "coord", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "node", "=", "self", ".", "graph", "[", "coord", "]", "=", "wrk_node", "(", "coord", ")", "\n", "\n", "", "if", "self", ".", "iteration", ">", "node", ".", "iteration", ":", "\n", "            ", "node", ".", "iteration", "=", "self", ".", "iteration", "\n", "node", ".", "h", "=", "self", ".", "compute_heuristic", "(", "self", ".", "init_pos", ",", "coord", ")", "\n", "", "return", "node", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy._compute_path": [[586, 634], ["od_mstar3.col_set_addition.NoSolutionError", "len", "workspace_graph.Astar_Policy.open_list.pop", "workspace_graph.Astar_Policy.get_neighbors", "workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy.open_list.insert_right", "workspace_graph.Astar_Policy.get_edge_cost", "workspace_graph.Astar_Policy.get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert_right", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "_compute_path", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Extends the search to reach the specified node\n\n        coord - (x,y) coordinate of targeted configuration\n\n        Tries to compute path from coord to goal.  If successful,\n        returns next coordinate in path to goal from coord.  If not\n        successful, raises an NoSolutionError.\n        \"\"\"", "\n", "if", "self", ".", "init_pos", "==", "self", ".", "goal", ":", "\n", "            ", "self", ".", "init_pos", "=", "coord", "\n", "# First need to update the heuristic for nodes in the open", "\n", "# list", "\n", "# Only change the heuristic for the intial coordinate, when the", "\n", "# open list is empty, so don't actually have to resort the open", "\n", "# list", "\n", "# Open list may be empty if trying after trying to find paths to", "\n", "# two unreachable nodes.  This will only be done my", "\n", "# multi_assignment_mstar while trying to compute the assignment", "\n", "# cost matrix.  Besides which, this will trigger a", "\n", "# NoSolutionError in case such a situtation is not supposed to", "\n", "# be found assert len(self.open_list) > 0", "\n", "", "while", "len", "(", "self", ".", "open_list", ")", ">", "0", ":", "\n", "            ", "node", "=", "self", ".", "open_list", ".", "pop", "(", ")", "\n", "if", "node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "node", ".", "closed", "=", "True", "\n", "node", ".", "open", "=", "False", "\n", "# Need to add the neighbors before checking if this is the", "\n", "# goal, so search can be resumed without being blocked by", "\n", "# this position", "\n", "neighbors", "=", "self", ".", "get_neighbors", "(", "node", ".", "coord", ")", "\n", "for", "i", "in", "neighbors", ":", "\n", "                ", "tnode", "=", "self", ".", "_get_node", "(", "i", ")", "\n", "if", "(", "tnode", ".", "closed", "or", "tnode", ".", "cost", "<=", "node", ".", "cost", "+", "\n", "self", ".", "get_edge_cost", "(", "i", ",", "node", ".", "coord", ")", ")", ":", "\n", "                    ", "continue", "\n", "", "tnode", ".", "cost", "=", "node", ".", "cost", "+", "self", ".", "get_edge_cost", "(", "\n", "i", ",", "node", ".", "coord", ")", "\n", "tnode", ".", "policy", "=", "node", ".", "coord", "\n", "tnode", ".", "open", "=", "True", "\n", "# Can add tnode directly, and will just skip any", "\n", "# inconsistent copies", "\n", "self", ".", "open_list", ".", "insert_right", "(", "tnode", ")", "\n", "", "if", "node", ".", "coord", "==", "coord", ":", "\n", "# Done, so return the next step", "\n", "                ", "return", "node", ".", "policy", "\n", "", "", "raise", "NoSolutionError", "(", "'Couldn\\'t finish individual policy'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.get_step": [[635, 654], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy._compute_path"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy._compute_path"], ["", "def", "get_step", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Gets the policy for the given coordinate\n\n        If no policy exists, extends planning to reach the coordinate\n\n        coord - (x, y) configuration\n\n        Returns a coordinate of the next node in the policy\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "node", ".", "closed", ":", "\n", "# Have already computed the optimal policy here", "\n", "            ", "return", "node", ".", "policy", "\n", "", "self", ".", "iteration", "+=", "1", "\n", "try", ":", "\n", "            ", "return", "self", ".", "_compute_path", "(", "coord", ")", "\n", "", "except", "NoSolutionError", ":", "\n", "# Couldn't find a path to goal, so return None", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.get_cost": [[655, 670], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy._compute_path"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy._compute_path"], ["", "", "def", "get_cost", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the cost of moving from given position to goal\n\n        Cost is for moving from coordinate specified at coord\n        to the goal configuration.\n\n        coord - (x, y) configuration\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "node", ".", "closed", ":", "\n", "            ", "return", "node", ".", "cost", "\n", "", "self", ".", "iteration", "+=", "1", "\n", "self", ".", "_compute_path", "(", "coord", ")", "\n", "assert", "node", ".", "closed", "\n", "return", "node", ".", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.get_edge_cost": [[671, 684], ["workspace_graph.Astar_Policy.cspace.get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Returns cost of config transition from coord1 to coord2\n\n        Wrapper function for returning the config space's\n        get_edge_cost from coord1 to coord2\n\n        coord1 - initial coordinate in transition\n        coord2 - final coordinate in transition\n\n        returns:\n        edge cost of going from coord1 to coord2\n        \"\"\"", "\n", "return", "self", ".", "cspace", ".", "get_edge_cost", "(", "coord1", ",", "coord2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy._gen_limited_offset_neighbors": [[685, 708], ["workspace_graph.Astar_Policy._get_node", "collections.defaultdict", "workspace_graph.Astar_Policy.get_cost", "workspace_graph.Astar_Policy.get_neighbors", "dict", "workspace_graph.Astar_Policy.opt_neighbors[].append", "workspace_graph.Astar_Policy.get_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["", "def", "_gen_limited_offset_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Stores the neighbors of a node by changes in f-value\n\n        f-value - the sum of cost to reach and cost to go.\n\n        coord - (x, y) configuration for which limited offset neighbors\n                are generated\n        \"\"\"", "\n", "# Repurposing a preexisting field, so need to change to a", "\n", "# defaultdict", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "node", ".", "opt_neighbors", "=", "defaultdict", "(", "lambda", ":", "[", "]", ")", "\n", "base_cost", "=", "self", ".", "get_cost", "(", "coord", ")", "\n", "# Need to compute offsets", "\n", "for", "neib", "in", "self", ".", "get_neighbors", "(", "coord", ")", ":", "\n", "# difference in path cost using different paths, need to", "\n", "# handle staying at the goal seperately", "\n", "            ", "if", "neib", "==", "self", ".", "goal", "and", "neib", "==", "coord", ":", "\n", "                ", "offset", "=", "0", "\n", "", "else", ":", "\n", "                ", "offset", "=", "self", ".", "get_cost", "(", "neib", ")", "-", "base_cost", "+", "1", "\n", "", "node", ".", "opt_neighbors", "[", "offset", "]", ".", "append", "(", "(", "offset", ",", "neib", ")", ")", "\n", "", "node", ".", "opt_neighbors", "=", "dict", "(", "node", ".", "opt_neighbors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.get_limited_offset_neighbors": [[709, 739], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy.opt_neighbors.iteritems", "workspace_graph.Astar_Policy._gen_limited_offset_neighbors", "out.extend"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], ["", "def", "get_limited_offset_neighbors", "(", "self", ",", "coord", ",", "max_offset", ",", "min_offset", "=", "0", ")", ":", "\n", "        ", "\"\"\"Returns set of neighbors specified by the offsets\n\n        More specifically, returns the set of neighbors for which the\n        maximum difference in path cost if passed through is less than\n        the specified value.\n\n        (i.e. if you are forced to pass through coordinate x, instead of\n        the optimal step, what is the difference in cost)?\n\n        coord - coordinates of the node to find neighbors of\n        max_offset - the maximum increase in path cost to encur in\n                     choice of neighbors\n        min_offset - minimum increae in path cost to encur in a neighbor\n\n        returns:\n        a list of tuples of the form (offset, coordinate)\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "not", "node", ".", "opt_neighbors", ":", "\n", "            ", "self", ".", "_gen_limited_offset_neighbors", "(", "coord", ")", "\n", "# Have already pre-computed the results", "\n", "", "out", "=", "[", "]", "\n", "for", "offset", ",", "neighbors", "in", "node", ".", "opt_neighbors", ".", "iteritems", "(", ")", ":", "\n", "            ", "if", "offset", "<", "min_offset", ":", "\n", "                ", "continue", "\n", "", "if", "offset", ">", "max_offset", ":", "\n", "                ", "return", "out", "\n", "", "out", ".", "extend", "(", "neighbors", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.get_offset_neighbors": [[740, 759], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], ["", "def", "get_offset_neighbors", "(", "self", ",", "coord", ",", "offset", ")", ":", "\n", "        ", "\"\"\"Generates offset neighbors for node specified by coord\n\n        If no offset neighbors exist, they are created\n\n        Only offset neighbors at a certain offset are returned\n\n        coord  - (x,y) configuration for which neighbors are being\n                 generated\n        offset - value of offset determing which neighbors are\n                 included in return value\n\n        returns:\n        list of tuples of form (offset, neighbor)\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "not", "node", ".", "opt_neighbors", ":", "\n", "            ", "self", ".", "_gen_limited_offset_neighbors", "(", "coord", ")", "\n", "", "return", "node", ".", "opt_neighbors", "[", "offset", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.get_offsets": [[760, 776], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy.opt_neighbors.keys", "workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], ["", "def", "get_offsets", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Return the possible offsets of the neighbors.\n\n        The offset of a neighbor is the difference in the cost of the\n        optimal path from coord to the cost of the best path constrained\n        to pass through a specific neighbor.  Used in EPEA*\n\n        coord - (x,y) configuration for which neighbors are being\n                generated and their offsets returned\n\n        Returns list of offsets of all neighbor nodes to coord\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "not", "node", ".", "opt_neighbors", ":", "\n", "            ", "self", ".", "_gen_limited_offset_neighbors", "(", "coord", ")", "\n", "", "return", "node", ".", "opt_neighbors", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.get_neighbors": [[777, 799], ["workspace_graph.Astar_Policy.cspace.get_neighbors", "workspace_graph.Astar_Policy.get_cost", "workspace_graph.Astar_Policy.get_cost", "opt_neighbors.append"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ",", "opt", "=", "False", ")", ":", "\n", "        ", "\"\"\"Wrapper function for get_neighbors function of underlying\n        config_space graph.\n\n        opt - only optimal neighbors are returned\n        coord - configuration for which neighbors are being returned\n\n        Returns list of tuples, where each tuple is a coordinate\n        \"\"\"", "\n", "neighbors", "=", "self", ".", "cspace", ".", "get_neighbors", "(", "coord", ")", "\n", "if", "not", "opt", ":", "\n", "            ", "return", "neighbors", "\n", "", "for", "i", "in", "neighbors", ":", "\n", "            ", "if", "opt", ":", "\n", "                ", "cost", "=", "self", ".", "get_cost", "(", "i", ")", "\n", "if", "cost", "<", "min_cost", ":", "\n", "                    ", "min_cost", "=", "cost", "\n", "", "", "", "opt_neighbors", "=", "[", "]", "\n", "for", "i", "in", "neighbors", ":", "\n", "            ", "if", "self", ".", "get_cost", "(", "i", ")", "==", "min_cost", ":", "\n", "                ", "opt_neighbors", ".", "append", "(", "i", ")", "\n", "", "", "return", "opt_neighbors", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Policy.get_graph_size": [[800, 808], ["sum", "map"], "methods", ["None"], ["", "def", "get_graph_size", "(", "self", ",", "correct_for_size", "=", "True", ")", ":", "\n", "        ", "\"\"\"Gets the size of the graph\n\n        correct_for_size - just intended to match signatures\n\n        Returns the number of nodes used for this graph\n        \"\"\"", "\n", "return", "sum", "(", "map", "(", "len", ",", "self", ".", "graph", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_DiGraph_Policy.__init__": [[826, 845], ["workspace_graph.Astar_Policy.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "__init__", "(", "self", ",", "world_descriptor", ",", "config_graph", ",", "goal", "=", "None", ",", "\n", "compute_heuristic", "=", "compute_heuristic_conn_4", ")", ":", "\n", "        ", "\"\"\"Initialization function for Astar_Policy\n\n        world_descriptor  - two-dimensional matrix which describes the\n                            gridworld with obstacles. Each point in the\n                            matrix is either a zero (no obstacle) or a\n                            one (obstacle)\n        config_graph      - a class which is used to represent the\n                            config space of the robot\n        goal              - (x, y)  target, optional, if not supplied,\n                            will not generate policy\n        compute_heuristic - helper function used to calculate the\n                            heuristic distance to the goal. Passed in\n                            because it interacts with the workspace\n        \"\"\"", "\n", "super", "(", "Astar_DiGraph_Policy", ",", "self", ")", ".", "__init__", "(", "\n", "world_descriptor", ",", "config_graph", ",", "goal", "=", "goal", ",", "\n", "compute_heuristic", "=", "compute_heuristic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_DiGraph_Policy._compute_path": [[846, 898], ["od_mstar3.col_set_addition.NoSolutionError", "len", "workspace_graph.Astar_DiGraph_Policy.open_list.pop", "workspace_graph.Astar_DiGraph_Policy.get_in_neighbors", "workspace_graph.Astar_DiGraph_Policy._get_node", "workspace_graph.Astar_DiGraph_Policy.open_list.insert_right", "workspace_graph.Astar_DiGraph_Policy.get_edge_cost", "workspace_graph.Astar_DiGraph_Policy.get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy.get_in_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert_right", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["", "def", "_compute_path", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Extends the search to reach the specified node\n\n        Explicitly plans in reverse from the goal to the target, using\n        get_in_neighbors to compute node expansion, instead of\n        Astar_Graph, which uses the get_neighbors function.\n\n        coord - (x,y) coordinate of targeted configuration\n\n        Tries to compute path from coord to goal.  If successful,\n        returns next coordinate in path to goal from coord.  If not\n        successful, raises an NoSolutionError.\n        \"\"\"", "\n", "if", "self", ".", "init_pos", "==", "self", ".", "goal", ":", "\n", "            ", "self", ".", "init_pos", "=", "coord", "\n", "# First need to update the heuristic for nodes in the open", "\n", "# list", "\n", "# Only change the heuristic for the intial coordinate, when the", "\n", "# open list is empty, so don't actually have to resort the open", "\n", "# list", "\n", "# Open list may be empty if trying after trying to find paths to", "\n", "# two unreachable nodes.  This will only be done my", "\n", "# multi_assignment_mstar while trying to compute the assignment", "\n", "# cost matrix.  Besides which, this will trigger a", "\n", "# NoSolutionError in case such a situtation is not supposed to", "\n", "# be found assert len(self.open_list) > 0", "\n", "", "while", "len", "(", "self", ".", "open_list", ")", ">", "0", ":", "\n", "            ", "node", "=", "self", ".", "open_list", ".", "pop", "(", ")", "\n", "if", "node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "node", ".", "closed", "=", "True", "\n", "node", ".", "open", "=", "False", "\n", "# Need to add the neighbors before checking if this is the", "\n", "# goal, so search can be resumed without being blocked by", "\n", "# this position", "\n", "neighbors", "=", "self", ".", "get_in_neighbors", "(", "node", ".", "coord", ")", "\n", "for", "i", "in", "neighbors", ":", "\n", "                ", "tnode", "=", "self", ".", "_get_node", "(", "i", ")", "\n", "if", "(", "tnode", ".", "closed", "or", "tnode", ".", "cost", "<=", "node", ".", "cost", "+", "\n", "self", ".", "get_edge_cost", "(", "i", ",", "node", ".", "coord", ")", ")", ":", "\n", "                    ", "continue", "\n", "", "tnode", ".", "cost", "=", "node", ".", "cost", "+", "self", ".", "get_edge_cost", "(", "\n", "i", ",", "node", ".", "coord", ")", "\n", "tnode", ".", "policy", "=", "node", ".", "coord", "\n", "tnode", ".", "open", "=", "True", "\n", "# Can add tnode directly, and will just skip any", "\n", "# inconsistent copies", "\n", "self", ".", "open_list", ".", "insert_right", "(", "tnode", ")", "\n", "", "if", "node", ".", "coord", "==", "coord", ":", "\n", "# Done, so return the next step", "\n", "                ", "return", "node", ".", "policy", "\n", "", "", "raise", "NoSolutionError", "(", "'Couldn\\'t finish individual policy'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_DiGraph_Policy.get_in_neighbors": [[899, 910], ["workspace_graph.Astar_DiGraph_Policy.cspace.get_in_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy.get_in_neighbors"], ["", "def", "get_in_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Wraper for the get_in_neighbors function of the underlying\n        config_space graph\n\n        coord - coordinate of whom the predecessors (in neighbors) are\n                returned\n\n        returns:\n        list of coordinates of the predecessors of coord\n        \"\"\"", "\n", "return", "self", ".", "cspace", ".", "get_in_neighbors", "(", "coord", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Priority_Graph.__init__": [[921, 930], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "astar_policy", ",", "max_t", "=", "None", ")", ":", "\n", "        ", "\"\"\"initialization for Priority_Graph\n\n        astar_policy       - the graph to wrap\n\n        max_t - greatest t - value allowed\n        \"\"\"", "\n", "self", ".", "astar_policy", "=", "astar_policy", "\n", "self", ".", "max_t", "=", "max_t", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Priority_Graph.get_step": [[931, 948], ["workspace_graph.Priority_Graph.astar_policy.get_step", "min"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["", "def", "get_step", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Gets the policy for the given coordinate,\n\n        If necessary, extends planning to reach said coordinate.  Will\n        increment time by 1\n\n        coord - (x, y, t) position and time coordinate for the specified\n                node\n        \"\"\"", "\n", "# Can do this by stripping time, querrying the underlying", "\n", "# astar_policy, then appending the appropriate new time", "\n", "t", "=", "coord", "[", "-", "1", "]", "+", "1", "\n", "# Check if this would exceed maximal value", "\n", "if", "self", ".", "max_t", "is", "not", "None", ":", "\n", "            ", "t", "=", "min", "(", "self", ".", "max_t", ",", "t", ")", "\n", "", "step", "=", "self", ".", "astar_policy", ".", "get_step", "(", "coord", "[", ":", "2", "]", ")", "\n", "return", "step", "+", "(", "t", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Priority_Graph.get_cost": [[949, 957], ["workspace_graph.Priority_Graph.astar_policy.get_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["", "def", "get_cost", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Gets cost of moving to goal from coord\n\n        coord - (x, y, t)  coordinates of node for which to get cost\n\n        Returns cost of moving from the given position to goal\n        \"\"\"", "\n", "return", "self", ".", "astar_policy", ".", "get_cost", "(", "coord", "[", ":", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Priority_Graph.set_max_t": [[958, 964], ["None"], "methods", ["None"], ["", "def", "set_max_t", "(", "self", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Sets the maximum time value the graph will use.\n\n        Allows for easy changes for different constraints\n        \"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Priority_Graph.get_neighbors": [[965, 977], ["workspace_graph.Priority_Graph.astar_policy.get_neighbors", "map", "min"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Gets the neighbors of the specified space-time point\n\n        coord - coordinate of configuration for which neighbors are\n                being returned\n\n        Returns neighbors of coord in config space, with a time stamp\n        one greater than that of coord\n        \"\"\"", "\n", "pos_neighbors", "=", "self", ".", "astar_policy", ".", "get_neighbors", "(", "(", "coord", "[", "0", "]", ",", "coord", "[", "1", "]", ")", ")", "\n", "return", "map", "(", "lambda", "x", ":", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "min", "(", "self", ".", "max_t", ",", "coord", "[", "-", "1", "]", "+", "1", ")", ")", ",", "\n", "pos_neighbors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Back_Priority_Graph.__init__": [[995, 1007], ["workspace_graph.Priority_Graph.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "__init__", "(", "self", ",", "astar_policy", ",", "max_t", "=", "None", ",", "prune_paths", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        astar_policy - the graph to wrap\n        max_t       - greatest t-value allowed\n        prune_paths - whether to prune neighbors that cannot reach the\n                      goal of astar_policy within the time specified.\n                      This is the default behavior.  Disabling when\n                      running task swapping allows for paths to be found\n                      to multiple initial configurations\n        \"\"\"", "\n", "Priority_Graph", ".", "__init__", "(", "self", ",", "astar_policy", ",", "max_t", "=", "max_t", ")", "\n", "self", ".", "prune_paths", "=", "prune_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Back_Priority_Graph.get_neighbors": [[1008, 1034], ["workspace_graph.Back_Priority_Graph.astar_policy.get_neighbors", "neighbors.append", "neighbors.append", "neighbors.append", "workspace_graph.Back_Priority_Graph.astar_policy.get_cost", "workspace_graph.Back_Priority_Graph.astar_policy.get_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Gets the neighbors of the specified space-time point\"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "if", "coord", "[", "-", "1", "]", "==", "0", "and", "self", ".", "max_t", "!=", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "pos_neighbors", "=", "self", ".", "astar_policy", ".", "get_neighbors", "(", "(", "coord", "[", "0", "]", ",", "coord", "[", "1", "]", ")", ")", "\n", "if", "coord", "[", "-", "1", "]", "==", "self", ".", "max_t", ":", "\n", "            ", "neighbors", "=", "[", "]", "\n", "for", "pos", "in", "pos_neighbors", ":", "\n", "                ", "neighbors", ".", "append", "(", "(", "pos", "[", "0", "]", ",", "pos", "[", "1", "]", ",", "self", ".", "max_t", ")", ")", "\n", "# Make sure that you can actually get form the initial", "\n", "# position to the suggested vertex in time", "\n", "if", "self", ".", "prune_paths", ":", "\n", "                    ", "if", "(", "not", "self", ".", "max_t", "==", "0", "and", "\n", "self", ".", "astar_policy", ".", "get_cost", "(", "pos", ")", "<=", "coord", "[", "-", "1", "]", "-", "1", ")", ":", "\n", "                        ", "neighbors", ".", "append", "(", "(", "pos", "[", "0", "]", ",", "pos", "[", "1", "]", ",", "coord", "[", "-", "1", "]", "-", "1", ")", ")", "\n", "", "", "else", ":", "\n", "# Don't check on whether there is time to reach the", "\n", "# intial configuration", "\n", "                    ", "neighbors", ".", "append", "(", "(", "pos", "[", "0", "]", ",", "pos", "[", "1", "]", ",", "coord", "[", "-", "1", "]", "-", "1", ")", ")", "\n", "", "", "return", "neighbors", "\n", "", "if", "self", ".", "prune_paths", ":", "\n", "            ", "return", "[", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "coord", "[", "-", "1", "]", "-", "1", ")", "for", "x", "in", "pos_neighbors", "\n", "if", "self", ".", "astar_policy", ".", "get_cost", "(", "x", ")", "<=", "coord", "[", "-", "1", "]", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "coord", "[", "-", "1", "]", "-", "1", ")", "for", "x", "in", "pos_neighbors", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Back_Priority_Graph.get_forwards_neighbors": [[1035, 1039], ["workspace_graph.Priority_Graph.get_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors"], ["", "", "def", "get_forwards_neighbors", "(", "self", ",", "coord", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Gets the forward time dynamics neighbors of this point\"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "return", "Priority_Graph", ".", "get_neighbors", "(", "self", ",", "coord", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Back_Priority_Graph.get_cost": [[1040, 1048], ["workspace_graph.Priority_Graph.get_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["", "def", "get_cost", "(", "self", ",", "coord", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Returns the cost of moving from given position to goal\n\n        coord - (x, y, t)  coordinates of node for which to get cost\n\n        \"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "return", "Priority_Graph", ".", "get_cost", "(", "self", ",", "coord", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Back_Priority_Graph.get_step": [[1049, 1059], ["workspace_graph.Priority_Graph.get_step"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["", "def", "get_step", "(", "self", ",", "coord", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Gets the policy for the given coordinate, extending planning\n        to reach said coordinate if necessary.  Will increment time by 1\n\n        coord - (x, y, t) position and time coordinate for the specified\n                node\n\n        \"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "return", "Priority_Graph", ".", "get_step", "(", "self", ",", "coord", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Limited_Astar_Policy.__init__": [[1070, 1073], ["workspace_graph.Astar_Policy.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "__init__", "(", "self", ",", "world_descriptor", ",", "goal", ",", "limit_graph", ",", "connect_8", "=", "False", ")", ":", "\n", "        ", "Astar_Policy", ".", "__init__", "(", "self", ",", "world_descriptor", ",", "goal", ",", "connect_8", ")", "\n", "self", ".", "limit_graph", "=", "limit_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Limited_Astar_Policy.get_neighbors": [[1074, 1080], ["workspace_graph.Limited_Astar_Policy.limit_graph.neighbors"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the neighbors of the given coordinate in the limit\n        graph\n\n        \"\"\"", "\n", "return", "self", ".", "limit_graph", ".", "neighbors", "(", "coord", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.__init__": [[1087, 1093], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Takes no arguments, because on grid graph, only the\n        coordinates matter\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.simple_pass_through": [[1094, 1111], ["range", "len", "range", "len"], "methods", ["None"], ["", "def", "simple_pass_through", "(", "self", ",", "c1", ",", "c2", ")", ":", "\n", "        ", "\"\"\"Simply check for collisions, avoid the additional overhead\n\n        for use with basic OD (op_decomp)\n\n        c1 - coordinate at time t\n        c2 - coordinate at time t + 1\n\n        returns:\n        True if pass through collision, else false\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c2", "[", "j", "]", "and", "c1", "[", "j", "]", "==", "c2", "[", "i", "]", ":", "\n", "                    ", "return", "True", "\n", "", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.simple_col_check": [[1112, 1126], ["range", "len", "range", "len"], "methods", ["None"], ["", "def", "simple_col_check", "(", "self", ",", "c1", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions at c1,\n\n        for use with basic OD (op_decomp)\n\n        returns:\n        True if collision exists\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                    ", "return", "True", "\n", "", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.simple_cross_over": [[1127, 1147], ["range", "len", "range", "len", "abs", "abs"], "methods", ["None"], ["", "def", "simple_cross_over", "(", "self", ",", "c1", ",", "c2", ")", ":", "\n", "        ", "\"\"\"Check for cross over collisions in 8-connected worlds\n\n        returns:\n        True if collision is detected\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "# compute displacement vector", "\n", "                ", "disp", "=", "[", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                    ", "continue", "\n", "# compute previous? displacement vector.  Have a pass", "\n", "# through or cross over collision if the displacement", "\n", "# vector is the opposite", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                    ", "return", "True", "\n", "", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.simple_incremental_cross_over": [[1148, 1167], ["range", "len", "abs", "abs"], "methods", ["None"], ["", "def", "simple_incremental_cross_over", "(", "self", ",", "c1", ",", "c2", ")", ":", "\n", "        ", "\"\"\"Check for cross over collisions in 8-connected worlds.\n\n        Assumes that collision checking has been performed for everything\n        but the last robot in the coordinates.  To be used to save a bit\n        of time for partial expansion approaches\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "disp", "=", "[", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "-", "1", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "-", "1", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                ", "continue", "\n", "# compute previous? displacement vector.  Have a pass through", "\n", "# or cross over collision if the displacement vector is the", "\n", "# opposite", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "-", "1", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "-", "1", "]", "[", "1", "]", ")", ")", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.simple_incremental_col_check": [[1168, 1181], ["range", "len"], "methods", ["None"], ["", "def", "simple_incremental_col_check", "(", "self", ",", "c1", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions at c1,\n\n        for use with basic OD (op_decomp)\n\n        returns:\n        True if collision exists\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "if", "c1", "[", "i", "]", "==", "c1", "[", "-", "1", "]", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.single_bot_outpath_check": [[1182, 1219], ["min", "range", "len", "len", "len", "abs", "abs"], "methods", ["None"], ["", "def", "single_bot_outpath_check", "(", "self", ",", "cur_coord", ",", "prev_coord", ",", "cur_t", ",", "paths", ")", ":", "\n", "        ", "\"\"\"Tests for collisions when moving from prev_coord to cur_coord\n        with the robots in paths.\n\n        cur_coord - position of a single robot\n\n        Returns:\n\n        True if a collision is found,\n        False otherwise\n\n        \"\"\"", "\n", "if", "paths", "is", "None", ":", "\n", "            ", "return", "False", "\n", "", "prev_t", "=", "cur_t", "-", "1", "\n", "check_t", "=", "min", "(", "cur_t", ",", "len", "(", "paths", ")", "-", "1", ")", "\n", "new_cols", "=", "0", "\n", "for", "bot", "in", "range", "(", "len", "(", "paths", "[", "0", "]", ")", ")", ":", "\n", "# Check for simultaneous occupation", "\n", "            ", "if", "(", "cur_coord", "[", "0", "]", "==", "paths", "[", "check_t", "]", "[", "bot", "]", "[", "0", "]", "and", "\n", "cur_coord", "[", "1", "]", "==", "paths", "[", "check_t", "]", "[", "bot", "]", "[", "1", "]", ")", ":", "\n", "                ", "return", "True", "\n", "", "if", "cur_t", ">=", "len", "(", "paths", ")", ":", "\n", "# Can't have edge collisions when out-group robots", "\n", "# aren't moving", "\n", "                ", "continue", "\n", "# Check for pass-through/cross over collisions", "\n", "", "disp", "=", "[", "prev_coord", "[", "0", "]", "-", "paths", "[", "prev_t", "]", "[", "bot", "]", "[", "0", "]", ",", "\n", "prev_coord", "[", "1", "]", "-", "paths", "[", "prev_t", "]", "[", "bot", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                ", "continue", "\n", "# Compute current displacement vector, and check for", "\n", "# inversion", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "cur_coord", "[", "0", "]", "-", "paths", "[", "cur_t", "]", "[", "bot", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "cur_coord", "[", "1", "]", "-", "paths", "[", "cur_t", "]", "[", "bot", "]", "[", "1", "]", ")", ")", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.simple_prio_col_check": [[1220, 1261], ["isinstance", "tuple", "min", "isinstance", "range", "map", "len", "len", "isinstance", "tuple", "isinstance", "tuple", "workspace_graph.Edge_Checker.single_bot_cross_over", "isinstance", "tuple"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.single_bot_cross_over"], ["", "def", "simple_prio_col_check", "(", "self", ",", "coord", ",", "t", ",", "paths", ",", "pcoord", "=", "None", ",", "\n", "conn_8", "=", "False", ")", ":", "\n", "        ", "\"\"\"Returns true, if collision is detected, false otherwise\n        at the moment only used to check the obstacle collisions, but\n        didn't want to reject the other code already\n\n        coord - coord of potential new neighbor\n        t - current time step\n        paths - previously found paths\n        pcoord - previous coordinate of the path\n\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "coord", ",", "tuple", ")", ":", "\n", "            ", "coord", "=", "tuple", "(", "coord", ")", "\n", "", "if", "paths", "is", "not", "None", ":", "\n", "            ", "t", "=", "min", "(", "t", ",", "len", "(", "paths", ")", "-", "1", ")", "\n", "# only one path", "\n", "if", "isinstance", "(", "paths", "[", "0", "]", "[", "0", "]", ",", "int", ")", ":", "\n", "                ", "paths", "=", "map", "(", "lambda", "x", ":", "[", "x", "]", ",", "paths", ")", "\n", "", "for", "bot", "in", "range", "(", "len", "(", "paths", "[", "t", "]", ")", ")", ":", "\n", "                ", "if", "not", "isinstance", "(", "paths", "[", "t", "]", "[", "bot", "]", ",", "tuple", ")", ":", "\n", "                    ", "paths", "[", "t", "]", "[", "bot", "]", "=", "tuple", "(", "paths", "[", "t", "]", "[", "bot", "]", ")", "\n", "# (a) simultaneous occupation of one node", "\n", "", "if", "coord", "==", "paths", "[", "t", "]", "[", "bot", "]", ":", "\n", "                        ", "return", "True", "\n", "# (b) pass through and cross over collision", "\n", "", "if", "pcoord", "is", "not", "None", ":", "\n", "                    ", "if", "not", "isinstance", "(", "pcoord", ",", "tuple", ")", ":", "\n", "                        ", "pcoord", "=", "tuple", "(", "pcoord", ")", "\n", "", "", "if", "not", "isinstance", "(", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", ",", "tuple", ")", ":", "\n", "                    ", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", "=", "tuple", "(", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", ")", "\n", "", "if", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", "==", "coord", "and", "paths", "[", "t", "]", "[", "bot", "]", "==", "pcoord", ":", "\n", "                    ", "return", "True", "\n", "# (c) cross over collision in case of conn_8", "\n", "", "if", "conn_8", ":", "\n", "                    ", "if", "self", ".", "single_bot_cross_over", "(", "paths", "[", "t", "]", "[", "bot", "]", ",", "\n", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", ",", "coord", ",", "\n", "pcoord", ")", ":", "\n", "                        ", "return", "True", "\n", "# No collision", "\n", "", "", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.col_check": [[1262, 1278], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["", "def", "col_check", "(", "self", ",", "c1", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single point.  Returns either a M*\n        or rM* collision set in the form of sets, depending on the\n        setting of recursive.\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.incremental_col_check": [[1279, 1296], ["range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["", "def", "incremental_col_check", "(", "self", ",", "c1", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single point.  Returns either a M*\n        or rM* collision set in the form of sets, depending on the\n        setting of recursive.  Only checks whether the last robot is\n        involved in a collision, for use with incremental methods\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "j", "=", "len", "(", "c1", ")", "-", "1", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "(", "i", ",", "j", ")", ")", "]", ",", "col_set", ")", "\n", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.cross_over": [[1297, 1324], ["range", "range", "len", "len", "adder", "abs", "abs", "frozenset"], "methods", ["None"], ["", "def", "cross_over", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "# compute current displacement vector", "\n", "                ", "if", "c1", "[", "i", "]", "is", "None", "or", "c1", "[", "j", "]", "is", "None", "or", "c2", "[", "i", "]", "is", "None", "or", "c2", "[", "j", "]", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "disp", "=", "(", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", ")", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                    ", "continue", "\n", "# Compute previous displacement vector.  Have a cross over or", "\n", "# pass through collision if the two displacement vectors are", "\n", "# opposites", "\n", "# pdisp = [c2[i][0] - c2[j][0], c2[i][1] - c2[j][1]]", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.incremental_cross_over": [[1325, 1356], ["range", "len", "len", "adder", "abs", "abs", "frozenset"], "methods", ["None"], ["", "def", "incremental_cross_over", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions.\n\n        Only checks if the last robot is involved in a collision, for use\n        with partial expansion approaches.\n\n        c1 - the initial configuration.\n        c2 - the final configuration. c1 may include additional robots,\n             if necessary\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "j", "=", "len", "(", "c2", ")", "-", "1", "\n", "for", "i", "in", "range", "(", "len", "(", "c2", ")", "-", "1", ")", ":", "\n", "# compute current displacement vector", "\n", "            ", "disp", "=", "(", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", ")", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                ", "continue", "\n", "# Compute previous displacement vector.  Have a cross over or", "\n", "# pass through collision if the two displacement vectors are", "\n", "# opposites", "\n", "# pdisp = [c2[i][0] - c2[j][0], c2[i][1] - c2[j][1]]", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.pass_through": [[1357, 1372], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["", "def", "pass_through", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"returns a tuple of colliding robots, or set of tuples if\n        recursive\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c2", "[", "j", "]", "and", "c1", "[", "j", "]", "==", "c2", "[", "i", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "(", "i", ",", "j", ")", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.single_bot_cross_over": [[1373, 1385], ["abs", "abs"], "methods", ["None"], ["", "def", "single_bot_cross_over", "(", "self", ",", "coord1", ",", "pcoord1", ",", "coord2", ",", "pcoord2", ")", ":", "\n", "        ", "\"\"\"Checks for cross-over and collisions between robots one and 2\n        moving from pcoord to coord\n\n        \"\"\"", "\n", "disp", "=", "(", "pcoord1", "[", "0", "]", "-", "pcoord2", "[", "0", "]", ",", "pcoord1", "[", "1", "]", "-", "pcoord2", "[", "1", "]", ")", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "            ", "return", "False", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "coord1", "[", "0", "]", "-", "coord2", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "coord1", "[", "1", "]", "-", "coord2", "[", "1", "]", ")", ")", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Edge_Checker.prio_col_check": [[1386, 1422], ["isinstance", "tuple", "isinstance", "tuple", "range", "len", "range", "len", "adder", "adder", "abs", "abs", "frozenset", "frozenset"], "methods", ["None"], ["", "def", "prio_col_check", "(", "self", ",", "coord", ",", "pcoord", ",", "t", ",", "paths", "=", "None", ",", "conn_8", "=", "False", ",", "\n", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Collision checking with paths passed as constraints\n\n        coord  - current node\n        pcoord - previous node\n        t      - timestep\n        paths  - paths that need to be avoided\n\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "coord", ",", "tuple", ")", ":", "\n", "            ", "coord", "=", "tuple", "(", "coord", ")", "\n", "", "if", "not", "isinstance", "(", "pcoord", ",", "tuple", ")", ":", "\n", "            ", "pcoord", "=", "tuple", "(", "pcoord", ")", "\n", "", "if", "paths", "is", "not", "None", ":", "\n", "            ", "col_set", "=", "[", "]", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "                ", "adder", "=", "add_col_set_recursive", "\n", "", "else", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "coord", ")", ")", ":", "\n", "                    ", "for", "j", "in", "range", "(", "len", "(", "paths", "[", "t", "]", ")", ")", ":", "\n", "# simultaneous occupation", "\n", "                        ", "if", "coord", "[", "i", "]", "==", "paths", "[", "t", "]", "[", "j", "]", ":", "\n", "                            ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "# pass-through and cross-over", "\n", "", "disp", "=", "[", "pcoord", "[", "i", "]", "[", "0", "]", "-", "paths", "[", "t", "-", "1", "]", "[", "j", "]", "[", "0", "]", ",", "\n", "pcoord", "[", "i", "]", "[", "1", "]", "-", "paths", "[", "t", "-", "1", "]", "[", "j", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                            ", "continue", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "coord", "[", "i", "]", "[", "0", "]", "-", "paths", "[", "t", "]", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "coord", "[", "i", "]", "[", "0", "]", "-", "paths", "[", "t", "]", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                            ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "", "", "", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.NoRotationChecker.__init__": [[1432, 1438], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Takes no arguments, because on grid graph, only the\n        coordinates matter\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.NoRotationChecker.col_check": [[1439, 1455], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["", "def", "col_check", "(", "self", ",", "c1", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single point.  Returns either a M*\n        or rM* collision set in the form of sets, depending on the\n        setting of recursive.\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.NoRotationChecker.cross_over": [[1456, 1486], ["range", "range", "len", "len", "adder", "abs", "abs", "adder", "frozenset", "frozenset"], "methods", ["None"], ["", "def", "cross_over", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "# compute current displacement vector", "\n", "                ", "if", "c1", "[", "i", "]", "is", "None", "or", "c1", "[", "j", "]", "is", "None", "or", "c2", "[", "i", "]", "is", "None", "or", "c2", "[", "j", "]", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "disp", "=", "(", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", ")", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                    ", "continue", "\n", "# Compute previous displacement vector.  Have a cross over or", "\n", "# pass through collision if the two displacement vectors are", "\n", "# opposites", "\n", "# pdisp = [c2[i][0] - c2[j][0], c2[i][1] - c2[j][1]]", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "elif", "c1", "[", "i", "]", "==", "c2", "[", "j", "]", "or", "c1", "[", "j", "]", "==", "c2", "[", "i", "]", ":", "\n", "# There is a rotation, which is banned", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Lazy_Edge_Checker.__init__": [[1493, 1499], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Takes no arguments, because on grid graph, only the\n        coordinates matter\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Lazy_Edge_Checker.col_check": [[1500, 1517], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["", "def", "col_check", "(", "self", ",", "c1", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single point.  Returns either a M*\n        or rM* collision set in the form of sets, depending on the\n        setting of recursive.\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Lazy_Edge_Checker.pass_through": [[1518, 1534], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["", "def", "pass_through", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"returns a tuple of colliding robots, or set of tuples if\n        recursive\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c2", "[", "j", "]", "and", "c1", "[", "j", "]", "==", "c2", "[", "i", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "", "", "", "return", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Lazy_Edge_Checker.cross_over": [[1535, 1560], ["range", "range", "len", "len", "adder", "abs", "abs", "frozenset"], "methods", ["None"], ["", "def", "cross_over", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "# compute current displacement vector", "\n", "                ", "disp", "=", "[", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                    ", "continue", "\n", "# Compute previous displacement vector.  Have a cross", "\n", "# over or pass through collision if the two displacement", "\n", "# vectors are opposites", "\n", "# pdisp = [c2[i][0] - c2[j][0], c2[i][1] - c2[j][1]]", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "", "", "", "return", "col_set", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.memoize": [[165, 176], ["functools.wraps", "f"], "function", ["None"], ["", "", "def", "memoize", "(", "f", ")", ":", "\n", "    ", "memo", "=", "{", "}", "\n", "\n", "@", "wraps", "(", "f", ")", "\n", "def", "inner", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "memo", "[", "args", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "z", "=", "memo", "[", "args", "]", "=", "f", "(", "*", "args", ")", "\n", "return", "z", "\n", "", "", "return", "inner", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.node_cmp": [[178, 188], ["None"], "function", ["None"], ["", "def", "node_cmp", "(", "n1", ",", "n2", ")", ":", "\n", "    ", "\"\"\" Sort nodes by cost \"\"\"", "\n", "if", "n1", ".", "cost", "<", "n2", ".", "cost", ":", "\n", "        ", "return", "-", "1", "\n", "", "elif", "n1", ".", "cost", ">", "n2", ".", "cost", ":", "\n", "        ", "return", "1", "\n", "# Returning 0 allows for stable sorting, i.e. equal objects stay in", "\n", "# the same order, which should provide a bit of a performance boost,", "\n", "# as well as a bit of consistency", "\n", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Workspace_Graph": [[402, 424], ["Flood_Fill_Policy", "Flood_Fill_Policy"], "function", ["None"], ["", "", "def", "Workspace_Graph", "(", "world_descriptor", ",", "goal", "=", "None", ",", "connect_8", "=", "False", ",", "\n", "road_rules", "=", "True", ")", ":", "\n", "    ", "\"\"\"Wrapper function for returning Flood_Fill_Policy objects\n\n    Function returns objects with different args depending on the\n    connect_8 flag\n\n    world_descriptor - two-dimensional matrix representing the space in\n                       which the robot can travel.  A value of 1 in the\n                       space represents an obstacle, and a value of 0\n                       represents an open space\n    goal             - position [x,y] of the goal of the policy\n    connect_8        - boolean determining whether Grid_Graph or\n                       Grid_Graph_Conn_8 is used\n    road_rules       - boolean supplied to policy object to determine if\n                       rightmost neighbor node should always be used\n    \"\"\"", "\n", "if", "connect_8", ":", "\n", "        ", "return", "Flood_Fill_Policy", "(", "world_descriptor", ",", "Grid_Graph_Conn_8", ",", "\n", "goal", ",", "road_rules", ")", "\n", "", "return", "Flood_Fill_Policy", "(", "world_descriptor", ",", "Grid_Graph", ",", "goal", ",", "\n", "road_rules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.compute_heuristic_conn_8": [[426, 436], ["max", "map", "abs"], "function", ["None"], ["", "def", "compute_heuristic_conn_8", "(", "init_pos", ",", "coord", ")", ":", "\n", "    ", "\"\"\"Returns a heuristic for distance between coord and init_pos\n\n    init_pos - coordinate of position of goal configuration\n    coord    - coordinate of configuration for which heuristic is\n               being computed\n\n    Returns the heuristic distance to goal\n    \"\"\"", "\n", "return", "max", "(", "map", "(", "lambda", "x", ",", "y", ":", "abs", "(", "x", "-", "y", ")", ",", "coord", ",", "init_pos", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.compute_heuristic_conn_8_diagonal": [[438, 454], ["abs", "abs", "min", "max"], "function", ["None"], ["", "def", "compute_heuristic_conn_8_diagonal", "(", "init_pos", ",", "coord", ")", ":", "\n", "    ", "\"\"\"Returns a heuristic for distance between coord and init_pos\n\n    Used when moving diagonally costs DIAGONAL_COST instead of 1\n\n    init_pos - coordinate of position of goal configuration\n    coord    - coordinate of configuration for which heuristic is\n               being computed\n\n    Returns the heuristic distance to goal\n    \"\"\"", "\n", "x_diff", "=", "abs", "(", "init_pos", "[", "0", "]", "-", "coord", "[", "0", "]", ")", "\n", "y_diff", "=", "abs", "(", "init_pos", "[", "1", "]", "-", "coord", "[", "1", "]", ")", "\n", "min_dist", "=", "min", "(", "x_diff", ",", "y_diff", ")", "\n", "max_dist", "=", "max", "(", "x_diff", ",", "y_diff", ")", "\n", "return", "DIAGONAL_COST", "*", "min_dist", "+", "(", "max_dist", "-", "min_dist", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.compute_heuristic_conn_4": [[456, 467], ["sum", "map", "abs"], "function", ["None"], ["", "def", "compute_heuristic_conn_4", "(", "init_pos", ",", "coord", ")", ":", "\n", "    ", "\"\"\"Returns Manhattan heuristic for distance from coord to init_pos\n\n    init_pos - coordinate of position of goal configuration\n    coord    - coordinate of configuration for which heursitic is\n               being computed\n\n    Returns the heuristic distance to goal through a\n    Manhattan metric calculation.\n    \"\"\"", "\n", "return", "sum", "(", "map", "(", "lambda", "x", ",", "y", ":", "abs", "(", "x", "-", "y", ")", ",", "coord", ",", "init_pos", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.od_mstar3.workspace_graph.Astar_Graph": [[469, 520], ["workspace_graph.Astar_Policy", "workspace_graph.Astar_Policy", "workspace_graph.Astar_Policy", "workspace_graph.Astar_Policy", "workspace_graph.GridGraphConn4WaitAtGoal", "workspace_graph.GridGraphConn8WaitAtGoal", "workspace_graph.Grid_Graph_Conn_8"], "function", ["None"], ["", "def", "Astar_Graph", "(", "world_descriptor", ",", "goal", "=", "None", ",", "connect_8", "=", "False", ",", "\n", "diagonal_cost", "=", "False", ",", "makespan", "=", "False", ",", "wait_cost", "=", "0.", ")", ":", "\n", "    ", "\"\"\"Wrapper function for returning Astar_Policy objects\n\n    Different heuristic functions are given to Astar_Policy object\n    depending on whether the gridworld is 8 connected or not\n\n    world_descriptor - two-dimensional matrix which describes the\n                       gridworld with obstacles. Each point in the\n                       matrix is either a zero (no obstacle) or a\n                       one (obstacle)\n    goal             - position (x, y) of the goal of the policy\n    connect_8        - boolean determining whether each coordinate\n                       in the gridworld has eight neighbors\n                       (including all diagonal neighbors) or only\n                       four (cardinal neighbors)\n    diagonal_cost    - boolean, apply DIAGONAL_COST for diagonal costs if True,\n                       apply 1 if False\n    makespan         - minimize makespan instead of minimizing time\n    wait_cost        - cost of waiting at the goal\n    \"\"\"", "\n", "if", "makespan", ":", "\n", "        ", "if", "connect_8", ":", "\n", "            ", "if", "diagonal_cost", ":", "\n", "                ", "h_func", "=", "compute_heuristic_conn_8_diagonal", "\n", "", "else", ":", "\n", "                ", "h_func", "=", "compute_heuristic_conn_8", "\n", "", "return", "Astar_Policy", "(", "\n", "world_descriptor", ",", "\n", "lambda", "x", ":", "Grid_Graph_Conn_8", "(", "x", ",", "diagonal_cost", "=", "diagonal_cost", ")", ",", "\n", "goal", "=", "goal", ",", "compute_heuristic", "=", "h_func", ")", "\n", "", "else", ":", "\n", "            ", "return", "Astar_Policy", "(", "world_descriptor", ",", "Grid_Graph", ",", "goal", "=", "goal", ",", "\n", "compute_heuristic", "=", "compute_heuristic_conn_4", ")", "\n", "", "", "if", "connect_8", ":", "\n", "        ", "if", "diagonal_cost", ":", "\n", "            ", "h_func", "=", "compute_heuristic_conn_8_diagonal", "\n", "", "else", ":", "\n", "            ", "h_func", "=", "compute_heuristic_conn_8", "\n", "", "return", "Astar_Policy", "(", "\n", "world_descriptor", ",", "\n", "lambda", "x", ":", "GridGraphConn8WaitAtGoal", "(", "x", ",", "goal", ",", "\n", "wait_cost", "=", "wait_cost", ",", "\n", "diagonal_cost", "=", "diagonal_cost", ",", "\n", ")", ",", "\n", "goal", ",", "h_func", ")", "\n", "", "return", "Astar_Policy", "(", "world_descriptor", ",", "\n", "lambda", "x", ":", "GridGraphConn4WaitAtGoal", "(", "\n", "x", ",", "goal", ",", "wait_cost", "=", "wait_cost", ",", "\n", "diagonal_cost", "=", "diagonal_cost", ")", ",", "\n", "goal", ",", "compute_heuristic_conn_4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.basic_block.LambdaLayer.__init__": [[5, 8], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["    ", "def", "__init__", "(", "self", ",", "lambd", ")", ":", "\n", "        ", "super", "(", "LambdaLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lambd", "=", "lambd", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.basic_block.LambdaLayer.forward": [[9, 11], ["basic_block.LambdaLayer.lambd"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "lambd", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.basic_block.BasicBlock.__init__": [[16, 35], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Sequential", "basic_block.LambdaLayer", "torch.nn.Sequential", "torch.pad", "torch.nn.Conv2d", "torch.nn.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ",", "option", "=", "'A'", ")", ":", "\n", "    ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "planes", ":", "\n", "        ", "if", "option", "==", "'A'", ":", "\n", "            ", "\"\"\"\n            For CIFAR10 ResNet paper uses option A.\n            \"\"\"", "\n", "self", ".", "shortcut", "=", "LambdaLayer", "(", "lambda", "x", ":", "\n", "F", ".", "pad", "(", "x", "[", ":", ",", ":", ",", ":", ":", "2", ",", ":", ":", "2", "]", ",", "(", "0", ",", "0", ",", "0", ",", "0", ",", "planes", "//", "4", ",", "planes", "//", "4", ")", ",", "\"constant\"", ",", "0", ")", ")", "\n", "", "elif", "option", "==", "'B'", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.basic_block.BasicBlock.forward": [[37, 43], ["torch.relu", "basic_block.BasicBlock.bn2", "basic_block.BasicBlock.shortcut", "torch.relu", "basic_block.BasicBlock.bn1", "basic_block.BasicBlock.conv2", "basic_block.BasicBlock.conv1"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "    ", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "return", "out", "", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.trainer.setup_train_and_test_file": [[11, 35], ["print", "os.walk", "numpy.random.permutation", "len", "print", "int", "len", "open", "open", "files.append", "fout.write", "fout.write", "os.path.join"], "function", ["None"], ["def", "setup_train_and_test_file", "(", "train_file", ",", "test_file", ")", ":", "\n", "  ", "print", "(", "'Setting up train and test file.'", ")", "\n", "files", "=", "[", "]", "\n", "for", "path", ",", "subdirs", ",", "f", "in", "os", ".", "walk", "(", "input_dir", ")", ":", "\n", "    ", "for", "name", "in", "f", ":", "\n", "      ", "files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "path", ",", "name", ")", ")", "\n", "\n", "", "", "perm", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "files", ")", ")", "\n", "files", "=", "[", "files", "[", "i", "]", "for", "i", "in", "perm", "]", "\n", "\n", "n", "=", "len", "(", "files", ")", "\n", "print", "(", "'Total input files found:'", ",", "n", ")", "\n", "\n", "train_size", "=", "int", "(", "0.9", "*", "n", ")", "\n", "train_files", "=", "files", "[", ":", "train_size", "]", "\n", "test_files", "=", "files", "[", "train_size", ":", "]", "\n", "\n", "with", "open", "(", "train_file", ",", "'w'", ")", "as", "fout", ":", "\n", "    ", "for", "file", "in", "train_files", ":", "\n", "        ", "fout", ".", "write", "(", "file", "+", "'\\n'", ")", "\n", "\n", "", "", "with", "open", "(", "test_file", ",", "'w'", ")", "as", "fout", ":", "\n", "      ", "for", "file", "in", "test_files", ":", "\n", "          ", "fout", ".", "write", "(", "file", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.trainer.train_model": [[36, 64], ["torch.device", "model.ViTResNet", "model.ViTResNet.to", "torch.optim.Adam", "torch.optim.lr_scheduler.StepLR", "model.data_loader", "model.data_loader", "range", "trainer.setup_train_and_test_file", "model.ViTResNet.parameters", "print", "time.time", "model.train", "print", "model.evaluate", "torch.cuda.is_available", "os.path.exists", "os.path.exists", "torch.save", "model.ViTResNet.state_dict", "time.time"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.data_loader", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.data_loader", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.trainer.setup_train_and_test_file", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.train", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.evaluate"], ["", "", "", "def", "train_model", "(", "input_dir", ",", "train_device", ",", "epochs", ",", "model_path", ")", ":", "\n", "  ", "device", "=", "torch", ".", "device", "(", "train_device", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "train_file", "=", "input_dir", "+", "'train.txt'", "\n", "test_file", "=", "input_dir", "+", "'test.txt'", "\n", "\n", "if", "not", "(", "os", ".", "path", ".", "exists", "(", "train_file", ")", "and", "os", ".", "path", ".", "exists", "(", "test_file", ")", ")", ":", "\n", "    ", "setup_train_and_test_file", "(", "train_file", ",", "test_file", ")", "\n", "\n", "", "model", "=", "ViTResNet", "(", "BasicBlock", ",", "[", "3", ",", "3", ",", "3", "]", ",", "BATCH_SIZE", ")", "\n", "model", ".", "to", "(", "device", ")", "\n", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "0.003", ")", "\n", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "optimizer", ",", "step_size", "=", "10000", ",", "gamma", "=", "0.992", ")", "\n", "\n", "train_loader", "=", "data_loader", "(", "train_file", ",", "BATCH_SIZE", ",", "device", ")", "\n", "test_loader", "=", "data_loader", "(", "test_file", ",", "BATCH_SIZE", ",", "device", ")", "\n", "\n", "train_loss_history", ",", "test_loss_history", "=", "[", "]", ",", "[", "]", "\n", "best_val_loss", "=", "1e9", "\n", "for", "epoch", "in", "range", "(", "1", ",", "epochs", "+", "1", ")", ":", "\n", "      ", "print", "(", "'Epoch:'", ",", "epoch", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "train", "(", "model", ",", "optimizer", ",", "train_loader", ",", "train_loss_history", ",", "scheduler", ")", "\n", "print", "(", "'Execution time:'", ",", "'{:5.2f}'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ",", "'seconds'", ")", "\n", "acc", ",", "val_loss", "=", "evaluate", "(", "model", ",", "test_loader", ",", "test_loss_history", ")", "\n", "if", "val_loss", "<", "best_val_loss", ":", "\n", "        ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "model_path", ")", "\n", "best_val_loss", "=", "val_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.ViTResNet.__init__": [[15, 60], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "model.ViTResNet._make_layer", "model.ViTResNet._make_layer", "model.ViTResNet._make_layer", "model.ViTResNet.apply", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "transformer.Transformer", "torch.nn.Identity", "torch.nn.Identity", "torch.nn.Identity", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.ViTResNet._make_layer", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.ViTResNet._make_layer", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.ViTResNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "num_blocks", ",", "batch_size", ")", ":", "\n", "        ", "super", "(", "ViTResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "32", "\n", "self", ".", "L", "=", "16", "\n", "self", ".", "cT", "=", "256", "\n", "self", ".", "mlp_dim", "=", "512", "\n", "self", ".", "num_classes", "=", "5", "\n", "self", ".", "heads", "=", "16", "\n", "self", ".", "depth", "=", "16", "\n", "self", ".", "emb_dropout", "=", "0.2", "\n", "self", ".", "transformer_dropout", "=", "0.2", "\n", "self", ".", "input_channels", "=", "10", "\n", "\n", "# Convolutions", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "self", ".", "input_channels", ",", "32", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "32", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "32", ",", "num_blocks", "[", "0", "]", ",", "stride", "=", "1", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "num_blocks", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "num_blocks", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "apply", "(", "_weights_init", ")", "\n", "\n", "\n", "# Tokenization", "\n", "self", ".", "token_wA", "=", "nn", ".", "Parameter", "(", "torch", ".", "empty", "(", "batch_size", ",", "self", ".", "L", ",", "128", ")", ",", "requires_grad", "=", "True", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "token_wA", ")", "\n", "self", ".", "token_wV", "=", "nn", ".", "Parameter", "(", "torch", ".", "empty", "(", "batch_size", ",", "128", ",", "self", ".", "cT", ")", ",", "requires_grad", "=", "True", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "token_wV", ")", "\n", "\n", "self", ".", "pos_embedding", "=", "nn", ".", "Parameter", "(", "torch", ".", "empty", "(", "1", ",", "(", "self", ".", "L", "+", "1", ")", ",", "self", ".", "cT", ")", ")", "\n", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "self", ".", "pos_embedding", ",", "std", "=", ".02", ")", "\n", "\n", "self", ".", "cls_token", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ",", "1", ",", "self", ".", "cT", ")", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "emb_dropout", ")", "\n", "\n", "self", ".", "transformer", "=", "Transformer", "(", "self", ".", "cT", ",", "self", ".", "depth", ",", "self", ".", "heads", ",", "self", ".", "mlp_dim", ",", "self", ".", "transformer_dropout", ")", "\n", "\n", "self", ".", "to_cls_token", "=", "nn", ".", "Identity", "(", ")", "\n", "\n", "self", ".", "nn_same", "=", "nn", ".", "Linear", "(", "self", ".", "cT", ",", "self", ".", "cT", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "nn_same", ".", "weight", ")", "\n", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "self", ".", "nn_same", ".", "bias", ",", "std", "=", "1e-6", ")", "\n", "\n", "self", ".", "nn1", "=", "nn", ".", "Linear", "(", "self", ".", "cT", ",", "self", ".", "num_classes", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "nn1", ".", "weight", ")", "\n", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "self", ".", "nn1", ".", "bias", ",", "std", "=", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.ViTResNet._make_layer": [[61, 69], ["torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "num_blocks", ",", "stride", ")", ":", "\n", "        ", "strides", "=", "[", "stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks", "-", "1", ")", "\n", "layers", "=", "[", "]", "\n", "for", "stride", "in", "strides", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "stride", ")", ")", "\n", "self", ".", "in_planes", "=", "planes", "*", "block", ".", "expansion", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.ViTResNet.forward": [[70, 100], ["torch.relu", "torch.relu", "torch.relu", "model.ViTResNet.layer1", "model.ViTResNet.layer2", "model.ViTResNet.layer3", "einops.rearrange", "einops.rearrange", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "einops.rearrange", "A.softmax.softmax.softmax", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "model.ViTResNet.cls_token.expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.ViTResNet.dropout", "model.ViTResNet.transformer", "model.ViTResNet.to_cls_token", "model.ViTResNet.nn_same", "model.ViTResNet.nn_same", "model.ViTResNet.nn1", "model.ViTResNet.bn1", "model.ViTResNet.conv1"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.expand"], ["", "def", "forward", "(", "self", ",", "img", ",", "mask", "=", "None", ")", ":", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "img", ")", ")", ")", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "\n", "x", "=", "rearrange", "(", "x", ",", "'b c h w -> b (h w) c'", ")", "\n", "\n", "# Tokenization ", "\n", "wa", "=", "rearrange", "(", "self", ".", "token_wA", ",", "'b h w -> b w h'", ")", "\n", "A", "=", "torch", ".", "einsum", "(", "'bij,bjk->bik'", ",", "x", ",", "wa", ")", "\n", "A", "=", "rearrange", "(", "A", ",", "'b h w -> b w h'", ")", "\n", "A", "=", "A", ".", "softmax", "(", "dim", "=", "-", "1", ")", "\n", "VV", "=", "torch", ".", "einsum", "(", "'bij,bjk->bik'", ",", "x", ",", "self", ".", "token_wV", ")", "\n", "T", "=", "torch", ".", "einsum", "(", "'bij,bjk->bik'", ",", "A", ",", "VV", ")", "\n", "\n", "# Class tokens and positional embeddings", "\n", "cls_tokens", "=", "self", ".", "cls_token", ".", "expand", "(", "img", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "-", "1", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "cls_tokens", ",", "T", ")", ",", "dim", "=", "1", ")", "\n", "x", "+=", "self", ".", "pos_embedding", "\n", "x", "=", "self", ".", "dropout", "(", "x", ")", "\n", "\n", "# Attention", "\n", "x", "=", "self", ".", "transformer", "(", "x", ",", "mask", ")", "\n", "x", "=", "self", ".", "to_cls_token", "(", "x", "[", ":", ",", "0", "]", ")", "\n", "x", "=", "self", ".", "nn_same", "(", "x", ")", "\n", "x", "=", "self", ".", "nn_same", "(", "x", ")", "\n", "x", "=", "self", ".", "nn1", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model._weights_init": [[10, 13], ["isinstance", "isinstance", "torch.kaiming_normal_"], "function", ["None"], ["def", "_weights_init", "(", "m", ")", ":", "\n", "    ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "        ", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.data_loader": [[101, 127], ["random.shuffle", "open().read().split", "len", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.tensor().long().to", "torch.tensor().long().to", "torch.tensor().long().to", "numpy.load", "torch.from_numpy().float().to.append", "Y.append", "open().read", "len", "random.shuffle", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.tensor().long", "torch.tensor().long", "torch.tensor().long", "open", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.tensor", "torch.tensor", "torch.tensor", "numpy.concatenate", "numpy.concatenate"], "function", ["None"], ["", "", "def", "data_loader", "(", "file_name", ",", "batch_size", ",", "device", ")", ":", "\n", "  ", "file_names", "=", "open", "(", "file_name", ")", ".", "read", "(", ")", ".", "split", "(", "'\\n'", ")", "[", ":", "-", "1", "]", "\n", "total_samples", "=", "len", "(", "file_names", ")", "*", "16", "\n", "random", ".", "shuffle", "(", "file_names", ")", "\n", "i", "=", "0", "\n", "while", "1", ":", "\n", "    ", "X", "=", "[", "]", "\n", "Y", "=", "[", "]", "\n", "k", "=", "batch_size", "\n", "\n", "while", "k", ">", "0", ":", "\n", "      ", "cur_file", "=", "file_names", "[", "i", "]", "\n", "loaded", "=", "np", ".", "load", "(", "cur_file", ")", "\n", "X", ".", "append", "(", "loaded", "[", "'X'", "]", ")", "\n", "Y", ".", "append", "(", "loaded", "[", "'y'", "]", ")", "\n", "i", "+=", "1", "\n", "k", "-=", "16", "\n", "\n", "if", "i", ">=", "len", "(", "file_names", ")", ":", "\n", "        ", "i", "=", "0", "\n", "random", ".", "shuffle", "(", "file_names", ")", "\n", "\n", "", "", "X", "=", "torch", ".", "from_numpy", "(", "np", ".", "concatenate", "(", "X", ")", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "y", "=", "torch", ".", "tensor", "(", "np", ".", "concatenate", "(", "Y", ")", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "yield", "total_samples", ",", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.train": [[128, 165], ["model.train", "print", "optimizer.zero_grad", "torch.log_softmax", "torch.nll_loss", "torch.max", "torch.max", "torch.max", "pred.eq().sum", "F.nll_loss.backward", "optimizer.step", "loss_history.append", "epoch_loss.append", "scheduler.step", "model", "F.nll_loss.item", "F.nll_loss.item", "print", "pred.eq", "print", "len", "sum", "len", "len", "sum", "len"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.train"], ["", "", "def", "train", "(", "model", ",", "optimizer", ",", "data_loader", ",", "loss_history", ",", "scheduler", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "epoch_loss", "=", "[", "]", "\n", "correct_samples", "=", "0", "\n", "i", "=", "0", "\n", "\n", "for", "total_samples", ",", "data", ",", "target", "in", "data_loader", ":", "\n", "        ", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "F", ".", "log_softmax", "(", "model", "(", "data", ")", ",", "dim", "=", "1", ")", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", ",", "target", ")", "\n", "_", ",", "pred", "=", "torch", ".", "max", "(", "output", ",", "dim", "=", "1", ")", "\n", "correct_samples", "+=", "pred", ".", "eq", "(", "target", ")", ".", "sum", "(", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "loss_history", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "epoch_loss", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "\n", "if", "i", "%", "10000", "==", "0", ":", "\n", "          ", "print", "(", "'['", "+", "'{:5}'", ".", "format", "(", "i", "*", "len", "(", "data", ")", ")", "+", "'/'", "+", "'{:5}'", ".", "format", "(", "total_samples", ")", "+", "\n", "'] Loss: '", "+", "'{:6.4f}'", ".", "format", "(", "sum", "(", "epoch_loss", ")", "/", "len", "(", "epoch_loss", ")", ")", ")", "\n", "\n", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "            ", "print", "(", "'Learning rate: '", ",", "param_group", "[", "'lr'", "]", ")", "\n", "\n", "", "", "if", "i", "*", "len", "(", "data", ")", ">=", "total_samples", ":", "\n", "#one epoch completed", "\n", "          ", "break", "\n", "\n", "", "i", "+=", "1", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n", "", "print", "(", "'\\nTrain Loss: {:6.4f}'", ".", "format", "(", "sum", "(", "epoch_loss", ")", "/", "len", "(", "epoch_loss", ")", ")", "+", "\n", "'  Accuracy:'", "+", "'{:5}'", ".", "format", "(", "correct_samples", ")", "+", "'/'", "+", "\n", "'{:5}'", ".", "format", "(", "total_samples", ")", "+", "' ('", "+", "\n", "'{:4.2f}'", ".", "format", "(", "100.0", "*", "correct_samples", "/", "total_samples", ")", "+", "'%)\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.model.evaluate": [[166, 197], ["model.eval", "loss_history.append", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.log_softmax", "torch.nll_loss", "torch.max", "torch.max", "torch.max", "F.nll_loss.item", "pred.eq().sum", "model", "pred.eq", "len"], "function", ["None"], ["", "def", "evaluate", "(", "model", ",", "data_loader", ",", "loss_history", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "\n", "total_samples", "=", "0", "\n", "correct_samples", "=", "0", "\n", "total_loss", "=", "0", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "i", "=", "0", "\n", "for", "test_samples", ",", "data", ",", "target", "in", "data_loader", ":", "\n", "            ", "total_samples", "=", "test_samples", "\n", "output", "=", "F", ".", "log_softmax", "(", "model", "(", "data", ")", ",", "dim", "=", "1", ")", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", "\n", "_", ",", "pred", "=", "torch", ".", "max", "(", "output", ",", "dim", "=", "1", ")", "\n", "\n", "total_loss", "+=", "loss", ".", "item", "(", ")", "\n", "correct_samples", "+=", "pred", ".", "eq", "(", "target", ")", ".", "sum", "(", ")", "\n", "\n", "if", "i", "*", "len", "(", "data", ")", ">=", "total_samples", ":", "\n", "#testing done", "\n", "              ", "break", "\n", "\n", "", "i", "+=", "1", "\n", "\n", "", "", "avg_loss", "=", "total_loss", "/", "total_samples", "\n", "loss_history", ".", "append", "(", "avg_loss", ")", "\n", "print", "(", "'\\nAverage test loss: '", "+", "'{:.4f}'", ".", "format", "(", "avg_loss", ")", "+", "\n", "'  Accuracy:'", "+", "'{:5}'", ".", "format", "(", "correct_samples", ")", "+", "'/'", "+", "\n", "'{:5}'", ".", "format", "(", "total_samples", ")", "+", "' ('", "+", "\n", "'{:4.2f}'", ".", "format", "(", "100.0", "*", "correct_samples", "/", "total_samples", ")", "+", "'%)\\n'", ")", "\n", "return", "(", "(", "100.0", "*", "correct_samples", "/", "total_samples", ")", ",", "avg_loss", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.Residual.__init__": [[7, 10], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["    ", "def", "__init__", "(", "self", ",", "fn", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fn", "=", "fn", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.Residual.forward": [[10, 12], ["transformer.Residual.fn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "fn", "(", "x", ",", "**", "kwargs", ")", "+", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.LayerNormalize.__init__": [[14, 18], ["torch.nn.Module.__init__", "torch.nn.LayerNorm", "torch.nn.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", ",", "fn", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "norm", "=", "nn", ".", "LayerNorm", "(", "dim", ")", "\n", "self", ".", "fn", "=", "fn", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.LayerNormalize.forward": [[18, 20], ["transformer.LayerNormalize.fn", "transformer.LayerNormalize.norm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "fn", "(", "self", ".", "norm", "(", "x", ")", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.MLP_Block.__init__": [[22, 33], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.GELU", "torch.nn.GELU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.Dropout", "torch.nn.Dropout"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", ",", "hidden_dim", ",", "dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "nn1", "=", "nn", ".", "Linear", "(", "dim", ",", "hidden_dim", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "nn1", ".", "weight", ")", "\n", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "self", ".", "nn1", ".", "bias", ",", "std", "=", "1e-6", ")", "\n", "self", ".", "af1", "=", "nn", ".", "GELU", "(", ")", "\n", "self", ".", "do1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "nn2", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "dim", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "nn2", ".", "weight", ")", "\n", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "self", ".", "nn2", ".", "bias", ",", "std", "=", "1e-6", ")", "\n", "self", ".", "do2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.MLP_Block.forward": [[34, 42], ["transformer.MLP_Block.nn1", "transformer.MLP_Block.af1", "transformer.MLP_Block.do1", "transformer.MLP_Block.nn2", "transformer.MLP_Block.do2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "nn1", "(", "x", ")", "\n", "x", "=", "self", ".", "af1", "(", "x", ")", "\n", "x", "=", "self", ".", "do1", "(", "x", ")", "\n", "x", "=", "self", ".", "nn2", "(", "x", ")", "\n", "x", "=", "self", ".", "do2", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.Attention.__init__": [[44, 57], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.zeros_", "torch.nn.init.zeros_", "torch.nn.init.zeros_", "torch.nn.init.zeros_", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.zeros_", "torch.nn.init.zeros_", "torch.nn.init.zeros_", "torch.nn.init.zeros_", "torch.nn.Dropout", "torch.nn.Dropout"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", ",", "heads", "=", "8", ",", "dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "heads", "=", "heads", "\n", "self", ".", "scale", "=", "dim", "**", "-", "0.5", "# 1/sqrt(dim)", "\n", "\n", "self", ".", "to_qkv", "=", "nn", ".", "Linear", "(", "dim", ",", "dim", "*", "3", ",", "bias", "=", "True", ")", "# Wq,Wk,Wv for each vector, thats why *3", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "to_qkv", ".", "weight", ")", "\n", "torch", ".", "nn", ".", "init", ".", "zeros_", "(", "self", ".", "to_qkv", ".", "bias", ")", "\n", "\n", "self", ".", "nn1", "=", "nn", ".", "Linear", "(", "dim", ",", "dim", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "nn1", ".", "weight", ")", "\n", "torch", ".", "nn", ".", "init", ".", "zeros_", "(", "self", ".", "nn1", ".", "bias", ")", "\n", "self", ".", "do1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.Attention.forward": [[59, 80], ["transformer.Attention.to_qkv", "einops.rearrange", "dots.softmax", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "einops.rearrange", "transformer.Attention.nn1", "transformer.Attention.do1", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.pad", "torch.pad", "dots.masked_fill_", "torch.pad.flatten", "float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "b", ",", "n", ",", "_", ",", "h", "=", "*", "x", ".", "shape", ",", "self", ".", "heads", "\n", "qkv", "=", "self", ".", "to_qkv", "(", "x", ")", "#gets q = Q = Wq matmul x1, k = Wk mm x2, v = Wv mm x3", "\n", "q", ",", "k", ",", "v", "=", "rearrange", "(", "qkv", ",", "'b n (qkv h d) -> qkv b h n d'", ",", "qkv", "=", "3", ",", "h", "=", "h", ")", "# split into multi head attentions", "\n", "\n", "dots", "=", "torch", ".", "einsum", "(", "'bhid,bhjd->bhij'", ",", "q", ",", "k", ")", "*", "self", ".", "scale", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "F", ".", "pad", "(", "mask", ".", "flatten", "(", "1", ")", ",", "(", "1", ",", "0", ")", ",", "value", "=", "True", ")", "\n", "assert", "mask", ".", "shape", "[", "-", "1", "]", "==", "dots", ".", "shape", "[", "-", "1", "]", ",", "'mask has incorrect dimensions'", "\n", "mask", "=", "mask", "[", ":", ",", "None", ",", ":", "]", "*", "mask", "[", ":", ",", ":", ",", "None", "]", "\n", "dots", ".", "masked_fill_", "(", "~", "mask", ",", "float", "(", "'-inf'", ")", ")", "\n", "del", "mask", "\n", "\n", "", "attn", "=", "dots", ".", "softmax", "(", "dim", "=", "-", "1", ")", "#follow the softmax,q,d,v equation in the paper", "\n", "\n", "out", "=", "torch", ".", "einsum", "(", "'bhij,bhjd->bhid'", ",", "attn", ",", "v", ")", "#product of v times whatever inside softmax", "\n", "out", "=", "rearrange", "(", "out", ",", "'b h n d -> b n (h d)'", ")", "#concat heads into one matrix, ready for next encoder block", "\n", "out", "=", "self", ".", "nn1", "(", "out", ")", "\n", "out", "=", "self", ".", "do1", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.Transformer.__init__": [[82, 89], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "torch.nn.ModuleList", "range", "transformer.Transformer.layers.append", "torch.nn.ModuleList", "torch.nn.ModuleList", "transformer.Residual", "transformer.Residual", "transformer.LayerNormalize", "transformer.LayerNormalize", "transformer.Attention", "transformer.MLP_Block"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", ",", "depth", ",", "heads", ",", "mlp_dim", ",", "dropout", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", "[", "]", ")", "\n", "for", "_", "in", "range", "(", "depth", ")", ":", "\n", "            ", "self", ".", "layers", ".", "append", "(", "nn", ".", "ModuleList", "(", "[", "\n", "Residual", "(", "LayerNormalize", "(", "dim", ",", "Attention", "(", "dim", ",", "heads", "=", "heads", ",", "dropout", "=", "dropout", ")", ")", ")", ",", "\n", "Residual", "(", "LayerNormalize", "(", "dim", ",", "MLP_Block", "(", "dim", ",", "mlp_dim", ",", "dropout", "=", "dropout", ")", ")", ")", "\n", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.models.transformer.Transformer.forward": [[90, 95], ["attention", "mlp"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "for", "attention", ",", "mlp", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "attention", "(", "x", ",", "mask", "=", "mask", ")", "# go to attention", "\n", "x", "=", "mlp", "(", "x", ")", "#go to MLP_Block", "\n", "", "return", "x", "", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_lmstar.sort_key": [[15, 20], ["int", "file.split", "file_name.split", "[].split", "file_name.split", "file_name.split"], "function", ["None"], ["def", "sort_key", "(", "file", ")", ":", "\n", "  ", "file_name", "=", "file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "num_agents", "=", "int", "(", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "\n", "base_name", "=", "file_name", ".", "split", "(", "'_'", "+", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "[", "0", "]", "\n", "return", "(", "base_name", ",", "num_agents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_lmstar.get_multi_agent_costs_to_go": [[21, 37], ["len", "numpy.zeros", "range", "range", "len"], "function", ["None"], ["", "def", "get_multi_agent_costs_to_go", "(", "path", ",", "goals", ")", ":", "\n", "  ", "n", "=", "len", "(", "goals", ")", "\n", "mac", "=", "np", ".", "zeros", "(", "n", ")", "\n", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "    ", "cost", "=", "0", "\n", "for", "j", "in", "range", "(", "1", ",", "len", "(", "path", ")", ")", ":", "\n", "      ", "if", "path", "[", "j", "]", "[", "i", "]", "==", "goals", "[", "i", "]", ":", "\n", "          ", "break", "\n", "", "if", "j", "!=", "0", "and", "path", "[", "j", "]", "[", "i", "]", "==", "path", "[", "j", "-", "1", "]", "[", "i", "]", ":", "\n", "        ", "continue", "\n", "", "cost", "+=", "1", "\n", "\n", "", "mac", "[", "i", "]", "=", "cost", "\n", "\n", "", "return", "mac", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_lmstar.extract_collision_information": [[38, 46], ["set", "set", "set.add", "set.update", "len", "len"], "function", ["None"], ["", "def", "extract_collision_information", "(", "collisions", ")", ":", "\n", "  ", "coords", "=", "set", "(", ")", "\n", "agents", "=", "set", "(", ")", "\n", "for", "col", "in", "collisions", ":", "\n", "    ", "coords", ".", "add", "(", "col", "[", "0", "]", ")", "\n", "agents", ".", "update", "(", "col", "[", "1", "]", ")", "\n", "\n", "", "return", "len", "(", "coords", ")", ",", "len", "(", "agents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_lmstar.solve_mapf_instances": [[47, 141], ["dict", "print", "numpy.array", "len", "print", "numpy.array", "json.dump", "json.load", "file.split", "file_name.split", "os.path.exists", "os.path.exists", "print", "len", "len", "int", "od_mstar.find_path", "numpy.sum", "test_lmstar.extract_collision_information", "print", "print", "print", "print", "print", "print", "print", "print", "open", "open", "print", "test_lmstar.get_multi_agent_costs_to_go", "print", "traceback.print_exc", "print", "[].split", "min", "file_name.split", "file_name.split"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_mstar.extract_collision_information", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_mstar.get_multi_agent_costs_to_go"], ["", "def", "solve_mapf_instances", "(", "inputs", ",", "output_dir", ",", "model_dir", ",", "trained_model", ",", "inflation", ")", ":", "\n", "  ", "track_failed", "=", "dict", "(", ")", "\n", "for", "file", "in", "inputs", ":", "\n", "    ", "print", "(", "'Working on file: '", ",", "file", ")", "\n", "\n", "try", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "open", "(", "file", ",", "'r'", ")", ")", "\n", "", "except", ":", "\n", "        ", "continue", "\n", "\n", "", "map_dim", "=", "data", "[", "'map_dim'", "]", "\n", "world", "=", "np", ".", "array", "(", "data", "[", "'world'", "]", ")", "\n", "obs", "=", "data", "[", "'obs'", "]", "\n", "num_agents", "=", "len", "(", "data", "[", "'init_pos'", "]", ")", "\n", "file_name", "=", "file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "base_name", "=", "file_name", ".", "split", "(", "'_'", "+", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "[", "0", "]", "\n", "out_file", "=", "output_dir", "+", "file_name", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "out_file", ")", "or", "os", ".", "path", ".", "exists", "(", "out_file", "+", "'.json'", ")", ":", "\n", "      ", "print", "(", "'Already done.'", ")", "\n", "continue", "\n", "\n", "", "assert", "len", "(", "data", "[", "'init_pos'", "]", ")", "==", "len", "(", "data", "[", "'goals'", "]", ")", "==", "int", "(", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "\n", "\n", "print", "(", "'Base Name: '", ",", "base_name", ")", "\n", "\n", "if", "base_name", "in", "track_failed", ":", "\n", "      ", "if", "num_agents", ">", "track_failed", "[", "base_name", "]", ":", "\n", "        ", "print", "(", "'Skipping on {} agents as it failed on {} agents before.'", ".", "format", "(", "num_agents", ",", "track_failed", "[", "base_name", "]", ")", ")", "\n", "continue", "\n", "\n", "", "", "model_config", "=", "{", "}", "\n", "model_config", "[", "'model_loc'", "]", "=", "model_dir", "\n", "model_config", "[", "'model_weights'", "]", "=", "trained_model", "\n", "model_config", "[", "'out_dim'", "]", "=", "32", "\n", "model_config", "[", "'batch_size'", "]", "=", "64", "\n", "model_config", "[", "'input_channels'", "]", "=", "10", "\n", "\n", "model_data", "=", "{", "}", "\n", "model_data", "[", "'obs'", "]", "=", "obs", "\n", "\n", "init_pos", "=", "data", "[", "'init_pos'", "]", "\n", "goals", "=", "data", "[", "'goals'", "]", "\n", "all_costs_to_go", "=", "np", ".", "array", "(", "data", "[", "'all_costs_to_go'", "]", ")", "\n", "\n", "model_data", "[", "'init_pos'", "]", "=", "init_pos", "\n", "model_data", "[", "'goals'", "]", "=", "goals", "\n", "model_data", "[", "'all_costs_to_go'", "]", "=", "all_costs_to_go", "\n", "model_data", "[", "'map_dim'", "]", "=", "map_dim", "\n", "model_data", "[", "'world'", "]", "=", "world", "\n", "\n", "model_config", "[", "'data'", "]", "=", "model_data", "\n", "\n", "try", ":", "\n", "      ", "lm_output", "=", "od_mstar", ".", "find_path", "(", "world", ",", "init_pos", ",", "goals", ",", "model_config", ",", "astar", "=", "True", ",", "recursive", "=", "False", ",", "inflation", "=", "inflation", ",", "time_limit", "=", "300", ",", "connect_8", "=", "False", ",", "return_memory", "=", "True", ")", "\n", "mac", "=", "np", ".", "sum", "(", "get_multi_agent_costs_to_go", "(", "lm_output", "[", "'path'", "]", ",", "goals", ")", ")", "\n", "num_unique_collision_coords", ",", "num_agents_colliding", "=", "extract_collision_information", "(", "lm_output", "[", "'collisions'", "]", ")", "\n", "\n", "print", "(", "'Sum of Costs: '", ",", "mac", ")", "\n", "print", "(", "'Time taken: '", ",", "lm_output", "[", "'time_taken'", "]", ")", "\n", "print", "(", "'Nodes Popped: '", ",", "lm_output", "[", "'nodes_popped'", "]", ")", "\n", "print", "(", "'Graph Size: '", ",", "lm_output", "[", "'corrected_graph_size'", "]", ")", "\n", "print", "(", "'Max collision set size: '", ",", "lm_output", "[", "'max_collision_set_size'", "]", ")", "\n", "print", "(", "'No. of unique collision coords: '", ",", "num_unique_collision_coords", ")", "\n", "print", "(", "'No. of unique agents colliding: '", ",", "num_agents_colliding", ")", "\n", "print", "(", "'No. of total collisions: '", ",", "lm_output", "[", "'total_collisions'", "]", ")", "\n", "\n", "if", "base_name", "in", "track_failed", "and", "track_failed", "[", "base_name", "]", "<", "num_agents", "+", "5", ":", "\n", "          ", "print", "(", "'Giving a buffer of 10 agents: '", ",", "num_agents", "+", "5", ")", "\n", "track_failed", "[", "base_name", "]", "=", "num_agents", "+", "5", "\n", "\n", "", "", "except", "Exception", ":", "\n", "      ", "traceback", ".", "print_exc", "(", ")", "\n", "if", "base_name", "not", "in", "track_failed", ":", "\n", "          ", "track_failed", "[", "base_name", "]", "=", "num_agents", "+", "5", "\n", "", "else", ":", "\n", "          ", "track_failed", "[", "base_name", "]", "=", "min", "(", "num_agents", "+", "5", ",", "track_failed", "[", "base_name", "]", ")", "\n", "", "print", "(", "'Failure tracking: '", ",", "track_failed", "[", "base_name", "]", ")", "\n", "continue", "\n", "\n", "", "lm_output", "[", "'mac'", "]", "=", "mac", "\n", "lm_output", "[", "'num_unique_collision_coords'", "]", "=", "num_unique_collision_coords", "\n", "lm_output", "[", "'num_agents_colliding'", "]", "=", "num_agents_colliding", "\n", "\n", "output", "=", "{", "}", "\n", "\n", "output", "[", "'map_dim'", "]", "=", "map_dim", "\n", "output", "[", "'num_agents'", "]", "=", "num_agents", "\n", "output", "[", "'obs'", "]", "=", "obs", "\n", "output", "[", "'init_pos'", "]", "=", "init_pos", "\n", "output", "[", "'goals'", "]", "=", "goals", "\n", "output", "[", "'m_output'", "]", "=", "lm_output", "\n", "\n", "json", ".", "dump", "(", "output", ",", "open", "(", "out_file", ",", "'w'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.__init__": [[24, 52], ["torch.device", "torch.device", "torch.device", "torch.device", "numpy.array", "numpy.array", "sys.path.append", "ViTResNet", "learnt_predictor.Predictor.net.to", "learnt_predictor.Predictor.net.load_state_dict", "learnt_predictor.Predictor.net.eval", "numpy.ones", "dict", "torch.load", "torch.load", "torch.load", "torch.load", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.device", "torch.device", "torch.device", "torch.device"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "model_config", ")", ":", "\n", "    ", "self", ".", "data", "=", "model_config", "[", "'data'", "]", "\n", "self", ".", "model_loc", "=", "model_config", "[", "'model_loc'", "]", "\n", "self", ".", "model_weights", "=", "model_config", "[", "'model_weights'", "]", "\n", "self", ".", "out_dim", "=", "model_config", "[", "'out_dim'", "]", "\n", "self", ".", "input_channels", "=", "model_config", "[", "'input_channels'", "]", "\n", "self", ".", "batch_size", "=", "model_config", "[", "'batch_size'", "]", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "\n", "self", ".", "obs", "=", "[", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ")", "for", "x", "in", "self", ".", "data", "[", "'obs'", "]", "]", "\n", "self", ".", "goals", "=", "[", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ")", "for", "x", "in", "self", ".", "data", "[", "'goals'", "]", "]", "\n", "self", ".", "all_costs_to_go", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'all_costs_to_go'", "]", ")", "\n", "self", ".", "map_dim", "=", "self", ".", "data", "[", "'map_dim'", "]", "\n", "self", ".", "world", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'world'", "]", ")", "\n", "\n", "sys", ".", "path", ".", "append", "(", "self", ".", "model_loc", ")", "\n", "from", "model", "import", "ViTResNet", "\n", "from", "basic_block", "import", "BasicBlock", "\n", "\n", "self", ".", "net", "=", "ViTResNet", "(", "BasicBlock", ",", "[", "3", ",", "3", ",", "3", "]", ",", "self", ".", "batch_size", ")", "\n", "self", ".", "net", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "net", ".", "load_state_dict", "(", "torch", ".", "load", "(", "self", ".", "model_weights", ",", "map_location", "=", "torch", ".", "device", "(", "self", ".", "device", ")", ")", ")", "\n", "#switch model to eval mode to disable dropout", "\n", "self", ".", "net", ".", "eval", "(", ")", "\n", "\n", "self", ".", "model_input", "=", "np", ".", "ones", "(", "(", "self", ".", "batch_size", ",", "self", ".", "input_channels", ",", "self", ".", "out_dim", ",", "self", ".", "out_dim", ")", ",", "dtype", "=", "float", ")", "\n", "\n", "self", ".", "already_predicted", "=", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.prediction_already_done": [[53, 55], ["None"], "methods", ["None"], ["", "def", "prediction_already_done", "(", "self", ",", "init_pos", ")", ":", "\n", "    ", "return", "init_pos", "in", "self", ".", "already_predicted", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.get_normalised_and_padded_ctg": [[56, 67], ["numpy.max", "numpy.min", "numpy.copy", "len", "numpy.pad"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy"], ["", "def", "get_normalised_and_padded_ctg", "(", "self", ",", "cost_to_go", ",", "max_cost_possible", ",", "top_pad", ",", "bottom_pad", ",", "left_pad", ",", "right_pad", ")", ":", "\n", "    ", "max_current", "=", "np", ".", "max", "(", "cost_to_go", "[", "cost_to_go", "<=", "max_cost_possible", "]", ")", "\n", "min_current", "=", "np", ".", "min", "(", "cost_to_go", ")", "\n", "if", "len", "(", "cost_to_go", "[", "cost_to_go", ">=", "max_cost_possible", "]", ")", "!=", "0", ":", "\n", "      ", "new_max", "=", "max_current", "+", "(", "max_current", "-", "min_current", ")", "\n", "", "else", ":", "\n", "      ", "new_max", "=", "max_current", "\n", "", "cost_to_go", "[", "cost_to_go", ">=", "max_cost_possible", "]", "=", "new_max", "\n", "cost_to_go", "=", "np", ".", "copy", "(", "np", ".", "pad", "(", "cost_to_go", ",", "(", "(", "top_pad", ",", "bottom_pad", ")", ",", "(", "left_pad", ",", "right_pad", ")", ")", ",", "mode", "=", "'constant'", ",", "constant_values", "=", "new_max", ")", ")", "\n", "cost_to_go", "=", "(", "cost_to_go", "-", "min_current", ")", "/", "(", "new_max", "-", "min_current", ")", "\n", "return", "cost_to_go", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.prepare_input_data": [[68, 160], ["numpy.floor().astype", "numpy.ceil().astype", "numpy.ceil().astype", "numpy.floor().astype", "numpy.copy", "numpy.zeros", "len", "range", "numpy.pad", "numpy.copy", "learnt_predictor.Predictor.get_normalised_and_padded_ctg", "numpy.zeros", "range", "numpy.copy", "numpy.floor", "numpy.ceil", "numpy.ceil", "numpy.floor", "numpy.array", "learnt_predictor.Predictor.get_normalised_and_padded_ctg", "learnt_predictor.Predictor.get_normalised_and_padded_ctg", "numpy.array", "Exception"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.get_normalised_and_padded_ctg", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.get_normalised_and_padded_ctg", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.get_normalised_and_padded_ctg"], ["", "def", "prepare_input_data", "(", "self", ",", "init_pos", ",", "model_input", ",", "input_channels", ",", "out_dim", ",", "map_dim", ",", "world", ",", "goals", ",", "all_costs_to_go", ")", ":", "\n", "    ", "top_pad", "=", "np", ".", "floor", "(", "(", "out_dim", "-", "map_dim", "[", "0", "]", ")", "/", "2", ")", ".", "astype", "(", "int", ")", "\n", "bottom_pad", "=", "np", ".", "ceil", "(", "(", "out_dim", "-", "map_dim", "[", "0", "]", ")", "/", "2", ")", ".", "astype", "(", "int", ")", "\n", "right_pad", "=", "np", ".", "ceil", "(", "(", "out_dim", "-", "map_dim", "[", "1", "]", ")", "/", "2", ")", ".", "astype", "(", "int", ")", "\n", "left_pad", "=", "np", ".", "floor", "(", "(", "out_dim", "-", "map_dim", "[", "1", "]", ")", "/", "2", ")", ".", "astype", "(", "int", ")", "\n", "\n", "bottom_pad", "+=", "top_pad", "\n", "right_pad", "+=", "left_pad", "\n", "top_pad", "=", "0", "\n", "left_pad", "=", "0", "\n", "\n", "world_padded", "=", "np", ".", "copy", "(", "np", ".", "pad", "(", "world", ",", "(", "(", "top_pad", ",", "bottom_pad", ")", ",", "(", "left_pad", ",", "right_pad", ")", ")", ",", "mode", "=", "'constant'", ",", "constant_values", "=", "1", ")", ")", "\n", "\n", "X_base", "=", "np", ".", "zeros", "(", "(", "input_channels", ",", "out_dim", ",", "out_dim", ")", ")", "\n", "X_base", "[", "0", "]", "=", "world_padded", "\n", "\n", "num_agents", "=", "len", "(", "init_pos", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_agents", ")", ":", "\n", "      ", "X", "=", "np", ".", "copy", "(", "X_base", ")", "\n", "start", "=", "init_pos", "[", "i", "]", "\n", "end", "=", "goals", "[", "i", "]", "\n", "\n", "X", "[", "1", "]", "[", "start", "[", "0", "]", "]", "[", "start", "[", "1", "]", "]", "=", "1", "\n", "X", "[", "2", "]", "[", "end", "[", "0", "]", "]", "[", "end", "[", "1", "]", "]", "=", "1", "\n", "\n", "X", "[", "3", "]", "=", "self", ".", "get_normalised_and_padded_ctg", "(", "np", ".", "array", "(", "all_costs_to_go", "[", "i", "]", ")", ",", "map_dim", "[", "0", "]", "*", "map_dim", "[", "1", "]", ",", "top_pad", ",", "bottom_pad", ",", "left_pad", ",", "right_pad", ")", "\n", "\n", "rows", "=", "map_dim", "[", "0", "]", "\n", "cols", "=", "map_dim", "[", "1", "]", "\n", "\n", "sum_of_costs_to_go", "=", "np", ".", "zeros", "(", "(", "out_dim", ",", "out_dim", ")", ")", "\n", "\n", "for", "j", "in", "range", "(", "num_agents", ")", ":", "\n", "        ", "if", "i", "==", "j", ":", "\n", "          ", "continue", "\n", "\n", "", "other_start", "=", "init_pos", "[", "j", "]", "\n", "other_goal", "=", "goals", "[", "j", "]", "\n", "other_cost_to_go", "=", "self", ".", "get_normalised_and_padded_ctg", "(", "np", ".", "array", "(", "all_costs_to_go", "[", "j", "]", ")", ",", "map_dim", "[", "0", "]", "*", "map_dim", "[", "1", "]", ",", "top_pad", ",", "bottom_pad", ",", "left_pad", ",", "right_pad", ")", "\n", "\n", "X", "[", "4", "]", "[", "other_start", "[", "0", "]", "]", "[", "other_start", "[", "1", "]", "]", "=", "1", "\n", "X", "[", "5", "]", "[", "other_goal", "[", "0", "]", "]", "[", "other_goal", "[", "1", "]", "]", "=", "1", "\n", "\n", "sum_of_costs_to_go", "+=", "other_cost_to_go", "\n", "\n", "pos_x", "=", "other_start", "[", "0", "]", "\n", "pos_y", "=", "other_start", "[", "1", "]", "\n", "\n", "moves", "=", "3", "\n", "\n", "if", "input_channels", "==", "9", ":", "\n", "          ", "array_idx", "=", "6", "\n", "", "elif", "input_channels", "==", "10", ":", "\n", "          ", "array_idx", "=", "7", "\n", "", "else", ":", "\n", "          ", "raise", "Exception", "(", "'Unidentified no of input channels found.'", ")", "\n", "\n", "", "while", "moves", ">", "0", ":", "\n", "          ", "min_x", "=", "pos_x", "\n", "min_y", "=", "pos_y", "\n", "min_cost", "=", "map_dim", "[", "0", "]", "*", "map_dim", "[", "1", "]", "\n", "\n", "if", "pos_x", ">", "0", "and", "other_cost_to_go", "[", "pos_x", "-", "1", "]", "[", "pos_y", "]", "<", "min_cost", ":", "\n", "            ", "min_cost", "=", "other_cost_to_go", "[", "pos_x", "-", "1", "]", "[", "pos_y", "]", "\n", "min_x", "=", "pos_x", "-", "1", "\n", "min_y", "=", "pos_y", "\n", "", "if", "pos_x", "<", "rows", "-", "1", "and", "other_cost_to_go", "[", "pos_x", "+", "1", "]", "[", "pos_y", "]", "<", "min_cost", ":", "\n", "            ", "min_cost", "=", "other_cost_to_go", "[", "pos_x", "+", "1", "]", "[", "pos_y", "]", "\n", "min_x", "=", "pos_x", "+", "1", "\n", "min_y", "=", "pos_y", "\n", "", "if", "pos_y", ">", "0", "and", "other_cost_to_go", "[", "pos_x", "]", "[", "pos_y", "-", "1", "]", "<", "min_cost", ":", "\n", "            ", "min_cost", "=", "other_cost_to_go", "[", "pos_x", "]", "[", "pos_y", "-", "1", "]", "\n", "min_x", "=", "pos_x", "\n", "min_y", "=", "pos_y", "-", "1", "\n", "", "if", "pos_y", "<", "cols", "-", "1", "and", "other_cost_to_go", "[", "pos_x", "]", "[", "pos_y", "+", "1", "]", "<", "min_cost", ":", "\n", "            ", "min_cost", "=", "other_cost_to_go", "[", "pos_x", "]", "[", "pos_y", "+", "1", "]", "\n", "min_x", "=", "pos_x", "\n", "min_y", "=", "pos_y", "+", "1", "\n", "\n", "", "X", "[", "array_idx", "]", "[", "min_x", "]", "[", "min_y", "]", "=", "1", "\n", "\n", "pos_x", "=", "min_x", "\n", "pos_y", "=", "min_y", "\n", "\n", "moves", "-=", "1", "\n", "array_idx", "+=", "1", "\n", "\n", "", "", "if", "input_channels", "==", "10", ":", "\n", "        ", "X", "[", "6", "]", "=", "self", ".", "get_normalised_and_padded_ctg", "(", "sum_of_costs_to_go", ",", "map_dim", "[", "0", "]", "*", "map_dim", "[", "1", "]", ",", "0", ",", "0", ",", "0", ",", "0", ")", "\n", "\n", "", "model_input", "[", "i", "]", "=", "np", ".", "copy", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.predict": [[161, 205], ["numpy.copy", "learnt_predictor.Predictor.prepare_input_data", "torch.log_softmax", "torch.log_softmax", "list", "range", "tuple", "learnt_predictor.Predictor.net", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "len", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "tuple", "new_coords.append", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "move.item", "move.item"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.prepare_input_data"], ["", "", "def", "predict", "(", "self", ",", "init_pos", ")", ":", "\n", "    ", "model_input", "=", "np", ".", "copy", "(", "self", ".", "model_input", ")", "\n", "input_channels", "=", "self", ".", "input_channels", "\n", "out_dim", "=", "self", ".", "out_dim", "\n", "map_dim", "=", "self", ".", "map_dim", "\n", "world", "=", "self", ".", "world", "\n", "goals", "=", "self", ".", "goals", "\n", "all_costs_to_go", "=", "self", ".", "all_costs_to_go", "\n", "device", "=", "self", ".", "device", "\n", "\n", "self", ".", "prepare_input_data", "(", "init_pos", ",", "model_input", ",", "input_channels", ",", "out_dim", ",", "map_dim", ",", "world", ",", "goals", ",", "all_costs_to_go", ")", "\n", "\n", "output", "=", "F", ".", "log_softmax", "(", "self", ".", "net", "(", "torch", ".", "from_numpy", "(", "model_input", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "_", ",", "indices", "=", "list", "(", "torch", ".", "sort", "(", "output", ",", "dim", "=", "1", ",", "descending", "=", "True", ")", ")", "\n", "#print(indices[: len(init_pos)])", "\n", "\n", "rows", "=", "map_dim", "[", "0", "]", "\n", "cols", "=", "map_dim", "[", "1", "]", "\n", "\n", "new_coords", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "init_pos", ")", ")", ":", "\n", "      ", "start_x", "=", "init_pos", "[", "i", "]", "[", "0", "]", "\n", "start_y", "=", "init_pos", "[", "i", "]", "[", "1", "]", "\n", "\"\"\"\n      if start_x == goals[i][0] and start_y == goals[i][1]:\n        new_coords.append((start_x, start_y))\n        continue\n      \"\"\"", "\n", "for", "move", "in", "indices", "[", "i", "]", ":", "\n", "        ", "new_x", "=", "start_x", "+", "moves", "[", "move", ".", "item", "(", ")", "]", "[", "0", "]", "\n", "new_y", "=", "start_y", "+", "moves", "[", "move", ".", "item", "(", ")", "]", "[", "1", "]", "\n", "\n", "if", "(", "new_x", ",", "new_y", ")", "in", "self", ".", "obs", ":", "\n", "          ", "continue", "\n", "\n", "", "if", "new_x", ">=", "0", "and", "new_x", "<", "rows", "and", "new_y", ">=", "0", "and", "new_y", "<", "cols", ":", "\n", "          ", "new_coords", ".", "append", "(", "(", "new_x", ",", "new_y", ")", ")", "\n", "break", "\n", "\n", "", "", "", "self", ".", "already_predicted", "[", "tuple", "(", "init_pos", ")", "]", "=", "tuple", "(", "new_coords", ")", "\n", "\n", "return", "new_coords", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_mstar.sort_key": [[18, 23], ["int", "file.split", "file_name.split", "[].split", "file_name.split", "file_name.split"], "function", ["None"], ["def", "sort_key", "(", "file", ")", ":", "\n", "  ", "file_name", "=", "file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "num_agents", "=", "int", "(", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "\n", "base_name", "=", "file_name", ".", "split", "(", "'_'", "+", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "[", "0", "]", "\n", "return", "(", "base_name", ",", "num_agents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_mstar.get_multi_agent_costs_to_go": [[24, 39], ["len", "numpy.zeros", "range", "range", "len"], "function", ["None"], ["", "def", "get_multi_agent_costs_to_go", "(", "path", ",", "goals", ")", ":", "\n", "  ", "n", "=", "len", "(", "goals", ")", "\n", "mac", "=", "np", ".", "zeros", "(", "n", ")", "\n", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "    ", "cost", "=", "0", "\n", "for", "j", "in", "range", "(", "1", ",", "len", "(", "path", ")", ")", ":", "\n", "      ", "if", "path", "[", "j", "]", "[", "i", "]", "==", "goals", "[", "i", "]", ":", "\n", "          ", "break", "\n", "", "if", "path", "[", "j", "]", "[", "i", "]", "==", "path", "[", "j", "-", "1", "]", "[", "i", "]", ":", "\n", "        ", "continue", "\n", "", "cost", "+=", "1", "\n", "", "mac", "[", "i", "]", "=", "cost", "\n", "\n", "", "return", "mac", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_mstar.extract_collision_information": [[40, 48], ["set", "set", "set.add", "set.update", "len", "len"], "function", ["None"], ["", "def", "extract_collision_information", "(", "collisions", ")", ":", "\n", "  ", "coords", "=", "set", "(", ")", "\n", "agents", "=", "set", "(", ")", "\n", "for", "col", "in", "collisions", ":", "\n", "    ", "coords", ".", "add", "(", "col", "[", "0", "]", ")", "\n", "agents", ".", "update", "(", "col", "[", "1", "]", ")", "\n", "\n", "", "return", "len", "(", "coords", ")", ",", "len", "(", "agents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_mstar.solve_mapf_instances": [[49, 124], ["dict", "print", "resource.setrlimit", "numpy.array", "len", "print", "json.dump", "json.load", "file.split", "file_name.split", "os.path.exists", "os.path.exists", "print", "len", "len", "int", "od_mstar.find_path", "numpy.sum", "test_mstar.extract_collision_information", "print", "print", "print", "print", "print", "print", "print", "print", "open", "open", "print", "test_mstar.get_multi_agent_costs_to_go", "print", "traceback.print_exc", "print", "[].split", "min", "file_name.split", "file_name.split"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_mstar.extract_collision_information", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.test_mstar.get_multi_agent_costs_to_go"], ["", "def", "solve_mapf_instances", "(", "inputs", ",", "output_dir", ",", "inflation", ")", ":", "\n", "  ", "track_failed", "=", "dict", "(", ")", "\n", "for", "file", "in", "inputs", ":", "\n", "    ", "print", "(", "'Working on file: '", ",", "file", ")", "\n", "\n", "resource", ".", "setrlimit", "(", "resource", ".", "RLIMIT_AS", ",", "(", "2", "**", "34", ",", "2", "**", "34", ")", ")", "\n", "\n", "try", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "open", "(", "file", ",", "'r'", ")", ")", "\n", "", "except", ":", "\n", "        ", "continue", "\n", "\n", "", "world", "=", "np", ".", "array", "(", "data", "[", "'world'", "]", ")", "\n", "obs", "=", "data", "[", "'obs'", "]", "\n", "init_pos", "=", "data", "[", "'init_pos'", "]", "\n", "goals", "=", "data", "[", "'goals'", "]", "\n", "file_name", "=", "file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "num_agents", "=", "len", "(", "data", "[", "'init_pos'", "]", ")", "\n", "base_name", "=", "file_name", ".", "split", "(", "'_'", "+", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "[", "0", "]", "\n", "out_file", "=", "output_dir", "+", "file_name", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "out_file", ")", "or", "os", ".", "path", ".", "exists", "(", "out_file", "+", "'.json'", ")", ":", "\n", "      ", "print", "(", "'Already done.'", ")", "\n", "continue", "\n", "\n", "", "assert", "len", "(", "data", "[", "'init_pos'", "]", ")", "==", "len", "(", "data", "[", "'goals'", "]", ")", "==", "int", "(", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "\n", "\n", "print", "(", "'Base Name: '", ",", "base_name", ")", "\n", "\n", "if", "base_name", "in", "track_failed", ":", "\n", "      ", "if", "num_agents", ">", "track_failed", "[", "base_name", "]", ":", "\n", "        ", "print", "(", "'Skipping on {} agents as it failed on {} agents before.'", ".", "format", "(", "num_agents", ",", "track_failed", "[", "base_name", "]", ")", ")", "\n", "continue", "\n", "\n", "", "", "try", ":", "\n", "      ", "m_output", "=", "od_mstar", ".", "find_path", "(", "world", ",", "init_pos", ",", "goals", ",", "astar", "=", "True", ",", "recursive", "=", "False", ",", "inflation", "=", "inflation", ",", "time_limit", "=", "300", ",", "connect_8", "=", "False", ",", "return_memory", "=", "True", ")", "\n", "mac", "=", "np", ".", "sum", "(", "get_multi_agent_costs_to_go", "(", "m_output", "[", "'path'", "]", ",", "goals", ")", ")", "\n", "num_unique_collision_coords", ",", "num_agents_colliding", "=", "extract_collision_information", "(", "m_output", "[", "'collisions'", "]", ")", "\n", "\n", "print", "(", "'Sum of Costs: '", ",", "mac", ")", "\n", "print", "(", "'Time taken: '", ",", "m_output", "[", "'time_taken'", "]", ")", "\n", "print", "(", "'Nodes Popped: '", ",", "m_output", "[", "'nodes_popped'", "]", ")", "\n", "print", "(", "'Graph Size: '", ",", "m_output", "[", "'corrected_graph_size'", "]", ")", "\n", "print", "(", "'Max collision set size: '", ",", "m_output", "[", "'max_collision_set_size'", "]", ")", "\n", "print", "(", "'No. of unique collision coords: '", ",", "num_unique_collision_coords", ")", "\n", "print", "(", "'No. of unique agents colliding: '", ",", "num_agents_colliding", ")", "\n", "print", "(", "'No. of total collisions: '", ",", "m_output", "[", "'total_collisions'", "]", ")", "\n", "\n", "if", "base_name", "in", "track_failed", "and", "track_failed", "[", "base_name", "]", "<", "num_agents", "+", "5", ":", "\n", "          ", "print", "(", "'Giving a buffer of 10 agents: '", ",", "num_agents", "+", "5", ")", "\n", "track_failed", "[", "base_name", "]", "=", "num_agents", "+", "5", "\n", "\n", "", "", "except", "Exception", ":", "\n", "      ", "traceback", ".", "print_exc", "(", ")", "\n", "if", "base_name", "not", "in", "track_failed", ":", "\n", "          ", "track_failed", "[", "base_name", "]", "=", "num_agents", "+", "5", "\n", "", "else", ":", "\n", "          ", "track_failed", "[", "base_name", "]", "=", "min", "(", "num_agents", "+", "5", ",", "track_failed", "[", "base_name", "]", ")", "\n", "", "print", "(", "'Failure tracking: '", ",", "track_failed", "[", "base_name", "]", ")", "\n", "continue", "\n", "\n", "", "m_output", "[", "'mac'", "]", "=", "mac", "\n", "m_output", "[", "'num_unique_collision_coords'", "]", "=", "num_unique_collision_coords", "\n", "m_output", "[", "'num_agents_colliding'", "]", "=", "num_agents_colliding", "\n", "\n", "output", "=", "{", "}", "\n", "\n", "output", "[", "'map_dim'", "]", "=", "data", "[", "'map_dim'", "]", "\n", "output", "[", "'num_agents'", "]", "=", "num_agents", "\n", "output", "[", "'obs'", "]", "=", "obs", "\n", "output", "[", "'init_pos'", "]", "=", "init_pos", "\n", "output", "[", "'goals'", "]", "=", "goals", "\n", "output", "[", "'m_output'", "]", "=", "m_output", "\n", "\n", "json", ".", "dump", "(", "output", ",", "open", "(", "out_file", ",", "'w'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Graph_Interface.get_edge_cost": [[43, 46], ["None"], "methods", ["None"], ["def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Returns edge_cost of going from coord1 to coord2.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Graph_Interface.get_neighbors": [[47, 53], ["None"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the collision free neighbors of the specified coord.\n\n        Return value is a list of tuples each of which are a coordinate\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Policy_Interface.get_cost": [[74, 77], ["None"], "methods", ["None"], ["def", "get_cost", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"Returns the cost of moving from given position to goal\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Policy_Interface.get_edge_cost": [[78, 83], ["None"], "methods", ["None"], ["", "def", "get_edge_cost", "(", "self", ",", "config1", ",", "config2", ")", ":", "\n", "        ", "\"\"\"Returns the cost of traversing an edge in the underlying\n        graph\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Policy_Interface.get_step": [[84, 87], ["None"], "methods", ["None"], ["", "def", "get_step", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"Returns the configurations of the optimal neighbor of config\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Policy_Interface.get_neighbors": [[88, 97], ["None"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"Returns neighboring configurations of config\n\n        This function returns the configurations which are next to\n        config\n\n        Return list of tuples, each of which is a coordinate\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Policy_Interface.get_graph_size": [[98, 101], ["None"], "methods", ["None"], ["", "def", "get_graph_size", "(", "self", ",", "correct_for_size", "=", "True", ")", ":", "\n", "        ", "\"\"\"Returns number of nodes in graph\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Policy_Interface.get_limited_offset_neighbors": [[102, 105], ["None"], "methods", ["None"], ["", "def", "get_limited_offset_neighbors", "(", "self", ",", "config", ",", "max_offset", ",", "min_offset", "=", "0", ")", ":", "\n", "        ", "\"\"\"Returns set of neighbors between the offset arguments\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Policy_Interface.get_offset_neighbors": [[106, 109], ["None"], "methods", ["None"], ["", "def", "get_offset_neighbors", "(", "self", ",", "config", ",", "offset", ")", ":", "\n", "        ", "\"\"\"Returns neighbors of coord with offset specified by argument\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Policy_Interface.get_offsets": [[110, 113], ["None"], "methods", ["None"], ["", "def", "get_offsets", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"Return the offsets of the neighbors\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Config_Edge_Checker.col_check": [[118, 129], ["None"], "methods", ["None"], ["def", "col_check", "(", "self", ",", "state", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single state\n\n        state     - list of coordinates of robots\n        recursive - generate collisions sets for rM*\n\n        Returns:\n        M* collision set in type set if recursive false\n        rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.pass_through": [[138, 149], ["None"], "methods", ["None"], ["def", "pass_through", "(", "self", ",", "state1", ",", "state2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects pass through collisions\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state,\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.col_check": [[150, 161], ["None"], "methods", ["None"], ["", "def", "col_check", "(", "self", ",", "state", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single state\n\n        state     - list of coordinates of robots\n        recursive - generate collisions sets for rM*\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.cross_over": [[162, 174], ["None"], "methods", ["None"], ["", "def", "cross_over", "(", "self", ",", "state1", ",", "state2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over and pass through collisions\n\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.simple_pass_through": [[175, 186], ["None"], "methods", ["None"], ["", "def", "simple_pass_through", "(", "self", ",", "state1", ",", "state2", ")", ":", "\n", "        ", "\"\"\"Check for pass through collisions\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state\n\n        Returns:\n        True if pass through collision\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.simple_col_check": [[187, 197], ["None"], "methods", ["None"], ["", "def", "simple_col_check", "(", "self", ",", "state", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions at state,\n\n        state - list of robot coordinates\n\n        returns:\n        True if collision\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.simple_cross_over": [[198, 209], ["None"], "methods", ["None"], ["", "def", "simple_cross_over", "(", "self", ",", "state1", ",", "state2", ")", ":", "\n", "        ", "\"\"\"Check for cross over collisions in 8-connected worlds\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state\n\n        returns:\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.simple_incremental_cross_over": [[210, 225], ["None"], "methods", ["None"], ["", "def", "simple_incremental_cross_over", "(", "self", ",", "state1", ",", "state2", ")", ":", "\n", "        ", "\"\"\"Check for cross over collisions in 8-connected worlds.\n\n        Assumes that collision checking has been performed for everything\n        but the last robot in the coordinates.  To be used to save a bit\n        of time for partial expansion approaches\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state\n\n        returns:\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.simple_incremental_col_check": [[226, 240], ["None"], "methods", ["None"], ["", "def", "simple_incremental_col_check", "(", "self", ",", "state1", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions at c1,\n\n        Assumes that collision checking has been performed for everything\n        but the last robot in the coordinates.  To be used to save a bit\n        of time for partial expansion approaches\n\n        state1 - list of robot coordinates\n\n        returns:\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.single_bot_outpath_check": [[241, 256], ["None"], "methods", ["None"], ["", "def", "single_bot_outpath_check", "(", "self", ",", "cur_coord", ",", "prev_coord", ",", "cur_t", ",", "paths", ")", ":", "\n", "        ", "\"\"\"Tests for collisions from prev_coord to cur_coord\n\n        Checks for cross over collisions and collisions at the same\n        location when moving from cur_coord to prev_coord while robots\n        are moving in paths\n\n        cur_coord - position of a single robot\n\n        Returns:\n\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.simple_prio_col_check": [[257, 273], ["None"], "methods", ["None"], ["", "def", "simple_prio_col_check", "(", "self", ",", "coord", ",", "t", ",", "paths", ",", "pcoord", "=", "None", ",", "\n", "conn_8", "=", "False", ")", ":", "\n", "        ", "\"\"\"Returns true, if collision is detected, false otherwise\n        at the moment only used to check the obstacle collisions, but\n        didn't want to reject the other code already\n\n        coord - coord of potential new neighbor\n        t - current time step\n        paths - previously found paths\n        pcoord - previous coordinate of the path\n\n        Returns:\n        True if collision exists\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.incremental_col_check": [[274, 288], ["None"], "methods", ["None"], ["", "def", "incremental_col_check", "(", "self", ",", "state", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions in state\n\n        state     - list of coordinates of robots\n        recursive - generate collisions sets for rM*\n\n        Only checks whether the last robot is\n        involved in a collision, for use with incremental methods\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.incremental_cross_over": [[289, 304], ["None"], "methods", ["None"], ["", "def", "incremental_cross_over", "(", "self", ",", "state1", ",", "state2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions.\n\n        Only checks if the last robot is involved in a collision, for use\n        with partial expansion approaches.\n\n        state1 - list of robot coordinates describing initial state\n        state2 - list of robot coordinates describing final state,\n\n        Returns:\n            M* collision set in type set if recursive false\n            rM* collision set in type set if recursive true\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.single_bot_cross_over": [[305, 320], ["None"], "methods", ["None"], ["", "def", "single_bot_cross_over", "(", "self", ",", "coord1", ",", "pcoord1", ",", "coord2", ",", "pcoord2", ")", ":", "\n", "        ", "\"\"\"Checks for cross-over and collisions between robots 1 and 2\n\n        Robots are moving from pcoord to coord\n\n        pcoord1 - first position of first robot\n        coord1  - second position of first robot\n        pcoord2 - first position of second robot\n        coord2  - second position of second robot\n\n        Returns:\n        True if collision\n        False otherwise\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.interface.Planner_Edge_Checker.prio_col_check": [[321, 336], ["None"], "methods", ["None"], ["", "def", "prio_col_check", "(", "self", ",", "coord", ",", "pcoord", ",", "t", ",", "paths", "=", "None", ",", "conn_8", "=", "False", ",", "\n", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Collision checking with paths passed as constraints\n\n        coord  - current node\n        pcoord - previous node\n        t      - timestep\n        paths  - paths that need to be avoided\n\n        Returns: (collision sets are of type set)\n            M* collision set if collision exists and recursive is false\n            rM* collision set if collision exists and recursive is true\n            None if no collision exists\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.prune_graph.to_networkx_graph": [[6, 24], ["od_mstar3.workspace_graph.Astar_Graph", "networkx.DiGraph", "range", "nx.DiGraph.nodes", "len", "range", "workspace_graph.Astar_Graph.get_neighbors", "len", "nx.DiGraph.add_edge", "nx.DiGraph.add_node"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Graph", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors"], ["def", "to_networkx_graph", "(", "obs_map", ")", ":", "\n", "    ", "'''Reads in a standard obs_map list and converts it to a networkx\n    digraph\n    obs_map - list of lists, 0 for empty cell, 1 for obstacle'''", "\n", "#Create a workspace_graph object to generate neighbors", "\n", "g", "=", "workspace_graph", ".", "Astar_Graph", "(", "obs_map", ",", "[", "0", ",", "0", "]", ")", "\n", "G", "=", "nx", ".", "DiGraph", "(", ")", "#Creates the graph object", "\n", "#Populate graph with nodes", "\n", "for", "x", "in", "range", "(", "len", "(", "obs_map", ")", ")", ":", "\n", "        ", "for", "y", "in", "range", "(", "len", "(", "obs_map", "[", "x", "]", ")", ")", ":", "\n", "            ", "if", "obs_map", "[", "x", "]", "[", "y", "]", "==", "0", ":", "\n", "                ", "G", ".", "add_node", "(", "(", "x", ",", "y", ")", ")", "\n", "#Add edges", "\n", "", "", "", "for", "i", "in", "G", ".", "nodes", "(", ")", ":", "\n", "#Stored nodes by their coordinates in G", "\n", "        ", "for", "j", "in", "g", ".", "get_neighbors", "(", "i", ")", ":", "\n", "            ", "G", ".", "add_edge", "(", "i", ",", "j", ")", "\n", "", "", "return", "G", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.prune_graph.prune_opposing_edge": [[25, 68], ["networkx.number_strongly_connected_components", "networkx.edge_betweenness_centrality", "max", "G.copy", "G.copy.remove_edge", "nx.edge_betweenness_centrality.values", "nx.edge_betweenness_centrality.keys", "networkx.number_strongly_connected_components", "nx.edge_betweenness_centrality.pop", "G.neighbors", "nx.edge_betweenness_centrality.values().index", "G.edges", "nx.edge_betweenness_centrality.values"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.index"], ["", "def", "prune_opposing_edge", "(", "G", ",", "num_edges", "=", "1", ")", ":", "\n", "    ", "'''Reads in a networkx digraph and prunes the edge opposing the most\n    between (i.e. edge on the most shortest path connections).  If this edge\n    doesn't have an opposing edge, or if the removal of said edge would\n    reduce the connectivity of the space, the next most between edge is pruned\n    instead.  Since computing completeness can be expensive, allows multiple\n    edges to be pruned before computing the impact of said prunning on\n    completeness is computed'''", "\n", "#Get the current number of strongly connected components, can't decrease", "\n", "#without preventing some paths from being found", "\n", "num_components", "=", "nx", ".", "number_strongly_connected_components", "(", "G", ")", "\n", "pruned", "=", "0", "\n", "# print 'computing betweeness'", "\n", "betweenness", "=", "nx", ".", "edge_betweenness_centrality", "(", "G", ")", "\n", "# print 'betweenness computed'", "\n", "while", "pruned", "<", "num_edges", ":", "\n", "        ", "max_bet", "=", "max", "(", "betweenness", ".", "values", "(", ")", ")", "\n", "if", "max_bet", "<=", "0", ":", "\n", "#Set betweeness to -1 if can't prune, set to 0 not between", "\n", "            ", "return", "G", "\n", "", "edge", "=", "betweenness", ".", "keys", "(", ")", "[", "betweenness", ".", "values", "(", ")", ".", "index", "(", "max_bet", ")", "]", "\n", "if", "not", "(", "edge", "[", "1", "]", ",", "edge", "[", "0", "]", ")", "in", "G", ".", "edges", "(", ")", ":", "\n", "#Already been pruned", "\n", "            ", "betweenness", "[", "edge", "]", "=", "-", "1", "\n", "# print 'no edge'", "\n", "continue", "\n", "#Test if pruning the edge will break connectivity", "\n", "", "temp_graph", "=", "G", ".", "copy", "(", ")", "\n", "temp_graph", ".", "remove_edge", "(", "edge", "[", "1", "]", ",", "edge", "[", "0", "]", ")", "\n", "if", "num_components", "==", "nx", ".", "number_strongly_connected_components", "(", "temp_graph", ")", ":", "\n", "#Can safely prune this edge", "\n", "            ", "G", "=", "temp_graph", "\n", "pruned", "+=", "1", "\n", "betweenness", "[", "edge", "]", "=", "-", "1", "\n", "betweenness", ".", "pop", "(", "(", "edge", "[", "1", "]", ",", "edge", "[", "0", "]", ")", ")", "\n", "# print 'pruned'", "\n", "#Need to prevent further edges from being pruned from this vertex", "\n", "for", "neighbor", "in", "G", ".", "neighbors", "(", "edge", "[", "1", "]", ")", ":", "\n", "                ", "betweenness", "[", "(", "edge", "[", "1", "]", ",", "neighbor", ")", "]", "=", "-", "1", "\n", "", "", "else", ":", "\n", "            ", "betweenness", "[", "edge", "]", "=", "-", "1", "\n", "# print 'breaks con %s' %(str(edge))", "\n", "", "", "return", "G", "\n", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.__init__": [[78, 85], ["sorted", "key"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "iterable", "=", "(", ")", ",", "key", "=", "None", ")", ":", "\n", "        ", "self", ".", "_given_key", "=", "key", "\n", "key", "=", "(", "lambda", "x", ":", "x", ")", "if", "key", "is", "None", "else", "key", "\n", "decorated", "=", "sorted", "(", "(", "key", "(", "item", ")", ",", "item", ")", "for", "item", "in", "iterable", ")", "\n", "self", ".", "_keys", "=", "[", "k", "for", "k", ",", "item", "in", "decorated", "]", "\n", "self", ".", "_items", "=", "[", "item", "for", "k", ",", "item", "in", "decorated", "]", "\n", "self", ".", "_key", "=", "key", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection._getkey": [[86, 88], ["None"], "methods", ["None"], ["", "def", "_getkey", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_key", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection._setkey": [[89, 92], ["SortedCollection.SortedCollection.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["", "def", "_setkey", "(", "self", ",", "key", ")", ":", "\n", "        ", "if", "key", "is", "not", "self", ".", "_key", ":", "\n", "            ", "self", ".", "__init__", "(", "self", ".", "_items", ",", "key", "=", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection._delkey": [[93, 95], ["SortedCollection.SortedCollection._setkey"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection._setkey"], ["", "", "def", "_delkey", "(", "self", ")", ":", "\n", "        ", "self", ".", "_setkey", "(", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.clear": [[98, 100], ["SortedCollection.SortedCollection.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["def", "clear", "(", "self", ")", ":", "\n", "        ", "self", ".", "__init__", "(", "[", "]", ",", "self", ".", "_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.copy": [[101, 103], ["SortedCollection.SortedCollection.__class__"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", "(", "self", ",", "self", ".", "_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.__len__": [[104, 106], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_items", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.__getitem__": [[107, 109], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "self", ".", "_items", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.__iter__": [[110, 112], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "_items", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.__reversed__": [[113, 115], ["reversed"], "methods", ["None"], ["", "def", "__reversed__", "(", "self", ")", ":", "\n", "        ", "return", "reversed", "(", "self", ".", "_items", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.__repr__": [[116, 121], ["getattr", "repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'%s(%r, key=%s)'", "%", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "\n", "self", ".", "_items", ",", "\n", "getattr", "(", "self", ".", "_given_key", ",", "'__name__'", ",", "repr", "(", "self", ".", "_given_key", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.__reduce__": [[123, 125], ["None"], "methods", ["None"], ["", "def", "__reduce__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ",", "(", "self", ".", "_items", ",", "self", ".", "_given_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.__contains__": [[126, 134], ["SortedCollection.SortedCollection._key", "bisect.bisect_left", "bisect.bisect_right"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"So if an item has its key value changed, you are not going to\n        be able to recover its value\n        \"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "j", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "return", "item", "in", "self", ".", "_items", "[", "i", ":", "j", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.resort": [[135, 147], ["sorted", "SortedCollection.SortedCollection.key"], "methods", ["None"], ["", "def", "resort", "(", "self", ")", ":", "\n", "        ", "\"\"\"If all the key values are expected to have changed\n        dramatically, resort the items list, and regenerate the internal\n        representation\n\n        Note that this operation is not guaranteed to be stable, as it\n        depends on the ordering of a key, item pair, and the ordering of\n        the items is effectively arbitrary\n        \"\"\"", "\n", "decorated", "=", "sorted", "(", "(", "self", ".", "key", "(", "item", ")", ",", "item", ")", "for", "item", "in", "self", ".", "_items", ")", "\n", "self", ".", "_keys", "=", "[", "k", "for", "k", ",", "item", "in", "decorated", "]", "\n", "self", ".", "_items", "=", "[", "item", "for", "k", ",", "item", "in", "decorated", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.index": [[148, 154], ["SortedCollection.SortedCollection._key", "bisect.bisect_left", "bisect.bisect_right", "SortedCollection.SortedCollection._items[].index"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.index"], ["", "def", "index", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Find the position of an item.  Raise ValueError if not found.\"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "j", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "return", "self", ".", "_items", "[", "i", ":", "j", "]", ".", "index", "(", "item", ")", "+", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.count": [[155, 161], ["SortedCollection.SortedCollection._key", "bisect.bisect_left", "bisect.bisect_right", "SortedCollection.SortedCollection._items[].count"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.count"], ["", "def", "count", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Return number of occurrences of item\"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "j", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "return", "self", ".", "_items", "[", "i", ":", "j", "]", ".", "count", "(", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert": [[162, 168], ["SortedCollection.SortedCollection._key", "bisect.bisect_left", "SortedCollection.SortedCollection._keys.insert", "SortedCollection.SortedCollection._items.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], ["", "def", "insert", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Insert a new item.  If equal keys are found, add to the left\"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "self", ".", "_keys", ".", "insert", "(", "i", ",", "k", ")", "\n", "self", ".", "_items", ".", "insert", "(", "i", ",", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert_right": [[169, 175], ["SortedCollection.SortedCollection._key", "bisect.bisect_right", "SortedCollection.SortedCollection._keys.insert", "SortedCollection.SortedCollection._items.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], ["", "def", "insert_right", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Insert a new item.  If equal keys are found, add to the right\"\"\"", "\n", "k", "=", "self", ".", "_key", "(", "item", ")", "\n", "i", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "self", ".", "_keys", ".", "insert", "(", "i", ",", "k", ")", "\n", "self", ".", "_items", ".", "insert", "(", "i", ",", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.remove": [[176, 184], ["SortedCollection.SortedCollection.index"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.index"], ["", "def", "remove", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Remove first occurence of item.\n\n        Raise ValueError if not found\n        \"\"\"", "\n", "i", "=", "self", ".", "index", "(", "item", ")", "\n", "del", "self", ".", "_keys", "[", "i", "]", "\n", "del", "self", ".", "_items", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop": [[185, 189], ["SortedCollection.SortedCollection._items.pop"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop"], ["", "def", "pop", "(", "self", ")", ":", "\n", "        ", "\"\"\"returns the rightmost value (greatest key value)\"\"\"", "\n", "del", "self", ".", "_keys", "[", "-", "1", "]", "\n", "return", "self", ".", "_items", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.consistent_pop": [[190, 202], ["SortedCollection.SortedCollection._keys.pop", "SortedCollection.SortedCollection._items.pop", "SortedCollection.SortedCollection._key"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop"], ["", "def", "consistent_pop", "(", "self", ")", ":", "\n", "        ", "\"\"\"returns the rightmost value (greatest key value) and checks\n        whether its cached key value is consistent with its current\n        cost.\n\n        returns:\n          value with greatest cached key\n          boolean: True if cached key is same as current key\n        \"\"\"", "\n", "cached_key", "=", "self", ".", "_keys", ".", "pop", "(", ")", "\n", "val", "=", "self", ".", "_items", ".", "pop", "(", ")", "\n", "return", "val", ",", "self", ".", "_key", "(", "val", ")", "==", "cached_key", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.find": [[203, 214], ["bisect.bisect_left", "ValueError", "len"], "methods", ["None"], ["", "def", "find", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return first item with a key == k.\n        Will fail if the key value of k was changed since it was\n        inserted\n\n        Raise ValueError if not found.\n        \"\"\"", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", "!=", "len", "(", "self", ")", "and", "self", ".", "_keys", "[", "i", "]", "==", "k", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key equal to: %r'", "%", "(", "k", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.find_le": [[215, 224], ["bisect.bisect_right", "ValueError"], "methods", ["None"], ["", "def", "find_le", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return last item with a key <= k.\n\n        Raise ValueError if not found.\n        \"\"\"", "\n", "i", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "-", "1", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key at or below: %r'", "%", "(", "k", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.find_lt": [[225, 234], ["bisect.bisect_left", "ValueError"], "methods", ["None"], ["", "def", "find_lt", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return last item with a key < k.\n\n        Raise ValueError if not found.\n        \"\"\"", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "-", "1", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key below: %r'", "%", "(", "k", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.find_ge": [[235, 244], ["bisect.bisect_left", "ValueError", "len"], "methods", ["None"], ["", "def", "find_ge", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return first item with a key >= equal to k.\n\n        Raise ValueError if not found\n        \"\"\"", "\n", "i", "=", "bisect_left", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", "!=", "len", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key at or above: %r'", "%", "(", "k", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.find_gt": [[245, 254], ["bisect.bisect_right", "ValueError", "len"], "methods", ["None"], ["", "def", "find_gt", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"Return first item with a key > k.\n\n        Raise ValueError if not found\n        \"\"\"", "\n", "i", "=", "bisect_right", "(", "self", ".", "_keys", ",", "k", ")", "\n", "if", "i", "!=", "len", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "_items", "[", "i", "]", "\n", "", "raise", "ValueError", "(", "'No item found with key above: %r'", "%", "(", "k", ",", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.OutOfTimeError.__init__": [[163, 165], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "value", "=", "None", ")", ":", "\n", "        ", "self", ".", "value", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.OutOfTimeError.__str__": [[166, 168], ["repr"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.NoSolutionError.__init__": [[171, 173], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "value", "=", "None", ")", ":", "\n", "        ", "self", ".", "value", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.NoSolutionError.__str__": [[174, 176], ["repr"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.OutOfScopeError.__init__": [[179, 182], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "value", "=", "None", ",", "col_set", "=", "(", ")", ")", ":", "\n", "        ", "self", ".", "value", "=", "value", "\n", "self", ".", "col_set", "=", "col_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.OutOfScopeError.__str__": [[183, 185], ["repr"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "value", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.add_col_set_recursive": [[8, 53], ["list", "list", "tuple", "len", "len", "list.append", "c2[].isdisjoint", "c2[].issuperset", "list.pop", "list.append", "list.pop", "list.pop", "c2.pop.union", "list.pop"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop"], ["def", "add_col_set_recursive", "(", "c1", ",", "c2", ")", ":", "\n", "    ", "\"\"\"Returns a new collision set resulting from adding c1 to c2.  No\n    side effecting\n\n    collision set is done for the recursive case, where\n    ({1, 2}, ) + ({3, 4}, ) = ({1, 2}, {3, 4})\n\n    c1, c2 - tuples of (immutable) sets\n\n    returns:\n    recursive collision set containing c1 and c2\n\n    \"\"\"", "\n", "# Make shallow copies", "\n", "c1", "=", "list", "(", "c1", ")", "\n", "c2", "=", "list", "(", "c2", ")", "\n", "while", "len", "(", "c1", ")", ">", "0", ":", "\n", "        ", "i", "=", "0", "\n", "# Whether c1[-1] overlaps with any element of c2", "\n", "found_overlap", "=", "False", "\n", "while", "i", "<", "len", "(", "c2", ")", ":", "\n", "            ", "if", "not", "c2", "[", "i", "]", ".", "isdisjoint", "(", "c1", "[", "-", "1", "]", ")", ":", "\n", "# Found overlap", "\n", "                ", "if", "c2", "[", "i", "]", ".", "issuperset", "(", "c1", "[", "-", "1", "]", ")", ":", "\n", "# No change in c2", "\n", "                    ", "c1", ".", "pop", "(", ")", "\n", "found_overlap", "=", "True", "\n", "break", "\n", "# Have found a non-trivial overlap.  Need to add the", "\n", "# union to  c1 so that we can check if the union has any", "\n", "# further overlap with elements of c2", "\n", "", "temp", "=", "c2", ".", "pop", "(", "i", ")", "\n", "# replace c2[i] with the union of c2[i] and c1[-1]", "\n", "c1", ".", "append", "(", "temp", ".", "union", "(", "c1", ".", "pop", "(", ")", ")", ")", "\n", "found_overlap", "=", "True", "\n", "break", "\n", "", "else", ":", "\n", "# No overlap between c1[-1] and c2[i], so check next", "\n", "# element of c2", "\n", "                ", "i", "+=", "1", "\n", "", "", "if", "not", "found_overlap", ":", "\n", "# c1[-1] has no overlap with any element of c2, so it can be", "\n", "# added as is to c2", "\n", "            ", "c2", ".", "append", "(", "c1", ".", "pop", "(", ")", ")", "\n", "", "", "return", "tuple", "(", "c2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.add_col_set": [[55, 75], ["frozenset", "len", "temp.union.union", "len", "len"], "function", ["None"], ["", "def", "add_col_set", "(", "c1", ",", "c2", ")", ":", "\n", "    ", "\"\"\"Adds the collision sets c1 to c2.  c2 is assumed to contain a\n    single,\n    possibly empty, set\n\n    c1, c2 - input collision sets\n\n    returns:\n    combined collision set containing c1 and c2\n\n    \"\"\"", "\n", "temp", "=", "frozenset", "(", "[", "]", ")", "\n", "if", "len", "(", "c2", ")", ">=", "1", ":", "\n", "        ", "temp", "=", "c2", "[", "0", "]", "\n", "assert", "len", "(", "c2", ")", "==", "1", "\n", "", "for", "i", "in", "c1", ":", "\n", "        ", "temp", "=", "temp", ".", "union", "(", "i", ")", "\n", "", "if", "len", "(", "temp", ")", "==", "0", ":", "\n", "        ", "return", "(", ")", "\n", "", "return", "(", "temp", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add": [[77, 91], ["col_set_addition.add_col_set_recursive", "col_set_addition.add_col_set"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.add_col_set_recursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set"], ["", "def", "col_set_add", "(", "c1", ",", "c2", ",", "recursive", ")", ":", "\n", "    ", "\"\"\"Adds two collision sets\n\n    c1, c2     - input collision sets\n    recursive - boolean, whether to perform recursive M* style addition\n\n    returns:\n    collision set containing c1 and c2\n\n    \"\"\"", "\n", "if", "recursive", ":", "\n", "        ", "return", "add_col_set_recursive", "(", "c1", ",", "c2", ")", "\n", "", "else", ":", "\n", "        ", "return", "add_col_set", "(", "c1", ",", "c2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.effective_col_set": [[93, 160], ["list", "list", "effective_set.extend", "tuple", "len", "len", "col_set[].issubset", "effective_set.append", "col_set_to_remove.append", "list.pop", "list.pop", "col_set[].isdisjoint", "list.pop", "list.extend"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop"], ["", "", "def", "effective_col_set", "(", "col_set", ",", "prev_col_set", ")", ":", "\n", "    ", "\"\"\"Computes the effective collision set to use given the current\n    collision set and the collision set used to get to the current node\n\n    Only makes sense when used with recursive M*\n\n    The purpose of this code is that in recursive M*, you invoke a\n    subplanner to figure out how to get to the goal, which caches the\n    entire path to the goal .  The next step, you have an empty\n    collision set, so you don't query the subplanner with the cached\n    path, and have to find a bunch of collisions before using the cached\n    solution.  This is intended for use with a memory of what the\n    collision set was when you reached a given node.\n\n    Computes the \"effecitve collision set\".  Elements of the memorized\n    collision set are used if they have no non-empty intersections with\n    elements of the current collision set that are not subsets of the\n    memorized component.\n\n    elements of col_set are NOT used if they are contained within some\n    element of prev_col_set that is used.  Elements of prev_col_set are\n    used if they completely contain all elements of col_set with which\n    they intersect\n\n    col_set      - current collision set\n    prev_col_set - \"memorized\" collision set, i.e. the collision set of\n                   the optimal predecessor at the time the path from the\n                   optimal predecessor was first found\n\n    returns:\n    effective collision set.  Consists of the elements of the previous\n    collision set, which should index subplanners which have cached\n    paths available, and elements of the current collision set which\n    are not contained within prev_col_set\n    \"\"\"", "\n", "effective_set", "=", "[", "]", "\n", "prev_col_set", "=", "list", "(", "prev_col_set", ")", "\n", "col_set", "=", "list", "(", "col_set", ")", "\n", "while", "(", "len", "(", "prev_col_set", ")", ">", "0", ")", ":", "\n", "# Need to keep around the elements of col_set that won't be", "\n", "# used, because the containing element of prev_col_set may be", "\n", "# invalidated by a later element of col_set", "\n", "        ", "col_set_to_remove", "=", "[", "]", "\n", "j", "=", "0", "\n", "while", "(", "j", "<", "len", "(", "col_set", ")", ")", ":", "\n", "            ", "if", "col_set", "[", "j", "]", ".", "issubset", "(", "prev_col_set", "[", "-", "1", "]", ")", ":", "\n", "# this element is contained in prev_col_set, so can be", "\n", "# skipped unless prev_col_set-1] is invalidated by some", "\n", "# later element of col_set", "\n", "                ", "col_set_to_remove", ".", "append", "(", "col_set", ".", "pop", "(", "j", ")", ")", "\n", "", "elif", "not", "col_set", "[", "j", "]", ".", "isdisjoint", "(", "prev_col_set", "[", "-", "1", "]", ")", ":", "\n", "# this element partially overlaps prev_col_set,", "\n", "# invalidating it, so cannot use this element of", "\n", "# prev_col_set", "\n", "                ", "prev_col_set", ".", "pop", "(", ")", "\n", "# return the elements of col_set we were going to remove", "\n", "col_set", ".", "extend", "(", "col_set_to_remove", ")", "\n", "break", "\n", "", "else", ":", "\n", "                ", "j", "+=", "1", "\n", "", "", "else", ":", "\n", "# Never broke, so prev_col_set can be used as part of the", "\n", "# effective collision set", "\n", "            ", "effective_set", ".", "append", "(", "prev_col_set", ".", "pop", "(", ")", ")", "\n", "# Just copy over any elements of col_set that survived", "\n", "", "", "effective_set", ".", "extend", "(", "col_set", ")", "\n", "return", "tuple", "(", "effective_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.__init__": [[161, 252], ["float", "len", "od_mstar.Od_Mstar.gen_policy_planners", "set", "set", "tuple", "workspace_graph.Edge_Checker", "print", "learnt_predictor.Predictor", "range", "len"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_policy_planners"], ["self", ".", "inflation", "=", "float", "(", "inflation", ")", "\n", "self", ".", "connect_8", "=", "connect_8", "\n", "self", ".", "astar", "=", "astar", "\n", "self", ".", "epeastar", "=", "epeastar", "\n", "self", ".", "offset_increment", "=", "offset_increment", "\n", "self", ".", "_makespan", "=", "makespan", "\n", "\n", "# Store some useful values", "\n", "self", ".", "updated", "=", "0", "\n", "self", ".", "num_bots", "=", "len", "(", "goals", ")", "\n", "# self.visualize = visualize", "\n", "self", ".", "full_space", "=", "full_space", "\n", "# Need a different key incorporating the offset for EPEM*", "\n", "if", "self", ".", "epeastar", ":", "\n", "            ", "self", ".", "open_list_key", "=", "lambda", "x", ":", "(", "-", "x", ".", "cost", "-", "x", ".", "h", "*", "self", ".", "inflation", "-", "\n", "x", ".", "offset", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "open_list_key", "=", "lambda", "x", ":", "-", "x", ".", "cost", "-", "x", ".", "h", "*", "self", ".", "inflation", "\n", "", "if", "self", ".", "rob_id", "is", "None", ":", "\n", "            ", "self", ".", "rob_id", "=", "tuple", "(", "range", "(", "len", "(", "goals", ")", ")", ")", "\n", "", "self", ".", "col_checker", "=", "col_checker", "\n", "if", "self", ".", "col_checker", "is", "None", ":", "\n", "            ", "self", ".", "col_checker", "=", "workspace_graph", ".", "Edge_Checker", "(", ")", "\n", "", "self", ".", "flood_fill_policy", "=", "flood_fill_policy", "\n", "# Making everything that can be immutable,  immutable", "\n", "self", ".", "_col_set_memory", "=", "col_set_memory", "\n", "self", ".", "gen_policy_planners", "(", "sub_search", ",", "self", ".", "obs_map", ",", "self", ".", "goals", ")", "\n", "\n", "", "def", "gen_policy_planners", "(", "self", ",", "sub_search", ",", "obs_map", ",", "goals", ")", ":", "\n", "        ", "\"\"\"Creates the sub-planners and necessary policy keys.  This is\n        because pretty much every sub-planner I've made requires\n        adjusting the graph used to create the policies and passing\n        around dummy sub_searches\n\n        side effects to generate self.sub_search and self.policy_keys\n        \"\"\"", "\n", "self", ".", "policy_keys", "=", "tuple", "(", "[", "(", "i", ",", ")", "for", "i", "in", "self", ".", "rob_id", "]", ")", "\n", "self", ".", "sub_search", "=", "sub_search", "\n", "if", "self", ".", "sub_search", "is", "None", ":", "\n", "            ", "self", ".", "sub_search", "=", "{", "}", "\n", "# Wrapping the robot number in a tuple so we can use the same", "\n", "# structure for planners for compound robots", "\n", "if", "self", ".", "flood_fill_policy", ":", "\n", "                ", "for", "dex", ",", "key", "in", "enumerate", "(", "self", ".", "policy_keys", ")", ":", "\n", "                    ", "self", ".", "sub_search", "[", "key", "]", "=", "workspace_graph", ".", "Workspace_Graph", "(", "\n", "obs_map", ",", "goals", "[", "dex", "]", ",", "connect_8", "=", "self", ".", "connect_8", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "dex", ",", "key", "in", "enumerate", "(", "self", ".", "policy_keys", ")", ":", "\n", "                    ", "self", ".", "sub_search", "[", "key", "]", "=", "workspace_graph", ".", "Astar_Graph", "(", "\n", "obs_map", ",", "goals", "[", "dex", "]", ",", "connect_8", "=", "self", ".", "connect_8", ",", "\n", "makespan", "=", "self", ".", "_makespan", ")", "\n", "\n", "", "", "", "", "def", "get_graph_size", "(", "self", ",", "correct_for_size", "=", "True", ")", ":", "\n", "        ", "\"\"\"Returns the number of nodes in the current graph\"\"\"", "\n", "if", "correct_for_size", ":", "\n", "            ", "return", "len", "(", "self", ".", "graph", ")", "*", "len", "(", "self", ".", "rob_id", ")", "\n", "", "return", "len", "(", "self", ".", "graph", ")", "\n", "\n", "", "def", "get_memory_useage", "(", "self", ",", "correct_for_size", "=", "True", ")", ":", "\n", "        ", "\"\"\"Returns the total number of nodes allocated in this planner\n        and any subplanners.\n        \"\"\"", "\n", "temp_sum", "=", "self", ".", "get_graph_size", "(", "correct_for_size", ")", "\n", "for", "i", "in", "self", ".", "sub_search", ":", "\n", "            ", "temp_sum", "+=", "self", ".", "sub_search", "[", "i", "]", ".", "get_graph_size", "(", ")", "\n", "", "return", "temp_sum", "\n", "\n", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"resets the map for later searches,  does not remove\n        forwards_pointer\n        \"\"\"", "\n", "self", ".", "updated", "+=", "1", "\n", "\n", "", "def", "heuristic", "(", "self", ",", "coord", ",", "standard_node", ")", ":", "\n", "        ", "\"\"\"Returns the heuristic value of the specified coordinate.\n\n        Does not handle inflation naturally so we can update the\n        heuristic properly\n\n        coord         - coordinate of the node at which to compute the\n                        heuristic\n        standard_node - whether this is a standard node\n        \"\"\"", "\n", "if", "standard_node", ":", "\n", "            ", "cost", "=", "sum", "(", "self", ".", "sub_search", "[", "key", "]", ".", "get_cost", "(", "coord", "[", "dex", "]", ")", "\n", "for", "dex", ",", "key", "in", "enumerate", "(", "self", ".", "policy_keys", ")", ")", "\n", "# return self.inflation * cost", "\n", "return", "cost", "\n", "", "else", ":", "\n", "# Compute heuristic for robots which have moved", "\n", "            ", "cost", "=", "sum", "(", "self", ".", "sub_search", "[", "key", "]", ".", "get_cost", "(", "coord", "[", "MOVE_TUPLE", "]", "[", "dex", "]", ")", "\n", "for", "dex", ",", "key", "in", "enumerate", "(", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_policy_planners": [[253, 276], ["tuple", "enumerate", "enumerate", "workspace_graph.Workspace_Graph", "workspace_graph.Astar_Graph"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Workspace_Graph", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Graph"], ["self", ".", "policy_keys", "[", ":", "len", "(", "coord", "[", "MOVE_TUPLE", "]", ")", "]", ")", ")", "\n", "# compute heuristic for robots which have not moved", "\n", "cost", "+=", "sum", "(", "self", ".", "sub_search", "[", "key", "]", ".", "get_cost", "(", "\n", "coord", "[", "POSITION", "]", "[", "dex", "+", "len", "(", "coord", "[", "MOVE_TUPLE", "]", ")", "]", ")", "\n", "for", "dex", ",", "key", "in", "enumerate", "(", "self", ".", "policy_keys", "[", "len", "(", "coord", "[", "\n", "MOVE_TUPLE", "]", ")", ":", "]", ")", ")", "\n", "return", "cost", "\n", "\n", "", "", "def", "pass_through", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Tests for a collision during transition from coord 1 to coord\n        2.\n\n        coord1, coord2 - joint coordinates of multirobot system\n\n        returns:\n\n        collision set for the edge,  empty list if there are no\n        collisions\n        \"\"\"", "\n", "# return self.col_checker.pass_through(coord1, coord2, self.recursive)", "\n", "return", "self", ".", "col_checker", ".", "cross_over", "(", "coord1", ",", "coord2", ",", "self", ".", "recursive", ")", "\n", "\n", "", "def", "incremental_col_check", "(", "self", ",", "start_coord", ",", "new_coord", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_graph_size": [[277, 282], ["len", "len", "len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage": [[283, 291], ["od_mstar.Od_Mstar.get_graph_size", "od_mstar.Od_Mstar.sub_search[].get_graph_size"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_graph_size", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_graph_size"], ["\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.reset": [[292, 297], ["None"], "methods", ["None"], ["col_set", "=", "self", ".", "col_checker", ".", "incremental_cross_over", "(", "\n", "start_coord", ",", "new_coord", ",", "self", ".", "recursive", ")", "\n", "if", "col_set", ":", "\n", "            ", "return", "col_set", "\n", "", "return", "self", ".", "col_checker", ".", "incremental_col_check", "(", "\n", "new_coord", ",", "self", ".", "recursive", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.heuristic": [[298, 325], ["sum", "sum", "sum", "od_mstar.Od_Mstar.sub_search[].get_cost", "od_mstar.Od_Mstar.sub_search[].get_cost", "od_mstar.Od_Mstar.sub_search[].get_cost", "enumerate", "enumerate", "enumerate", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["\n", "", "def", "get_node", "(", "self", ",", "coord", ",", "standard_node", ")", ":", "\n", "        ", "\"\"\"Returns the node at the specified coordinates.\n\n        Remember intermediate nodes are of the form\n        (base_coord, move_tuple)\n\n        coord         - coordinates of the node,  potentially an\n                        intermediate node\n        standard_node - whether this is a standard node or an\n                        intermediate node\n        \"\"\"", "\n", "if", "coord", "in", "self", ".", "graph", ":", "\n", "# Node already exists.  reset if necessary", "\n", "            ", "t_node", "=", "self", ".", "graph", "[", "coord", "]", "\n", "t_node", ".", "reset", "(", "self", ".", "updated", ")", "\n", "return", "t_node", "\n", "# Need to instantiate the node", "\n", "", "if", "standard_node", ":", "\n", "            ", "col", "=", "self", ".", "col_checker", ".", "col_check", "(", "coord", ",", "self", ".", "recursive", ")", "\n", "", "else", ":", "\n", "# Only check for collisions between robots whose move has", "\n", "# been determined", "\n", "            ", "col", "=", "self", ".", "col_checker", ".", "col_check", "(", "coord", "[", "MOVE_TUPLE", "]", ",", "self", ".", "recursive", ")", "\n", "", "free", "=", "(", "len", "(", "col", ")", "==", "0", ")", "\n", "t_node", "=", "mstar_node", "(", "coord", ",", "free", ",", "self", ".", "recursive", ",", "standard_node", ")", "\n", "# Cache the resultant col_set", "\n", "t_node", ".", "col_set", "=", "col", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.pass_through": [[326, 339], ["od_mstar.Od_Mstar.col_checker.cross_over"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.cross_over"], ["t_node", ".", "updated", "=", "self", ".", "updated", "\n", "t_node", ".", "h", "=", "self", ".", "heuristic", "(", "coord", ",", "standard_node", ")", "\n", "# Add the node to the graph", "\n", "self", ".", "graph", "[", "coord", "]", "=", "t_node", "\n", "return", "t_node", "\n", "\n", "", "def", "get_step", "(", "self", ",", "init_pos", ",", "standard_node", "=", "True", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.incremental_col_check": [[340, 363], ["od_mstar.Od_Mstar.col_checker.incremental_cross_over", "od_mstar.Od_Mstar.col_checker.incremental_col_check"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.incremental_cross_over", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.incremental_col_check"], ["\n", "cur_node", "=", "self", ".", "get_node", "(", "init_pos", ",", "standard_node", ")", "\n", "temp", "=", "cur_node", ".", "get_step", "(", ")", "\n", "if", "temp", "is", "not", "None", ":", "\n", "            ", "return", "temp", "\n", "# Use a zero time limit,  so the end time will not be modified", "\n", "", "path", "=", "self", ".", "find_path", "(", "init_pos", ",", "time_limit", "=", "-", "1", ")", "\n", "return", "cur_node", ".", "get_step", "(", ")", "\n", "\n", "", "def", "gen_init_nodes", "(", "self", ",", "init_pos", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node": [[364, 414], ["od_mstar.mstar_node", "od_mstar.Od_Mstar.heuristic", "od_mstar.mstar_node.reset", "od_mstar.Od_Mstar.col_checker.col_check", "od_mstar.Od_Mstar.col_checker.col_check", "len", "tuple.extend", "tuple.extend", "tuple", "len", "od_mstar.Od_Mstar.collision_logger.add", "enumerate", "len", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.heuristic", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.reset", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.col_check", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.col_check"], ["\n", "first", "=", "self", ".", "get_node", "(", "init_pos", ",", "True", ")", "\n", "first", ".", "open", "=", "True", "\n", "first", ".", "cost", "=", "0", "\n", "first", ".", "back_ptr", "=", "first", "\n", "return", "[", "first", "]", "\n", "\n", "", "def", "find_path", "(", "self", ",", "init_pos", ",", "time_limit", "=", "5", "*", "60", ")", ":", "\n", "        ", "\"\"\"Finds a path from init_pos to the goal specified when self\n        was instantiated.\n\n        init_pos   - ((x1, y1), (x2, y2), ...) coordinates of initial\n                     position\n        time_limit - time allocated to find a solution.  Will raise an\n                     exception if a path cannot be found within this time\n                     period\n        \"\"\"", "\n", "self", ".", "reset", "(", ")", "\n", "if", "time_limit", ">", "0", ":", "\n", "            ", "self", ".", "end_time", "=", "timer", ".", "time", "(", ")", "+", "time_limit", "\n", "# For replanning to work correctly, need to update the end", "\n", "# time for all subplanners.  Otherwise, the end time of the", "\n", "# subplanners will never be updated, so if you make a query", "\n", "# more than the original time_limit seconds after the first", "\n", "# query to this object, you will always get a timeout,", "\n", "# regardless of the time limit used on the second query", "\n", "for", "planner", "in", "self", ".", "sub_search", ".", "values", "(", ")", ":", "\n", "                ", "if", "hasattr", "(", "planner", ",", "'end_time'", ")", ":", "\n", "                    ", "planner", ".", "end_time", "=", "self", ".", "end_time", "\n", "\n", "# Configure the goal node", "\n", "", "", "", "goal_node", "=", "self", ".", "get_node", "(", "self", ".", "goals", ",", "True", ")", "\n", "goal_node", ".", "forwards_ptr", "=", "goal_node", "\n", "# Use the negation of the cost,  so SortedCollection will put the", "\n", "# lowest value item at the right of its internal list", "\n", "init_nodes", "=", "self", ".", "gen_init_nodes", "(", "init_pos", ")", "\n", "open_list", "=", "SortedCollection", ".", "SortedCollection", "(", "init_nodes", ",", "\n", "key", "=", "self", ".", "open_list_key", ")", "\n", "\n", "while", "len", "(", "open_list", ")", ">", "0", ":", "\n", "            ", "if", "timer", ".", "time", "(", ")", ">", "self", ".", "end_time", ":", "\n", "                ", "raise", "OutOfTimeError", "(", "timer", ".", "time", "(", ")", ")", "\n", "", "node", ",", "consistent", "=", "open_list", ".", "consistent_pop", "(", ")", "\n", "if", "not", "consistent", ":", "\n", "                ", "continue", "\n", "", "node", ".", "open", "=", "False", "\n", "if", "self", ".", "solution_condition", "(", "node", ")", ":", "\n", "                ", "path", "=", "node", ".", "get_path", "(", ")", "\n", "return", "tuple", "(", "path", ")", "\n", "", "self", ".", "expand", "(", "node", ",", "open_list", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_step": [[415, 436], ["od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.get_step", "od_mstar.Od_Mstar.find_path", "od_mstar.Od_Mstar.get_step"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["", "raise", "NoSolutionError", "(", ")", "\n", "\n", "", "def", "solution_condition", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Checks whether we have finished finding a path when node has\n        been reached\n\n        Checks whether node.forwards_ptr indicates that a path to the\n        goal has been found\n\n        node - node to check for indicating a path to the goal\n\n        returns:\n\n        True if goal has been reached or a cached path to the goal has\n        been reached, else False\n        \"\"\"", "\n", "if", "node", ".", "forwards_ptr", "is", "not", "None", ":", "\n", "            ", "return", "True", "\n", "\n", "", "return", "False", "\n", "\n", "", "def", "expand", "(", "self", ",", "node", ",", "open_list", ")", ":", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_init_nodes": [[437, 454], ["od_mstar.Od_Mstar.get_node"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node"], ["        ", "\"\"\"Handles the expansion of the given node and the addition of\n        its neighbors to the open list\n\n        node      - node to expand\n        open_list - open list used during the search\n        \"\"\"", "\n", "node", ".", "closed", "=", "True", "\n", "# ASSUMES THAT get_neighbors HANDLES UPDATING NEIGHBOR COST,", "\n", "# AND DOES NOT RETURN NEIGHBORS FOR WHICH THERE IS ALREADY A", "\n", "# PATH AT LEAST AS GOOD", "\n", "if", "self", ".", "recursive", ":", "\n", "            ", "neighbors", ",", "col_set", "=", "self", ".", "get_neighbors_recursive", "(", "node", ")", "\n", "", "else", ":", "\n", "            ", "neighbors", ",", "col_set", "=", "self", ".", "get_neighbors_nonrecursive", "(", "node", ")", "\n", "\n", "# node is the only element in the backpropagation sets of", "\n", "# neighbors that has changed,  so we can backpropagate from here", "\n", "", "old_col_set", "=", "node", ".", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.find_path": [[455, 508], ["od_mstar.Od_Mstar.reset", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.gen_init_nodes", "SortedCollection.SortedCollection", "col_set_addition.NoSolutionError", "od_mstar.Od_Mstar.sub_search.values", "len", "SortedCollection.SortedCollection.consistent_pop", "od_mstar.Od_Mstar.solution_condition", "od_mstar.Od_Mstar.expand", "time.time", "hasattr", "time.time", "col_set_addition.OutOfTimeError", "node.get_path", "tuple", "time.time"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.reset", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_init_nodes", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.consistent_pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.solution_condition", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.expand", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.get_path"], ["if", "not", "self", ".", "full_space", ":", "\n", "            ", "node", ".", "back_prop_col_set", "(", "col_set", ",", "open_list", ",", "epeastar", "=", "self", ".", "epeastar", ")", "\n", "", "for", "i", "in", "neighbors", ":", "\n", "            ", "i", ".", "back_ptr", "=", "node", "\n", "# Even if the node is already in the open list,  removing if", "\n", "# from its old position (given by the old cost value) is too", "\n", "# expensive, requiring an O(N) operation to delete.  Simply", "\n", "# add the new value and reject the old copy (which will be", "\n", "# marked as closed),  when you come to it", "\n", "i", ".", "open", "=", "True", "\n", "open_list", ".", "insert_right", "(", "i", ")", "\n", "", "if", "self", ".", "epeastar", ":", "\n", "# if running epeastar", "\n", "            ", "if", "old_col_set", "==", "node", ".", "col_set", ":", "\n", "# If the collision set changed,  then adding the node", "\n", "# back to the open list with properly updated collision", "\n", "# set has been handled by the backprop function", "\n", "                ", "node", ".", "offset", "+=", "self", ".", "offset_increment", "\n", "open_list", ".", "insert", "(", "node", ")", "\n", "\n", "", "", "", "def", "od_mstar_neighbors", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Generates the free neighbors of the given node for the\n        non-recursive case, using operator decomposition\n\n        Also returns the associated collision set due to neighbors\n        which are non-free due to robot-robot collisions.  Only returns\n        nodes which can be most cheaply reached through node\n\n        node - node to determine neighbors\n\n        returns:\n\n        (neighbors, col_set)\n        neighbors - collision free neighbors which can most efficiently\n                    be reached from node\n        col_set   - collision set for neighbors which are not collision\n                    free\n        \"\"\"", "\n", "col_set", "=", "(", ")", "\n", "if", "not", "node", ".", "free", ":", "\n", "# Can't have an out neighbor for a node in collision", "\n", "            ", "return", "col_set", ",", "node", ".", "col_set", "\n", "", "rob_dex", "=", "0", "# Keeps track of the robot to move in this step", "\n", "\n", "# split the coordinates into the start coordinate and the move", "\n", "# list if the node is standard,  doing this so variables are", "\n", "# initialized in  the preferred namespace,  which is probably not", "\n", "# necessary", "\n", "move_list", "=", "(", ")", "\n", "start_coord", "=", "node", ".", "coord", "\n", "if", "not", "node", ".", "standard_node", ":", "\n", "            ", "start_coord", "=", "node", ".", "coord", "[", "POSITION", "]", "\n", "move_list", "=", "node", ".", "coord", "[", "MOVE_TUPLE", "]", "\n", "rob_dex", "=", "len", "(", "node", ".", "coord", "[", "MOVE_TUPLE", "]", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.solution_condition": [[509, 527], ["None"], "methods", ["None"], ["", "if", "(", "(", "len", "(", "node", ".", "col_set", ")", ">", "0", "and", "rob_dex", "in", "node", ".", "col_set", "[", "0", "]", ")", "or", "\n", "self", ".", "full_space", ")", ":", "\n", "# This robot is in the collision set,  so consider all", "\n", "# possible neighbors", "\n", "            ", "neighbors", "=", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "rob_dex", "]", "]", ".", "get_neighbors", "(", "start_coord", "[", "rob_dex", "]", ")", "\n", "", "else", ":", "\n", "            ", "neighbors", "=", "[", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "rob_dex", "]", "]", ".", "get_step", "(", "\n", "start_coord", "[", "rob_dex", "]", ")", "]", "\n", "# check if this is the last robot to be moved", "\n", "", "filled", "=", "(", "rob_dex", "==", "(", "self", ".", "num_bots", "-", "1", ")", ")", "\n", "\n", "new_neighbors", "=", "[", "]", "\n", "# visualize_holder = []", "\n", "for", "i", "in", "neighbors", ":", "\n", "# Generate the move list with the new robot position", "\n", "            ", "new_moves", "=", "list", "(", "move_list", ")", "\n", "new_moves", ".", "append", "(", "i", ")", "\n", "new_moves", "=", "tuple", "(", "new_moves", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.expand": [[528, 578], ["od_mstar.Od_Mstar.get_neighbors_recursive", "od_mstar.Od_Mstar.get_neighbors_nonrecursive", "len", "node.back_prop_col_set", "open_list.insert_right", "max", "open_list.insert", "len", "len", "od_mstar.Od_Mstar.collision_logger.add", "enumerate", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_neighbors_recursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_neighbors_nonrecursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.back_prop_col_set", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert_right", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], ["# Check for collisions in the transition to the new", "\n", "# position, only need to consider the robots in the move list", "\n", "# pass through", "\n", "pass_col", "=", "self", ".", "pass_through", "(", "start_coord", "[", ":", "rob_dex", "+", "1", "]", ",", "new_moves", ")", "\n", "if", "len", "(", "pass_col", ")", ">", "0", ":", "\n", "# Have robot-robot collisions", "\n", "                ", "col_set", "=", "col_set_add", "(", "pass_col", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "continue", "\n", "# Need to branch on whether we have filled the move list", "\n", "", "if", "filled", ":", "\n", "# Generate a standard node.  Static collisions are found", "\n", "# in self.get_node()", "\n", "                ", "new_node", "=", "self", ".", "get_node", "(", "new_moves", ",", "True", ")", "\n", "", "else", ":", "\n", "# Generate an intermediate node", "\n", "                ", "new_node", "=", "self", ".", "get_node", "(", "(", "start_coord", ",", "new_moves", ")", ",", "False", ")", "\n", "", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "                ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "# Always need to add the col_set of any vertex that we can", "\n", "# actually reach,  as otherwise,  we would need to wait for", "\n", "# another robot to collide downstream of the reached vertex", "\n", "# before that vertex would back propagate its col_set", "\n", "", "col_set", "=", "col_set_add", "(", "new_node", ".", "col_set", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "if", "not", "new_node", ".", "free", ":", "\n", "                ", "continue", "\n", "# Skip if closed", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "                ", "continue", "\n", "# Handle costs, which depends soely on the move list,", "\n", "# function to allow for alternate cost functions", "\n", "", "temp_cost", "=", "self", ".", "od_mstar_transition_cost", "(", "start_coord", ",", "node", ".", "cost", ",", "\n", "i", ",", "rob_dex", ")", "\n", "if", "temp_cost", ">=", "new_node", ".", "cost", ":", "\n", "                ", "continue", "\n", "", "new_node", ".", "cost", "=", "temp_cost", "\n", "new_neighbors", ".", "append", "(", "new_node", ")", "\n", "# Set the intermediate nod's col_set equal to its parent,", "\n", "# so later elements will actually be explored.  Not", "\n", "# technically required but will cut back on thrashing", "\n", "if", "not", "new_node", ".", "standard_node", ":", "\n", "                ", "new_node", ".", "add_col_set", "(", "node", ".", "col_set", ")", "\n", "", "", "return", "new_neighbors", ",", "col_set", "\n", "\n", "", "def", "od_mstar_transition_cost", "(", "self", ",", "start_coord", ",", "prev_cost", ",", "neighbor", ",", "\n", "rob_dex", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_mstar_neighbors": [[579, 682], ["len", "od_mstar.Od_Mstar.sub_search[].get_neighbors", "list", "tuple.append", "tuple", "od_mstar.Od_Mstar.pass_through", "col_set_addition.col_set_add", "od_mstar.Od_Mstar.od_mstar_transition_cost", "new_neighbors.append", "od_mstar.Od_Mstar.sub_search[].get_step", "Exception", "time.time", "col_set_addition.OutOfTimeError", "len", "col_set_addition.col_set_add", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.back_prop_set.append", "od_mstar.Od_Mstar.add_col_set", "len", "time.time"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_mstar_transition_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set"], ["\n", "prev_cost", "+=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "rob_dex", "]", "]", ".", "get_edge_cost", "(", "\n", "start_coord", "[", "rob_dex", "]", ",", "neighbor", ")", "\n", "return", "prev_cost", "\n", "\n", "", "def", "gen_epeastar_coords", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Helper function for generating neighbors of a node using EPEA*\n\n        Uses a two step process. First the incremental costs are\n        computed, then the neighbors fitting those incremental costs.\n        More directly matches what was done in the EPEA* paper.  Performs\n        incremental collision checking during the generation of\n        neighbors,  to prune out as many invalid nodes as early as\n        possible\n\n        node - node for which to generate neighbors\n        \"\"\"", "\n", "adder", "=", "add_col_set", "\n", "if", "self", ".", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "offset", "=", "node", ".", "offset", "\n", "coord", "=", "node", ".", "coord", "\n", "if", "len", "(", "node", ".", "col_set", ")", "==", "0", ":", "\n", "# have empty collision set", "\n", "            ", "new_coord", "=", "tuple", "(", "\n", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_step", "(", "\n", "coord", "[", "dex", "]", ")", "for", "dex", "in", "range", "(", "self", ".", "num_bots", ")", ")", "\n", "pass_col", "=", "self", ".", "pass_through", "(", "coord", ",", "new_coord", ")", "\n", "if", "pass_col", ":", "\n", "                ", "return", "[", "]", ",", "pass_col", "\n", "", "col", "=", "self", ".", "col_checker", ".", "col_check", "(", "new_coord", ",", "self", ".", "recursive", ")", "\n", "if", "col", ":", "\n", "                ", "return", "[", "]", ",", "col", "\n", "", "return", "[", "new_coord", "]", ",", "[", "]", "\n", "", "search_list", "=", "[", "(", "0", ",", "(", ")", ")", "]", "\n", "assert", "len", "(", "node", ".", "col_set", ")", "==", "1", "\n", "node_col", "=", "node", ".", "col_set", "[", "0", "]", "\n", "for", "rob_dex", "in", "range", "(", "self", ".", "num_bots", ")", ":", "\n", "            ", "if", "rob_dex", "in", "node_col", ":", "\n", "                ", "offsets", "=", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "rob_dex", "]", "]", ".", "get_offsets", "(", "coord", "[", "rob_dex", "]", ")", "\n", "", "else", ":", "\n", "                ", "offsets", "=", "(", "0", ",", ")", "\n", "", "new_list", "=", "[", "]", "\n", "for", "cost", ",", "pos", "in", "search_list", ":", "\n", "                ", "for", "off", "in", "offsets", ":", "\n", "                    ", "if", "rob_dex", "<", "self", ".", "num_bots", "-", "1", ":", "\n", "                        ", "if", "off", "+", "cost", "<=", "offset", ":", "\n", "                            ", "new_list", ".", "append", "(", "(", "off", "+", "cost", ",", "pos", "+", "(", "off", ",", ")", ")", ")", "\n", "", "", "elif", "off", "+", "cost", "==", "offset", ":", "\n", "# For the last robot,  only want to keep costs which", "\n", "# match perfectly", "\n", "                        ", "new_list", ".", "append", "(", "(", "off", "+", "cost", ",", "pos", "+", "(", "off", ",", ")", ")", ")", "\n", "", "", "search_list", "=", "new_list", "\n", "", "", "neighbors", "=", "[", "]", "\n", "col_set", "=", "[", "]", "\n", "for", "offset", ",", "costs", "in", "search_list", ":", "\n", "            ", "gen_list", "=", "[", "(", ")", "]", "\n", "for", "dex", ",", "c", "in", "enumerate", "(", "costs", ")", ":", "\n", "                ", "if", "dex", "in", "node_col", ":", "\n", "                    ", "neib", "=", "(", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_offset_neighbors", "(", "\n", "coord", "[", "dex", "]", ",", "c", ")", ")", "\n", "", "else", ":", "\n", "                    ", "neib", "=", "(", "(", "0", ",", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_step", "(", "coord", "[", "dex", "]", ")", ")", ",", ")", "\n", "", "new_list", "=", "[", "]", "\n", "for", "_", ",", "n", "in", "neib", ":", "\n", "                    ", "for", "old", "in", "gen_list", ":", "\n", "                        ", "new_coord", "=", "old", "+", "(", "n", ",", ")", "\n", "# Perform collision checking", "\n", "tcol", "=", "self", ".", "incremental_col_check", "(", "coord", ",", "new_coord", ")", "\n", "if", "tcol", ":", "\n", "                            ", "col_set", "=", "adder", "(", "col_set", ",", "tcol", ")", "\n", "continue", "\n", "", "new_list", ".", "append", "(", "new_coord", ")", "\n", "", "", "gen_list", "=", "new_list", "\n", "", "neighbors", ".", "extend", "(", "gen_list", ")", "\n", "", "return", "neighbors", ",", "col_set", "\n", "\n", "", "def", "get_epeastar_neighbors", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Generates the free neighbors of the given node for the\n        non-recursive case.\n\n        Also returns the associated collision set due to neighbors\n        which are non-free due to robot-robot collisions.  Only returns\n        nodes which can be most cheaply reached through node\n\n        node - node to be expanded\n\n        returns:\n        (neighbors, col_set)\n        neighbors - neighbors that can most be efficiently reached from\n                    node, that are collision free\n        col_set   - collisions incurred when trying to reach\n                    non-collision free nodes\n        \"\"\"", "\n", "if", "not", "node", ".", "free", ":", "\n", "# Can't have an out neighbor for a node in collision", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_mstar_transition_cost": [[683, 700], ["od_mstar.Od_Mstar.sub_search[].get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["            ", "return", "[", "]", ",", "node", ".", "col_set", "\n", "", "start_coord", "=", "node", ".", "coord", "\n", "neighbor_coords", ",", "col_set", "=", "self", ".", "gen_epeastar_coords", "(", "node", ")", "\n", "neighbors", "=", "[", "]", "\n", "for", "i", "in", "neighbor_coords", ":", "\n", "            ", "new_node", "=", "self", ".", "get_node", "(", "i", ",", "True", ")", "\n", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "                ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "", "if", "not", "new_node", ".", "free", ":", "\n", "                ", "continue", "\n", "# update costs", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "t_cost", "=", "self", ".", "epeastar_transition_cost", "(", "start_coord", ",", "node", ".", "cost", ",", "i", ")", "\n", "if", "t_cost", "<", "new_node", ".", "cost", ":", "\n", "                ", "new_node", ".", "cost", "=", "t_cost", "\n", "new_node", ".", "back_ptr", "=", "node", "\n", "neighbors", ".", "append", "(", "new_node", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_epeastar_coords": [[701, 775], ["range", "len", "tuple", "od_mstar.Od_Mstar.pass_through", "od_mstar.Od_Mstar.col_checker.col_check", "len", "enumerate", "neighbors.extend", "od_mstar.Od_Mstar.sub_search[].get_offsets", "od_mstar.Od_Mstar.sub_search[].get_step", "od_mstar.Od_Mstar.sub_search[].get_offset_neighbors", "range", "od_mstar.Od_Mstar.incremental_col_check", "new_list.append", "new_list.append", "new_list.append", "od_mstar.Od_Mstar.sub_search[].get_step", "adder"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.col_check", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_offsets", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_offset_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.incremental_col_check", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["", "", "return", "neighbors", ",", "col_set", "\n", "\n", "", "def", "epeastar_transition_cost", "(", "self", ",", "start_coord", ",", "prev_cost", ",", "new_coord", ")", ":", "\n", "        ", "\"\"\"Computes the cost of a new node at the specified coordinates,\n        starting from the given position and cost\n\n        start_coord - node at which the system starts\n        prev_cost   - cost of the node at start_coord\n        new_coord   - destination node\n        \"\"\"", "\n", "for", "dex", ",", "(", "source", ",", "target", ")", "in", "enumerate", "(", "zip", "(", "start_coord", ",", "new_coord", ")", ")", ":", "\n", "            ", "prev_cost", "+=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_edge_cost", "(", "\n", "source", ",", "target", ")", "\n", "", "return", "prev_cost", "\n", "\n", "", "def", "get_neighbors_nonrecursive", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Generates neighbors using a non-recursive method.  Note that\n        collision sets will still be generated in the style specified by\n        self.recursive\n\n        node - node for which to generate neighbors\n        \"\"\"", "\n", "if", "self", ".", "astar", ":", "\n", "            ", "return", "self", ".", "get_astar_neighbors", "(", "node", ")", "\n", "", "elif", "self", ".", "epeastar", ":", "\n", "            ", "return", "self", ".", "get_epeastar_neighbors", "(", "node", ")", "\n", "", "return", "self", ".", "od_mstar_neighbors", "(", "node", ")", "\n", "\n", "", "def", "create_sub_search", "(", "self", ",", "new_goals", ",", "rob_id", ")", ":", "\n", "        ", "\"\"\"Creates a new instance of a subsearch for recursive search\n\n        new_goals - goals for the subset of the robots\n        rob_ids   - ids of the robots involved in the subsearch\n\n        returns:\n\n        new OD_Mstar instance to perform search for the specified subset\n        of robots\"\"\"", "\n", "return", "Od_Mstar", "(", "self", ".", "obs_map", ",", "new_goals", ",", "self", ".", "recursive", ",", "\n", "sub_search", "=", "self", ".", "sub_search", ",", "\n", "col_checker", "=", "self", ".", "col_checker", ",", "rob_id", "=", "rob_id", ",", "\n", "inflation", "=", "self", ".", "inflation", ",", "\n", "end_time", "=", "self", ".", "end_time", ",", "connect_8", "=", "self", ".", "connect_8", ",", "\n", "astar", "=", "self", ".", "astar", ",", "full_space", "=", "self", ".", "full_space", ",", "\n", "epeastar", "=", "self", ".", "epeastar", ",", "makespan", "=", "self", ".", "_makespan", ",", "\n", "col_set_memory", "=", "self", ".", "_col_set_memory", ")", "\n", "\n", "", "def", "get_subplanner_keys", "(", "self", ",", "col_set", ")", ":", "\n", "        ", "\"\"\"Returns keys to subplanners required for planning for some\n        subset of robots.\n\n        col_set - collision set to be solved\n\n        returns:\n\n        keys for the necessary subplanners in self.sub_search\n        \"\"\"", "\n", "# Convert the collision sets into the global indicies,  and", "\n", "# convert to tuples.  Assumes self.rob_id is sorted", "\n", "global_col", "=", "list", "(", "map", "(", "lambda", "y", ":", "tuple", "(", "map", "(", "lambda", "x", ":", "self", ".", "rob_id", "[", "x", "]", ",", "y", ")", ")", ",", "\n", "col_set", ")", ")", "\n", "# generate the sub planners,  if necessary", "\n", "for", "dex", ",", "gc", "in", "enumerate", "(", "global_col", ")", ":", "\n", "            ", "if", "gc", "not", "in", "self", ".", "sub_search", ":", "\n", "                ", "t_goals", "=", "tuple", "(", "[", "self", ".", "goals", "[", "k", "]", "for", "k", "in", "col_set", "[", "dex", "]", "]", ")", "\n", "self", ".", "sub_search", "[", "gc", "]", "=", "self", ".", "create_sub_search", "(", "t_goals", ",", "gc", ")", "\n", "", "", "return", "global_col", "\n", "\n", "", "def", "get_neighbors_recursive", "(", "self", ",", "node", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_epeastar_neighbors": [[776, 816], ["od_mstar.Od_Mstar.gen_epeastar_coords", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.epeastar_transition_cost", "time.time", "col_set_addition.OutOfTimeError", "od_mstar.Od_Mstar.back_prop_set.append", "neighbors.append", "time.time"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.gen_epeastar_coords", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.epeastar_transition_cost"], ["\n", "# Handle collision set memory if necessary", "\n", "# use_memory = False", "\n", "if", "self", ".", "_col_set_memory", ":", "\n", "            ", "col_set", "=", "effective_col_set", "(", "node", ".", "col_set", ",", "node", ".", "prev_col_set", ")", "\n", "effective_set", "=", "col_set", "\n", "# if set(col_set) != set(node.col_set):", "\n", "#     # using memory", "\n", "#     use_memory = True", "\n", "# Sort the collision set,  which also converts them into", "\n", "# lists", "\n", "col_set", "=", "list", "(", "map", "(", "sorted", ",", "col_set", ")", ")", "\n", "", "else", ":", "\n", "# Sort the collision set,  which also converts them into lists", "\n", "            ", "col_set", "=", "list", "(", "map", "(", "sorted", ",", "node", ".", "col_set", ")", ")", "\n", "# Use standard operator decomposition,  if appropriate", "\n", "", "if", "len", "(", "col_set", ")", "==", "1", "and", "len", "(", "col_set", "[", "0", "]", ")", "==", "self", ".", "num_bots", ":", "\n", "# At base of recursion case", "\n", "            ", "return", "self", ".", "get_neighbors_nonrecursive", "(", "node", ")", "\n", "", "start_coord", "=", "node", ".", "coord", "\n", "if", "not", "node", ".", "standard_node", ":", "\n", "            ", "assert", "False", "\n", "# Generate subplanners for new coupled groups of robots and get", "\n", "# their sub_search keys", "\n", "", "coupled_keys", "=", "self", ".", "get_subplanner_keys", "(", "col_set", ")", "\n", "# Generate the individually optimal step", "\n", "new_coord", "=", "[", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "i", "]", "]", ".", "get_step", "(", "\n", "start_coord", "[", "i", "]", ")", "for", "i", "in", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "# Iterate over the colliding sets of robots,  and integrate the", "\n", "# results of the sup planning for each set", "\n", "for", "i", "in", "range", "(", "len", "(", "col_set", ")", ")", ":", "\n", "# if use_memory and frozenset(col_set[i]) in node.prev_col_set:", "\n", "# assert self.sub_search[", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.epeastar_transition_cost": [[817, 829], ["enumerate", "zip", "od_mstar.Od_Mstar.sub_search[].get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["#     coupled_keys[i]].graph[", "\n", "#         tuple([start_coord[j]", "\n", "#                for j in col_set[i]])].forwards_ptr != None", "\n", "            ", "try", ":", "\n", "                ", "new_step", "=", "self", ".", "sub_search", "[", "coupled_keys", "[", "i", "]", "]", ".", "get_step", "(", "\n", "tuple", "(", "[", "start_coord", "[", "j", "]", "for", "j", "in", "col_set", "[", "i", "]", "]", ")", ")", "\n", "", "except", "NoSolutionError", ":", "\n", "# Can't get to the goal from here", "\n", "                ", "return", "[", "]", ",", "[", "]", "\n", "# Copy the step into position", "\n", "", "for", "j", "in", "range", "(", "len", "(", "col_set", "[", "i", "]", ")", ")", ":", "\n", "                ", "new_coord", "[", "col_set", "[", "i", "]", "[", "j", "]", "]", "=", "new_step", "[", "j", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_neighbors_nonrecursive": [[830, 842], ["od_mstar.Od_Mstar.od_mstar_neighbors", "od_mstar.Od_Mstar.get_astar_neighbors", "od_mstar.Od_Mstar.get_epeastar_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_mstar_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_astar_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_epeastar_neighbors"], ["", "", "new_coord", "=", "tuple", "(", "new_coord", ")", "\n", "# process the neighbor", "\n", "pass_col", "=", "self", ".", "pass_through", "(", "start_coord", ",", "new_coord", ")", "\n", "if", "len", "(", "pass_col", ")", ">", "0", ":", "\n", "# Have collisions before reaching node", "\n", "            ", "return", "[", "]", ",", "pass_col", "\n", "", "new_node", "=", "self", ".", "get_node", "(", "new_coord", ",", "True", ")", "\n", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "            ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "", "if", "not", "new_node", ".", "free", ":", "\n", "            ", "return", "[", "]", ",", "new_node", ".", "col_set", "\n", "# Skip if closed", "\n", "", "if", "new_node", ".", "closed", ":", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.create_sub_search": [[843, 861], ["od_mstar.Od_Mstar"], "methods", ["None"], ["            ", "return", "[", "]", ",", "new_node", ".", "col_set", "\n", "# Compute the costs. THIS MAY NOT WORK IF node IS AN INTERMEDIATE", "\n", "# NODE", "\n", "", "t_cost", "=", "self", ".", "get_node", "(", "start_coord", ",", "True", ")", ".", "cost", "\n", "t_cost", "=", "self", ".", "od_rmstar_transition_cost", "(", "start_coord", ",", "t_cost", ",", "\n", "new_node", ".", "coord", ")", "\n", "if", "t_cost", "<", "new_node", ".", "cost", ":", "\n", "            ", "new_node", ".", "cost", "=", "t_cost", "\n", "if", "self", ".", "_col_set_memory", ":", "\n", "                ", "new_node", ".", "prev_col_set", "=", "effective_set", "\n", "", "return", "[", "new_node", "]", ",", "new_node", ".", "col_set", "\n", "", "return", "[", "]", ",", "new_node", ".", "col_set", "\n", "\n", "", "def", "od_rmstar_transition_cost", "(", "self", ",", "start_coord", ",", "prev_cost", ",", "new_coord", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_subplanner_keys": [[862, 882], ["list", "enumerate", "map", "tuple", "od_mstar.Od_Mstar.create_sub_search", "tuple", "map"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.create_sub_search"], ["\n", "for", "dex", ",", "(", "source", ",", "target", ")", "in", "enumerate", "(", "zip", "(", "start_coord", ",", "new_coord", ")", ")", ":", "\n", "            ", "prev_cost", "+=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "dex", "]", "]", ".", "get_edge_cost", "(", "\n", "source", ",", "target", ")", "\n", "", "return", "prev_cost", "\n", "\n", "", "def", "alt_get_astar_neighbors", "(", "self", ",", "node", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_neighbors_recursive": [[883, 1030], ["od_mstar.Od_Mstar.get_subplanner_keys", "range", "tuple", "od_mstar.Od_Mstar.pass_through", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.od_rmstar_transition_cost", "col_set_addition.effective_col_set", "list", "list", "od_mstar.Od_Mstar.get_neighbors_nonrecursive", "od_mstar.Od_Mstar.predictor.prediction_already_done", "len", "range", "len", "od_mstar.Od_Mstar.back_prop_set.append", "od_mstar.Od_Mstar.get_node", "map", "map", "len", "len", "od_mstar.Od_Mstar.sub_search[].get_step", "tuple", "od_mstar.Od_Mstar.predictor.predict", "time.time", "col_set_addition.OutOfTimeError", "len", "range", "od_mstar.Od_Mstar.sub_search[].get_step", "time.time", "od_mstar.Od_Mstar.sub_search[].get_step", "od_mstar.Od_Mstar.predictor.prediction_already_done", "tuple", "tuple", "tuple", "range", "tuple", "tuple", "od_mstar.Od_Mstar.predictor.predict", "list", "od_mstar.Od_Mstar.append", "tuple.append", "od_mstar.Od_Mstar.sub_search[].get_step", "od_mstar.Od_Mstar.odrmstar_already_predicted_next_step.add", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_subplanner_keys", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_rmstar_transition_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.effective_col_set", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_neighbors_nonrecursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.prediction_already_done", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.predict", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.prediction_already_done", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.predict", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["\n", "start_coord", "=", "node", ".", "coord", "\n", "# Generate the individually optimal setp", "\n", "base_coord", "=", "[", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "i", "]", "]", ".", "get_step", "(", "\n", "start_coord", "[", "i", "]", ")", "for", "i", "in", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "old_coords", "=", "[", "base_coord", "]", "\n", "assert", "len", "(", "node", ".", "col_set", ")", "<=", "1", "\n", "to_explore", "=", "node", ".", "col_set", "\n", "if", "self", ".", "full_space", ":", "\n", "            ", "to_explore", "=", "[", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "", "for", "i", "in", "to_explore", ":", "\n", "            ", "for", "bot", "in", "i", ":", "\n", "                ", "new_coords", "=", "[", "]", "\n", "neighbors", "=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "bot", "]", "]", ".", "get_neighbors", "(", "start_coord", "[", "bot", "]", ")", "\n", "for", "neigh", "in", "neighbors", ":", "\n", "                    ", "for", "k", "in", "old_coords", ":", "\n", "                        ", "temp", "=", "k", "[", ":", "]", "\n", "temp", "[", "bot", "]", "=", "neigh", "\n", "new_coords", ".", "append", "(", "temp", ")", "\n", "", "", "old_coords", "=", "new_coords", "\n", "", "", "col_set", "=", "[", "]", "\n", "neighbors", "=", "[", "]", "\n", "old_coords", "=", "list", "(", "map", "(", "tuple", ",", "old_coords", ")", ")", "\n", "for", "i", "in", "old_coords", ":", "\n", "# Check if we can get there", "\n", "            ", "pass_col", "=", "self", ".", "pass_through", "(", "start_coord", ",", "i", ")", "\n", "if", "len", "(", "pass_col", ")", ">", "0", ":", "\n", "                ", "col_set", "=", "col_set_add", "(", "pass_col", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "continue", "\n", "", "new_node", "=", "self", ".", "get_node", "(", "i", ",", "True", ")", "\n", "col_set", "=", "col_set_add", "(", "new_node", ".", "col_set", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "                ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "", "if", "not", "new_node", ".", "free", ":", "\n", "                ", "continue", "\n", "# update costs", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "t_cost", "=", "node", ".", "cost", "\n", "for", "j", "in", "range", "(", "len", "(", "start_coord", ")", ")", ":", "\n", "                ", "t_cost", "+=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "j", "]", "]", ".", "get_edge_cost", "(", "\n", "start_coord", "[", "i", "]", ",", "new_node", ".", "coord", "[", "j", "]", ")", "\n", "", "if", "t_cost", "<", "new_node", ".", "cost", ":", "\n", "                ", "new_node", ".", "cost", "=", "t_cost", "\n", "new_node", ".", "back_ptr", "=", "node", "\n", "neighbors", ".", "append", "(", "new_node", ")", "\n", "", "", "return", "neighbors", ",", "col_set", "\n", "\n", "", "def", "get_astar_neighbors", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\"Gets neighbors of a specified node using the standard A*\n        approach,\n\n        assumes working with standard nodes\n\n        node - node for which to generate neighbors\n\n        returns:\n        (neighbors, col_set)\n        neighbors - coordinates of collision free neighboring nodes\n        col_set   - collisions resulting from trying to reach\n                    non-collision free neighbors\n        \"\"\"", "\n", "start_coord", "=", "node", ".", "coord", "\n", "# Generate the individually optimal setp", "\n", "base_coord", "=", "[", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "i", "]", "]", ".", "get_step", "(", "\n", "start_coord", "[", "i", "]", ")", "for", "i", "in", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "old_coords", "=", "[", "base_coord", "]", "\n", "assert", "len", "(", "node", ".", "col_set", ")", "<=", "1", "\n", "to_explore", "=", "node", ".", "col_set", "\n", "if", "self", ".", "full_space", ":", "\n", "            ", "to_explore", "=", "[", "range", "(", "self", ".", "num_bots", ")", "]", "\n", "", "for", "i", "in", "to_explore", ":", "\n", "            ", "for", "bot", "in", "i", ":", "\n", "                ", "new_coords", "=", "[", "]", "\n", "neighbors", "=", "self", ".", "sub_search", "[", "self", ".", "policy_keys", "[", "bot", "]", "]", ".", "get_neighbors", "(", "start_coord", "[", "bot", "]", ")", "\n", "for", "neigh", "in", "neighbors", ":", "\n", "                    ", "for", "k", "in", "old_coords", ":", "\n", "                        ", "temp", "=", "k", "[", ":", "]", "\n", "temp", "[", "bot", "]", "=", "neigh", "\n", "new_coords", ".", "append", "(", "temp", ")", "\n", "", "", "old_coords", "=", "new_coords", "\n", "", "", "col_set", "=", "[", "]", "\n", "neighbors", "=", "[", "]", "\n", "old_coords", "=", "list", "(", "map", "(", "tuple", ",", "old_coords", ")", ")", "\n", "for", "i", "in", "old_coords", ":", "\n", "# First check if this path is relevant.  I.e. if there is already a", "\n", "# better path to the node,  then the search will never try to use", "\n", "# that route,  so we don't need to consider collisions", "\n", "            ", "new_node", "=", "self", ".", "get_node", "(", "i", ",", "True", ")", "\n", "if", "node", ".", "free", ":", "\n", "                ", "t_cost", "=", "node", ".", "cost", "\n", "for", "j", "in", "range", "(", "len", "(", "start_coord", ")", ")", ":", "\n", "                    ", "t_cost", "+=", "self", ".", "sub_search", "[", "\n", "self", ".", "policy_keys", "[", "j", "]", "]", ".", "get_edge_cost", "(", "start_coord", "[", "j", "]", ",", "\n", "i", "[", "j", "]", ")", "\n", "", "if", "t_cost", ">=", "new_node", ".", "cost", ":", "\n", "                    ", "continue", "\n", "# Check if we can get there", "\n", "", "", "pass_col", "=", "self", ".", "pass_through", "(", "start_coord", ",", "i", ")", "\n", "if", "len", "(", "pass_col", ")", ">", "0", ":", "\n", "                ", "col_set", "=", "col_set_add", "(", "pass_col", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "continue", "\n", "", "new_node", "=", "self", ".", "get_node", "(", "i", ",", "True", ")", "\n", "col_set", "=", "col_set_add", "(", "new_node", ".", "col_set", ",", "col_set", ",", "self", ".", "recursive", ")", "\n", "if", "node", "not", "in", "new_node", ".", "back_prop_set", ":", "\n", "                ", "new_node", ".", "back_prop_set", ".", "append", "(", "node", ")", "\n", "", "if", "not", "new_node", ".", "free", ":", "\n", "                ", "continue", "\n", "# update costs", "\n", "", "if", "new_node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "if", "t_cost", "<", "new_node", ".", "cost", ":", "\n", "                ", "new_node", ".", "cost", "=", "t_cost", "\n", "new_node", ".", "back_ptr", "=", "node", "\n", "neighbors", ".", "append", "(", "new_node", ")", "\n", "", "", "return", "neighbors", ",", "col_set", "\n", "\n", "\n", "", "", "class", "mstar_node", "(", "object", ")", ":", "\n", "    ", "\"\"\"Holds the data needed for a single node in operator decomposition\n    m* coord should be a tuple of tuples.  Standard nodes have\n    coordinates of the form ((x1, y1), (x2, y2), ...),  while\n    intermediate nodes have coordinates of the form (((x1, y1), ...),\n    move_tuple)\n    \"\"\"", "\n", "\n", "__slots__", "=", "[", "'free'", ",", "'coord'", ",", "'updated'", ",", "'open'", ",", "'closed'", ",", "'standard_node'", ",", "\n", "'h'", ",", "'cost'", ",", "'back_ptr'", ",", "'back_prop_set'", ",", "'col_set'", ",", "\n", "'recursive'", ",", "'forwards_ptr'", ",", "'assignment'", ",", "'colset_changed'", ",", "\n", "'offset'", ",", "'prev_col_set'", "]", "\n", "\n", "def", "__init__", "(", "self", ",", "coord", ",", "free", ",", "recursive", ",", "standard_node", ",", "back_ptr", "=", "None", ",", "\n", "forwards_ptr", "=", "None", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.od_rmstar_transition_cost": [[1031, 1047], ["enumerate", "zip", "od_mstar.Od_Mstar.sub_search[].get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["\n", "self", ".", "free", "=", "free", "\n", "self", ".", "coord", "=", "coord", "\n", "self", ".", "updated", "=", "-", "1", "\n", "# Whether already in the open list", "\n", "self", ".", "open", "=", "False", "\n", "\n", "# Whether this has been expanded.  Note that a node can be added", "\n", "# back to the open list after it has been expanded,  but will", "\n", "# still be marked as closed.  It cannot have its cost changed,", "\n", "# but it can add neighbors, but not be added as a neighbor", "\n", "self", ".", "closed", "=", "False", "\n", "self", ".", "standard_node", "=", "standard_node", "\n", "# Heuristic cost to go,  None to ensure it will be properly", "\n", "# calculated", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.alt_get_astar_neighbors": [[1048, 1112], ["list", "od_mstar.Od_Mstar.sub_search[].get_step", "len", "map", "od_mstar.Od_Mstar.pass_through", "od_mstar.Od_Mstar.get_node", "col_set_addition.col_set_add", "range", "range", "range", "od_mstar.Od_Mstar.sub_search[].get_neighbors", "time.time", "col_set_addition.OutOfTimeError", "len", "col_set_addition.col_set_add", "od_mstar.Od_Mstar.back_prop_set.append", "len", "od_mstar.Od_Mstar.sub_search[].get_edge_cost", "od_mstar.Od_Mstar.append", "time.time", "new_coords.append"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["self", ".", "h", "=", "None", "\n", "# Cost to reach", "\n", "self", ".", "cost", "=", "MAX_COST", "\n", "\n", "# Optimal way to reach this node.  Point to self to indicate the", "\n", "# initial position", "\n", "self", ".", "back_ptr", "=", "back_ptr", "\n", "self", ".", "back_prop_set", "=", "[", "]", "# Ways found to reach this node", "\n", "self", ".", "col_set", "=", "(", ")", "\n", "# store the collision set of back_ptr when the path from", "\n", "# back_ptr to self was first found.  Used for hopefully more", "\n", "# efficient cached path access", "\n", "self", ".", "prev_col_set", "=", "(", ")", "\n", "self", ".", "recursive", "=", "recursive", "\n", "\n", "# Keeps track of solutions that have already been found,", "\n", "# replace forwards_tree.  Denote the goal node by pointing", "\n", "# forwards_ptr", "\n", "# to itself", "\n", "self", ".", "forwards_ptr", "=", "forwards_ptr", "\n", "self", ".", "assignment", "=", "None", "# Used for multiassignment mstar", "\n", "\n", "# Used to track whether new assignments need to be generated for", "\n", "# MURTY  mstar", "\n", "self", ".", "colset_changed", "=", "False", "\n", "# Tracks current offset for multiple re-expansion a la EPEA*", "\n", "self", ".", "offset", "=", "0", "\n", "\n", "", "def", "reset", "(", "self", ",", "t", ")", ":", "\n", "        ", "\"\"\"Resets if t > last update time\"\"\"", "\n", "if", "t", ">", "self", ".", "updated", ":", "\n", "            ", "self", ".", "updated", "=", "t", "\n", "self", ".", "open", "=", "False", "\n", "self", ".", "closed", "=", "False", "\n", "self", ".", "cost", "=", "MAX_COST", "\n", "self", ".", "back_ptr", "=", "None", "\n", "self", ".", "back_prop_set", "=", "[", "]", "\n", "self", ".", "offset", "=", "0", "\n", "\n", "", "", "def", "get_path", "(", "self", ")", ":", "\n", "        ", "\"\"\"Gets the path passing through path to the goal,  assumes that\n        self is either the goal node,  or a node connected to the goal\n        node through forwards_pointers\n        \"\"\"", "\n", "path", "=", "self", ".", "backtrack_path", "(", ")", "\n", "return", "self", ".", "forwards_extend_path", "(", "path", ")", "\n", "\n", "", "def", "backtrack_path", "(", "self", ",", "path", "=", "None", ",", "prev", "=", "None", ")", ":", "\n", "        ", "\"\"\"Finds the path that leads up to this node,  updating\n        forwards_ptr so that we can recover this path quickly,  only\n        returns standard nodes\n\n        path - current reconstructed path for use in recusion, must\n               start as None\n        prev - pointer to the last node visited by backtrack_path, used\n               to update forwards_ptr to record the best paths to the\n               goal\n        \"\"\"", "\n", "if", "path", "is", "None", ":", "\n", "            ", "path", "=", "[", "]", "\n", "", "if", "prev", "is", "not", "None", ":", "\n", "            ", "self", ".", "forwards_ptr", "=", "prev", "\n", "if", "isinstance", "(", "self", ".", "h", ",", "tuple", ")", ":", "\n", "# Needed for constrained od_mstar,  and don't feel like", "\n", "# coming up with a better solution for now", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_astar_neighbors": [[1113, 1222], ["list", "od_mstar.Od_Mstar.predictor.prediction_already_done", "list.append", "len", "map", "od_mstar.Od_Mstar.get_node", "od_mstar.Od_Mstar.pass_through", "od_mstar.Od_Mstar.get_node", "col_set_addition.col_set_add", "tuple", "od_mstar.Od_Mstar.sub_search[].get_step", "od_mstar.Od_Mstar.predictor.predict", "list", "od_mstar.Od_Mstar.predictor.prediction_already_done", "range", "od_mstar.Od_Mstar.sub_search[].get_neighbors", "time.time", "col_set_addition.OutOfTimeError", "range", "len", "col_set_addition.col_set_add", "od_mstar.Od_Mstar.back_prop_set.append", "od_mstar.Od_Mstar.append", "range", "tuple", "od_mstar.Od_Mstar.sub_search[].get_step", "time.time", "col_set_addition.OutOfTimeError", "time.time", "len", "od_mstar.Od_Mstar.sub_search[].get_edge_cost", "range", "time.time", "new_coords.append", "tuple"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.prediction_already_done", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.predict", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.learnt_predictor.Predictor.prediction_already_done", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.col_set_add", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["                ", "self", ".", "h", "=", "(", "prev", ".", "h", "[", "0", "]", "+", "prev", ".", "cost", "[", "0", "]", "-", "self", ".", "cost", "[", "0", "]", ",", "self", ".", "h", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "h", "=", "prev", ".", "h", "+", "(", "prev", ".", "cost", "-", "self", ".", "cost", ")", "\n", "", "", "if", "self", ".", "standard_node", ":", "\n", "            ", "assert", "self", ".", "coord", "not", "in", "path", "\n", "path", ".", "insert", "(", "0", ",", "self", ".", "coord", ")", "\n", "", "if", "self", ".", "back_ptr", "==", "self", ":", "\n", "# Done so that it cannot terminate on a node that wasn't", "\n", "# properly initialized", "\n", "            ", "return", "path", "\n", "", "return", "self", ".", "back_ptr", ".", "backtrack_path", "(", "path", ",", "self", ")", "\n", "\n", "", "def", "forwards_extend_path", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"Extends the path from self to the goal node,  following\n        forwards pointers,  only includes standard nodes\n\n        path - current path to extend towards the goal, as list of joint\n               configuration space coordinates\n        \"\"\"", "\n", "if", "self", ".", "forwards_ptr", "==", "self", ":", "\n", "            ", "return", "path", "\n", "", "if", "self", ".", "forwards_ptr", ".", "standard_node", ":", "\n", "            ", "path", ".", "append", "(", "self", ".", "forwards_ptr", ".", "coord", ")", "\n", "", "return", "self", ".", "forwards_ptr", ".", "forwards_extend_path", "(", "path", ")", "\n", "\n", "", "def", "add_col_set", "(", "self", ",", "c", ")", ":", "\n", "        ", "\"\"\"Adds the contents of c to self.col_set.\n\n        c - collision set to add to the current node's collision set\n\n        returns:\n\n        True if modifications were made, else False\n        \"\"\"", "\n", "if", "len", "(", "c", ")", "==", "0", ":", "\n", "            ", "return", "False", "\n", "", "if", "self", ".", "recursive", ":", "\n", "            ", "temp", "=", "add_col_set_recursive", "(", "c", ",", "self", ".", "col_set", ")", "\n", "", "else", ":", "\n", "            ", "temp", "=", "add_col_set", "(", "c", ",", "self", ".", "col_set", ")", "\n", "", "modified", "=", "(", "temp", "!=", "self", ".", "col_set", ")", "\n", "if", "modified", ":", "\n", "            ", "self", ".", "col_set", "=", "temp", "\n", "return", "True", "\n", "", "return", "False", "\n", "\n", "", "def", "back_prop_col_set", "(", "self", ",", "new_col", ",", "open_list", ",", "epeastar", "=", "False", ")", ":", "\n", "        ", "\"\"\"Propagates the collision dependencies found by its children\n        to the parent,  which adds any new dependencies to this col_set\n\n        new_col   - the new collision set to add\n        open_list - the open list to which nodes with changed collisoin\n                    sets are added,  assumed to be a SortedCollection\n        \"\"\"", "\n", "further", "=", "self", ".", "add_col_set", "(", "new_col", ")", "\n", "if", "further", ":", "\n", "            ", "self", ".", "colset_changed", "=", "True", "\n", "if", "not", "self", ".", "open", ":", "\n", "# assert self.closed", "\n", "                ", "self", ".", "open", "=", "True", "\n", "# self.closed = False", "\n", "self", ".", "offset", "=", "0", "\n", "\n", "# Inserting to the left of any node with the same key", "\n", "# value,  to encourage exploring closer to the collison", "\n", "open_list", ".", "insert", "(", "self", ")", "\n", "", "elif", "epeastar", "and", "self", ".", "offset", "!=", "0", ":", "\n", "# Need to reset the offset and reinsert to allow a path", "\n", "# to be found even if the node is already in the open", "\n", "# list", "\n", "                ", "self", ".", "offset", "=", "0", "\n", "# Inserting to the left of any node with the same key", "\n", "# value, to encourage exploring closer to the collison", "\n", "open_list", ".", "insert", "(", "self", ")", "\n", "", "for", "j", "in", "self", ".", "back_prop_set", ":", "\n", "                ", "j", ".", "back_prop_col_set", "(", "self", ".", "col_set", ",", "open_list", ",", "epeastar", "=", "epeastar", ")", "\n", "\n", "", "", "", "def", "get_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns the coordinate of the next standard node in the path,\n\n        returns:\n\n        None if no such thing\n        \"\"\"", "\n", "if", "self", ".", "forwards_ptr", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "if", "self", ".", "forwards_ptr", ".", "standard_node", ":", "\n", "            ", "return", "self", ".", "forwards_ptr", ".", "coord", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "forwards_ptr", ".", "get_step", "(", ")", "\n", "\n", "\n", "", "", "", "def", "individually_optimal_paths", "(", "obs_map", ",", "init_pos", ",", "goals", ")", ":", "\n", "    ", "\"\"\"Returns the individually optimal paths for a system\"\"\"", "\n", "\n", "path", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "init_pos", ")", ")", ":", "\n", "        ", "path", ".", "append", "(", "find_path", "(", "obs_map", ",", "[", "init_pos", "[", "i", "]", "]", ",", "[", "goals", "[", "i", "]", "]", ")", ")", "\n", "# Need to convert to full space", "\n", "", "max_length", "=", "max", "(", "list", "(", "map", "(", "len", ",", "path", ")", ")", ")", "\n", "for", "i", "in", "path", ":", "\n", "        ", "while", "len", "(", "i", ")", "<", "max_length", ":", "\n", "            ", "i", ".", "append", "(", "i", "[", "-", "1", "]", ")", "\n", "", "", "jpath", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "max_length", ")", ":", "\n", "        ", "temp", "=", "[", "]", "\n", "for", "j", "in", "path", ":", "\n", "            ", "temp", ".", "append", "(", "j", "[", "i", "]", "[", "0", "]", ")", "\n", "", "jpath", ".", "append", "(", "temp", ")", "\n", "", "return", "jpath", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.__init__": [[1237, 1292], ["None"], "methods", ["None"], ["for", "i", "in", "range", "(", "pruning_passes", ")", ":", "\n", "        ", "G", "=", "prune_graph", ".", "prune_opposing_edge", "(", "G", ",", "num_edges", "=", "5", ")", "\n", "# Replace the individual policies with limited graphs", "\n", "", "for", "i", "in", "range", "(", "len", "(", "o", ".", "goals", ")", ")", ":", "\n", "        ", "o", ".", "sub_search", "[", "(", "i", ",", ")", "]", "=", "workspace_graph", ".", "Networkx_Graph", "(", "\n", "obs_map", ",", "goals", "[", "i", "]", ",", "graph", "=", "G", ",", "connect_8", "=", "connect_8", ")", "\n", "# Need to make sure that the recursion limit is great enough to", "\n", "# actually construct the path", "\n", "", "longest", "=", "max", "(", "[", "o", ".", "sub_search", "[", "(", "i", ",", ")", "]", ".", "get_cost", "(", "init_pos", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "init_pos", ")", ")", "]", ")", "\n", "# Guess that the longest path will not be any longer than 5 times the", "\n", "# longest individual robot path", "\n", "sys", ".", "setrecursionlimit", "(", "max", "(", "sys", ".", "getrecursionlimit", "(", ")", ",", "longest", "*", "5", "*", "\n", "len", "(", "init_pos", ")", ")", ")", "\n", "path", "=", "o", ".", "find_path", "(", "init_pos", ",", "time_limit", "=", "time_limit", ")", "\n", "num_nodes", "=", "o", ".", "get_memory_useage", "(", "False", ")", "\n", "corrected_mem", "=", "o", ".", "get_memory_useage", "(", "True", ")", "\n", "if", "get_obj", ":", "\n", "        ", "return", "path", ",", "o", "\n", "# if visualize:", "\n", "#     return path,  global_move_list", "\n", "", "if", "return_memory", ":", "\n", "        ", "return", "path", ",", "num_nodes", ",", "corrected_mem", "\n", "", "return", "path", "\n", "", ""]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.reset": [[1293, 1303], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.get_path": [[1304, 1311], ["od_mstar.mstar_node.backtrack_path", "od_mstar.mstar_node.forwards_extend_path"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.backtrack_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.forwards_extend_path"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.backtrack_path": [[1312, 1341], ["od_mstar.mstar_node.back_ptr.backtrack_path", "isinstance", "path.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.backtrack_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.forwards_extend_path": [[1342, 1354], ["od_mstar.mstar_node.forwards_ptr.forwards_extend_path", "path.append"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.forwards_extend_path"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set": [[1355, 1375], ["len", "col_set_addition.add_col_set_recursive", "col_set_addition.add_col_set"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.col_set_addition.add_col_set_recursive", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.back_prop_col_set": [[1376, 1406], ["od_mstar.mstar_node.add_col_set", "open_list.insert", "j.back_prop_col_set", "open_list.insert"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.add_col_set", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.back_prop_col_set", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.mstar_node.get_step": [[1407, 1420], ["od_mstar.mstar_node.forwards_ptr.get_step"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path": [[39, 154], ["resource.setrlimit", "od_mstar.Od_Mstar.get_memory_useage", "od_mstar.Od_Mstar.get_memory_useage", "od_mstar.Od_Mstar.get_graph_size", "list", "torch.cuda.empty_cache", "od_mstar.Od_Mstar", "max", "sys.setrecursionlimit", "time.time", "od_mstar.Od_Mstar.find_path", "time.time", "isinstance", "tuple", "tuple", "max", "traceback.print_exc", "map", "map", "Od_Mstar.sub_search[].get_cost", "sys.getrecursionlimit", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_graph_size", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["\n", "global", "global_move_list", "\n", "if", "(", "col_checker", "is", "None", "or", "isinstance", "(", "col_checker", ",", "\n", "workspace_graph", ".", "Edge_Checker", ")", ")", ":", "\n", "        ", "goals", "=", "tuple", "(", "map", "(", "tuple", ",", "goals", ")", ")", "\n", "init_pos", "=", "tuple", "(", "map", "(", "tuple", ",", "init_pos", ")", ")", "\n", "", "global_move_list", "=", "[", "]", "\n", "o", "=", "Od_Mstar", "(", "obs_map", ",", "goals", ",", "recursive", "=", "recursive", ",", "inflation", "=", "inflation", ",", "\n", "astar", "=", "astar", ",", "connect_8", "=", "connect_8", ",", "full_space", "=", "full_space", ",", "\n", "flood_fill_policy", "=", "flood_fill_policy", ",", "col_checker", "=", "col_checker", ",", "\n", "epeastar", "=", "epemstar", ",", "makespan", "=", "makespan", ",", "\n", "col_set_memory", "=", "col_set_memory", ")", "\n", "# Need to make sure that the recursion limit is great enough to", "\n", "# actually construct the path", "\n", "longest", "=", "max", "(", "[", "o", ".", "sub_search", "[", "(", "i", ",", ")", "]", ".", "get_cost", "(", "init_pos", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "init_pos", ")", ")", "]", ")", "\n", "# Guess that the longest path will not be any longer than 5 times the", "\n", "# longest individual robot path", "\n", "sys", ".", "setrecursionlimit", "(", "max", "(", "sys", ".", "getrecursionlimit", "(", ")", ",", "longest", "*", "5", "*", "\n", "len", "(", "init_pos", ")", ")", ")", "\n", "path", "=", "o", ".", "find_path", "(", "init_pos", ",", "time_limit", "=", "time_limit", ")", "\n", "num_nodes", "=", "o", ".", "get_memory_useage", "(", "False", ")", "\n", "corrected_mem", "=", "o", ".", "get_memory_useage", "(", "True", ")", "\n", "if", "get_obj", ":", "\n", "        ", "return", "path", ",", "o", "\n", "", "if", "return_memory", ":", "\n", "        ", "return", "path", ",", "num_nodes", ",", "corrected_mem", "\n", "", "return", "path", "\n", "\n", "\n", "", "class", "Od_Mstar", "(", "object", ")", ":", "\n", "    ", "\"\"\"Implements M* and rM* using operator decomposition instead of\n    basic M* as the base computation.\n\n    \"\"\"", "\n", "def", "__init__", "(", "self", ",", "obs_map", ",", "goals", ",", "recursive", ",", "sub_search", "=", "None", ",", "\n", "col_checker", "=", "None", ",", "rob_id", "=", "None", ",", "inflation", "=", "1.0", ",", "\n", "end_time", "=", "10", "**", "15", ",", "connect_8", "=", "False", ",", "astar", "=", "False", ",", "\n", "full_space", "=", "False", ",", "flood_fill_policy", "=", "False", ",", "epeastar", "=", "False", ",", "\n", "offset_increment", "=", "1", ",", "makespan", "=", "False", ",", "col_set_memory", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        obs_map           - obstacle map,  matrix with 0 for free,  1\n                            for obstacle\n        goals             - ((x1, y1), (x2, y2), ...) coordinates of the\n                            goal, should be tuples\n        recursive         - True for rM*, false for basic M*\n        sub_search        - Sub planners, should be None for the full\n                            configuration space\n        col_checker       - object to handle robot-robot collision\n                            checking.  Should implement the same\n                            interface as workspace_graph.Edge_Checker\n        rob_id            - maps local robot identity to full\n                            configuration space identity,  should be\n                            None for the full configuration space\n                            instance\n        inflation         - how much the metric should be inflated by\n        end_time          - when the search should be terminated\n        connect_8         - True for 8 connected graph,  False for 4\n                            connected graph\n        astar             - use basic A* instead of operator\n                            decomposition\n        full_space        - whether to perform a full configuration\n                            space search\n        flood_fill_policy - compute policy with flood fill instead of\n                            resumable A*\n        epeastar          - Uses EPEA* instead of OD or A* for graph\n                            search\n        offset_increment  - how much to increase the EPEA* offset after\n                            every expansion\n        makespan          - minimize makespan (time to solution),\n                            instead of minimizing time robots spend away\n                            from their robots\n        col_set_memory    - remember previous step collision set,\n                            intended to provide more efficient cached\n                            path utillization.  False by default\n        \"\"\"", "\n", "# visualize - turn on visualization code - DISABLED", "\n", "self", ".", "obs_map", "=", "obs_map", "\n", "self", ".", "recursive", "=", "recursive", "\n", "self", ".", "sub_search", "=", "sub_search", "\n", "# Stores the global ids of the robots in order of their position", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.individually_optimal_paths": [[1422, 1440], ["range", "max", "range", "len", "path.append", "list", "jpath.append", "od_mstar.find_path", "map", "len", "i.append", "temp.append"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path_limited_graph": [[1442, 1478], ["od_mstar.Od_Mstar", "prune_graph.to_networkx_graph", "range", "range", "max", "sys.setrecursionlimit", "od_mstar.Od_Mstar.find_path", "od_mstar.Od_Mstar.get_memory_useage", "od_mstar.Od_Mstar.get_memory_useage", "prune_graph.prune_opposing_edge", "len", "workspace_graph.Networkx_Graph", "max", "Od_Mstar.sub_search[].get_cost", "sys.getrecursionlimit", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.prune_graph.to_networkx_graph", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.find_path", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.od_mstar.Od_Mstar.get_memory_useage", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.prune_graph.prune_opposing_edge", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], []], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.wrk_node.__init__": [[140, 159], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Initialization function for nodes of astar policy graph.\n\n        coord - coordinate of configuration which wrk_node represents\n                in astar_policy graph\n        \"\"\"", "\n", "self", ".", "coord", "=", "coord", "# Want to store as tuples", "\n", "self", ".", "policy", "=", "None", "# Holds coordinate of next neighbor to visit", "\n", "# Holds all optimal neighbors, intended to make replanning the", "\n", "# policy to find an optimal, collision avoiding path easier", "\n", "self", ".", "opt_neighbors", "=", "[", "]", "# currently only generated by _road_rules,", "\n", "# also used to store neighbor offsets for EPEA*", "\n", "self", ".", "cost", "=", "MAX_COST", "# Cost to goal", "\n", "# Used for extension easier to running resumable A* search", "\n", "self", ".", "h", "=", "0", "\n", "# Used to determine when a policy is finalized", "\n", "self", ".", "closed", "=", "False", "\n", "self", ".", "iteration", "=", "-", "1", "\n", "self", ".", "open", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Networkx_DiGraph.__init__": [[198, 203], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "graph", ")", ":", "\n", "        ", "\"\"\"graph - networkx.DiGraph specifying the configuration space.\n                   assumes, cost is stored in the cost parameter\n        \"\"\"", "\n", "self", ".", "graph", "=", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Networkx_DiGraph.get_edge_cost": [[204, 213], ["None"], "methods", ["None"], ["", "def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Returns edge_cost of going from coord1 to coord2\n\n        coord1, coord2 - node identification\n\n        returns:\n        edge cost\n        \"\"\"", "\n", "return", "self", ".", "graph", "[", "coord1", "]", "[", "coord2", "]", "[", "'cost'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Networkx_DiGraph.get_neighbors": [[214, 223], ["workspace_graph.Networkx_DiGraph.graph.neighbors"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the out-neighbors of the specified node\n\n        coord - identifier of the node to query\n\n        returns:\n        list of node identifiers of neighboring nodes\n        \"\"\"", "\n", "return", "self", ".", "graph", ".", "neighbors", "(", "coord", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Networkx_DiGraph.get_in_neighbors": [[224, 233], ["workspace_graph.Networkx_DiGraph.graph.in_edges"], "methods", ["None"], ["", "def", "get_in_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the in-neighbors of the specified node\n\n        coord - identifier of the node to query\n\n        returns:\n        list of node identifiers of in-neighbors\n        \"\"\"", "\n", "return", "[", "c", "[", "0", "]", "for", "c", "in", "self", ".", "graph", ".", "in_edges", "(", "coord", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Grid_Graph.__init__": [[245, 259], ["len", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "world_descriptor", ",", "diagonal_cost", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization for grid graph\n\n        world_descriptor - Rectangular matrix, 0 for free cell, 1 for obstacle\n        diagonal_cost    - Boolean, apply 2**.5 for diagonal cost\n        \"\"\"", "\n", "self", ".", "world_descriptor", "=", "world_descriptor", "\n", "self", ".", "width", "=", "len", "(", "world_descriptor", ")", "\n", "self", ".", "height", "=", "len", "(", "world_descriptor", "[", "0", "]", ")", "\n", "self", ".", "actions", "=", "CONNECTED_4", "\n", "if", "diagonal_cost", ":", "\n", "            ", "self", ".", "_diagonal_cost", "=", "DIAGONAL_COST", "\n", "", "else", ":", "\n", "            ", "self", ".", "_diagonal_cost", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Grid_Graph.get_edge_cost": [[260, 275], ["None"], "methods", ["None"], ["", "", "def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Retrieves config edge cost between two configurations\n\n        Grid_Graph has a fixed edge cost of one, effectively optimizing\n        make-span\n\n        coord1 - coordinate of source vertex\n        coord2 - coordinate of target vertex\n\n        Returns edge_cost of going from coord1 to coord2.\n        \"\"\"", "\n", "if", "(", "self", ".", "_diagonal_cost", "and", "coord1", "[", "0", "]", "!=", "coord2", "[", "0", "]", "and", "\n", "coord1", "[", "1", "]", "!=", "coord2", "[", "1", "]", ")", ":", "\n", "            ", "return", "self", ".", "_diagonal_cost", "\n", "", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Grid_Graph.get_neighbors": [[276, 299], ["neighbors.append"], "methods", ["None"], ["", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns collision free neighbors of the specified coordinate.\n\n        coord - (x, y) coordinate of the node for which neighbors are\n                being generated\n\n        Return value in form of list of (x, y) tuples giving coordinates\n        of neighbors, including self\n        \"\"\"", "\n", "neighbors", "=", "[", "]", "\n", "min_cost", "=", "MAX_COST", "\n", "for", "i", "in", "self", ".", "actions", ":", "\n", "            ", "new_coord", "=", "(", "i", "[", "0", "]", "+", "coord", "[", "0", "]", ",", "i", "[", "1", "]", "+", "coord", "[", "1", "]", ")", "\n", "# check if points to a coordinate in the graph", "\n", "if", "(", "new_coord", "[", "0", "]", "<", "0", "or", "new_coord", "[", "0", "]", ">=", "self", ".", "width", "or", "\n", "new_coord", "[", "1", "]", "<", "0", "or", "new_coord", "[", "1", "]", ">=", "self", ".", "height", ")", ":", "\n", "                ", "continue", "\n", "", "if", "self", ".", "world_descriptor", "[", "new_coord", "[", "0", "]", "]", "[", "new_coord", "[", "1", "]", "]", "==", "OBS", ":", "\n", "# Points to obstacle", "\n", "                ", "continue", "\n", "# Valid single robot action", "\n", "", "neighbors", ".", "append", "(", "new_coord", ")", "\n", "\n", "", "return", "neighbors", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Grid_Graph.get_in_neighbors": [[300, 313], ["workspace_graph.Grid_Graph.get_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors"], ["\n", "", "def", "get_in_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the collision free in-neighbors of the specified\n        coordinate.\n\n        Equivalent to get_neighbors, because the graph is undirected\n\n        coord - (x, y) coordinate of vertex for which to return the\n                in-neighbors\n\n        Returns:\n        List of coordinates of in-neighbors\n        \"\"\"", "\n", "return", "self", ".", "get_neighbors", "(", "coord", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Grid_Graph_Conn_8.__init__": [[322, 331], ["workspace_graph.Grid_Graph.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["\n", "def", "__init__", "(", "self", ",", "world_descriptor", ",", "diagonal_cost", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization for grid graph with 8 connectivity\n\n        world_descriptor    - Rectangular matrix, 0 for free cell, 1 for\n                              obstacle\n        \"\"\"", "\n", "super", "(", "Grid_Graph_Conn_8", ",", "self", ")", ".", "__init__", "(", "world_descriptor", ",", "\n", "diagonal_cost", "=", "diagonal_cost", ")", "\n", "self", ".", "actions", "=", "CONNECTED_8", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.GridGraphConn4WaitAtGoal.__init__": [[341, 357], ["workspace_graph.Grid_Graph.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["\n", "def", "__init__", "(", "self", ",", "world_descriptor", ",", "goal", ",", "wait_cost", "=", ".0", ",", "\n", "diagonal_cost", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization for grid graph\n\n        world_descriptor - Rectangular matrix, 0 for free cell, 1 for\n                           obstacle\n        goal             - goal of the robot\n        wait_cost        - cost to incur for waiting at the goal\n                           configuration\n        diagonal_cost    - incur DIAGONAL_COST for moving diagonally,\n                           1 otherwise. included to support subclasses\n        \"\"\"", "\n", "super", "(", "GridGraphConn4WaitAtGoal", ",", "self", ")", ".", "__init__", "(", "\n", "world_descriptor", ",", "diagonal_cost", "=", "diagonal_cost", ")", "\n", "self", ".", "_goal", "=", "goal", "\n", "self", ".", "_wait_cost", "=", "wait_cost", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.GridGraphConn4WaitAtGoal.get_edge_cost": [[358, 373], ["workspace_graph.Grid_Graph.get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["\n", "", "def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Retrieves edge cost between two configurations\n\n        Waiting at the goal incurs cost wait_cost, while any other\n        action incurs cost self._wait_cost\n\n        coord1 - coordinate of source vertex\n        coord2 - coordinate of target vertex\n\n        Returns edge_cost of going from coord1 to coord2.\n        \"\"\"", "\n", "if", "coord1", "==", "self", ".", "_goal", "and", "coord2", "==", "self", ".", "_goal", ":", "\n", "            ", "return", "self", ".", "_wait_cost", "\n", "", "return", "super", "(", "GridGraphConn4WaitAtGoal", ",", "self", ")", ".", "get_edge_cost", "(", "coord1", ",", "\n", "coord2", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.GridGraphConn8WaitAtGoal.__init__": [[383, 399], ["workspace_graph.GridGraphConn4WaitAtGoal.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["\n", "def", "__init__", "(", "self", ",", "world_descriptor", ",", "goal", ",", "wait_cost", "=", ".0", ",", "\n", "diagonal_cost", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization for grid graph\n\n        world_descriptor - Rectangular matrix, 0 for free cell, 1 for\n                           obstacle\n        goal             - goal of the robot\n        wait_cost        - cost to incur for waiting at the goal\n                           configuration\n        diagonal_cost    - incur DIAGONAL_COST for moving diagonally if True,\n                           incur 1 if False\n        \"\"\"", "\n", "super", "(", "GridGraphConn8WaitAtGoal", ",", "self", ")", ".", "__init__", "(", "\n", "world_descriptor", ",", "goal", ",", "wait_cost", "=", "wait_cost", ",", "\n", "diagonal_cost", "=", "diagonal_cost", ")", "\n", "self", ".", "actions", "=", "CONNECTED_8", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.__init__": [[533, 566], ["config_graph", "workspace_graph.Astar_Policy._get_node", "SortedCollection.SortedCollection"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node"], ["\n", "def", "__init__", "(", "self", ",", "world_descriptor", ",", "config_graph", ",", "goal", "=", "None", ",", "\n", "compute_heuristic", "=", "compute_heuristic_conn_4", ")", ":", "\n", "        ", "\"\"\"Initialization function for Astar_Policy\n\n        world_descriptor  - two-dimensional matrix which describes the\n                            gridworld with obstacles. Each point in the\n                            matrix is either a zero (no obstacle) or a\n                            one (obstacle)\n        config_graph      - a callable that takes a single argument, the\n                            world descriptor, and returns an object that\n                            represents the configuration graph, which\n                            implements the methods defined by\n                            Graph_Interface\n        goal              - (x, y)  target, optional, if not supplied,\n                            will not generate policy\n        compute_heuristic - helper function used to calculate the\n                            heuristic distance to the goal. Passed in\n                            because it interacts with the workspace\n        \"\"\"", "\n", "self", ".", "cspace", "=", "config_graph", "(", "world_descriptor", ")", "\n", "self", ".", "graph", "=", "{", "}", "\n", "self", ".", "iteration", "=", "0", "\n", "self", ".", "goal", "=", "goal", "\n", "self", ".", "init_pos", "=", "self", ".", "goal", "\n", "self", ".", "compute_heuristic", "=", "compute_heuristic", "\n", "self", ".", "goal_node", "=", "self", ".", "_get_node", "(", "self", ".", "goal", ")", "\n", "# We implicitly assume a self loop by setting the goal node's", "\n", "# policy to be its own coordin", "\n", "self", ".", "goal_node", ".", "policy", "=", "self", ".", "goal_node", ".", "coord", "\n", "self", ".", "goal_node", ".", "cost", "=", "0", "\n", "self", ".", "goal_node", ".", "open", "=", "True", "\n", "self", ".", "open_list", "=", "SortedCollection", ".", "SortedCollection", "(", "\n", "[", "self", ".", "goal_node", "]", ",", "key", "=", "lambda", "x", ":", "-", "x", ".", "cost", "-", "x", ".", "h", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node": [[567, 584], ["workspace_graph.Astar_Policy.compute_heuristic", "workspace_graph.wrk_node"], "methods", ["None"], ["\n", "", "def", "_get_node", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns node specified by coord\n\n        In addition, updates its heursitic and iteration values.  If no\n        such node exists, it is created.\n\n        coord - coordinate of node to return\n        \"\"\"", "\n", "try", ":", "\n", "            ", "node", "=", "self", ".", "graph", "[", "coord", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "node", "=", "self", ".", "graph", "[", "coord", "]", "=", "wrk_node", "(", "coord", ")", "\n", "\n", "", "if", "self", ".", "iteration", ">", "node", ".", "iteration", ":", "\n", "            ", "node", ".", "iteration", "=", "self", ".", "iteration", "\n", "node", ".", "h", "=", "self", ".", "compute_heuristic", "(", "self", ".", "init_pos", ",", "coord", ")", "\n", "", "return", "node", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._compute_path": [[585, 633], ["col_set_addition.NoSolutionError", "len", "workspace_graph.Astar_Policy.open_list.pop", "workspace_graph.Astar_Policy.get_neighbors", "workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy.open_list.insert_right", "workspace_graph.Astar_Policy.get_edge_cost", "workspace_graph.Astar_Policy.get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert_right", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["\n", "", "def", "_compute_path", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Extends the search to reach the specified node\n\n        coord - (x,y) coordinate of targeted configuration\n\n        Tries to compute path from coord to goal.  If successful,\n        returns next coordinate in path to goal from coord.  If not\n        successful, raises an NoSolutionError.\n        \"\"\"", "\n", "if", "self", ".", "init_pos", "==", "self", ".", "goal", ":", "\n", "            ", "self", ".", "init_pos", "=", "coord", "\n", "# First need to update the heuristic for nodes in the open", "\n", "# list", "\n", "# Only change the heuristic for the intial coordinate, when the", "\n", "# open list is empty, so don't actually have to resort the open", "\n", "# list", "\n", "# Open list may be empty if trying after trying to find paths to", "\n", "# two unreachable nodes.  This will only be done my", "\n", "# multi_assignment_mstar while trying to compute the assignment", "\n", "# cost matrix.  Besides which, this will trigger a", "\n", "# NoSolutionError in case such a situtation is not supposed to", "\n", "# be found assert len(self.open_list) > 0", "\n", "", "while", "len", "(", "self", ".", "open_list", ")", ">", "0", ":", "\n", "            ", "node", "=", "self", ".", "open_list", ".", "pop", "(", ")", "\n", "if", "node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "node", ".", "closed", "=", "True", "\n", "node", ".", "open", "=", "False", "\n", "# Need to add the neighbors before checking if this is the", "\n", "# goal, so search can be resumed without being blocked by", "\n", "# this position", "\n", "neighbors", "=", "self", ".", "get_neighbors", "(", "node", ".", "coord", ")", "\n", "for", "i", "in", "neighbors", ":", "\n", "                ", "tnode", "=", "self", ".", "_get_node", "(", "i", ")", "\n", "if", "(", "tnode", ".", "closed", "or", "tnode", ".", "cost", "<=", "node", ".", "cost", "+", "\n", "self", ".", "get_edge_cost", "(", "i", ",", "node", ".", "coord", ")", ")", ":", "\n", "                    ", "continue", "\n", "", "tnode", ".", "cost", "=", "node", ".", "cost", "+", "self", ".", "get_edge_cost", "(", "\n", "i", ",", "node", ".", "coord", ")", "\n", "tnode", ".", "policy", "=", "node", ".", "coord", "\n", "tnode", ".", "open", "=", "True", "\n", "# Can add tnode directly, and will just skip any", "\n", "# inconsistent copies", "\n", "self", ".", "open_list", ".", "insert_right", "(", "tnode", ")", "\n", "", "if", "node", ".", "coord", "==", "coord", ":", "\n", "# Done, so return the next step", "\n", "                ", "return", "node", ".", "policy", "\n", "", "", "raise", "NoSolutionError", "(", "'Couldn\\'t finish individual policy'", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_step": [[634, 653], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy._compute_path"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy._compute_path"], ["\n", "", "def", "get_step", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Gets the policy for the given coordinate\n\n        If no policy exists, extends planning to reach the coordinate\n\n        coord - (x, y) configuration\n\n        Returns a coordinate of the next node in the policy\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "node", ".", "closed", ":", "\n", "# Have already computed the optimal policy here", "\n", "            ", "return", "node", ".", "policy", "\n", "", "self", ".", "iteration", "+=", "1", "\n", "try", ":", "\n", "            ", "return", "self", ".", "_compute_path", "(", "coord", ")", "\n", "", "except", "NoSolutionError", ":", "\n", "# Couldn't find a path to goal, so return None", "\n", "            ", "return", "None", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_cost": [[654, 669], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy._compute_path"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy._compute_path"], ["\n", "", "", "def", "get_cost", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the cost of moving from given position to goal\n\n        Cost is for moving from coordinate specified at coord\n        to the goal configuration.\n\n        coord - (x, y) configuration\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "node", ".", "closed", ":", "\n", "            ", "return", "node", ".", "cost", "\n", "", "self", ".", "iteration", "+=", "1", "\n", "self", ".", "_compute_path", "(", "coord", ")", "\n", "assert", "node", ".", "closed", "\n", "return", "node", ".", "cost", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost": [[670, 683], ["workspace_graph.Astar_Policy.cspace.get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["\n", "", "def", "get_edge_cost", "(", "self", ",", "coord1", ",", "coord2", ")", ":", "\n", "        ", "\"\"\"Returns cost of config transition from coord1 to coord2\n\n        Wrapper function for returning the config space's\n        get_edge_cost from coord1 to coord2\n\n        coord1 - initial coordinate in transition\n        coord2 - final coordinate in transition\n\n        returns:\n        edge cost of going from coord1 to coord2\n        \"\"\"", "\n", "return", "self", ".", "cspace", ".", "get_edge_cost", "(", "coord1", ",", "coord2", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._gen_limited_offset_neighbors": [[684, 707], ["workspace_graph.Astar_Policy._get_node", "collections.defaultdict", "workspace_graph.Astar_Policy.get_cost", "workspace_graph.Astar_Policy.get_neighbors", "dict", "workspace_graph.Astar_Policy.opt_neighbors[].append", "workspace_graph.Astar_Policy.get_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["\n", "", "def", "_gen_limited_offset_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Stores the neighbors of a node by changes in f-value\n\n        f-value - the sum of cost to reach and cost to go.\n\n        coord - (x, y) configuration for which limited offset neighbors\n                are generated\n        \"\"\"", "\n", "# Repurposing a preexisting field, so need to change to a", "\n", "# defaultdict", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "node", ".", "opt_neighbors", "=", "defaultdict", "(", "lambda", ":", "[", "]", ")", "\n", "base_cost", "=", "self", ".", "get_cost", "(", "coord", ")", "\n", "# Need to compute offsets", "\n", "for", "neib", "in", "self", ".", "get_neighbors", "(", "coord", ")", ":", "\n", "# difference in path cost using different paths, need to", "\n", "# handle staying at the goal seperately", "\n", "            ", "if", "neib", "==", "self", ".", "goal", "and", "neib", "==", "coord", ":", "\n", "                ", "offset", "=", "0", "\n", "", "else", ":", "\n", "                ", "offset", "=", "self", ".", "get_cost", "(", "neib", ")", "-", "base_cost", "+", "1", "\n", "", "node", ".", "opt_neighbors", "[", "offset", "]", ".", "append", "(", "(", "offset", ",", "neib", ")", ")", "\n", "", "node", ".", "opt_neighbors", "=", "dict", "(", "node", ".", "opt_neighbors", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_limited_offset_neighbors": [[708, 738], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy.opt_neighbors.iteritems", "workspace_graph.Astar_Policy._gen_limited_offset_neighbors", "out.extend"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], ["\n", "", "def", "get_limited_offset_neighbors", "(", "self", ",", "coord", ",", "max_offset", ",", "min_offset", "=", "0", ")", ":", "\n", "        ", "\"\"\"Returns set of neighbors specified by the offsets\n\n        More specifically, returns the set of neighbors for which the\n        maximum difference in path cost if passed through is less than\n        the specified value.\n\n        (i.e. if you are forced to pass through coordinate x, instead of\n        the optimal step, what is the difference in cost)?\n\n        coord - coordinates of the node to find neighbors of\n        max_offset - the maximum increase in path cost to encur in\n                     choice of neighbors\n        min_offset - minimum increae in path cost to encur in a neighbor\n\n        returns:\n        a list of tuples of the form (offset, coordinate)\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "not", "node", ".", "opt_neighbors", ":", "\n", "            ", "self", ".", "_gen_limited_offset_neighbors", "(", "coord", ")", "\n", "# Have already pre-computed the results", "\n", "", "out", "=", "[", "]", "\n", "for", "offset", ",", "neighbors", "in", "node", ".", "opt_neighbors", ".", "iteritems", "(", ")", ":", "\n", "            ", "if", "offset", "<", "min_offset", ":", "\n", "                ", "continue", "\n", "", "if", "offset", ">", "max_offset", ":", "\n", "                ", "return", "out", "\n", "", "out", ".", "extend", "(", "neighbors", ")", "\n", "", "return", "out", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_offset_neighbors": [[739, 758], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], ["\n", "", "def", "get_offset_neighbors", "(", "self", ",", "coord", ",", "offset", ")", ":", "\n", "        ", "\"\"\"Generates offset neighbors for node specified by coord\n\n        If no offset neighbors exist, they are created\n\n        Only offset neighbors at a certain offset are returned\n\n        coord  - (x,y) configuration for which neighbors are being\n                 generated\n        offset - value of offset determing which neighbors are\n                 included in return value\n\n        returns:\n        list of tuples of form (offset, neighbor)\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "not", "node", ".", "opt_neighbors", ":", "\n", "            ", "self", ".", "_gen_limited_offset_neighbors", "(", "coord", ")", "\n", "", "return", "node", ".", "opt_neighbors", "[", "offset", "]", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_offsets": [[759, 775], ["workspace_graph.Astar_Policy._get_node", "workspace_graph.Astar_Policy.opt_neighbors.keys", "workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._gen_limited_offset_neighbors"], ["\n", "", "def", "get_offsets", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Return the possible offsets of the neighbors.\n\n        The offset of a neighbor is the difference in the cost of the\n        optimal path from coord to the cost of the best path constrained\n        to pass through a specific neighbor.  Used in EPEA*\n\n        coord - (x,y) configuration for which neighbors are being\n                generated and their offsets returned\n\n        Returns list of offsets of all neighbor nodes to coord\n        \"\"\"", "\n", "node", "=", "self", ".", "_get_node", "(", "coord", ")", "\n", "if", "not", "node", ".", "opt_neighbors", ":", "\n", "            ", "self", ".", "_gen_limited_offset_neighbors", "(", "coord", ")", "\n", "", "return", "node", ".", "opt_neighbors", ".", "keys", "(", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_neighbors": [[776, 798], ["workspace_graph.Astar_Policy.cspace.get_neighbors", "workspace_graph.Astar_Policy.get_cost", "workspace_graph.Astar_Policy.get_cost", "opt_neighbors.append"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["\n", "", "def", "get_neighbors", "(", "self", ",", "coord", ",", "opt", "=", "False", ")", ":", "\n", "        ", "\"\"\"Wrapper function for get_neighbors function of underlying\n        config_space graph.\n\n        opt - only optimal neighbors are returned\n        coord - configuration for which neighbors are being returned\n\n        Returns list of tuples, where each tuple is a coordinate\n        \"\"\"", "\n", "neighbors", "=", "self", ".", "cspace", ".", "get_neighbors", "(", "coord", ")", "\n", "if", "not", "opt", ":", "\n", "            ", "return", "neighbors", "\n", "", "for", "i", "in", "neighbors", ":", "\n", "            ", "if", "opt", ":", "\n", "                ", "cost", "=", "self", ".", "get_cost", "(", "i", ")", "\n", "if", "cost", "<", "min_cost", ":", "\n", "                    ", "min_cost", "=", "cost", "\n", "", "", "", "opt_neighbors", "=", "[", "]", "\n", "for", "i", "in", "neighbors", ":", "\n", "            ", "if", "self", ".", "get_cost", "(", "i", ")", "==", "min_cost", ":", "\n", "                ", "opt_neighbors", ".", "append", "(", "i", ")", "\n", "", "", "return", "opt_neighbors", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_graph_size": [[799, 807], ["sum", "map"], "methods", ["None"], ["\n", "", "def", "get_graph_size", "(", "self", ",", "correct_for_size", "=", "True", ")", ":", "\n", "        ", "\"\"\"Gets the size of the graph\n\n        correct_for_size - just intended to match signatures\n\n        Returns the number of nodes used for this graph\n        \"\"\"", "\n", "return", "sum", "(", "map", "(", "len", ",", "self", ".", "graph", ")", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy.__init__": [[825, 844], ["workspace_graph.Astar_Policy.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["\n", "def", "__init__", "(", "self", ",", "world_descriptor", ",", "config_graph", ",", "goal", "=", "None", ",", "\n", "compute_heuristic", "=", "compute_heuristic_conn_4", ")", ":", "\n", "        ", "\"\"\"Initialization function for Astar_Policy\n\n        world_descriptor  - two-dimensional matrix which describes the\n                            gridworld with obstacles. Each point in the\n                            matrix is either a zero (no obstacle) or a\n                            one (obstacle)\n        config_graph      - a class which is used to represent the\n                            config space of the robot\n        goal              - (x, y)  target, optional, if not supplied,\n                            will not generate policy\n        compute_heuristic - helper function used to calculate the\n                            heuristic distance to the goal. Passed in\n                            because it interacts with the workspace\n        \"\"\"", "\n", "super", "(", "Astar_DiGraph_Policy", ",", "self", ")", ".", "__init__", "(", "\n", "world_descriptor", ",", "config_graph", ",", "goal", "=", "goal", ",", "\n", "compute_heuristic", "=", "compute_heuristic", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy._compute_path": [[845, 897], ["col_set_addition.NoSolutionError", "len", "workspace_graph.Astar_DiGraph_Policy.open_list.pop", "workspace_graph.Astar_DiGraph_Policy.get_in_neighbors", "workspace_graph.Astar_DiGraph_Policy._get_node", "workspace_graph.Astar_DiGraph_Policy.open_list.insert_right", "workspace_graph.Astar_DiGraph_Policy.get_edge_cost", "workspace_graph.Astar_DiGraph_Policy.get_edge_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.pop", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy.get_in_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy._get_node", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.SortedCollection.SortedCollection.insert_right", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Policy.get_edge_cost"], ["\n", "", "def", "_compute_path", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Extends the search to reach the specified node\n\n        Explicitly plans in reverse from the goal to the target, using\n        get_in_neighbors to compute node expansion, instead of\n        Astar_Graph, which uses the get_neighbors function.\n\n        coord - (x,y) coordinate of targeted configuration\n\n        Tries to compute path from coord to goal.  If successful,\n        returns next coordinate in path to goal from coord.  If not\n        successful, raises an NoSolutionError.\n        \"\"\"", "\n", "if", "self", ".", "init_pos", "==", "self", ".", "goal", ":", "\n", "            ", "self", ".", "init_pos", "=", "coord", "\n", "# First need to update the heuristic for nodes in the open", "\n", "# list", "\n", "# Only change the heuristic for the intial coordinate, when the", "\n", "# open list is empty, so don't actually have to resort the open", "\n", "# list", "\n", "# Open list may be empty if trying after trying to find paths to", "\n", "# two unreachable nodes.  This will only be done my", "\n", "# multi_assignment_mstar while trying to compute the assignment", "\n", "# cost matrix.  Besides which, this will trigger a", "\n", "# NoSolutionError in case such a situtation is not supposed to", "\n", "# be found assert len(self.open_list) > 0", "\n", "", "while", "len", "(", "self", ".", "open_list", ")", ">", "0", ":", "\n", "            ", "node", "=", "self", ".", "open_list", ".", "pop", "(", ")", "\n", "if", "node", ".", "closed", ":", "\n", "                ", "continue", "\n", "", "node", ".", "closed", "=", "True", "\n", "node", ".", "open", "=", "False", "\n", "# Need to add the neighbors before checking if this is the", "\n", "# goal, so search can be resumed without being blocked by", "\n", "# this position", "\n", "neighbors", "=", "self", ".", "get_in_neighbors", "(", "node", ".", "coord", ")", "\n", "for", "i", "in", "neighbors", ":", "\n", "                ", "tnode", "=", "self", ".", "_get_node", "(", "i", ")", "\n", "if", "(", "tnode", ".", "closed", "or", "tnode", ".", "cost", "<=", "node", ".", "cost", "+", "\n", "self", ".", "get_edge_cost", "(", "i", ",", "node", ".", "coord", ")", ")", ":", "\n", "                    ", "continue", "\n", "", "tnode", ".", "cost", "=", "node", ".", "cost", "+", "self", ".", "get_edge_cost", "(", "\n", "i", ",", "node", ".", "coord", ")", "\n", "tnode", ".", "policy", "=", "node", ".", "coord", "\n", "tnode", ".", "open", "=", "True", "\n", "# Can add tnode directly, and will just skip any", "\n", "# inconsistent copies", "\n", "self", ".", "open_list", ".", "insert_right", "(", "tnode", ")", "\n", "", "if", "node", ".", "coord", "==", "coord", ":", "\n", "# Done, so return the next step", "\n", "                ", "return", "node", ".", "policy", "\n", "", "", "raise", "NoSolutionError", "(", "'Couldn\\'t finish individual policy'", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy.get_in_neighbors": [[898, 909], ["workspace_graph.Astar_DiGraph_Policy.cspace.get_in_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_DiGraph_Policy.get_in_neighbors"], ["\n", "", "def", "get_in_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Wraper for the get_in_neighbors function of the underlying\n        config_space graph\n\n        coord - coordinate of whom the predecessors (in neighbors) are\n                returned\n\n        returns:\n        list of coordinates of the predecessors of coord\n        \"\"\"", "\n", "return", "self", ".", "cspace", ".", "get_in_neighbors", "(", "coord", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Priority_Graph.__init__": [[920, 929], ["None"], "methods", ["None"], ["\n", "def", "__init__", "(", "self", ",", "astar_policy", ",", "max_t", "=", "None", ")", ":", "\n", "        ", "\"\"\"initialization for Priority_Graph\n\n        astar_policy       - the graph to wrap\n\n        max_t - greatest t - value allowed\n        \"\"\"", "\n", "self", ".", "astar_policy", "=", "astar_policy", "\n", "self", ".", "max_t", "=", "max_t", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Priority_Graph.get_step": [[930, 947], ["workspace_graph.Priority_Graph.astar_policy.get_step", "min"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["\n", "", "def", "get_step", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Gets the policy for the given coordinate,\n\n        If necessary, extends planning to reach said coordinate.  Will\n        increment time by 1\n\n        coord - (x, y, t) position and time coordinate for the specified\n                node\n        \"\"\"", "\n", "# Can do this by stripping time, querrying the underlying", "\n", "# astar_policy, then appending the appropriate new time", "\n", "t", "=", "coord", "[", "-", "1", "]", "+", "1", "\n", "# Check if this would exceed maximal value", "\n", "if", "self", ".", "max_t", "is", "not", "None", ":", "\n", "            ", "t", "=", "min", "(", "self", ".", "max_t", ",", "t", ")", "\n", "", "step", "=", "self", ".", "astar_policy", ".", "get_step", "(", "coord", "[", ":", "2", "]", ")", "\n", "return", "step", "+", "(", "t", ",", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Priority_Graph.get_cost": [[948, 956], ["workspace_graph.Priority_Graph.astar_policy.get_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["\n", "", "def", "get_cost", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Gets cost of moving to goal from coord\n\n        coord - (x, y, t)  coordinates of node for which to get cost\n\n        Returns cost of moving from the given position to goal\n        \"\"\"", "\n", "return", "self", ".", "astar_policy", ".", "get_cost", "(", "coord", "[", ":", "2", "]", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Priority_Graph.set_max_t": [[957, 963], ["None"], "methods", ["None"], ["\n", "", "def", "set_max_t", "(", "self", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Sets the maximum time value the graph will use.\n\n        Allows for easy changes for different constraints\n        \"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Priority_Graph.get_neighbors": [[964, 976], ["workspace_graph.Priority_Graph.astar_policy.get_neighbors", "map", "min"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors"], ["\n", "", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Gets the neighbors of the specified space-time point\n\n        coord - coordinate of configuration for which neighbors are\n                being returned\n\n        Returns neighbors of coord in config space, with a time stamp\n        one greater than that of coord\n        \"\"\"", "\n", "pos_neighbors", "=", "self", ".", "astar_policy", ".", "get_neighbors", "(", "(", "coord", "[", "0", "]", ",", "coord", "[", "1", "]", ")", ")", "\n", "return", "map", "(", "lambda", "x", ":", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "min", "(", "self", ".", "max_t", ",", "coord", "[", "-", "1", "]", "+", "1", ")", ")", ",", "\n", "pos_neighbors", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.__init__": [[994, 1006], ["workspace_graph.Priority_Graph.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["\n", "def", "__init__", "(", "self", ",", "astar_policy", ",", "max_t", "=", "None", ",", "prune_paths", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        astar_policy - the graph to wrap\n        max_t       - greatest t-value allowed\n        prune_paths - whether to prune neighbors that cannot reach the\n                      goal of astar_policy within the time specified.\n                      This is the default behavior.  Disabling when\n                      running task swapping allows for paths to be found\n                      to multiple initial configurations\n        \"\"\"", "\n", "Priority_Graph", ".", "__init__", "(", "self", ",", "astar_policy", ",", "max_t", "=", "max_t", ")", "\n", "self", ".", "prune_paths", "=", "prune_paths", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_neighbors": [[1007, 1033], ["workspace_graph.Back_Priority_Graph.astar_policy.get_neighbors", "neighbors.append", "neighbors.append", "neighbors.append", "workspace_graph.Back_Priority_Graph.astar_policy.get_cost", "workspace_graph.Back_Priority_Graph.astar_policy.get_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost", "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["\n", "", "def", "get_neighbors", "(", "self", ",", "coord", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Gets the neighbors of the specified space-time point\"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "if", "coord", "[", "-", "1", "]", "==", "0", "and", "self", ".", "max_t", "!=", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "pos_neighbors", "=", "self", ".", "astar_policy", ".", "get_neighbors", "(", "(", "coord", "[", "0", "]", ",", "coord", "[", "1", "]", ")", ")", "\n", "if", "coord", "[", "-", "1", "]", "==", "self", ".", "max_t", ":", "\n", "            ", "neighbors", "=", "[", "]", "\n", "for", "pos", "in", "pos_neighbors", ":", "\n", "                ", "neighbors", ".", "append", "(", "(", "pos", "[", "0", "]", ",", "pos", "[", "1", "]", ",", "self", ".", "max_t", ")", ")", "\n", "# Make sure that you can actually get form the initial", "\n", "# position to the suggested vertex in time", "\n", "if", "self", ".", "prune_paths", ":", "\n", "                    ", "if", "(", "not", "self", ".", "max_t", "==", "0", "and", "\n", "self", ".", "astar_policy", ".", "get_cost", "(", "pos", ")", "<=", "coord", "[", "-", "1", "]", "-", "1", ")", ":", "\n", "                        ", "neighbors", ".", "append", "(", "(", "pos", "[", "0", "]", ",", "pos", "[", "1", "]", ",", "coord", "[", "-", "1", "]", "-", "1", ")", ")", "\n", "", "", "else", ":", "\n", "# Don't check on whether there is time to reach the", "\n", "# intial configuration", "\n", "                    ", "neighbors", ".", "append", "(", "(", "pos", "[", "0", "]", ",", "pos", "[", "1", "]", ",", "coord", "[", "-", "1", "]", "-", "1", ")", ")", "\n", "", "", "return", "neighbors", "\n", "", "if", "self", ".", "prune_paths", ":", "\n", "            ", "return", "[", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "coord", "[", "-", "1", "]", "-", "1", ")", "for", "x", "in", "pos_neighbors", "\n", "if", "self", ".", "astar_policy", ".", "get_cost", "(", "x", ")", "<=", "coord", "[", "-", "1", "]", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "coord", "[", "-", "1", "]", "-", "1", ")", "for", "x", "in", "pos_neighbors", "]", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_forwards_neighbors": [[1034, 1038], ["workspace_graph.Priority_Graph.get_neighbors"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors"], ["\n", "", "", "def", "get_forwards_neighbors", "(", "self", ",", "coord", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Gets the forward time dynamics neighbors of this point\"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "return", "Priority_Graph", ".", "get_neighbors", "(", "self", ",", "coord", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost": [[1039, 1047], ["workspace_graph.Priority_Graph.get_cost"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_cost"], ["\n", "", "def", "get_cost", "(", "self", ",", "coord", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Returns the cost of moving from given position to goal\n\n        coord - (x, y, t)  coordinates of node for which to get cost\n\n        \"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "return", "Priority_Graph", ".", "get_cost", "(", "self", ",", "coord", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step": [[1048, 1058], ["workspace_graph.Priority_Graph.get_step"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Back_Priority_Graph.get_step"], ["\n", "", "def", "get_step", "(", "self", ",", "coord", ",", "max_t", ")", ":", "\n", "        ", "\"\"\"Gets the policy for the given coordinate, extending planning\n        to reach said coordinate if necessary.  Will increment time by 1\n\n        coord - (x, y, t) position and time coordinate for the specified\n                node\n\n        \"\"\"", "\n", "self", ".", "max_t", "=", "max_t", "\n", "return", "Priority_Graph", ".", "get_step", "(", "self", ",", "coord", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.__init__": [[1069, 1072], ["workspace_graph.Astar_Policy.__init__"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__"], ["\n", "def", "__init__", "(", "self", ",", "world_descriptor", ",", "goal", ",", "limit_graph", ",", "connect_8", "=", "False", ")", ":", "\n", "        ", "Astar_Policy", ".", "__init__", "(", "self", ",", "world_descriptor", ",", "goal", ",", "connect_8", ")", "\n", "self", ".", "limit_graph", "=", "limit_graph", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Limited_Astar_Policy.get_neighbors": [[1073, 1079], ["workspace_graph.Limited_Astar_Policy.limit_graph.neighbors"], "methods", ["None"], ["\n", "", "def", "get_neighbors", "(", "self", ",", "coord", ")", ":", "\n", "        ", "\"\"\"Returns the neighbors of the given coordinate in the limit\n        graph\n\n        \"\"\"", "\n", "return", "self", ".", "limit_graph", ".", "neighbors", "(", "coord", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.__init__": [[1086, 1092], ["None"], "methods", ["None"], ["\n", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Takes no arguments, because on grid graph, only the\n        coordinates matter\n\n        \"\"\"", "\n", "pass", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.simple_pass_through": [[1093, 1110], ["range", "len", "range", "len"], "methods", ["None"], ["\n", "", "def", "simple_pass_through", "(", "self", ",", "c1", ",", "c2", ")", ":", "\n", "        ", "\"\"\"Simply check for collisions, avoid the additional overhead\n\n        for use with basic OD (op_decomp)\n\n        c1 - coordinate at time t\n        c2 - coordinate at time t + 1\n\n        returns:\n        True if pass through collision, else false\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c2", "[", "j", "]", "and", "c1", "[", "j", "]", "==", "c2", "[", "i", "]", ":", "\n", "                    ", "return", "True", "\n", "", "", "", "return", "False", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.simple_col_check": [[1111, 1125], ["range", "len", "range", "len"], "methods", ["None"], ["\n", "", "def", "simple_col_check", "(", "self", ",", "c1", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions at c1,\n\n        for use with basic OD (op_decomp)\n\n        returns:\n        True if collision exists\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                    ", "return", "True", "\n", "", "", "", "return", "False", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.simple_cross_over": [[1126, 1146], ["range", "len", "range", "len", "abs", "abs"], "methods", ["None"], ["\n", "", "def", "simple_cross_over", "(", "self", ",", "c1", ",", "c2", ")", ":", "\n", "        ", "\"\"\"Check for cross over collisions in 8-connected worlds\n\n        returns:\n        True if collision is detected\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "# compute displacement vector", "\n", "                ", "disp", "=", "[", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                    ", "continue", "\n", "# compute previous? displacement vector.  Have a pass", "\n", "# through or cross over collision if the displacement", "\n", "# vector is the opposite", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                    ", "return", "True", "\n", "", "", "", "return", "False", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.simple_incremental_cross_over": [[1147, 1166], ["range", "len", "abs", "abs"], "methods", ["None"], ["\n", "", "def", "simple_incremental_cross_over", "(", "self", ",", "c1", ",", "c2", ")", ":", "\n", "        ", "\"\"\"Check for cross over collisions in 8-connected worlds.\n\n        Assumes that collision checking has been performed for everything\n        but the last robot in the coordinates.  To be used to save a bit\n        of time for partial expansion approaches\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "disp", "=", "[", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "-", "1", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "-", "1", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                ", "continue", "\n", "# compute previous? displacement vector.  Have a pass through", "\n", "# or cross over collision if the displacement vector is the", "\n", "# opposite", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "-", "1", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "-", "1", "]", "[", "1", "]", ")", ")", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "False", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.simple_incremental_col_check": [[1167, 1180], ["range", "len"], "methods", ["None"], ["\n", "", "def", "simple_incremental_col_check", "(", "self", ",", "c1", ")", ":", "\n", "        ", "\"\"\"Checks for robot-robot collisions at c1,\n\n        for use with basic OD (op_decomp)\n\n        returns:\n        True if collision exists\n\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "if", "c1", "[", "i", "]", "==", "c1", "[", "-", "1", "]", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "False", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.single_bot_outpath_check": [[1181, 1218], ["min", "range", "len", "len", "len", "abs", "abs"], "methods", ["None"], ["\n", "", "def", "single_bot_outpath_check", "(", "self", ",", "cur_coord", ",", "prev_coord", ",", "cur_t", ",", "paths", ")", ":", "\n", "        ", "\"\"\"Tests for collisions when moving from prev_coord to cur_coord\n        with the robots in paths.\n\n        cur_coord - position of a single robot\n\n        Returns:\n\n        True if a collision is found,\n        False otherwise\n\n        \"\"\"", "\n", "if", "paths", "is", "None", ":", "\n", "            ", "return", "False", "\n", "", "prev_t", "=", "cur_t", "-", "1", "\n", "check_t", "=", "min", "(", "cur_t", ",", "len", "(", "paths", ")", "-", "1", ")", "\n", "new_cols", "=", "0", "\n", "for", "bot", "in", "range", "(", "len", "(", "paths", "[", "0", "]", ")", ")", ":", "\n", "# Check for simultaneous occupation", "\n", "            ", "if", "(", "cur_coord", "[", "0", "]", "==", "paths", "[", "check_t", "]", "[", "bot", "]", "[", "0", "]", "and", "\n", "cur_coord", "[", "1", "]", "==", "paths", "[", "check_t", "]", "[", "bot", "]", "[", "1", "]", ")", ":", "\n", "                ", "return", "True", "\n", "", "if", "cur_t", ">=", "len", "(", "paths", ")", ":", "\n", "# Can't have edge collisions when out-group robots", "\n", "# aren't moving", "\n", "                ", "continue", "\n", "# Check for pass-through/cross over collisions", "\n", "", "disp", "=", "[", "prev_coord", "[", "0", "]", "-", "paths", "[", "prev_t", "]", "[", "bot", "]", "[", "0", "]", ",", "\n", "prev_coord", "[", "1", "]", "-", "paths", "[", "prev_t", "]", "[", "bot", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                ", "continue", "\n", "# Compute current displacement vector, and check for", "\n", "# inversion", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "cur_coord", "[", "0", "]", "-", "paths", "[", "cur_t", "]", "[", "bot", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "cur_coord", "[", "1", "]", "-", "paths", "[", "cur_t", "]", "[", "bot", "]", "[", "1", "]", ")", ")", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "False", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.simple_prio_col_check": [[1219, 1260], ["isinstance", "tuple", "min", "isinstance", "range", "map", "len", "len", "isinstance", "tuple", "isinstance", "tuple", "workspace_graph.Edge_Checker.single_bot_cross_over", "isinstance", "tuple"], "methods", ["home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.single_bot_cross_over"], ["\n", "", "def", "simple_prio_col_check", "(", "self", ",", "coord", ",", "t", ",", "paths", ",", "pcoord", "=", "None", ",", "\n", "conn_8", "=", "False", ")", ":", "\n", "        ", "\"\"\"Returns true, if collision is detected, false otherwise\n        at the moment only used to check the obstacle collisions, but\n        didn't want to reject the other code already\n\n        coord - coord of potential new neighbor\n        t - current time step\n        paths - previously found paths\n        pcoord - previous coordinate of the path\n\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "coord", ",", "tuple", ")", ":", "\n", "            ", "coord", "=", "tuple", "(", "coord", ")", "\n", "", "if", "paths", "is", "not", "None", ":", "\n", "            ", "t", "=", "min", "(", "t", ",", "len", "(", "paths", ")", "-", "1", ")", "\n", "# only one path", "\n", "if", "isinstance", "(", "paths", "[", "0", "]", "[", "0", "]", ",", "int", ")", ":", "\n", "                ", "paths", "=", "map", "(", "lambda", "x", ":", "[", "x", "]", ",", "paths", ")", "\n", "", "for", "bot", "in", "range", "(", "len", "(", "paths", "[", "t", "]", ")", ")", ":", "\n", "                ", "if", "not", "isinstance", "(", "paths", "[", "t", "]", "[", "bot", "]", ",", "tuple", ")", ":", "\n", "                    ", "paths", "[", "t", "]", "[", "bot", "]", "=", "tuple", "(", "paths", "[", "t", "]", "[", "bot", "]", ")", "\n", "# (a) simultaneous occupation of one node", "\n", "", "if", "coord", "==", "paths", "[", "t", "]", "[", "bot", "]", ":", "\n", "                        ", "return", "True", "\n", "# (b) pass through and cross over collision", "\n", "", "if", "pcoord", "is", "not", "None", ":", "\n", "                    ", "if", "not", "isinstance", "(", "pcoord", ",", "tuple", ")", ":", "\n", "                        ", "pcoord", "=", "tuple", "(", "pcoord", ")", "\n", "", "", "if", "not", "isinstance", "(", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", ",", "tuple", ")", ":", "\n", "                    ", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", "=", "tuple", "(", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", ")", "\n", "", "if", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", "==", "coord", "and", "paths", "[", "t", "]", "[", "bot", "]", "==", "pcoord", ":", "\n", "                    ", "return", "True", "\n", "# (c) cross over collision in case of conn_8", "\n", "", "if", "conn_8", ":", "\n", "                    ", "if", "self", ".", "single_bot_cross_over", "(", "paths", "[", "t", "]", "[", "bot", "]", ",", "\n", "paths", "[", "t", "-", "1", "]", "[", "bot", "]", ",", "coord", ",", "\n", "pcoord", ")", ":", "\n", "                        ", "return", "True", "\n", "# No collision", "\n", "", "", "", "", "return", "False", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.col_check": [[1261, 1277], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["\n", "", "def", "col_check", "(", "self", ",", "c1", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single point.  Returns either a M*\n        or rM* collision set in the form of sets, depending on the\n        setting of recursive.\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.incremental_col_check": [[1278, 1295], ["range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["\n", "", "def", "incremental_col_check", "(", "self", ",", "c1", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single point.  Returns either a M*\n        or rM* collision set in the form of sets, depending on the\n        setting of recursive.  Only checks whether the last robot is\n        involved in a collision, for use with incremental methods\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "j", "=", "len", "(", "c1", ")", "-", "1", "\n", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "(", "i", ",", "j", ")", ")", "]", ",", "col_set", ")", "\n", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.cross_over": [[1296, 1323], ["range", "range", "len", "len", "adder", "abs", "abs", "frozenset"], "methods", ["None"], ["\n", "", "def", "cross_over", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "# compute current displacement vector", "\n", "                ", "if", "c1", "[", "i", "]", "is", "None", "or", "c1", "[", "j", "]", "is", "None", "or", "c2", "[", "i", "]", "is", "None", "or", "c2", "[", "j", "]", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "disp", "=", "(", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", ")", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                    ", "continue", "\n", "# Compute previous displacement vector.  Have a cross over or", "\n", "# pass through collision if the two displacement vectors are", "\n", "# opposites", "\n", "# pdisp = [c2[i][0] - c2[j][0], c2[i][1] - c2[j][1]]", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.incremental_cross_over": [[1324, 1355], ["range", "len", "len", "adder", "abs", "abs", "frozenset"], "methods", ["None"], ["\n", "", "def", "incremental_cross_over", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions.\n\n        Only checks if the last robot is involved in a collision, for use\n        with partial expansion approaches.\n\n        c1 - the initial configuration.\n        c2 - the final configuration. c1 may include additional robots,\n             if necessary\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "j", "=", "len", "(", "c2", ")", "-", "1", "\n", "for", "i", "in", "range", "(", "len", "(", "c2", ")", "-", "1", ")", ":", "\n", "# compute current displacement vector", "\n", "            ", "disp", "=", "(", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", ")", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                ", "continue", "\n", "# Compute previous displacement vector.  Have a cross over or", "\n", "# pass through collision if the two displacement vectors are", "\n", "# opposites", "\n", "# pdisp = [c2[i][0] - c2[j][0], c2[i][1] - c2[j][1]]", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.pass_through": [[1356, 1371], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["\n", "", "def", "pass_through", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"returns a tuple of colliding robots, or set of tuples if\n        recursive\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c2", "[", "j", "]", "and", "c1", "[", "j", "]", "==", "c2", "[", "i", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "(", "i", ",", "j", ")", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.single_bot_cross_over": [[1372, 1384], ["abs", "abs"], "methods", ["None"], ["\n", "", "def", "single_bot_cross_over", "(", "self", ",", "coord1", ",", "pcoord1", ",", "coord2", ",", "pcoord2", ")", ":", "\n", "        ", "\"\"\"Checks for cross-over and collisions between robots one and 2\n        moving from pcoord to coord\n\n        \"\"\"", "\n", "disp", "=", "(", "pcoord1", "[", "0", "]", "-", "pcoord2", "[", "0", "]", ",", "pcoord1", "[", "1", "]", "-", "pcoord2", "[", "1", "]", ")", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "            ", "return", "False", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "coord1", "[", "0", "]", "-", "coord2", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "coord1", "[", "1", "]", "-", "coord2", "[", "1", "]", ")", ")", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Edge_Checker.prio_col_check": [[1385, 1421], ["isinstance", "tuple", "isinstance", "tuple", "range", "len", "range", "len", "adder", "adder", "abs", "abs", "frozenset", "frozenset"], "methods", ["None"], ["\n", "", "def", "prio_col_check", "(", "self", ",", "coord", ",", "pcoord", ",", "t", ",", "paths", "=", "None", ",", "conn_8", "=", "False", ",", "\n", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Collision checking with paths passed as constraints\n\n        coord  - current node\n        pcoord - previous node\n        t      - timestep\n        paths  - paths that need to be avoided\n\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "coord", ",", "tuple", ")", ":", "\n", "            ", "coord", "=", "tuple", "(", "coord", ")", "\n", "", "if", "not", "isinstance", "(", "pcoord", ",", "tuple", ")", ":", "\n", "            ", "pcoord", "=", "tuple", "(", "pcoord", ")", "\n", "", "if", "paths", "is", "not", "None", ":", "\n", "            ", "col_set", "=", "[", "]", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "                ", "adder", "=", "add_col_set_recursive", "\n", "", "else", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "coord", ")", ")", ":", "\n", "                    ", "for", "j", "in", "range", "(", "len", "(", "paths", "[", "t", "]", ")", ")", ":", "\n", "# simultaneous occupation", "\n", "                        ", "if", "coord", "[", "i", "]", "==", "paths", "[", "t", "]", "[", "j", "]", ":", "\n", "                            ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "# pass-through and cross-over", "\n", "", "disp", "=", "[", "pcoord", "[", "i", "]", "[", "0", "]", "-", "paths", "[", "t", "-", "1", "]", "[", "j", "]", "[", "0", "]", ",", "\n", "pcoord", "[", "i", "]", "[", "1", "]", "-", "paths", "[", "t", "-", "1", "]", "[", "j", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                            ", "continue", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "coord", "[", "i", "]", "[", "0", "]", "-", "paths", "[", "t", "]", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "coord", "[", "i", "]", "[", "0", "]", "-", "paths", "[", "t", "]", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                            ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "", "", "", "", "", "return", "None", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.NoRotationChecker.__init__": [[1431, 1437], ["None"], "methods", ["None"], ["\n", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Takes no arguments, because on grid graph, only the\n        coordinates matter\n\n        \"\"\"", "\n", "pass", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.NoRotationChecker.col_check": [[1438, 1454], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["\n", "", "def", "col_check", "(", "self", ",", "c1", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single point.  Returns either a M*\n        or rM* collision set in the form of sets, depending on the\n        setting of recursive.\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.NoRotationChecker.cross_over": [[1455, 1485], ["range", "range", "len", "len", "adder", "abs", "abs", "adder", "frozenset", "frozenset"], "methods", ["None"], ["\n", "", "def", "cross_over", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "# compute current displacement vector", "\n", "                ", "if", "c1", "[", "i", "]", "is", "None", "or", "c1", "[", "j", "]", "is", "None", "or", "c2", "[", "i", "]", "is", "None", "or", "c2", "[", "j", "]", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "disp", "=", "(", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", ")", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                    ", "continue", "\n", "# Compute previous displacement vector.  Have a cross over or", "\n", "# pass through collision if the two displacement vectors are", "\n", "# opposites", "\n", "# pdisp = [c2[i][0] - c2[j][0], c2[i][1] - c2[j][1]]", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "elif", "c1", "[", "i", "]", "==", "c2", "[", "j", "]", "or", "c1", "[", "j", "]", "==", "c2", "[", "i", "]", ":", "\n", "# There is a rotation, which is banned", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.__init__": [[1492, 1498], ["None"], "methods", ["None"], ["\n", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Takes no arguments, because on grid graph, only the\n        coordinates matter\n\n        \"\"\"", "\n", "pass", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.col_check": [[1499, 1516], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["\n", "", "def", "col_check", "(", "self", ",", "c1", ",", "recursive", ")", ":", "\n", "        ", "\"\"\"Checks for collisions at a single point.  Returns either a M*\n        or rM* collision set in the form of sets, depending on the\n        setting of recursive.\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c1", "[", "j", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.pass_through": [[1517, 1533], ["range", "range", "len", "len", "adder", "frozenset"], "methods", ["None"], ["\n", "", "def", "pass_through", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"returns a tuple of colliding robots, or set of tuples if\n        recursive\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "                ", "if", "c1", "[", "i", "]", "==", "c2", "[", "j", "]", "and", "c1", "[", "j", "]", "==", "c2", "[", "i", "]", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Lazy_Edge_Checker.cross_over": [[1534, 1559], ["range", "range", "len", "len", "adder", "abs", "abs", "frozenset"], "methods", ["None"], ["\n", "", "def", "cross_over", "(", "self", ",", "c1", ",", "c2", ",", "recursive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Detects cross over collisions as well as pass through\n        collisions\n\n        \"\"\"", "\n", "col_set", "=", "[", "]", "\n", "# Select the function to be used for adding collision sets", "\n", "adder", "=", "add_col_set", "\n", "if", "recursive", ":", "\n", "            ", "adder", "=", "add_col_set_recursive", "\n", "", "for", "i", "in", "range", "(", "len", "(", "c1", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "c1", ")", ")", ":", "\n", "# compute current displacement vector", "\n", "                ", "disp", "=", "[", "c1", "[", "i", "]", "[", "0", "]", "-", "c1", "[", "j", "]", "[", "0", "]", ",", "c1", "[", "i", "]", "[", "1", "]", "-", "c1", "[", "j", "]", "[", "1", "]", "]", "\n", "if", "abs", "(", "disp", "[", "1", "]", ")", ">", "1", "or", "abs", "(", "disp", "[", "0", "]", ")", ">", "1", ":", "\n", "                    ", "continue", "\n", "# Compute previous displacement vector.  Have a cross", "\n", "# over or pass through collision if the two displacement", "\n", "# vectors are opposites", "\n", "# pdisp = [c2[i][0] - c2[j][0], c2[i][1] - c2[j][1]]", "\n", "", "if", "(", "disp", "[", "0", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "0", "]", "-", "c2", "[", "j", "]", "[", "0", "]", ")", "and", "\n", "disp", "[", "1", "]", "==", "-", "(", "c2", "[", "i", "]", "[", "1", "]", "-", "c2", "[", "j", "]", "[", "1", "]", ")", ")", ":", "\n", "                    ", "col_set", "=", "adder", "(", "[", "frozenset", "(", "[", "i", ",", "j", "]", ")", "]", ",", "col_set", ")", "\n", "return", "col_set", "\n", "", "", "", "return", "col_set", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.memoize": [[165, 176], ["functools.wraps", "f"], "function", ["None"], ["", "", "def", "memoize", "(", "f", ")", ":", "\n", "    ", "memo", "=", "{", "}", "\n", "\n", "@", "wraps", "(", "f", ")", "\n", "def", "inner", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "memo", "[", "args", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "z", "=", "memo", "[", "args", "]", "=", "f", "(", "*", "args", ")", "\n", "return", "z", "\n", "", "", "return", "inner", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.node_cmp": [[178, 188], ["None"], "function", ["None"], ["", "def", "node_cmp", "(", "n1", ",", "n2", ")", ":", "\n", "    ", "\"\"\" Sort nodes by cost \"\"\"", "\n", "if", "n1", ".", "cost", "<", "n2", ".", "cost", ":", "\n", "        ", "return", "-", "1", "\n", "", "elif", "n1", ".", "cost", ">", "n2", ".", "cost", ":", "\n", "        ", "return", "1", "\n", "# Returning 0 allows for stable sorting, i.e. equal objects stay in", "\n", "# the same order, which should provide a bit of a performance boost,", "\n", "# as well as a bit of consistency", "\n", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Workspace_Graph": [[401, 423], ["Flood_Fill_Policy", "Flood_Fill_Policy"], "function", ["None"], ["\n", "", "", "def", "Workspace_Graph", "(", "world_descriptor", ",", "goal", "=", "None", ",", "connect_8", "=", "False", ",", "\n", "road_rules", "=", "True", ")", ":", "\n", "    ", "\"\"\"Wrapper function for returning Flood_Fill_Policy objects\n\n    Function returns objects with different args depending on the\n    connect_8 flag\n\n    world_descriptor - two-dimensional matrix representing the space in\n                       which the robot can travel.  A value of 1 in the\n                       space represents an obstacle, and a value of 0\n                       represents an open space\n    goal             - position [x,y] of the goal of the policy\n    connect_8        - boolean determining whether Grid_Graph or\n                       Grid_Graph_Conn_8 is used\n    road_rules       - boolean supplied to policy object to determine if\n                       rightmost neighbor node should always be used\n    \"\"\"", "\n", "if", "connect_8", ":", "\n", "        ", "return", "Flood_Fill_Policy", "(", "world_descriptor", ",", "Grid_Graph_Conn_8", ",", "\n", "goal", ",", "road_rules", ")", "\n", "", "return", "Flood_Fill_Policy", "(", "world_descriptor", ",", "Grid_Graph", ",", "goal", ",", "\n", "road_rules", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.compute_heuristic_conn_8": [[425, 435], ["max", "map", "abs"], "function", ["None"], ["\n", "", "def", "compute_heuristic_conn_8", "(", "init_pos", ",", "coord", ")", ":", "\n", "    ", "\"\"\"Returns a heuristic for distance between coord and init_pos\n\n    init_pos - coordinate of position of goal configuration\n    coord    - coordinate of configuration for which heuristic is\n               being computed\n\n    Returns the heuristic distance to goal\n    \"\"\"", "\n", "return", "max", "(", "map", "(", "lambda", "x", ",", "y", ":", "abs", "(", "x", "-", "y", ")", ",", "coord", ",", "init_pos", ")", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.compute_heuristic_conn_8_diagonal": [[437, 453], ["abs", "abs", "min", "max"], "function", ["None"], ["\n", "", "def", "compute_heuristic_conn_8_diagonal", "(", "init_pos", ",", "coord", ")", ":", "\n", "    ", "\"\"\"Returns a heuristic for distance between coord and init_pos\n\n    Used when moving diagonally costs DIAGONAL_COST instead of 1\n\n    init_pos - coordinate of position of goal configuration\n    coord    - coordinate of configuration for which heuristic is\n               being computed\n\n    Returns the heuristic distance to goal\n    \"\"\"", "\n", "x_diff", "=", "abs", "(", "init_pos", "[", "0", "]", "-", "coord", "[", "0", "]", ")", "\n", "y_diff", "=", "abs", "(", "init_pos", "[", "1", "]", "-", "coord", "[", "1", "]", ")", "\n", "min_dist", "=", "min", "(", "x_diff", ",", "y_diff", ")", "\n", "max_dist", "=", "max", "(", "x_diff", ",", "y_diff", ")", "\n", "return", "DIAGONAL_COST", "*", "min_dist", "+", "(", "max_dist", "-", "min_dist", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.compute_heuristic_conn_4": [[455, 466], ["sum", "map", "abs"], "function", ["None"], ["\n", "", "def", "compute_heuristic_conn_4", "(", "init_pos", ",", "coord", ")", ":", "\n", "    ", "\"\"\"Returns Manhattan heuristic for distance from coord to init_pos\n\n    init_pos - coordinate of position of goal configuration\n    coord    - coordinate of configuration for which heursitic is\n               being computed\n\n    Returns the heuristic distance to goal through a\n    Manhattan metric calculation.\n    \"\"\"", "\n", "return", "sum", "(", "map", "(", "lambda", "x", ",", "y", ":", "abs", "(", "x", "-", "y", ")", ",", "coord", ",", "init_pos", ")", ")", "\n"]], "home.repos.pwc.inspect_result.lakshayvirmani_learning-assisted-mstar.lmstar.workspace_graph.Astar_Graph": [[468, 519], ["workspace_graph.Astar_Policy", "workspace_graph.Astar_Policy", "workspace_graph.Astar_Policy", "workspace_graph.Astar_Policy", "workspace_graph.GridGraphConn4WaitAtGoal", "workspace_graph.GridGraphConn8WaitAtGoal", "workspace_graph.Grid_Graph_Conn_8"], "function", ["None"], ["\n", "", "def", "Astar_Graph", "(", "world_descriptor", ",", "goal", "=", "None", ",", "connect_8", "=", "False", ",", "\n", "diagonal_cost", "=", "False", ",", "makespan", "=", "False", ",", "wait_cost", "=", "0.", ")", ":", "\n", "    ", "\"\"\"Wrapper function for returning Astar_Policy objects\n\n    Different heuristic functions are given to Astar_Policy object\n    depending on whether the gridworld is 8 connected or not\n\n    world_descriptor - two-dimensional matrix which describes the\n                       gridworld with obstacles. Each point in the\n                       matrix is either a zero (no obstacle) or a\n                       one (obstacle)\n    goal             - position (x, y) of the goal of the policy\n    connect_8        - boolean determining whether each coordinate\n                       in the gridworld has eight neighbors\n                       (including all diagonal neighbors) or only\n                       four (cardinal neighbors)\n    diagonal_cost    - boolean, apply DIAGONAL_COST for diagonal costs if True,\n                       apply 1 if False\n    makespan         - minimize makespan instead of minimizing time\n    wait_cost        - cost of waiting at the goal\n    \"\"\"", "\n", "if", "makespan", ":", "\n", "        ", "if", "connect_8", ":", "\n", "            ", "if", "diagonal_cost", ":", "\n", "                ", "h_func", "=", "compute_heuristic_conn_8_diagonal", "\n", "", "else", ":", "\n", "                ", "h_func", "=", "compute_heuristic_conn_8", "\n", "", "return", "Astar_Policy", "(", "\n", "world_descriptor", ",", "\n", "lambda", "x", ":", "Grid_Graph_Conn_8", "(", "x", ",", "diagonal_cost", "=", "diagonal_cost", ")", ",", "\n", "goal", "=", "goal", ",", "compute_heuristic", "=", "h_func", ")", "\n", "", "else", ":", "\n", "            ", "return", "Astar_Policy", "(", "world_descriptor", ",", "Grid_Graph", ",", "goal", "=", "goal", ",", "\n", "compute_heuristic", "=", "compute_heuristic_conn_4", ")", "\n", "", "", "if", "connect_8", ":", "\n", "        ", "if", "diagonal_cost", ":", "\n", "            ", "h_func", "=", "compute_heuristic_conn_8_diagonal", "\n", "", "else", ":", "\n", "            ", "h_func", "=", "compute_heuristic_conn_8", "\n", "", "return", "Astar_Policy", "(", "\n", "world_descriptor", ",", "\n", "lambda", "x", ":", "GridGraphConn8WaitAtGoal", "(", "x", ",", "goal", ",", "\n", "wait_cost", "=", "wait_cost", ",", "\n", "diagonal_cost", "=", "diagonal_cost", ",", "\n", ")", ",", "\n", "goal", ",", "h_func", ")", "\n", "", "return", "Astar_Policy", "(", "world_descriptor", ",", "\n", "lambda", "x", ":", "GridGraphConn4WaitAtGoal", "(", "\n", "x", ",", "goal", ",", "wait_cost", "=", "wait_cost", ",", "\n", "diagonal_cost", "=", "diagonal_cost", ")", ",", "\n", "goal", ",", "compute_heuristic_conn_4", ")", "\n"]]}