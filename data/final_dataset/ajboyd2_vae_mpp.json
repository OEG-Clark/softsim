{"home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.save_and_vis_intensities": [[20, 96], ["model.eval", "seaborn.color_palette", "enumerate", "[].item", "print", "matplotlib.subplots", "fig.tight_layout", "to_cpu.squeeze().numpy", "torch.exp().squeeze", "[].squeeze().numpy", "model_intensities.numpy.numpy", "print", "range", "batch[].squeeze().tolist", "batch[].squeeze().tolist", "range", "zip", "ax_bot.eventplot", "ax_top.set_ylabel", "ax_bot.set_ylabel", "ax_bot.get_yaxis().set_ticks", "ax_bot.set_xlabel", "ax_top.set_xlim", "ax_bot.set_xlim", "ax_top.legend", "os.path.exists", "fig.savefig", "torch.linspace().unsqueeze", "isinstance", "torch.no_grad", "vae_mpp.train.forward_pass", "evaluate.save_and_vis_intensities.to_cpu"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.forward_pass"], ["def", "save_and_vis_intensities", "(", "args", ",", "model", ",", "dataloader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "colors", "=", "sns", ".", "color_palette", "(", ")", "\n", "pp_objs", "=", "None", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "        ", "if", "args", ".", "cuda", ":", "\n", "            ", "batch", "=", "{", "k", ":", "v", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", "}", "\n", "", "T", "=", "batch", "[", "\"T\"", "]", "[", "0", "]", ".", "item", "(", ")", "\n", "\n", "all_times", "=", "torch", ".", "linspace", "(", "0", ",", "T", ",", "500", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "batch", "[", "\"T\"", "]", ".", "device", ")", ".", "unsqueeze", "(", "0", ")", "+", "1e-8", "\n", "\n", "def", "to_cpu", "(", "obj", ")", ":", "\n", "            ", "if", "isinstance", "(", "obj", ",", "dict", ")", ":", "\n", "                ", "return", "{", "k", ":", "to_cpu", "(", "v", ")", "for", "k", ",", "v", "in", "obj", ".", "items", "(", ")", "}", "\n", "", "elif", "isinstance", "(", "obj", ",", "list", ")", ":", "\n", "                ", "return", "[", "to_cpu", "(", "v", ")", "for", "v", "in", "obj", "]", "\n", "", "elif", "isinstance", "(", "obj", ",", "torch", ".", "distributions", ".", "distribution", ".", "Distribution", ")", ":", "\n", "                ", "return", "obj", "\n", "", "else", ":", "\n", "                ", "return", "obj", ".", "cpu", "(", ")", "\n", "\n", "# Process Batch", "\n", "", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "losses", ",", "results", "=", "forward_pass", "(", "args", ",", "batch", ",", "model", ",", "sample_timestamps", "=", "all_times", ")", "\n", "results", "=", "to_cpu", "(", "results", ")", "\n", "all_times", "=", "to_cpu", "(", "all_times", ")", "\n", "\n", "", "print", "(", "i", ",", "results", "[", "\"latent_state\"", "]", ".", "tolist", "(", ")", ")", "\n", "\n", "fig", ",", "(", "ax_top", ",", "ax_bot", ")", "=", "plt", ".", "subplots", "(", "2", ",", "1", ",", "figsize", "=", "(", "12", ",", "8", ")", ",", "sharex", "=", "True", ",", "gridspec_kw", "=", "{", "'height_ratios'", ":", "[", "3", ",", "1", "]", "}", ")", "\n", "fig", ".", "tight_layout", "(", ")", "\n", "all_times", "=", "all_times", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "model_intensities", "=", "torch", ".", "exp", "(", "results", "[", "\"sample_intensities\"", "]", "[", "\"all_log_mark_intensities\"", "]", ")", ".", "squeeze", "(", ")", "\n", "total_intensity", "=", "results", "[", "\"sample_intensities\"", "]", "[", "\"total_intensity\"", "]", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", "\n", "model_intensities", "=", "model_intensities", ".", "numpy", "(", ")", "\n", "print", "(", "model_intensities", ".", "shape", ")", "\n", "\n", "for", "k", "in", "range", "(", "model_intensities", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "ax_top", ".", "plot", "(", "all_times", ",", "model_intensities", "[", ":", ",", "k", "]", ",", "color", "=", "colors", "[", "k", "]", ",", "label", "=", "\"Model - k={}\"", ".", "format", "(", "k", ")", ")", "\n", "\n", "", "actual_times", "=", "batch", "[", "\"tgt_times\"", "]", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", "\n", "actual_marks", "=", "batch", "[", "\"tgt_marks\"", "]", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "if", "pp_objs", "is", "not", "None", ":", "\n", "            ", "pp_obj", "=", "pp_objs", "[", "pp_obj_idx", "]", "\n", "pp_obj", ".", "clear", "(", ")", "\n", "for", "t", ",", "m", "in", "zip", "(", "actual_times", ",", "actual_marks", ")", ":", "\n", "                ", "pp_obj", ".", "update", "(", "t", ",", "m", ",", "0", ")", "\n", "", "actual_intensities", "=", "np", ".", "array", "(", "[", "pp_obj", ".", "intensity", "(", "t", "=", "t", ",", "batch", "=", "0", ")", ".", "squeeze", "(", ")", "for", "t", "in", "all_times", "]", ")", "\n", "\n", "for", "k", "in", "range", "(", "model_intensities", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "ax_top", ".", "plot", "(", "all_times", ",", "actual_intensities", "[", ":", ",", "k", "]", ",", "color", "=", "colors", "[", "k", "]", ",", "alpha", "=", "0.5", ",", "linestyle", "=", "'dashed'", ",", "label", "=", "\"Real  - k={}\"", ".", "format", "(", "k", ")", ")", "\n", "\n", "", "", "events", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "model_intensities", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "events", ".", "append", "(", "[", "]", ")", "\n", "\n", "", "for", "pt", ",", "mark", "in", "zip", "(", "actual_times", ",", "actual_marks", ")", ":", "\n", "            ", "events", "[", "mark", "]", ".", "append", "(", "pt", ")", "\n", "ax_top", ".", "axvline", "(", "pt", ",", "color", "=", "colors", "[", "mark", "]", ",", "alpha", "=", "0.2", ",", "linestyle", "=", "'dotted'", ",", "linewidth", "=", "1", ")", "\n", "", "ax_bot", ".", "eventplot", "(", "events", ",", "colors", "=", "colors", "[", ":", "model_intensities", ".", "shape", "[", "1", "]", "]", ",", "linelengths", "=", "0.4", ",", "linewidths", "=", "1.2", ")", "\n", "\n", "ax_top", ".", "set_ylabel", "(", "\"Intensity by Mark\"", ")", "\n", "ax_bot", ".", "set_ylabel", "(", "\"Events\"", ")", "\n", "ax_bot", ".", "get_yaxis", "(", ")", ".", "set_ticks", "(", "[", "]", ")", "\n", "ax_bot", ".", "set_xlabel", "(", "\"Time\"", ")", "\n", "ax_top", ".", "set_xlim", "(", "(", "0", ",", "T", ")", ")", "\n", "ax_bot", ".", "set_xlim", "(", "(", "0", ",", "T", ")", ")", "\n", "ax_top", ".", "legend", "(", ")", "\n", "final_path", "=", "\"{}/example_{}.png\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ",", "i", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "final_path", ")", ":", "\n", "            ", "os", ".", "remove", "(", "final_path", ")", "\n", "", "fig", ".", "savefig", "(", "final_path", ",", "\n", "dpi", "=", "150", ",", "\n", "bbox_inches", "=", "\"tight\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.filter_contributions": [[97, 102], ["valid_times.sum", "torch.where().sum", "torch.where", "torch.zeros_like"], "function", ["None"], ["", "", "def", "filter_contributions", "(", "cont", ",", "times", ",", "T", ")", ":", "\n", "    ", "valid_times", "=", "times", "<=", "T", "\n", "num_valid", "=", "valid_times", ".", "sum", "(", "-", "1", ")", "\n", "partial_sum", "=", "torch", ".", "where", "(", "valid_times", ",", "cont", ",", "torch", ".", "zeros_like", "(", "cont", ")", ")", ".", "sum", "(", "-", "1", ")", "\n", "return", "partial_sum", ",", "num_valid", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.partial_pos_contributions_and_count": [[103, 106], ["evaluate.filter_contributions"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.filter_contributions"], ["", "def", "partial_pos_contributions_and_count", "(", "cont", ",", "times", ",", "T", ")", ":", "\n", "    ", "partial_sum", ",", "num_valid", "=", "filter_contributions", "(", "cont", ",", "times", ",", "T", ")", "\n", "return", "partial_sum", ",", "num_valid", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.partial_neg_contributions": [[107, 112], ["evaluate.filter_contributions", "torch.where", "torch.where", "torch.zeros_like", "torch.zeros_like"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.filter_contributions"], ["", "def", "partial_neg_contributions", "(", "cont", ",", "times", ",", "T", ")", ":", "\n", "    ", "partial_sum", ",", "num_valid", "=", "filter_contributions", "(", "cont", ",", "times", ",", "T", ")", "\n", "partial_sum", "=", "torch", ".", "where", "(", "num_valid", "!=", "0", ",", "partial_sum", ",", "torch", ".", "zeros_like", "(", "partial_sum", ")", ")", "\n", "num_valid", "=", "torch", ".", "where", "(", "num_valid", "!=", "0", ",", "num_valid", ",", "torch", ".", "zeros_like", "(", "num_valid", ")", "+", "1", ")", "\n", "return", "partial_sum", ",", "partial_sum", "/", "num_valid", ",", "(", "partial_sum", "/", "num_valid", "*", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.add_contribution": [[113, 121], ["zip", "new_cont_tensor.item", "T_limit_tensor.item", "total_contributions[].append"], "function", ["None"], ["", "def", "add_contribution", "(", "total_contributions", ",", "new_conts", ",", "T", ",", "T_limits", ")", ":", "\n", "    ", "for", "new_cont_tensor", ",", "T_limit_tensor", "in", "zip", "(", "new_conts", ",", "T_limits", ")", ":", "\n", "        ", "new_cont", ",", "T_limit", "=", "new_cont_tensor", ".", "item", "(", ")", ",", "T_limit_tensor", ".", "item", "(", ")", "\n", "if", "T", "<=", "T_limit", ":", "\n", "            ", "if", "T", "in", "total_contributions", ":", "\n", "                ", "total_contributions", "[", "T", "]", ".", "append", "(", "new_cont", ")", "\n", "", "else", ":", "\n", "                ", "total_contributions", "[", "T", "]", "=", "[", "new_cont", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.likelihood_over_time": [[122, 181], ["model.eval", "enumerate", "all_contributions.items", "pickle.dump", "open", "vae_mpp.utils.print_log", "torch.no_grad", "vae_mpp.train.forward_pass", "numpy.arange", "sorted", "evaluate.partial_neg_contributions", "evaluate.partial_neg_contributions", "evaluate.partial_neg_contributions", "new_conts.items", "sorted", "sorted", "args.checkpoint_path.rstrip", "len", "batch[].max().item", "evaluate.add_contribution", "total_contributions.items", "batch[].max", "sum", "sum", "total_contributions.items", "total_contributions.items", "sum", "sum", "sum", "len"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.forward_pass", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.partial_neg_contributions", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.partial_neg_contributions", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.partial_neg_contributions", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.add_contribution"], ["", "", "", "", "def", "likelihood_over_time", "(", "args", ",", "model", ",", "dataloader", ")", ":", "\n", "\n", "    ", "lik_total_contributions", "=", "{", "}", "\n", "pos_total_contributions", "=", "{", "}", "\n", "neg_total_contributions", "=", "{", "}", "\n", "ce_total_contributions", "=", "{", "}", "\n", "overall_freq", "=", "{", "}", "\n", "lik_diff_contributions", "=", "{", "}", "\n", "pos_diff_contributions", "=", "{", "}", "\n", "neg_diff_contributions", "=", "{", "}", "\n", "ce_diff_contributions", "=", "{", "}", "\n", "\n", "all_contributions", "=", "{", "\n", "\"lik_total\"", ":", "lik_total_contributions", ",", "\n", "\"pos_total\"", ":", "pos_total_contributions", ",", "\n", "\"neg_total\"", ":", "neg_total_contributions", ",", "\n", "\"ce_total\"", ":", "ce_total_contributions", ",", "\n", "}", "\n", "\n", "res", "=", "args", ".", "likelihood_resolution", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "        ", "if", "i", "%", "20", "==", "0", ":", "\n", "            ", "print_log", "(", "\"Progress: {} / {}\"", ".", "format", "(", "i", ",", "len", "(", "dataloader", ")", ")", ")", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "ll_results", ",", "sample_timestamps", ",", "tgt_timestamps", "=", "forward_pass", "(", "args", ",", "batch", ",", "model", ",", "sample_timestamps", "=", "None", ",", "num_samples", "=", "1000", ",", "get_raw_likelihoods", "=", "True", ")", "\n", "pos_cont", ",", "neg_cont", ",", "ce", "=", "ll_results", "[", "\"positive_contribution\"", "]", ",", "ll_results", "[", "\"negative_contribution\"", "]", ",", "ll_results", "[", "\"cross_entropy\"", "]", "\n", "\n", "prev_lik", ",", "prev_pos", ",", "prev_neg", ",", "prev_count", ",", "prev_ce", "=", "0", ",", "0", ",", "0", ",", "0", ",", "0", "\n", "for", "T", "in", "np", ".", "arange", "(", "res", ",", "batch", "[", "\"T\"", "]", ".", "max", "(", ")", ".", "item", "(", ")", "+", "res", ",", "res", ")", ":", "\n", "                ", "partial_pos_sum", ",", "partial_pos_mean", ",", "partial_pos_mean_scaled", "=", "partial_neg_contributions", "(", "pos_cont", ",", "tgt_timestamps", ",", "T", ")", "\n", "partial_ce_sum", ",", "partial_ce_mean", ",", "partial_ce_mean_scaled", "=", "partial_neg_contributions", "(", "ce", ",", "tgt_timestamps", ",", "T", ")", "\n", "partial_neg_sum", ",", "partial_neg_mean", ",", "partial_neg_mean_scaled", "=", "partial_neg_contributions", "(", "neg_cont", ",", "sample_timestamps", ",", "T", ")", "\n", "partial_lik_cont", "=", "partial_pos_sum", "-", "partial_neg_mean_scaled", "\n", "new_conts", "=", "{", "\n", "\"lik_total\"", ":", "partial_lik_cont", ",", "\n", "\"pos_total\"", ":", "partial_ce_mean", "+", "partial_pos_mean", ",", "\n", "\"neg_total\"", ":", "partial_neg_mean", ",", "\n", "\"ce_total\"", ":", "partial_ce_mean", ",", "\n", "}", "\n", "for", "key", ",", "new_cont", "in", "new_conts", ".", "items", "(", ")", ":", "\n", "                    ", "add_contribution", "(", "all_contributions", "[", "key", "]", ",", "new_cont", ",", "T", ",", "batch", "[", "\"T\"", "]", ")", "\n", "\n", "\n", "", "", "", "", "mean_contributions", "=", "{", "}", "\n", "lower_ci_contributions", "=", "{", "}", "\n", "upper_ci_contributions", "=", "{", "}", "\n", "for", "key", ",", "total_contributions", "in", "all_contributions", ".", "items", "(", ")", ":", "\n", "        ", "if", "\"ce_\"", "in", "key", ":", "\n", "            ", "mean_contributions", "[", "key", "]", "=", "sorted", "(", "[", "(", "t", ",", "sum", "(", "ls", ")", "/", "sum", "(", "1", "for", "x", "in", "ls", "if", "(", "x", "!=", "0", ")", "and", "(", "x", "!=", "0.0", ")", ")", ")", "for", "t", ",", "ls", "in", "total_contributions", ".", "items", "(", ")", "]", ")", "\n", "", "elif", "\"pos_\"", "in", "key", ":", "\n", "            ", "mean_contributions", "[", "key", "]", "=", "sorted", "(", "[", "(", "t", ",", "sum", "(", "ls", ")", "/", "sum", "(", "1", "for", "x", "in", "all_contributions", "[", "\"ce_total\"", "]", "[", "t", "]", "if", "(", "x", "!=", "0", ")", "and", "(", "x", "!=", "0.0", ")", ")", ")", "for", "t", ",", "ls", "in", "total_contributions", ".", "items", "(", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "mean_contributions", "[", "key", "]", "=", "sorted", "(", "[", "(", "t", ",", "sum", "(", "ls", ")", "/", "len", "(", "ls", ")", ")", "for", "t", ",", "ls", "in", "total_contributions", ".", "items", "(", ")", "]", ")", "\n", "\n", "", "", "pickle", ".", "dump", "(", "\n", "{", "\"mean\"", ":", "mean_contributions", "}", ",", "\n", "open", "(", "\"{}/likelihood_data.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", ",", "\"wb\"", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.sample_generations": [[183, 281], ["model.eval", "iter", "pickle.dump", "open", "next", "vae_mpp.utils.print_log", "all_samples.append", "tgt_timestamps.squeeze().tolist", "tgt_marks.squeeze().tolist", "T.squeeze().tolist", "vae_mpp.utils.print_log", "range", "args.checkpoint_path.rstrip", "v.cuda", "new_tgt_timestamps[].squeeze().item", "print", "set", "print", "[].append", "torch.cuda.current_device", "next.items", "padding_mask.cumsum().max().item", "padding_mask.cumsum().max().item", "tgt_timestamps.squeeze", "tgt_marks.squeeze", "T.squeeze", "model.sample_points", "print", "tgt_marks[].squeeze().tolist", "new_tgt_timestamps[].squeeze", "math.floor", "len", "len", "len", "len", "len", "min", "padding_mask.cumsum().max", "padding_mask.cumsum().max", "tgt_marks[].squeeze", "set", "set.intersection", "math.floor", "math.floor", "tgt_timestamps.squeeze", "set", "padding_mask.cumsum", "padding_mask.cumsum", "math.floor"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.sample_points"], ["", "def", "sample_generations", "(", "args", ",", "model", ",", "dataloader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "samples_per_time", "=", "args", ".", "samples_per_sequence", "\n", "users_sampled", "=", "args", ".", "num_samples", "\n", "T_pcts", "=", "[", "0.5", ",", "0.3", ",", "0.1", "]", "#, 0.05, 0.0]", "\n", "\n", "all_samples", "=", "[", "]", "\n", "data_iter", "=", "iter", "(", "dataloader", ")", "\n", "\n", "i", "=", "0", "\n", "while", "i", "<", "users_sampled", ":", "\n", "#    for i, batch in enumerate(dataloader):", "\n", "#        if i >= users_sampled:", "\n", "#            break", "\n", "        ", "try", ":", "\n", "            ", "batch", "=", "next", "(", "data_iter", ")", "\n", "print_log", "(", "\"New user {}\"", ".", "format", "(", "i", ")", ")", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "                ", "batch", "=", "{", "k", ":", "v", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", "}", "\n", "\n", "", "ref_marks", ",", "ref_timestamps", ",", "context_lengths", ",", "padding_mask", "=", "batch", "[", "\"ref_marks\"", "]", ",", "batch", "[", "\"ref_times\"", "]", ",", "batch", "[", "\"context_lengths\"", "]", ",", "batch", "[", "\"padding_mask\"", "]", "\n", "ref_marks_backwards", ",", "ref_timestamps_backwards", "=", "batch", "[", "\"ref_marks_backwards\"", "]", ",", "batch", "[", "\"ref_times_backwards\"", "]", "\n", "tgt_marks", ",", "tgt_timestamps", "=", "batch", "[", "\"tgt_marks\"", "]", ",", "batch", "[", "\"tgt_times\"", "]", "\n", "pp_id", "=", "batch", "[", "\"pp_id\"", "]", "\n", "tgt_timestamps", "=", "tgt_timestamps", "[", "...", ",", ":", "padding_mask", ".", "cumsum", "(", "-", "1", ")", ".", "max", "(", ")", ".", "item", "(", ")", "]", "\n", "tgt_marks", "=", "tgt_marks", "[", "...", ",", ":", "padding_mask", ".", "cumsum", "(", "-", "1", ")", ".", "max", "(", ")", ".", "item", "(", ")", "]", "\n", "\n", "T", "=", "batch", "[", "\"T\"", "]", "\n", "\n", "user_samples", "=", "{", "\"original_times\"", ":", "tgt_timestamps", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", ",", "\"original_marks\"", ":", "tgt_marks", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", ",", "\"original_T\"", ":", "T", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", ",", "\"samples\"", ":", "{", "}", "}", "\n", "\n", "for", "pct", "in", "T_pcts", ":", "\n", "                ", "print_log", "(", "\"New pct {}\"", ".", "format", "(", "pct", ")", ")", "\n", "user_samples", "[", "\"samples\"", "]", "[", "pct", "]", "=", "[", "]", "\n", "if", "pct", "==", "0.0", ":", "\n", "                    ", "new_tgt_timestamps", "=", "tgt_timestamps", "[", "...", ",", ":", "1", "]", "*", "10000", "\n", "new_tgt_marks", "=", "tgt_marks", "[", "...", ",", ":", "1", "]", "\n", "left_window", "=", "0.0", "\n", "", "else", ":", "\n", "                    ", "new_tgt_timestamps", "=", "tgt_timestamps", "[", "...", ",", ":", "math", ".", "floor", "(", "pct", "*", "tgt_timestamps", ".", "shape", "[", "-", "1", "]", ")", "+", "1", "]", "#torch.where(good_times, tgt_timestamps, torch.ones_like(tgt_timestamps) * 10000)", "\n", "new_tgt_marks", "=", "tgt_marks", "[", "...", ",", ":", "math", ".", "floor", "(", "pct", "*", "tgt_timestamps", ".", "shape", "[", "-", "1", "]", ")", "+", "1", "]", "\n", "left_window", "=", "new_tgt_timestamps", "[", "...", ",", "-", "1", "]", ".", "squeeze", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "for", "j", "in", "range", "(", "samples_per_time", ")", ":", "\n", "                    ", "print", "(", "\"New sample {}\"", ".", "format", "(", "j", ")", ")", "\n", "samples", "=", "None", "\n", "m", "=", "1.0", "\n", "while", "samples", "is", "None", ":", "\n", "                        ", "if", "m", ">=", "10.0", ":", "\n", "                            ", "break", "\n", "", "samples", "=", "model", ".", "sample_points", "(", "\n", "ref_marks", "=", "ref_marks", ",", "\n", "ref_timestamps", "=", "ref_timestamps", ",", "\n", "ref_marks_bwd", "=", "ref_marks_backwards", ",", "\n", "ref_timestamps_bwd", "=", "ref_timestamps_backwards", ",", "\n", "tgt_marks", "=", "new_tgt_marks", ",", "\n", "tgt_timestamps", "=", "new_tgt_timestamps", ",", "\n", "context_lengths", "=", "context_lengths", ",", "\n", "dominating_rate", "=", "args", ".", "dominating_rate", "*", "m", ",", "\n", "T", "=", "T", ",", "\n", "left_window", "=", "left_window", ",", "\n", "top_k", "=", "args", ".", "top_k", ",", "\n", "top_p", "=", "args", ".", "top_p", ",", "\n", ")", "\n", "m", "*=", "1.5", "\n", "\n", "", "if", "samples", "is", "None", ":", "\n", "                        ", "print", "(", "\"No good sample found. Skipping\"", ")", "\n", "continue", "\n", "\n", "", "sampled_times", ",", "sampled_marks", "=", "samples", "\n", "\n", "held_out_marks", "=", "set", "(", "tgt_marks", "[", "...", ",", "math", ".", "floor", "(", "pct", "*", "tgt_timestamps", ".", "shape", "[", "-", "1", "]", ")", ":", "]", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "print", "(", "\"Pct: {} | Left Window: {} |Num Original: {} | Num Conditioned: {} | Num Sampled Alone: {} | Unique Marks on Held Out: {} | Unique Marks Sampled: {} | Common Marks: {}\"", ".", "format", "(", "\n", "pct", ",", "\n", "left_window", ",", "\n", "tgt_timestamps", ".", "squeeze", "(", ")", ".", "shape", "[", "0", "]", ",", "\n", "math", ".", "floor", "(", "pct", "*", "tgt_timestamps", ".", "shape", "[", "-", "1", "]", ")", ",", "\n", "len", "(", "sampled_times", ")", ",", "\n", "len", "(", "held_out_marks", ")", ",", "\n", "len", "(", "set", "(", "sampled_marks", ")", ")", ",", "\n", "len", "(", "held_out_marks", ".", "intersection", "(", "set", "(", "sampled_marks", ")", ")", ")", ",", "\n", ")", ")", "\n", "assert", "(", "len", "(", "sampled_times", ")", "==", "0", "or", "left_window", "<=", "min", "(", "sampled_times", ")", ")", "\n", "user_samples", "[", "\"samples\"", "]", "[", "pct", "]", ".", "append", "(", "(", "sampled_times", ",", "sampled_marks", ")", ")", "\n", "\n", "", "", "all_samples", ".", "append", "(", "user_samples", ")", "\n", "i", "+=", "1", "\n", "", "except", "StopIteration", ":", "\n", "            ", "break", "# ran out of data", "\n", "", "except", ":", "\n", "            ", "continue", "# data processing error", "\n", "\n", "\n", "", "", "pickle", ".", "dump", "(", "all_samples", ",", "open", "(", "\"{}/scaling_samples_top_p_{}_top_k_{}.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ",", "args", ".", "top_p", ",", "args", ".", "top_k", ")", ",", "\"wb\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.save_latents": [[282, 335], ["len", "model.eval", "enumerate", "pickle.dump", "zip", "open", "vae_mpp.utils.print_log", "torch.no_grad", "model.get_latent", "torch.zeros_like", "mean.tolist", "torch.zeros_like.tolist", "context_lengths.squeeze().tolist", "ref_marks.tolist", "ref_timestamps.tolist", "pp_id.squeeze().tolist", "latents.append", "v.cuda", "len", "args.checkpoint_path.rstrip", "torch.cuda.current_device", "batch.items", "context_lengths.squeeze", "pp_id.squeeze", "zip", "len", "sum", "len", "sorted", "len"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_latent"], ["", "def", "save_latents", "(", "args", ",", "model", ",", "dataloader", ")", ":", "\n", "    ", "num_samples", "=", "len", "(", "dataloader", ")", "\n", "model", ".", "eval", "(", ")", "\n", "latents", "=", "[", "]", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "        ", "if", "args", ".", "cuda", ":", "\n", "            ", "batch", "=", "{", "k", ":", "v", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", "}", "\n", "", "if", "i", "%", "(", "num_samples", "//", "10", ")", "==", "0", ":", "\n", "            ", "print_log", "(", "\"{} Latent state batches extracted\"", ".", "format", "(", "i", ")", ")", "\n", "", "if", "i", ">", "num_samples", ":", "\n", "            ", "break", "\n", "", "ref_marks", ",", "ref_timestamps", ",", "context_lengths", ",", "padding_mask", "=", "batch", "[", "\"ref_marks\"", "]", ",", "batch", "[", "\"ref_times\"", "]", ",", "batch", "[", "\"context_lengths\"", "]", ",", "batch", "[", "\"padding_mask\"", "]", "\n", "ref_marks_backwards", ",", "ref_timestamps_backwards", "=", "batch", "[", "\"ref_marks_backwards\"", "]", ",", "batch", "[", "\"ref_times_backwards\"", "]", "\n", "pp_id", "=", "batch", "[", "\"pp_id\"", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "latent", "=", "model", ".", "get_latent", "(", "\n", "ref_marks_fwd", "=", "ref_marks", ",", "\n", "ref_timestamps_fwd", "=", "ref_timestamps", ",", "\n", "ref_marks_bwd", "=", "ref_marks_backwards", ",", "\n", "ref_timestamps_bwd", "=", "ref_timestamps_backwards", ",", "\n", "context_lengths", "=", "context_lengths", ",", "\n", "pp_id", "=", "pp_id", ",", "\n", ")", "\n", "", "mean", "=", "latent", "[", "\"latent_state\"", "]", "\n", "sigma", "=", "latent", "[", "\"q_z_x\"", "]", "\n", "if", "sigma", "is", "None", ":", "\n", "            ", "sigma", "=", "torch", ".", "zeros_like", "(", "mean", ")", "\n", "", "else", ":", "\n", "            ", "sigma", "=", "sigma", ".", "scale", "\n", "\n", "", "for", "ls", ",", "sm", ",", "cl", ",", "m", ",", "t", ",", "pp", "in", "zip", "(", "mean", ".", "tolist", "(", ")", ",", "sigma", ".", "tolist", "(", ")", ",", "context_lengths", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", ",", "ref_marks", ".", "tolist", "(", ")", ",", "ref_timestamps", ".", "tolist", "(", ")", ",", "pp_id", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", ")", ":", "\n", "            ", "m", ",", "t", "=", "m", "[", ":", "cl", "+", "1", "]", ",", "t", "[", ":", "cl", "+", "1", "]", "\n", "mark_counts", "=", "{", "}", "\n", "t_delta", "=", "[", "t1", "-", "t0", "for", "t1", ",", "t0", "in", "zip", "(", "t", "[", "1", ":", "]", ",", "t", "[", ":", "-", "1", "]", ")", "]", "\n", "if", "len", "(", "t_delta", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "for", "k", "in", "m", ":", "\n", "                ", "if", "k", "not", "in", "mark_counts", ":", "\n", "                    ", "mark_counts", "[", "k", "]", "=", "1", "\n", "", "else", ":", "\n", "                    ", "mark_counts", "[", "k", "]", "+=", "1", "\n", "", "", "latents", ".", "append", "(", "{", "\n", "\"latent_mu\"", ":", "ls", ",", "\n", "\"latent_sigma\"", ":", "sm", ",", "\n", "\"mark_counts\"", ":", "mark_counts", ",", "\n", "\"total_events\"", ":", "len", "(", "m", ")", ",", "\n", "\"mean_inter_event_time\"", ":", "sum", "(", "t_delta", ")", "/", "len", "(", "t_delta", ")", ",", "\n", "\"median_inter_event_time\"", ":", "sorted", "(", "t_delta", ")", "[", "len", "(", "t_delta", ")", "//", "2", "]", ",", "\n", "\"user_id\"", ":", "pp", ",", "\n", "}", ")", "\n", "\n", "", "", "pickle", ".", "dump", "(", "latents", ",", "open", "(", "\"{}/extracted_latents.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", ",", "\"wb\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.l1_loss": [[336, 341], ["l1.unsqueeze.tolist", "len", "l1.unsqueeze.unsqueeze", "pred_times.squeeze", "true_times.squeeze"], "function", ["None"], ["", "def", "l1_loss", "(", "pred_times", ",", "true_times", ",", "**", "kwargs", ")", ":", "\n", "    ", "l1", "=", "(", "pred_times", ".", "squeeze", "(", ")", "-", "true_times", ".", "squeeze", "(", ")", ")", ".", "abs", "(", ")", "\n", "if", "len", "(", "l1", ".", "shape", ")", "==", "0", ":", "\n", "        ", "l1", "=", "l1", ".", "unsqueeze", "(", "0", ")", "\n", "", "return", "l1", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.l2_loss": [[342, 347], ["l2.unsqueeze.tolist", "len", "l2.unsqueeze.unsqueeze", "pred_times.squeeze", "true_times.squeeze"], "function", ["None"], ["", "def", "l2_loss", "(", "pred_times", ",", "true_times", ",", "**", "kwargs", ")", ":", "\n", "    ", "l2", "=", "(", "pred_times", ".", "squeeze", "(", ")", "-", "true_times", ".", "squeeze", "(", ")", ")", ".", "pow", "(", "2", ")", "\n", "if", "len", "(", "l2", ".", "shape", ")", "==", "0", ":", "\n", "        ", "l2", "=", "l2", ".", "unsqueeze", "(", "0", ")", "\n", "", "return", "l2", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank": [[349, 356], ["all_ranks.gather().squeeze", "len", "ranks.unsqueeze.unsqueeze", "orig_indices.sort", "all_ranks.gather", "true_events.unsqueeze"], "function", ["None"], ["", "def", "_rank", "(", "pred_dists", ",", "true_events", ",", "**", "kwargs", ")", ":", "\n", "    ", "orig_indices", "=", "(", "-", "pred_dists", ")", ".", "sort", "(", ")", "[", "-", "1", "]", "# negate so that small values are good", "\n", "all_ranks", "=", "orig_indices", ".", "sort", "(", ")", "[", "-", "1", "]", "+", "1", "\n", "ranks", "=", "all_ranks", ".", "gather", "(", "-", "1", ",", "true_events", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", ")", "\n", "if", "len", "(", "ranks", ".", "shape", ")", "==", "0", ":", "\n", "        ", "ranks", "=", "ranks", ".", "unsqueeze", "(", "0", ")", "\n", "", "return", "ranks", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.rank": [[358, 360], ["_rank().tolist", "evaluate._rank"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank"], ["", "def", "rank", "(", "pred_dists", ",", "true_events", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "_rank", "(", "pred_dists", ",", "true_events", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.mean_reciprocal_rank": [[361, 363], ["_rank().float", "evaluate._rank"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank"], ["", "def", "mean_reciprocal_rank", "(", "pred_dists", ",", "true_events", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "(", "1", "/", "_rank", "(", "pred_dists", ",", "true_events", ")", ".", "float", "(", ")", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank_n": [[364, 368], ["evaluate._rank"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank"], ["", "def", "_rank_n", "(", "pred_dists", ",", "true_events", ",", "n", ",", "r", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "r", "is", "None", ":", "\n", "        ", "r", "=", "_rank", "(", "pred_dists", ",", "true_events", ")", "\n", "", "return", "(", "1", "*", "(", "r", "<=", "n", ")", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.rank_1": [[369, 371], ["evaluate._rank_n"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank_n"], ["", "def", "rank_1", "(", "pred_dists", ",", "true_events", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "_rank_n", "(", "pred_dists", ",", "true_events", ",", "n", "=", "1", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.rank_5": [[372, 374], ["evaluate._rank_n"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank_n"], ["", "def", "rank_5", "(", "pred_dists", ",", "true_events", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "_rank_n", "(", "pred_dists", ",", "true_events", ",", "n", "=", "5", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.rank_10": [[375, 377], ["evaluate._rank_n"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank_n"], ["", "def", "rank_10", "(", "pred_dists", ",", "true_events", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "_rank_n", "(", "pred_dists", ",", "true_events", ",", "n", "=", "10", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.rank_25": [[378, 380], ["evaluate._rank_n"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank_n"], ["", "def", "rank_25", "(", "pred_dists", ",", "true_events", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "_rank_n", "(", "pred_dists", ",", "true_events", ",", "n", "=", "25", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.rank_100": [[381, 383], ["evaluate._rank_n"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank_n"], ["", "def", "rank_100", "(", "pred_dists", ",", "true_events", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "_rank_n", "(", "pred_dists", ",", "true_events", ",", "n", "=", "100", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.next_event_prediction": [[396, 619], ["model.eval", "torch.arange", "torch.linspace().unsqueeze", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "num_samples_iterated.cuda.cuda", "base_linspace.cuda.cuda", "list", "os.path.exists", "vae_mpp.utils.print_log", "vae_mpp.train.get_data", "enumerate", "set", "results.items", "results.items", "torch.linspace", "torch.cuda.current_device", "torch.cuda.current_device", "range", "args.checkpoint_path.rstrip", "args.checkpoint_path.rstrip", "os.path.exists", "os.path.extists", "pickle.load", "pickle.load", "args.checkpoint_path.rstrip", "pickle.load", "tgt_timestamps[].unsqueeze", "model", "torch.cumsum", "evaluate._rank", "zip", "batch_res.items", "vae_mpp.utils.print_log", "pickle.dump", "pickle.dump", "vae_mpp.utils.print_log", "pickle.dump", "min", "open", "open", "open", "len", "all_metrics.keys", "vae_mpp.utils.print_log", "batch[].sum", "vae_mpp.utils.print_log", "log_mark_intensity.exp", "total_intensity.unsqueeze", "torch.exp", "t_density.unsqueeze", "metric", "t.squeeze().tolist", "results[].extend", "bad_indices.union.union", "len", "args.checkpoint_path.rstrip", "args.checkpoint_path.rstrip", "open", "open", "args.checkpoint_path.rstrip", "open", "len", "v.cuda", "all_metrics.items", "isinstance", "set", "len", "batch.items", "torch.cuda.current_device", "batch.items", "t.squeeze", "enumerate", "sum", "len", "len", "timestep.unsqueeze", "enumerate"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.get_data", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._rank", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log"], ["def", "next_event_prediction", "(", "args", ",", "model", ",", "dataloader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "samples_per_time", "=", "args", ".", "samples_per_sequence", "\n", "div", "=", "4", "\n", "num_batches", "=", "args", ".", "num_samples", "//", "(", "args", ".", "batch_size", "//", "div", ")", "\n", "num_samples", "=", "10000", "\n", "num_samples_iterated", "=", "torch", ".", "arange", "(", "start", "=", "1", ",", "end", "=", "num_samples", "+", "1", ")", "\n", "base_linspace", "=", "torch", ".", "linspace", "(", "1e-10", ",", "1.0", ",", "num_samples", "+", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "        ", "num_samples_iterated", "=", "num_samples_iterated", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "base_linspace", "=", "base_linspace", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "\n", "", "select_condition_amounts", "=", "False", "# TODO: Make this an option in the args", "\n", "if", "select_condition_amounts", ":", "\n", "        ", "events_to_cond", "=", "[", "2", ",", "5", ",", "10", ",", "20", ",", "50", "]", "#, 0.05, 0.0]", "\n", "", "else", ":", "\n", "# args.max_seq_len is set in the data", "\n", "        ", "events_to_cond", "=", "list", "(", "range", "(", "1", ",", "min", "(", "args", ".", "max_seq_len", ",", "50", ")", ")", ")", "\n", "\n", "", "all_results", "=", "{", "}", "\n", "mean_results", "=", "{", "}", "\n", "if", "select_condition_amounts", ":", "\n", "        ", "all_res_path", "=", "\"{}/pred_task_all_results.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", "\n", "mean_res_path", "=", "\"{}/pred_task_mean_results.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "all_res_path", ")", "and", "os", ".", "path", ".", "extists", "(", "mean_res_path", ")", ":", "\n", "            ", "all_results", "=", "pickle", ".", "load", "(", "open", "(", "all_results", ",", "\"rb\"", ")", ")", "\n", "mean_results", "=", "pickle", ".", "load", "(", "open", "(", "mean_res_path", ",", "\"rb\"", ")", ")", "\n", "events_to_cond", "=", "[", "i", "for", "i", "in", "events_to_cond", "if", "i", "not", "in", "mean_results", "]", "\n", "", "", "else", ":", "\n", "        ", "all_mean_res_path", "=", "\"{}/all_pred_task_mean_results.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "all_mean_res_path", ")", ":", "\n", "            ", "mean_results", "=", "pickle", ".", "load", "(", "open", "(", "all_mean_res_path", ",", "\"rb\"", ")", ")", "\n", "events_to_cond", "=", "[", "i", "for", "i", "in", "events_to_cond", "if", "i", "not", "in", "mean_results", "]", "\n", "\n", "", "", "print_log", "(", "f\"Next event prediction with {(args.batch_size // div) * len(dataloader)} predictions for {events_to_cond} different condition lengths.\"", ")", "\n", "print_log", "(", "f\"Batch size of {args.batch_size // div} with {len(dataloader)} total batches. {num_samples} samples per prediction.\"", ")", "\n", "\n", "for", "cond_num", "in", "events_to_cond", ":", "\n", "        ", "print_log", "(", "f\"Starting prediction tasks where we condition on {cond_num} events prior to prediction.\"", ")", "\n", "_", ",", "_", ",", "dataloader", "=", "get_data", "(", "args", ")", "\n", "#data_iter = iter(dataloader)", "\n", "results", "=", "{", "k", ":", "[", "]", "for", "k", "in", "all_metrics", ".", "keys", "(", ")", "}", "\n", "results", "[", "\"pred_time\"", "]", "=", "[", "]", "\n", "results", "[", "\"true_time\"", "]", "=", "[", "]", "\n", "results", "[", "\"last_time\"", "]", "=", "[", "]", "\n", "#while i < num_batches:", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "if", "(", "(", "i", "+", "1", ")", "%", "10", "==", "0", ")", "or", "(", "i", "<", "20", ")", ":", "\n", "                ", "print_log", "(", "f\"Batch {i+1}/{len(dataloader)} for conditioning on {cond_num} events processed.\"", ")", "\n", "\n", "#batch = next(data_iter)", "\n", "", "invalid_examples", "=", "batch", "[", "\"padding_mask\"", "]", ".", "sum", "(", "dim", "=", "-", "1", ")", "<", "(", "cond_num", "+", "1", ")", "\n", "if", "(", "(", "1.0", "*", "invalid_examples", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "==", "1.0", ")", "or", "(", "batch", "[", "\"tgt_times\"", "]", ".", "shape", "[", "-", "1", "]", "<", "(", "cond_num", "+", "1", ")", ")", ":", "\n", "                ", "print_log", "(", "f\"Skipped batch at i={i-1}\"", ")", "\n", "continue", "\n", "", "else", ":", "\n", "                ", "batch", "=", "{", "k", ":", "v", "[", "~", "invalid_examples", ",", "...", "]", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", "}", "\n", "#if i % (len(dataloader) // 10) == 0:", "\n", "\n", "", "if", "args", ".", "cuda", ":", "\n", "                ", "batch", "=", "{", "k", ":", "v", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", "}", "\n", "\n", "", "ref_marks", ",", "ref_timestamps", ",", "context_lengths", ",", "padding_mask", "=", "batch", "[", "\"ref_marks\"", "]", ",", "batch", "[", "\"ref_times\"", "]", ",", "batch", "[", "\"context_lengths\"", "]", ",", "batch", "[", "\"padding_mask\"", "]", "\n", "ref_marks_backwards", ",", "ref_timestamps_backwards", "=", "batch", "[", "\"ref_marks_backwards\"", "]", ",", "batch", "[", "\"ref_times_backwards\"", "]", "\n", "tgt_marks", ",", "tgt_timestamps", "=", "batch", "[", "\"tgt_marks\"", "]", ",", "batch", "[", "\"tgt_times\"", "]", "\n", "pp_id", "=", "batch", "[", "\"pp_id\"", "]", "\n", "T", "=", "batch", "[", "\"T\"", "]", "\n", "\n", "# truncate inputs", "\n", "true_times", ",", "true_events", "=", "tgt_timestamps", "[", "...", ",", "cond_num", "]", ",", "tgt_marks", "[", "...", ",", "cond_num", "]", "\n", "\n", "tgt_timestamps", "=", "tgt_timestamps", "[", "...", ",", ":", "cond_num", "]", "\n", "tgt_marks", "=", "tgt_marks", "[", "...", ",", ":", "cond_num", "]", "\n", "padding_mask", "=", "padding_mask", "[", "...", ",", ":", "cond_num", "]", "\n", "\n", "last_times", "=", "tgt_timestamps", "[", "...", ",", "-", "1", "]", ".", "unsqueeze", "(", "-", "1", ")", "## commented code below assumes there is no `unsqueeze(-1)` operation", "\n", "\n", "# get output intensity values", "\n", "# sample_timestamps = torch.rand(", "\n", "#     tgt_timestamps.shape[0], ", "\n", "#     num_samples, ", "\n", "#     dtype=tgt_timestamps.dtype, ", "\n", "#     device=tgt_timestamps.device", "\n", "# ).clamp(min=1e-8)  # ~ U(0,1)", "\n", "# sample_timestamps = sample_timestamps * (T.squeeze(-1) - last_times).unsqueeze(-1) + last_times.unsqueeze(-1)  # ~ U(t_{i-1}, T)", "\n", "# sample_timestamps = []", "\n", "# for i in range(last_times.shape[0]):", "\n", "#     sample_timestamps.append(torch.linspace(last_times[i]+1e-9, T[i,0], num_samples+1))", "\n", "# sample_timestamps = torch.stack(sample_timestamps, dim=0)", "\n", "sample_timestamps", "=", "base_linspace", "*", "(", "T", "-", "last_times", ")", "+", "last_times", "\n", "timestep", "=", "(", "T", "-", "last_times", ")", "/", "num_samples", "\n", "\n", "model_res", "=", "model", "(", "\n", "ref_marks", "=", "ref_marks", ",", "\n", "ref_timestamps", "=", "ref_timestamps", ",", "\n", "ref_marks_bwd", "=", "ref_marks_backwards", ",", "\n", "ref_timestamps_bwd", "=", "ref_timestamps_backwards", ",", "\n", "tgt_marks", "=", "tgt_marks", ",", "\n", "tgt_timestamps", "=", "tgt_timestamps", ",", "\n", "context_lengths", "=", "context_lengths", ",", "\n", "sample_timestamps", "=", "sample_timestamps", ",", "\n", "pp_id", "=", "pp_id", ",", "\n", ")", "\n", "\n", "sample_intensities", "=", "model_res", "[", "\"sample_intensities\"", "]", "\n", "log_mark_intensity", "=", "sample_intensities", "[", "\"all_log_mark_intensities\"", "]", "\n", "total_intensity", "=", "sample_intensities", "[", "\"total_intensity\"", "]", "\n", "mark_prob", "=", "log_mark_intensity", ".", "exp", "(", ")", "/", "total_intensity", ".", "unsqueeze", "(", "-", "1", ")", "\n", "#log_total_intensity = total_intensity.clamp(0.0001, None).log()", "\n", "#log_mark_prob = log_mark_intensity - log_total_intensity.unsqueeze(-1)", "\n", "#mark_prob = log_mark_prob.exp()", "\n", "\n", "intensity_integral", "=", "torch", ".", "cumsum", "(", "timestep", "*", "total_intensity", ",", "dim", "=", "-", "1", ")", "\n", "t_density", "=", "total_intensity", "*", "torch", ".", "exp", "(", "-", "intensity_integral", ")", "\n", "t_pit", "=", "sample_timestamps", "*", "t_density", "# integrand for time estimator", "\n", "pm_pit", "=", "mark_prob", "*", "t_density", ".", "unsqueeze", "(", "-", "1", ")", "# integrand for mark estimator", "\n", "\n", "# use the trapeze method of integration", "\n", "pred_times", "=", "(", "timestep", "*", "0.5", "*", "(", "t_pit", "[", "...", ",", "1", ":", "]", "+", "t_pit", "[", "...", ",", ":", "-", "1", "]", ")", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "# sum over sample timestep dimension", "\n", "pred_dists", "=", "(", "timestep", ".", "unsqueeze", "(", "-", "1", ")", "*", "0.5", "*", "(", "pm_pit", "[", "...", ",", "1", ":", ",", ":", "]", "+", "pm_pit", "[", "...", ",", ":", "-", "1", ",", ":", "]", ")", ")", ".", "sum", "(", "dim", "=", "-", "2", ")", "# sum over sample timestep dimension", "\n", "\n", "# MC estimate probability distributions", "\n", "# sample_intensities = model_res[\"sample_intensities\"]", "\n", "# log_mark_intensity = sample_intensities[\"all_log_mark_intensities\"]", "\n", "# total_intensity = sample_intensities[\"total_intensity\"]", "\n", "# log_total_intensity = total_intensity.clamp(0.0001, None).log()", "\n", "# log_mark_prob = log_mark_intensity - log_total_intensity.unsqueeze(-1)", "\n", "# #mark_prob = log_mark_prob.exp()", "\n", "\n", "# ## p(t_i=t) = \\lambda(t) exp(-\\int_{t_{i-1}}^t \\lambda(s) ds)", "\n", "# ## \\int_{t_{i-1}}^t \\lambda(s) ds \\approx (t - t_{i-1}) * 1/N * \\sum_{i=1}^N \\lambda(s_i)", "\n", "# ##   for s_i \\sim U(t_{i-1}, t]", "\n", "# cum_hazard = total_intensity.cumsum(dim=-1)", "\n", "# cum_hazard = cum_hazard * (sample_timestamps - last_times.unsqueeze(-1))", "\n", "# cum_hazard = -cum_hazard / num_samples_iterated", "\n", "# p_t = total_intensity * cum_hazard.exp() ", "\n", "# log_p_t = log_total_intensity + cum_hazard", "\n", "\n", "# ## \\hat{t_i} = \\int_{t_{i-1}}^T tp(t_i=t) dt", "\n", "# pred_times = (T.squeeze() - last_times) / num_samples * (sample_timestamps * p_t).sum(dim=-1)", "\n", "\n", "# ## p(k_i=k) \\propto \\int_{t_{i-1}}^T \\lambda_k(t) / \\lambda(t) * P(t_i=t) dt", "\n", "# ## since we only care about rankings, we will compute the following instead", "\n", "# ## p(k_i=k) \\propto \\int_{t_{i-1}}^T log \\lambda_k(t) - log\\lambda(t) + log P(t_i=t) dt", "\n", "# ## log_mark_prob is size (batch, num_samples, total_marks)", "\n", "# pred_dists = (log_mark_prob + log_p_t.unsqueeze(-1)).sum(dim=-2)  # sum over sample dim", "\n", "# pred_dists = pred_dists * (T.squeeze() - last_times).unsqueeze(-1) / num_samples", "\n", "\n", "# evaluate metrics", "\n", "r", "=", "_rank", "(", "pred_dists", ",", "true_events", ")", "# compute this so we only rank them once per batch", "\n", "batch_res", "=", "{", "k", ":", "metric", "(", "\n", "pred_times", "=", "pred_times", ",", "\n", "pred_dists", "=", "pred_dists", ",", "\n", "true_times", "=", "true_times", ",", "\n", "true_events", "=", "true_events", ",", "\n", "r", "=", "r", ",", "\n", ")", "for", "k", ",", "metric", "in", "all_metrics", ".", "items", "(", ")", "}", "\n", "\n", "for", "t", ",", "k", "in", "zip", "(", "[", "pred_times", ",", "true_times", ",", "last_times", "]", ",", "[", "\"pred_time\"", ",", "\"true_time\"", ",", "\"last_time\"", "]", ")", ":", "\n", "                ", "_t", "=", "t", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", "\n", "if", "not", "isinstance", "(", "_t", ",", "list", ")", ":", "\n", "                    ", "_t", "=", "[", "_t", "]", "\n", "", "batch_res", "[", "k", "]", "=", "_t", "\n", "\n", "# import readline # optional, will allow Up/Down/History in the console", "\n", "# import code", "\n", "# variables = globals().copy()", "\n", "# variables.update(locals())", "\n", "# shell = code.InteractiveConsole(variables)", "\n", "# shell.interact()", "\n", "\n", "\n", "# print(\"DONE\")", "\n", "# input()", "\n", "\n", "# store results ", "\n", "", "for", "k", ",", "b_res", "in", "batch_res", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "not", "in", "results", ":", "\n", "                    ", "results", "[", "k", "]", "=", "[", "]", "\n", "", "results", "[", "k", "]", ".", "extend", "(", "b_res", ")", "\n", "## this was debugging for lastfm predictions", "\n", "## makes no sense for other datasets", "\n", "# if any(x > 30 for x in batch_res[\"time_l1\"]):  ", "\n", "#     print_log(\"BAD BATCH DETECTED\")", "\n", "#     print_log(\"BAD BATCH DETECTED\")", "\n", "#     print_log(\"BAD BATCH DETECTED\")", "\n", "#     if \"bad_batches\" not in results:", "\n", "#         results[\"bad_batches\"] = []", "\n", "#     results[\"bad_batches\"].append((batch_res, {k:v.tolist() for k,v in batch.items()}))", "\n", "\n", "# add to overall results", "\n", "\n", "", "", "if", "select_condition_amounts", ":", "\n", "            ", "all_results", "[", "cond_num", "]", "=", "results", "\n", "\n", "", "mean_res", "=", "{", "}", "\n", "bad_indices", "=", "set", "(", ")", "\n", "for", "k", ",", "v", "in", "results", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "!=", "\"bad_batches\"", ":", "\n", "                ", "bad_indices", "=", "bad_indices", ".", "union", "(", "set", "(", "i", "for", "i", ",", "el", "in", "enumerate", "(", "v", ")", "if", "el", "!=", "el", ")", ")", "# filter out nan's", "\n", "", "", "for", "k", ",", "v", "in", "results", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "!=", "\"bad_batches\"", ":", "\n", "                ", "filtered_v", "=", "[", "el", "for", "i", ",", "el", "in", "enumerate", "(", "v", ")", "if", "i", "not", "in", "bad_indices", "]", "\n", "if", "len", "(", "filtered_v", ")", ">", "0", ":", "\n", "                    ", "mean_res", "[", "k", "]", "=", "sum", "(", "filtered_v", ")", "/", "len", "(", "filtered_v", ")", "\n", "", "else", ":", "\n", "                    ", "mean_res", "[", "k", "]", "=", "-", "1", "\n", "", "num_seqs", "=", "len", "(", "filtered_v", ")", "\n", "", "", "mean_res", "[", "\"num_predictions\"", "]", "=", "num_seqs", "\n", "#mean_results[cond_num] = {k:((sum(v) / len(v)) if len(v) > 0 else None) for k,v in results.items() if k != \"bad_batches\"}", "\n", "mean_results", "[", "cond_num", "]", "=", "mean_res", "\n", "# save results to file", "\n", "if", "select_condition_amounts", ":", "\n", "            ", "mean_res_path", "=", "\"{}/pred_task_mean_results.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", "\n", "all_res_path", "=", "\"{}/pred_task_all_results.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", "\n", "print_log", "(", "\"Saving intermittent results to\"", ",", "mean_res_path", ",", "all_res_path", ")", "\n", "pickle", ".", "dump", "(", "all_results", ",", "open", "(", "all_res_path", ",", "\"wb\"", ")", ")", "\n", "pickle", ".", "dump", "(", "mean_results", ",", "open", "(", "mean_res_path", ",", "\"wb\"", ")", ")", "\n", "", "else", ":", "\n", "            ", "mean_res_path", "=", "\"{}/all_pred_task_mean_results.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", "\n", "print_log", "(", "\"Saving intermittent results to\"", ",", "mean_res_path", ")", "\n", "pickle", ".", "dump", "(", "mean_results", ",", "open", "(", "mean_res_path", ",", "\"wb\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.anomaly_detection": [[620, 709], ["model.eval", "zip", "vae_mpp.data.AnomalyDetectionDataset", "torch.utils.data.DataLoader", "enumerate", "sorted", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "pickle.dump", "model", "model.log_likelihood", "zip", "sum", "len", "args.checkpoint_path.rstrip", "open", "vae_mpp.utils.print_log", "torch.rand().clamp", "batch[].tolist", "ll_results[].tolist", "results.append", "vae_mpp.data.pad_and_combine_instances", "v.cuda", "len", "torch.cuda.current_device", "batch.items", "torch.rand", "len", "all_results.items"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.log_likelihood", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.pad_and_combine_instances"], ["", "", "", "def", "anomaly_detection", "(", "args", ",", "model", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "num_samples", "=", "10000", "\n", "lengths_to_test", "=", "[", "1", ",", "5", ",", "10", ",", "20", ",", "50", ",", "None", "]", "\n", "labels", "=", "[", "f\"cond_{i if i is not None else 'all'}\"", "for", "i", "in", "lengths_to_test", "]", "\n", "all_results", "=", "{", "}", "\n", "for", "length", ",", "label", "in", "zip", "(", "lengths_to_test", ",", "labels", ")", ":", "\n", "        ", "results", "=", "[", "]", "\n", "\n", "dataset", "=", "AnomalyDetectionDataset", "(", "\n", "file_path", "=", "args", ".", "valid_data_path", ",", "\n", "args", "=", "args", ",", "\n", "max_tgt_seq_len", "=", "length", ",", "\n", "num_total_pairs", "=", "10000", ",", "\n", "test", "=", "True", ",", "\n", ")", "\n", "\n", "dataloader", "=", "DataLoader", "(", "\n", "dataset", "=", "dataset", ",", "\n", "batch_size", "=", "args", ".", "batch_size", "//", "8", ",", "\n", "shuffle", "=", "False", ",", "\n", "num_workers", "=", "0", ",", "\n", "collate_fn", "=", "lambda", "x", ":", "pad_and_combine_instances", "(", "x", ",", "dataset", ".", "max_period", ")", ",", "\n", "drop_last", "=", "False", ",", "\n", "pin_memory", "=", "args", ".", "pin_test_memory", ",", "\n", ")", "\n", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "if", "(", "(", "i", "+", "1", ")", "%", "10", "==", "0", ")", "or", "(", "i", "<", "20", ")", ":", "\n", "                ", "print_log", "(", "f\"Batch {i+1}/{len(dataloader)} for conditioning on {length} events processed.\"", ")", "\n", "\n", "", "if", "args", ".", "cuda", ":", "\n", "                ", "batch", "=", "{", "k", ":", "v", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", "}", "\n", "\n", "", "ref_marks", ",", "ref_timestamps", ",", "context_lengths", ",", "padding_mask", "=", "batch", "[", "\"ref_marks\"", "]", ",", "batch", "[", "\"ref_times\"", "]", ",", "batch", "[", "\"context_lengths\"", "]", ",", "batch", "[", "\"padding_mask\"", "]", "\n", "ref_marks_backwards", ",", "ref_timestamps_backwards", "=", "batch", "[", "\"ref_marks_backwards\"", "]", ",", "batch", "[", "\"ref_times_backwards\"", "]", "\n", "tgt_marks", ",", "tgt_timestamps", "=", "batch", "[", "\"tgt_marks\"", "]", ",", "batch", "[", "\"tgt_times\"", "]", "\n", "pp_id", "=", "batch", "[", "\"pp_id\"", "]", "\n", "T", "=", "batch", "[", "\"T\"", "]", "\n", "\n", "sample_timestamps", "=", "torch", ".", "rand", "(", "\n", "tgt_timestamps", ".", "shape", "[", "0", "]", ",", "\n", "num_samples", ",", "\n", "dtype", "=", "tgt_timestamps", ".", "dtype", ",", "\n", "device", "=", "tgt_timestamps", ".", "device", "\n", ")", ".", "clamp", "(", "min", "=", "1e-8", ")", "*", "T", "# ~ U(0, T)", "\n", "\n", "model_res", "=", "model", "(", "\n", "ref_marks", "=", "ref_marks", ",", "\n", "ref_timestamps", "=", "ref_timestamps", ",", "\n", "ref_marks_bwd", "=", "ref_marks_backwards", ",", "\n", "ref_timestamps_bwd", "=", "ref_timestamps_backwards", ",", "\n", "tgt_marks", "=", "tgt_marks", ",", "\n", "tgt_timestamps", "=", "tgt_timestamps", ",", "\n", "context_lengths", "=", "context_lengths", ",", "\n", "sample_timestamps", "=", "sample_timestamps", ",", "\n", "pp_id", "=", "pp_id", ",", "\n", ")", "\n", "\n", "ll_results", "=", "model", ".", "log_likelihood", "(", "\n", "return_dict", "=", "model_res", ",", "\n", "right_window", "=", "T", ",", "\n", "left_window", "=", "0.0", ",", "\n", "mask", "=", "padding_mask", ",", "\n", "reduce", "=", "False", ",", "\n", ")", "\n", "\n", "for", "same_source", ",", "ll", "in", "zip", "(", "batch", "[", "\"same_source\"", "]", ".", "tolist", "(", ")", ",", "ll_results", "[", "\"batch_log_likelihood\"", "]", ".", "tolist", "(", ")", ")", ":", "\n", "                ", "results", ".", "append", "(", "(", "same_source", "[", "0", "]", ",", "ll", ")", ")", "\n", "\n", "", "", "sorted_results", "=", "sorted", "(", "results", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", "\n", "most_likely", "=", "sorted_results", "[", ":", "(", "len", "(", "sorted_results", ")", "//", "2", ")", "]", "\n", "correctly_ranked", "=", "[", "same_source", "for", "same_source", ",", "ll", "in", "most_likely", "]", "\n", "proportion_ranked", "=", "sum", "(", "correctly_ranked", ")", "/", "len", "(", "correctly_ranked", ")", "\n", "\n", "all_results", "[", "label", "]", "=", "{", "\n", "\"raw\"", ":", "results", ",", "\n", "\"agg\"", ":", "proportion_ranked", ",", "\n", "}", "\n", "\n", "print_log", "(", "f\"Finished anomaly detection for {length} length target sequences.\"", ")", "\n", "print_log", "(", "f\"Final proportion of correctly ranked pairs: {proportion_ranked}.\"", ")", "\n", "print_log", "(", "f\"Results up to now: { {k:v for k,v in all_results.items() if k == 'agg'} }\"", ")", "\n", "print_log", "(", "\"\"", ")", "\n", "\n", "res_path", "=", "\"{}/anomaly_detection_results_{}_{}.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ",", "\"diff_refs\"", "if", "args", ".", "anomaly_same_tgt_diff_refs", "else", "\"diff_tgt\"", ",", "\"trunc_tgt\"", "if", "args", ".", "anomaly_truncate_tgts", "else", "\"trunc_refs\"", ")", "\n", "print_log", "(", "\"Saving intermittent results to\"", ",", "res_path", ")", "\n", "pickle", ".", "dump", "(", "all_results", ",", "open", "(", "res_path", ",", "\"wb\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_ab_to_ms": [[710, 719], ["alpha.keys"], "function", ["None"], ["", "", "def", "_gamma_ab_to_ms", "(", "alpha", ",", "beta", ")", ":", "\n", "    ", "new_mu", "=", "{", "}", "\n", "new_var", "=", "{", "}", "\n", "for", "k", "in", "alpha", ".", "keys", "(", ")", ":", "\n", "        ", "a", ",", "b", "=", "alpha", "[", "k", "]", ",", "beta", "[", "k", "]", "\n", "new_mu", "[", "k", "]", "=", "a", "/", "b", "\n", "new_var", "[", "k", "]", "=", "a", "/", "(", "b", "**", "2", ")", "\n", "\n", "", "return", "new_mu", ",", "new_var", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_ms_to_ab": [[720, 729], ["mu.keys"], "function", ["None"], ["", "def", "_gamma_ms_to_ab", "(", "mu", ",", "sigma_sq", ")", ":", "\n", "    ", "new_alpha", "=", "{", "}", "\n", "new_beta", "=", "{", "}", "\n", "for", "k", "in", "mu", ".", "keys", "(", ")", ":", "\n", "        ", "m", ",", "s", "=", "mu", "[", "k", "]", ",", "sigma_sq", "[", "k", "]", "\n", "new_alpha", "[", "k", "]", "=", "(", "m", "**", "2", ")", "/", "s", "\n", "new_beta", "[", "k", "]", "=", "m", "/", "s", "\n", "\n", "", "return", "new_alpha", ",", "new_beta", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_mode": [[730, 739], ["alpha.keys"], "function", ["None"], ["", "def", "_gamma_mode", "(", "alpha", ",", "beta", ")", ":", "\n", "    ", "modes", "=", "{", "}", "\n", "for", "k", "in", "alpha", ".", "keys", "(", ")", ":", "\n", "        ", "a", ",", "b", "=", "alpha", "[", "k", "]", ",", "beta", "[", "k", "]", "\n", "if", "a", "<", "1", ":", "\n", "#return None, False", "\n", "            ", "a", "=", "1", "+", "1e-4", "\n", "", "modes", "[", "k", "]", "=", "(", "a", "-", "1", ")", "/", "b", "\n", "", "return", "modes", ",", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_mean": [[740, 746], ["alpha.keys"], "function", ["None"], ["", "def", "_gamma_mean", "(", "alpha", ",", "beta", ")", ":", "\n", "    ", "means", "=", "{", "}", "\n", "for", "k", "in", "alpha", ".", "keys", "(", ")", ":", "\n", "        ", "a", ",", "b", "=", "alpha", "[", "k", "]", ",", "beta", "[", "k", "]", "\n", "modes", "[", "k", "]", "=", "a", "/", "b", "\n", "", "return", "means", ",", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_post": [[747, 756], ["collections.defaultdict", "alpha.keys", "alpha.copy", "beta.copy"], "function", ["None"], ["", "def", "_gamma_post", "(", "obs", ",", "alpha", ",", "beta", ")", ":", "\n", "    ", "counts", "=", "defaultdict", "(", "int", ")", "\n", "alpha", ",", "beta", "=", "alpha", ".", "copy", "(", ")", ",", "beta", ".", "copy", "(", ")", "\n", "for", "mark", "in", "obs", "[", "\"ref_marks\"", "]", ":", "\n", "        ", "counts", "[", "mark", "]", "+=", "1", "\n", "", "for", "k", "in", "alpha", ".", "keys", "(", ")", ":", "\n", "        ", "alpha", "[", "k", "]", "+=", "counts", "[", "k", "]", "\n", "beta", "[", "k", "]", "+=", "1", "\n", "", "return", "alpha", ",", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_post_means": [[757, 766], ["collections.defaultdict", "alpha.keys", "alpha.copy", "beta.copy"], "function", ["None"], ["", "def", "_gamma_post_means", "(", "obs", ",", "alpha", ",", "beta", ",", "var_scale", "=", "1", ")", ":", "\n", "    ", "counts", "=", "defaultdict", "(", "int", ")", "\n", "alpha", ",", "beta", "=", "alpha", ".", "copy", "(", ")", ",", "beta", ".", "copy", "(", ")", "\n", "means", "=", "{", "}", "\n", "for", "mark", "in", "obs", "[", "\"ref_marks\"", "]", ":", "\n", "        ", "counts", "[", "mark", "]", "+=", "1", "\n", "", "for", "k", "in", "alpha", ".", "keys", "(", ")", ":", "\n", "        ", "means", "[", "k", "]", "=", "(", "var_scale", "*", "alpha", "[", "k", "]", "+", "counts", "[", "k", "]", ")", "/", "(", "var_scale", "*", "beta", "[", "k", "]", "+", "1", ")", "\n", "", "return", "means", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._pois_lik": [[767, 781], ["collections.defaultdict", "lambda_mode.items", "sum", "obs[].item", "log_lik_i.items", "math.log", "math.log", "math.factorial"], "function", ["None"], ["", "def", "_pois_lik", "(", "obs", ",", "lambda_mode", ",", "max_T", ")", ":", "\n", "    ", "counts", "=", "defaultdict", "(", "int", ")", "\n", "for", "mark", "in", "obs", "[", "\"tgt_marks\"", "]", ":", "\n", "        ", "counts", "[", "mark", "]", "+=", "1", "\n", "", "log_lik_i", "=", "{", "}", "\n", "for", "k", ",", "rate", "in", "lambda_mode", ".", "items", "(", ")", ":", "\n", "        ", "count", "=", "counts", "[", "k", "]", "\n", "adj_rate", "=", "rate", "*", "obs", "[", "\"T\"", "]", ".", "item", "(", ")", "/", "max_T", "\n", "if", "rate", "==", "0.0", ":", "\n", "            ", "log_lik_i", "[", "k", "]", "=", "-", "1e10", "\n", "", "else", ":", "\n", "            ", "log_lik_i", "[", "k", "]", "=", "-", "adj_rate", "-", "math", ".", "log", "(", "math", ".", "factorial", "(", "count", ")", ")", "+", "count", "*", "math", ".", "log", "(", "adj_rate", ")", "\n", "#return log_lik_i, sum(v for k,v in log_lik_i.items())", "\n", "", "", "return", "sum", "(", "v", "for", "k", ",", "v", "in", "log_lik_i", ".", "items", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.baseline_anomaly_detection": [[782, 905], ["collections.defaultdict", "collections.defaultdict", "os.path.exists", "evaluate._gamma_ab_to_ms", "vae_mpp.data.AnomalyDetectionDataset", "vae_mpp.utils.print_log", "sorted", "vae_mpp.utils.print_log", "zip", "args.checkpoint_path.rstrip", "pickle.load", "vae_mpp.utils.print_log", "enumerate", "pickle.dump", "vae_mpp.utils.print_log", "enumerate", "sorted", "vae_mpp.utils.print_log", "sorted.items", "vae_mpp.utils.print_log", "vae_mpp.data.AnomalyDetectionDataset", "vae_mpp.utils.print_log", "evaluate._gamma_ms_to_ab", "enumerate", "sorted", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "pickle.dump", "open", "open", "range", "evaluate._gamma_post_means", "evaluate._pois_lik", "results.append", "sum", "len", "evaluate._gamma_post_means", "evaluate._pois_lik", "test_results.append", "sum", "len", "args.checkpoint_path.rstrip", "open", "vae_mpp.utils.print_log", "v.numpy", "abs", "vae_mpp.utils.print_log", "v.numpy", "vae_mpp.utils.print_log", "v.numpy", "obs.items", "obs.items", "obs[].item", "len", "prior_var.items", "obs.items", "obs[].item", "len", "obs[].item", "len", "len", "len", "all_results.items"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_ab_to_ms", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_ms_to_ab", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_post_means", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._pois_lik", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._gamma_post_means", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate._pois_lik", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log"], ["", "def", "baseline_anomaly_detection", "(", "args", ",", "train_dataloader", ")", ":", "\n", "    ", "train_dataset", "=", "train_dataloader", ".", "dataset", "\n", "\n", "# find mle from training data", "\n", "max_T", "=", "train_dataset", ".", "max_period", "\n", "mle_counts", "=", "defaultdict", "(", "int", ")", "\n", "mle_props", "=", "defaultdict", "(", "float", ")", "\n", "total_obs", "=", "0", "\n", "mle_path", "=", "\"{}/anomaly_detection_baseline_mle.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "mle_path", ")", ":", "\n", "        ", "mle_counts", ",", "total_obs", "=", "pickle", ".", "load", "(", "open", "(", "mle_path", ",", "\"rb\"", ")", ")", "\n", "", "else", ":", "\n", "        ", "print_log", "(", "\"Finding mle from training data\"", ")", "\n", "for", "i", ",", "obs", "in", "enumerate", "(", "train_dataset", ")", ":", "\n", "            ", "if", "i", "%", "50000", "==", "0", ":", "\n", "                ", "print_log", "(", "f\"\\tProgress {i} / {len(train_dataset)}\"", ")", "\n", "", "obs", "=", "{", "k", ":", "v", ".", "numpy", "(", ")", "for", "k", ",", "v", "in", "obs", ".", "items", "(", ")", "}", "\n", "if", "abs", "(", "obs", "[", "\"T\"", "]", ".", "item", "(", ")", "-", "max_T", ")", ">", "1e-2", ":", "\n", "                ", "continue", "\n", "\n", "", "total_obs", "+=", "1", "\n", "for", "mark", "in", "obs", "[", "\"tgt_marks\"", "]", ":", "\n", "                ", "mle_counts", "[", "mark", "]", "+=", "1", "\n", "", "", "pickle", ".", "dump", "(", "(", "mle_counts", ",", "total_obs", ")", ",", "open", "(", "mle_path", ",", "\"wb\"", ")", ")", "\n", "\n", "# tune variance on valid data", "\n", "", "prior_alpha", "=", "mle_counts", "\n", "prior_beta", "=", "{", "k", ":", "total_obs", "for", "k", "in", "mle_counts", "}", "\n", "prior_mu", ",", "prior_var", "=", "_gamma_ab_to_ms", "(", "prior_alpha", ",", "prior_beta", ")", "\n", "\n", "var_scales", "=", "[", "10", "**", "(", "-", "i", ")", "for", "i", "in", "range", "(", "12", ")", "]", "\n", "\n", "valid_dataset", "=", "AnomalyDetectionDataset", "(", "\n", "file_path", "=", "args", ".", "valid_data_path", ",", "\n", "args", "=", "args", ",", "\n", "max_tgt_seq_len", "=", "None", ",", "\n", "num_total_pairs", "=", "1000", ",", "\n", "test", "=", "False", ",", "\n", ")", "\n", "\n", "acc_results", "=", "{", "}", "\n", "print_log", "(", "f\"Testing different variance scales {var_scales}\"", ")", "\n", "for", "var_scale", "in", "var_scales", ":", "\n", "        ", "print_log", "(", "f\"Trying {var_scale}\"", ")", "\n", "results", "=", "[", "]", "\n", "#adj_prior_alpha, adj_prior_beta = _gamma_ms_to_ab(prior_mu, {k:v*var_scale for k,v in prior_var.items()})", "\n", "# adj_prior_alpha, adj_prior_beta = _gamma_adjust_priors(prior_mu, {k:v*var_scale for k,v in prior_var.items()})", "\n", "# _, good_prior = _gamma_mean(adj_prior_alpha, adj_prior_beta)", "\n", "# if not good_prior:", "\n", "#     print_log(\"Not a good prior\")", "\n", "#     continue ", "\n", "\n", "for", "i", ",", "obs", "in", "enumerate", "(", "valid_dataset", ")", ":", "\n", "            ", "if", "i", "%", "100", "==", "0", ":", "\n", "                ", "print_log", "(", "f\"\\t Progress {i} / {len(valid_dataset)}\"", ")", "\n", "", "obs", "=", "{", "k", ":", "v", ".", "numpy", "(", ")", "for", "k", ",", "v", "in", "obs", ".", "items", "(", ")", "}", "\n", "# post_alpha, post_beta = _gamma_post(obs, adj_prior_alpha, adj_prior_beta, var_scale)", "\n", "# lambda_modes, _ = _gamma_mode(post_alpha, post_beta)", "\n", "#ll = _pois_lik(obs, lambda_modes, max_T)", "\n", "lambda_means", "=", "_gamma_post_means", "(", "obs", ",", "prior_alpha", ",", "prior_beta", ",", "var_scale", ")", "\n", "ll", "=", "_pois_lik", "(", "obs", ",", "lambda_means", ",", "max_T", ")", "\n", "results", ".", "append", "(", "(", "obs", "[", "\"same_source\"", "]", ".", "item", "(", ")", ",", "ll", ")", ")", "\n", "\n", "", "sorted_results", "=", "sorted", "(", "results", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", "\n", "#print_log(sorted_results[:100], sorted_results[-100:])", "\n", "most_likely", "=", "sorted_results", "[", ":", "(", "len", "(", "sorted_results", ")", "//", "2", ")", "]", "\n", "correctly_ranked", "=", "[", "same_source", "for", "same_source", ",", "ll", "in", "most_likely", "]", "\n", "proportion_ranked", "=", "sum", "(", "correctly_ranked", ")", "/", "len", "(", "correctly_ranked", ")", "\n", "acc_results", "[", "var_scale", "]", "=", "proportion_ranked", "\n", "print_log", "(", "f\"Var Scale {var_scale} used, resulted in {proportion_ranked} acc\"", ")", "\n", "\n", "", "acc_results", "=", "sorted", "(", "acc_results", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", "\n", "var_scale", ",", "best_valid_acc", "=", "acc_results", "[", "0", "]", "\n", "print_log", "(", "f\"Var Scale chosen: {var_scale} w/ valid accuracy of {best_valid_acc}\"", ")", "\n", "\n", "lengths_to_test", "=", "[", "1", ",", "5", ",", "10", ",", "20", ",", "50", ",", "None", "]", "[", ":", ":", "-", "1", "]", "\n", "labels", "=", "[", "f\"cond_{i if i is not None else 'all'}\"", "for", "i", "in", "lengths_to_test", "]", "\n", "all_results", "=", "{", "}", "\n", "for", "length", ",", "label", "in", "zip", "(", "lengths_to_test", ",", "labels", ")", ":", "\n", "        ", "print_log", "(", "\"Performing test on\"", ",", "label", ")", "\n", "\n", "test_dataset", "=", "AnomalyDetectionDataset", "(", "\n", "file_path", "=", "args", ".", "valid_data_path", ",", "\n", "args", "=", "args", ",", "\n", "max_tgt_seq_len", "=", "length", ",", "\n", "num_total_pairs", "=", "10000", ",", "\n", "test", "=", "True", ",", "\n", ")", "\n", "\n", "# get ranking ", "\n", "test_results", "=", "[", "]", "\n", "print_log", "(", "\"Adjusting priors\"", ")", "\n", "adj_prior_alpha", ",", "adj_prior_beta", "=", "_gamma_ms_to_ab", "(", "prior_mu", ",", "{", "k", ":", "v", "*", "var_scale", "for", "k", ",", "v", "in", "prior_var", ".", "items", "(", ")", "}", ")", "\n", "for", "i", ",", "obs", "in", "enumerate", "(", "test_dataset", ")", ":", "\n", "            ", "if", "i", "%", "100", "==", "0", ":", "\n", "                ", "print_log", "(", "f\"\\t Progress {i} / {len(test_dataset)}\"", ")", "\n", "", "obs", "=", "{", "k", ":", "v", ".", "numpy", "(", ")", "for", "k", ",", "v", "in", "obs", ".", "items", "(", ")", "}", "\n", "#post_alpha, post_beta = _gamma_post(obs, adj_prior_alpha, adj_prior_beta)", "\n", "#lambda_modes,_ = _gamma_mode(post_alpha, post_beta)", "\n", "#ll = _pois_lik(obs, lambda_modes, max_T)", "\n", "lambda_means", "=", "_gamma_post_means", "(", "obs", ",", "prior_alpha", ",", "prior_beta", ",", "var_scale", ")", "\n", "ll", "=", "_pois_lik", "(", "obs", ",", "lambda_means", ",", "max_T", ")", "\n", "test_results", ".", "append", "(", "(", "obs", "[", "\"same_source\"", "]", ".", "item", "(", ")", ",", "ll", ")", ")", "\n", "\n", "", "sorted_results", "=", "sorted", "(", "test_results", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", "\n", "most_likely", "=", "sorted_results", "[", ":", "(", "len", "(", "sorted_results", ")", "//", "2", ")", "]", "\n", "correctly_ranked", "=", "[", "same_source", "for", "same_source", ",", "ll", "in", "most_likely", "]", "\n", "proportion_ranked", "=", "sum", "(", "correctly_ranked", ")", "/", "len", "(", "correctly_ranked", ")", "\n", "\n", "all_results", "[", "label", "]", "=", "{", "\n", "\"raw\"", ":", "test_results", ",", "\n", "\"agg\"", ":", "proportion_ranked", ",", "\n", "\"var_scale\"", ":", "var_scale", "\n", "}", "\n", "\n", "print_log", "(", "f\"Finished anomaly detection for {length} length target sequences.\"", ")", "\n", "print_log", "(", "f\"Final proportion of correctly ranked pairs: {proportion_ranked}.\"", ")", "\n", "print_log", "(", "f\"Results up to now: { {k:v for k,v in all_results.items() if k == 'agg'} }\"", ")", "\n", "print_log", "(", "\"\"", ")", "\n", "\n", "res_path", "=", "\"{}/anomaly_detection_baseline_results_{}_{}.pickle\"", ".", "format", "(", "args", ".", "checkpoint_path", ".", "rstrip", "(", "\"/\"", ")", ",", "\"diff_refs\"", "if", "args", ".", "anomaly_same_tgt_diff_refs", "else", "\"diff_tgt\"", ",", "\"trunc_tgt\"", "if", "args", ".", "anomaly_truncate_tgts", "else", "\"trunc_refs\"", ")", "\n", "print_log", "(", "\"Saving intermittent results to\"", ",", "res_path", ")", "\n", "pickle", ".", "dump", "(", "all_results", ",", "open", "(", "res_path", ",", "\"wb\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.main": [[907, 982], ["vae_mpp.utils.print_log", "vae_mpp.arguments.get_args", "vae_mpp.utils.print_log", "vae_mpp.train.set_random_seed", "vae_mpp.utils.print_log", "vae_mpp.train.get_data", "vae_mpp.utils.print_log", "vae_mpp.train.setup_model_and_optim", "vae_mpp.train.report_model_stats", "vae_mpp.train.load_checkpoint", "len", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.train.load_checkpoint", "vae_mpp.utils.print_log", "evaluate.save_and_vis_intensities", "fp.replace", "old_path.rstrip", "vae_mpp.utils.print_log", "evaluate.sample_generations", "vae_mpp.utils.print_log", "evaluate.likelihood_over_time", "vae_mpp.utils.print_log", "evaluate.save_latents", "vae_mpp.utils.print_log", "torch.no_grad", "evaluate.anomaly_detection", "evaluate.baseline_anomaly_detection", "vae_mpp.utils.print_log", "torch.no_grad", "evaluate.next_event_prediction", "len"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.get_args", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.set_random_seed", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.get_data", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.setup_model_and_optim", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.report_model_stats", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.load_checkpoint", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.load_checkpoint", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.save_and_vis_intensities", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.sample_generations", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.likelihood_over_time", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.save_latents", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.anomaly_detection", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.baseline_anomaly_detection", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.evaluate.next_event_prediction"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "print_log", "(", "\"Getting arguments.\"", ")", "\n", "args", "=", "get_args", "(", ")", "\n", "\n", "# args.anomaly_detection = True", "\n", "# args.anomaly_same_tgt_diff_refs = True  # default is True, True, False", "\n", "# args.anomaly_truncate_tgts = False", "\n", "# args.anomaly_truncate_refs = True ", "\n", "args", ".", "sample_generations", "=", "True", "\n", "args", ".", "top_k", "=", "0", "\n", "args", ".", "top_p", "=", "0", "\n", "\n", "if", "args", ".", "visualize", "or", "args", ".", "sample_generations", ":", "\n", "        ", "args", ".", "batch_size", "=", "4", "\n", "", "if", "args", ".", "get_latents", ":", "\n", "        ", "args", ".", "shuffle", "=", "False", "\n", "args", ".", "same_tgt_and_ref", "=", "True", "\n", "", "else", ":", "\n", "        ", "args", ".", "shuffle", "=", "False", "\n", "\n", "", "if", "not", "(", "args", ".", "next_event_prediction", "or", "args", ".", "anomaly_detection", ")", ":", "\n", "        ", "args", ".", "train_data_path", "=", "[", "fp", ".", "replace", "(", "\"train\"", ",", "\"vis\"", "if", "args", ".", "visualize", "else", "\"valid\"", ")", "for", "fp", "in", "args", ".", "train_data_path", "]", "\n", "\n", "", "print_log", "(", "\"Setting seed.\"", ")", "\n", "set_random_seed", "(", "args", ")", "\n", "\n", "print_log", "(", "\"Setting up dataloaders.\"", ")", "\n", "args", ".", "pin_test_memory", "=", "True", "\n", "# train_dataloader contains the right data for most tasks", "\n", "train_dataloader", ",", "valid_dataloader", ",", "test_dataloader", "=", "get_data", "(", "args", ")", "\n", "\n", "print_log", "(", "\"Setting up model, optimizer, and learning rate scheduler.\"", ")", "\n", "model", ",", "_", ",", "_", "=", "setup_model_and_optim", "(", "args", ",", "len", "(", "train_dataloader", ")", ")", "\n", "\n", "report_model_stats", "(", "model", ")", "\n", "\n", "load_result", "=", "load_checkpoint", "(", "args", ",", "model", ")", "\n", "if", "load_result", "==", "0", ":", "\n", "        ", "old_path", "=", "args", ".", "checkpoint_path", "\n", "args", ".", "checkpoint_path", "=", "old_path", ".", "rstrip", "(", "\"/\"", ")", "+", "\"/data_ablation/\"", "\n", "print_log", "(", "f\"Model not found in {old_path}.\"", ")", "\n", "print_log", "(", "f\"Trying to load model instead from {args.checkpoint_path}.\"", ")", "\n", "load_checkpoint", "(", "args", ",", "model", ")", "\n", "args", ".", "checkpoint_path", "=", "old_path", "\n", "\n", "", "if", "args", ".", "visualize", ":", "\n", "        ", "print_log", "(", "\"Starting visualization.\"", ")", "\n", "save_and_vis_intensities", "(", "args", ",", "model", ",", "train_dataloader", ")", "\n", "", "elif", "args", ".", "sample_generations", ":", "\n", "        ", "print_log", "(", "\"Sampling generations.\"", ")", "\n", "sample_generations", "(", "args", ",", "model", ",", "test_dataloader", ")", "# train_dataloader)", "\n", "", "elif", "args", ".", "likelihood_over_time", ":", "\n", "        ", "print_log", "(", "\"Starting likelihood over time analysis.\"", ")", "\n", "if", "\"amazon\"", "in", "args", ".", "checkpoint_path", ":", "\n", "            ", "args", ".", "likelihood_resolution", "=", "args", ".", "likelihood_resolution", "/", "4.0", "# 1/4 day resolution", "\n", "", "elif", "\"lastfm\"", "in", "args", ".", "checkpoint_path", ":", "\n", "            ", "args", ".", "likelihood_resolution", "=", "args", ".", "likelihood_resolution", "/", "6.0", "# 10 minute resolution", "\n", "# else: 1 hour resolution over 1 week = 168 bins", "\n", "\n", "", "likelihood_over_time", "(", "args", ",", "model", ",", "test_dataloader", ")", "# train_dataloader)", "\n", "", "elif", "args", ".", "get_latents", ":", "\n", "        ", "print_log", "(", "\"Extracting latent states.\"", ")", "\n", "save_latents", "(", "args", ",", "model", ",", "train_dataloader", ")", "\n", "", "elif", "args", ".", "anomaly_detection", ":", "\n", "        ", "print_log", "(", "\"Starting anomaly detection experiments.\"", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "anomaly_detection", "(", "args", ",", "model", ")", "\n", "", "if", "\"rmtpp\"", "in", "args", ".", "checkpoint_path", ":", "\n", "            ", "baseline_anomaly_detection", "(", "args", ",", "train_dataloader", ")", "\n", "", "", "elif", "args", ".", "next_event_prediction", ":", "\n", "        ", "print_log", "(", "\"Performing next event prediction experiments.\"", ")", "\n", "#args.num_workers = 0", "\n", "args", ".", "num_samples", "=", "(", "len", "(", "test_dataloader", ")", "-", "1", ")", "*", "args", ".", "batch_size", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "next_event_prediction", "(", "args", ",", "model", ",", "test_dataloader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.general_args": [[7, 14], ["parser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument"], "function", ["None"], ["def", "general_args", "(", "parser", ")", ":", "\n", "    ", "group", "=", "parser", ".", "add_argument_group", "(", "\"General set arguments for miscelaneous utilities.\"", ")", "\n", "#group.add_argument(\"--json_config_path\", default=None, help=\"Path to json file containing arguments to be parsed.\")", "\n", "group", ".", "add_argument", "(", "\"--seed\"", ",", "type", "=", "int", ",", "default", "=", "1234321", ",", "help", "=", "\"Seed for all random processes.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dont_print_args\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Specify to disable printing of arguments.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--cuda\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Convert model and data to GPU.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--device_num\"", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "\"Should cuda be enabled, this is the GPU id to use.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.model_config_args": [[15, 47], ["parser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument"], "function", ["None"], ["", "def", "model_config_args", "(", "parser", ")", ":", "\n", "    ", "group", "=", "parser", ".", "add_argument_group", "(", "\"Model configuration arguments.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--time_embedding_size\"", ",", "type", "=", "int", ",", "default", "=", "16", ",", "help", "=", "\"Size of temporal embeddings.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--use_raw_time\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Use raw time for encoding temporal information.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--use_delta_time\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Use time differences for encoding temporal information.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--channel_embedding_size\"", ",", "type", "=", "int", ",", "default", "=", "16", ",", "help", "=", "\"Size of mark embeddings.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--num_channels\"", ",", "type", "=", "int", ",", "default", "=", "3", ",", "help", "=", "\"Number of different possible marks.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--enc_hidden_size\"", ",", "type", "=", "int", ",", "default", "=", "8", ",", "help", "=", "\"Hidden size for encoder GRU.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--enc_bidirectional\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Enables bidirectional encoding.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--enc_num_recurrent_layers\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"Number of recurrent GRU layers in encoder.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--latent_size\"", ",", "type", "=", "int", ",", "default", "=", "4", ",", "help", "=", "\"Final size of the latent vector.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--agg_method\"", ",", "type", "=", "str", ",", "default", "=", "\"concat\"", ",", "help", "=", "\"Method to use for aggregating hidden states from encoder\"", ")", "\n", "group", ".", "add_argument", "(", "\"--agg_noise\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Add random noise during training to encoded latent vector.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--use_encoder\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Setup the model in a VAE fashion.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dec_recurrent_hidden_size\"", ",", "type", "=", "int", ",", "default", "=", "16", ",", "help", "=", "\"Hidden size for decoder GRU.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dec_num_recurrent_layers\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"Number of recurrent layers in decoder.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dec_intensity_factored_heads\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"If enabled, models the logged total intensity and proporation of marks separately.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dec_intensity_use_embeddings\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"If enabled, compute mark intensities by comparing to channel embeddings.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dec_intensity_hidden_size\"", ",", "type", "=", "int", ",", "default", "=", "16", ",", "help", "=", "\"Hidden size of intermediate layers in intensity network.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dec_num_intensity_layers\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"Number of layers in intensity network.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dec_act_func\"", ",", "type", "=", "str", ",", "default", "=", "\"gelu\"", ",", "help", "=", "\"Activation function to be used in intensity network.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dropout\"", ",", "type", "=", "float", ",", "default", "=", "0.2", ",", "help", "=", "\"Dropout rate to be applied to all supported layers during training.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--not_amortized\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Selecting this will disable amortization.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--same_tgt_and_ref\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Not selecting will mix examples that are being encoded and decoded.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--use_hawkes\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Uses a parametric Hawkes process.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--hawkes_bounded\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Make Hawkes parameters non-negative.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--neural_hawkes\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Makes decoder a Neural Hawkes Process.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--rmtpp\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Makes decoder use the RMTPP architecture.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--s2s\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Removes Variational part to the VAE setup.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--normal_dist\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Enables distributions to be Normal. Laplacian otherwise.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--zero_inflated\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Enables the model specified to be in 'zero inflated' mode meaning that an additional bernoulli variable will be modeled to artificially inflate zero counts in corresponding output intensities.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--personalized_head\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Adds a linear transformation of the user embedding to the intensity logits.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.training_args": [[48, 73], ["parser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument"], "function", ["None"], ["", "def", "training_args", "(", "parser", ")", ":", "\n", "    ", "group", "=", "parser", ".", "add_argument_group", "(", "\"Training specification arguments.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--checkpoint_path\"", ",", "type", "=", "str", ",", "default", "=", "\"./\"", ",", "help", "=", "\"Path to folder that contains model checkpoints. Will take the most recent one.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--finetune\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Will load in a model from the checkpoint path to finetune.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--train_data_percentage\"", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "\"Percentage (between 0 and 1) of training data to keep. Used for ablation studies with relation to amount of data.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--train_epochs\"", ",", "type", "=", "int", ",", "default", "=", "40", ",", "help", "=", "\"Number of epochs to iterate over for training.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--train_data_path\"", ",", "nargs", "=", "\"+\"", ",", "type", "=", "str", ",", "default", "=", "[", "\"./data/1_pp/training.pickle\"", "]", ",", "help", "=", "\"Path to training data file.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--num_workers\"", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "\"Number of parallel workers for data loaders.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--batch_size\"", ",", "type", "=", "int", ",", "default", "=", "32", ",", "help", "=", "\"Number of samples per batch.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--log_interval\"", ",", "type", "=", "int", ",", "default", "=", "100", ",", "help", "=", "\"Number of batches to complete before printing intermediate results.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--save_epochs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"Number of training epochs to complete between model checkpoint saves.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--optimizer\"", ",", "type", "=", "str", ",", "default", "=", "\"adam\"", ",", "help", "=", "\"Type of optimization algorithm to use.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--grad_clip\"", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "\"Threshold for gradient clipping.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--lr\"", ",", "type", "=", "float", ",", "default", "=", "0.0003", ",", "help", "=", "\"Learning rate.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--loss_beta\"", ",", "type", "=", "float", ",", "default", "=", "0.2", ",", "help", "=", "\"Beta scaling parameter for loss.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--loss_monotonic\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "help", "=", "\"Loss scaling parameters annealing monotonic schedule.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--loss_cyclical\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "help", "=", "\"Loss scaling parameters annealing monotonic schedule.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--loss_lambda\"", ",", "type", "=", "float", ",", "default", "=", "2", ",", "help", "=", "\"Lambda scaling parameter for loss.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--weight_decay\"", ",", "type", "=", "float", ",", "default", "=", "0.01", ",", "help", "=", "\"L2 coefficient for weight decay.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--warmup_pct\"", ",", "type", "=", "float", ",", "default", "=", "0.01", ",", "help", "=", "\"Percentage of 'train_iters' to be spent ramping learning rate up from 0.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--lr_decay_style\"", ",", "type", "=", "str", ",", "default", "=", "\"cosine\"", ",", "help", "=", "\"Decay style for the learning rate, after the warmup period.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--dont_shuffle\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Don't shuffle training and validation dataloaders.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--early_stop\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Does not predfine the number of epochs to run, but will instead stop when validation performance slows down or regresses.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--augment_loss_coef\"", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "\"Coefficient for negative contributions of mark intensities to be accounted for in loss. In enabled with zero_inflated then this will be used as observed values for the modeled bernoulli variables.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--augment_loss_surprise\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"If enabled w/ augment_loss_coef > 0, then the negative contributions will punish marks that have not been seen yet, otherwise marks that don't appear in the sequence as a whole will be punished.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.evaluation_args": [[74, 92], ["parser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument"], "function", ["None"], ["", "def", "evaluation_args", "(", "parser", ")", ":", "\n", "    ", "group", "=", "parser", ".", "add_argument_group", "(", "\"Evaluation specification arguments.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--valid_data_path\"", ",", "nargs", "=", "\"+\"", ",", "type", "=", "str", ",", "default", "=", "[", "\"./data/1_pp/validation.pickle\"", "]", ",", "help", "=", "\"Path to training data file.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--valid_epochs\"", ",", "type", "=", "int", ",", "default", "=", "5", ",", "help", "=", "\"Number of epochs to execute validation on.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--valid_to_test_pct\"", ",", "type", "=", "float", ",", "default", "=", "0.3", ",", "help", "=", "\"Percentage of held out data to be used for validation, rest is used for testing at the end.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--classify_latents\"", ",", "action", "=", "'store_true'", ",", "help", "=", "\"On validation, train a logistic regression model on latent vectors to classify PP id and report results.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--visualize\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"In evaluate.py selects the visualization script to run.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--sample_generations\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"In evaluate.py selects the generations script to run.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--next_event_prediction\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"In evaluate.py selects the next event prediction task to run.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--anomaly_detection\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"In evaluate.py selects the anomaly detection task to run.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--num_samples\"", ",", "type", "=", "int", ",", "default", "=", "1024", ",", "help", "=", "\"Number of sequences to generate samples from.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--samples_per_sequence\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"Number of samples to generate per sequence.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--get_latents\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Loads a model and saves latent states from the encoder.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--top_k\"", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "\"Enables top_k sampling for marks.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--top_p\"", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "\"Enables top_p sampling for marks.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--likelihood_over_time\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"In evaluate.py analyzes likelihood over time for a given model.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--likelihood_resolution\"", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "\"When likelihood_over_time is enabled, this defines the bucket width to bin likelihood differences into.\"", ")", "\n", "group", ".", "add_argument", "(", "\"--pin_test_memory\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Pin memory for test dataloader.\"", ")", "\n", "#group.add_argument(\"--\", type=, default=, help=\"\")pin_test_memory", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.sampling_args": [[94, 96], ["parser.add_argument_group"], "function", ["None"], ["", "def", "sampling_args", "(", "parser", ")", ":", "\n", "    ", "group", "=", "parser", ".", "add_argument_group", "(", "\"Sampling specification arguments.\"", ")", "\n", "#group.add_argument(\"--\", type=, default=, help=\"\")", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.print_args": [[98, 107], ["max", "sorted", "utils.print_log", "len", "args.items", "args.keys", "len"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log"], ["", "def", "print_args", "(", "args", ")", ":", "\n", "    ", "max_arg_len", "=", "max", "(", "len", "(", "k", ")", "for", "k", ",", "v", "in", "args", ".", "items", "(", ")", ")", "\n", "key_set", "=", "sorted", "(", "[", "k", "for", "k", "in", "args", ".", "keys", "(", ")", "]", ")", "\n", "for", "k", "in", "key_set", ":", "\n", "        ", "v", "=", "args", "[", "k", "]", "\n", "print_log", "(", "\"{} {} {}\"", ".", "format", "(", "\n", "k", ",", "\n", "\".\"", "*", "(", "max_arg_len", "+", "3", "-", "len", "(", "k", ")", ")", ",", "\n", "v", ",", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.get_args": [[109, 134], ["argparse.ArgumentParser", "arguments.general_args", "arguments.model_config_args", "arguments.training_args", "arguments.evaluation_args", "arguments.sampling_args", "argparse.ArgumentParser.parse_args", "arguments.print_args", "vars"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.general_args", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.model_config_args", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.training_args", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.evaluation_args", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.sampling_args", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.arguments.print_args"], ["", "", "def", "get_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "general_args", "(", "parser", ")", "\n", "model_config_args", "(", "parser", ")", "\n", "training_args", "(", "parser", ")", "\n", "evaluation_args", "(", "parser", ")", "\n", "sampling_args", "(", "parser", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "args", ".", "do_valid", "=", "args", ".", "valid_data_path", "!=", "\"\"", "\n", "args", ".", "shuffle", "=", "not", "args", ".", "dont_shuffle", "\n", "args", ".", "amortized", "=", "not", "args", ".", "not_amortized", "\n", "if", "args", ".", "s2s", ":", "\n", "        ", "args", ".", "loss_beta", "=", "0.0", "\n", "args", ".", "loss_monotonic", "=", "None", "\n", "args", ".", "loss_cyclical", "=", "None", "\n", "args", ".", "loss_lambda", "=", "0.0", "\n", "args", ".", "agg_noise", "=", "False", "\n", "\n", "", "if", "not", "args", ".", "dont_print_args", ":", "\n", "        ", "print_args", "(", "vars", "(", "args", ")", ")", "\n", "\n", "", "return", "args", "\n", "", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.forward_pass": [[29, 106], ["model", "model.augmented_log_likelihood", "model.log_likelihood", "vae_mpp.utils.kl_div().mean", "torch.zeros_like", "v.cuda", "torch.rand().clamp", "torch.cuda.current_device", "batch.items", "vae_mpp.utils.kl_div", "torch.rand"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.augmented_log_likelihood", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.log_likelihood", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.kl_div"], ["def", "forward_pass", "(", "args", ",", "batch", ",", "model", ",", "sample_timestamps", "=", "None", ",", "num_samples", "=", "150", ",", "get_raw_likelihoods", "=", "False", ")", ":", "\n", "    ", "if", "args", ".", "cuda", ":", "\n", "        ", "batch", "=", "{", "k", ":", "v", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", "}", "\n", "\n", "", "ref_marks", ",", "ref_timestamps", ",", "context_lengths", ",", "padding_mask", "=", "batch", "[", "\"ref_marks\"", "]", ",", "batch", "[", "\"ref_times\"", "]", ",", "batch", "[", "\"context_lengths\"", "]", ",", "batch", "[", "\"padding_mask\"", "]", "\n", "ref_marks_backwards", ",", "ref_timestamps_backwards", "=", "batch", "[", "\"ref_marks_backwards\"", "]", ",", "batch", "[", "\"ref_times_backwards\"", "]", "\n", "tgt_marks", ",", "tgt_timestamps", "=", "batch", "[", "\"tgt_marks\"", "]", ",", "batch", "[", "\"tgt_times\"", "]", "\n", "pp_id", "=", "batch", "[", "\"pp_id\"", "]", "\n", "\n", "T", "=", "batch", "[", "\"T\"", "]", "\n", "\n", "if", "sample_timestamps", "is", "None", ":", "\n", "        ", "sample_timestamps", "=", "torch", ".", "rand", "(", "\n", "tgt_timestamps", ".", "shape", "[", "0", "]", ",", "\n", "num_samples", ",", "\n", "dtype", "=", "tgt_timestamps", ".", "dtype", ",", "\n", "device", "=", "tgt_timestamps", ".", "device", "\n", ")", ".", "clamp", "(", "min", "=", "1e-8", ")", "*", "T", "# ~ U(0, T)", "\n", "\n", "# Forward Pass", "\n", "", "results", "=", "model", "(", "\n", "ref_marks", "=", "ref_marks", ",", "\n", "ref_timestamps", "=", "ref_timestamps", ",", "\n", "ref_marks_bwd", "=", "ref_marks_backwards", ",", "\n", "ref_timestamps_bwd", "=", "ref_timestamps_backwards", ",", "\n", "tgt_marks", "=", "tgt_marks", ",", "\n", "tgt_timestamps", "=", "tgt_timestamps", ",", "\n", "context_lengths", "=", "context_lengths", ",", "\n", "sample_timestamps", "=", "sample_timestamps", ",", "\n", "pp_id", "=", "pp_id", ",", "\n", ")", "\n", "\n", "# Calculate losses", "\n", "if", "args", ".", "augment_loss_coef", ">", "0.0", ":", "\n", "        ", "ll_results", "=", "model", ".", "augmented_log_likelihood", "(", "\n", "return_dict", "=", "results", ",", "\n", "right_window", "=", "T", ",", "\n", "augment_mask", "=", "batch", "[", "\"augment_mask\"", "]", ",", "\n", "augment_coef", "=", "args", ".", "augment_loss_coef", ",", "\n", "left_window", "=", "0.0", ",", "\n", "mask", "=", "padding_mask", ",", "\n", "reduce", "=", "not", "get_raw_likelihoods", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "ll_results", "=", "model", ".", "log_likelihood", "(", "\n", "return_dict", "=", "results", ",", "\n", "right_window", "=", "T", ",", "\n", "left_window", "=", "0.0", ",", "\n", "mask", "=", "padding_mask", ",", "\n", "reduce", "=", "not", "get_raw_likelihoods", ",", "\n", ")", "\n", "\n", "\n", "", "if", "get_raw_likelihoods", ":", "\n", "        ", "return", "ll_results", ",", "sample_timestamps", ",", "tgt_timestamps", "\n", "\n", "", "augmented_log_likelihood", ",", "log_likelihood", ",", "ll_pos_contrib", ",", "ll_neg_contrib", "=", "ll_results", "[", "\"augmented_log_likelihood\"", "]", ",", "ll_results", "[", "\"log_likelihood\"", "]", ",", "ll_results", "[", "\"positive_contribution\"", "]", ",", "ll_results", "[", "\"negative_contribution\"", "]", "\n", "\n", "if", "args", ".", "agg_noise", "and", "args", ".", "use_encoder", ":", "\n", "        ", "kl_term", "=", "kl_div", "(", "results", "[", "\"q_z_x\"", "]", ",", "results", "[", "\"p_z\"", "]", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "        ", "kl_term", "=", "torch", ".", "zeros_like", "(", "log_likelihood", ")", "\n", "\n", "#objective = log_likelihood - (args.loss_beta * kl_term) #- (args.loss_lambda * mmd_term)", "\n", "", "objective", "=", "augmented_log_likelihood", "-", "(", "args", ".", "loss_beta", "*", "kl_term", ")", "#- (args.loss_lambda * mmd_term)", "\n", "loss", "=", "-", "1", "*", "objective", "# minimize loss, maximize objective", "\n", "\n", "return", "{", "\n", "\"loss\"", ":", "loss", ",", "\n", "\"augmented_log_likelihood\"", ":", "augmented_log_likelihood", ",", "\n", "\"log_likelihood\"", ":", "log_likelihood", ",", "\n", "\"ll_pos\"", ":", "ll_pos_contrib", ",", "\n", "\"ll_neg\"", ":", "ll_neg_contrib", ",", "\n", "\"kl_divergence\"", ":", "kl_term", ",", "\n", "}", ",", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.backward_pass": [[107, 121], ["optimizer.zero_grad", "torch.isnan().any().item", "loss.backward", "torch.nn.utils.clip_grad_norm_", "torch.isnan().any", "model.parameters", "torch.isnan"], "function", ["None"], ["", "def", "backward_pass", "(", "args", ",", "loss", ",", "model", ",", "optimizer", ")", ":", "\n", "\n", "    ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# TODO: Support different backwards passes for fp16", "\n", "if", "torch", ".", "isnan", "(", "loss", ")", ".", "any", "(", ")", ".", "item", "(", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "loss", ".", "backward", "(", ")", "\n", "\n", "# TODO: If using data parallel, need to perform a reduce operation", "\n", "# TODO: Update master gradients if using fp16", "\n", "clip_grad", "(", "parameters", "=", "model", ".", "parameters", "(", ")", ",", "max_norm", "=", "args", ".", "grad_clip", ",", "norm_type", "=", "2", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.train_step": [[122, 145], ["train.forward_pass", "train.backward_pass", "optimizer.step", "lr_scheduler.step", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "input", "torch.isnan().any().item", "v.min().item", "v.max().item", "loss_results.items", "isinstance", "torch.isnan().any().item", "v.min().item", "v.max().item", "batch.items", "isinstance", "torch.isnan().any().item", "v.min().item", "v.max().item", "forward_results[].items", "torch.isnan().any().item", "v.min().item", "v.max().item", "forward_results[].items", "torch.isnan().any().item", "v.min().item", "v.max().item", "forward_results[].items", "torch.isnan().any", "v.min", "v.max", "torch.isnan().any", "v.min", "v.max", "torch.isnan().any", "v.min", "v.max", "torch.isnan().any", "v.min", "v.max", "torch.isnan().any", "v.min", "v.max", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.forward_pass", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.backward_pass", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.step", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.step", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log"], ["", "", "def", "train_step", "(", "args", ",", "model", ",", "optimizer", ",", "lr_scheduler", ",", "batch", ")", ":", "\n", "\n", "    ", "loss_results", ",", "forward_results", "=", "forward_pass", "(", "args", ",", "batch", ",", "model", ")", "\n", "\n", "if", "backward_pass", "(", "args", ",", "loss_results", "[", "\"loss\"", "]", ",", "model", ",", "optimizer", ")", ":", "\n", "        ", "optimizer", ".", "step", "(", ")", "\n", "lr_scheduler", ".", "step", "(", ")", "\n", "", "else", ":", "\n", "        ", "print_log", "(", "'======= NAN-Loss ======='", ")", "\n", "print_log", "(", "\"Loss Results:\"", ",", "{", "k", ":", "(", "torch", ".", "isnan", "(", "v", ")", ".", "any", "(", ")", ".", "item", "(", ")", ",", "v", ".", "min", "(", ")", ".", "item", "(", ")", ",", "v", ".", "max", "(", ")", ".", "item", "(", ")", ")", "for", "k", ",", "v", "in", "loss_results", ".", "items", "(", ")", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", "}", ")", "\n", "print_log", "(", "\"Loss Results:\"", ",", "loss_results", ")", "\n", "print_log", "(", "\"\"", ")", "\n", "print_log", "(", "\"Batch:\"", ",", "{", "k", ":", "(", "torch", ".", "isnan", "(", "v", ")", ".", "any", "(", ")", ".", "item", "(", ")", ",", "v", ".", "min", "(", ")", ".", "item", "(", ")", ",", "v", ".", "max", "(", ")", ".", "item", "(", ")", ")", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", "}", ")", "\n", "print_log", "(", "\"Batch:\"", ",", "batch", ")", "\n", "print_log", "(", "\"\"", ")", "\n", "print_log", "(", "\"Results:\"", ",", "{", "k", ":", "(", "torch", ".", "isnan", "(", "v", ")", ".", "any", "(", ")", ".", "item", "(", ")", ",", "v", ".", "min", "(", ")", ".", "item", "(", ")", ",", "v", ".", "max", "(", ")", ".", "item", "(", ")", ")", "for", "k", ",", "v", "in", "forward_results", "[", "\"state_dict\"", "]", ".", "items", "(", ")", "}", ")", "\n", "print_log", "(", "\"Results:\"", ",", "{", "k", ":", "(", "torch", ".", "isnan", "(", "v", ")", ".", "any", "(", ")", ".", "item", "(", ")", ",", "v", ".", "min", "(", ")", ".", "item", "(", ")", ",", "v", ".", "max", "(", ")", ".", "item", "(", ")", ")", "for", "k", ",", "v", "in", "forward_results", "[", "\"tgt_intensities\"", "]", ".", "items", "(", ")", "}", ")", "\n", "print_log", "(", "\"Results:\"", ",", "{", "k", ":", "(", "torch", ".", "isnan", "(", "v", ")", ".", "any", "(", ")", ".", "item", "(", ")", ",", "v", ".", "min", "(", ")", ".", "item", "(", ")", ",", "v", ".", "max", "(", ")", ".", "item", "(", ")", ")", "for", "k", ",", "v", "in", "forward_results", "[", "\"sample_intensities\"", "]", ".", "items", "(", ")", "}", ")", "\n", "print_log", "(", "\"Results:\"", ",", "forward_results", ")", "\n", "print_log", "(", "\"========================\"", ")", "\n", "input", "(", ")", "\n", "\n", "", "return", "loss_results", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.train_epoch": [[146, 169], ["model.train", "collections.defaultdict", "len", "enumerate", "train.train_step", "train_step.items", "items_to_print.extend", "items_to_print.extend", "train.print_results", "v.item", "items_to_print.extend", "items_to_print.extend", "train.print_results", "collections.defaultdict", "collections.defaultdict.items", "lr_scheduler.get_lr", "lr_scheduler.get_lr", "collections.defaultdict.items", "collections.defaultdict.items"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.train_step", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.print_results", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.print_results", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.get_lr", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.get_lr"], ["", "def", "train_epoch", "(", "args", ",", "model", ",", "optimizer", ",", "lr_scheduler", ",", "dataloader", ",", "epoch_number", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "\n", "total_losses", "=", "defaultdict", "(", "lambda", ":", "0.0", ")", "\n", "data_len", "=", "len", "(", "dataloader", ")", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "        ", "batch_loss", "=", "train_step", "(", "args", ",", "model", ",", "optimizer", ",", "lr_scheduler", ",", "batch", ")", "\n", "for", "k", ",", "v", "in", "batch_loss", ".", "items", "(", ")", ":", "\n", "            ", "total_losses", "[", "k", "]", "+=", "v", ".", "item", "(", ")", "\n", "", "if", "(", "(", "i", "+", "1", ")", "%", "args", ".", "log_interval", "==", "0", ")", "or", "(", "(", "i", "+", "1", "<=", "5", ")", "and", "(", "epoch_number", "<=", "1", ")", ")", ":", "\n", "            ", "items_to_print", "=", "[", "(", "\"LR\"", ",", "lr_scheduler", ".", "get_lr", "(", ")", ")", "]", "\n", "items_to_print", ".", "extend", "(", "[", "(", "k", ",", "v", "/", "args", ".", "log_interval", ")", "for", "k", ",", "v", "in", "total_losses", ".", "items", "(", ")", "]", ")", "\n", "items_to_print", ".", "extend", "(", "[", "(", "\"beta\"", ",", "args", ".", "loss_beta", ")", ",", "(", "\"lambda\"", ",", "args", ".", "loss_lambda", ")", "]", ")", "\n", "print_results", "(", "args", ",", "items_to_print", ",", "epoch_number", ",", "i", "+", "1", ",", "data_len", ",", "True", ")", "\n", "total_losses", "=", "defaultdict", "(", "lambda", ":", "0.0", ")", "\n", "\n", "", "", "if", "(", "i", "+", "1", ")", "%", "args", ".", "log_interval", "!=", "0", ":", "\n", "        ", "items_to_print", "=", "[", "(", "\"LR\"", ",", "lr_scheduler", ".", "get_lr", "(", ")", ")", "]", "\n", "items_to_print", ".", "extend", "(", "[", "(", "k", ",", "v", "/", "(", "i", "%", "args", ".", "log_interval", ")", ")", "for", "k", ",", "v", "in", "total_losses", ".", "items", "(", ")", "]", ")", "\n", "items_to_print", ".", "extend", "(", "[", "(", "\"beta\"", ",", "args", ".", "loss_beta", ")", ",", "(", "\"lambda\"", ",", "args", ".", "loss_lambda", ")", "]", ")", "\n", "print_results", "(", "args", ",", "items_to_print", ",", "epoch_number", ",", "i", "+", "1", ",", "data_len", ",", "True", ")", "\n", "\n", "", "return", "{", "k", ":", "v", "/", "data_len", "for", "k", ",", "v", "in", "total_losses", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.eval_step": [[170, 172], ["train.forward_pass"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.forward_pass"], ["", "def", "eval_step", "(", "args", ",", "model", ",", "batch", ",", "num_samples", "=", "150", ")", ":", "\n", "    ", "return", "forward_pass", "(", "args", ",", "batch", ",", "model", ",", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.eval_epoch": [[173, 224], ["model.eval", "train.print_results", "torch.no_grad", "collections.defaultdict", "len", "enumerate", "torch.cat().squeeze().numpy", "torch.cat().squeeze().numpy", "torch.cat().squeeze().numpy", "torch.cat().squeeze().numpy", "sklearn.linear_model.LogisticRegression().fit", "numpy.unique", "numpy.unique", "vae_mpp.utils.print_log", "train.eval_step", "batch_loss.items", "torch.no_grad", "LogisticRegression().fit.score", "LogisticRegression().fit.score", "t_counts.max", "len", "len", "collections.defaultdict.items", "torch.cat().squeeze().numpy.append", "torch.cat().squeeze().numpy.append", "v.item", "collections.defaultdict.items", "train.eval_step", "torch.cat().squeeze().numpy.append", "torch.cat().squeeze().numpy.append", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "sklearn.linear_model.LogisticRegression", "t_counts.argmax", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "numpy.where"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.print_results", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.eval_step", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.eval_step"], ["", "def", "eval_epoch", "(", "args", ",", "model", ",", "eval_dataloader", ",", "train_dataloader", ",", "epoch_number", ",", "num_samples", "=", "150", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "total_losses", "=", "defaultdict", "(", "lambda", ":", "0.0", ")", "\n", "data_len", "=", "len", "(", "eval_dataloader", ")", "\n", "valid_latents", ",", "valid_labels", "=", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "eval_dataloader", ")", ":", "\n", "            ", "batch_loss", ",", "results", "=", "eval_step", "(", "args", ",", "model", ",", "batch", ",", "num_samples", ")", "\n", "if", "args", ".", "classify_latents", ":", "\n", "                ", "valid_latents", ".", "append", "(", "results", "[", "\"latent_state_dict\"", "]", "[", "\"latent_state\"", "]", ")", "\n", "valid_labels", ".", "append", "(", "batch", "[", "\"pp_id\"", "]", ")", "\n", "", "for", "k", ",", "v", "in", "batch_loss", ".", "items", "(", ")", ":", "\n", "                ", "total_losses", "[", "k", "]", "+=", "v", ".", "item", "(", ")", "\n", "\n", "", "", "", "print_results", "(", "args", ",", "[", "(", "k", ",", "v", "/", "data_len", ")", "for", "k", ",", "v", "in", "total_losses", ".", "items", "(", ")", "]", ",", "epoch_number", ",", "i", "+", "1", ",", "data_len", ",", "False", ")", "\n", "\n", "if", "args", ".", "classify_latents", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "train_latents", ",", "train_labels", "=", "[", "]", ",", "[", "]", "\n", "for", "batch", "in", "train_dataloader", ":", "\n", "                ", "_", ",", "results", "=", "eval_step", "(", "args", ",", "model", ",", "batch", ")", "\n", "train_latents", ".", "append", "(", "results", "[", "\"latent_state_dict\"", "]", "[", "\"latent_state\"", "]", ")", "\n", "train_labels", ".", "append", "(", "batch", "[", "\"pp_id\"", "]", ")", "\n", "\n", "", "", "train_latents", "=", "torch", ".", "cat", "(", "train_latents", ",", "dim", "=", "0", ")", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", "\n", "train_labels", "=", "torch", ".", "cat", "(", "train_labels", ",", "dim", "=", "0", ")", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", "\n", "valid_latents", "=", "torch", ".", "cat", "(", "valid_latents", ",", "dim", "=", "0", ")", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", "\n", "valid_labels", "=", "torch", ".", "cat", "(", "valid_labels", ",", "dim", "=", "0", ")", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", "\n", "clf", "=", "LogisticRegression", "(", "\n", "random_state", "=", "args", ".", "seed", ",", "\n", "solver", "=", "\"liblinear\"", ",", "\n", "multi_class", "=", "\"auto\"", ",", "\n", ")", ".", "fit", "(", "train_latents", ",", "train_labels", ")", "\n", "\n", "train_acc", ",", "valid_acc", "=", "clf", ".", "score", "(", "train_latents", ",", "train_labels", ")", ",", "clf", ".", "score", "(", "valid_latents", ",", "valid_labels", ")", "\n", "\n", "t_vals", ",", "t_counts", "=", "np", ".", "unique", "(", "train_labels", ",", "return_counts", "=", "True", ")", "\n", "t_most_freq_val", ",", "t_most_freq_count", "=", "t_vals", "[", "t_counts", ".", "argmax", "(", ")", "]", ",", "t_counts", ".", "max", "(", ")", "\n", "naive_train_acc", "=", "t_most_freq_count", "/", "len", "(", "train_labels", ")", "\n", "\n", "v_vals", ",", "v_counts", "=", "np", ".", "unique", "(", "valid_labels", ",", "return_counts", "=", "True", ")", "\n", "v_most_freq_count", "=", "v_counts", "[", "np", ".", "where", "(", "v_vals", "==", "t_most_freq_val", ")", "[", "0", "]", "[", "0", "]", "]", "\n", "naive_valid_acc", "=", "v_most_freq_count", "/", "len", "(", "valid_labels", ")", "\n", "\n", "print_log", "(", "\"[C] Epoch {}/{} | Train Acc {:.4E} | Valid Acc {:.4E} | (N) Train Acc {:.4E} | (N) Valid Acc {:.4E}\"", ".", "format", "(", "\n", "epoch_number", ",", "args", ".", "train_epochs", ",", "\n", "train_acc", ",", "valid_acc", ",", "\n", "naive_train_acc", ",", "naive_valid_acc", ",", "\n", ")", ")", "\n", "", "return", "{", "k", ":", "v", "/", "data_len", "for", "k", ",", "v", "in", "total_losses", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.print_results": [[225, 229], ["vae_mpp.utils.print_log"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log"], ["", "def", "print_results", "(", "args", ",", "items", ",", "epoch_number", ",", "iteration", ",", "data_len", ",", "training", "=", "True", ")", ":", "\n", "    ", "msg", "=", "\"[{}] Epoch {}/{} | Iter {}/{} | \"", ".", "format", "(", "\"T\"", "if", "training", "else", "\"V\"", ",", "epoch_number", ",", "args", ".", "train_epochs", ",", "iteration", ",", "data_len", ")", "\n", "msg", "+=", "\"\"", ".", "join", "(", "\"{} {:.4E} | \"", ".", "format", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "items", ")", "\n", "print_log", "(", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.set_random_seed": [[230, 239], ["random.seed", "numpy.random.seed", "torch.manual_seed"], "function", ["None"], ["", "def", "set_random_seed", "(", "args", ")", ":", "\n", "    ", "\"\"\"Set random seed for reproducibility.\"\"\"", "\n", "\n", "seed", "=", "args", ".", "seed", "\n", "\n", "if", "seed", "is", "not", "None", "and", "seed", ">", "0", ":", "\n", "        ", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.setup_model_and_optim": [[240, 282], ["vae_mpp.models.get_model", "vae_mpp.optim.get_optimizer", "vae_mpp.optim.get_lr_scheduler", "print", "torch.cuda.set_device", "vae_mpp.models.get_model.cuda", "torch.cuda.current_device"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.__init__.get_model", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.get_optimizer", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.get_lr_scheduler"], ["", "", "def", "setup_model_and_optim", "(", "args", ",", "epoch_len", ")", ":", "\n", "    ", "model", "=", "get_model", "(", "\n", "time_embedding_size", "=", "args", ".", "time_embedding_size", ",", "\n", "use_raw_time", "=", "args", ".", "use_raw_time", ",", "\n", "use_delta_time", "=", "args", ".", "use_delta_time", ",", "\n", "max_period", "=", "args", ".", "max_period", ",", "\n", "channel_embedding_size", "=", "args", ".", "channel_embedding_size", ",", "\n", "num_channels", "=", "args", ".", "num_channels", ",", "\n", "enc_hidden_size", "=", "args", ".", "enc_hidden_size", ",", "\n", "enc_bidirectional", "=", "args", ".", "enc_bidirectional", ",", "\n", "enc_num_recurrent_layers", "=", "args", ".", "enc_num_recurrent_layers", ",", "\n", "latent_size", "=", "args", ".", "latent_size", ",", "\n", "agg_method", "=", "args", ".", "agg_method", ",", "\n", "agg_noise", "=", "args", ".", "agg_noise", ",", "\n", "use_encoder", "=", "args", ".", "use_encoder", ",", "\n", "dec_recurrent_hidden_size", "=", "args", ".", "dec_recurrent_hidden_size", ",", "\n", "dec_num_recurrent_layers", "=", "args", ".", "dec_num_recurrent_layers", ",", "\n", "dec_intensity_hidden_size", "=", "args", ".", "dec_intensity_hidden_size", ",", "\n", "dec_intensity_factored_heads", "=", "args", ".", "dec_intensity_factored_heads", ",", "\n", "dec_num_intensity_layers", "=", "args", ".", "dec_num_intensity_layers", ",", "\n", "dec_intensity_use_embeddings", "=", "args", ".", "dec_intensity_use_embeddings", ",", "\n", "dec_act_func", "=", "args", ".", "dec_act_func", ",", "\n", "dropout", "=", "args", ".", "dropout", ",", "\n", "amortized", "=", "args", ".", "amortized", ",", "\n", "hawkes", "=", "args", ".", "use_hawkes", ",", "\n", "hawkes_bounded", "=", "args", ".", "hawkes_bounded", ",", "\n", "neural_hawkes", "=", "args", ".", "neural_hawkes", ",", "\n", "rmtpp", "=", "args", ".", "rmtpp", ",", "\n", "normal_dist", "=", "args", ".", "normal_dist", ",", "\n", "zero_inflated", "=", "args", ".", "zero_inflated", ",", "\n", "personalized_head", "=", "args", ".", "personalized_head", ",", "\n", ")", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "        ", "print", "(", "f\"USING GPU {args.device_num}\"", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "args", ".", "device_num", ")", "\n", "model", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "\n", "", "optimizer", "=", "get_optimizer", "(", "model", ",", "args", ")", "\n", "lr_scheduler", "=", "get_lr_scheduler", "(", "optimizer", ",", "args", ",", "epoch_len", ")", "\n", "\n", "return", "model", ",", "optimizer", ",", "lr_scheduler", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.get_data": [[283, 349], ["vae_mpp.data.PointPatternDataset", "torch.utils.data.DataLoader", "vae_mpp.utils.print_log", "vae_mpp.data.PointPatternDataset.get_max_T", "vae_mpp.data.PointPatternDataset", "torch.utils.data.DataLoader", "vae_mpp.utils.print_log", "vae_mpp.data.PointPatternDataset", "torch.utils.data.DataLoader", "vae_mpp.utils.print_log", "len", "len", "vae_mpp.data.pad_and_combine_instances", "len", "len", "len", "len", "vae_mpp.data.pad_and_combine_instances", "vae_mpp.data.pad_and_combine_instances"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.PointPatternDataset.get_max_T", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.pad_and_combine_instances", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.pad_and_combine_instances", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.pad_and_combine_instances"], ["", "def", "get_data", "(", "args", ")", ":", "\n", "    ", "train_dataset", "=", "PointPatternDataset", "(", "\n", "file_path", "=", "args", ".", "train_data_path", ",", "\n", "args", "=", "args", ",", "\n", "keep_pct", "=", "args", ".", "train_data_percentage", ",", "\n", "set_dominating_rate", "=", "args", ".", "sample_generations", ",", "\n", "is_test", "=", "False", ",", "\n", ")", "\n", "args", ".", "num_channels", "=", "train_dataset", ".", "vocab_size", "\n", "\n", "train_dataloader", "=", "DataLoader", "(", "\n", "dataset", "=", "train_dataset", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "shuffle", "=", "args", ".", "shuffle", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "collate_fn", "=", "lambda", "x", ":", "pad_and_combine_instances", "(", "x", ",", "train_dataset", ".", "max_period", ")", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "\n", "args", ".", "max_period", "=", "train_dataset", ".", "get_max_T", "(", ")", "/", "2.0", "\n", "\n", "print_log", "(", "\"Loaded {} / {} training examples / batches from {}\"", ".", "format", "(", "len", "(", "train_dataset", ")", ",", "len", "(", "train_dataloader", ")", ",", "args", ".", "train_data_path", ")", ")", "\n", "\n", "if", "args", ".", "do_valid", ":", "\n", "        ", "valid_dataset", "=", "PointPatternDataset", "(", "\n", "file_path", "=", "args", ".", "valid_data_path", ",", "\n", "args", "=", "args", ",", "\n", "keep_pct", "=", "args", ".", "valid_to_test_pct", ",", "\n", "set_dominating_rate", "=", "False", ",", "\n", "is_test", "=", "False", ",", "\n", ")", "\n", "\n", "valid_dataloader", "=", "DataLoader", "(", "\n", "dataset", "=", "valid_dataset", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "shuffle", "=", "args", ".", "shuffle", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "collate_fn", "=", "lambda", "x", ":", "pad_and_combine_instances", "(", "x", ",", "valid_dataset", ".", "max_period", ")", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "print_log", "(", "\"Loaded {} / {} validation examples / batches from {}\"", ".", "format", "(", "len", "(", "valid_dataset", ")", ",", "len", "(", "valid_dataloader", ")", ",", "args", ".", "valid_data_path", ")", ")", "\n", "\n", "test_dataset", "=", "PointPatternDataset", "(", "\n", "file_path", "=", "args", ".", "valid_data_path", ",", "\n", "args", "=", "args", ",", "\n", "keep_pct", "=", "args", ".", "valid_to_test_pct", ",", "# object accounts for the test set having (1 - valid_to_test_pct) amount", "\n", "set_dominating_rate", "=", "False", ",", "\n", "is_test", "=", "True", ",", "\n", ")", "\n", "\n", "test_dataloader", "=", "DataLoader", "(", "\n", "dataset", "=", "test_dataset", ",", "\n", "batch_size", "=", "args", ".", "batch_size", "//", "4", ",", "\n", "shuffle", "=", "args", ".", "shuffle", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "collate_fn", "=", "lambda", "x", ":", "pad_and_combine_instances", "(", "x", ",", "test_dataset", ".", "max_period", ")", ",", "\n", "drop_last", "=", "True", ",", "\n", "pin_memory", "=", "args", ".", "pin_test_memory", ",", "\n", ")", "\n", "print_log", "(", "\"Loaded {} / {} test examples / batches from {}\"", ".", "format", "(", "len", "(", "test_dataset", ")", ",", "len", "(", "test_dataloader", ")", ",", "args", ".", "valid_data_path", ")", ")", "\n", "", "else", ":", "\n", "        ", "valid_dataloader", "=", "None", "\n", "test_dataloader", "=", "None", "\n", "\n", "\n", "", "return", "train_dataloader", ",", "valid_dataloader", ",", "test_dataloader", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.save_checkpoint": [[350, 366], ["folder_path.split", "range", "os.path.exists", "torch.save", "vae_mpp.utils.print_log", "len", "folder_path.rstrip", "os.remove", "model.state_dict", "os.path.exists", "os.mkdir"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.state_dict"], ["", "def", "save_checkpoint", "(", "args", ",", "model", ",", "optimizer", ",", "lr_scheduler", ",", "epoch", ")", ":", "\n", "# Create folder if not already created", "\n", "    ", "folder_path", "=", "args", ".", "checkpoint_path", "\n", "folders", "=", "folder_path", ".", "split", "(", "\"/\"", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "folders", ")", ")", ":", "\n", "        ", "if", "folders", "[", "i", "]", "==", "\"\"", ":", "\n", "            ", "continue", "\n", "", "intermediate_path", "=", "\"/\"", ".", "join", "(", "folders", "[", ":", "i", "+", "1", "]", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "intermediate_path", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "intermediate_path", ")", "\n", "\n", "", "", "final_path", "=", "\"{}/model_{:03d}.pt\"", ".", "format", "(", "folder_path", ".", "rstrip", "(", "\"/\"", ")", ",", "epoch", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "final_path", ")", ":", "\n", "        ", "os", ".", "remove", "(", "final_path", ")", "\n", "", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "final_path", ")", "\n", "print_log", "(", "\"Saved model at {}\"", ".", "format", "(", "final_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.load_checkpoint": [[367, 391], ["vae_mpp.utils.print_log", "model.load_state_dict", "vae_mpp.utils.print_log", "os.path.exists", "vae_mpp.utils.print_log", "len", "vae_mpp.utils.print_log", "sorted", "folder_path.rstrip", "os.path.exists", "vae_mpp.utils.print_log", "torch.load", "model.cuda", "int", "os.listdir", "torch.cuda.current_device", "latest_model.replace().replace", "latest_model.replace"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.load_state_dict", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log"], ["", "def", "load_checkpoint", "(", "args", ",", "model", ")", ":", "\n", "    ", "folder_path", "=", "args", ".", "checkpoint_path", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "folder_path", ")", ":", "\n", "        ", "print_log", "(", "f\"Checkpoint path [{folder_path}] does not exist.\"", ")", "\n", "return", "0", "\n", "\n", "", "print_log", "(", "f\"Checkpoint path [{folder_path}] does exist.\"", ")", "\n", "files", "=", "[", "f", "for", "f", "in", "os", ".", "listdir", "(", "folder_path", ")", "if", "\".pt\"", "in", "f", "]", "\n", "if", "len", "(", "files", ")", "==", "0", ":", "\n", "        ", "print_log", "(", "\"No .pt files found in checkpoint path.\"", ")", "\n", "return", "0", "\n", "\n", "", "latest_model", "=", "sorted", "(", "files", ")", "[", "-", "1", "]", "\n", "file_path", "=", "\"{}/{}\"", ".", "format", "(", "folder_path", ".", "rstrip", "(", "\"/\"", ")", ",", "latest_model", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "file_path", ")", ":", "\n", "        ", "print_log", "(", "f\"File [{file_path}] not found.\"", ")", "\n", "return", "0", "\n", "\n", "", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "file_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "        ", "model", ".", "cuda", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "", "print_log", "(", "\"Loaded model from {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "return", "int", "(", "latest_model", ".", "replace", "(", "\"model_\"", ",", "\"\"", ")", ".", "replace", "(", "\".pt\"", ",", "\"\"", ")", ")", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.report_model_stats": [[392, 413], ["model.named_parameters", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "vae_mpp.utils.print_log", "name.startswith", "param.numel", "param.numel", "name.startswith", "param.numel", "param.numel"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log"], ["", "def", "report_model_stats", "(", "model", ")", ":", "\n", "    ", "encoder_parameter_count", "=", "0", "\n", "aggregator_parameter_count", "=", "0", "\n", "decoder_parameter_count", "=", "0", "\n", "total", "=", "0", "\n", "for", "name", ",", "param", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "\"encoder\"", ")", ":", "\n", "            ", "encoder_parameter_count", "+=", "param", ".", "numel", "(", ")", "\n", "", "elif", "name", ".", "startswith", "(", "\"aggregator\"", ")", ":", "\n", "            ", "aggregator_parameter_count", "+=", "param", ".", "numel", "(", ")", "\n", "", "else", ":", "\n", "            ", "decoder_parameter_count", "+=", "param", ".", "numel", "(", ")", "\n", "", "total", "+=", "param", ".", "numel", "(", ")", "\n", "\n", "", "print_log", "(", ")", "\n", "print_log", "(", "\"<Parameter Counts>\"", ")", "\n", "print_log", "(", "\"Encoder........{}\"", ".", "format", "(", "encoder_parameter_count", ")", ")", "\n", "print_log", "(", "\"Aggregator.....{}\"", ".", "format", "(", "aggregator_parameter_count", ")", ")", "\n", "print_log", "(", "\"Decoder........{}\"", ".", "format", "(", "decoder_parameter_count", ")", ")", "\n", "print_log", "(", "\"---Total.......{}\"", ".", "format", "(", "total", ")", ")", "\n", "print_log", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.main": [[414, 478], ["vae_mpp.utils.print_log", "train.set_random_seed", "vae_mpp.utils.print_log", "train.get_data", "vae_mpp.utils.print_log", "train.setup_model_and_optim", "train.report_model_stats", "vae_mpp.utils.print_log", "torch.cuda.empty_cache", "len", "train.load_checkpoint", "float", "results[].append", "train.save_checkpoint", "range", "train.train_epoch", "train.eval_epoch", "results[].append", "train.save_checkpoint", "train.eval_epoch", "results[].append"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.set_random_seed", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.get_data", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.setup_model_and_optim", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.report_model_stats", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.load_checkpoint", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.save_checkpoint", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.train_epoch", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.eval_epoch", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.save_checkpoint", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.train.eval_epoch"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "print_log", "(", "\"Setting seed.\"", ")", "\n", "set_random_seed", "(", "args", ")", "\n", "\n", "print_log", "(", "\"Setting up dataloaders.\"", ")", "\n", "train_dataloader", ",", "valid_dataloader", ",", "test_dataloader", "=", "get_data", "(", "args", ")", "\n", "\n", "print_log", "(", "\"Setting up model, optimizer, and learning rate scheduler.\"", ")", "\n", "model", ",", "optimizer", ",", "lr_scheduler", "=", "setup_model_and_optim", "(", "args", ",", "len", "(", "train_dataloader", ")", ")", "\n", "\n", "report_model_stats", "(", "model", ")", "\n", "\n", "if", "args", ".", "finetune", ":", "\n", "        ", "epoch", "=", "load_checkpoint", "(", "args", ",", "model", ")", "\n", "", "else", ":", "\n", "        ", "epoch", "=", "0", "\n", "", "original_epoch", "=", "epoch", "\n", "\n", "print_log", "(", "\"Starting training.\"", ")", "\n", "results", "=", "{", "\"valid\"", ":", "[", "]", ",", "\"train\"", ":", "[", "]", ",", "\"test\"", ":", "[", "]", "}", "\n", "last_valid_ll", "=", "-", "float", "(", "'inf'", ")", "\n", "epsilon", "=", "0.03", "\n", "\n", "while", "epoch", "<", "args", ".", "train_epochs", "or", "args", ".", "early_stop", ":", "\n", "        ", "results", "[", "\"train\"", "]", ".", "append", "(", "train_epoch", "(", "args", ",", "model", ",", "optimizer", ",", "lr_scheduler", ",", "train_dataloader", ",", "epoch", "+", "1", ")", ")", "\n", "\n", "if", "args", ".", "do_valid", "and", "(", "(", "epoch", "+", "1", ")", "%", "args", ".", "valid_epochs", "==", "0", ")", ":", "\n", "            ", "new_valid", "=", "eval_epoch", "(", "args", ",", "model", ",", "valid_dataloader", ",", "train_dataloader", ",", "epoch", "+", "1", ")", "\n", "results", "[", "\"valid\"", "]", ".", "append", "(", "new_valid", ")", "\n", "if", "args", ".", "early_stop", ":", "\n", "                ", "if", "new_valid", "[", "\"log_likelihood\"", "]", "-", "last_valid_ll", "<", "epsilon", ":", "\n", "                    ", "break", "\n", "", "", "last_valid_ll", "=", "new_valid", "[", "\"log_likelihood\"", "]", "\n", "\n", "\n", "", "if", "(", "(", "epoch", "+", "1", ")", "%", "args", ".", "save_epochs", "==", "0", ")", ":", "\n", "            ", "save_checkpoint", "(", "args", ",", "model", ",", "optimizer", ",", "lr_scheduler", ",", "epoch", ")", "\n", "\n", "", "epoch", "+=", "1", "\n", "\n", "", "if", "args", ".", "save_epochs", ">", "0", "and", "original_epoch", "!=", "epoch", ":", "\n", "        ", "save_checkpoint", "(", "args", ",", "model", ",", "optimizer", ",", "lr_scheduler", ",", "epoch", ")", "\n", "\n", "", "if", "args", ".", "do_valid", ":", "\n", "        ", "overall_test_results", "=", "{", "}", "\n", "reps", "=", "5", "\n", "for", "_", "in", "range", "(", "reps", ")", ":", "\n", "            ", "test_results", "=", "eval_epoch", "(", "args", ",", "model", ",", "test_dataloader", ",", "train_dataloader", ",", "epoch", "+", "1", ",", "num_samples", "=", "500", ")", "\n", "# for k,v in test_results.items():", "\n", "#     if k not in overall_test_results:", "\n", "#         overall_test_results[k] = v / reps", "\n", "#     else:", "\n", "#         overall_test_results[k] += v / reps", "\n", "results", "[", "\"test\"", "]", ".", "append", "(", "test_results", ")", "#overall_test_results)", "\n", "\n", "", "", "del", "model", "\n", "del", "optimizer", "\n", "del", "lr_scheduler", "\n", "del", "train_dataloader", "\n", "del", "valid_dataloader", "\n", "del", "test_dataloader", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.PointPatternDataset.__init__": [[59, 124], ["isinstance", "os.path.isdir", "sorted", "print", "any", "data.PointPatternDataset.read_instances", "len", "print", "max", "len", "data.PointPatternDataset.read_instances", "data.PointPatternDataset._instances.extend", "max", "range", "os.listdir", "len", "len", "file_path[].rstrip", "max"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.PointPatternDataset.read_instances", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.PointPatternDataset.read_instances"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "file_path", ",", "\n", "args", ",", "\n", "keep_pct", ",", "\n", "set_dominating_rate", ",", "\n", "is_test", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Loads text file containing realizations of point processes.\n        Each line in the dataset corresponds to one realization.\n        Each line will contain a comma-delineated sequence of \"(t,k)\"\n        where \"t\" is the absolute time of the event and \"k\" is the associated mark.\n        As of writing this, \"t\" should be a floating point number, and \"k\" should be a non-negative integer.\n        The max value of \"k\" seen in the dataset determines the vocabulary size.\n        \"\"\"", "\n", "self", ".", "keep_pct", "=", "keep_pct", "\n", "self", ".", "max_channels", "=", "args", ".", "num_channels", "\n", "self", ".", "is_test", "=", "is_test", "\n", "\n", "if", "len", "(", "file_path", ")", "==", "1", "and", "os", ".", "path", ".", "isdir", "(", "file_path", "[", "0", "]", ")", ":", "\n", "            ", "file_path", "=", "[", "file_path", "[", "0", "]", ".", "rstrip", "(", "\"/\"", ")", "+", "\"/\"", "+", "fp", "for", "fp", "in", "os", ".", "listdir", "(", "file_path", "[", "0", "]", ")", "]", "\n", "file_path", "=", "sorted", "(", "file_path", ")", "\n", "print", "(", "file_path", ")", "\n", "\n", "", "self", ".", "user_mapping", "=", "{", "}", "\n", "self", ".", "user_id", "=", "{", "}", "\n", "if", "isinstance", "(", "file_path", ",", "list", ")", ":", "\n", "            ", "self", ".", "is_valid", "=", "any", "(", "[", "\"valid\"", "in", "fp", "for", "fp", "in", "file_path", "]", ")", "\n", "self", ".", "_instances", "=", "[", "]", "\n", "self", ".", "vocab_size", "=", "0", "\n", "for", "fp", "in", "file_path", ":", "\n", "                ", "instances", ",", "vocab_size", "=", "self", ".", "read_instances", "(", "fp", ")", "\n", "self", ".", "_instances", ".", "extend", "(", "instances", ")", "\n", "self", ".", "vocab_size", "=", "max", "(", "self", ".", "vocab_size", ",", "vocab_size", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "is_valid", "=", "\"valid\"", "in", "file_path", "\n", "self", ".", "_instances", ",", "self", ".", "vocab_size", "=", "self", ".", "read_instances", "(", "file_path", ")", "\n", "\n", "", "self", ".", "same_tgt_and_ref", "=", "args", ".", "same_tgt_and_ref", "\n", "\n", "self", ".", "do_augment", "=", "args", ".", "augment_loss_coef", ">", "0", "\n", "self", ".", "surprise_augment", "=", "args", ".", "augment_loss_surprise", "and", "self", ".", "do_augment", "\n", "\n", "# find a dominating rate for the dataset for the purposes of sampling", "\n", "if", "set_dominating_rate", ":", "\n", "            ", "max_rate", "=", "0", "\n", "avg_rate", "=", "0", "\n", "for", "instance", "in", "self", ".", "_instances", ":", "\n", "                ", "avg_rate", "+=", "len", "(", "instance", "[", "\"times\"", "]", ")", "/", "instance", "[", "\"T\"", "]", "\n", "for", "i", "in", "range", "(", "3", ",", "len", "(", "instance", "[", "\"times\"", "]", ")", ")", ":", "\n", "                    ", "diff", "=", "(", "instance", "[", "\"times\"", "]", "[", "i", "]", "-", "instance", "[", "\"times\"", "]", "[", "i", "-", "3", "]", ")", "\n", "if", "diff", ">", "0", ":", "\n", "                        ", "max_rate", "=", "max", "(", "max_rate", ",", "4", "/", "diff", ")", "\n", "", "", "", "avg_rate", "/=", "len", "(", "self", ".", "_instances", ")", "\n", "args", ".", "dominating_rate", "=", "50", "*", "avg_rate", "\n", "\n", "print", "(", "\"For Data Loaded, average rate {}, max rate {}, dominating rate {}\"", ".", "format", "(", "avg_rate", ",", "max_rate", ",", "args", ".", "dominating_rate", ")", ")", "\n", "\n", "", "max_period", "=", "0", "\n", "for", "instance", "in", "self", ".", "_instances", ":", "\n", "            ", "max_period", "=", "max", "(", "max_period", ",", "instance", "[", "\"T\"", "]", ")", "\n", "", "self", ".", "max_period", "=", "max_period", "\n", "args", ".", "max_seq_len", "=", "self", ".", "max_seq_len", "\n", "self", ".", "explicit_pairings", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.PointPatternDataset.__getitem__": [[125, 189], ["torch.LongTensor", "torch.nn.functional.one_hot", "torch.where", "torch.zeros.sum().unsqueeze", "torch.zeros", "torch.FloatTensor", "torch.LongTensor", "torch.FloatTensor", "torch.LongTensor", "torch.FloatTensor", "torch.ones", "torch.LongTensor", "torch.FloatTensor", "torch.BoolTensor", "torch.LongTensor", "torch.LongTensor", "expanded_marks.sum().expand_as.sum().expand_as.cumsum", "expanded_marks.sum().expand_as.sum().expand_as.sum().expand_as", "torch.ones_like", "torch.zeros_like", "print", "print", "input", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "len", "len", "torch.zeros.sum", "expanded_marks.sum().expand_as.sum().expand_as.sum", "len", "random.choice", "random.choice"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "tgt_instance", "=", "self", ".", "_instances", "[", "idx", "]", "\n", "\n", "tgt_times", ",", "tgt_marks", "=", "tgt_instance", "[", "\"times\"", "]", ",", "tgt_instance", "[", "\"marks\"", "]", "\n", "\n", "if", "self", ".", "same_tgt_and_ref", ":", "\n", "            ", "ref_times", ",", "ref_marks", "=", "tgt_times", ",", "tgt_marks", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "explicit_pairings", ":", "\n", "                ", "ref_instance", "=", "self", ".", "_ref_instances", "[", "idx", "]", "\n", "", "elif", "self", ".", "is_valid", ":", "\n", "                ", "ref_instance", "=", "self", ".", "_instances", "[", "random", ".", "choice", "(", "[", "ref_idx", "for", "ref_idx", "in", "self", ".", "user_mapping", "[", "tgt_instance", "[", "\"user\"", "]", "]", "if", "ref_idx", "!=", "idx", "]", ")", "]", "\n", "", "else", ":", "\n", "                ", "ref_instance", "=", "self", ".", "_instances", "[", "random", ".", "choice", "(", "self", ".", "user_mapping", "[", "tgt_instance", "[", "\"user\"", "]", "]", ")", "]", "\n", "", "ref_times", ",", "ref_marks", "=", "ref_instance", "[", "\"times\"", "]", ",", "ref_instance", "[", "\"marks\"", "]", "\n", "\n", "", "tgt_marks", "=", "torch", ".", "LongTensor", "(", "tgt_marks", ")", "\n", "\n", "if", "self", ".", "do_augment", ":", "\n", "            ", "expanded_marks", "=", "torch", ".", "nn", ".", "functional", ".", "one_hot", "(", "tgt_marks", ",", "num_classes", "=", "self", ".", "max_channels", ")", "\n", "if", "self", ".", "surprise_augment", ":", "\n", "                ", "expanded_marks", "=", "expanded_marks", ".", "cumsum", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "                ", "expanded_marks", "=", "expanded_marks", ".", "sum", "(", "dim", "=", "0", ")", ".", "expand_as", "(", "expanded_marks", ")", "\n", "", "augment_mask", "=", "torch", ".", "where", "(", "\n", "expanded_marks", "==", "0", ",", "\n", "torch", ".", "ones_like", "(", "expanded_marks", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "torch", ".", "zeros_like", "(", "expanded_marks", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", ")", "\n", "augment_mask_count", "=", "augment_mask", ".", "sum", "(", "dim", "=", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "if", "(", "augment_mask_count", "==", "0", ")", ".", "any", "(", ")", ".", "item", "(", ")", ":", "\n", "                ", "print", "(", "\"ZERO COUNT\"", ")", "\n", "print", "(", "augment_mask", ")", "\n", "input", "(", ")", "\n", "", "augment_mask", "=", "augment_mask", "/", "augment_mask_count", "\n", "", "else", ":", "\n", "            ", "augment_mask", "=", "torch", ".", "zeros", "(", "tgt_marks", ".", "shape", "[", "0", "]", ",", "self", ".", "max_channels", ")", "\n", "\n", "", "item", "=", "{", "\n", "'ref_times'", ":", "torch", ".", "FloatTensor", "(", "ref_times", ")", ",", "\n", "'ref_marks'", ":", "torch", ".", "LongTensor", "(", "ref_marks", ")", ",", "\n", "'ref_times_backwards'", ":", "torch", ".", "FloatTensor", "(", "np", ".", "ascontiguousarray", "(", "ref_times", "[", ":", ":", "-", "1", "]", ")", ")", ",", "\n", "'ref_marks_backwards'", ":", "torch", ".", "LongTensor", "(", "np", ".", "ascontiguousarray", "(", "ref_marks", "[", ":", ":", "-", "1", "]", ")", ")", ",", "\n", "'tgt_times'", ":", "torch", ".", "FloatTensor", "(", "tgt_times", ")", ",", "\n", "'tgt_marks'", ":", "tgt_marks", ",", "# made into a tensor for loss augmentation", "\n", "'padding_mask'", ":", "torch", ".", "ones", "(", "len", "(", "tgt_marks", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", ",", "\n", "'context_lengths'", ":", "torch", ".", "LongTensor", "(", "[", "len", "(", "ref_times", ")", "-", "1", "]", ")", ",", "# these will be used for indexing later, hence the subtracting 1", "\n", "'T'", ":", "torch", ".", "FloatTensor", "(", "[", "tgt_instance", "[", "\"T\"", "]", "]", ")", ",", "\n", "'augment_mask'", ":", "augment_mask", ",", "\n", "}", "\n", "\n", "if", "self", ".", "explicit_pairings", ":", "\n", "            ", "item", "[", "'same_source'", "]", "=", "torch", ".", "BoolTensor", "(", "[", "tgt_instance", "[", "\"user\"", "]", "==", "ref_instance", "[", "\"user\"", "]", "]", ")", "\n", "\n", "", "if", "\"pp_obj_id\"", "in", "tgt_instance", ":", "\n", "            ", "item", "[", "\"pp_id\"", "]", "=", "torch", ".", "LongTensor", "(", "[", "tgt_instance", "[", "\"pp_obj_id\"", "]", "]", ")", "\n", "\n", "", "if", "\"user\"", "in", "tgt_instance", ":", "\n", "#print(\"USER\", tgt_instance[\"user\"])", "\n", "            ", "if", "tgt_instance", "[", "\"user\"", "]", "not", "in", "self", ".", "user_id", ":", "\n", "                ", "self", ".", "user_id", "[", "tgt_instance", "[", "\"user\"", "]", "]", "=", "len", "(", "self", ".", "user_id", ")", "\n", "", "item", "[", "\"pp_id\"", "]", "=", "torch", ".", "LongTensor", "(", "[", "self", ".", "user_id", "[", "tgt_instance", "[", "\"user\"", "]", "]", "]", ")", "\n", "\n", "", "return", "item", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.PointPatternDataset.__len__": [[190, 192], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.PointPatternDataset.get_max_T": [[193, 195], ["max"], "methods", ["None"], ["", "def", "get_max_T", "(", "self", ")", ":", "\n", "        ", "return", "max", "(", "item", "[", "\"T\"", "]", "for", "item", "in", "self", ".", "_instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.PointPatternDataset.read_instances": [[196, 277], ["range", "range", "enumerate", "sorted", "print", "len", "max", "len", "sorted", "list", "random.Random().shuffle", "set", "print", "len", "sum", "len", "sorted", "open", "pickle.load", "list", "range", "sorted", "sorted", "len", "len", "len", "open", "open", "enumerate", "len", "max", "user_counts.items", "set", "len", "random.Random", "len", "data.PointPatternDataset.user_mapping[].append", "len", "len", "len", "len", "len", "len", "instances.append", "zip", "instances.append", "len", "len", "data.PointPatternDataset.user_mapping.items", "json.loads", "math.floor", "math.floor", "float", "int", "parse.findall", "line.strip", "len", "len"], "methods", ["None"], ["", "def", "read_instances", "(", "self", ",", "file_path", ")", ":", "\n", "        ", "\"\"\"Load PointProcessDataset from a file\"\"\"", "\n", "\n", "if", "\".pickle\"", "in", "file_path", ":", "\n", "            ", "with", "open", "(", "file_path", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "collection", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "instances", "=", "collection", "[", "\"sequences\"", "]", "\n", "for", "instance", "in", "instances", ":", "\n", "                ", "if", "\"T\"", "not", "in", "instance", ":", "\n", "                    ", "instance", "[", "\"T\"", "]", "=", "50.0", "\n", "", "", "", "elif", "\".json\"", "in", "file_path", ":", "\n", "            ", "instances", "=", "[", "]", "\n", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "for", "line", "in", "f", ":", "\n", "                    ", "instances", ".", "append", "(", "json", ".", "loads", "(", "line", ")", ")", "\n", "", "", "", "else", ":", "\n", "            ", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "instances", "=", "[", "]", "\n", "for", "line", "in", "f", ":", "\n", "                    ", "items", "=", "[", "(", "float", "(", "r", ".", "fixed", "[", "0", "]", ")", ",", "int", "(", "r", ".", "fixed", "[", "1", "]", ")", ")", "for", "r", "in", "findall", "(", "\"({},{})\"", ",", "line", ".", "strip", "(", ")", ")", "]", "\n", "times", ",", "marks", "=", "zip", "(", "*", "items", ")", "\n", "instances", ".", "append", "(", "{", "\n", "\"user\"", ":", "file_path", ",", "\n", "\"T\"", ":", "50.0", ",", "\n", "\"times\"", ":", "times", ",", "\n", "\"marks\"", ":", "marks", "\n", "}", ")", "\n", "", "", "", "for", "i", "in", "range", "(", "len", "(", "instances", ")", ")", ":", "\n", "            ", "instance", "=", "instances", "[", "i", "]", "\n", "keep_idx", "=", "[", "j", "for", "j", ",", "m", "in", "enumerate", "(", "instance", "[", "\"marks\"", "]", ")", "if", "m", "<", "self", ".", "max_channels", "]", "\n", "instance", "[", "\"times\"", "]", "=", "[", "instance", "[", "\"times\"", "]", "[", "j", "]", "for", "j", "in", "keep_idx", "]", "\n", "instance", "[", "\"marks\"", "]", "=", "[", "instance", "[", "\"marks\"", "]", "[", "j", "]", "for", "j", "in", "keep_idx", "]", "\n", "", "instances", "=", "[", "instance", "for", "instance", "in", "instances", "if", "len", "(", "instance", "[", "\"times\"", "]", ")", ">", "0", "]", "\n", "\n", "vocab_size", "=", "max", "(", "max", "(", "instance", "[", "\"marks\"", "]", ")", "for", "instance", "in", "instances", ")", "+", "1", "\n", "\n", "if", "self", ".", "is_valid", ":", "\n", "            ", "user_counts", "=", "{", "}", "\n", "for", "instance", "in", "instances", ":", "\n", "                ", "user", "=", "instance", "[", "\"user\"", "]", "\n", "if", "user", "in", "user_counts", ":", "\n", "                    ", "user_counts", "[", "user", "]", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "user_counts", "[", "user", "]", "=", "1", "\n", "", "", "user_counts", "=", "{", "k", "for", "k", ",", "v", "in", "user_counts", ".", "items", "(", ")", "if", "v", ">", "1", "}", "\n", "instances", "=", "[", "instance", "for", "instance", "in", "instances", "if", "instance", "[", "\"user\"", "]", "in", "user_counts", "]", "\n", "\n", "", "if", "self", ".", "keep_pct", "<", "1", ":", "\n", "            ", "old_len", "=", "len", "(", "instances", ")", "\n", "users", "=", "sorted", "(", "list", "(", "set", "(", "instance", "[", "\"user\"", "]", "for", "instance", "in", "instances", ")", ")", ")", "# sort to make future selection deterministic", "\n", "indices", "=", "list", "(", "range", "(", "len", "(", "users", ")", ")", ")", "\n", "random", ".", "Random", "(", "0", ")", ".", "shuffle", "(", "indices", ")", "# seeded shuffle", "\n", "if", "self", ".", "is_test", ":", "\n", "                ", "indices", "=", "sorted", "(", "indices", "[", "math", ".", "floor", "(", "len", "(", "users", ")", "*", "self", ".", "keep_pct", ")", ":", "]", ")", "\n", "", "else", ":", "\n", "                ", "indices", "=", "sorted", "(", "indices", "[", ":", "math", ".", "floor", "(", "len", "(", "users", ")", "*", "self", ".", "keep_pct", ")", "]", ")", "\n", "", "users", "=", "set", "(", "users", "[", "idx", "]", "for", "idx", "in", "indices", ")", "\n", "instances", "=", "[", "instance", "for", "instance", "in", "instances", "if", "instance", "[", "'user'", "]", "in", "users", "]", "\n", "print", "(", "\"Before filtering: {} | After filtering: {} | Prop: {} | Goal: {}\"", ".", "format", "(", "old_len", ",", "len", "(", "instances", ")", ",", "len", "(", "instances", ")", "/", "old_len", ",", "self", ".", "keep_pct", ")", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "instances", ")", ")", ":", "\n", "            ", "if", "instances", "[", "i", "]", "[", "\"times\"", "]", "[", "0", "]", "==", "0.0", ":", "\n", "                ", "instances", "[", "i", "]", "[", "\"times\"", "]", "[", "0", "]", "+=", "1e-8", "\n", "assert", "(", "(", "len", "(", "instances", "[", "i", "]", "[", "\"times\"", "]", ")", "==", "1", ")", "or", "(", "instances", "[", "i", "]", "[", "\"times\"", "]", "[", "0", "]", "<", "instances", "[", "i", "]", "[", "\"times\"", "]", "[", "1", "]", ")", ")", "\n", "\n", "", "", "for", "i", ",", "item", "in", "enumerate", "(", "instances", ")", ":", "\n", "            ", "if", "\"user\"", "in", "item", "and", "(", "item", "[", "\"user\"", "]", "not", "in", "self", ".", "user_mapping", ")", ":", "\n", "                ", "self", ".", "user_mapping", "[", "item", "[", "\"user\"", "]", "]", "=", "[", "i", "]", "\n", "", "elif", "\"user\"", "in", "item", ":", "\n", "                ", "self", ".", "user_mapping", "[", "item", "[", "\"user\"", "]", "]", ".", "append", "(", "i", ")", "\n", "\n", "", "", "lengths", "=", "sorted", "(", "[", "len", "(", "item", "[", "\"times\"", "]", ")", "for", "item", "in", "instances", "]", ")", "\n", "med_len", "=", "lengths", "[", "len", "(", "instances", ")", "//", "2", "]", "\n", "self", ".", "max_seq_len", "=", "lengths", "[", "-", "1", "]", "\n", "avg_len", "=", "sum", "(", "len", "(", "item", "[", "\"times\"", "]", ")", "for", "item", "in", "instances", ")", "/", "len", "(", "instances", ")", "\n", "med_su", "=", "sorted", "(", "[", "len", "(", "v", ")", "for", "k", ",", "v", "in", "self", ".", "user_mapping", ".", "items", "(", ")", "]", ")", "[", "len", "(", "self", ".", "user_mapping", ")", "//", "2", "]", "\n", "print", "(", "\"SEQS {} | USERS {} | Med S/U {} | Avg S/U {} | Med SEQ LEN {} | Avg SEQ LEN {}\"", ".", "format", "(", "\n", "len", "(", "instances", ")", ",", "len", "(", "self", ".", "user_mapping", ")", ",", "med_su", ",", "len", "(", "instances", ")", "/", "len", "(", "self", ".", "user_mapping", ")", ",", "med_len", ",", "avg_len", ",", "\n", ")", ")", "\n", "\n", "return", "instances", ",", "vocab_size", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.AnomalyDetectionDataset.__init__": [[283, 374], ["data.PointPatternDataset.__init__", "list", "random.Random().shuffle", "zip", "range", "len", "same_instances.append", "same_indices.append", "random.Random().choice", "good_ref_instances.append", "len", "len", "len", "random.Random().choice", "len", "random.Random", "len", "copy.deepcopy", "bad_ref_instances.append", "range", "range", "random.Random", "random.Random", "copy.deepcopy", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "file_path", ",", "\n", "args", ",", "\n", "max_tgt_seq_len", "=", "None", ",", "\n", "num_total_pairs", "=", "1000", ",", "\n", "test", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "file_path", "=", "file_path", ",", "\n", "args", "=", "args", ",", "\n", "keep_pct", "=", "args", ".", "valid_to_test_pct", ",", "\n", "set_dominating_rate", "=", "False", ",", "\n", "is_test", "=", "test", ",", "\n", ")", "\n", "\n", "self", ".", "explicit_pairings", "=", "True", "\n", "self", ".", "max_tgt_seq_len", "=", "max_tgt_seq_len", "\n", "\n", "self", ".", "anomaly_same_tgt_diff_refs", "=", "args", ".", "anomaly_same_tgt_diff_refs", "\n", "self", ".", "anomaly_truncate_tgts", "=", "args", ".", "anomaly_truncate_tgts", "\n", "self", ".", "anomaly_truncate_refs", "=", "args", ".", "anomaly_truncate_refs", "\n", "\n", "indices", "=", "list", "(", "range", "(", "len", "(", "self", ".", "_instances", ")", ")", ")", "\n", "random", ".", "Random", "(", "0", ")", ".", "shuffle", "(", "indices", ")", "\n", "# tgt_indices = indices[:num_total_pairs // 2]", "\n", "# tgt_instances = [self._instances[tgt_idx] for tgt_idx in tgt_indices]", "\n", "same_instances", ",", "same_indices", "=", "[", "]", ",", "[", "]", "\n", "i", "=", "-", "1", "\n", "while", "len", "(", "same_instances", ")", "<", "(", "num_total_pairs", "//", "2", ")", ":", "\n", "            ", "i", "+=", "1", "\n", "if", "i", ">=", "len", "(", "self", ".", "_instances", ")", ":", "\n", "                ", "break", "\n", "", "same_idx", "=", "indices", "[", "i", "]", "\n", "same_instance", "=", "self", ".", "_instances", "[", "same_idx", "]", "\n", "### This original code would make it so that if a sequence had less than max_tgt_seq_len", "\n", "### then it would be thrown out.", "\n", "### Without it, we will be taking partial sequences _up to_ max_tgt_seq_len instead of only", "\n", "### the max_tgt_seq_len.", "\n", "# if max_tgt_seq_len is not None:", "\n", "#     if len(tgt_instance[\"marks\"]) < max_tgt_seq_len:", "\n", "#         continue", "\n", "same_instances", ".", "append", "(", "same_instance", ")", "\n", "same_indices", ".", "append", "(", "same_idx", ")", "\n", "\n", "", "good_ref_instances", "=", "[", "]", "\n", "for", "same_instance", ",", "same_idx", "in", "zip", "(", "same_instances", ",", "same_indices", ")", ":", "\n", "            ", "choice_indices", "=", "[", "ref_idx", "for", "ref_idx", "in", "self", ".", "user_mapping", "[", "same_instance", "[", "\"user\"", "]", "]", "if", "ref_idx", "!=", "same_idx", "]", "\n", "ref_idx", "=", "random", ".", "Random", "(", "same_idx", ")", ".", "choice", "(", "choice_indices", ")", "\n", "good_ref_instances", ".", "append", "(", "deepcopy", "(", "self", ".", "_instances", "[", "ref_idx", "]", ")", ")", "\n", "\n", "", "bad_ref_instances", "=", "[", "]", "\n", "offset", "=", "0", "\n", "while", "len", "(", "bad_ref_instances", ")", "<", "len", "(", "good_ref_instances", ")", ":", "\n", "            ", "i", "=", "len", "(", "bad_ref_instances", ")", "\n", "same_instance", ",", "same_idx", "=", "same_instances", "[", "i", "]", ",", "same_indices", "[", "i", "]", "\n", "random_idx", "=", "random", ".", "Random", "(", "same_idx", "+", "offset", ")", ".", "choice", "(", "indices", ")", "\n", "random_instance", "=", "self", ".", "_instances", "[", "random_idx", "]", "\n", "if", "random_instance", "[", "\"user\"", "]", "==", "same_instance", "[", "\"user\"", "]", ":", "\n", "                ", "offset", "+=", "1", "\n", "continue", "\n", "", "else", ":", "\n", "                ", "offset", "=", "0", "\n", "bad_ref_instances", ".", "append", "(", "deepcopy", "(", "random_instance", ")", ")", "\n", "\n", "", "", "if", "self", ".", "anomaly_same_tgt_diff_refs", ":", "\n", "            ", "self", ".", "_instances", "=", "same_instances", "+", "same_instances", "\n", "self", ".", "_ref_instances", "=", "good_ref_instances", "+", "bad_ref_instances", "\n", "", "else", ":", "\n", "            ", "self", ".", "_ref_instances", "=", "same_instances", "+", "same_instances", "\n", "self", ".", "_instances", "=", "good_ref_instances", "+", "bad_ref_instances", "\n", "\n", "", "if", "self", ".", "anomaly_truncate_tgts", ":", "\n", "            ", "if", "max_tgt_seq_len", "is", "not", "None", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "_instances", ")", ")", ":", "\n", "                    ", "tgt_instance", "=", "self", ".", "_instances", "[", "i", "]", "\n", "if", "len", "(", "tgt_instance", "[", "\"marks\"", "]", ")", ">", "max_tgt_seq_len", ":", "\n", "                        ", "tgt_instance", "[", "\"marks\"", "]", "=", "tgt_instance", "[", "\"marks\"", "]", "[", ":", "max_tgt_seq_len", "]", "\n", "tgt_instance", "[", "\"times\"", "]", "=", "tgt_instance", "[", "\"times\"", "]", "[", ":", "max_tgt_seq_len", "]", "\n", "tgt_instance", "[", "\"T\"", "]", "=", "tgt_instance", "[", "\"times\"", "]", "[", "-", "1", "]", "+", "1e-8", "\n", "self", ".", "_instances", "[", "i", "]", "=", "tgt_instance", "\n", "\n", "", "", "", "", "if", "self", ".", "anomaly_truncate_refs", ":", "\n", "            ", "if", "max_tgt_seq_len", "is", "not", "None", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "_ref_instances", ")", ")", ":", "\n", "                    ", "ref_instance", "=", "self", ".", "_ref_instances", "[", "i", "]", "\n", "if", "len", "(", "ref_instance", "[", "\"marks\"", "]", ")", ">", "max_tgt_seq_len", ":", "\n", "                        ", "ref_instance", "[", "\"marks\"", "]", "=", "ref_instance", "[", "\"marks\"", "]", "[", ":", "max_tgt_seq_len", "]", "\n", "ref_instance", "[", "\"times\"", "]", "=", "ref_instance", "[", "\"times\"", "]", "[", ":", "max_tgt_seq_len", "]", "\n", "ref_instance", "[", "\"T\"", "]", "=", "ref_instance", "[", "\"times\"", "]", "[", "-", "1", "]", "+", "1e-8", "\n", "self", ".", "_ref_instances", "[", "i", "]", "=", "ref_instance", "\n", "", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data._ld_to_dl": [[28, 45], ["collections.defaultdict", "d.items", "dl[].append", "isinstance", "torch.nn.functional.pad", "torch.nn.functional.pad"], "function", ["None"], ["def", "_ld_to_dl", "(", "ld", ",", "padded_size", ",", "def_pad_value", ")", ":", "\n", "    ", "\"\"\"Converts list of dictionaries into dictionary of padded lists\"\"\"", "\n", "dl", "=", "defaultdict", "(", "list", ")", "\n", "for", "d", "in", "ld", ":", "\n", "        ", "for", "key", ",", "val", "in", "d", ".", "items", "(", ")", ":", "\n", "            ", "if", "key", "in", "PADDING_VALUES", ":", "\n", "                ", "pad_val", "=", "PADDING_VALUES", "[", "key", "]", "\n", "if", "pad_val", "is", "None", ":", "\n", "                    ", "pad_val", "=", "def_pad_value", "\n", "", "if", "isinstance", "(", "pad_val", ",", "list", ")", ":", "\n", "                    ", "new_val", "=", "F", ".", "pad", "(", "val", ",", "(", "0", ",", "0", ",", "0", ",", "padded_size", "-", "val", ".", "shape", "[", "-", "2", "]", ")", ",", "value", "=", "pad_val", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                    ", "new_val", "=", "F", ".", "pad", "(", "val", ",", "(", "0", ",", "padded_size", "-", "val", ".", "shape", "[", "-", "1", "]", ")", ",", "value", "=", "pad_val", ")", "\n", "", "", "else", ":", "\n", "                ", "new_val", "=", "val", "\n", "", "dl", "[", "key", "]", ".", "append", "(", "new_val", ")", "\n", "", "", "return", "dl", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data.pad_and_combine_instances": [[46, 56], ["len", "max", "data._ld_to_dl", "max", "max", "torch.stack", "_ld_to_dl.items", "len", "len"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.data._ld_to_dl"], ["", "def", "pad_and_combine_instances", "(", "batch", ",", "def_pad_value", ")", ":", "\n", "    ", "\"\"\"\n    A collate function for padding and combining instance dictionaries.\n    \"\"\"", "\n", "batch_size", "=", "len", "(", "batch", ")", "\n", "max_seq_len", "=", "max", "(", "max", "(", "len", "(", "ex", "[", "\"ref_times\"", "]", ")", "for", "ex", "in", "batch", ")", ",", "max", "(", "len", "(", "ex", "[", "\"tgt_times\"", "]", ")", "for", "ex", "in", "batch", ")", ")", "\n", "\n", "out_dict", "=", "_ld_to_dl", "(", "batch", ",", "max_seq_len", ",", "def_pad_value", ")", "\n", "\n", "return", "{", "k", ":", "torch", ".", "stack", "(", "v", ",", "dim", "=", "0", ")", "for", "k", ",", "v", "in", "out_dict", ".", "items", "(", ")", "}", "# dim=0 means batch is the first dimension", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.visualize._visualize": [[25, 117], ["logging.FileHandler", "logging.getLogger().addHandler", "torch.manual_seed", "numpy.random.seed", "vae_mpp.models.Model.from_config", "torch.load", "Model.from_config.load_state_dict", "vae_mpp.data.PointPatternDataset", "torch.utils.data.DataLoader", "tqdm.tqdm", "seaborn.color_palette", "config_file_path.exists", "logger.error", "sys.exit", "checkpoint_path.exists", "logger.error", "sys.exit", "open", "yaml.load", "vis_output_dir.exists", "logger.info", "vis_output_dir.mkdir", "yaml.load.get", "train_config.get", "matplotlib.subplots", "numpy.array", "torch.exp().squeeze", "numpy.array", "range", "instance[].squeeze().tolist", "instance[].squeeze().tolist", "zip", "ax.set_ylabel", "ax.set_xlabel", "ax.legend", "fig.savefig", "logging.getLogger", "yaml.load.get", "open", "pickle.load", "vae_mpp.parametric_pp.PointProcessFactory", "train_config.get", "torch.no_grad", "Model.from_config.", "output[].squeeze", "ax.plot", "pp_obj.clear", "zip", "numpy.array", "range", "ax.axvline", "torch.exp", "instance[].squeeze", "instance[].squeeze", "pp_obj.update", "ax.plot", "pp_obj.intensity().squeeze", "pp_obj.intensity"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.load_state_dict", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.PointProcessFactory", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.clear", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.update", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.intensity"], ["def", "_visualize", "(", "args", ")", ":", "\n", "    ", "'''Training function'''", "\n", "\n", "config_file_path", "=", "args", ".", "model_dir", "/", "\"config.yaml\"", "\n", "checkpoint_path", "=", "args", ".", "model_dir", "/", "\"model.pt\"", "\n", "vis_output_dir", "=", "args", ".", "model_dir", "/", "\"visualizations\"", "\n", "\n", "if", "not", "config_file_path", ".", "exists", "(", ")", ":", "\n", "        ", "logger", ".", "error", "(", "'File config.yaml does not exist. Exiting.'", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "if", "not", "checkpoint_path", ".", "exists", "(", ")", ":", "\n", "        ", "logger", ".", "error", "(", "'File model.pt does not exist. Exiting.'", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "with", "open", "(", "config_file_path", ",", "'r'", ")", "as", "config_file", ":", "\n", "        ", "config", "=", "yaml", ".", "load", "(", "config_file", ",", "Loader", "=", "yaml", ".", "SafeLoader", ")", "\n", "\n", "", "if", "not", "vis_output_dir", ".", "exists", "(", ")", ":", "\n", "        ", "logger", ".", "info", "(", "'Creating directory \"{}\"'", ".", "format", "(", "vis_output_dir", ")", ")", "\n", "vis_output_dir", ".", "mkdir", "(", ")", "\n", "\n", "# Set up logging", "\n", "", "fh", "=", "logging", ".", "FileHandler", "(", "args", ".", "model_dir", "/", "'output.log'", ")", "\n", "logging", ".", "getLogger", "(", ")", ".", "addHandler", "(", "fh", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "config", ".", "get", "(", "'seed'", ",", "5150", ")", ")", "\n", "np", ".", "random", ".", "seed", "(", "config", ".", "get", "(", "'seed'", ",", "1336", ")", "+", "1", ")", "\n", "\n", "# Initialize model components from config", "\n", "model", "=", "Model", ".", "from_config", "(", "config", "[", "'model'", "]", ")", "\n", "\n", "# Restore checkpoint", "\n", "state_dict", "=", "torch", ".", "load", "(", "checkpoint_path", ")", "\n", "model", ".", "load_state_dict", "(", "state_dict", "[", "'model'", "]", ")", "\n", "\n", "train_config", "=", "config", "[", "'training'", "]", "\n", "\n", "eval_dataset", "=", "PointPatternDataset", "(", "config", "[", "'evaluation_data'", "]", ")", "\n", "if", "\"point_process_objects\"", "in", "config", ":", "\n", "        ", "with", "open", "(", "config", "[", "\"point_process_objects\"", "]", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "pp_obj_dicts", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "pp_objs", "=", "[", "PointProcessFactory", "(", "d", ")", "for", "d", "in", "pp_obj_dicts", "]", "\n", "", "else", ":", "\n", "        ", "pp_objs", "=", "None", "\n", "\n", "", "data_loader", "=", "DataLoader", "(", "eval_dataset", ",", "\n", "batch_size", "=", "1", ",", "\n", "shuffle", "=", "False", ",", "\n", "num_workers", "=", "train_config", ".", "get", "(", "'num_workers'", ",", "0", ")", ",", "\n", "collate_fn", "=", "pad_and_combine_instances", ")", "\n", "data_tqdm", "=", "tqdm", "(", "data_loader", ",", "desc", "=", "''", ")", "\n", "pp_obj_idx", "=", "0", "\n", "colors", "=", "sns", ".", "color_palette", "(", ")", "\n", "for", "instance", "in", "data_tqdm", ":", "\n", "# Process Batch", "\n", "        ", "instance", "[", "\"mc_samples\"", "]", "=", "2000", "\n", "instance", "[", "\"T\"", "]", "=", "train_config", ".", "get", "(", "\"train_right_window\"", ",", "None", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "output", "=", "model", "(", "**", "instance", ")", "\n", "\n", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "12", ",", "8", ")", ")", "\n", "all_times", "=", "np", ".", "array", "(", "output", "[", "\"all_times\"", "]", ".", "squeeze", "(", ")", ")", "\n", "model_intensities", "=", "torch", ".", "exp", "(", "output", "[", "\"log_intensities\"", "]", "+", "output", "[", "\"log_probs\"", "]", ")", ".", "squeeze", "(", ")", "\n", "model_intensities", "=", "np", ".", "array", "(", "model_intensities", ")", "\n", "\n", "for", "k", "in", "range", "(", "model_intensities", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "ax", ".", "plot", "(", "all_times", ",", "model_intensities", "[", ":", ",", "k", "]", ",", "color", "=", "colors", "[", "k", "]", ",", "label", "=", "\"Model - k={}\"", ".", "format", "(", "k", ")", ")", "\n", "\n", "", "actual_times", "=", "instance", "[", "\"times\"", "]", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", "\n", "actual_marks", "=", "instance", "[", "\"marks\"", "]", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "if", "pp_objs", "is", "not", "None", ":", "\n", "            ", "pp_obj", "=", "pp_objs", "[", "pp_obj_idx", "]", "\n", "pp_obj", ".", "clear", "(", ")", "\n", "for", "t", ",", "m", "in", "zip", "(", "actual_times", ",", "actual_marks", ")", ":", "\n", "                ", "pp_obj", ".", "update", "(", "t", ",", "m", ",", "0", ")", "\n", "", "actual_intensities", "=", "np", ".", "array", "(", "[", "pp_obj", ".", "intensity", "(", "t", "=", "t", ",", "batch", "=", "0", ")", ".", "squeeze", "(", ")", "for", "t", "in", "all_times", "]", ")", "\n", "\n", "for", "k", "in", "range", "(", "model_intensities", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "ax", ".", "plot", "(", "all_times", ",", "actual_intensities", "[", ":", ",", "k", "]", ",", "color", "=", "colors", "[", "k", "]", ",", "alpha", "=", "0.5", ",", "linestyle", "=", "'dashed'", ",", "label", "=", "\"Real  - k={}\"", ".", "format", "(", "k", ")", ")", "\n", "\n", "", "", "for", "pt", ",", "mark", "in", "zip", "(", "actual_times", ",", "actual_marks", ")", ":", "\n", "            ", "ax", ".", "axvline", "(", "pt", ",", "color", "=", "colors", "[", "mark", "]", ",", "alpha", "=", "0.2", ",", "linestyle", "=", "'dotted'", ")", "\n", "\n", "", "ax", ".", "set_ylabel", "(", "\"Intensity by Mark\"", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Time\"", ")", "\n", "ax", ".", "legend", "(", ")", "\n", "fig", ".", "savefig", "(", "vis_output_dir", "/", "\"example_{}.png\"", ".", "format", "(", "pp_obj_idx", ")", ",", "\n", "dpi", "=", "400", ",", "\n", "bbox_inches", "=", "\"tight\"", ")", "\n", "\n", "pp_obj_idx", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SoftPlus.__init__": [[8, 11], ["numpy.ones"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "K", ")", ":", "\n", "        ", "self", ".", "K", "=", "K", "\n", "self", ".", "weights", "=", "np", ".", "ones", "(", "K", ")", "# (rand.rand(K) / 4) + 0.75", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SoftPlus.__call__": [[12, 15], ["numpy.log", "numpy.exp"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "t", ")", ":", "\n", "        ", "s", "=", "self", ".", "weights", "\n", "return", "s", "*", "np", ".", "log", "(", "1", "+", "np", ".", "exp", "(", "t", "/", "s", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.PointProcess.__init__": [[19, 21], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "conditional", "=", "False", ")", ":", "\n", "        ", "self", ".", "conditional", "=", "conditional", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.PointProcess.intensity": [[22, 25], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "intensity", "(", "self", ",", "t", ",", "batch", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.PointProcess.update": [[26, 29], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "update", "(", "self", ",", "t", ",", "k", ",", "batch", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.PointProcess.generate_point_pattern": [[30, 109], ["numpy.zeros", "numpy.concatenate", "numpy.cumsum", "numpy.random.rand", "numpy.concatenate.append", "numpy.sum", "numpy.all", "numpy.random.rand", "range", "numpy.array", "numpy.array", "numpy.array", "parametric_pp.PointProcess.intensity", "numpy.apply_along_axis", "numpy.split", "numpy.split", "numpy.split", "range", "parametric_pp.PointProcess.sum", "numpy.where", "numpy.log", "numpy.random.rand", "parametric_pp.PointProcess.sum", "numpy.random.choice", "parametric_pp.PointProcess.intensity", "numpy.diff", "parametric_pp.PointProcess.sum", "numpy.array.append", "intensities.append", "numpy.random.choice", "numpy.apply_along_axis.append", "parametric_pp.PointProcess.update", "parametric_pp.PointProcess.sum"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.intensity", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.intensity", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.update"], ["", "def", "generate_point_pattern", "(", "self", ",", "base_intensity", ",", "right_limit", ",", "batch_size", ")", ":", "\n", "        ", "'''\n        Generates a temporal point pattern for a given intensity using a thinning process.\n\n        Arguments:\n            base_intensity (float) - Defines a single intensity rate that dominates the entire intensity\n                function for process being simulated across the time window\n            right_limit (float) - The function generates points within the time window [0, right_limit)\n            batch_size (int) - The size of the batch of independent samples being generated\n\n        Returns:\n            A tuple of tuples containing three arrays, each length n.\n            The first element in the nested tuple contains the generated arrival event times.\n            The second element contains the associated mark id.\n            The third element contains the intensity values at the associated time.\n            Each nested tuple is a sample and there will be 'batch_size' of them.\n        '''", "\n", "\n", "initial_point_count", "=", "base_intensity", "*", "right_limit", "\n", "candidate_points", "=", "[", "]", "\n", "max_sum", "=", "np", ".", "zeros", "(", "batch_size", ")", "\n", "while", "True", ":", "\n", "            ", "random_quants", "=", "rand", ".", "rand", "(", "batch_size", ",", "initial_point_count", ")", "# uniform [0,1) draws", "\n", "random_homo_pp", "=", "-", "1", "*", "np", ".", "log", "(", "1", "-", "random_quants", ")", "/", "base_intensity", "# quantile for exp dist", "\n", "candidate_points", ".", "append", "(", "random_homo_pp", ")", "\n", "\n", "# check if we have reached the right_limit yet for all samples", "\n", "# (could speed up for checking individual samples)", "\n", "max_sum", "+=", "np", ".", "sum", "(", "random_homo_pp", ",", "axis", "=", "1", ")", "\n", "if", "np", ".", "all", "(", "max_sum", ">", "right_limit", ")", ":", "\n", "                ", "break", "\n", "\n", "", "", "candidate_points", "=", "np", ".", "concatenate", "(", "candidate_points", ",", "axis", "=", "1", ")", "# shape = batch_size, samples", "\n", "candidate_arrival_times", "=", "np", ".", "cumsum", "(", "candidate_points", ",", "axis", "=", "1", ")", "# calculate the actual event times", "\n", "\n", "if", "self", ".", "conditional", ":", "\n", "            ", "marks", "=", "[", "]", "\n", "arrival_times", "=", "[", "]", "\n", "intensities", "=", "[", "]", "\n", "batch_size", ",", "sample_size", "=", "candidate_arrival_times", ".", "shape", "\n", "generated_rvs", "=", "rand", ".", "rand", "(", "batch_size", ",", "sample_size", ")", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "for", "s", "in", "range", "(", "sample_size", ")", ":", "\n", "                    ", "t", "=", "candidate_arrival_times", "[", "b", ",", "s", "]", "\n", "rv", "=", "generated_rvs", "[", "b", ",", "s", "]", "\n", "if", "t", "<", "right_limit", ":", "\n", "                        ", "intensity_vector", "=", "self", ".", "intensity", "(", "t", ",", "b", ")", "\n", "prob", "=", "intensity_vector", ".", "sum", "(", ")", "/", "base_intensity", "\n", "if", "rv", "<", "prob", ":", "\n", "                            ", "arrival_times", ".", "append", "(", "t", ")", "\n", "intensities", ".", "append", "(", "intensity_vector", ")", "\n", "intensity_prob", "=", "intensity_vector", "/", "intensity_vector", ".", "sum", "(", ")", "\n", "mark", "=", "rand", ".", "choice", "(", "intensity_vector", ".", "shape", "[", "0", "]", ",", "p", "=", "intensity_prob", ")", "\n", "marks", ".", "append", "(", "mark", ")", "\n", "self", ".", "update", "(", "t", ",", "mark", ",", "b", ")", "\n", "", "", "", "", "marks", "=", "np", ".", "array", "(", "marks", ")", "\n", "arrival_times", "=", "np", ".", "array", "(", "arrival_times", ")", "\n", "intensity_values", "=", "np", ".", "array", "(", "intensities", ")", "\n", "", "else", ":", "\n", "            ", "intensity_values", "=", "self", ".", "intensity", "(", "candidate_arrival_times", ")", "# shape = sample_size, samples, marks", "\n", "K", "=", "intensity_values", ".", "shape", "[", "2", "]", "\n", "probs", "=", "intensity_values", ".", "sum", "(", "axis", "=", "2", ")", "/", "base_intensity", "\n", "\n", "# thinning", "\n", "accepted_point_indices", "=", "(", "rand", ".", "rand", "(", "*", "candidate_arrival_times", ".", "shape", ")", "<", "probs", ")", "&", "(", "\n", "candidate_arrival_times", "<", "right_limit", ")", "\n", "\n", "arrival_times", "=", "candidate_arrival_times", "[", "accepted_point_indices", "]", "\n", "intensity_values", "=", "intensity_values", "[", "accepted_point_indices", "]", "\n", "\n", "intensity_probs", "=", "(", "\n", "intensity_values", "/", "intensity_values", ".", "sum", "(", "axis", "=", "1", ")", "[", ":", ",", "np", ".", "newaxis", "]", ")", "# normalize at each point", "\n", "marks", "=", "np", ".", "apply_along_axis", "(", "lambda", "x", ":", "rand", ".", "choice", "(", "K", ",", "p", "=", "x", ")", ",", "axis", "=", "1", ",", "arr", "=", "intensity_probs", ")", "\n", "\n", "", "split_indices", "=", "np", ".", "where", "(", "np", ".", "diff", "(", "arrival_times", ")", "<", "0", ")", "[", "0", "]", "+", "1", "\n", "\n", "return", "(", "np", ".", "split", "(", "arrival_times", ",", "split_indices", ")", ",", "\n", "np", ".", "split", "(", "marks", ",", "split_indices", ")", ",", "\n", "np", ".", "split", "(", "intensity_values", ",", "split_indices", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.HomogenousPoissonProcess.__init__": [[112, 116], ["parametric_pp.PointProcess.__init__", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "K", ",", "scale", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "conditional", "=", "False", ")", "\n", "self", ".", "K", "=", "K", "\n", "self", ".", "scale", "=", "rand", ".", "rand", "(", "K", ")", "*", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.HomogenousPoissonProcess.intensity": [[117, 121], ["numpy.repeat"], "methods", ["None"], ["", "def", "intensity", "(", "self", ",", "t", ",", "batch", "=", "None", ")", ":", "\n", "        ", "scale", "=", "self", ".", "scale", "\n", "x", "=", "np", ".", "repeat", "(", "t", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "self", ".", "K", ",", "axis", "=", "2", ")", "\n", "return", "scale", "*", "(", "(", "x", "*", "0", ")", "+", "1", ")", "# just to get the same size", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.HomogenousPoissonProcess.update": [[122, 124], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "t", ",", "k", ",", "batch", ")", ":", "\n", "        ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.HomogenousPoissonProcess.__repr__": [[125, 127], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"K={}\\nScale={}\"", ".", "format", "(", "self", ".", "K", ",", "self", ".", "scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.InhomogenousPoissonProcess.__init__": [[130, 136], ["parametric_pp.PointProcess.__init__", "numpy.random.rand", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "K", ",", "scale", ",", "right_limit", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "conditional", "=", "False", ")", "\n", "self", ".", "K", "=", "K", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "mu", "=", "rand", ".", "rand", "(", "K", ")", "*", "right_limit", "\n", "self", ".", "sigma", "=", "3", "+", "rand", ".", "rand", "(", "K", ")", "*", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.InhomogenousPoissonProcess.intensity": [[137, 143], ["numpy.repeat", "numpy.exp", "numpy.sqrt"], "methods", ["None"], ["", "def", "intensity", "(", "self", ",", "t", ",", "batch", "=", "None", ")", ":", "\n", "        ", "sigma", "=", "self", ".", "sigma", "\n", "mu", "=", "self", ".", "mu", "\n", "scale", "=", "self", ".", "scale", "\n", "x", "=", "np", ".", "repeat", "(", "t", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "self", ".", "K", ",", "axis", "=", "2", ")", "\n", "return", "scale", "/", "(", "sigma", "*", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", ")", "*", "np", ".", "exp", "(", "-", "(", "x", "-", "mu", ")", "**", "2", "/", "(", "2", "*", "sigma", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.InhomogenousPoissonProcess.update": [[144, 146], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "t", ",", "k", ",", "batch", ")", ":", "\n", "        ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.InhomogenousPoissonProcess.__repr__": [[147, 149], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"K={}\\nScale={}\\nMu={}\\nSigma={}\"", ".", "format", "(", "self", ".", "K", ",", "self", ".", "scale", ",", "self", ".", "mu", ",", "self", ".", "sigma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfCorrectingProcess.__init__": [[153, 161], ["parametric_pp.PointProcess.__init__", "parametric_pp.SoftPlus", "numpy.random.rand", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "K", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "conditional", "=", "True", ")", "\n", "self", ".", "K", "=", "K", "\n", "self", ".", "func", "=", "SoftPlus", "(", "K", ")", "\n", "self", ".", "eta", "=", "(", "rand", ".", "rand", "(", "K", ")", "-", "0.1", ")", "*", "3", "/", "K", "\n", "self", ".", "gamma", "=", "(", "rand", ".", "rand", "(", "K", ",", "K", ")", "-", "0.2", ")", "/", "K", "# influence of events to row, from col", "\n", "self", ".", "history_times", "=", "{", "}", "\n", "self", ".", "history_marks", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfCorrectingProcess.clear": [[162, 165], ["None"], "methods", ["None"], ["", "def", "clear", "(", "self", ")", ":", "\n", "        ", "self", ".", "history_times", "=", "{", "}", "\n", "self", ".", "history_marks", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfCorrectingProcess.intensity": [[166, 180], ["parametric_pp.SelfCorrectingProcess.func", "numpy.exp", "numpy.exp", "numpy.sum"], "methods", ["None"], ["", "def", "intensity", "(", "self", ",", "t", ",", "batch", ")", ":", "\n", "# t: single value", "\n", "# intensity output shape: K", "\n", "\n", "        ", "if", "batch", "in", "self", ".", "history_times", ":", "\n", "            ", "times", "=", "self", ".", "history_times", "[", "batch", "]", "\n", "marks", "=", "self", ".", "history_marks", "[", "batch", "]", "\n", "\n", "valid_obs", "=", "times", "<", "t", "\n", "gammas", "=", "self", ".", "gamma", "[", ":", ",", "marks", "]", "\n", "vals", "=", "np", ".", "exp", "(", "(", "self", ".", "eta", "*", "t", ")", "-", "np", ".", "sum", "(", "gammas", "*", "valid_obs", ",", "axis", "=", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "vals", "=", "np", ".", "exp", "(", "self", ".", "eta", "*", "t", ")", "\n", "", "return", "self", ".", "func", "(", "vals", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfCorrectingProcess.update": [[181, 188], ["numpy.append", "parametric_pp.SelfCorrectingProcess.history_marks[].append", "numpy.array"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "t", ",", "k", ",", "batch", ")", ":", "\n", "        ", "if", "batch", "in", "self", ".", "history_times", ":", "\n", "            ", "self", ".", "history_times", "[", "batch", "]", "=", "np", ".", "append", "(", "self", ".", "history_times", "[", "batch", "]", ",", "t", ")", "\n", "self", ".", "history_marks", "[", "batch", "]", ".", "append", "(", "k", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "history_times", "[", "batch", "]", "=", "np", ".", "array", "(", "[", "t", "]", ")", "\n", "self", ".", "history_marks", "[", "batch", "]", "=", "[", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfCorrectingProcess.__repr__": [[189, 191], ["str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfExcitingProcess.__init__": [[195, 204], ["parametric_pp.PointProcess.__init__", "parametric_pp.SoftPlus", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "K", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "conditional", "=", "True", ")", "\n", "self", ".", "K", "=", "K", "\n", "self", ".", "func", "=", "SoftPlus", "(", "K", ")", "\n", "self", ".", "mu", "=", "(", "rand", ".", "rand", "(", "K", ")", "-", "0.5", ")", "*", "3", "/", "K", "\n", "self", ".", "alpha", "=", "(", "rand", ".", "rand", "(", "K", ",", "K", ")", "-", "0.5", ")", "/", "K", "# influence of events to row, from col", "\n", "self", ".", "delta", "=", "rand", ".", "rand", "(", "K", ",", "K", ")", "*", "3", "*", "K", "\n", "self", ".", "history_times", "=", "{", "}", "\n", "self", ".", "history_marks", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfExcitingProcess.clear": [[205, 208], ["None"], "methods", ["None"], ["", "def", "clear", "(", "self", ")", ":", "\n", "        ", "self", ".", "history_times", "=", "{", "}", "\n", "self", ".", "history_marks", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfExcitingProcess.intensity": [[209, 225], ["parametric_pp.SelfExcitingProcess.func", "numpy.sum", "numpy.exp"], "methods", ["None"], ["", "def", "intensity", "(", "self", ",", "t", ",", "batch", ")", ":", "\n", "# t: single value", "\n", "# intensity output shape: K", "\n", "\n", "        ", "if", "batch", "in", "self", ".", "history_times", ":", "\n", "            ", "times", "=", "self", ".", "history_times", "[", "batch", "]", "\n", "marks", "=", "self", ".", "history_marks", "[", "batch", "]", "\n", "\n", "valid_obs", "=", "times", "<", "t", "\n", "diffs", "=", "t", "-", "times", "\n", "alphas", "=", "self", ".", "alpha", "[", ":", ",", "marks", "]", "\n", "deltas", "=", "self", ".", "delta", "[", ":", ",", "marks", "]", "\n", "vals", "=", "self", ".", "mu", "+", "np", ".", "sum", "(", "valid_obs", "*", "alphas", "*", "np", ".", "exp", "(", "-", "1", "*", "deltas", "*", "diffs", ")", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "vals", "=", "self", ".", "mu", "\n", "", "return", "self", ".", "func", "(", "vals", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfExcitingProcess.update": [[226, 233], ["numpy.append", "parametric_pp.SelfExcitingProcess.history_marks[].append", "numpy.array"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "t", ",", "k", ",", "batch", ")", ":", "\n", "        ", "if", "batch", "in", "self", ".", "history_times", ":", "\n", "            ", "self", ".", "history_times", "[", "batch", "]", "=", "np", ".", "append", "(", "self", ".", "history_times", "[", "batch", "]", ",", "t", ")", "\n", "self", ".", "history_marks", "[", "batch", "]", ".", "append", "(", "k", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "history_times", "[", "batch", "]", "=", "np", ".", "array", "(", "[", "t", "]", ")", "\n", "self", ".", "history_marks", "[", "batch", "]", "=", "[", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfExcitingProcess.__repr__": [[234, 236], ["str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.__init__": [[240, 252], ["parametric_pp.PointProcess.__init__", "parametric_pp.SoftPlus", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "K", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "conditional", "=", "True", ")", "\n", "self", ".", "K", "=", "K", "\n", "self", ".", "func", "=", "SoftPlus", "(", "K", ")", "\n", "self", ".", "mu", "=", "(", "rand", ".", "rand", "(", "K", ")", "-", "0.5", ")", "*", "3", "/", "K", "\n", "self", ".", "alpha", "=", "(", "rand", ".", "rand", "(", "K", ",", "K", ")", "-", "0.5", ")", "/", "K", "# influence of events to row, from col", "\n", "self", ".", "delta", "=", "rand", ".", "rand", "(", "K", ",", "K", ")", "*", "3", "*", "K", "\n", "self", ".", "eta", "=", "(", "rand", ".", "rand", "(", "K", ")", "-", "0.1", ")", "*", "3", "/", "K", "\n", "self", ".", "gamma", "=", "(", "rand", ".", "rand", "(", "K", ",", "K", ")", "-", "0.2", ")", "/", "K", "# influence of events to row, from col", "\n", "self", ".", "proportion", "=", "rand", ".", "rand", "(", "1", ")", "[", "0", "]", "\n", "self", ".", "history_times", "=", "{", "}", "\n", "self", ".", "history_marks", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.clear": [[253, 256], ["None"], "methods", ["None"], ["", "def", "clear", "(", "self", ")", ":", "\n", "        ", "self", ".", "history_times", "=", "{", "}", "\n", "self", ".", "history_marks", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.intensity": [[257, 277], ["parametric_pp.SelfModulatingProcess.func", "numpy.exp", "numpy.exp", "numpy.sum", "numpy.sum", "numpy.exp"], "methods", ["None"], ["", "def", "intensity", "(", "self", ",", "t", ",", "batch", ")", ":", "\n", "# t: single value", "\n", "# intensity output shape: K", "\n", "\n", "        ", "if", "batch", "in", "self", ".", "history_times", ":", "\n", "            ", "times", "=", "self", ".", "history_times", "[", "batch", "]", "\n", "marks", "=", "self", ".", "history_marks", "[", "batch", "]", "\n", "\n", "valid_obs", "=", "times", "<", "t", "\n", "diffs", "=", "t", "-", "times", "\n", "alphas", "=", "self", ".", "alpha", "[", ":", ",", "marks", "]", "\n", "deltas", "=", "self", ".", "delta", "[", ":", ",", "marks", "]", "\n", "se_vals", "=", "self", ".", "mu", "+", "np", ".", "sum", "(", "valid_obs", "*", "alphas", "*", "np", ".", "exp", "(", "-", "1", "*", "deltas", "*", "diffs", ")", ",", "axis", "=", "1", ")", "\n", "gammas", "=", "self", ".", "gamma", "[", ":", ",", "marks", "]", "\n", "sc_vals", "=", "np", ".", "exp", "(", "(", "self", ".", "eta", "*", "t", ")", "-", "np", ".", "sum", "(", "gammas", "*", "valid_obs", ",", "axis", "=", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "se_vals", "=", "self", ".", "mu", "\n", "sc_vals", "=", "np", ".", "exp", "(", "self", ".", "eta", "*", "t", ")", "\n", "", "p", "=", "self", ".", "proportion", "\n", "return", "self", ".", "func", "(", "p", "*", "se_vals", "+", "(", "1", "-", "p", ")", "*", "sc_vals", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.update": [[278, 285], ["numpy.append", "parametric_pp.SelfModulatingProcess.history_marks[].append", "numpy.array"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "t", ",", "k", ",", "batch", ")", ":", "\n", "        ", "if", "batch", "in", "self", ".", "history_times", ":", "\n", "            ", "self", ".", "history_times", "[", "batch", "]", "=", "np", ".", "append", "(", "self", ".", "history_times", "[", "batch", "]", ",", "t", ")", "\n", "self", ".", "history_marks", "[", "batch", "]", ".", "append", "(", "k", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "history_times", "[", "batch", "]", "=", "np", ".", "array", "(", "[", "t", "]", ")", "\n", "self", ".", "history_marks", "[", "batch", "]", "=", "[", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.SelfModulatingProcess.__repr__": [[286, 288], ["str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.parametric_pp.PointProcessFactory": [[289, 297], ["parametric_pp.SelfExcitingProcess", "pp_args.items"], "function", ["None"], ["", "", "def", "PointProcessFactory", "(", "pp_args", ")", ":", "\n", "\n", "    ", "pp_obj", "=", "SelfExcitingProcess", "(", "pp_args", "[", "\"K\"", "]", ")", "\n", "\n", "for", "k", ",", "v", "in", "pp_args", ".", "items", "(", ")", ":", "\n", "        ", "pp_obj", ".", "__dict__", "[", "k", "]", "=", "v", "\n", "\n", "", "return", "pp_obj", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.__init__": [[29, 52], ["float", "optim.LRScheduler.step"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.step"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "start_lr", ",", "warmup_iter", ",", "num_iters", ",", "decay_style", ",", "args", ")", ":", "\n", "        ", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "start_lr", "=", "float", "(", "start_lr", ")", "\n", "self", ".", "warmup_iter", "=", "warmup_iter", "\n", "self", ".", "num_iters", "=", "0", "# current step", "\n", "self", ".", "end_iter", "=", "num_iters", "\n", "self", ".", "decay_style", "=", "decay_style", "\n", "self", ".", "decay_func", "=", "LRScheduler", ".", "DECAY_STYLES", "[", "decay_style", "]", "\n", "\n", "self", ".", "args", "=", "args", "\n", "if", "args", ".", "loss_monotonic", "is", "not", "None", ":", "\n", "            ", "self", ".", "loss_annealing", "=", "\"monotonic\"", "\n", "self", ".", "loss_rate", "=", "args", ".", "loss_monotonic", "\n", "", "elif", "args", ".", "loss_cyclical", "is", "not", "None", ":", "\n", "            ", "self", ".", "loss_annealing", "=", "\"cyclical\"", "\n", "self", ".", "loss_rate", "=", "args", ".", "loss_cyclical", "\n", "", "else", ":", "\n", "            ", "self", ".", "loss_annealing", "=", "\"constant\"", "\n", "\n", "", "self", ".", "true_beta", "=", "args", ".", "loss_beta", "\n", "self", ".", "true_lambda", "=", "args", ".", "loss_lambda", "\n", "\n", "self", ".", "step", "(", "self", ".", "num_iters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.get_lr": [[53, 60], ["optim.LRScheduler.decay_func"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ")", ":", "\n", "# Ramp up linearly if we are in the warmup period", "\n", "        ", "if", "self", ".", "warmup_iter", ">", "0", "and", "self", ".", "num_iters", "<=", "self", ".", "warmup_iter", ":", "\n", "            ", "return", "self", ".", "start_lr", "*", "self", ".", "num_iters", "/", "self", ".", "warmup_iter", "\n", "", "else", ":", "\n", "            ", "pct_step", "=", "(", "self", ".", "num_iters", "-", "self", ".", "warmup_iter", ")", "/", "(", "self", ".", "end_iter", "-", "self", ".", "warmup_iter", ")", "\n", "return", "self", ".", "start_lr", "*", "self", ".", "decay_func", "(", "pct_step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.get_loss_mult": [[61, 78], ["min", "int", "min"], "methods", ["None"], ["", "", "def", "get_loss_mult", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "warmup_iter", ">", "0", "and", "self", ".", "num_iters", "<=", "self", ".", "warmup_iter", ":", "\n", "            ", "if", "self", ".", "loss_annealing", "==", "\"constant\"", ":", "\n", "                ", "return", "1.0", "\n", "", "else", ":", "\n", "                ", "return", "0.0", "\n", "", "", "else", ":", "\n", "            ", "adj_iter", "=", "self", ".", "num_iters", "-", "self", ".", "warmup_iter", "\n", "total_iter", "=", "self", ".", "end_iter", "-", "self", ".", "warmup_iter", "\n", "pct_step", "=", "adj_iter", "/", "total_iter", "\n", "if", "self", ".", "loss_annealing", "==", "\"monotonic\"", ":", "\n", "                ", "return", "min", "(", "pct_step", "/", "self", ".", "loss_rate", ",", "1.0", ")", "\n", "", "elif", "self", ".", "loss_annealing", "==", "\"cyclical\"", ":", "\n", "                ", "cycle", "=", "int", "(", "total_iter", "*", "self", ".", "loss_rate", ")", "\n", "return", "min", "(", "2.0", "*", "(", "(", "adj_iter", "%", "cycle", ")", "/", "cycle", ")", ",", "1.0", ")", "\n", "", "else", ":", "\n", "                ", "return", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.step": [[79, 91], ["optim.LRScheduler.get_lr", "optim.LRScheduler.get_loss_mult"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.get_lr", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.get_loss_mult"], ["", "", "", "def", "step", "(", "self", ",", "step_num", "=", "None", ")", ":", "\n", "        ", "if", "step_num", "is", "None", ":", "\n", "            ", "step_num", "=", "self", ".", "num_iters", "+", "1", "\n", "", "self", ".", "num_iters", "=", "step_num", "\n", "new_lr", "=", "self", ".", "get_lr", "(", ")", "\n", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", ":", "\n", "            ", "group", "[", "'lr'", "]", "=", "new_lr", "\n", "\n", "", "mult", "=", "self", ".", "get_loss_mult", "(", ")", "\n", "\n", "self", ".", "args", ".", "loss_beta", "=", "mult", "*", "self", ".", "true_beta", "\n", "self", ".", "args", ".", "loss_lambda", "=", "mult", "*", "self", ".", "true_lambda", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.state_dict": [[92, 101], ["None"], "methods", ["None"], ["", "def", "state_dict", "(", "self", ")", ":", "\n", "        ", "sd", "=", "{", "\n", "'start_lr'", ":", "self", ".", "start_lr", ",", "\n", "'warmup_iter'", ":", "self", ".", "warmup_iter", ",", "\n", "'num_iters'", ":", "self", ".", "num_iters", ",", "\n", "'decay_style'", ":", "self", ".", "decay_style", ",", "\n", "'end_iter'", ":", "self", ".", "end_iter", "\n", "}", "\n", "return", "sd", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.load_state_dict": [[102, 110], ["optim.LRScheduler.step"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.LRScheduler.step"], ["", "def", "load_state_dict", "(", "self", ",", "sd", ")", ":", "\n", "        ", "self", ".", "start_lr", "=", "sd", "[", "'start_lr'", "]", "\n", "self", ".", "warmup_iter", "=", "sd", "[", "'warmup_iter'", "]", "\n", "self", ".", "num_iters", "=", "sd", "[", "'num_iters'", "]", "\n", "self", ".", "end_iter", "=", "sd", "[", "'end_iter'", "]", "\n", "self", ".", "decay_style", "=", "sd", "[", "'decay_style'", "]", "\n", "self", ".", "decay_func", "=", "LRScheduler", ".", "DECAY_STYLES", "[", "sd", "[", "'decay_style'", "]", "]", "\n", "self", ".", "step", "(", "self", ".", "num_iters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.get_optimizer": [[112, 123], ["model.get_param_groups"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_param_groups"], ["", "", "def", "get_optimizer", "(", "model", ",", "args", ")", ":", "\n", "\n", "    ", "param_groups", "=", "model", ".", "get_param_groups", "(", ")", "\n", "\n", "optimizer", "=", "OPTIMIZERS", "[", "args", ".", "optimizer", "]", "(", "\n", "param_groups", ",", "\n", "lr", "=", "args", ".", "lr", ",", "\n", "weight_decay", "=", "args", ".", "weight_decay", ",", "# learning rate, weight decay, etc.", "\n", ")", "\n", "\n", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.optim.get_lr_scheduler": [[124, 139], ["math.floor", "optim.LRScheduler"], "function", ["None"], ["", "def", "get_lr_scheduler", "(", "optimizer", ",", "args", ",", "epoch_len", ")", ":", "\n", "\n", "    ", "total_iterations", "=", "args", ".", "train_epochs", "*", "epoch_len", "#  args[\"train_iters\"]", "\n", "warmup_iterations", "=", "math", ".", "floor", "(", "args", ".", "warmup_pct", "*", "total_iterations", ")", "\n", "\n", "lr_scheduler", "=", "LRScheduler", "(", "\n", "optimizer", "=", "optimizer", ",", "\n", "start_lr", "=", "args", ".", "lr", ",", "\n", "warmup_iter", "=", "warmup_iterations", ",", "\n", "num_iters", "=", "total_iterations", ",", "\n", "decay_style", "=", "args", ".", "lr_decay_style", ",", "\n", "args", "=", "args", ",", "\n", ")", "\n", "\n", "return", "lr_scheduler", "\n", "", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.print_log": [[6, 8], ["print", "datetime.datetime.now"], "function", ["None"], ["def", "print_log", "(", "*", "args", ")", ":", "\n", "    ", "print", "(", "\"[{}]\"", ".", "format", "(", "datetime", ".", "now", "(", ")", ")", ",", "*", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.compute_kernel": [[9, 19], ["x.unsqueeze.size", "y.unsqueeze.size", "x.unsqueeze.size", "x.unsqueeze.unsqueeze", "y.unsqueeze.unsqueeze", "x.unsqueeze.expand", "y.unsqueeze.expand", "torch.exp", "float"], "function", ["None"], ["", "def", "compute_kernel", "(", "x", ",", "y", ")", ":", "\n", "    ", "x_size", "=", "x", ".", "size", "(", "0", ")", "\n", "y_size", "=", "y", ".", "size", "(", "0", ")", "\n", "dim", "=", "x", ".", "size", "(", "1", ")", "\n", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", "# (x_size, 1, dim)", "\n", "y", "=", "y", ".", "unsqueeze", "(", "0", ")", "# (1, y_size, dim)", "\n", "tiled_x", "=", "x", ".", "expand", "(", "x_size", ",", "y_size", ",", "dim", ")", "\n", "tiled_y", "=", "y", ".", "expand", "(", "x_size", ",", "y_size", ",", "dim", ")", "\n", "kernel_input", "=", "(", "tiled_x", "-", "tiled_y", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", "2", ")", "/", "float", "(", "dim", ")", "\n", "return", "torch", ".", "exp", "(", "-", "kernel_input", ")", "# (x_size, y_size)", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.compute_mmd": [[20, 26], ["utils.compute_kernel", "utils.compute_kernel", "utils.compute_kernel", "compute_kernel.mean", "compute_kernel.mean", "compute_kernel.mean"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.compute_kernel", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.compute_kernel", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.compute_kernel"], ["", "def", "compute_mmd", "(", "x", ",", "y", ")", ":", "\n", "    ", "x_kernel", "=", "compute_kernel", "(", "x", ",", "x", ")", "\n", "y_kernel", "=", "compute_kernel", "(", "y", ",", "y", ")", "\n", "xy_kernel", "=", "compute_kernel", "(", "x", ",", "y", ")", "\n", "mmd", "=", "x_kernel", ".", "mean", "(", ")", "+", "y_kernel", ".", "mean", "(", ")", "-", "2", "*", "xy_kernel", ".", "mean", "(", ")", "\n", "return", "mmd", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.kl_div": [[27, 34], ["torch.distributions.kl_divergence", "d1.rsample", "type", "type", "torch.Size", "d1.log_prob", "d2.log_prob"], "function", ["None"], ["", "def", "kl_div", "(", "d1", ",", "d2", ",", "K", "=", "100", ")", ":", "\n", "    ", "\"\"\"Computes closed-form KL if available, else computes a MC estimate.\"\"\"", "\n", "if", "(", "type", "(", "d1", ")", ",", "type", "(", "d2", ")", ")", "in", "torch", ".", "distributions", ".", "kl", ".", "_KL_REGISTRY", ":", "\n", "        ", "return", "torch", ".", "distributions", ".", "kl_divergence", "(", "d1", ",", "d2", ")", "\n", "", "else", ":", "\n", "        ", "samples", "=", "d1", ".", "rsample", "(", "torch", ".", "Size", "(", "[", "K", "]", ")", ")", "\n", "return", "(", "d1", ".", "log_prob", "(", "samples", ")", "-", "d2", ".", "log_prob", "(", "samples", ")", ")", ".", "mean", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.mmd_div": [[35, 39], ["torch.randn_like", "utils.compute_mmd"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.vae_mpp.utils.compute_mmd"], ["", "", "def", "mmd_div", "(", "z", ")", ":", "\n", "    ", "raise", "NotImplementedError", "\n", "true_samples", "=", "torch", ".", "randn_like", "(", "z", ")", "\n", "return", "compute_mmd", "(", "true_samples", ",", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.encoder.PPEncoder.__init__": [[14, 56], ["torch.Module.__init__", "torch.GRU", "torch.GRU", "encoder.PPEncoder.register_parameter", "torch.Sequential", "torch.Sequential", "torch.GRU", "torch.GRU", "encoder.PPEncoder.register_parameter", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "utils.xavier_truncated_normal", "torch.Parameter", "torch.Parameter", "utils.xavier_truncated_normal"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.xavier_truncated_normal", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.xavier_truncated_normal"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_embedding", ",", "\n", "time_embedding", ",", "\n", "hidden_size", ",", "\n", "bidirectional", ",", "\n", "num_recurrent_layers", ",", "\n", "dropout", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "channel_embedding", "=", "channel_embedding", "\n", "self", ".", "time_embedding", "=", "time_embedding", "\n", "self", ".", "channel_embedding_size", ",", "self", ".", "time_embedding_dim", "=", "self", ".", "channel_embedding", ".", "weight", ".", "shape", "[", "-", "1", "]", ",", "self", ".", "time_embedding", ".", "embedding_dim", "\n", "\n", "recurrent_net_args", "=", "{", "\n", "\"input_size\"", ":", "self", ".", "channel_embedding_size", "+", "self", ".", "time_embedding_dim", ",", "\n", "\"hidden_size\"", ":", "hidden_size", ",", "\n", "\"num_layers\"", ":", "num_recurrent_layers", ",", "\n", "\"batch_first\"", ":", "True", ",", "\n", "\"bidirectional\"", ":", "False", ",", "# Need to keep separate networks if bidir=True due to potential padding issues", "\n", "\"dropout\"", ":", "dropout", ",", "\n", "}", "\n", "self", ".", "forward_recurrent_net", "=", "nn", ".", "GRU", "(", "**", "recurrent_net_args", ")", "\n", "self", ".", "register_parameter", "(", "\n", "name", "=", "\"forward_init_hidden_state\"", ",", "\n", "param", "=", "nn", ".", "Parameter", "(", "xavier_truncated_normal", "(", "size", "=", "(", "num_recurrent_layers", ",", "1", ",", "hidden_size", ")", ",", "no_average", "=", "True", ")", ")", "\n", ")", "\n", "\n", "self", ".", "bidirectional", "=", "bidirectional", "\n", "if", "bidirectional", ":", "\n", "            ", "self", ".", "backward_recurrent_net", "=", "nn", ".", "GRU", "(", "**", "recurrent_net_args", ")", "\n", "self", ".", "register_parameter", "(", "\n", "name", "=", "\"backward_init_hidden_state\"", ",", "\n", "param", "=", "nn", ".", "Parameter", "(", "xavier_truncated_normal", "(", "size", "=", "(", "num_recurrent_layers", ",", "1", ",", "hidden_size", ")", ",", "no_average", "=", "True", ")", ")", "\n", ")", "\n", "out_size", "=", "hidden_size", "*", "2", "\n", "", "else", ":", "\n", "            ", "self", ".", "backward_recurrent_net", "=", "None", "\n", "out_size", "=", "hidden_size", "\n", "\n", "", "self", ".", "last_linear_layer", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "out_size", ",", "out_size", ")", ",", "ACTIVATIONS", "[", "\"gelu\"", "]", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.encoder.PPEncoder.forward": [[57, 73], ["encoder.PPEncoder.last_linear_layer", "steps.append", "encoder.PPEncoder.channel_embedding", "encoder.PPEncoder.time_embedding", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "last_hidden_states.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "recurrent_net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "forward_marks", ",", "forward_timestamps", ",", "backward_marks", "=", "None", ",", "backward_timestamps", "=", "None", ")", ":", "\n", "        ", "steps", "=", "[", "(", "forward_marks", ",", "forward_timestamps", ",", "self", ".", "forward_recurrent_net", ",", "self", ".", "forward_init_hidden_state", ")", "]", "\n", "if", "self", ".", "bidirectional", ":", "\n", "            ", "assert", "(", "backward_marks", "is", "not", "None", "and", "backward_timestamps", "is", "not", "None", ")", "\n", "steps", ".", "append", "(", "(", "backward_marks", ",", "backward_timestamps", ",", "self", ".", "backward_recurrent_net", ",", "self", ".", "backward_init_hidden_state", ")", ")", "\n", "\n", "", "last_hidden_states", "=", "[", "]", "\n", "for", "marks", ",", "timestamps", ",", "recurrent_net", ",", "init_hidden_state", "in", "steps", ":", "\n", "            ", "mark_embedding", "=", "self", ".", "channel_embedding", "(", "marks", ")", "\n", "time_embedding", "=", "self", ".", "time_embedding", "(", "timestamps", ")", "\n", "recurrent_input", "=", "torch", ".", "cat", "(", "(", "mark_embedding", ",", "time_embedding", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "hidden_states", "=", "recurrent_net", "(", "recurrent_input", ")", "[", "0", "]", "# output is a tuple, first element are all hidden states for last layer second is last hidden state for all layers", "\n", "last_hidden_states", ".", "append", "(", "hidden_states", ")", "\n", "\n", "", "return", "self", ".", "last_linear_layer", "(", "torch", ".", "cat", "(", "last_hidden_states", ",", "dim", "=", "-", "1", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.time_embedding.SinusoidalEmbedding.__init__": [[14, 27], ["torch.Module.__init__", "utils.xavier_truncated_normal", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "time_embedding.SinusoidalEmbedding.register_parameter", "time_embedding.SinusoidalEmbedding.register_buffer", "torch.Parameter", "torch.Parameter", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "math.log"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.xavier_truncated_normal"], ["def", "__init__", "(", "self", ",", "embedding_dim", ",", "learnable", "=", "False", ",", "random", "=", "False", ",", "max_period", "=", "10000.0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "random", "=", "random", "\n", "if", "random", ":", "\n", "            ", "weight", "=", "xavier_truncated_normal", "(", "size", "=", "embedding_dim", "//", "2", ",", "limit", "=", "2", ")", "\n", "", "else", ":", "\n", "            ", "weight", "=", "torch", ".", "exp", "(", "torch", ".", "arange", "(", "0", ",", "embedding_dim", ",", "2", ")", ".", "float", "(", ")", "*", "(", "-", "math", ".", "log", "(", "max_period", ")", "/", "embedding_dim", ")", ")", "\n", "\n", "", "if", "learnable", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'weight'", ",", "nn", ".", "Parameter", "(", "weight", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_buffer", "(", "'weight'", ",", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.time_embedding.SinusoidalEmbedding.forward": [[28, 32], ["torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "t", ")", ":", "\n", "        ", "sin_emb", "=", "torch", ".", "sin", "(", "t", "*", "self", ".", "weight", ")", "\n", "cos_emb", "=", "torch", ".", "cos", "(", "t", "*", "self", ".", "weight", ")", "\n", "return", "torch", ".", "cat", "(", "(", "sin_emb", ",", "cos_emb", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.time_embedding.ExponentialEmbedding.__init__": [[40, 46], ["time_embedding.SinusoidalEmbedding.__init__"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["def", "__init__", "(", "self", ",", "embedding_dim", ",", "learnable", "=", "True", ",", "random", "=", "True", ",", "max_period", "=", "10000.0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "embedding_dim", "=", "embedding_dim", "*", "(", "2", "if", "random", "else", "1", ")", ",", "#  If used in conjunction with SinusoidalEmbeddings, should follow the torch.cat(...) pattern ", "\n", "learnable", "=", "learnable", ",", "\n", "random", "=", "random", ",", "\n", "max_period", "=", "max_period", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.time_embedding.ExponentialEmbedding.forward": [[48, 54], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "time_embedding.ExponentialEmbedding.weight.abs"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "t", ")", ":", "\n", "        ", "embedding", "=", "torch", ".", "exp", "(", "-", "t", "*", "self", ".", "weight", ".", "abs", "(", ")", ")", "\n", "if", "self", ".", "random", ":", "\n", "            ", "return", "embedding", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "cat", "(", "(", "embedding", ",", "embedding", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.time_embedding.SinExpEmbedding.__init__": [[63, 87], ["torch.Module.__init__", "time_embedding.SinusoidalEmbedding", "time_embedding.ExponentialEmbedding"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["def", "__init__", "(", "self", ",", "embedding_dim", ",", "use_sinusoidal", "=", "True", ",", "use_exponential", "=", "False", ",", "sin_rand", "=", "False", ",", "exp_rand", "=", "False", ",", "max_period", "=", "10000.0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "(", "use_sinusoidal", "or", "use_exponential", ")", "\n", "\n", "if", "use_sinusoidal", ":", "\n", "            ", "self", ".", "sin_embed", "=", "SinusoidalEmbedding", "(", "\n", "embedding_dim", "=", "embedding_dim", ",", "\n", "learnable", "=", "sin_rand", ",", "# For now, assume if the weights are randomly initialized, then they are also learnable", "\n", "random", "=", "sin_rand", ",", "\n", "max_period", "=", "max_period", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "sin_embed", "=", "None", "\n", "\n", "", "if", "use_exponential", ":", "\n", "            ", "self", ".", "exp_embed", "=", "ExponentialEmbedding", "(", "\n", "embedding_dim", "=", "embedding_dim", ",", "\n", "learnable", "=", "exp_rand", ",", "# For now, assume if the weights are randomly initialized, then they are also learnable", "\n", "random", "=", "exp_rand", ",", "\n", "max_period", "=", "max_period", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "exp_embed", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.time_embedding.SinExpEmbedding.forward": [[88, 100], ["time_embedding.SinExpEmbedding.sin_embed", "time_embedding.SinExpEmbedding.exp_embed"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "t", ")", ":", "\n", "        ", "if", "self", ".", "sin_embed", ":", "\n", "            ", "sin_embedding", "=", "self", ".", "sin_embed", "(", "t", ")", "\n", "", "else", ":", "\n", "            ", "sin_embedding", "=", "1", "\n", "\n", "", "if", "self", ".", "exp_embed", ":", "\n", "            ", "exp_embedding", "=", "self", ".", "exp_embed", "(", "t", ")", "\n", "", "else", ":", "\n", "            ", "exp_embedding", "=", "1", "\n", "\n", "", "return", "sin_embedding", "*", "exp_embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.time_embedding.TemporalEmbedding.__init__": [[110, 154], ["torch.Module.__init__", "time_embedding.SinExpEmbedding", "time_embedding.SinExpEmbedding"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "embedding_dim", ",", "\n", "use_raw_time", "=", "True", ",", "\n", "use_delta_time", "=", "False", ",", "\n", "learnable_delta_weights", "=", "True", ",", "\n", "max_period", "=", "10000.0", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "(", "use_raw_time", "or", "use_delta_time", ")", "\n", "num_components", "=", "2", "if", "use_raw_time", "and", "use_delta_time", "else", "1", "\n", "\n", "if", "use_raw_time", ":", "\n", "            ", "if", "embedding_dim", "==", "1", ":", "\n", "                ", "self", ".", "raw_time_embed", "=", "lambda", "x", ":", "x", "#.unsqueeze(-1)", "\n", "", "else", ":", "\n", "                ", "self", ".", "raw_time_embed", "=", "SinExpEmbedding", "(", "\n", "embedding_dim", "=", "embedding_dim", "//", "num_components", ",", "\n", "use_sinusoidal", "=", "True", ",", "\n", "use_exponential", "=", "False", ",", "\n", "sin_rand", "=", "False", ",", "\n", "exp_rand", "=", "False", ",", "\n", "max_period", "=", "max_period", ",", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "raw_time_embed", "=", "None", "\n", "\n", "", "if", "use_delta_time", ":", "\n", "            ", "if", "embedding_dim", "==", "1", ":", "\n", "                ", "self", ".", "delta_time_embed", "=", "lambda", "x", ":", "x", "#.unsqueeze(-1)", "\n", "", "else", ":", "\n", "                ", "self", ".", "delta_time_embed", "=", "SinExpEmbedding", "(", "\n", "embedding_dim", "=", "embedding_dim", "//", "num_components", ",", "\n", "use_sinusoidal", "=", "True", ",", "\n", "use_exponential", "=", "True", ",", "\n", "sin_rand", "=", "False", ",", "\n", "exp_rand", "=", "True", ",", "\n", "max_period", "=", "max_period", ",", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "delta_time_embed", "=", "None", "\n", "\n", "", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.time_embedding.TemporalEmbedding.forward": [[155, 172], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.append", "torch.cat.append", "utils.find_closest", "torch.cat.append", "torch.cat.append", "time_embedding.TemporalEmbedding.raw_time_embed", "time_embedding.TemporalEmbedding.delta_time_embed", "t.unsqueeze", "delta_t.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.find_closest"], ["", "def", "forward", "(", "self", ",", "t", ",", "true_times", "=", "None", ")", ":", "\n", "# true_times are the timestamps of events that have actually happened", "\n", "# this is necessary as we sometimes sample for times that don't actually happen", "\n", "        ", "if", "true_times", "is", "None", ":", "\n", "            ", "true_times", "=", "t", "\n", "\n", "", "embeddings", "=", "[", "]", "\n", "if", "self", ".", "raw_time_embed", "is", "not", "None", ":", "\n", "            ", "embeddings", ".", "append", "(", "self", ".", "raw_time_embed", "(", "t", ".", "unsqueeze", "(", "-", "1", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "delta_time_embed", "is", "not", "None", ":", "\n", "            ", "closest_dict", "=", "find_closest", "(", "sample_times", "=", "t", ",", "true_times", "=", "true_times", ")", "\n", "delta_t", "=", "t", "-", "closest_dict", "[", "\"closest_values\"", "]", "\n", "embeddings", ".", "append", "(", "self", ".", "delta_time_embed", "(", "delta_t", ".", "unsqueeze", "(", "-", "1", ")", ")", ")", "\n", "\n", "", "embeddings", "=", "torch", ".", "cat", "(", "embeddings", ",", "dim", "=", "-", "1", ")", "\n", "return", "embeddings", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.IntensityNet.__init__": [[11, 57], ["torch.Module.__init__", "isinstance", "preprocessing_layers.extend", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "print", "print", "print", "torch.Linear", "torch.Linear", "torch.Linear", "print", "torch.Softplus", "torch.Softplus", "torch.Softplus", "print", "torch.Sequential", "torch.Sequential", "torch.Sequential", "print", "torch.Linear", "torch.Linear", "torch.Linear", "act_func", "torch.Dropout", "torch.Dropout", "torch.Dropout", "utils.flatten", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Linear", "torch.Linear", "torch.Linear", "act_func", "torch.Dropout", "torch.Dropout", "torch.Dropout", "range"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.flatten"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_embedding", ",", "\n", "input_size", ",", "\n", "hidden_size", ",", "\n", "num_layers", ",", "\n", "act_func", ",", "\n", "dropout", ",", "\n", "use_embedding_weights", "=", "False", ",", "\n", "factored_heads", "=", "True", ",", "\n", "zero_inflated", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "channel_embedding", "=", "channel_embedding", "\n", "self", ".", "input_size", "=", "input_size", "\n", "num_channels", ",", "channel_embedding_dim", "=", "channel_embedding", ".", "weight", ".", "shape", "\n", "\n", "if", "isinstance", "(", "act_func", ",", "str", ")", ":", "\n", "            ", "act_func", "=", "ACTIVATIONS", "[", "act_func", "]", "\n", "\n", "", "preprocessing_layers", "=", "[", "(", "nn", ".", "Linear", "(", "input_size", ",", "hidden_size", ")", ",", "act_func", "(", ")", ",", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", ")", "]", "\n", "preprocessing_layers", ".", "extend", "(", "[", "(", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", ",", "act_func", "(", ")", ",", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", ")", "for", "_", "in", "range", "(", "num_layers", "-", "1", ")", "]", ")", "\n", "self", ".", "preprocessing_net", "=", "nn", ".", "Sequential", "(", "*", "flatten", "(", "preprocessing_layers", ")", ")", "\n", "\n", "self", ".", "factored_heads", "=", "factored_heads", "\n", "self", ".", "mark_net", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "channel_embedding_dim", "if", "use_embedding_weights", "else", "num_channels", ")", "\n", "self", ".", "use_embedding_weights", "=", "use_embedding_weights", "\n", "if", "use_embedding_weights", ":", "\n", "            ", "print", "(", "\"USING EMBEDDING WEIGHTS\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"NOT USING EMBEDDING WEIGHTS\"", ")", "\n", "\n", "", "if", "factored_heads", ":", "\n", "            ", "print", "(", "\"FACTORED HEADS\"", ")", "\n", "self", ".", "intensity_net", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"NON FACTORED HEADS\"", ")", "\n", "self", ".", "softplus", "=", "nn", ".", "Softplus", "(", ")", "\n", "\n", "", "self", ".", "zero_inflated", "=", "zero_inflated", "\n", "if", "zero_inflated", ":", "\n", "            ", "print", "(", "\"ZERO INFLATED NHP\"", ")", "\n", "self", ".", "zero_prob_net", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "hidden_size", ",", "num_channels", ")", ",", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"NOT USING ZERO INFLATION\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.IntensityNet.forward": [[59, 87], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "decoder.IntensityNet.preprocessing_net", "decoder.IntensityNet.mark_net", "torch.linear", "torch.linear", "torch.linear", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "decoder.IntensityNet.intensity_net", "decoder.IntensityNet.exp().squeeze", "decoder.IntensityNet.softplus", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "decoder.IntensityNet.sum", "decoder.IntensityNet.zero_prob_net", "decoder.IntensityNet.log", "decoder.IntensityNet.exp"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "x", "=", "torch", ".", "cat", "(", "args", ",", "dim", "=", "-", "1", ")", "\n", "assert", "(", "x", ".", "shape", "[", "-", "1", "]", "==", "self", ".", "input_size", ")", "\n", "zero_probs", "=", "None", "\n", "\n", "pre_out", "=", "self", ".", "preprocessing_net", "(", "x", ")", "\n", "\n", "mark_net_out", "=", "self", ".", "mark_net", "(", "pre_out", ")", "\n", "if", "self", ".", "use_embedding_weights", ":", "\n", "            ", "mark_net_out", "=", "F", ".", "linear", "(", "mark_net_out", ",", "self", ".", "channel_embedding", ".", "weight", ")", "# No bias by default", "\n", "\n", "", "if", "self", ".", "factored_heads", ":", "\n", "            ", "log_mark_probs", "=", "F", ".", "log_softmax", "(", "mark_net_out", ",", "dim", "=", "-", "1", ")", "\n", "log_intensity", "=", "self", ".", "intensity_net", "(", "pre_out", ")", "\n", "all_log_mark_intensities", "=", "log_mark_probs", "+", "log_intensity", "\n", "total_intensity", "=", "log_intensity", ".", "exp", "(", ")", ".", "squeeze", "(", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "mark_net_out", "=", "self", ".", "softplus", "(", "mark_net_out", ")", "\n", "all_log_mark_intensities", "=", "torch", ".", "log", "(", "mark_net_out", "+", "1e-12", ")", "\n", "if", "self", ".", "zero_inflated", ":", "\n", "                ", "zero_probs", "=", "self", ".", "zero_prob_net", "(", "mark_net_out", ")", "\n", "all_log_mark_intensities", "+=", "zero_probs", ".", "log", "(", ")", "\n", "", "total_intensity", "=", "mark_net_out", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "", "return", "{", "\n", "\"all_log_mark_intensities\"", ":", "all_log_mark_intensities", ",", "\n", "\"total_intensity\"", ":", "total_intensity", ",", "\n", "\"zero_probs\"", ":", "zero_probs", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.PPDecoder.__init__": [[92, 149], ["torch.Module.__init__", "decoder.IntensityNet", "torch.GRU", "torch.GRU", "torch.GRU", "print", "torch.Sequential", "torch.Sequential", "torch.Sequential", "print", "decoder.PPDecoder.register_parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "utils.xavier_truncated_normal"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.xavier_truncated_normal"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_embedding", ",", "\n", "time_embedding", ",", "\n", "act_func", ",", "\n", "num_intensity_layers", ",", "\n", "intensity_hidden_size", ",", "\n", "num_recurrent_layers", ",", "\n", "recurrent_hidden_size", ",", "\n", "dropout", ",", "\n", "latent_size", "=", "None", ",", "\n", "factored_heads", "=", "True", ",", "\n", "estimate_init_state", "=", "True", ",", "\n", "use_embedding_weights", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "latent_size", "is", "None", ":", "\n", "            ", "latent_size", "=", "0", "\n", "", "self", ".", "channel_embedding", "=", "channel_embedding", "\n", "self", ".", "time_embedding", "=", "time_embedding", "\n", "self", ".", "channel_embedding_size", ",", "self", ".", "time_embedding_dim", "=", "self", ".", "channel_embedding", ".", "weight", ".", "shape", "[", "-", "1", "]", ",", "self", ".", "time_embedding", ".", "embedding_dim", "\n", "\n", "self", ".", "intensity_net", "=", "IntensityNet", "(", "\n", "channel_embedding", "=", "self", ".", "channel_embedding", ",", "\n", "input_size", "=", "latent_size", "+", "self", ".", "time_embedding_dim", "+", "recurrent_hidden_size", ",", "\n", "hidden_size", "=", "intensity_hidden_size", ",", "\n", "num_layers", "=", "num_intensity_layers", ",", "\n", "act_func", "=", "act_func", ",", "\n", "dropout", "=", "dropout", ",", "\n", "factored_heads", "=", "factored_heads", ",", "\n", "use_embedding_weights", "=", "use_embedding_weights", ",", "\n", ")", "\n", "\n", "self", ".", "recurrent_input_size", "=", "latent_size", "+", "self", ".", "channel_embedding_size", "+", "self", ".", "time_embedding_dim", "\n", "self", ".", "recurrent_net", "=", "nn", ".", "GRU", "(", "\n", "input_size", "=", "self", ".", "recurrent_input_size", ",", "\n", "hidden_size", "=", "recurrent_hidden_size", ",", "\n", "num_layers", "=", "num_recurrent_layers", ",", "\n", "bidirectional", "=", "False", ",", "\n", "dropout", "=", "dropout", ",", "\n", "batch_first", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "latent_size", "=", "latent_size", "\n", "self", ".", "num_recurrent_layers", "=", "num_recurrent_layers", "\n", "self", ".", "recurrent_hidden_size", "=", "recurrent_hidden_size", "\n", "self", ".", "estimate_init_state", "=", "(", "latent_size", "!=", "0", ")", "and", "estimate_init_state", "\n", "if", "self", ".", "estimate_init_state", ":", "\n", "            ", "print", "(", "\"ESTIMATING INITIAL STATE\"", ")", "\n", "self", ".", "init_hidden_state_network", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "latent_size", ",", "num_recurrent_layers", "*", "recurrent_hidden_size", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"NOT ESTIMATING INITIAL STATE\"", ")", "\n", "self", ".", "register_parameter", "(", "\n", "name", "=", "\"init_hidden_state\"", ",", "\n", "param", "=", "nn", ".", "Parameter", "(", "xavier_truncated_normal", "(", "size", "=", "(", "num_recurrent_layers", ",", "1", ",", "recurrent_hidden_size", ")", ",", "no_average", "=", "True", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.PPDecoder.get_states": [[151, 183], ["components.append", "components.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "decoder.PPDecoder.recurrent_net", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "decoder.PPDecoder.channel_embedding", "decoder.PPDecoder.time_embedding", "components.append", "decoder.PPDecoder.init_hidden_state_network().view", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "decoder.PPDecoder.init_hidden_state.expand().contiguous", "latent_state.unsqueeze().expand", "init_hidden_state[].unsqueeze", "decoder.PPDecoder.init_hidden_state_network", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "decoder.PPDecoder.init_hidden_state.expand", "latent_state.unsqueeze"], "methods", ["None"], ["", "", "def", "get_states", "(", "self", ",", "marks", ",", "timestamps", ",", "latent_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Produce the set of hidden states from a given set of marks, timestamps, and latent vector that can then be used to calculate intensities.\n        \n        Arguments:\n            marks {torch.LongTensor} -- Tensor containing mark ids that correspond to channel embeddings.\n            timestamps {torch.FloatTensor} -- Tensor containing times of events that correspond to the marks.\n\n        Keyword Arguments:\n            latent_state {torch.FloatTensor} -- Latent vector that [hopefully] summarizes relevant point process dynamics from a reference point pattern. (default: {None})\n        \n        Returns:\n            torch.FloatTensor -- Corresponding hidden states that represent the history of the point process.\n        \"\"\"", "\n", "\n", "components", "=", "[", "]", "\n", "components", ".", "append", "(", "self", ".", "channel_embedding", "(", "marks", ")", ")", "\n", "components", ".", "append", "(", "self", ".", "time_embedding", "(", "timestamps", ")", ")", "\n", "\n", "if", "latent_state", "is", "not", "None", ":", "\n", "             ", "components", ".", "append", "(", "latent_state", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "latent_state", ".", "shape", "[", "0", "]", ",", "timestamps", ".", "shape", "[", "1", "]", ",", "latent_state", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "recurrent_input", "=", "torch", ".", "cat", "(", "components", ",", "dim", "=", "-", "1", ")", "\n", "assert", "(", "recurrent_input", ".", "shape", "[", "-", "1", "]", "==", "self", ".", "recurrent_input_size", ")", "\n", "\n", "if", "self", ".", "estimate_init_state", ":", "\n", "            ", "init_hidden_state", "=", "self", ".", "init_hidden_state_network", "(", "latent_state", ")", ".", "view", "(", "-", "1", ",", "self", ".", "num_recurrent_layers", ",", "self", ".", "recurrent_hidden_size", ")", "\n", "init_hidden_state", "=", "torch", ".", "transpose", "(", "init_hidden_state", ",", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "", "else", ":", "\n", "            ", "init_hidden_state", "=", "self", ".", "init_hidden_state", ".", "expand", "(", "-", "1", ",", "recurrent_input", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ".", "contiguous", "(", ")", "# Match batch size", "\n", "", "hidden_states", ",", "_", "=", "self", ".", "recurrent_net", "(", "recurrent_input", ",", "init_hidden_state", ")", "\n", "\n", "return", "torch", ".", "cat", "(", "(", "init_hidden_state", "[", "-", "1", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", ",", "hidden_states", ")", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.PPDecoder.get_intensity": [[184, 211], ["utils.find_closest", "padded_state_values.gather", "decoder.PPDecoder.time_embedding", "decoder.PPDecoder.intensity_net", "components.append", "closest_dict[].unsqueeze().expand", "latent_state.unsqueeze().expand", "closest_dict[].unsqueeze", "latent_state.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.find_closest"], ["", "def", "get_intensity", "(", "self", ",", "state_values", ",", "state_times", ",", "timestamps", ",", "latent_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Gennerate intensity values for a point process.\n        \n        Arguments:\n            state_values {torch.FloatTensor} -- Output hidden states from `get_states` call.\n            state_times {torch.FloatTensor} -- Corresponding timestamps used to generate state_values. These are the \"true event times\" to be compared against.\n            timestamps {torch.FloatTensor} -- Times to generate intensity values for.\n        \n        Keyword Arguments:\n            latent_state {torch.FloatTensor} -- Latent vector that [hopefully] summarizes relevant point process dynamics from a reference point pattern. (default: {None})\n        \n        Returns:\n            [type] -- [description]\n        \"\"\"", "\n", "closest_dict", "=", "find_closest", "(", "sample_times", "=", "timestamps", ",", "true_times", "=", "state_times", ")", "\n", "\n", "padded_state_values", "=", "state_values", "\n", "\n", "selected_hidden_states", "=", "padded_state_values", ".", "gather", "(", "dim", "=", "1", ",", "index", "=", "closest_dict", "[", "\"closest_indices\"", "]", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "padded_state_values", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "\n", "time_embedding", "=", "self", ".", "time_embedding", "(", "timestamps", ",", "state_times", ")", "\n", "\n", "components", "=", "[", "time_embedding", ",", "selected_hidden_states", "]", "\n", "if", "latent_state", "is", "not", "None", ":", "\n", "            ", "components", ".", "append", "(", "latent_state", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "latent_state", ".", "shape", "[", "0", "]", ",", "timestamps", ".", "shape", "[", "1", "]", ",", "latent_state", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "return", "self", ".", "intensity_net", "(", "*", "components", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.__init__": [[215, 265], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "print", "torch.Linear", "torch.Linear", "torch.Linear", "print", "torch.Sequential", "torch.Sequential", "torch.Sequential", "print", "decoder.HawkesDecoder.register_parameter", "print", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Parameter", "torch.Parameter", "torch.Parameter", "utils.xavier_truncated_normal"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.xavier_truncated_normal"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_embedding", ",", "\n", "time_embedding", ",", "\n", "recurrent_hidden_size", ",", "\n", "latent_size", "=", "None", ",", "\n", "estimate_init_state", "=", "True", ",", "\n", "zero_inflated", "=", "False", ",", "\n", "personalized_head", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "latent_size", "is", "None", ":", "\n", "            ", "latent_size", "=", "0", "\n", "", "self", ".", "channel_embedding", "=", "channel_embedding", "\n", "self", ".", "time_embedding", "=", "time_embedding", "\n", "self", ".", "num_channels", ",", "self", ".", "channel_embedding_size", "=", "self", ".", "channel_embedding", ".", "weight", ".", "shape", "\n", "self", ".", "latent_size", "=", "latent_size", "\n", "\n", "self", ".", "recurrent_input_size", "=", "self", ".", "channel_embedding_size", "+", "recurrent_hidden_size", "+", "latent_size", "\n", "self", ".", "recurrent_hidden_size", "=", "recurrent_hidden_size", "\n", "self", ".", "cell_param_network", "=", "nn", ".", "Linear", "(", "self", ".", "recurrent_input_size", ",", "7", "*", "recurrent_hidden_size", ",", "bias", "=", "True", ")", "\n", "self", ".", "soft_plus_params", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "num_channels", ",", ")", "*", "0.0001", ")", "\n", "\n", "self", ".", "hidden_to_intensity_logits", "=", "nn", ".", "Linear", "(", "recurrent_hidden_size", ",", "self", ".", "num_channels", ")", "\n", "\n", "self", ".", "personalized_head", "=", "personalized_head", "\n", "if", "personalized_head", ":", "\n", "            ", "print", "(", "\"USING PERSONALIZED INTENSITY HEAD\"", ")", "\n", "self", ".", "user_emb_to_intensity_logits", "=", "nn", ".", "Linear", "(", "latent_size", ",", "self", ".", "num_channels", ",", "bias", "=", "True", ")", "\n", "self", ".", "user_emb_to_intensity_logits", ".", "weight", ".", "data", "=", "torch", ".", "rand_like", "(", "self", ".", "user_emb_to_intensity_logits", ".", "weight", ".", "data", ")", "*", "0.001", "\n", "self", ".", "user_emb_to_intensity_logits", ".", "bias", ".", "data", "=", "torch", ".", "rand_like", "(", "self", ".", "user_emb_to_intensity_logits", ".", "bias", ".", "data", ")", "*", "0.001", "\n", "\n", "\n", "", "self", ".", "estimate_init_state", "=", "estimate_init_state", "\n", "if", "self", ".", "estimate_init_state", ":", "\n", "            ", "print", "(", "\"ESTIMATING INITIAL STATE\"", ")", "\n", "self", ".", "init_hidden_state_network", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "latent_size", ",", "6", "*", "recurrent_hidden_size", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"NOT ESTIMATING INITIAL STATE\"", ")", "\n", "self", ".", "register_parameter", "(", "\n", "name", "=", "\"init_hidden_state\"", ",", "\n", "param", "=", "nn", ".", "Parameter", "(", "xavier_truncated_normal", "(", "size", "=", "(", "1", ",", "6", "*", "recurrent_hidden_size", ")", ",", "no_average", "=", "True", ")", ")", "\n", ")", "\n", "\n", "", "self", ".", "zero_inflated", "=", "zero_inflated", "\n", "if", "zero_inflated", ":", "\n", "            ", "print", "(", "\"ZERO INFLATED NEURAL HAWKES PROCESS\"", ")", "\n", "self", ".", "zero_prob_net", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "recurrent_hidden_size", ",", "self", ".", "num_channels", ")", ",", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.get_init_states": [[266, 274], ["torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "decoder.HawkesDecoder.init_hidden_state_network", "decoder.HawkesDecoder.init_hidden_state.expand", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.softplus", "torch.softplus", "torch.softplus", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "", "def", "get_init_states", "(", "self", ",", "batch_size", ",", "latent_state", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "estimate_init_state", ":", "\n", "            ", "init_states", "=", "self", ".", "init_hidden_state_network", "(", "latent_state", ")", "\n", "", "else", ":", "\n", "            ", "init_states", "=", "self", ".", "init_hidden_state", ".", "expand", "(", "batch_size", ",", "-", "1", ")", "\n", "", "h_d", ",", "c_d", ",", "c_bar", ",", "c", ",", "delta", ",", "o", "=", "torch", ".", "chunk", "(", "init_states", ",", "6", ",", "-", "1", ")", "\n", "\n", "return", "torch", ".", "tanh", "(", "h_d", ")", ",", "torch", ".", "tanh", "(", "c_d", ")", ",", "torch", ".", "tanh", "(", "c_bar", ")", ",", "torch", ".", "tanh", "(", "c", ")", ",", "F", ".", "softplus", "(", "delta", ")", ",", "torch", ".", "sigmoid", "(", "o", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.recurrence": [[275, 298], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.softplus", "torch.softplus", "torch.softplus", "decoder.HawkesDecoder.cell_param_network"], "methods", ["None"], ["", "def", "recurrence", "(", "self", ",", "emb_event_t", ",", "h_d_tm1", ",", "c_tm1", ",", "c_bar_tm1", ")", ":", "\n", "        ", "feed", "=", "torch", ".", "cat", "(", "(", "emb_event_t", ",", "h_d_tm1", ")", ",", "dim", "=", "1", ")", "\n", "# B * 2H", "\n", "(", "gate_i", ",", "\n", "gate_f", ",", "\n", "gate_z", ",", "\n", "gate_o", ",", "\n", "gate_i_bar", ",", "\n", "gate_f_bar", ",", "\n", "gate_delta", ")", "=", "torch", ".", "chunk", "(", "self", ".", "cell_param_network", "(", "feed", ")", ",", "7", ",", "-", "1", ")", "\n", "\n", "gate_i", "=", "torch", ".", "sigmoid", "(", "gate_i", ")", "\n", "gate_f", "=", "torch", ".", "sigmoid", "(", "gate_f", ")", "\n", "gate_z", "=", "torch", ".", "tanh", "(", "gate_z", ")", "\n", "gate_o", "=", "torch", ".", "sigmoid", "(", "gate_o", ")", "\n", "gate_i_bar", "=", "torch", ".", "sigmoid", "(", "gate_i_bar", ")", "\n", "gate_f_bar", "=", "torch", ".", "sigmoid", "(", "gate_f_bar", ")", "\n", "gate_delta", "=", "F", ".", "softplus", "(", "gate_delta", ")", "\n", "\n", "c_t", "=", "gate_f", "*", "c_tm1", "+", "gate_i", "*", "gate_z", "\n", "c_bar_t", "=", "gate_f_bar", "*", "c_bar_tm1", "+", "gate_i_bar", "*", "gate_z", "\n", "\n", "return", "c_t", ",", "c_bar_t", ",", "gate_o", ",", "gate_delta", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.decay": [[299, 306], ["torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "def", "decay", "(", "self", ",", "c_t", ",", "c_bar_t", ",", "o_t", ",", "delta_t", ",", "duration_t", ")", ":", "\n", "        ", "c_d_t", "=", "c_bar_t", "+", "(", "c_t", "-", "c_bar_t", ")", "*", "torch", ".", "exp", "(", "-", "delta_t", "*", "duration_t", ")", "\n", "\n", "h_d_t", "=", "o_t", "*", "torch", ".", "tanh", "(", "c_d_t", ")", "\n", "\n", "return", "c_d_t", ",", "h_d_t", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.get_states": [[307, 342], ["decoder.HawkesDecoder.time_embedding", "components.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "decoder.HawkesDecoder.get_init_states", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "decoder.HawkesDecoder.channel_embedding", "components.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "decoder.HawkesDecoder.recurrence", "decoder.HawkesDecoder.decay", "torch.stack.append", "torch.stack.append", "torch.stack.append", "latent_state.unsqueeze().expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "latent_state.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.RMTPPDecoder.get_init_states", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.recurrence", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.decay"], ["", "def", "get_states", "(", "self", ",", "marks", ",", "timestamps", ",", "latent_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Produce the set of hidden states from a given set of marks, timestamps, and latent vector that can then be used to calculate intensities.\n        \n        Arguments:\n            marks {torch.LongTensor} -- Tensor containing mark ids that correspond to channel embeddings.\n            timestamps {torch.FloatTensor} -- Tensor containing times of events that correspond to the marks.\n\n        Keyword Arguments:\n            latent_state {torch.FloatTensor} -- Latent vector that [hopefully] summarizes relevant point process dynamics from a reference point pattern. (default: {None})\n        \n        Returns:\n            torch.FloatTensor -- Corresponding hidden states that represent the history of the point process.\n        \"\"\"", "\n", "\n", "time_deltas", "=", "self", ".", "time_embedding", "(", "timestamps", ")", "\n", "\n", "components", "=", "[", "]", "\n", "components", ".", "append", "(", "self", ".", "channel_embedding", "(", "marks", ")", ")", "\n", "\n", "if", "latent_state", "is", "not", "None", ":", "\n", "             ", "components", ".", "append", "(", "latent_state", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "latent_state", ".", "shape", "[", "0", "]", ",", "timestamps", ".", "shape", "[", "1", "]", ",", "latent_state", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "recurrent_input", "=", "torch", ".", "cat", "(", "components", ",", "dim", "=", "-", "1", ")", "\n", "assert", "(", "recurrent_input", ".", "shape", "[", "-", "1", "]", "==", "(", "self", ".", "recurrent_input_size", "-", "self", ".", "recurrent_hidden_size", ")", ")", "\n", "\n", "h_d", ",", "c_d", ",", "c_bar", ",", "c", ",", "delta_t", ",", "o_t", "=", "self", ".", "get_init_states", "(", "time_deltas", ".", "shape", "[", "0", "]", ",", "latent_state", ")", "\n", "hidden_states", "=", "[", "torch", ".", "cat", "(", "(", "h_d", ",", "o_t", ",", "c_bar", ",", "c", ",", "delta_t", ")", ",", "-", "1", ")", "]", "\n", "for", "i", "in", "range", "(", "time_deltas", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "r_input", ",", "t_input", "=", "recurrent_input", "[", ":", ",", "i", ",", ":", "]", ",", "time_deltas", "[", ":", ",", "i", ",", ":", "]", "\n", "c", ",", "c_bar", ",", "o_t", ",", "delta_t", "=", "self", ".", "recurrence", "(", "r_input", ",", "h_d", ",", "c_d", ",", "c_bar", ")", "\n", "c_d", ",", "h_d", "=", "self", ".", "decay", "(", "c", ",", "c_bar", ",", "o_t", ",", "delta_t", ",", "t_input", ")", "\n", "hidden_states", ".", "append", "(", "torch", ".", "cat", "(", "(", "h_d", ",", "o_t", ",", "c_bar", ",", "c", ",", "delta_t", ")", ",", "-", "1", ")", ")", "\n", "\n", "", "hidden_states", "=", "torch", ".", "stack", "(", "hidden_states", ",", "dim", "=", "1", ")", "\n", "return", "hidden_states", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.get_intensity": [[343, 384], ["utils.find_closest", "padded_state_values.gather", "decoder.HawkesDecoder.time_embedding", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "decoder.HawkesDecoder.decay", "torch.softplus", "torch.softplus", "torch.softplus", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.softplus.sum", "decoder.HawkesDecoder.user_emb_to_intensity_logits().unsqueeze", "decoder.HawkesDecoder.zero_prob_net", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "closest_dict[].unsqueeze().expand", "decoder.HawkesDecoder.hidden_to_intensity_logits", "decoder.HawkesDecoder.user_emb_to_intensity_logits", "closest_dict[].unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.find_closest", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.HawkesDecoder.decay"], ["", "def", "get_intensity", "(", "self", ",", "state_values", ",", "state_times", ",", "timestamps", ",", "latent_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Gennerate intensity values for a point process.\n        \n        Arguments:\n            state_values {torch.FloatTensor} -- Output hidden states from `get_states` call.\n            state_times {torch.FloatTensor} -- Corresponding timestamps used to generate state_values. These are the \"true event times\" to be compared against.\n            timestamps {torch.FloatTensor} -- Times to generate intensity values for.\n        \n        Keyword Arguments:\n            latent_state {torch.FloatTensor} -- Latent vector that [hopefully] summarizes relevant point process dynamics from a reference point pattern. (default: {None})\n        \n        Returns:\n            [type] -- [description]\n        \"\"\"", "\n", "closest_dict", "=", "find_closest", "(", "sample_times", "=", "timestamps", ",", "true_times", "=", "state_times", ")", "\n", "zero_probs", "=", "None", "\n", "\n", "padded_state_values", "=", "state_values", "\n", "\n", "selected_hidden_states", "=", "padded_state_values", ".", "gather", "(", "dim", "=", "1", ",", "index", "=", "closest_dict", "[", "\"closest_indices\"", "]", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "padded_state_values", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "time_embedding", "=", "self", ".", "time_embedding", "(", "timestamps", ",", "state_times", ")", "\n", "h_d", ",", "o_t", ",", "c_bar", ",", "c", ",", "delta_t", "=", "torch", ".", "chunk", "(", "selected_hidden_states", ",", "5", ",", "-", "1", ")", "\n", "\n", "_", ",", "h_t", "=", "self", ".", "decay", "(", "c", ",", "c_bar", ",", "o_t", ",", "delta_t", ",", "time_embedding", ")", "\n", "\n", "if", "self", ".", "personalized_head", ":", "\n", "            ", "user_emb_logits", "=", "self", ".", "user_emb_to_intensity_logits", "(", "latent_state", ")", ".", "unsqueeze", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "user_emb_logits", "=", "0", "\n", "\n", "", "intensity_values", "=", "F", ".", "softplus", "(", "self", ".", "hidden_to_intensity_logits", "(", "h_t", ")", "+", "user_emb_logits", ")", "\n", "all_log_mark_intensities", "=", "torch", ".", "log", "(", "intensity_values", "+", "1e-12", ")", "\n", "if", "self", ".", "zero_inflated", ":", "\n", "            ", "zero_probs", "=", "self", ".", "zero_prob_net", "(", "h_t", ")", "\n", "all_log_mark_intensities", "+=", "torch", ".", "log", "(", "zero_probs", "+", "1e-12", ")", "\n", "", "total_intensity", "=", "intensity_values", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "return", "{", "\n", "\"all_log_mark_intensities\"", ":", "all_log_mark_intensities", ",", "\n", "\"total_intensity\"", ":", "total_intensity", ",", "\n", "\"zero_probs\"", ":", "zero_probs", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.RMTPPDecoder.__init__": [[389, 448], ["torch.Module.__init__", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "print", "torch.Linear", "torch.Linear", "torch.Linear", "print", "torch.Sequential", "torch.Sequential", "torch.Sequential", "print", "decoder.RMTPPDecoder.register_parameter", "print", "torch.Sequential", "torch.Sequential", "torch.Sequential", "print", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Parameter", "torch.Parameter", "torch.Parameter", "utils.xavier_truncated_normal"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.xavier_truncated_normal"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channel_embedding", ",", "\n", "time_embedding", ",", "\n", "recurrent_hidden_size", ",", "\n", "latent_size", "=", "None", ",", "\n", "estimate_init_state", "=", "True", ",", "\n", "zero_inflated", "=", "False", ",", "\n", "personalized_head", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "latent_size", "is", "None", ":", "\n", "            ", "latent_size", "=", "0", "\n", "", "self", ".", "channel_embedding", "=", "channel_embedding", "\n", "self", ".", "time_embedding", "=", "time_embedding", "\n", "self", ".", "num_channels", ",", "self", ".", "channel_embedding_size", "=", "self", ".", "channel_embedding", ".", "weight", ".", "shape", "\n", "self", ".", "latent_size", "=", "latent_size", "\n", "self", ".", "personalized_head", "=", "personalized_head", "\n", "\n", "self", ".", "recurrent_input_size", "=", "self", ".", "channel_embedding_size", "+", "latent_size", "+", "self", ".", "time_embedding", ".", "embedding_dim", "\n", "self", ".", "recurrent_hidden_size", "=", "recurrent_hidden_size", "\n", "self", ".", "recurrent_net", "=", "nn", ".", "LSTM", "(", "\n", "input_size", "=", "self", ".", "recurrent_input_size", ",", "\n", "hidden_size", "=", "self", ".", "recurrent_hidden_size", ",", "\n", "num_layers", "=", "1", ",", "\n", "bidirectional", "=", "False", ",", "\n", "batch_first", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "hidden_to_intensity_logits", "=", "nn", ".", "Linear", "(", "recurrent_hidden_size", ",", "self", ".", "num_channels", ")", "\n", "self", ".", "time_to_intensity_logits", "=", "nn", ".", "Linear", "(", "1", ",", "self", ".", "num_channels", ")", "\n", "self", ".", "time_to_intensity_logits", ".", "weight", ".", "data", "=", "torch", ".", "rand_like", "(", "self", ".", "time_to_intensity_logits", ".", "weight", ".", "data", ")", "*", "0.001", "\n", "self", ".", "time_to_intensity_logits", ".", "bias", ".", "data", "=", "torch", ".", "rand_like", "(", "self", ".", "time_to_intensity_logits", ".", "bias", ".", "data", ")", "*", "0.001", "\n", "\n", "if", "personalized_head", ":", "\n", "            ", "print", "(", "\"USING PERSONALIZED INTENSITY HEAD\"", ")", "\n", "self", ".", "user_emb_to_intensity_logits", "=", "nn", ".", "Linear", "(", "latent_size", ",", "self", ".", "num_channels", ",", "bias", "=", "False", ")", "\n", "self", ".", "user_emb_to_intensity_logits", ".", "weight", ".", "data", "=", "torch", ".", "rand_like", "(", "self", ".", "user_emb_to_intensity_logits", ".", "weight", ".", "data", ")", "*", "0.001", "\n", "\n", "\n", "", "self", ".", "estimate_init_state", "=", "estimate_init_state", "\n", "if", "self", ".", "estimate_init_state", ":", "\n", "            ", "print", "(", "\"ESTIMATING INITIAL STATE\"", ")", "\n", "self", ".", "init_hidden_state_network", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "latent_size", ",", "2", "*", "recurrent_hidden_size", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"NOT ESTIMATING INITIAL STATE\"", ")", "\n", "self", ".", "register_parameter", "(", "\n", "name", "=", "\"init_hidden_state\"", ",", "\n", "param", "=", "nn", ".", "Parameter", "(", "xavier_truncated_normal", "(", "size", "=", "(", "1", ",", "1", ",", "2", "*", "recurrent_hidden_size", ")", ",", "no_average", "=", "True", ")", ")", "\n", ")", "\n", "\n", "", "self", ".", "zero_inflated", "=", "zero_inflated", "\n", "if", "zero_inflated", ":", "\n", "            ", "print", "(", "\"ZERO INFLATED RMTPP\"", ")", "\n", "self", ".", "zero_prob_net", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "recurrent_hidden_size", ",", "self", ".", "num_channels", ")", ",", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"NOT USING ZERO INFLATION\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.RMTPPDecoder.get_init_states": [[450, 458], ["torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "decoder.RMTPPDecoder.init_hidden_state_network().unsqueeze", "decoder.RMTPPDecoder.init_hidden_state.expand", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "decoder.RMTPPDecoder.init_hidden_state_network"], "methods", ["None"], ["", "", "def", "get_init_states", "(", "self", ",", "batch_size", ",", "latent_state", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "estimate_init_state", ":", "\n", "            ", "init_states", "=", "self", ".", "init_hidden_state_network", "(", "latent_state", ")", ".", "unsqueeze", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "init_states", "=", "self", ".", "init_hidden_state", ".", "expand", "(", "1", ",", "batch_size", ",", "-", "1", ")", "\n", "", "h_0", ",", "c_0", "=", "torch", ".", "chunk", "(", "init_states", ",", "2", ",", "-", "1", ")", "\n", "\n", "return", "torch", ".", "tanh", "(", "h_0", ")", ",", "torch", ".", "tanh", "(", "c_0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.RMTPPDecoder.get_states": [[459, 493], ["decoder.RMTPPDecoder.time_embedding", "components.append", "components.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "decoder.RMTPPDecoder.get_init_states", "decoder.RMTPPDecoder.recurrent_net", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "decoder.RMTPPDecoder.channel_embedding", "components.append", "init_state[].squeeze().unsqueeze", "latent_state.unsqueeze().expand", "init_state[].squeeze", "latent_state.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.RMTPPDecoder.get_init_states"], ["", "def", "get_states", "(", "self", ",", "marks", ",", "timestamps", ",", "latent_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Produce the set of hidden states from a given set of marks, timestamps, and latent vector that can then be used to calculate intensities.\n        \n        Arguments:\n            marks {torch.LongTensor} -- Tensor containing mark ids that correspond to channel embeddings.\n            timestamps {torch.FloatTensor} -- Tensor containing times of events that correspond to the marks.\n\n        Keyword Arguments:\n            latent_state {torch.FloatTensor} -- Latent vector that [hopefully] summarizes relevant point process dynamics from a reference point pattern. (default: {None})\n        \n        Returns:\n            torch.FloatTensor -- Corresponding hidden states that represent the history of the point process.\n        \"\"\"", "\n", "\n", "time_deltas", "=", "self", ".", "time_embedding", "(", "timestamps", ")", "\n", "\n", "components", "=", "[", "]", "\n", "components", ".", "append", "(", "self", ".", "channel_embedding", "(", "marks", ")", ")", "\n", "components", ".", "append", "(", "time_deltas", ")", "\n", "\n", "if", "latent_state", "is", "not", "None", ":", "\n", "             ", "components", ".", "append", "(", "latent_state", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "latent_state", ".", "shape", "[", "0", "]", ",", "timestamps", ".", "shape", "[", "1", "]", ",", "latent_state", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "recurrent_input", "=", "torch", ".", "cat", "(", "components", ",", "dim", "=", "-", "1", ")", "\n", "assert", "(", "recurrent_input", ".", "shape", "[", "-", "1", "]", "==", "(", "self", ".", "recurrent_input_size", ")", ")", "\n", "\n", "init_state", "=", "self", ".", "get_init_states", "(", "time_deltas", ".", "shape", "[", "0", "]", ",", "latent_state", ")", "\n", "\n", "hidden_states", "=", "[", "init_state", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "unsqueeze", "(", "1", ")", "]", "\n", "output_hidden_states", ",", "(", "ohs", ",", "ocs", ")", "=", "self", ".", "recurrent_net", "(", "recurrent_input", ",", "init_state", ")", "\n", "hidden_states", ".", "append", "(", "output_hidden_states", ")", "\n", "\n", "hidden_states", "=", "torch", ".", "cat", "(", "hidden_states", ",", "dim", "=", "1", ")", "\n", "return", "hidden_states", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.decoder.RMTPPDecoder.get_intensity": [[494, 536], ["utils.find_closest", "padded_state_values.gather", "decoder.RMTPPDecoder.time_embedding", "decoder.RMTPPDecoder.hidden_to_intensity_logits", "decoder.RMTPPDecoder.time_to_intensity_logits", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp.sum", "torch.exp.sum", "torch.exp.sum", "decoder.RMTPPDecoder.user_emb_to_intensity_logits().unsqueeze", "decoder.RMTPPDecoder.zero_prob_net", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "closest_dict[].unsqueeze().expand", "decoder.RMTPPDecoder.user_emb_to_intensity_logits", "closest_dict[].unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.find_closest"], ["", "def", "get_intensity", "(", "self", ",", "state_values", ",", "state_times", ",", "timestamps", ",", "latent_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Gennerate intensity values for a point process.\n        \n        Arguments:\n            state_values {torch.FloatTensor} -- Output hidden states from `get_states` call.\n            state_times {torch.FloatTensor} -- Corresponding timestamps used to generate state_values. These are the \"true event times\" to be compared against.\n            timestamps {torch.FloatTensor} -- Times to generate intensity values for.\n        \n        Keyword Arguments:\n            latent_state {torch.FloatTensor} -- Latent vector that [hopefully] summarizes relevant point process dynamics from a reference point pattern. (default: {None})\n        \n        Returns:\n            [type] -- [description]\n        \"\"\"", "\n", "closest_dict", "=", "find_closest", "(", "sample_times", "=", "timestamps", ",", "true_times", "=", "state_times", ")", "\n", "zero_probs", "=", "None", "\n", "\n", "padded_state_values", "=", "state_values", "\n", "\n", "selected_hidden_states", "=", "padded_state_values", ".", "gather", "(", "dim", "=", "1", ",", "index", "=", "closest_dict", "[", "\"closest_indices\"", "]", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "padded_state_values", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "time_embedding", "=", "self", ".", "time_embedding", "(", "timestamps", ",", "state_times", ")", "\n", "\n", "hs_logits", "=", "self", ".", "hidden_to_intensity_logits", "(", "selected_hidden_states", ")", "\n", "time_logits", "=", "self", ".", "time_to_intensity_logits", "(", "time_embedding", ")", "\n", "\n", "all_log_mark_intensities", "=", "hs_logits", "+", "time_logits", "\n", "\n", "if", "self", ".", "personalized_head", ":", "\n", "            ", "user_emb_logits", "=", "self", ".", "user_emb_to_intensity_logits", "(", "latent_state", ")", ".", "unsqueeze", "(", "1", ")", "\n", "all_log_mark_intensities", "+=", "user_emb_logits", "\n", "\n", "", "if", "self", ".", "zero_inflated", ":", "\n", "            ", "zero_probs", "=", "self", ".", "zero_prob_net", "(", "h_t", ")", "\n", "all_log_mark_intensities", "+=", "torch", ".", "log", "(", "zero_probs", "+", "1e-12", ")", "\n", "\n", "", "intensity_values", "=", "torch", ".", "exp", "(", "all_log_mark_intensities", ")", "\n", "total_intensity", "=", "intensity_values", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "return", "{", "\n", "\"all_log_mark_intensities\"", ":", "all_log_mark_intensities", ",", "\n", "\"total_intensity\"", ":", "total_intensity", ",", "\n", "\"zero_probs\"", ":", "zero_probs", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.aggregator.PPAggregator.__init__": [[12, 25], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["def", "__init__", "(", "self", ",", "method", ",", "hidden_size", ",", "latent_size", ",", "noise", "=", "True", ",", "q_z_x", "=", "torch", ".", "distributions", ".", "Laplace", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "noise", "=", "noise", "\n", "\n", "if", "method", "==", "\"concat\"", ":", "\n", "            ", "self", ".", "method", "=", "self", ".", "_concat", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "\n", "\n", "", "self", ".", "mu_network", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "latent_size", ")", "\n", "self", ".", "sigma_network", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "latent_size", ")", "\n", "self", ".", "q_z_x", "=", "q_z_x", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.aggregator.PPAggregator._concat": [[26, 31], ["hidden_states.gather().squeeze", "len", "len", "hidden_states.gather", "context_lengths.unsqueeze().expand", "context_lengths.unsqueeze"], "methods", ["None"], ["", "def", "_concat", "(", "self", ",", "hidden_states", ",", "context_lengths", ")", ":", "\n", "        ", "assert", "(", "len", "(", "hidden_states", ".", "shape", ")", "==", "3", ")", "\n", "assert", "(", "len", "(", "context_lengths", ".", "shape", ")", "==", "2", ")", "\n", "\n", "return", "hidden_states", ".", "gather", "(", "dim", "=", "1", ",", "index", "=", "context_lengths", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "hidden_states", ".", "shape", "[", "-", "1", "]", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.aggregator.PPAggregator.forward": [[32, 54], ["aggregator.PPAggregator.method", "aggregator.PPAggregator.mu_network", "aggregator.PPAggregator.sigma_network", "aggregator.PPAggregator.q_z_x", "aggregator.PPAggregator.rsample", "torch.softmax", "torch.softmax", "torch.softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "hidden_states", ",", "context_lengths", ",", "sample_override", "=", "False", ")", ":", "\n", "        ", "extracted_states", "=", "self", ".", "method", "(", "hidden_states", ",", "context_lengths", ")", "\n", "\n", "mu", "=", "self", ".", "mu_network", "(", "extracted_states", ")", "\n", "if", "not", "self", ".", "noise", ":", "\n", "            ", "return", "{", "\n", "\"latent_state\"", ":", "mu", ",", "\n", "\"q_z_x\"", ":", "None", ",", "\n", "}", "\n", "", "sigma", "=", "self", ".", "sigma_network", "(", "extracted_states", ")", "#F.softplus(self.sigma_network(extracted_states))", "\n", "sigma", "=", "F", ".", "softmax", "(", "sigma", ",", "dim", "=", "-", "1", ")", "*", "sigma", ".", "shape", "[", "-", "1", "]", "+", "1e-6", "\n", "\n", "q_z_x", "=", "self", ".", "q_z_x", "(", "mu", ",", "sigma", ")", "\n", "\n", "if", "self", ".", "training", "or", "sample_override", ":", "\n", "            ", "latent_state", "=", "q_z_x", ".", "rsample", "(", ")", "\n", "", "else", ":", "\n", "            ", "latent_state", "=", "mu", "\n", "\n", "", "return", "{", "\n", "\"latent_state\"", ":", "latent_state", ",", "\n", "\"q_z_x\"", ":", "q_z_x", ",", "\n", "}", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.Log.__init__": [[8, 10], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["\n", "", "def", "compute_kernel", "(", "x", ",", "y", ")", ":", "\n", "    ", "x_size", "=", "x", ".", "size", "(", "0", ")", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.Log.forward": [[11, 13], ["torch.log"], "methods", ["None"], ["y_size", "=", "y", ".", "size", "(", "0", ")", "\n", "dim", "=", "x", ".", "size", "(", "1", ")", "\n", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", "# (x_size, 1, dim)", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.Identity.__init__": [[16, 18], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["tiled_y", "=", "y", ".", "expand", "(", "x_size", ",", "y_size", ",", "dim", ")", "\n", "kernel_input", "=", "(", "tiled_x", "-", "tiled_y", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", "2", ")", "/", "float", "(", "dim", ")", "\n", "return", "torch", ".", "exp", "(", "-", "kernel_input", ")", "# (x_size, y_size)", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.Identity.forward": [[19, 21], ["None"], "methods", ["None"], ["\n", "", "def", "compute_mmd", "(", "x", ",", "y", ")", ":", "\n", "    ", "x_kernel", "=", "compute_kernel", "(", "x", ",", "x", ")", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.GELU.__init__": [[24, 26], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["mmd", "=", "x_kernel", ".", "mean", "(", ")", "+", "y_kernel", ".", "mean", "(", ")", "-", "2", "*", "xy_kernel", ".", "mean", "(", ")", "\n", "return", "mmd", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.GELU.forward": [[27, 29], ["torch.tanh", "math.sqrt", "torch.pow"], "methods", ["None"], ["", "def", "kl_div", "(", "d1", ",", "d2", ",", "K", "=", "100", ")", ":", "\n", "    ", "\"\"\"Computes closed-form KL if available, else computes a MC estimate.\"\"\"", "\n", "if", "(", "type", "(", "d1", ")", ",", "type", "(", "d2", ")", ")", "in", "torch", ".", "distributions", ".", "kl", ".", "_KL_REGISTRY", ":", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.truncated_normal": [[40, 54], ["torch.fmod", "torch.randn"], "function", ["None"], ["", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.xavier_truncated_normal": [[55, 67], ["isinstance", "utils.truncated_normal", "len"], "function", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.truncated_normal"], []], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.flatten": [[68, 71], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.modules.utils.find_closest": [[72, 101], ["torch.cat", "torch.cat.unsqueeze().expand", "expanded_true_times.permute.permute", "torch.where", "torch.where.max", "sample_times.unsqueeze", "torch.cat.unsqueeze", "list", "float", "range", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.hawkes.HawkesModel.__init__": [[10, 42], ["model.PPModel.__init__", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "num_marks", ",", "\n", "bounded", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Constructor for general PPModel class.\n        \n        Arguments:\n            decoder {torch.nn.Module} -- Neural network decoder that accepts a latent state, marks, timestamps, and times of sample points. \n\n        Keyword Arguments:\n            time_embedding {torch.nn.Module} -- Function to transform k-dimensional timestamps into (k+1)-dimensional embedded vectors. If specified, will make encoder and decoder share this function. (default: {None})\n            encoder {torch.nn.Module} -- Neural network encoder that accepts marks and timestamps and returns a single latent state (default: {None})\n            aggregator {torch.nn.Module} -- Module that turns a tensor of hidden states into a latent vector (with noise added during training) (default: {None})\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "decoder", "=", "None", ")", "\n", "\n", "self", ".", "num_marks", "=", "num_marks", "\n", "self", ".", "alphas", "=", "torch", ".", "nn", ".", "Embedding", "(", "\n", "num_embeddings", "=", "num_marks", ",", "\n", "embedding_dim", "=", "num_marks", ",", "\n", ")", "\n", "self", ".", "deltas", "=", "torch", ".", "nn", ".", "Embedding", "(", "\n", "num_embeddings", "=", "num_marks", ",", "\n", "embedding_dim", "=", "num_marks", ",", "\n", ")", "\n", "self", ".", "alphas", ".", "weight", ".", "data", "=", "torch", ".", "randn_like", "(", "self", ".", "alphas", ".", "weight", ".", "data", ")", "*", "0.0001", "\n", "self", ".", "deltas", ".", "weight", ".", "data", "=", "torch", ".", "randn_like", "(", "self", ".", "deltas", ".", "weight", ".", "data", ")", "*", "0.0001", "\n", "\n", "self", ".", "mus", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "num_marks", ",", ")", "*", "0.0001", ")", "\n", "self", ".", "s", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "num_marks", ",", ")", "*", "0.0001", ")", "\n", "self", ".", "bounded", "=", "bounded", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.hawkes.HawkesModel.get_states": [[43, 49], ["None"], "methods", ["None"], ["", "def", "get_states", "(", "self", ",", "tgt_marks", ",", "tgt_timestamps", ",", "latent_state", ")", ":", "\n", "        ", "\"\"\"Get the hidden states that can be used to extract intensity values from.\"\"\"", "\n", "\n", "return", "{", "\n", "\"state_values\"", ":", "tgt_marks", ",", "\n", "\"state_times\"", ":", "tgt_timestamps", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.hawkes.HawkesModel.get_intensity": [[51, 91], ["mu.unsqueeze().unsqueeze().expand.unsqueeze().unsqueeze().expand.unsqueeze().unsqueeze().expand", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.transpose().contiguous", "torch.relu", "torch.relu", "torch.relu", "time_diffs.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "all_mark_intensities.log", "all_mark_intensities.sum", "hawkes.HawkesModel.alphas", "hawkes.HawkesModel.deltas", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.where.sum", "torch.where.sum", "torch.where.sum", "hawkes.HawkesModel.s.unsqueeze().unsqueeze().expand().exp", "intensity_dict[].gather().squeeze", "mu.unsqueeze().unsqueeze().expand.unsqueeze().unsqueeze().expand.exp", "torch.transpose().contiguous.exp", "torch.transpose().contiguous.exp", "torch.transpose().contiguous.exp", "torch.transpose().contiguous.exp", "torch.transpose().contiguous.exp", "torch.transpose().contiguous.exp", "mu.unsqueeze().unsqueeze().expand.unsqueeze().unsqueeze().expand.unsqueeze().unsqueeze", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "timestamps.unsqueeze", "state_times.unsqueeze", "time_diffs.unsqueeze().expand.unsqueeze().expand.unsqueeze", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.transpose().contiguous.unsqueeze().expand", "torch.transpose().contiguous.unsqueeze().expand", "torch.transpose().contiguous.unsqueeze().expand", "torch.transpose().contiguous.unsqueeze().expand", "torch.transpose().contiguous.unsqueeze().expand", "torch.transpose().contiguous.unsqueeze().expand", "hawkes.HawkesModel.s.unsqueeze().unsqueeze().expand", "intensity_dict[].gather", "mu.unsqueeze().unsqueeze().expand.unsqueeze().unsqueeze().expand.unsqueeze", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.transpose().contiguous.unsqueeze", "torch.transpose().contiguous.unsqueeze", "torch.transpose().contiguous.unsqueeze", "torch.transpose().contiguous.unsqueeze", "torch.transpose().contiguous.unsqueeze", "torch.transpose().contiguous.unsqueeze", "hawkes.HawkesModel.s.unsqueeze().unsqueeze", "marks.unsqueeze", "hawkes.HawkesModel.s.unsqueeze"], "methods", ["None"], ["", "def", "get_intensity", "(", "self", ",", "state_values", ",", "state_times", ",", "timestamps", ",", "latent_state", ",", "marks", "=", "None", ")", ":", "\n", "        ", "\"\"\"Given a set of hidden states, timestamps, and latent_state get a tensor representing intensity values at timestamps.\n        Specify marks to get intensity values for specific channels.\"\"\"", "\n", "\n", "batch_size", ",", "seq_len", "=", "timestamps", ".", "shape", "\n", "hist_len", "=", "state_times", ".", "shape", "[", "1", "]", "\n", "num_marks", "=", "self", ".", "num_marks", "\n", "\n", "mu", ",", "alpha", ",", "delta", "=", "self", ".", "mus", ",", "self", ".", "alphas", "(", "state_values", ")", ",", "self", ".", "deltas", "(", "state_values", ")", "\n", "if", "self", ".", "bounded", ":", "\n", "            ", "mu", ",", "alpha", ",", "delta", "=", "mu", ".", "exp", "(", ")", ",", "alpha", ".", "exp", "(", ")", ",", "delta", ".", "exp", "(", ")", "\n", "", "mu", "=", "mu", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "batch_size", ",", "seq_len", ",", "-", "1", ")", "\n", "alpha", "=", "torch", ".", "transpose", "(", "alpha", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "-", "1", ",", "seq_len", ")", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "delta", "=", "torch", ".", "transpose", "(", "delta", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "-", "1", ",", "seq_len", ")", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "\n", "time_diffs", "=", "F", ".", "relu", "(", "timestamps", ".", "unsqueeze", "(", "2", ")", "-", "state_times", ".", "unsqueeze", "(", "1", ")", ")", "\n", "time_diffs", "=", "time_diffs", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "num_marks", ",", "-", "1", ")", "\n", "valid_terms", "=", "time_diffs", ">", "0", "\n", "\n", "prod", "=", "alpha", "*", "(", "-", "1", "*", "delta", "*", "time_diffs", ")", ".", "exp", "(", ")", "\n", "prod", "=", "torch", ".", "where", "(", "valid_terms", ",", "prod", ",", "torch", ".", "zeros_like", "(", "prod", ")", ")", "\n", "\n", "all_mark_intensities", "=", "mu", "+", "prod", ".", "sum", "(", "-", "1", ")", "\n", "\n", "if", "not", "self", ".", "bounded", ":", "\n", "            ", "s", "=", "self", ".", "s", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "batch_size", ",", "seq_len", ",", "-", "1", ")", ".", "exp", "(", ")", "\n", "all_mark_intensities", "=", "s", "*", "torch", ".", "log", "(", "1", "+", "torch", ".", "exp", "(", "all_mark_intensities", "/", "s", ")", ")", "\n", "\n", "", "all_log_mark_intensities", "=", "all_mark_intensities", ".", "log", "(", ")", "\n", "total_intensity", "=", "all_mark_intensities", ".", "sum", "(", "-", "1", ")", "\n", "\n", "intensity_dict", "=", "{", "\n", "\"all_log_mark_intensities\"", ":", "all_log_mark_intensities", ",", "\n", "\"total_intensity\"", ":", "total_intensity", ",", "\n", "}", "\n", "\n", "if", "marks", "is", "not", "None", ":", "\n", "            ", "intensity_dict", "[", "\"log_mark_intensity\"", "]", "=", "intensity_dict", "[", "\"all_log_mark_intensities\"", "]", ".", "gather", "(", "dim", "=", "-", "1", ",", "index", "=", "marks", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "", "return", "intensity_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.hawkes.HawkesModel.forward": [[92, 155], ["hawkes.HawkesModel.get_states", "hawkes.HawkesModel.get_intensity", "hawkes.HawkesModel.get_intensity"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_states", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_intensity", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_intensity"], ["", "def", "forward", "(", "self", ",", "ref_marks", ",", "ref_timestamps", ",", "ref_marks_bwd", ",", "ref_timestamps_bwd", ",", "tgt_marks", ",", "tgt_timestamps", ",", "context_lengths", ",", "sample_timestamps", "=", "None", ",", "pp_id", "=", "None", ")", ":", "\n", "        ", "\"\"\"Encodes a(n optional) set of marks and timestamps into a latent vector, \n        then decodes corresponding intensity values for a target set of timestamps and marks \n        (as well as a sample set if specified).\n        \n        Arguments:\n            ref_marks {torch.LongTensor} -- Tensor containing mark ids that correspond to channel embeddings. Part of the reference set to be encoded.\n            ref_timestamps {torch.FloatTensor} -- Tensor containing times that correspond to the events in `ref_marks`. Part of the reference set to be encoded.\n            ref_marks_bwd {torch.LongTensor} -- Tensor containing reverse mark ids that correspond to channel embeddings. Part of the reference set to be encoded.\n            ref_timestamps_bwd {torch.FloatTensor} -- Tensor containing reverse times that correspond to the events in `ref_marks`. Part of the reference set to be encoded.\n            tgt_marks {torch.FloatTensor} -- Tensor containing mark ids that correspond to channel embeddings. These events will be decoded and are assumed to have happened.\n            tgt_timestamps {torch.FloatTensor} -- Tensor containing times that correspond to the events in `tgt_marks`. These times will be decoded and are assumed to have happened.\n            context_lengths {torch.LongTensor} -- Tensor containing position ids that correspond to last events in the reference material.\n\n        Keyword Arguments:\n            sample_timestamps {torch.FloatTensor} -- Times that will have intensity values generated for. These events are _not_ assumed to have happened. (default: {None})\n        \n        Returns:\n            dict -- Dictionary containing the produced latent vector, intermediate hidden states, and intensity values for target sequence and sample points.\n        \"\"\"", "\n", "return_dict", "=", "{", "}", "\n", "\n", "# Encoding phase", "\n", "latent_state_dict", "=", "{", "\n", "\"latent_state\"", ":", "None", ",", "\n", "\"q_z_x\"", ":", "None", ",", "\n", "}", "\n", "latent_state", "=", "latent_state_dict", "[", "\"latent_state\"", "]", "\n", "return_dict", "[", "\"latent_state\"", "]", "=", "latent_state", "\n", "return_dict", "[", "\"q_z_x\"", "]", "=", "latent_state_dict", "[", "\"q_z_x\"", "]", "\n", "return_dict", "[", "\"p_z\"", "]", "=", "None", "\n", "\n", "# Decoding phase", "\n", "intensity_state_dict", "=", "self", ".", "get_states", "(", "\n", "tgt_marks", "=", "tgt_marks", ",", "\n", "tgt_timestamps", "=", "tgt_timestamps", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", ")", "\n", "return_dict", "[", "\"state_dict\"", "]", "=", "intensity_state_dict", "\n", "\n", "tgt_intensities", "=", "self", ".", "get_intensity", "(", "\n", "state_values", "=", "intensity_state_dict", "[", "\"state_values\"", "]", ",", "\n", "state_times", "=", "intensity_state_dict", "[", "\"state_times\"", "]", ",", "\n", "timestamps", "=", "tgt_timestamps", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", "marks", "=", "tgt_marks", ",", "\n", ")", "\n", "return_dict", "[", "\"tgt_intensities\"", "]", "=", "tgt_intensities", "\n", "\n", "# Sample intensities for objective function", "\n", "if", "sample_timestamps", "is", "not", "None", ":", "\n", "\n", "            ", "sample_intensities", "=", "self", ".", "get_intensity", "(", "\n", "state_values", "=", "intensity_state_dict", "[", "\"state_values\"", "]", ",", "\n", "state_times", "=", "intensity_state_dict", "[", "\"state_times\"", "]", ",", "\n", "timestamps", "=", "sample_timestamps", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", "marks", "=", "None", ",", "\n", ")", "\n", "return_dict", "[", "\"sample_intensities\"", "]", "=", "sample_intensities", "\n", "\n", "\n", "", "return", "return_dict", "", "", "", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__": [[52, 91], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "decoder", ",", "\n", "encoder", "=", "None", ",", "\n", "aggregator", "=", "None", ",", "\n", "amortized", "=", "True", ",", "\n", "p_z", "=", "torch", ".", "distributions", ".", "Laplace", ",", "\n", "q_z_x", "=", "torch", ".", "distributions", ".", "Laplace", ",", "\n", "zero_inflated", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Constructor for general PPModel class.\n        \n        Arguments:\n            decoder {torch.nn.Module} -- Neural network decoder that accepts a latent state, marks, timestamps, and times of sample points. \n\n        Keyword Arguments:\n            time_embedding {torch.nn.Module} -- Function to transform k-dimensional timestamps into (k+1)-dimensional embedded vectors. If specified, will make encoder and decoder share this function. (default: {None})\n            encoder {torch.nn.Module} -- Neural network encoder that accepts marks and timestamps and returns a single latent state (default: {None})\n            aggregator {torch.nn.Module} -- Module that turns a tensor of hidden states into a latent vector (with noise added during training) (default: {None})\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "decoder", "=", "decoder", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "aggregator", "=", "aggregator", "\n", "self", ".", "has_encoder", "=", "(", "encoder", "is", "not", "None", ")", "and", "(", "aggregator", "is", "not", "None", ")", "\n", "self", ".", "amortized", "=", "amortized", "\n", "if", "not", "amortized", ":", "\n", "            ", "self", ".", "latent_mu", "=", "nn", ".", "Embedding", "(", "num_embeddings", "=", "100", ",", "embedding_dim", "=", "decoder", ".", "latent_size", ")", "\n", "self", ".", "latent_sigma", "=", "nn", ".", "Embedding", "(", "num_embeddings", "=", "100", ",", "embedding_dim", "=", "decoder", ".", "latent_size", ")", "\n", "\n", "", "if", "decoder", "is", "not", "None", ":", "\n", "            ", "self", ".", "p_z", "=", "p_z", "\n", "self", ".", "q_z_x", "=", "q_z_x", "\n", "self", ".", "_p_z_params", "=", "nn", ".", "ParameterList", "(", "[", "\n", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ",", "decoder", ".", "latent_size", ")", ",", "requires_grad", "=", "False", ")", ",", "# mu", "\n", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ",", "decoder", ".", "latent_size", ")", ",", "requires_grad", "=", "False", ")", "# logvar", "\n", "]", ")", "\n", "", "self", ".", "zero_inflated", "=", "zero_inflated", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_prior_params": [[92, 94], ["torch.softmax", "torch.softmax", "torch.softmax", "model.PPModel._p_z_params[].size"], "methods", ["None"], ["", "def", "get_prior_params", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_p_z_params", "[", "0", "]", ",", "F", ".", "softmax", "(", "self", ".", "_p_z_params", "[", "1", "]", ",", "dim", "=", "-", "1", ")", "*", "self", ".", "_p_z_params", "[", "1", "]", ".", "size", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_states": [[95, 107], ["model.PPModel.decoder.get_states"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_states"], ["", "def", "get_states", "(", "self", ",", "tgt_marks", ",", "tgt_timestamps", ",", "latent_state", ")", ":", "\n", "        ", "\"\"\"Get the hidden states that can be used to extract intensity values from.\"\"\"", "\n", "\n", "states", "=", "self", ".", "decoder", ".", "get_states", "(", "\n", "marks", "=", "tgt_marks", ",", "\n", "timestamps", "=", "tgt_timestamps", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", ")", "\n", "\n", "return", "{", "\n", "\"state_values\"", ":", "states", ",", "\n", "\"state_times\"", ":", "tgt_timestamps", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_intensity": [[109, 124], ["model.PPModel.decoder.get_intensity", "intensity_dict[].gather().squeeze", "intensity_dict[].gather", "marks.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_intensity"], ["", "def", "get_intensity", "(", "self", ",", "state_values", ",", "state_times", ",", "timestamps", ",", "latent_state", ",", "marks", "=", "None", ")", ":", "\n", "        ", "\"\"\"Given a set of hidden states, timestamps, and latent_state get a tensor representing intensity values at timestamps.\n        Specify marks to get intensity values for specific channels.\"\"\"", "\n", "\n", "intensity_dict", "=", "self", ".", "decoder", ".", "get_intensity", "(", "\n", "state_values", "=", "state_values", ",", "\n", "state_times", "=", "state_times", ",", "\n", "timestamps", "=", "timestamps", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", ")", "\n", "\n", "if", "marks", "is", "not", "None", ":", "\n", "            ", "intensity_dict", "[", "\"log_mark_intensity\"", "]", "=", "intensity_dict", "[", "\"all_log_mark_intensities\"", "]", ".", "gather", "(", "dim", "=", "-", "1", ",", "index", "=", "marks", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "", "return", "intensity_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_latent": [[125, 150], ["model.PPModel.encoder", "model.PPModel.aggregator", "model.PPModel.latent_mu", "model.PPModel.latent_sigma", "mu.squeeze", "sigma.squeeze", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like"], "methods", ["None"], ["", "def", "get_latent", "(", "self", ",", "ref_marks_fwd", ",", "ref_timestamps_fwd", ",", "ref_marks_bwd", ",", "ref_timestamps_bwd", ",", "context_lengths", ",", "pp_id", ")", ":", "\n", "        ", "\"\"\"Computes latent variable for a given set of reference marks and timestamped events.\"\"\"", "\n", "if", "self", ".", "amortized", ":", "\n", "            ", "hidden_states", "=", "self", ".", "encoder", "(", "\n", "forward_marks", "=", "ref_marks_fwd", ",", "\n", "forward_timestamps", "=", "ref_timestamps_fwd", ",", "\n", "backward_marks", "=", "ref_marks_bwd", ",", "\n", "backward_timestamps", "=", "ref_timestamps_bwd", ",", "\n", ")", "\n", "\n", "return", "self", ".", "aggregator", "(", "hidden_states", ",", "context_lengths", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "mu", ",", "sigma", "=", "self", ".", "latent_mu", "(", "pp_id", ")", ",", "self", ".", "latent_sigma", "(", "pp_id", ")", "\n", "mu", ",", "sigma", "=", "mu", ".", "squeeze", "(", "dim", "=", "1", ")", ",", "sigma", ".", "squeeze", "(", "dim", "=", "1", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "                ", "latent_state", "=", "torch", ".", "randn_like", "(", "mu", ")", "*", "sigma", "+", "mu", "\n", "", "else", ":", "\n", "                ", "latent_state", "=", "mu", "\n", "\n", "", "return", "{", "\n", "\"latent_state\"", ":", "latent_state", ",", "\n", "\"mu\"", ":", "mu", ",", "\n", "\"sigma\"", ":", "sigma", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.forward": [[152, 223], ["model.PPModel.p_z", "model.PPModel.get_states", "model.PPModel.get_intensity", "model.PPModel.get_latent", "model.PPModel.get_intensity", "model.PPModel.get_prior_params"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_states", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_intensity", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_latent", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_intensity", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_prior_params"], ["", "", "def", "forward", "(", "self", ",", "ref_marks", ",", "ref_timestamps", ",", "ref_marks_bwd", ",", "ref_timestamps_bwd", ",", "tgt_marks", ",", "tgt_timestamps", ",", "context_lengths", ",", "sample_timestamps", "=", "None", ",", "pp_id", "=", "None", ")", ":", "\n", "        ", "\"\"\"Encodes a(n optional) set of marks and timestamps into a latent vector, \n        then decodes corresponding intensity values for a target set of timestamps and marks \n        (as well as a sample set if specified).\n        \n        Arguments:\n            ref_marks {torch.LongTensor} -- Tensor containing mark ids that correspond to channel embeddings. Part of the reference set to be encoded.\n            ref_timestamps {torch.FloatTensor} -- Tensor containing times that correspond to the events in `ref_marks`. Part of the reference set to be encoded.\n            ref_marks_bwd {torch.LongTensor} -- Tensor containing reverse mark ids that correspond to channel embeddings. Part of the reference set to be encoded.\n            ref_timestamps_bwd {torch.FloatTensor} -- Tensor containing reverse times that correspond to the events in `ref_marks`. Part of the reference set to be encoded.\n            tgt_marks {torch.FloatTensor} -- Tensor containing mark ids that correspond to channel embeddings. These events will be decoded and are assumed to have happened.\n            tgt_timestamps {torch.FloatTensor} -- Tensor containing times that correspond to the events in `tgt_marks`. These times will be decoded and are assumed to have happened.\n            context_lengths {torch.LongTensor} -- Tensor containing position ids that correspond to last events in the reference material.\n\n        Keyword Arguments:\n            sample_timestamps {torch.FloatTensor} -- Times that will have intensity values generated for. These events are _not_ assumed to have happened. (default: {None})\n        \n        Returns:\n            dict -- Dictionary containing the produced latent vector, intermediate hidden states, and intensity values for target sequence and sample points.\n        \"\"\"", "\n", "return_dict", "=", "{", "}", "\n", "\n", "# Encoding phase", "\n", "if", "self", ".", "has_encoder", ":", "\n", "            ", "latent_state_dict", "=", "self", ".", "get_latent", "(", "\n", "ref_marks_fwd", "=", "ref_marks", ",", "\n", "ref_timestamps_fwd", "=", "ref_timestamps", ",", "\n", "ref_marks_bwd", "=", "ref_marks_bwd", ",", "\n", "ref_timestamps_bwd", "=", "ref_timestamps_bwd", ",", "\n", "context_lengths", "=", "context_lengths", ",", "\n", "pp_id", "=", "pp_id", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "latent_state_dict", "=", "{", "\n", "\"latent_state\"", ":", "None", ",", "\n", "\"q_z_x\"", ":", "None", ",", "\n", "}", "\n", "", "latent_state", "=", "latent_state_dict", "[", "\"latent_state\"", "]", "\n", "return_dict", "[", "\"latent_state\"", "]", "=", "latent_state", "\n", "return_dict", "[", "\"q_z_x\"", "]", "=", "latent_state_dict", "[", "\"q_z_x\"", "]", "\n", "return_dict", "[", "\"p_z\"", "]", "=", "self", ".", "p_z", "(", "*", "self", ".", "get_prior_params", "(", ")", ")", "\n", "\n", "# Decoding phase", "\n", "intensity_state_dict", "=", "self", ".", "get_states", "(", "\n", "tgt_marks", "=", "tgt_marks", ",", "\n", "tgt_timestamps", "=", "tgt_timestamps", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", ")", "\n", "return_dict", "[", "\"state_dict\"", "]", "=", "intensity_state_dict", "\n", "\n", "tgt_intensities", "=", "self", ".", "get_intensity", "(", "\n", "state_values", "=", "intensity_state_dict", "[", "\"state_values\"", "]", ",", "\n", "state_times", "=", "intensity_state_dict", "[", "\"state_times\"", "]", ",", "\n", "timestamps", "=", "tgt_timestamps", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", "marks", "=", "tgt_marks", ",", "\n", ")", "\n", "return_dict", "[", "\"tgt_intensities\"", "]", "=", "tgt_intensities", "\n", "\n", "# Sample intensities for objective function", "\n", "if", "sample_timestamps", "is", "not", "None", ":", "\n", "            ", "sample_intensities", "=", "self", ".", "get_intensity", "(", "\n", "state_values", "=", "intensity_state_dict", "[", "\"state_values\"", "]", ",", "\n", "state_times", "=", "intensity_state_dict", "[", "\"state_times\"", "]", ",", "\n", "timestamps", "=", "sample_timestamps", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", "marks", "=", "None", ",", "\n", ")", "\n", "return_dict", "[", "\"sample_intensities\"", "]", "=", "sample_intensities", "\n", "\n", "", "return", "return_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.log_likelihood": [[224, 270], ["all", "len", "window.squeeze.squeeze.squeeze", "torch.where().sum", "torch.where().sum", "torch.where().sum", "torch.where().sum", "torch.where().sum", "torch.where().sum", "torch.where().sum", "torch.where().sum", "torch.where().sum", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "[].mean", "torch.where.mean", "torch.where.mean", "torch.where.mean", "negative_samples.mean", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where.sum", "torch.where.sum", "torch.where.sum", "zip", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "[].log", "negative_samples.mean"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "log_likelihood", "(", "return_dict", ",", "right_window", ",", "left_window", "=", "0.0", ",", "mask", "=", "None", ",", "reduce", "=", "True", ")", ":", "\n", "        ", "\"\"\"Computes per-batch log-likelihood from the results of a forward pass (that included a set of sample points). \n        \n        Arguments:\n            return_dict {dict} -- Output from a forward call where `tgt_marks` and `sample_timestamps` were not None\n            right_window {float} -- Upper-most value that was considered when the sampled points were generated\n\n        Keyword Arguments:\n            left_window {float} -- Lower-most value that was considered when the sampled points were generated (default: {0})\n            mask {FloatTensor} -- Mask to delineate target intensities that correspond to real events and paddings (default: {None}) \n        \"\"\"", "\n", "\n", "assert", "(", "\"tgt_intensities\"", "in", "return_dict", "and", "\"log_mark_intensity\"", "in", "return_dict", "[", "\"tgt_intensities\"", "]", ")", "\n", "assert", "(", "\"sample_intensities\"", "in", "return_dict", ")", "\n", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "1", "\n", "", "else", ":", "\n", "            ", "assert", "(", "all", "(", "x", "==", "y", "for", "x", ",", "y", "in", "zip", "(", "return_dict", "[", "\"tgt_intensities\"", "]", "[", "\"log_mark_intensity\"", "]", ".", "shape", ",", "mask", ".", "shape", ")", ")", ")", "# make sure they are same size", "\n", "\n", "", "log_mark_intensity", "=", "return_dict", "[", "\"tgt_intensities\"", "]", "[", "\"log_mark_intensity\"", "]", "\n", "window", "=", "right_window", "-", "left_window", "\n", "if", "len", "(", "window", ".", "shape", ")", ">", "1", ":", "\n", "            ", "window", "=", "window", ".", "squeeze", "(", "-", "1", ")", "\n", "", "if", "reduce", ":", "\n", "            ", "positive_samples", "=", "torch", ".", "where", "(", "mask", ",", "log_mark_intensity", ",", "torch", ".", "zeros_like", "(", "log_mark_intensity", ")", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "#negative_samples = (right_window - left_window) * return_dict[\"sample_intensities\"][\"total_intensity\"].mean(dim=-1)  # Summing and divided by number of samples", "\n", "negative_samples", "=", "window", "*", "return_dict", "[", "\"sample_intensities\"", "]", "[", "\"total_intensity\"", "]", ".", "mean", "(", "dim", "=", "-", "1", ")", "# Summing and divided by number of samples", "\n", "\n", "ll_results", "=", "{", "\n", "\"log_likelihood\"", ":", "(", "(", "1.0", "*", "positive_samples", ")", "-", "negative_samples", ")", ".", "mean", "(", ")", ",", "\n", "\"positive_contribution\"", ":", "positive_samples", ".", "mean", "(", ")", ",", "\n", "\"negative_contribution\"", ":", "negative_samples", ".", "mean", "(", ")", ",", "\n", "}", "\n", "ll_results", "[", "\"augmented_log_likelihood\"", "]", "=", "ll_results", "[", "\"log_likelihood\"", "]", "\n", "return", "ll_results", "\n", "", "else", ":", "\n", "            ", "positive_samples", "=", "torch", ".", "where", "(", "mask", ",", "log_mark_intensity", ",", "torch", ".", "zeros_like", "(", "log_mark_intensity", ")", ")", "\n", "negative_samples", "=", "return_dict", "[", "\"sample_intensities\"", "]", "[", "\"total_intensity\"", "]", "# Summing and divided by number of samples", "\n", "\n", "return", "{", "\n", "\"positive_contribution\"", ":", "positive_samples", ",", "\n", "\"negative_contribution\"", ":", "negative_samples", ",", "\n", "\"cross_entropy\"", ":", "-", "(", "positive_samples", "-", "return_dict", "[", "\"tgt_intensities\"", "]", "[", "\"total_intensity\"", "]", ".", "log", "(", ")", ")", ",", "\n", "\"batch_log_likelihood\"", ":", "positive_samples", ".", "sum", "(", "dim", "=", "-", "1", ")", "-", "(", "window", "*", "negative_samples", ".", "mean", "(", "dim", "=", "-", "1", ")", ")", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.augmented_log_likelihood": [[272, 303], ["model.PPModel.log_likelihood", "model.PPModel.log_likelihood", "torch.where().log", "torch.where().log", "torch.where().log", "torch.where().log", "torch.where().log", "torch.where().log", "torch.where().log", "torch.where().log", "torch.where().log", "torch.where().log.mean().sum", "torch.where().log.mean().sum", "torch.where().log.mean().sum", "model.PPModel.log_likelihood", "[].clamp().log().unsqueeze", "selected_negative_marks.mean", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where().log.mean", "torch.where().log.mean", "torch.where().log.mean", "torch.where().log.mean().sum.mean", "[].clamp().log", "[].clamp", "log_mark_prob.exp"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.log_likelihood", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.log_likelihood", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.log_likelihood"], ["", "", "def", "augmented_log_likelihood", "(", "\n", "self", ",", "\n", "return_dict", ",", "\n", "right_window", ",", "\n", "augment_mask", ",", "\n", "augment_coef", ",", "\n", "left_window", "=", "0.0", ",", "\n", "mask", "=", "None", ",", "\n", "reduce", "=", "True", ",", "\n", ")", ":", "\n", "        ", "if", "not", "reduce", ":", "\n", "            ", "return", "self", ".", "log_likelihood", "(", "return_dict", ",", "right_window", ",", "left_window", ",", "mask", ",", "reduce", ")", "\n", "", "if", "self", ".", "zero_inflated", ":", "\n", "            ", "ll_results", "=", "self", ".", "log_likelihood", "(", "return_dict", ",", "right_window", ",", "left_window", ",", "mask", ",", "reduce", "=", "True", ")", "\n", "zero_probs", "=", "return_dict", "[", "\"tgt_intensities\"", "]", "[", "\"zero_probs\"", "]", "\n", "log_likelihood_bernoulli", "=", "torch", ".", "where", "(", "augment_mask", ">", "0", ",", "zero_probs", ",", "1", "-", "zero_probs", ")", ".", "log", "(", ")", "# [batch, sequence, marks]", "\n", "reduced_ll_bern", "=", "log_likelihood_bernoulli", ".", "mean", "(", "dim", "=", "-", "1", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "# averaged over marks, summed across sequence", "\n", "\n", "ll_results", "[", "\"augmented_log_likelihood\"", "]", "=", "ll_results", "[", "\"log_likelihood\"", "]", "+", "augment_coef", "*", "reduced_ll_bern", ".", "mean", "(", ")", "# averaged over batch", "\n", "", "else", ":", "\n", "            ", "ll_results", "=", "self", ".", "log_likelihood", "(", "return_dict", ",", "right_window", ",", "left_window", ",", "mask", ",", "reduce", "=", "True", ")", "\n", "log_mark_intensity", "=", "return_dict", "[", "\"tgt_intensities\"", "]", "[", "\"all_log_mark_intensities\"", "]", "# [\"log_mark_intensity\"]", "\n", "log_total_intensity", "=", "return_dict", "[", "\"tgt_intensities\"", "]", "[", "\"total_intensity\"", "]", ".", "clamp", "(", "0.001", ",", "None", ")", ".", "log", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "log_mark_prob", "=", "log_mark_intensity", "-", "log_total_intensity", "\n", "log_mark_comp_prob", "=", "(", "1", "-", "log_mark_prob", ".", "exp", "(", ")", ")", ".", "clamp", "(", "0.001", ",", "1.0", ")", ".", "log", "(", ")", "\n", "selected_negative_marks", "=", "(", "augment_coef", "*", "augment_mask", "*", "log_mark_comp_prob", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "#ll_results[\"augmented_log_likelihood\"] = ll_results[\"log_likelihood\"] - selected_negative_marks.mean()", "\n", "ll_results", "[", "\"augmented_log_likelihood\"", "]", "=", "ll_results", "[", "\"log_likelihood\"", "]", "+", "selected_negative_marks", ".", "mean", "(", ")", "\n", "\n", "", "return", "ll_results", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.sample_points": [[304, 361], ["model.PPModel.forward", "torch.distributions.Exponential", "torch.distributions.Exponential", "torch.distributions.Exponential", "torch.distributions.Exponential", "torch.distributions.Exponential", "torch.distributions.Exponential", "torch.distributions.Exponential", "torch.distributions.Exponential", "torch.distributions.Exponential", "range", "torch.distributions.Exponential.sample().to", "torch.distributions.Exponential.sample().to", "torch.distributions.Exponential.sample().to", "model.PPModel.get_intensity", "model.PPModel.get_intensity", "print", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.softmax", "torch.softmax", "torch.softmax", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical.sample", "torch.distributions.Categorical.sample", "torch.distributions.Categorical.sample", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "sampled_times.append", "sampled_marks.append", "model.PPModel.forward", "torch.distributions.Exponential.sample().to", "torch.distributions.Exponential.sample().to", "torch.distributions.Exponential.sample().to", "torch.rand_like().clamp", "torch.rand_like().clamp", "torch.rand_like().clamp", "torch.rand_like().clamp", "torch.rand_like().clamp", "torch.rand_like().clamp", "torch.rand_like().clamp", "torch.rand_like().clamp", "torch.rand_like().clamp", "print", "print", "torch.distributions.Exponential.sample", "torch.distributions.Exponential.sample", "torch.distributions.Exponential.sample", "model.top_k_top_p_filtering", "new_time.squeeze().item", "torch.distributions.Categorical.sample.squeeze().item", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.distributions.Exponential.sample", "torch.distributions.Exponential.sample", "torch.distributions.Exponential.sample", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "sample_intensities[].max().item", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "new_time.squeeze", "torch.distributions.Categorical.sample.squeeze", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "sample_intensities[].max"], "methods", ["home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.forward", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_intensity", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_intensity", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.forward", "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.top_k_top_p_filtering"], ["", "def", "sample_points", "(", "self", ",", "ref_marks", ",", "ref_timestamps", ",", "ref_marks_bwd", ",", "ref_timestamps_bwd", ",", "tgt_marks", ",", "tgt_timestamps", ",", "context_lengths", ",", "dominating_rate", ",", "T", ",", "left_window", ",", "top_k", "=", "0", ",", "top_p", "=", "0.0", ")", ":", "\n", "        ", "state", "=", "self", ".", "forward", "(", "ref_marks", ",", "ref_timestamps", ",", "ref_marks_bwd", ",", "ref_timestamps_bwd", ",", "tgt_marks", ",", "tgt_timestamps", ",", "context_lengths", ")", "\n", "state_values", ",", "state_times", ",", "latent_state", "=", "state", "[", "\"state_dict\"", "]", "[", "\"state_values\"", "]", ",", "state", "[", "\"state_dict\"", "]", "[", "\"state_times\"", "]", ",", "state", "[", "\"latent_state\"", "]", "\n", "\n", "dist", "=", "torch", ".", "distributions", ".", "Exponential", "(", "dominating_rate", ")", "\n", "last_time", "=", "left_window", "\n", "new_time", "=", "last_time", "+", "dist", ".", "sample", "(", "sample_shape", "=", "torch", ".", "Size", "(", "(", "1", ",", "1", ")", ")", ")", ".", "to", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "sampled_times", "=", "[", "]", "\n", "sampled_marks", "=", "[", "]", "\n", "while", "new_time", "<", "T", ":", "\n", "            ", "sample_intensities", "=", "self", ".", "get_intensity", "(", "\n", "state_values", "=", "state_values", ",", "\n", "state_times", "=", "state_times", ",", "\n", "timestamps", "=", "new_time", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", "marks", "=", "None", ",", "\n", ")", "\n", "\n", "if", "torch", ".", "rand_like", "(", "new_time", ")", "<=", "(", "sample_intensities", "[", "\"total_intensity\"", "]", "/", "(", "dominating_rate", ")", ")", ":", "\n", "                ", "if", "top_k", ">", "0", "or", "top_p", ">", "0", ":", "\n", "                    ", "logits", "=", "top_k_top_p_filtering", "(", "sample_intensities", "[", "\"all_log_mark_intensities\"", "]", ",", "top_k", "=", "top_k", ",", "top_p", "=", "top_p", ")", "\n", "", "else", ":", "\n", "                    ", "logits", "=", "sample_intensities", "[", "\"all_log_mark_intensities\"", "]", "\n", "", "mark_probs", "=", "F", ".", "softmax", "(", "logits", ",", "-", "1", ")", "#(sample_intensities[\"all_log_mark_intensities\"] - sample_intensities[\"total_intensity\"].unsqueeze(-1).log()).exp()", "\n", "mark_dist", "=", "torch", ".", "distributions", ".", "Categorical", "(", "mark_probs", ")", "\n", "new_mark", "=", "mark_dist", ".", "sample", "(", ")", "\n", "tgt_timestamps", "=", "torch", ".", "cat", "(", "(", "tgt_timestamps", ",", "new_time", ")", ",", "-", "1", ")", "\n", "tgt_marks", "=", "torch", ".", "cat", "(", "(", "tgt_marks", ",", "new_mark", ")", ",", "-", "1", ")", "\n", "sampled_times", ".", "append", "(", "new_time", ".", "squeeze", "(", ")", ".", "item", "(", ")", ")", "\n", "sampled_marks", ".", "append", "(", "new_mark", ".", "squeeze", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "state", "=", "self", ".", "forward", "(", "ref_marks", ",", "ref_timestamps", ",", "ref_marks_bwd", ",", "ref_timestamps_bwd", ",", "tgt_marks", ",", "tgt_timestamps", ",", "context_lengths", ")", "\n", "state_values", ",", "state_times", ",", "latent_state", "=", "state", "[", "\"state_dict\"", "]", "[", "\"state_values\"", "]", ",", "state", "[", "\"state_dict\"", "]", "[", "\"state_times\"", "]", ",", "state", "[", "\"latent_state\"", "]", "\n", "\n", "", "new_time", "=", "new_time", "+", "dist", ".", "sample", "(", "sample_shape", "=", "torch", ".", "Size", "(", "(", "1", ",", "1", ")", ")", ")", ".", "to", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "\n", "", "assumption_violation", "=", "False", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "            ", "eval_times", "=", "torch", ".", "rand_like", "(", "tgt_timestamps", ")", ".", "clamp", "(", "min", "=", "1e-8", ")", "*", "T", "\n", "sample_intensities", "=", "self", ".", "get_intensity", "(", "\n", "state_values", "=", "state_values", ",", "\n", "state_times", "=", "state_times", ",", "\n", "timestamps", "=", "eval_times", ",", "\n", "latent_state", "=", "latent_state", ",", "\n", "marks", "=", "None", ",", "\n", ")", "\n", "if", "(", "sample_intensities", "[", "\"total_intensity\"", "]", ">", "dominating_rate", ")", ".", "any", "(", ")", ".", "item", "(", ")", ":", "\n", "                ", "print", "(", "\"DR: {}\"", ".", "format", "(", "dominating_rate", ")", ")", "\n", "print", "(", "\"IN: {}\"", ".", "format", "(", "sample_intensities", "[", "\"total_intensity\"", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", ")", "\n", "assumption_violation", "=", "True", "\n", "break", "\n", "\n", "", "", "if", "assumption_violation", ":", "\n", "            ", "print", "(", "\"Violation in sampling assumption occurred. Redoing sample.\"", ")", "\n", "return", "None", "# self.sample_points(ref_marks, ref_timestamps, ref_marks_bwd, ref_timestamps_bwd, tgt_marks, tgt_timestamps, context_lengths, dominating_rate * 2, T)", "\n", "", "else", ":", "\n", "            ", "return", "sampled_times", ",", "sampled_marks", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.PPModel.get_param_groups": [[362, 389], ["model.PPModel.modules", "isinstance", "no_weight_decay_params[].extend", "weight_decay_params[].extend", "no_weight_decay_params[].extend", "module_._parameters.values", "module_._parameters.items", "module_._parameters.items"], "methods", ["None"], ["", "", "def", "get_param_groups", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns iterable of dictionaries specifying parameter groups.\n        The first dictionary in the return value contains parameters that will be subject to weight decay.\n        The second dictionary in the return value contains parameters that will not be subject to weight decay.\n        \n        Returns:\n            (param_group, param_groups) -- Tuple containing sets of parameters, one of which has weight decay enabled, one of which has it disabled.\n        \"\"\"", "\n", "\n", "weight_decay_params", "=", "{", "'params'", ":", "[", "]", "}", "\n", "no_weight_decay_params", "=", "{", "'params'", ":", "[", "]", ",", "'weight_decay'", ":", "0.0", "}", "\n", "for", "module_", "in", "self", ".", "modules", "(", ")", ":", "\n", "# Doesn't make sense to decay weights for a LayerNorm, BatchNorm, etc.", "\n", "            ", "if", "isinstance", "(", "module_", ",", "NORMS", ")", ":", "\n", "                ", "no_weight_decay_params", "[", "'params'", "]", ".", "extend", "(", "[", "\n", "p", "for", "p", "in", "module_", ".", "_parameters", ".", "values", "(", ")", "if", "p", "is", "not", "None", "\n", "]", ")", "\n", "", "else", ":", "\n", "# Also doesn't make sense to decay biases.", "\n", "                ", "weight_decay_params", "[", "'params'", "]", ".", "extend", "(", "[", "\n", "p", "for", "n", ",", "p", "in", "module_", ".", "_parameters", ".", "items", "(", ")", "if", "p", "is", "not", "None", "and", "n", "!=", "'bias'", "\n", "]", ")", "\n", "no_weight_decay_params", "[", "'params'", "]", ".", "extend", "(", "[", "\n", "p", "for", "n", ",", "p", "in", "module_", ".", "_parameters", ".", "items", "(", ")", "if", "p", "is", "not", "None", "and", "n", "==", "'bias'", "\n", "]", ")", "\n", "\n", "", "", "return", "weight_decay_params", ",", "no_weight_decay_params", "", "", "", ""]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.model.top_k_top_p_filtering": [[17, 48], ["logits.squeeze.squeeze", "min", "logits.squeeze.unsqueeze().unsqueeze", "float", "logits.squeeze.dim", "logits.squeeze.size", "torch.sort", "torch.sort", "torch.sort", "torch.cumsum", "torch.cumsum", "torch.cumsum", "sorted_indices_to_remove[].clone", "torch.softmax", "logits.squeeze.unsqueeze", "torch.topk", "torch.topk", "torch.topk"], "function", ["None"], ["def", "top_k_top_p_filtering", "(", "logits", ",", "top_k", "=", "0", ",", "top_p", "=", "0.0", ",", "filter_value", "=", "-", "float", "(", "'Inf'", ")", ")", ":", "\n", "    ", "\"\"\" Filter a distribution of logits using top-k and/or nucleus (top-p) filtering\n        Adapted from https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317\n\n        Args:\n            logits: logits distribution shape (vocabulary size)\n            top_k >0: keep only top k tokens with highest probability (top-k filtering).\n            top_p >0.0: keep the top tokens with cumulative probability >= top_p (nucleus filtering).\n                Nucleus filtering is described in Holtzman et al. (http://arxiv.org/abs/1904.09751)\n    \"\"\"", "\n", "logits", "=", "logits", ".", "squeeze", "(", ")", "\n", "assert", "logits", ".", "dim", "(", ")", "==", "1", "# batch size 1 for now - could be updated for more but the code would be less clear", "\n", "top_k", "=", "min", "(", "top_k", ",", "logits", ".", "size", "(", "-", "1", ")", ")", "# Safety check", "\n", "if", "top_k", ">", "0", ":", "\n", "# Remove all tokens with a probability less than the last token of the top-k", "\n", "        ", "indices_to_remove", "=", "logits", "<", "torch", ".", "topk", "(", "logits", ",", "top_k", ")", "[", "0", "]", "[", "...", ",", "-", "1", ",", "None", "]", "\n", "logits", "[", "indices_to_remove", "]", "=", "filter_value", "\n", "\n", "", "if", "top_p", ">", "0.0", ":", "\n", "        ", "sorted_logits", ",", "sorted_indices", "=", "torch", ".", "sort", "(", "logits", ",", "descending", "=", "True", ")", "\n", "cumulative_probs", "=", "torch", ".", "cumsum", "(", "F", ".", "softmax", "(", "sorted_logits", ",", "dim", "=", "-", "1", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Remove tokens with cumulative probability above the threshold", "\n", "sorted_indices_to_remove", "=", "cumulative_probs", ">", "top_p", "\n", "# Shift the indices to the right to keep also the first token above the threshold", "\n", "sorted_indices_to_remove", "[", "...", ",", "1", ":", "]", "=", "sorted_indices_to_remove", "[", "...", ",", ":", "-", "1", "]", ".", "clone", "(", ")", "\n", "sorted_indices_to_remove", "[", "...", ",", "0", "]", "=", "0", "\n", "\n", "indices_to_remove", "=", "sorted_indices", "[", "sorted_indices_to_remove", "]", "\n", "logits", "[", "indices_to_remove", "]", "=", "filter_value", "\n", "", "return", "logits", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ajboyd2_vae_mpp.models.__init__.get_model": [[7, 140], ["vae_mpp.modules.TemporalEmbedding", "torch.nn.Embedding", "vae_mpp.models.model.PPModel", "vae_mpp.models.hawkes.HawkesModel", "vae_mpp.modules.PPEncoder", "vae_mpp.modules.PPAggregator", "vae_mpp.modules.HawkesDecoder", "vae_mpp.modules.RMTPPDecoder", "vae_mpp.modules.PPDecoder", "vae_mpp.modules.TemporalEmbedding", "vae_mpp.modules.TemporalEmbedding"], "function", ["None"], []]}